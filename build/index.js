(function () {
  var v = process.version
  var parts = v.slice(1).split('.')
  var major = parseInt(parts[0], 10)
  var minor = parseInt(parts[1], 10)
  if (major < 10 || (major == 10 && minor < 12)) {
    throw new Error('coc.nvim requires node >= v10.12.0, current version: ' + v)
  }
})(); 
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(this, args.concat(slice.call(arguments)));
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(that, args.concat(slice.call(arguments)));
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    module2.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/object-keys/implementation.js"(exports2, module2) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name2 in object) {
            if (!(skipProto && name2 === "prototype") && has.call(object, name2)) {
              theKeys.push(String(name2));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module2.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports2, module2) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation2();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module2.exports = keysShim;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports2, module2) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var arePropertyDescriptorsSupported = function() {
      var obj = {};
      try {
        origDefineProperty(obj, "x", { enumerable: false, value: obj });
        for (var _ in obj) {
          return false;
        }
        return obj.x === obj;
      } catch (e) {
        return false;
      }
    };
    var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();
    var defineProperty = function(object, name2, value, predicate) {
      if (name2 in object && (!isFunction(predicate) || !predicate())) {
        return;
      }
      if (supportsDescriptors) {
        origDefineProperty(object, name2, {
          configurable: true,
          enumerable: false,
          value,
          writable: true
        });
      } else {
        object[name2] = value;
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module2.exports = defineProperties;
  }
});

// node_modules/promise.prototype.finally/requirePromise.js
var require_requirePromise = __commonJS({
  "node_modules/promise.prototype.finally/requirePromise.js"(exports2, module2) {
    "use strict";
    module2.exports = function requirePromise() {
      if (typeof Promise !== "function") {
        throw new TypeError("`Promise.prototype.finally` requires a global `Promise` be available.");
      }
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports2, module2) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
    module2.exports = function isCallable(value) {
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (typeof value === "function" && !value.prototype) {
        return true;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      return strClass === fnClass || strClass === genClass;
    };
  }
});

// node_modules/promise.prototype.finally/node_modules/es-abstract/2018/IsCallable.js
var require_IsCallable = __commonJS({
  "node_modules/promise.prototype.finally/node_modules/es-abstract/2018/IsCallable.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_callable();
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = global.Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/promise.prototype.finally/node_modules/es-abstract/GetIntrinsic.js
var require_GetIntrinsic = __commonJS({
  "node_modules/promise.prototype.finally/node_modules/es-abstract/GetIntrinsic.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $TypeError = TypeError;
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var generator;
    var generatorFunction = generator ? getProto(generator) : undefined2;
    var asyncFn;
    var asyncFunction = asyncFn ? asyncFn.constructor : undefined2;
    var asyncGen;
    var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined2;
    var asyncGenIterator = asyncGen ? asyncGen() : undefined2;
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer.prototype,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%ArrayPrototype%": Array.prototype,
      "%ArrayProto_entries%": Array.prototype.entries,
      "%ArrayProto_forEach%": Array.prototype.forEach,
      "%ArrayProto_keys%": Array.prototype.keys,
      "%ArrayProto_values%": Array.prototype.values,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": asyncFunction,
      "%AsyncFunctionPrototype%": asyncFunction ? asyncFunction.prototype : undefined2,
      "%AsyncGenerator%": asyncGen ? getProto(asyncGenIterator) : undefined2,
      "%AsyncGeneratorFunction%": asyncGenFunction,
      "%AsyncGeneratorPrototype%": asyncGenFunction ? asyncGenFunction.prototype : undefined2,
      "%AsyncIteratorPrototype%": asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined2,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%Boolean%": Boolean,
      "%BooleanPrototype%": Boolean.prototype,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%DataViewPrototype%": typeof DataView === "undefined" ? undefined2 : DataView.prototype,
      "%Date%": Date,
      "%DatePrototype%": Date.prototype,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%ErrorPrototype%": Error.prototype,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%EvalErrorPrototype%": EvalError.prototype,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined2 : Float32Array.prototype,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined2 : Float64Array.prototype,
      "%Function%": Function,
      "%FunctionPrototype%": Function.prototype,
      "%Generator%": generator ? getProto(generator()) : undefined2,
      "%GeneratorFunction%": generatorFunction,
      "%GeneratorPrototype%": generatorFunction ? generatorFunction.prototype : undefined2,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined2 : Int8Array.prototype,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined2 : Int8Array.prototype,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined2 : Int32Array.prototype,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto(new Map()[Symbol.iterator]()),
      "%MapPrototype%": typeof Map === "undefined" ? undefined2 : Map.prototype,
      "%Math%": Math,
      "%Number%": Number,
      "%NumberPrototype%": Number.prototype,
      "%Object%": Object,
      "%ObjectPrototype%": Object.prototype,
      "%ObjProto_toString%": Object.prototype.toString,
      "%ObjProto_valueOf%": Object.prototype.valueOf,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%PromisePrototype%": typeof Promise === "undefined" ? undefined2 : Promise.prototype,
      "%PromiseProto_then%": typeof Promise === "undefined" ? undefined2 : Promise.prototype.then,
      "%Promise_all%": typeof Promise === "undefined" ? undefined2 : Promise.all,
      "%Promise_reject%": typeof Promise === "undefined" ? undefined2 : Promise.reject,
      "%Promise_resolve%": typeof Promise === "undefined" ? undefined2 : Promise.resolve,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%RangeErrorPrototype%": RangeError.prototype,
      "%ReferenceError%": ReferenceError,
      "%ReferenceErrorPrototype%": ReferenceError.prototype,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%RegExpPrototype%": RegExp.prototype,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto(new Set()[Symbol.iterator]()),
      "%SetPrototype%": typeof Set === "undefined" ? undefined2 : Set.prototype,
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer.prototype,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%StringPrototype%": String.prototype,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SymbolPrototype%": hasSymbols ? Symbol.prototype : undefined2,
      "%SyntaxError%": SyntaxError,
      "%SyntaxErrorPrototype%": SyntaxError.prototype,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypedArrayPrototype%": TypedArray ? TypedArray.prototype : undefined2,
      "%TypeError%": $TypeError,
      "%TypeErrorPrototype%": $TypeError.prototype,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array.prototype,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray.prototype,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array.prototype,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array.prototype,
      "%URIError%": URIError,
      "%URIErrorPrototype%": URIError.prototype,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined2 : WeakMap.prototype,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined2 : WeakSet.prototype
    };
    var bind = require_function_bind();
    var $replace = bind.call(Function.call, String.prototype.replace);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string2) {
      var result = [];
      $replace(string2, rePropName, function(match, number2, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      if (!(name2 in INTRINSICS)) {
        throw new SyntaxError("intrinsic " + name2 + " does not exist!");
      }
      if (typeof INTRINSICS[name2] === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
      }
      return INTRINSICS[name2];
    };
    module2.exports = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath(name2);
      var value = getBaseIntrinsic("%" + (parts.length > 0 ? parts[0] : "") + "%", allowMissing);
      for (var i = 1; i < parts.length; i += 1) {
        if (value != null) {
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, parts[i]);
            if (!allowMissing && !(parts[i] in value)) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            value = desc ? desc.get || desc.value : value[parts[i]];
          } else {
            value = value[parts[i]];
          }
        }
      }
      return value;
    };
  }
});

// node_modules/promise.prototype.finally/node_modules/es-abstract/2018/IsConstructor.js
var require_IsConstructor = __commonJS({
  "node_modules/promise.prototype.finally/node_modules/es-abstract/2018/IsConstructor.js"(exports2, module2) {
    "use strict";
    module2.exports = function IsConstructor(argument) {
      return typeof argument === "function" && !!argument.prototype;
    };
  }
});

// node_modules/promise.prototype.finally/node_modules/es-abstract/5/Type.js
var require_Type = __commonJS({
  "node_modules/promise.prototype.finally/node_modules/es-abstract/5/Type.js"(exports2, module2) {
    "use strict";
    module2.exports = function Type(x) {
      if (x === null) {
        return "Null";
      }
      if (typeof x === "undefined") {
        return "Undefined";
      }
      if (typeof x === "function" || typeof x === "object") {
        return "Object";
      }
      if (typeof x === "number") {
        return "Number";
      }
      if (typeof x === "boolean") {
        return "Boolean";
      }
      if (typeof x === "string") {
        return "String";
      }
    };
  }
});

// node_modules/promise.prototype.finally/node_modules/es-abstract/2018/Type.js
var require_Type2 = __commonJS({
  "node_modules/promise.prototype.finally/node_modules/es-abstract/2018/Type.js"(exports2, module2) {
    "use strict";
    var ES5Type = require_Type();
    module2.exports = function Type(x) {
      if (typeof x === "symbol") {
        return "Symbol";
      }
      return ES5Type(x);
    };
  }
});

// node_modules/promise.prototype.finally/node_modules/es-abstract/2018/SpeciesConstructor.js
var require_SpeciesConstructor = __commonJS({
  "node_modules/promise.prototype.finally/node_modules/es-abstract/2018/SpeciesConstructor.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic();
    var $species = GetIntrinsic("%Symbol.species%", true);
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsConstructor = require_IsConstructor();
    var Type = require_Type2();
    module2.exports = function SpeciesConstructor(O, defaultConstructor) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      var C = O.constructor;
      if (typeof C === "undefined") {
        return defaultConstructor;
      }
      if (Type(C) !== "Object") {
        throw new $TypeError("O.constructor is not an Object");
      }
      var S = $species ? C[$species] : void 0;
      if (S == null) {
        return defaultConstructor;
      }
      if (IsConstructor(S)) {
        return S;
      }
      throw new $TypeError("no constructor found");
    };
  }
});

// node_modules/promise.prototype.finally/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/promise.prototype.finally/implementation.js"(exports2, module2) {
    "use strict";
    var requirePromise = require_requirePromise();
    requirePromise();
    var IsCallable = require_IsCallable();
    var SpeciesConstructor = require_SpeciesConstructor();
    var Type = require_Type2();
    var promiseResolve = function PromiseResolve(C, value) {
      return new C(function(resolve3) {
        resolve3(value);
      });
    };
    var OriginalPromise = Promise;
    var createThenFinally = function CreateThenFinally(C, onFinally) {
      return function(value) {
        var result = onFinally();
        var promise = promiseResolve(C, result);
        var valueThunk = function() {
          return value;
        };
        return promise.then(valueThunk);
      };
    };
    var createCatchFinally = function CreateCatchFinally(C, onFinally) {
      return function(reason) {
        var result = onFinally();
        var promise = promiseResolve(C, result);
        var thrower = function() {
          throw reason;
        };
        return promise.then(thrower);
      };
    };
    var promiseFinally2 = function finally_(onFinally) {
      var promise = this;
      if (Type(promise) !== "Object") {
        throw new TypeError("receiver is not an Object");
      }
      var C = SpeciesConstructor(promise, OriginalPromise);
      var thenFinally = onFinally;
      var catchFinally = onFinally;
      if (IsCallable(onFinally)) {
        thenFinally = createThenFinally(C, onFinally);
        catchFinally = createCatchFinally(C, onFinally);
      }
      return promise.then(thenFinally, catchFinally);
    };
    if (Object.getOwnPropertyDescriptor) {
      descriptor = Object.getOwnPropertyDescriptor(promiseFinally2, "name");
      if (descriptor && descriptor.configurable) {
        Object.defineProperty(promiseFinally2, "name", { configurable: true, value: "finally" });
      }
    }
    var descriptor;
    module2.exports = promiseFinally2;
  }
});

// node_modules/promise.prototype.finally/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/promise.prototype.finally/polyfill.js"(exports2, module2) {
    "use strict";
    var requirePromise = require_requirePromise();
    var implementation = require_implementation3();
    module2.exports = function getPolyfill() {
      requirePromise();
      return typeof Promise.prototype["finally"] === "function" ? Promise.prototype["finally"] : implementation;
    };
  }
});

// node_modules/promise.prototype.finally/shim.js
var require_shim = __commonJS({
  "node_modules/promise.prototype.finally/shim.js"(exports2, module2) {
    "use strict";
    var requirePromise = require_requirePromise();
    var getPolyfill = require_polyfill();
    var define = require_define_properties();
    module2.exports = function shimPromiseFinally() {
      requirePromise();
      var polyfill = getPolyfill();
      define(Promise.prototype, { "finally": polyfill }, {
        "finally": function testFinally() {
          return Promise.prototype["finally"] !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/promise.prototype.finally/index.js
var require_promise_prototype = __commonJS({
  "node_modules/promise.prototype.finally/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var define = require_define_properties();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var bound = bind.call(Function.call, getPolyfill());
    define(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = bound;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse5(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse5(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.instances = [];
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return match;
            }
            index++;
            const formatter2 = createDebug.formatters[format2];
            if (typeof formatter2 === "function") {
              const val = args[index];
              match = formatter2.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.enabled = createDebug.enabled(namespace);
        debug.useColors = createDebug.useColors();
        debug.color = selectColor(namespace);
        debug.destroy = destroy;
        debug.extend = extend;
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        createDebug.instances.push(debug);
        return debug;
      }
      function destroy() {
        const index = createDebug.instances.indexOf(this);
        if (index !== -1) {
          createDebug.instances.splice(index, 1);
          return true;
        }
        return false;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
        for (i = 0; i < createDebug.instances.length; i++) {
          const instance = createDebug.instances[i];
          instance.enabled = createDebug.enabled(instance.namespace);
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name2)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log(...args) {
      return typeof console === "object" && console.log && console.log(...args);
    }
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os11 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os11.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("GITHUB_ACTIONS" in env) {
        return 1;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util4 = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util4.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util4.inspect(v, this.inspectOpts).replace(/\s*\n\s*/g, " ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util4.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "node_modules/rfdc/index.js"(exports2, module2) {
    "use strict";
    module2.exports = rfdc;
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles)
        return rfdcCircles(opts);
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        var o2 = {};
        for (var k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        var o2 = {};
        for (var k in o) {
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      var refs = [];
      var refsNew = [];
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else {
            var index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k] = refsNew[index];
            } else {
              a2[k] = fn(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k in o) {
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// node_modules/log4js/lib/configuration.js
var require_configuration = __commonJS({
  "node_modules/log4js/lib/configuration.js"(exports2, module2) {
    var util4 = require("util");
    var debug = require_src()("log4js:configuration");
    var preProcessingListeners = [];
    var listeners = [];
    var not = (thing) => !thing;
    var anObject = (thing) => thing && typeof thing === "object" && !Array.isArray(thing);
    var validIdentifier = (thing) => /^[A-Za-z][A-Za-z0-9_]*$/g.test(thing);
    var anInteger = (thing) => thing && typeof thing === "number" && Number.isInteger(thing);
    var addListener = (fn) => {
      listeners.push(fn);
      debug(`Added listener, now ${listeners.length} listeners`);
    };
    var addPreProcessingListener = (fn) => {
      preProcessingListeners.push(fn);
      debug(`Added pre-processing listener, now ${preProcessingListeners.length} listeners`);
    };
    var throwExceptionIf = (config, checks, message) => {
      const tests = Array.isArray(checks) ? checks : [checks];
      tests.forEach((test) => {
        if (test) {
          throw new Error(`Problem with log4js configuration: (${util4.inspect(config, { depth: 5 })}) - ${message}`);
        }
      });
    };
    var configure = (candidate) => {
      debug("New configuration to be validated: ", candidate);
      throwExceptionIf(candidate, not(anObject(candidate)), "must be an object.");
      debug(`Calling pre-processing listeners (${preProcessingListeners.length})`);
      preProcessingListeners.forEach((listener) => listener(candidate));
      debug("Configuration pre-processing finished.");
      debug(`Calling configuration listeners (${listeners.length})`);
      listeners.forEach((listener) => listener(candidate));
      debug("Configuration finished.");
    };
    module2.exports = {
      configure,
      addListener,
      addPreProcessingListener,
      throwExceptionIf,
      anObject,
      anInteger,
      validIdentifier,
      not
    };
  }
});

// node_modules/date-format/lib/index.js
var require_lib = __commonJS({
  "node_modules/date-format/lib/index.js"(exports2, module2) {
    "use strict";
    function padWithZeros(vNumber, width) {
      var numAsString = vNumber.toString();
      while (numAsString.length < width) {
        numAsString = "0" + numAsString;
      }
      return numAsString;
    }
    function addZero(vNumber) {
      return padWithZeros(vNumber, 2);
    }
    function offset(timezoneOffset) {
      var os11 = Math.abs(timezoneOffset);
      var h = String(Math.floor(os11 / 60));
      var m = String(os11 % 60);
      if (h.length === 1) {
        h = "0" + h;
      }
      if (m.length === 1) {
        m = "0" + m;
      }
      return timezoneOffset < 0 ? "+" + h + m : "-" + h + m;
    }
    function asString(format2, date) {
      if (typeof format2 !== "string") {
        date = format2;
        format2 = module2.exports.ISO8601_FORMAT;
      }
      if (!date) {
        date = module2.exports.now();
      }
      var vDay = addZero(date.getDate());
      var vMonth = addZero(date.getMonth() + 1);
      var vYearLong = addZero(date.getFullYear());
      var vYearShort = addZero(vYearLong.substring(2, 4));
      var vYear = format2.indexOf("yyyy") > -1 ? vYearLong : vYearShort;
      var vHour = addZero(date.getHours());
      var vMinute = addZero(date.getMinutes());
      var vSecond = addZero(date.getSeconds());
      var vMillisecond = padWithZeros(date.getMilliseconds(), 3);
      var vTimeZone = offset(date.getTimezoneOffset());
      var formatted = format2.replace(/dd/g, vDay).replace(/MM/g, vMonth).replace(/y{1,4}/g, vYear).replace(/hh/g, vHour).replace(/mm/g, vMinute).replace(/ss/g, vSecond).replace(/SSS/g, vMillisecond).replace(/O/g, vTimeZone);
      return formatted;
    }
    function setDatePart(date, part, value, local) {
      date["set" + (local ? "" : "UTC") + part](value);
    }
    function extractDateParts(pattern, str, missingValuesDate) {
      var local = pattern.indexOf("O") < 0;
      var matchers = [
        {
          pattern: /y{1,4}/,
          regexp: "\\d{1,4}",
          fn: function(date2, value) {
            setDatePart(date2, "FullYear", value, local);
          }
        },
        {
          pattern: /MM/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            setDatePart(date2, "Month", value - 1, local);
          }
        },
        {
          pattern: /dd/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            setDatePart(date2, "Date", value, local);
          }
        },
        {
          pattern: /hh/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            setDatePart(date2, "Hours", value, local);
          }
        },
        {
          pattern: /mm/,
          regexp: "\\d\\d",
          fn: function(date2, value) {
            setDatePart(date2, "Minutes", value, local);
          }
        },
        {
          pattern: /ss/,
          regexp: "\\d\\d",
          fn: function(date2, value) {
            setDatePart(date2, "Seconds", value, local);
          }
        },
        {
          pattern: /SSS/,
          regexp: "\\d\\d\\d",
          fn: function(date2, value) {
            setDatePart(date2, "Milliseconds", value, local);
          }
        },
        {
          pattern: /O/,
          regexp: "[+-]\\d{3,4}|Z",
          fn: function(date2, value) {
            if (value === "Z") {
              value = 0;
            }
            var offset2 = Math.abs(value);
            var timezoneOffset = (value > 0 ? -1 : 1) * (offset2 % 100 + Math.floor(offset2 / 100) * 60);
            date2.setUTCMinutes(date2.getUTCMinutes() + timezoneOffset);
          }
        }
      ];
      var parsedPattern = matchers.reduce(function(p, m) {
        if (m.pattern.test(p.regexp)) {
          m.index = p.regexp.match(m.pattern).index;
          p.regexp = p.regexp.replace(m.pattern, "(" + m.regexp + ")");
        } else {
          m.index = -1;
        }
        return p;
      }, { regexp: pattern, index: [] });
      var dateFns = matchers.filter(function(m) {
        return m.index > -1;
      });
      dateFns.sort(function(a, b) {
        return a.index - b.index;
      });
      var matcher = new RegExp(parsedPattern.regexp);
      var matches = matcher.exec(str);
      if (matches) {
        var date = missingValuesDate || module2.exports.now();
        dateFns.forEach(function(f, i) {
          f.fn(date, matches[i + 1]);
        });
        return date;
      }
      throw new Error("String '" + str + "' could not be parsed as '" + pattern + "'");
    }
    function parse5(pattern, str, missingValuesDate) {
      if (!pattern) {
        throw new Error("pattern must be supplied");
      }
      return extractDateParts(pattern, str, missingValuesDate);
    }
    function now() {
      return new Date();
    }
    module2.exports = asString;
    module2.exports.asString = asString;
    module2.exports.parse = parse5;
    module2.exports.now = now;
    module2.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS";
    module2.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO";
    module2.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS";
    module2.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";
  }
});

// node_modules/log4js/lib/layouts.js
var require_layouts = __commonJS({
  "node_modules/log4js/lib/layouts.js"(exports2, module2) {
    var dateFormat = require_lib();
    var os11 = require("os");
    var util4 = require("util");
    var path34 = require("path");
    var styles3 = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [90, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [91, 39],
      yellow: [33, 39]
    };
    function colorizeStart(style2) {
      return style2 ? `[${styles3[style2][0]}m` : "";
    }
    function colorizeEnd(style2) {
      return style2 ? `[${styles3[style2][1]}m` : "";
    }
    function colorize(str, style2) {
      return colorizeStart(style2) + str + colorizeEnd(style2);
    }
    function timestampLevelAndCategory(loggingEvent, colour) {
      return colorize(util4.format("[%s] [%s] %s - ", dateFormat.asString(loggingEvent.startTime), loggingEvent.level.toString(), loggingEvent.categoryName), colour);
    }
    function basicLayout(loggingEvent) {
      return timestampLevelAndCategory(loggingEvent) + util4.format(...loggingEvent.data);
    }
    function colouredLayout(loggingEvent) {
      return timestampLevelAndCategory(loggingEvent, loggingEvent.level.colour) + util4.format(...loggingEvent.data);
    }
    function messagePassThroughLayout(loggingEvent) {
      return util4.format(...loggingEvent.data);
    }
    function dummyLayout(loggingEvent) {
      return loggingEvent.data[0];
    }
    function patternLayout(pattern, tokens) {
      const TTCC_CONVERSION_PATTERN = "%r %p %c - %m%n";
      const regex = /%(-?[0-9]+)?(\.?-?[0-9]+)?([[\]cdhmnprzxXyflos%])(\{([^}]+)\})?|([^%]+)/;
      pattern = pattern || TTCC_CONVERSION_PATTERN;
      function categoryName(loggingEvent, specifier) {
        let loggerName = loggingEvent.categoryName;
        if (specifier) {
          const precision = parseInt(specifier, 10);
          const loggerNameBits = loggerName.split(".");
          if (precision < loggerNameBits.length) {
            loggerName = loggerNameBits.slice(loggerNameBits.length - precision).join(".");
          }
        }
        return loggerName;
      }
      function formatAsDate(loggingEvent, specifier) {
        let format2 = dateFormat.ISO8601_FORMAT;
        if (specifier) {
          format2 = specifier;
          if (format2 === "ISO8601") {
            format2 = dateFormat.ISO8601_FORMAT;
          } else if (format2 === "ISO8601_WITH_TZ_OFFSET") {
            format2 = dateFormat.ISO8601_WITH_TZ_OFFSET_FORMAT;
          } else if (format2 === "ABSOLUTE") {
            format2 = dateFormat.ABSOLUTETIME_FORMAT;
          } else if (format2 === "DATE") {
            format2 = dateFormat.DATETIME_FORMAT;
          }
        }
        return dateFormat.asString(format2, loggingEvent.startTime);
      }
      function hostname() {
        return os11.hostname().toString();
      }
      function formatMessage(loggingEvent) {
        return util4.format(...loggingEvent.data);
      }
      function endOfLine() {
        return os11.EOL;
      }
      function logLevel(loggingEvent) {
        return loggingEvent.level.toString();
      }
      function startTime(loggingEvent) {
        return dateFormat.asString("hh:mm:ss", loggingEvent.startTime);
      }
      function startColour(loggingEvent) {
        return colorizeStart(loggingEvent.level.colour);
      }
      function endColour(loggingEvent) {
        return colorizeEnd(loggingEvent.level.colour);
      }
      function percent() {
        return "%";
      }
      function pid(loggingEvent) {
        return loggingEvent && loggingEvent.pid ? loggingEvent.pid.toString() : process.pid.toString();
      }
      function clusterInfo() {
        return pid();
      }
      function userDefined(loggingEvent, specifier) {
        if (typeof tokens[specifier] !== "undefined") {
          return typeof tokens[specifier] === "function" ? tokens[specifier](loggingEvent) : tokens[specifier];
        }
        return null;
      }
      function contextDefined(loggingEvent, specifier) {
        const resolver = loggingEvent.context[specifier];
        if (typeof resolver !== "undefined") {
          return typeof resolver === "function" ? resolver(loggingEvent) : resolver;
        }
        return null;
      }
      function fileName(loggingEvent, specifier) {
        let filename = loggingEvent.fileName || "";
        if (specifier) {
          const fileDepth = parseInt(specifier, 10);
          const fileList = filename.split(path34.sep);
          if (fileList.length > fileDepth) {
            filename = fileList.slice(-fileDepth).join(path34.sep);
          }
        }
        return filename;
      }
      function lineNumber(loggingEvent) {
        return loggingEvent.lineNumber ? `${loggingEvent.lineNumber}` : "";
      }
      function columnNumber(loggingEvent) {
        return loggingEvent.columnNumber ? `${loggingEvent.columnNumber}` : "";
      }
      function callStack(loggingEvent) {
        return loggingEvent.callStack || "";
      }
      const replacers = {
        c: categoryName,
        d: formatAsDate,
        h: hostname,
        m: formatMessage,
        n: endOfLine,
        p: logLevel,
        r: startTime,
        "[": startColour,
        "]": endColour,
        y: clusterInfo,
        z: pid,
        "%": percent,
        x: userDefined,
        X: contextDefined,
        f: fileName,
        l: lineNumber,
        o: columnNumber,
        s: callStack
      };
      function replaceToken(conversionCharacter, loggingEvent, specifier) {
        return replacers[conversionCharacter](loggingEvent, specifier);
      }
      function truncate(truncation, toTruncate) {
        let len;
        if (truncation) {
          len = parseInt(truncation.substr(1), 10);
          return len > 0 ? toTruncate.slice(0, len) : toTruncate.slice(len);
        }
        return toTruncate;
      }
      function pad2(padding, toPad) {
        let len;
        if (padding) {
          if (padding.charAt(0) === "-") {
            len = parseInt(padding.substr(1), 10);
            while (toPad.length < len) {
              toPad += " ";
            }
          } else {
            len = parseInt(padding, 10);
            while (toPad.length < len) {
              toPad = ` ${toPad}`;
            }
          }
        }
        return toPad;
      }
      function truncateAndPad(toTruncAndPad, truncation, padding) {
        let replacement = toTruncAndPad;
        replacement = truncate(truncation, replacement);
        replacement = pad2(padding, replacement);
        return replacement;
      }
      return function(loggingEvent) {
        let formattedString = "";
        let result;
        let searchString = pattern;
        while ((result = regex.exec(searchString)) !== null) {
          const padding = result[1];
          const truncation = result[2];
          const conversionCharacter = result[3];
          const specifier = result[5];
          const text = result[6];
          if (text) {
            formattedString += text.toString();
          } else {
            const replacement = replaceToken(conversionCharacter, loggingEvent, specifier);
            formattedString += truncateAndPad(replacement, truncation, padding);
          }
          searchString = searchString.substr(result.index + result[0].length);
        }
        return formattedString;
      };
    }
    var layoutMakers = {
      messagePassThrough() {
        return messagePassThroughLayout;
      },
      basic() {
        return basicLayout;
      },
      colored() {
        return colouredLayout;
      },
      coloured() {
        return colouredLayout;
      },
      pattern(config) {
        return patternLayout(config && config.pattern, config && config.tokens);
      },
      dummy() {
        return dummyLayout;
      }
    };
    module2.exports = {
      basicLayout,
      messagePassThroughLayout,
      patternLayout,
      colouredLayout,
      coloredLayout: colouredLayout,
      dummyLayout,
      addLayout(name2, serializerGenerator) {
        layoutMakers[name2] = serializerGenerator;
      },
      layout(name2, config) {
        return layoutMakers[name2] && layoutMakers[name2](config);
      }
    };
  }
});

// node_modules/log4js/lib/levels.js
var require_levels = __commonJS({
  "node_modules/log4js/lib/levels.js"(exports2, module2) {
    var configuration = require_configuration();
    var validColours = [
      "white",
      "grey",
      "black",
      "blue",
      "cyan",
      "green",
      "magenta",
      "red",
      "yellow"
    ];
    var Level = class {
      constructor(level, levelStr, colour) {
        this.level = level;
        this.levelStr = levelStr;
        this.colour = colour;
      }
      toString() {
        return this.levelStr;
      }
      static getLevel(sArg, defaultLevel) {
        if (!sArg) {
          return defaultLevel;
        }
        if (sArg instanceof Level) {
          return sArg;
        }
        if (sArg instanceof Object && sArg.levelStr) {
          sArg = sArg.levelStr;
        }
        return Level[sArg.toString().toUpperCase()] || defaultLevel;
      }
      static addLevels(customLevels) {
        if (customLevels) {
          const levels = Object.keys(customLevels);
          levels.forEach((l) => {
            const levelStr = l.toUpperCase();
            Level[levelStr] = new Level(customLevels[l].value, levelStr, customLevels[l].colour);
            const existingLevelIndex = Level.levels.findIndex((lvl) => lvl.levelStr === levelStr);
            if (existingLevelIndex > -1) {
              Level.levels[existingLevelIndex] = Level[levelStr];
            } else {
              Level.levels.push(Level[levelStr]);
            }
          });
          Level.levels.sort((a, b) => a.level - b.level);
        }
      }
      isLessThanOrEqualTo(otherLevel) {
        if (typeof otherLevel === "string") {
          otherLevel = Level.getLevel(otherLevel);
        }
        return this.level <= otherLevel.level;
      }
      isGreaterThanOrEqualTo(otherLevel) {
        if (typeof otherLevel === "string") {
          otherLevel = Level.getLevel(otherLevel);
        }
        return this.level >= otherLevel.level;
      }
      isEqualTo(otherLevel) {
        if (typeof otherLevel === "string") {
          otherLevel = Level.getLevel(otherLevel);
        }
        return this.level === otherLevel.level;
      }
    };
    Level.levels = [];
    Level.addLevels({
      ALL: { value: Number.MIN_VALUE, colour: "grey" },
      TRACE: { value: 5e3, colour: "blue" },
      DEBUG: { value: 1e4, colour: "cyan" },
      INFO: { value: 2e4, colour: "green" },
      WARN: { value: 3e4, colour: "yellow" },
      ERROR: { value: 4e4, colour: "red" },
      FATAL: { value: 5e4, colour: "magenta" },
      MARK: { value: 9007199254740992, colour: "grey" },
      OFF: { value: Number.MAX_VALUE, colour: "grey" }
    });
    configuration.addListener((config) => {
      const levelConfig = config.levels;
      if (levelConfig) {
        configuration.throwExceptionIf(config, configuration.not(configuration.anObject(levelConfig)), "levels must be an object");
        const newLevels = Object.keys(levelConfig);
        newLevels.forEach((l) => {
          configuration.throwExceptionIf(config, configuration.not(configuration.validIdentifier(l)), `level name "${l}" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`);
          configuration.throwExceptionIf(config, configuration.not(configuration.anObject(levelConfig[l])), `level "${l}" must be an object`);
          configuration.throwExceptionIf(config, configuration.not(levelConfig[l].value), `level "${l}" must have a 'value' property`);
          configuration.throwExceptionIf(config, configuration.not(configuration.anInteger(levelConfig[l].value)), `level "${l}".value must have an integer value`);
          configuration.throwExceptionIf(config, configuration.not(levelConfig[l].colour), `level "${l}" must have a 'colour' property`);
          configuration.throwExceptionIf(config, configuration.not(validColours.indexOf(levelConfig[l].colour) > -1), `level "${l}".colour must be one of ${validColours.join(", ")}`);
        });
      }
    });
    configuration.addListener((config) => {
      Level.addLevels(config.levels);
    });
    module2.exports = Level;
  }
});

// node_modules/flatted/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  default: () => esm_default,
  parse: () => parse,
  stringify: () => stringify
});
var Flatted, esm_default, parse, stringify;
var init_esm = __esm({
  "node_modules/flatted/esm/index.js"() {
    Flatted = function(Primitive, primitive) {
      var Flatted2 = {
        parse: function parse5(text, reviver) {
          var input = JSON.parse(text, Primitives).map(primitives);
          var value = input[0];
          var $ = reviver || noop;
          var tmp = typeof value === "object" && value ? revive(input, new Set(), value, $) : value;
          return $.call({ "": tmp }, "", tmp);
        },
        stringify: function stringify3(value, replacer, space) {
          for (var firstRun, known = new Map(), input = [], output = [], $ = replacer && typeof replacer === typeof input ? function(k, v) {
            if (k === "" || -1 < replacer.indexOf(k))
              return v;
          } : replacer || noop, i = +set(known, input, $.call({ "": value }, "", value)), replace = function(key, value2) {
            if (firstRun) {
              firstRun = !firstRun;
              return value2;
            }
            var after = $.call(this, key, value2);
            switch (typeof after) {
              case "object":
                if (after === null)
                  return after;
              case primitive:
                return known.get(after) || set(known, input, after);
            }
            return after;
          }; i < input.length; i++) {
            firstRun = true;
            output[i] = JSON.stringify(input[i], replace, space);
          }
          return "[" + output.join(",") + "]";
        }
      };
      return Flatted2;
      function noop(key, value) {
        return value;
      }
      function revive(input, parsed, output, $) {
        return Object.keys(output).reduce(function(output2, key) {
          var value = output2[key];
          if (value instanceof Primitive) {
            var tmp = input[value];
            if (typeof tmp === "object" && !parsed.has(tmp)) {
              parsed.add(tmp);
              output2[key] = $.call(output2, key, revive(input, parsed, tmp, $));
            } else {
              output2[key] = $.call(output2, key, tmp);
            }
          } else
            output2[key] = $.call(output2, key, value);
          return output2;
        }, output);
      }
      function set(known, input, value) {
        var index = Primitive(input.push(value) - 1);
        known.set(value, index);
        return index;
      }
      function primitives(value) {
        return value instanceof Primitive ? Primitive(value) : value;
      }
      function Primitives(key, value) {
        return typeof value === primitive ? new Primitive(value) : value;
      }
    }(String, "string");
    esm_default = Flatted;
    parse = Flatted.parse;
    stringify = Flatted.stringify;
  }
});

// node_modules/log4js/lib/LoggingEvent.js
var require_LoggingEvent = __commonJS({
  "node_modules/log4js/lib/LoggingEvent.js"(exports2, module2) {
    var flatted = (init_esm(), esm_exports);
    var levels = require_levels();
    var LoggingEvent = class {
      constructor(categoryName, level, data, context, location) {
        this.startTime = new Date();
        this.categoryName = categoryName;
        this.data = data;
        this.level = level;
        this.context = Object.assign({}, context);
        this.pid = process.pid;
        if (location) {
          this.functionName = location.functionName;
          this.fileName = location.fileName;
          this.lineNumber = location.lineNumber;
          this.columnNumber = location.columnNumber;
          this.callStack = location.callStack;
        }
      }
      serialise() {
        const logData = this.data.map((e) => {
          if (e && e.message && e.stack) {
            e = Object.assign({ message: e.message, stack: e.stack }, e);
          }
          return e;
        });
        this.data = logData;
        return flatted.stringify(this);
      }
      static deserialise(serialised) {
        let event;
        try {
          const rehydratedEvent = flatted.parse(serialised);
          rehydratedEvent.data = rehydratedEvent.data.map((e) => {
            if (e && e.message && e.stack) {
              const fakeError = new Error(e);
              Object.keys(e).forEach((key) => {
                fakeError[key] = e[key];
              });
              e = fakeError;
            }
            return e;
          });
          event = new LoggingEvent(rehydratedEvent.categoryName, levels.getLevel(rehydratedEvent.level.levelStr), rehydratedEvent.data, rehydratedEvent.context);
          event.startTime = new Date(rehydratedEvent.startTime);
          event.pid = rehydratedEvent.pid;
          event.cluster = rehydratedEvent.cluster;
        } catch (e) {
          event = new LoggingEvent("log4js", levels.ERROR, ["Unable to parse log:", serialised, "because: ", e]);
        }
        return event;
      }
    };
    module2.exports = LoggingEvent;
  }
});

// node_modules/log4js/lib/clustering.js
var require_clustering = __commonJS({
  "node_modules/log4js/lib/clustering.js"(exports2, module2) {
    var debug = require_src()("log4js:clustering");
    var LoggingEvent = require_LoggingEvent();
    var configuration = require_configuration();
    var disabled = false;
    var cluster = null;
    try {
      cluster = require("cluster");
    } catch (e) {
      debug("cluster module not present");
      disabled = true;
    }
    var listeners = [];
    var pm2 = false;
    var pm2InstanceVar = "NODE_APP_INSTANCE";
    var isPM2Master = () => pm2 && process.env[pm2InstanceVar] === "0";
    var isMaster = () => disabled || cluster.isMaster || isPM2Master();
    var sendToListeners = (logEvent) => {
      listeners.forEach((l) => l(logEvent));
    };
    var receiver = (worker, message) => {
      debug("cluster message received from worker ", worker, ": ", message);
      if (worker.topic && worker.data) {
        message = worker;
        worker = void 0;
      }
      if (message && message.topic && message.topic === "log4js:message") {
        debug("received message: ", message.data);
        const logEvent = LoggingEvent.deserialise(message.data);
        sendToListeners(logEvent);
      }
    };
    if (!disabled) {
      configuration.addListener((config) => {
        listeners.length = 0;
        ({
          pm2,
          disableClustering: disabled,
          pm2InstanceVar = "NODE_APP_INSTANCE"
        } = config);
        debug(`clustering disabled ? ${disabled}`);
        debug(`cluster.isMaster ? ${cluster && cluster.isMaster}`);
        debug(`pm2 enabled ? ${pm2}`);
        debug(`pm2InstanceVar = ${pm2InstanceVar}`);
        debug(`process.env[${pm2InstanceVar}] = ${process.env[pm2InstanceVar]}`);
        if (pm2) {
          process.removeListener("message", receiver);
        }
        if (cluster && cluster.removeListener) {
          cluster.removeListener("message", receiver);
        }
        if (disabled || config.disableClustering) {
          debug("Not listening for cluster messages, because clustering disabled.");
        } else if (isPM2Master()) {
          debug("listening for PM2 broadcast messages");
          process.on("message", receiver);
        } else if (cluster.isMaster) {
          debug("listening for cluster messages");
          cluster.on("message", receiver);
        } else {
          debug("not listening for messages, because we are not a master process");
        }
      });
    }
    module2.exports = {
      onlyOnMaster: (fn, notMaster) => isMaster() ? fn() : notMaster,
      isMaster,
      send: (msg) => {
        if (isMaster()) {
          sendToListeners(msg);
        } else {
          if (!pm2) {
            msg.cluster = {
              workerId: cluster.worker.id,
              worker: process.pid
            };
          }
          process.send({ topic: "log4js:message", data: msg.serialise() });
        }
      },
      onMessage: (listener) => {
        listeners.push(listener);
      }
    };
  }
});

// node_modules/log4js/lib/appenders/adapters.js
var require_adapters = __commonJS({
  "node_modules/log4js/lib/appenders/adapters.js"(exports2, module2) {
    function maxFileSizeUnitTransform(maxLogSize) {
      if (typeof maxLogSize === "number" && Number.isInteger(maxLogSize)) {
        return maxLogSize;
      }
      const units = {
        K: 1024,
        M: 1024 * 1024,
        G: 1024 * 1024 * 1024
      };
      const validUnit = Object.keys(units);
      const unit = maxLogSize.substr(maxLogSize.length - 1).toLocaleUpperCase();
      const value = maxLogSize.substring(0, maxLogSize.length - 1).trim();
      if (validUnit.indexOf(unit) < 0 || !Number.isInteger(Number(value))) {
        throw Error(`maxLogSize: "${maxLogSize}" is invalid`);
      } else {
        return value * units[unit];
      }
    }
    function adapter(configAdapter, config) {
      const newConfig = Object.assign({}, config);
      Object.keys(configAdapter).forEach((key) => {
        if (newConfig[key]) {
          newConfig[key] = configAdapter[key](config[key]);
        }
      });
      return newConfig;
    }
    function fileAppenderAdapter(config) {
      const configAdapter = {
        maxLogSize: maxFileSizeUnitTransform
      };
      return adapter(configAdapter, config);
    }
    var adapters = {
      file: fileAppenderAdapter,
      fileSync: fileAppenderAdapter
    };
    module2.exports.modifyConfig = (config) => adapters[config.type] ? adapters[config.type](config) : config;
  }
});

// node_modules/log4js/lib/appenders/console.js
var require_console = __commonJS({
  "node_modules/log4js/lib/appenders/console.js"(exports2, module2) {
    var consoleLog = console.log.bind(console);
    function consoleAppender(layout, timezoneOffset) {
      return (loggingEvent) => {
        consoleLog(layout(loggingEvent, timezoneOffset));
      };
    }
    function configure(config, layouts) {
      let layout = layouts.colouredLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      return consoleAppender(layout, config.timezoneOffset);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/stdout.js
var require_stdout = __commonJS({
  "node_modules/log4js/lib/appenders/stdout.js"(exports2) {
    function stdoutAppender(layout, timezoneOffset) {
      return (loggingEvent) => {
        process.stdout.write(`${layout(loggingEvent, timezoneOffset)}
`);
      };
    }
    function configure(config, layouts) {
      let layout = layouts.colouredLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      return stdoutAppender(layout, config.timezoneOffset);
    }
    exports2.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/stderr.js
var require_stderr = __commonJS({
  "node_modules/log4js/lib/appenders/stderr.js"(exports2, module2) {
    function stderrAppender(layout, timezoneOffset) {
      return (loggingEvent) => {
        process.stderr.write(`${layout(loggingEvent, timezoneOffset)}
`);
      };
    }
    function configure(config, layouts) {
      let layout = layouts.colouredLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      return stderrAppender(layout, config.timezoneOffset);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/logLevelFilter.js
var require_logLevelFilter = __commonJS({
  "node_modules/log4js/lib/appenders/logLevelFilter.js"(exports2, module2) {
    function logLevelFilter(minLevelString, maxLevelString, appender, levels) {
      const minLevel = levels.getLevel(minLevelString);
      const maxLevel = levels.getLevel(maxLevelString, levels.FATAL);
      return (logEvent) => {
        const eventLevel = logEvent.level;
        if (eventLevel.isGreaterThanOrEqualTo(minLevel) && eventLevel.isLessThanOrEqualTo(maxLevel)) {
          appender(logEvent);
        }
      };
    }
    function configure(config, layouts, findAppender, levels) {
      const appender = findAppender(config.appender);
      return logLevelFilter(config.level, config.maxLevel, appender, levels);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/categoryFilter.js
var require_categoryFilter = __commonJS({
  "node_modules/log4js/lib/appenders/categoryFilter.js"(exports2, module2) {
    var debug = require_src()("log4js:categoryFilter");
    function categoryFilter(excludes, appender) {
      if (typeof excludes === "string")
        excludes = [excludes];
      return (logEvent) => {
        debug(`Checking ${logEvent.categoryName} against ${excludes}`);
        if (excludes.indexOf(logEvent.categoryName) === -1) {
          debug("Not excluded, sending to appender");
          appender(logEvent);
        }
      };
    }
    function configure(config, layouts, findAppender) {
      const appender = findAppender(config.appender);
      return categoryFilter(config.exclude, appender);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/noLogFilter.js
var require_noLogFilter = __commonJS({
  "node_modules/log4js/lib/appenders/noLogFilter.js"(exports2, module2) {
    var debug = require_src()("log4js:noLogFilter");
    function removeNullOrEmptyRegexp(regexp) {
      const filtered = regexp.filter((el) => el != null && el !== "");
      return filtered;
    }
    function noLogFilter(filters, appender) {
      return (logEvent) => {
        debug(`Checking data: ${logEvent.data} against filters: ${filters}`);
        if (typeof filters === "string") {
          filters = [filters];
        }
        filters = removeNullOrEmptyRegexp(filters);
        const regex = new RegExp(filters.join("|"), "i");
        if (filters.length === 0 || logEvent.data.findIndex((value) => regex.test(value)) < 0) {
          debug("Not excluded, sending to appender");
          appender(logEvent);
        }
      };
    }
    function configure(config, layouts, findAppender) {
      const appender = findAppender(config.appender);
      return noLogFilter(config.exclude, appender);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/streamroller/node_modules/universalify/index.js
var require_universalify = __commonJS({
  "node_modules/streamroller/node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function() {
        if (typeof arguments[arguments.length - 1] === "function")
          fn.apply(this, arguments);
        else {
          return new Promise((resolve3, reject) => {
            arguments[arguments.length] = (err, res) => {
              if (err)
                return reject(err);
              resolve3(res);
            };
            arguments.length++;
            fn.apply(this, arguments);
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function() {
        const cb = arguments[arguments.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, arguments);
        else
          fn.apply(this, arguments).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform3 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    var chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null;
      chdir.call(process, d);
    };
    module2.exports = patch;
    function patch(fs26) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs26);
      }
      if (!fs26.lutimes) {
        patchLutimes(fs26);
      }
      fs26.chown = chownFix(fs26.chown);
      fs26.fchown = chownFix(fs26.fchown);
      fs26.lchown = chownFix(fs26.lchown);
      fs26.chmod = chmodFix(fs26.chmod);
      fs26.fchmod = chmodFix(fs26.fchmod);
      fs26.lchmod = chmodFix(fs26.lchmod);
      fs26.chownSync = chownFixSync(fs26.chownSync);
      fs26.fchownSync = chownFixSync(fs26.fchownSync);
      fs26.lchownSync = chownFixSync(fs26.lchownSync);
      fs26.chmodSync = chmodFixSync(fs26.chmodSync);
      fs26.fchmodSync = chmodFixSync(fs26.fchmodSync);
      fs26.lchmodSync = chmodFixSync(fs26.lchmodSync);
      fs26.stat = statFix(fs26.stat);
      fs26.fstat = statFix(fs26.fstat);
      fs26.lstat = statFix(fs26.lstat);
      fs26.statSync = statFixSync(fs26.statSync);
      fs26.fstatSync = statFixSync(fs26.fstatSync);
      fs26.lstatSync = statFixSync(fs26.lstatSync);
      if (!fs26.lchmod) {
        fs26.lchmod = function(path34, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs26.lchmodSync = function() {
        };
      }
      if (!fs26.lchown) {
        fs26.lchown = function(path34, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs26.lchownSync = function() {
        };
      }
      if (platform3 === "win32") {
        fs26.rename = function(fs$rename) {
          return function(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs26.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          };
        }(fs26.rename);
      }
      fs26.read = function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs26, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs26, fd, buffer, offset, length, position, callback);
        }
        read.__proto__ = fs$read;
        return read;
      }(fs26.read);
      fs26.readSync = function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs26, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs26.readSync);
      function patchLchmod(fs27) {
        fs27.lchmod = function(path34, mode, callback) {
          fs27.open(path34, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
            if (err) {
              if (callback)
                callback(err);
              return;
            }
            fs27.fchmod(fd, mode, function(err2) {
              fs27.close(fd, function(err22) {
                if (callback)
                  callback(err2 || err22);
              });
            });
          });
        };
        fs27.lchmodSync = function(path34, mode) {
          var fd = fs27.openSync(path34, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs27.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs27.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs27.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs27) {
        if (constants.hasOwnProperty("O_SYMLINK")) {
          fs27.lutimes = function(path34, at, mt, cb) {
            fs27.open(path34, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs27.futimes(fd, at, mt, function(er2) {
                fs27.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs27.lutimesSync = function(path34, at, mt) {
            var fd = fs27.openSync(path34, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs27.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs27.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs27.closeSync(fd);
              }
            }
            return ret;
          };
        } else {
          fs27.lutimes = function(_a2, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs27.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs26, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs26, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs26, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs26, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs26, target, options, callback) : orig.call(fs26, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs26, target, options) : orig.call(fs26, target);
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs26) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path34, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path34, options);
        Stream.call(this);
        var self2 = this;
        this.path = path34;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs26.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path34, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path34, options);
        Stream.call(this);
        this.path = path34;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs26.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: obj.__proto__ };
      else
        var copy = Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    var fs26 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util4 = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util4.debuglog)
      debug = util4.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util4.format.apply(util4, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs26[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs26, queue);
      fs26.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs26, fd, function(err) {
            if (!err) {
              retry();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs26.close);
      fs26.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs26, arguments);
          retry();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs26.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs26[gracefulQueue]);
          require("assert").equal(fs26[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs26[gracefulQueue]);
    }
    module2.exports = patch(clone(fs26));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs26.__patched) {
      module2.exports = patch(fs26);
      fs26.__patched = true;
    }
    function patch(fs27) {
      polyfills(fs27);
      fs27.gracefulify = patch;
      fs27.createReadStream = createReadStream;
      fs27.createWriteStream = createWriteStream;
      var fs$readFile = fs27.readFile;
      fs27.readFile = readFile2;
      function readFile2(path34, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path34, options, cb);
        function go$readFile(path35, options2, cb2) {
          return fs$readFile(path35, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path35, options2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$writeFile = fs27.writeFile;
      fs27.writeFile = writeFile2;
      function writeFile2(path34, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path34, data, options, cb);
        function go$writeFile(path35, data2, options2, cb2) {
          return fs$writeFile(path35, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path35, data2, options2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$appendFile = fs27.appendFile;
      if (fs$appendFile)
        fs27.appendFile = appendFile;
      function appendFile(path34, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path34, data, options, cb);
        function go$appendFile(path35, data2, options2, cb2) {
          return fs$appendFile(path35, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path35, data2, options2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$readdir = fs27.readdir;
      fs27.readdir = readdir;
      function readdir(path34, options, cb) {
        var args = [path34];
        if (typeof options !== "function") {
          args.push(options);
        } else {
          cb = options;
        }
        args.push(go$readdir$cb);
        return go$readdir(args);
        function go$readdir$cb(err, files) {
          if (files && files.sort)
            files.sort();
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readdir, [args]]);
          else {
            if (typeof cb === "function")
              cb.apply(this, arguments);
            retry();
          }
        }
      }
      function go$readdir(args) {
        return fs$readdir.apply(fs27, args);
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs27);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs27.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs27.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs27, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs27, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs27, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs27, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path34, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path34, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path34, options) {
        return new fs27.ReadStream(path34, options);
      }
      function createWriteStream(path34, options) {
        return new fs27.WriteStream(path34, options);
      }
      var fs$open = fs27.open;
      fs27.open = open;
      function open(path34, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path34, flags, mode, cb);
        function go$open(path35, flags2, mode2, cb2) {
          return fs$open(path35, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path35, flags2, mode2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      return fs27;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs26[gracefulQueue].push(elem);
    }
    function retry() {
      var elem = fs26[gracefulQueue].shift();
      if (elem) {
        debug("RETRY", elem[0].name, elem[1]);
        elem[0].apply(null, elem[1]);
      }
    }
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/fs/index.js"(exports2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs26 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchown",
      "lchmod",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "readFile",
      "readdir",
      "readlink",
      "realpath",
      "rename",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs26[key] === "function";
    });
    Object.keys(fs26).forEach((key) => {
      if (key === "promises") {
        return;
      }
      exports2[key] = fs26[key];
    });
    api.forEach((method) => {
      exports2[method] = u(fs26[method]);
    });
    exports2.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs26.exists(filename, callback);
      }
      return new Promise((resolve3) => {
        return fs26.exists(filename, resolve3);
      });
    };
    exports2.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs26.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve3, reject) => {
        fs26.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve3({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports2.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs26.write(fd, buffer, ...args);
      }
      return new Promise((resolve3, reject) => {
        fs26.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve3({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    if (typeof fs26.realpath.native === "function") {
      exports2.realpath.native = u(fs26.realpath.native);
    }
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/win32.js
var require_win32 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/win32.js"(exports2, module2) {
    "use strict";
    var path34 = require("path");
    function getRootPath(p) {
      p = path34.normalize(path34.resolve(p)).split(path34.sep);
      if (p.length > 0)
        return p[0];
      return null;
    }
    var INVALID_PATH_CHARS = /[<>:"|?*]/;
    function invalidWin32Path(p) {
      const rp = getRootPath(p);
      p = p.replace(rp, "");
      return INVALID_PATH_CHARS.test(p);
    }
    module2.exports = {
      getRootPath,
      invalidWin32Path
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs.js
var require_mkdirs = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var invalidWin32Path = require_win32().invalidWin32Path;
    var o777 = parseInt("0777", 8);
    function mkdirs(p, opts, callback, made) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      if (process.platform === "win32" && invalidWin32Path(p)) {
        const errInval = new Error(p + " contains invalid WIN32 path characters.");
        errInval.code = "EINVAL";
        return callback(errInval);
      }
      let mode = opts.mode;
      const xfs = opts.fs || fs26;
      if (mode === void 0) {
        mode = o777 & ~process.umask();
      }
      if (!made)
        made = null;
      callback = callback || function() {
      };
      p = path34.resolve(p);
      xfs.mkdir(p, mode, (er) => {
        if (!er) {
          made = made || p;
          return callback(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path34.dirname(p) === p)
              return callback(er);
            mkdirs(path34.dirname(p), opts, (er2, made2) => {
              if (er2)
                callback(er2, made2);
              else
                mkdirs(p, opts, callback, made2);
            });
            break;
          default:
            xfs.stat(p, (er2, stat) => {
              if (er2 || !stat.isDirectory())
                callback(er, made);
              else
                callback(null, made);
            });
            break;
        }
      });
    }
    module2.exports = mkdirs;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js
var require_mkdirs_sync = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var invalidWin32Path = require_win32().invalidWin32Path;
    var o777 = parseInt("0777", 8);
    function mkdirsSync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      let mode = opts.mode;
      const xfs = opts.fs || fs26;
      if (process.platform === "win32" && invalidWin32Path(p)) {
        const errInval = new Error(p + " contains invalid WIN32 path characters.");
        errInval.code = "EINVAL";
        throw errInval;
      }
      if (mode === void 0) {
        mode = o777 & ~process.umask();
      }
      if (!made)
        made = null;
      p = path34.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        if (err0.code === "ENOENT") {
          if (path34.dirname(p) === p)
            throw err0;
          made = mkdirsSync(path34.dirname(p), opts, made);
          mkdirsSync(p, opts, made);
        } else {
          let stat;
          try {
            stat = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat.isDirectory())
            throw err0;
        }
      }
      return made;
    }
    module2.exports = mkdirsSync;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var mkdirs = u(require_mkdirs());
    var mkdirsSync = require_mkdirs_sync();
    module2.exports = {
      mkdirs,
      mkdirsSync,
      mkdirp: mkdirs,
      mkdirpSync: mkdirsSync,
      ensureDir: mkdirs,
      ensureDirSync: mkdirsSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/util/utimes.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var os11 = require("os");
    var path34 = require("path");
    function hasMillisResSync() {
      let tmpfile = path34.join("millis-test-sync" + Date.now().toString() + Math.random().toString().slice(2));
      tmpfile = path34.join(os11.tmpdir(), tmpfile);
      const d = new Date(1435410243862);
      fs26.writeFileSync(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141");
      const fd = fs26.openSync(tmpfile, "r+");
      fs26.futimesSync(fd, d, d);
      fs26.closeSync(fd);
      return fs26.statSync(tmpfile).mtime > 1435410243e3;
    }
    function hasMillisRes(callback) {
      let tmpfile = path34.join("millis-test" + Date.now().toString() + Math.random().toString().slice(2));
      tmpfile = path34.join(os11.tmpdir(), tmpfile);
      const d = new Date(1435410243862);
      fs26.writeFile(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141", (err) => {
        if (err)
          return callback(err);
        fs26.open(tmpfile, "r+", (err2, fd) => {
          if (err2)
            return callback(err2);
          fs26.futimes(fd, d, d, (err3) => {
            if (err3)
              return callback(err3);
            fs26.close(fd, (err4) => {
              if (err4)
                return callback(err4);
              fs26.stat(tmpfile, (err5, stats) => {
                if (err5)
                  return callback(err5);
                callback(null, stats.mtime > 1435410243e3);
              });
            });
          });
        });
      });
    }
    function timeRemoveMillis(timestamp) {
      if (typeof timestamp === "number") {
        return Math.floor(timestamp / 1e3) * 1e3;
      } else if (timestamp instanceof Date) {
        return new Date(Math.floor(timestamp.getTime() / 1e3) * 1e3);
      } else {
        throw new Error("fs-extra: timeRemoveMillis() unknown parameter type");
      }
    }
    function utimesMillis(path35, atime, mtime, callback) {
      fs26.open(path35, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs26.futimes(fd, atime, mtime, (futimesErr) => {
          fs26.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path35, atime, mtime) {
      const fd = fs26.openSync(path35, "r+");
      fs26.futimesSync(fd, atime, mtime);
      return fs26.closeSync(fd);
    }
    module2.exports = {
      hasMillisRes,
      hasMillisResSync,
      timeRemoveMillis,
      utimesMillis,
      utimesMillisSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/util/stat.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var NODE_VERSION_MAJOR_WITH_BIGINT = 10;
    var NODE_VERSION_MINOR_WITH_BIGINT = 5;
    var NODE_VERSION_PATCH_WITH_BIGINT = 0;
    var nodeVersion = process.versions.node.split(".");
    var nodeVersionMajor = Number.parseInt(nodeVersion[0], 10);
    var nodeVersionMinor = Number.parseInt(nodeVersion[1], 10);
    var nodeVersionPatch = Number.parseInt(nodeVersion[2], 10);
    function nodeSupportsBigInt() {
      if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {
        return true;
      } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {
        if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {
          return true;
        } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {
          if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {
            return true;
          }
        }
      }
      return false;
    }
    function getStats(src, dest, cb) {
      if (nodeSupportsBigInt()) {
        fs26.stat(src, { bigint: true }, (err, srcStat) => {
          if (err)
            return cb(err);
          fs26.stat(dest, { bigint: true }, (err2, destStat) => {
            if (err2) {
              if (err2.code === "ENOENT")
                return cb(null, { srcStat, destStat: null });
              return cb(err2);
            }
            return cb(null, { srcStat, destStat });
          });
        });
      } else {
        fs26.stat(src, (err, srcStat) => {
          if (err)
            return cb(err);
          fs26.stat(dest, (err2, destStat) => {
            if (err2) {
              if (err2.code === "ENOENT")
                return cb(null, { srcStat, destStat: null });
              return cb(err2);
            }
            return cb(null, { srcStat, destStat });
          });
        });
      }
    }
    function getStatsSync(src, dest) {
      let srcStat, destStat;
      if (nodeSupportsBigInt()) {
        srcStat = fs26.statSync(src, { bigint: true });
      } else {
        srcStat = fs26.statSync(src);
      }
      try {
        if (nodeSupportsBigInt()) {
          destStat = fs26.statSync(dest, { bigint: true });
        } else {
          destStat = fs26.statSync(dest);
        }
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, cb) {
      getStats(src, dest, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
          return cb(new Error("Source and destination must not be the same."));
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName) {
      const { srcStat, destStat } = getStatsSync(src, dest);
      if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      const srcParent = path34.resolve(path34.dirname(src));
      const destParent = path34.resolve(path34.dirname(dest));
      if (destParent === srcParent || destParent === path34.parse(destParent).root)
        return cb();
      if (nodeSupportsBigInt()) {
        fs26.stat(destParent, { bigint: true }, (err, destStat) => {
          if (err) {
            if (err.code === "ENOENT")
              return cb();
            return cb(err);
          }
          if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
            return cb(new Error(errMsg(src, dest, funcName)));
          }
          return checkParentPaths(src, srcStat, destParent, funcName, cb);
        });
      } else {
        fs26.stat(destParent, (err, destStat) => {
          if (err) {
            if (err.code === "ENOENT")
              return cb();
            return cb(err);
          }
          if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
            return cb(new Error(errMsg(src, dest, funcName)));
          }
          return checkParentPaths(src, srcStat, destParent, funcName, cb);
        });
      }
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path34.resolve(path34.dirname(src));
      const destParent = path34.resolve(path34.dirname(dest));
      if (destParent === srcParent || destParent === path34.parse(destParent).root)
        return;
      let destStat;
      try {
        if (nodeSupportsBigInt()) {
          destStat = fs26.statSync(destParent, { bigint: true });
        } else {
          destStat = fs26.statSync(destParent);
        }
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path34.resolve(src).split(path34.sep).filter((i) => i);
      const destArr = path34.resolve(dest).split(path34.sep).filter((i) => i);
      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/util/buffer.js
var require_buffer = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/util/buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = function(size) {
      if (typeof Buffer.allocUnsafe === "function") {
        try {
          return Buffer.allocUnsafe(size);
        } catch (e) {
          return new Buffer(size);
        }
      }
      return new Buffer(size);
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/copy-sync.js
var require_copy_sync = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/copy-sync.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var mkdirpSync = require_mkdirs2().mkdirsSync;
    var utimesSync = require_utimes().utimesMillisSync;
    var stat = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy");
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      return handleFilterAndCopy(destStat, src, dest, opts);
    }
    function handleFilterAndCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path34.dirname(dest);
      if (!fs26.existsSync(destParent))
        mkdirpSync(destParent);
      return startCopy(destStat, src, dest, opts);
    }
    function startCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs26.statSync : fs26.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs26.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      if (typeof fs26.copyFileSync === "function") {
        fs26.copyFileSync(src, dest);
        fs26.chmodSync(dest, srcStat.mode);
        if (opts.preserveTimestamps) {
          return utimesSync(dest, srcStat.atime, srcStat.mtime);
        }
        return;
      }
      return copyFileFallback(srcStat, src, dest, opts);
    }
    function copyFileFallback(srcStat, src, dest, opts) {
      const BUF_LENGTH = 64 * 1024;
      const _buff = require_buffer()(BUF_LENGTH);
      const fdr = fs26.openSync(src, "r");
      const fdw = fs26.openSync(dest, "w", srcStat.mode);
      let pos = 0;
      while (pos < srcStat.size) {
        const bytesRead = fs26.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
        fs26.writeSync(fdw, _buff, 0, bytesRead);
        pos += bytesRead;
      }
      if (opts.preserveTimestamps)
        fs26.futimesSync(fdw, srcStat.atime, srcStat.mtime);
      fs26.closeSync(fdr);
      fs26.closeSync(fdw);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat, src, dest, opts);
      if (destStat && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcStat, src, dest, opts) {
      fs26.mkdirSync(dest);
      copyDir(src, dest, opts);
      return fs26.chmodSync(dest, srcStat.mode);
    }
    function copyDir(src, dest, opts) {
      fs26.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path34.join(src, item);
      const destItem = path34.join(dest, item);
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy");
      return startCopy(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs26.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path34.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs26.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs26.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs26.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path34.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (fs26.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs26.unlinkSync(dest);
      return fs26.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/index.js
var require_copy_sync2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      copySync: require_copy_sync()
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs26 = require_fs();
    function pathExists(path34) {
      return fs26.access(path34).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs26.existsSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/copy/copy.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var mkdirp = require_mkdirs2().mkdirs;
    var pathExists = require_path_exists().pathExists;
    var utimes = require_utimes().utimesMillis;
    var stat = require_stat();
    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      stat.checkPaths(src, dest, "copy", (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2)
            return cb(err2);
          if (opts.filter)
            return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
          return checkParentDir(destStat, src, dest, opts, cb);
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path34.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return startCopy(destStat, src, dest, opts, cb);
        mkdirp(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return startCopy(destStat, src, dest, opts, cb);
        });
      });
    }
    function handleFilter(onInclude, destStat, src, dest, opts, cb) {
      Promise.resolve(opts.filter(src, dest)).then((include) => {
        if (include)
          return onInclude(destStat, src, dest, opts, cb);
        return cb();
      }, (error) => cb(error));
    }
    function startCopy(destStat, src, dest, opts, cb) {
      if (opts.filter)
        return handleFilter(getStats, destStat, src, dest, opts, cb);
      return getStats(destStat, src, dest, opts, cb);
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat2 = opts.dereference ? fs26.stat : fs26.lstat;
      stat2(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs26.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
      if (typeof fs26.copyFile === "function") {
        return fs26.copyFile(src, dest, (err) => {
          if (err)
            return cb(err);
          return setDestModeAndTimestamps(srcStat, dest, opts, cb);
        });
      }
      return copyFileFallback(srcStat, src, dest, opts, cb);
    }
    function copyFileFallback(srcStat, src, dest, opts, cb) {
      const rs = fs26.createReadStream(src);
      rs.on("error", (err) => cb(err)).once("open", () => {
        const ws = fs26.createWriteStream(dest, { mode: srcStat.mode });
        ws.on("error", (err) => cb(err)).on("open", () => rs.pipe(ws)).once("close", () => setDestModeAndTimestamps(srcStat, dest, opts, cb));
      });
    }
    function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
      fs26.chmod(dest, srcStat.mode, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps) {
          return utimes(dest, srcStat.atime, srcStat.mtime, cb);
        }
        return cb();
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return mkDirAndCopy(srcStat, src, dest, opts, cb);
      if (destStat && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcStat, src, dest, opts, cb) {
      fs26.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return fs26.chmod(dest, srcStat.mode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs26.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path34.join(src, item);
      const destItem = path34.join(dest, item);
      stat.checkPaths(srcItem, destItem, "copy", (err, stats) => {
        if (err)
          return cb(err);
        const { destStat } = stats;
        startCopy(destStat, srcItem, destItem, opts, (err2) => {
          if (err2)
            return cb(err2);
          return copyDirItems(items, src, dest, opts, cb);
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs26.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path34.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
          return fs26.symlink(resolvedSrc, dest, cb);
        } else {
          fs26.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs26.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path34.resolve(process.cwd(), resolvedDest);
            }
            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs26.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs26.symlink(resolvedSrc, dest, cb);
      });
    }
    module2.exports = copy;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/copy/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      copy: u(require_copy())
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/remove/rimraf.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var assert = require("assert");
    var isWindows4 = process.platform === "win32";
    function defaults2(options) {
      const methods2 = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods2.forEach((m) => {
        options[m] = options[m] || fs26[m];
        m = m + "Sync";
        options[m] = options[m] || fs26[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
    }
    function rimraf(p, options, cb) {
      let busyTries = 0;
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      defaults2(options);
      rimraf_(p, options, function CB(er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
            busyTries++;
            const time = busyTries * 100;
            return setTimeout(() => rimraf_(p, options, CB), time);
          }
          if (er.code === "ENOENT")
            er = null;
        }
        cb(er);
      });
    }
    function rimraf_(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT") {
          return cb(null);
        }
        if (er && er.code === "EPERM" && isWindows4) {
          return fixWinEPERM(p, options, er, cb);
        }
        if (st && st.isDirectory()) {
          return rmdir(p, options, er, cb);
        }
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT") {
              return cb(null);
            }
            if (er2.code === "EPERM") {
              return isWindows4 ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            }
            if (er2.code === "EISDIR") {
              return rmdir(p, options, er2, cb);
            }
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      if (er) {
        assert(er instanceof Error);
      }
      options.chmod(p, 438, (er2) => {
        if (er2) {
          cb(er2.code === "ENOENT" ? null : er);
        } else {
          options.stat(p, (er3, stats) => {
            if (er3) {
              cb(er3.code === "ENOENT" ? null : er);
            } else if (stats.isDirectory()) {
              rmdir(p, options, er, cb);
            } else {
              options.unlink(p, cb);
            }
          });
        }
      });
    }
    function fixWinEPERMSync(p, options, er) {
      let stats;
      assert(p);
      assert(options);
      if (er) {
        assert(er instanceof Error);
      }
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      if (stats.isDirectory()) {
        rmdirSync(p, options, er);
      } else {
        options.unlinkSync(p);
      }
    }
    function rmdir(p, options, originalEr, cb) {
      assert(p);
      assert(options);
      if (originalEr) {
        assert(originalEr instanceof Error);
      }
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
          rmkids(p, options, cb);
        } else if (er && er.code === "ENOTDIR") {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }
    function rmkids(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        let errState;
        if (n === 0)
          return options.rmdir(p, cb);
        files.forEach((f) => {
          rimraf(path34.join(p, f), options, (er2) => {
            if (errState) {
              return;
            }
            if (er2)
              return cb(errState = er2);
            if (--n === 0) {
              options.rmdir(p, cb);
            }
          });
        });
      });
    }
    function rimrafSync(p, options) {
      let st;
      options = options || {};
      defaults2(options);
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      try {
        st = options.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        }
        if (er.code === "EPERM" && isWindows4) {
          fixWinEPERMSync(p, options, er);
        }
      }
      try {
        if (st && st.isDirectory()) {
          rmdirSync(p, options, null);
        } else {
          options.unlinkSync(p);
        }
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        } else if (er.code === "EPERM") {
          return isWindows4 ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
        } else if (er.code !== "EISDIR") {
          throw er;
        }
        rmdirSync(p, options, er);
      }
    }
    function rmdirSync(p, options, originalEr) {
      assert(p);
      assert(options);
      if (originalEr) {
        assert(originalEr instanceof Error);
      }
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOTDIR") {
          throw originalEr;
        } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
          rmkidsSync(p, options);
        } else if (er.code !== "ENOENT") {
          throw er;
        }
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path34.join(p, f), options));
      if (isWindows4) {
        const startTime = Date.now();
        do {
          try {
            const ret = options.rmdirSync(p, options);
            return ret;
          } catch (er) {
          }
        } while (Date.now() - startTime < 500);
      } else {
        const ret = options.rmdirSync(p, options);
        return ret;
      }
    }
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/remove/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var rimraf = require_rimraf();
    module2.exports = {
      remove: u(rimraf),
      removeSync: rimraf.sync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/empty/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var mkdir = require_mkdirs2();
    var remove = require_remove();
    var emptyDir = u(function emptyDir2(dir, callback) {
      callback = callback || function() {
      };
      fs26.readdir(dir, (err, items) => {
        if (err)
          return mkdir.mkdirs(dir, callback);
        items = items.map((item) => path34.join(dir, item));
        deleteItem();
        function deleteItem() {
          const item = items.pop();
          if (!item)
            return callback();
          remove.remove(item, (err2) => {
            if (err2)
              return callback(err2);
            deleteItem();
          });
        }
      });
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs26.readdirSync(dir);
      } catch (err) {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path34.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/file.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path34 = require("path");
    var fs26 = require_graceful_fs();
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    function createFile(file, callback) {
      function makeFile() {
        fs26.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs26.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path34.dirname(file);
        pathExists(dir, (err2, dirExists) => {
          if (err2)
            return callback(err2);
          if (dirExists)
            return makeFile();
          mkdir.mkdirs(dir, (err3) => {
            if (err3)
              return callback(err3);
            makeFile();
          });
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs26.statSync(file);
      } catch (e) {
      }
      if (stats && stats.isFile())
        return;
      const dir = path34.dirname(file);
      if (!fs26.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      fs26.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/link.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path34 = require("path");
    var fs26 = require_graceful_fs();
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs26.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        fs26.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureLink");
            return callback(err2);
          }
          const dir = path34.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir.mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      const destinationExists = fs26.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      try {
        fs26.lstatSync(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path34.dirname(dstpath);
      const dirExists = fs26.existsSync(dir);
      if (dirExists)
        return fs26.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs26.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports2, module2) {
    "use strict";
    var path34 = require("path");
    var fs26 = require_graceful_fs();
    var pathExists = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path34.isAbsolute(srcpath)) {
        return fs26.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            "toCwd": srcpath,
            "toDst": srcpath
          });
        });
      } else {
        const dstdir = path34.dirname(dstpath);
        const relativeToDst = path34.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists) => {
          if (err)
            return callback(err);
          if (exists) {
            return callback(null, {
              "toCwd": relativeToDst,
              "toDst": srcpath
            });
          } else {
            return fs26.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                "toCwd": srcpath,
                "toDst": path34.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path34.isAbsolute(srcpath)) {
        exists = fs26.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          "toCwd": srcpath,
          "toDst": srcpath
        };
      } else {
        const dstdir = path34.dirname(dstpath);
        const relativeToDst = path34.join(dstdir, srcpath);
        exists = fs26.existsSync(relativeToDst);
        if (exists) {
          return {
            "toCwd": relativeToDst,
            "toDst": srcpath
          };
        } else {
          exists = fs26.existsSync(srcpath);
          if (!exists)
            throw new Error("relative srcpath does not exist");
          return {
            "toCwd": srcpath,
            "toDst": path34.relative(dstdir, srcpath)
          };
        }
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type)
        return callback(null, type);
      fs26.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs26.lstatSync(srcpath);
      } catch (e) {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path34 = require("path");
    var fs26 = require_graceful_fs();
    var _mkdirs = require_mkdirs2();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists().pathExists;
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        symlinkPaths(srcpath, dstpath, (err2, relative) => {
          if (err2)
            return callback(err2);
          srcpath = relative.toDst;
          symlinkType(relative.toCwd, type, (err3, type2) => {
            if (err3)
              return callback(err3);
            const dir = path34.dirname(dstpath);
            pathExists(dir, (err4, dirExists) => {
              if (err4)
                return callback(err4);
              if (dirExists)
                return fs26.symlink(srcpath, dstpath, type2, callback);
              mkdirs(dir, (err5) => {
                if (err5)
                  return callback(err5);
                fs26.symlink(srcpath, dstpath, type2, callback);
              });
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      const destinationExists = fs26.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path34.dirname(dstpath);
      const exists = fs26.existsSync(dir);
      if (exists)
        return fs26.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs26.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/index.js"(exports2, module2) {
    "use strict";
    var file = require_file();
    var link = require_link();
    var symlink = require_symlink();
    module2.exports = {
      createFile: file.createFile,
      createFileSync: file.createFileSync,
      ensureFile: file.createFile,
      ensureFileSync: file.createFileSync,
      createLink: link.createLink,
      createLinkSync: link.createLinkSync,
      ensureLink: link.createLink,
      ensureLinkSync: link.createLinkSync,
      createSymlink: symlink.createSymlink,
      createSymlinkSync: symlink.createSymlinkSync,
      ensureSymlink: symlink.createSymlink,
      ensureSymlinkSync: symlink.createSymlinkSync
    };
  }
});

// node_modules/streamroller/node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "node_modules/streamroller/node_modules/jsonfile/index.js"(exports2, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = require("fs");
    }
    function readFile2(file, options, callback) {
      if (callback == null) {
        callback = options;
        options = {};
      }
      if (typeof options === "string") {
        options = { encoding: options };
      }
      options = options || {};
      var fs26 = options.fs || _fs;
      var shouldThrow = true;
      if ("throws" in options) {
        shouldThrow = options.throws;
      }
      fs26.readFile(file, options, function(err, data) {
        if (err)
          return callback(err);
        data = stripBom(data);
        var obj;
        try {
          obj = JSON.parse(data, options ? options.reviver : null);
        } catch (err2) {
          if (shouldThrow) {
            err2.message = file + ": " + err2.message;
            return callback(err2);
          } else {
            return callback(null, null);
          }
        }
        callback(null, obj);
      });
    }
    function readFileSync(file, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { encoding: options };
      }
      var fs26 = options.fs || _fs;
      var shouldThrow = true;
      if ("throws" in options) {
        shouldThrow = options.throws;
      }
      try {
        var content = fs26.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = file + ": " + err.message;
          throw err;
        } else {
          return null;
        }
      }
    }
    function stringify3(obj, options) {
      var spaces;
      var EOL2 = "\n";
      if (typeof options === "object" && options !== null) {
        if (options.spaces) {
          spaces = options.spaces;
        }
        if (options.EOL) {
          EOL2 = options.EOL;
        }
      }
      var str = JSON.stringify(obj, options ? options.replacer : null, spaces);
      return str.replace(/\n/g, EOL2) + EOL2;
    }
    function writeFile2(file, obj, options, callback) {
      if (callback == null) {
        callback = options;
        options = {};
      }
      options = options || {};
      var fs26 = options.fs || _fs;
      var str = "";
      try {
        str = stringify3(obj, options);
      } catch (err) {
        if (callback)
          callback(err, null);
        return;
      }
      fs26.writeFile(file, str, options, callback);
    }
    function writeFileSync(file, obj, options) {
      options = options || {};
      var fs26 = options.fs || _fs;
      var str = stringify3(obj, options);
      return fs26.writeFileSync(file, str, options);
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      content = content.replace(/^\uFEFF/, "");
      return content;
    }
    var jsonfile = {
      readFile: readFile2,
      readFileSync,
      writeFile: writeFile2,
      writeFileSync
    };
    module2.exports = jsonfile;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/json/jsonfile.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var jsonFile = require_jsonfile();
    module2.exports = {
      readJson: u(jsonFile.readFile),
      readJsonSync: jsonFile.readFileSync,
      writeJson: u(jsonFile.writeFile),
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/json/output-json.js"(exports2, module2) {
    "use strict";
    var path34 = require("path");
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    var jsonFile = require_jsonfile2();
    function outputJson(file, data, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      const dir = path34.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return jsonFile.writeJson(file, data, options, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          jsonFile.writeJson(file, data, options, callback);
        });
      });
    }
    module2.exports = outputJson;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/json/output-json-sync.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var mkdir = require_mkdirs2();
    var jsonFile = require_jsonfile2();
    function outputJsonSync(file, data, options) {
      const dir = path34.dirname(file);
      if (!fs26.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      jsonFile.writeJsonSync(file, data, options);
    }
    module2.exports = outputJsonSync;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/json/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/move-sync/move-sync.js
var require_move_sync = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/move-sync/move-sync.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var copySync = require_copy_sync2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs2().mkdirpSync;
    var stat = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat } = stat.checkPathsSync(src, dest, "move");
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      mkdirpSync(path34.dirname(dest));
      return doRename(src, dest, overwrite);
    }
    function doRename(src, dest, overwrite) {
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs26.existsSync(dest))
        throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs26.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/move-sync/index.js
var require_move_sync2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/move-sync/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      moveSync: require_move_sync()
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/move/move.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var copy = require_copy2().copy;
    var remove = require_remove().remove;
    var mkdirp = require_mkdirs2().mkdirp;
    var pathExists = require_path_exists().pathExists;
    var stat = require_stat();
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const overwrite = opts.overwrite || opts.clobber || false;
      stat.checkPaths(src, dest, "move", (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2)
            return cb(err2);
          mkdirp(path34.dirname(dest), (err3) => {
            if (err3)
              return cb(err3);
            return doRename(src, dest, overwrite, cb);
          });
        });
      });
    }
    function doRename(src, dest, overwrite, cb) {
      if (overwrite) {
        return remove(dest, (err) => {
          if (err)
            return cb(err);
          return rename(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename(src, dest, overwrite, cb);
      });
    }
    function rename(src, dest, overwrite, cb) {
      fs26.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copy(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove(src, cb);
      });
    }
    module2.exports = move;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/move/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      move: u(require_move())
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/output/index.js
var require_output = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/output/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path34.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs26.writeFile(file, data, encoding, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs26.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path34.dirname(file);
      if (fs26.existsSync(dir)) {
        return fs26.writeFileSync(file, ...args);
      }
      mkdir.mkdirsSync(dir);
      fs26.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.assign({}, require_fs(), require_copy_sync2(), require_copy2(), require_empty(), require_ensure(), require_json(), require_mkdirs2(), require_move_sync2(), require_move2(), require_output(), require_path_exists(), require_remove());
    var fs26 = require("fs");
    if (Object.getOwnPropertyDescriptor(fs26, "promises")) {
      Object.defineProperty(module2.exports, "promises", {
        get() {
          return fs26.promises;
        }
      });
    }
  }
});

// node_modules/streamroller/lib/now.js
var require_now = __commonJS({
  "node_modules/streamroller/lib/now.js"(exports2, module2) {
    module2.exports = () => new Date();
  }
});

// node_modules/streamroller/node_modules/date-format/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/streamroller/node_modules/date-format/lib/index.js"(exports2, module2) {
    "use strict";
    function padWithZeros(vNumber, width) {
      var numAsString = vNumber.toString();
      while (numAsString.length < width) {
        numAsString = "0" + numAsString;
      }
      return numAsString;
    }
    function addZero(vNumber) {
      return padWithZeros(vNumber, 2);
    }
    function offset(timezoneOffset) {
      var os11 = Math.abs(timezoneOffset);
      var h = String(Math.floor(os11 / 60));
      var m = String(os11 % 60);
      if (h.length === 1) {
        h = "0" + h;
      }
      if (m.length === 1) {
        m = "0" + m;
      }
      return timezoneOffset < 0 ? "+" + h + m : "-" + h + m;
    }
    function datePart(date, displayUTC, part) {
      return displayUTC ? date["getUTC" + part]() : date["get" + part]();
    }
    function asString(format2, date) {
      if (typeof format2 !== "string") {
        date = format2;
        format2 = module2.exports.ISO8601_FORMAT;
      }
      if (!date) {
        date = module2.exports.now();
      }
      var displayUTC = format2.indexOf("O") > -1;
      var vDay = addZero(datePart(date, displayUTC, "Date"));
      var vMonth = addZero(datePart(date, displayUTC, "Month") + 1);
      var vYearLong = addZero(datePart(date, displayUTC, "FullYear"));
      var vYearShort = addZero(vYearLong.substring(2, 4));
      var vYear = format2.indexOf("yyyy") > -1 ? vYearLong : vYearShort;
      var vHour = addZero(datePart(date, displayUTC, "Hours"));
      var vMinute = addZero(datePart(date, displayUTC, "Minutes"));
      var vSecond = addZero(datePart(date, displayUTC, "Seconds"));
      var vMillisecond = padWithZeros(datePart(date, displayUTC, "Milliseconds"), 3);
      var vTimeZone = offset(date.getTimezoneOffset());
      var formatted = format2.replace(/dd/g, vDay).replace(/MM/g, vMonth).replace(/y{1,4}/g, vYear).replace(/hh/g, vHour).replace(/mm/g, vMinute).replace(/ss/g, vSecond).replace(/SSS/g, vMillisecond).replace(/O/g, vTimeZone);
      return formatted;
    }
    function extractDateParts(pattern, str, missingValuesDate) {
      var matchers = [
        {
          pattern: /y{1,4}/,
          regexp: "\\d{1,4}",
          fn: function(date2, value) {
            date2.setFullYear(value);
          }
        },
        {
          pattern: /MM/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            date2.setMonth(value - 1);
          }
        },
        {
          pattern: /dd/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            date2.setDate(value);
          }
        },
        {
          pattern: /hh/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            date2.setHours(value);
          }
        },
        {
          pattern: /mm/,
          regexp: "\\d\\d",
          fn: function(date2, value) {
            date2.setMinutes(value);
          }
        },
        {
          pattern: /ss/,
          regexp: "\\d\\d",
          fn: function(date2, value) {
            date2.setSeconds(value);
          }
        },
        {
          pattern: /SSS/,
          regexp: "\\d\\d\\d",
          fn: function(date2, value) {
            date2.setMilliseconds(value);
          }
        },
        {
          pattern: /O/,
          regexp: "[+-]\\d{3,4}|Z",
          fn: function(date2, value) {
            if (value === "Z") {
              value = 0;
            }
            var offset2 = Math.abs(value);
            var minutes = offset2 % 100 + Math.floor(offset2 / 100) * 60;
            date2.setMinutes(date2.getMinutes() + (value > 0 ? minutes : -minutes));
          }
        }
      ];
      var parsedPattern = matchers.reduce(function(p, m) {
        if (m.pattern.test(p.regexp)) {
          m.index = p.regexp.match(m.pattern).index;
          p.regexp = p.regexp.replace(m.pattern, "(" + m.regexp + ")");
        } else {
          m.index = -1;
        }
        return p;
      }, { regexp: pattern, index: [] });
      var dateFns = matchers.filter(function(m) {
        return m.index > -1;
      });
      dateFns.sort(function(a, b) {
        return a.index - b.index;
      });
      var matcher = new RegExp(parsedPattern.regexp);
      var matches = matcher.exec(str);
      if (matches) {
        var date = missingValuesDate || module2.exports.now();
        dateFns.forEach(function(f, i) {
          f.fn(date, matches[i + 1]);
        });
        return date;
      }
      throw new Error("String '" + str + "' could not be parsed as '" + pattern + "'");
    }
    function parse5(pattern, str, missingValuesDate) {
      if (!pattern) {
        throw new Error("pattern must be supplied");
      }
      return extractDateParts(pattern, str, missingValuesDate);
    }
    function now() {
      return new Date();
    }
    module2.exports = asString;
    module2.exports.asString = asString;
    module2.exports.parse = parse5;
    module2.exports.now = now;
    module2.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS";
    module2.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO";
    module2.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS";
    module2.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";
  }
});

// node_modules/streamroller/lib/fileNameFormatter.js
var require_fileNameFormatter = __commonJS({
  "node_modules/streamroller/lib/fileNameFormatter.js"(exports2, module2) {
    var debug = require_src()("streamroller:fileNameFormatter");
    var path34 = require("path");
    var FILENAME_SEP = ".";
    var ZIP_EXT = ".gz";
    module2.exports = ({
      file,
      keepFileExt,
      needsIndex,
      alwaysIncludeDate,
      compress
    }) => {
      const dirAndName = path34.join(file.dir, file.name);
      const ext = (f) => f + file.ext;
      const index = (f, i, d) => (needsIndex || !d) && i ? f + FILENAME_SEP + i : f;
      const date = (f, i, d) => {
        return (i > 0 || alwaysIncludeDate) && d ? f + FILENAME_SEP + d : f;
      };
      const gzip = (f, i) => i && compress ? f + ZIP_EXT : f;
      const parts = keepFileExt ? [date, index, ext, gzip] : [ext, date, index, gzip];
      return ({ date: date2, index: index2 }) => {
        debug(`_formatFileName: date=${date2}, index=${index2}`);
        return parts.reduce((filename, part) => part(filename, index2, date2), dirAndName);
      };
    };
  }
});

// node_modules/streamroller/lib/fileNameParser.js
var require_fileNameParser = __commonJS({
  "node_modules/streamroller/lib/fileNameParser.js"(exports2, module2) {
    var debug = require_src()("streamroller:fileNameParser");
    var FILENAME_SEP = ".";
    var ZIP_EXT = ".gz";
    var format2 = require_lib3();
    module2.exports = ({ file, keepFileExt, pattern }) => {
      const zip = (f, p) => {
        if (f.endsWith(ZIP_EXT)) {
          debug("it is gzipped");
          p.isCompressed = true;
          return f.slice(0, -1 * ZIP_EXT.length);
        }
        return f;
      };
      const __NOT_MATCHING__ = "__NOT_MATCHING__";
      const extAtEnd = (f) => {
        if (f.startsWith(file.name) && f.endsWith(file.ext)) {
          debug("it starts and ends with the right things");
          return f.slice(file.name.length + 1, -1 * file.ext.length);
        }
        return __NOT_MATCHING__;
      };
      const extInMiddle = (f) => {
        if (f.startsWith(file.base)) {
          debug("it starts with the right things");
          return f.slice(file.base.length + 1);
        }
        return __NOT_MATCHING__;
      };
      const dateAndIndex = (f, p) => {
        const items = f.split(FILENAME_SEP);
        let indexStr = items[items.length - 1];
        debug("items: ", items, ", indexStr: ", indexStr);
        let dateStr = f;
        if (indexStr !== void 0 && indexStr.match(/^\d+$/)) {
          dateStr = f.slice(0, -1 * (indexStr.length + 1));
          debug(`dateStr is ${dateStr}`);
          if (pattern && !dateStr) {
            dateStr = indexStr;
            indexStr = "0";
          }
        } else {
          indexStr = "0";
        }
        try {
          const date = format2.parse(pattern, dateStr, new Date(0, 0));
          if (format2.asString(pattern, date) !== dateStr)
            return f;
          p.index = parseInt(indexStr, 10);
          p.date = dateStr;
          p.timestamp = date.getTime();
          return "";
        } catch (e) {
          debug(`Problem parsing ${dateStr} as ${pattern}, error was: `, e);
          return f;
        }
      };
      const index = (f, p) => {
        if (f.match(/^\d+$/)) {
          debug("it has an index");
          p.index = parseInt(f, 10);
          return "";
        }
        return f;
      };
      let parts = [
        zip,
        keepFileExt ? extAtEnd : extInMiddle,
        pattern ? dateAndIndex : index
      ];
      return (filename) => {
        let result = { filename, index: 0, isCompressed: false };
        let whatsLeftOver = parts.reduce((remains, part) => part(remains, result), filename);
        return whatsLeftOver ? null : result;
      };
    };
  }
});

// node_modules/streamroller/lib/moveAndMaybeCompressFile.js
var require_moveAndMaybeCompressFile = __commonJS({
  "node_modules/streamroller/lib/moveAndMaybeCompressFile.js"(exports2, module2) {
    var debug = require_src()("streamroller:moveAndMaybeCompressFile");
    var fs26 = require_lib2();
    var zlib = require("zlib");
    var moveAndMaybeCompressFile = async (sourceFilePath, targetFilePath, needCompress) => {
      if (sourceFilePath === targetFilePath) {
        debug(`moveAndMaybeCompressFile: source and target are the same, not doing anything`);
        return;
      }
      if (await fs26.pathExists(sourceFilePath)) {
        debug(`moveAndMaybeCompressFile: moving file from ${sourceFilePath} to ${targetFilePath} ${needCompress ? "with" : "without"} compress`);
        if (needCompress) {
          await new Promise((resolve3, reject) => {
            fs26.createReadStream(sourceFilePath).pipe(zlib.createGzip()).pipe(fs26.createWriteStream(targetFilePath)).on("finish", () => {
              debug(`moveAndMaybeCompressFile: finished compressing ${targetFilePath}, deleting ${sourceFilePath}`);
              fs26.unlink(sourceFilePath).then(resolve3).catch(() => {
                debug(`Deleting ${sourceFilePath} failed, truncating instead`);
                fs26.truncate(sourceFilePath).then(resolve3).catch(reject);
              });
            });
          });
        } else {
          debug(`moveAndMaybeCompressFile: deleting file=${targetFilePath}, renaming ${sourceFilePath} to ${targetFilePath}`);
          try {
            await fs26.move(sourceFilePath, targetFilePath, { overwrite: true });
          } catch (e) {
            debug(`moveAndMaybeCompressFile: error moving ${sourceFilePath} to ${targetFilePath}`, e);
            debug(`Trying copy+truncate instead`);
            await fs26.copy(sourceFilePath, targetFilePath, { overwrite: true });
            await fs26.truncate(sourceFilePath);
          }
        }
      }
    };
    module2.exports = moveAndMaybeCompressFile;
  }
});

// node_modules/streamroller/lib/RollingFileWriteStream.js
var require_RollingFileWriteStream = __commonJS({
  "node_modules/streamroller/lib/RollingFileWriteStream.js"(exports2, module2) {
    var debug = require_src()("streamroller:RollingFileWriteStream");
    var fs26 = require_lib2();
    var path34 = require("path");
    var newNow = require_now();
    var format2 = require_lib3();
    var { Writable } = require("stream");
    var fileNameFormatter = require_fileNameFormatter();
    var fileNameParser = require_fileNameParser();
    var moveAndMaybeCompressFile = require_moveAndMaybeCompressFile();
    var RollingFileWriteStream = class extends Writable {
      constructor(filePath, options) {
        debug(`constructor: creating RollingFileWriteStream. path=${filePath}`);
        super(options);
        this.options = this._parseOption(options);
        this.fileObject = path34.parse(filePath);
        if (this.fileObject.dir === "") {
          this.fileObject = path34.parse(path34.join(process.cwd(), filePath));
        }
        this.fileFormatter = fileNameFormatter({
          file: this.fileObject,
          alwaysIncludeDate: this.options.alwaysIncludePattern,
          needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,
          compress: this.options.compress,
          keepFileExt: this.options.keepFileExt
        });
        this.fileNameParser = fileNameParser({
          file: this.fileObject,
          keepFileExt: this.options.keepFileExt,
          pattern: this.options.pattern
        });
        this.state = {
          currentSize: 0
        };
        if (this.options.pattern) {
          this.state.currentDate = format2(this.options.pattern, newNow());
        }
        this.filename = this.fileFormatter({
          index: 0,
          date: this.state.currentDate
        });
        if (["a", "a+", "as", "as+"].includes(this.options.flags)) {
          this._setExistingSizeAndDate();
        }
        debug(`constructor: create new file ${this.filename}, state=${JSON.stringify(this.state)}`);
        this._renewWriteStream();
      }
      _setExistingSizeAndDate() {
        try {
          const stats = fs26.statSync(this.filename);
          this.state.currentSize = stats.size;
          if (this.options.pattern) {
            this.state.currentDate = format2(this.options.pattern, stats.mtime);
          }
        } catch (e) {
          return;
        }
      }
      _parseOption(rawOptions) {
        const defaultOptions2 = {
          maxSize: Number.MAX_SAFE_INTEGER,
          numToKeep: Number.MAX_SAFE_INTEGER,
          encoding: "utf8",
          mode: parseInt("0644", 8),
          flags: "a",
          compress: false,
          keepFileExt: false,
          alwaysIncludePattern: false
        };
        const options = Object.assign({}, defaultOptions2, rawOptions);
        if (options.maxSize <= 0) {
          throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);
        }
        if (options.numToKeep <= 0) {
          throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);
        }
        debug(`_parseOption: creating stream with option=${JSON.stringify(options)}`);
        return options;
      }
      _final(callback) {
        this.currentFileStream.end("", this.options.encoding, callback);
      }
      _write(chunk, encoding, callback) {
        this._shouldRoll().then(() => {
          debug(`_write: writing chunk. file=${this.currentFileStream.path} state=${JSON.stringify(this.state)} chunk=${chunk}`);
          this.currentFileStream.write(chunk, encoding, (e) => {
            this.state.currentSize += chunk.length;
            callback(e);
          });
        });
      }
      async _shouldRoll() {
        if (this._dateChanged() || this._tooBig()) {
          debug(`_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`);
          await this._roll();
        }
      }
      _dateChanged() {
        return this.state.currentDate && this.state.currentDate !== format2(this.options.pattern, newNow());
      }
      _tooBig() {
        return this.state.currentSize >= this.options.maxSize;
      }
      _roll() {
        debug(`_roll: closing the current stream`);
        return new Promise((resolve3, reject) => {
          this.currentFileStream.end("", this.options.encoding, () => {
            this._moveOldFiles().then(resolve3).catch(reject);
          });
        });
      }
      async _moveOldFiles() {
        const files = await this._getExistingFiles();
        const todaysFiles = this.state.currentDate ? files.filter((f) => f.date === this.state.currentDate) : files;
        for (let i = todaysFiles.length; i >= 0; i--) {
          debug(`_moveOldFiles: i = ${i}`);
          const sourceFilePath = this.fileFormatter({
            date: this.state.currentDate,
            index: i
          });
          const targetFilePath = this.fileFormatter({
            date: this.state.currentDate,
            index: i + 1
          });
          await moveAndMaybeCompressFile(sourceFilePath, targetFilePath, this.options.compress && i === 0);
        }
        this.state.currentSize = 0;
        this.state.currentDate = this.state.currentDate ? format2(this.options.pattern, newNow()) : null;
        debug(`_moveOldFiles: finished rolling files. state=${JSON.stringify(this.state)}`);
        this._renewWriteStream();
        await new Promise((resolve3, reject) => {
          this.currentFileStream.write("", "utf8", () => {
            this._clean().then(resolve3).catch(reject);
          });
        });
      }
      async _getExistingFiles() {
        const files = await fs26.readdir(this.fileObject.dir).catch(() => []);
        debug(`_getExistingFiles: files=${files}`);
        const existingFileDetails = files.map((n) => this.fileNameParser(n)).filter((n) => n);
        const getKey = (n) => (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;
        existingFileDetails.sort((a, b) => getKey(a) - getKey(b));
        return existingFileDetails;
      }
      _renewWriteStream() {
        fs26.ensureDirSync(this.fileObject.dir);
        const filePath = this.fileFormatter({
          date: this.state.currentDate,
          index: 0
        });
        const ops = {
          flags: this.options.flags,
          encoding: this.options.encoding,
          mode: this.options.mode
        };
        this.currentFileStream = fs26.createWriteStream(filePath, ops);
        this.currentFileStream.on("error", (e) => {
          this.emit("error", e);
        });
      }
      async _clean() {
        const existingFileDetails = await this._getExistingFiles();
        debug(`_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`);
        debug("_clean: existing files are: ", existingFileDetails);
        if (this._tooManyFiles(existingFileDetails.length)) {
          const fileNamesToRemove = existingFileDetails.slice(0, existingFileDetails.length - this.options.numToKeep - 1).map((f) => path34.format({ dir: this.fileObject.dir, base: f.filename }));
          await deleteFiles(fileNamesToRemove);
        }
      }
      _tooManyFiles(numFiles) {
        return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;
      }
    };
    var deleteFiles = (fileNames) => {
      debug(`deleteFiles: files to delete: ${fileNames}`);
      return Promise.all(fileNames.map((f) => fs26.unlink(f).catch((e) => {
        debug(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);
      })));
    };
    module2.exports = RollingFileWriteStream;
  }
});

// node_modules/streamroller/lib/RollingFileStream.js
var require_RollingFileStream = __commonJS({
  "node_modules/streamroller/lib/RollingFileStream.js"(exports2, module2) {
    var RollingFileWriteStream = require_RollingFileWriteStream();
    var RollingFileStream = class extends RollingFileWriteStream {
      constructor(filename, size, backups, options) {
        if (!options) {
          options = {};
        }
        if (size) {
          options.maxSize = size;
        }
        if (!backups) {
          backups = 1;
        }
        options.numToKeep = backups;
        super(filename, options);
        this.backups = this.options.numToKeep;
        this.size = this.options.maxSize;
      }
      get theStream() {
        return this.currentFileStream;
      }
    };
    module2.exports = RollingFileStream;
  }
});

// node_modules/streamroller/lib/DateRollingFileStream.js
var require_DateRollingFileStream = __commonJS({
  "node_modules/streamroller/lib/DateRollingFileStream.js"(exports2, module2) {
    var RollingFileWriteStream = require_RollingFileWriteStream();
    var DateRollingFileStream = class extends RollingFileWriteStream {
      constructor(filename, pattern, options) {
        if (pattern && typeof pattern === "object") {
          options = pattern;
          pattern = null;
        }
        if (!options) {
          options = {};
        }
        if (!pattern) {
          pattern = "yyyy-MM-dd";
        }
        if (options.daysToKeep) {
          options.numToKeep = options.daysToKeep;
        }
        if (pattern.startsWith(".")) {
          pattern = pattern.substring(1);
        }
        options.pattern = pattern;
        super(filename, options);
        this.mode = this.options.mode;
      }
      get theStream() {
        return this.currentFileStream;
      }
    };
    module2.exports = DateRollingFileStream;
  }
});

// node_modules/streamroller/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/streamroller/lib/index.js"(exports2, module2) {
    module2.exports = {
      RollingFileWriteStream: require_RollingFileWriteStream(),
      RollingFileStream: require_RollingFileStream(),
      DateRollingFileStream: require_DateRollingFileStream()
    };
  }
});

// node_modules/log4js/lib/appenders/file.js
var require_file2 = __commonJS({
  "node_modules/log4js/lib/appenders/file.js"(exports2, module2) {
    var debug = require_src()("log4js:file");
    var path34 = require("path");
    var streams = require_lib4();
    var os11 = require("os");
    var eol = os11.EOL;
    function openTheStream(file, fileSize, numFiles, options) {
      const stream = new streams.RollingFileStream(file, fileSize, numFiles, options);
      stream.on("error", (err) => {
        console.error("log4js.fileAppender - Writing to file %s, error happened ", file, err);
      });
      stream.on("drain", () => {
        process.emit("log4js:pause", false);
      });
      return stream;
    }
    function fileAppender(file, layout, logSize, numBackups, options, timezoneOffset) {
      file = path34.normalize(file);
      numBackups = numBackups === void 0 ? 5 : numBackups;
      numBackups = numBackups === 0 ? 1 : numBackups;
      debug("Creating file appender (", file, ", ", logSize, ", ", numBackups, ", ", options, ", ", timezoneOffset, ")");
      let writer = openTheStream(file, logSize, numBackups, options);
      const app = function(loggingEvent) {
        if (options.removeColor === true) {
          const regex = /\x1b[[0-9;]*m/g;
          loggingEvent.data = loggingEvent.data.map((d) => {
            if (typeof d === "string")
              return d.replace(regex, "");
            return d;
          });
        }
        if (!writer.write(layout(loggingEvent, timezoneOffset) + eol, "utf8")) {
          process.emit("log4js:pause", true);
        }
      };
      app.reopen = function() {
        writer.end(() => {
          writer = openTheStream(file, logSize, numBackups, options);
        });
      };
      app.sighupHandler = function() {
        debug("SIGHUP handler called.");
        app.reopen();
      };
      app.shutdown = function(complete2) {
        process.removeListener("SIGHUP", app.sighupHandler);
        writer.end("", "utf-8", complete2);
      };
      process.on("SIGHUP", app.sighupHandler);
      return app;
    }
    function configure(config, layouts) {
      let layout = layouts.basicLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      return fileAppender(config.filename, layout, config.maxLogSize, config.backups, config, config.timezoneOffset);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/dateFile.js
var require_dateFile = __commonJS({
  "node_modules/log4js/lib/appenders/dateFile.js"(exports2, module2) {
    var streams = require_lib4();
    var os11 = require("os");
    var eol = os11.EOL;
    function appender(filename, pattern, layout, options, timezoneOffset) {
      options.maxSize = options.maxLogSize;
      const logFile = new streams.DateRollingFileStream(filename, pattern, options);
      logFile.on("drain", () => {
        process.emit("log4js:pause", false);
      });
      const app = function(logEvent) {
        if (!logFile.write(layout(logEvent, timezoneOffset) + eol, "utf8")) {
          process.emit("log4js:pause", true);
        }
      };
      app.shutdown = function(complete2) {
        logFile.write("", "utf-8", () => {
          logFile.end(complete2);
        });
      };
      return app;
    }
    function configure(config, layouts) {
      let layout = layouts.basicLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      if (!config.alwaysIncludePattern) {
        config.alwaysIncludePattern = false;
      }
      return appender(config.filename, config.pattern, layout, config, config.timezoneOffset);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/fileSync.js
var require_fileSync = __commonJS({
  "node_modules/log4js/lib/appenders/fileSync.js"(exports2, module2) {
    var debug = require_src()("log4js:fileSync");
    var path34 = require("path");
    var fs26 = require("fs");
    var os11 = require("os");
    var eol = os11.EOL || "\n";
    function touchFile(file, options) {
      if (fs26.existsSync(file)) {
        return;
      }
      const id = fs26.openSync(file, options.flags, options.mode);
      fs26.closeSync(id);
    }
    var RollingFileSync = class {
      constructor(filename, size, backups, options) {
        debug("In RollingFileStream");
        function throwErrorIfArgumentsAreNotValid() {
          if (!filename || !size || size <= 0) {
            throw new Error("You must specify a filename and file size");
          }
        }
        throwErrorIfArgumentsAreNotValid();
        this.filename = filename;
        this.size = size;
        this.backups = backups || 1;
        this.options = options;
        this.currentSize = 0;
        function currentFileSize(file) {
          let fileSize = 0;
          try {
            fileSize = fs26.statSync(file).size;
          } catch (e) {
            touchFile(file, options);
          }
          return fileSize;
        }
        this.currentSize = currentFileSize(this.filename);
      }
      shouldRoll() {
        debug("should roll with current size %d, and max size %d", this.currentSize, this.size);
        return this.currentSize >= this.size;
      }
      roll(filename) {
        const that = this;
        const nameMatcher = new RegExp(`^${path34.basename(filename)}`);
        function justTheseFiles(item) {
          return nameMatcher.test(item);
        }
        function index(filename_) {
          return parseInt(filename_.substring(`${path34.basename(filename)}.`.length), 10) || 0;
        }
        function byIndex(a, b) {
          if (index(a) > index(b)) {
            return 1;
          }
          if (index(a) < index(b)) {
            return -1;
          }
          return 0;
        }
        function increaseFileIndex(fileToRename) {
          const idx = index(fileToRename);
          debug(`Index of ${fileToRename} is ${idx}`);
          if (idx < that.backups) {
            try {
              fs26.unlinkSync(`${filename}.${idx + 1}`);
            } catch (e) {
            }
            debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);
            fs26.renameSync(path34.join(path34.dirname(filename), fileToRename), `${filename}.${idx + 1}`);
          }
        }
        function renameTheFiles() {
          debug("Renaming the old files");
          const files = fs26.readdirSync(path34.dirname(filename));
          files.filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);
        }
        debug("Rolling, rolling, rolling");
        renameTheFiles();
      }
      write(chunk, encoding) {
        const that = this;
        function writeTheChunk() {
          debug("writing the chunk to the file");
          that.currentSize += chunk.length;
          fs26.appendFileSync(that.filename, chunk);
        }
        debug("in write");
        if (this.shouldRoll()) {
          this.currentSize = 0;
          this.roll(this.filename);
        }
        writeTheChunk();
      }
    };
    function fileAppender(file, layout, logSize, numBackups, timezoneOffset, options) {
      debug("fileSync appender created");
      file = path34.normalize(file);
      numBackups = numBackups === void 0 ? 5 : numBackups;
      numBackups = numBackups === 0 ? 1 : numBackups;
      function openTheStream(filePath, fileSize, numFiles) {
        let stream;
        if (fileSize) {
          stream = new RollingFileSync(filePath, fileSize, numFiles, options);
        } else {
          stream = ((f) => {
            touchFile(f, options);
            return {
              write(data) {
                fs26.appendFileSync(f, data);
              }
            };
          })(filePath);
        }
        return stream;
      }
      const logFile = openTheStream(file, logSize, numBackups);
      return (loggingEvent) => {
        logFile.write(layout(loggingEvent, timezoneOffset) + eol);
      };
    }
    function configure(config, layouts) {
      let layout = layouts.basicLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      const options = {
        flags: config.flags || "a",
        encoding: config.encoding || "utf8",
        mode: config.mode || 420
      };
      return fileAppender(config.filename, layout, config.maxLogSize, config.backups, config.timezoneOffset, options);
    }
    module2.exports.configure = configure;
  }
});

// env-ns:node_modules/log4js/lib/appenders
var require_appenders = __commonJS({
  "env-ns:node_modules/log4js/lib/appenders"(exports2, module2) {
    var path34 = require("path");
    var debug = require_src()("log4js:appenders");
    var configuration = require_configuration();
    var clustering = require_clustering();
    var levels = require_levels();
    var layouts = require_layouts();
    var adapters = require_adapters();
    var coreAppenders = new Map();
    coreAppenders.set("console", require_console());
    coreAppenders.set("stdout", require_stdout());
    coreAppenders.set("stderr", require_stderr());
    coreAppenders.set("logLevelFilter", require_logLevelFilter());
    coreAppenders.set("categoryFilter", require_categoryFilter());
    coreAppenders.set("noLogFilter", require_noLogFilter());
    coreAppenders.set("file", require_file2());
    coreAppenders.set("dateFile", require_dateFile());
    coreAppenders.set("fileSync", require_fileSync());
    var appenders = new Map();
    var tryLoading = (modulePath, config) => {
      debug("Loading module from ", modulePath);
      try {
        return require(modulePath);
      } catch (e) {
        configuration.throwExceptionIf(config, e.code !== "MODULE_NOT_FOUND", `appender "${modulePath}" could not be loaded (error was: ${e})`);
        return void 0;
      }
    };
    var loadAppenderModule = (type, config) => coreAppenders.get(type) || tryLoading(`./${type}`, config) || tryLoading(type, config) || "" || tryLoading(path34.join(process.cwd(), type), config);
    var appendersLoading = new Set();
    var getAppender = (name2, config) => {
      if (appenders.has(name2))
        return appenders.get(name2);
      if (!config.appenders[name2])
        return false;
      if (appendersLoading.has(name2))
        throw new Error(`Dependency loop detected for appender ${name2}.`);
      appendersLoading.add(name2);
      debug(`Creating appender ${name2}`);
      const appender = createAppender(name2, config);
      appendersLoading.delete(name2);
      appenders.set(name2, appender);
      return appender;
    };
    var createAppender = (name2, config) => {
      const appenderConfig = config.appenders[name2];
      const appenderModule = appenderConfig.type.configure ? appenderConfig.type : loadAppenderModule(appenderConfig.type, config);
      configuration.throwExceptionIf(config, configuration.not(appenderModule), `appender "${name2}" is not valid (type "${appenderConfig.type}" could not be found)`);
      if (appenderModule.appender) {
        debug(`DEPRECATION: Appender ${appenderConfig.type} exports an appender function.`);
      }
      if (appenderModule.shutdown) {
        debug(`DEPRECATION: Appender ${appenderConfig.type} exports a shutdown function.`);
      }
      debug(`${name2}: clustering.isMaster ? ${clustering.isMaster()}`);
      debug(`${name2}: appenderModule is ${require("util").inspect(appenderModule)}`);
      return clustering.onlyOnMaster(() => {
        debug(`calling appenderModule.configure for ${name2} / ${appenderConfig.type}`);
        return appenderModule.configure(adapters.modifyConfig(appenderConfig), layouts, (appender) => getAppender(appender, config), levels);
      }, () => {
      });
    };
    var setup = (config) => {
      appenders.clear();
      appendersLoading.clear();
      const usedAppenders = [];
      Object.values(config.categories).forEach((category) => {
        usedAppenders.push(...category.appenders);
      });
      Object.keys(config.appenders).forEach((name2) => {
        if (usedAppenders.includes(name2) || config.appenders[name2].type === "tcp-server") {
          getAppender(name2, config);
        }
      });
    };
    setup({ appenders: { out: { type: "stdout" } }, categories: { default: { appenders: ["out"], level: "trace" } } });
    configuration.addListener((config) => {
      configuration.throwExceptionIf(config, configuration.not(configuration.anObject(config.appenders)), 'must have a property "appenders" of type object.');
      const appenderNames = Object.keys(config.appenders);
      configuration.throwExceptionIf(config, configuration.not(appenderNames.length), "must define at least one appender.");
      appenderNames.forEach((name2) => {
        configuration.throwExceptionIf(config, configuration.not(config.appenders[name2].type), `appender "${name2}" is not valid (must be an object with property "type")`);
      });
    });
    configuration.addListener(setup);
    module2.exports = appenders;
  }
});

// node_modules/log4js/lib/categories.js
var require_categories = __commonJS({
  "node_modules/log4js/lib/categories.js"(exports2, module2) {
    var debug = require_src()("log4js:categories");
    var configuration = require_configuration();
    var levels = require_levels();
    var appenders = require_appenders();
    var categories = new Map();
    function inheritFromParent(config, category, categoryName) {
      if (category.inherit === false)
        return;
      const lastDotIndex = categoryName.lastIndexOf(".");
      if (lastDotIndex < 0)
        return;
      const parentCategoryName = categoryName.substring(0, lastDotIndex);
      let parentCategory = config.categories[parentCategoryName];
      if (!parentCategory) {
        parentCategory = { inherit: true, appenders: [] };
      }
      inheritFromParent(config, parentCategory, parentCategoryName);
      if (!config.categories[parentCategoryName] && parentCategory.appenders && parentCategory.appenders.length && parentCategory.level) {
        config.categories[parentCategoryName] = parentCategory;
      }
      category.appenders = category.appenders || [];
      category.level = category.level || parentCategory.level;
      parentCategory.appenders.forEach((ap) => {
        if (!category.appenders.includes(ap)) {
          category.appenders.push(ap);
        }
      });
      category.parent = parentCategory;
    }
    function addCategoryInheritance(config) {
      if (!config.categories)
        return;
      const categoryNames = Object.keys(config.categories);
      categoryNames.forEach((name2) => {
        const category = config.categories[name2];
        inheritFromParent(config, category, name2);
      });
    }
    configuration.addPreProcessingListener((config) => addCategoryInheritance(config));
    configuration.addListener((config) => {
      configuration.throwExceptionIf(config, configuration.not(configuration.anObject(config.categories)), 'must have a property "categories" of type object.');
      const categoryNames = Object.keys(config.categories);
      configuration.throwExceptionIf(config, configuration.not(categoryNames.length), "must define at least one category.");
      categoryNames.forEach((name2) => {
        const category = config.categories[name2];
        configuration.throwExceptionIf(config, [
          configuration.not(category.appenders),
          configuration.not(category.level)
        ], `category "${name2}" is not valid (must be an object with properties "appenders" and "level")`);
        configuration.throwExceptionIf(config, configuration.not(Array.isArray(category.appenders)), `category "${name2}" is not valid (appenders must be an array of appender names)`);
        configuration.throwExceptionIf(config, configuration.not(category.appenders.length), `category "${name2}" is not valid (appenders must contain at least one appender name)`);
        if (Object.prototype.hasOwnProperty.call(category, "enableCallStack")) {
          configuration.throwExceptionIf(config, typeof category.enableCallStack !== "boolean", `category "${name2}" is not valid (enableCallStack must be boolean type)`);
        }
        category.appenders.forEach((appender) => {
          configuration.throwExceptionIf(config, configuration.not(appenders.get(appender)), `category "${name2}" is not valid (appender "${appender}" is not defined)`);
        });
        configuration.throwExceptionIf(config, configuration.not(levels.getLevel(category.level)), `category "${name2}" is not valid (level "${category.level}" not recognised; valid levels are ${levels.levels.join(", ")})`);
      });
      configuration.throwExceptionIf(config, configuration.not(config.categories.default), 'must define a "default" category.');
    });
    var setup = (config) => {
      categories.clear();
      const categoryNames = Object.keys(config.categories);
      categoryNames.forEach((name2) => {
        const category = config.categories[name2];
        const categoryAppenders = [];
        category.appenders.forEach((appender) => {
          categoryAppenders.push(appenders.get(appender));
          debug(`Creating category ${name2}`);
          categories.set(name2, {
            appenders: categoryAppenders,
            level: levels.getLevel(category.level),
            enableCallStack: category.enableCallStack || false
          });
        });
      });
    };
    setup({ categories: { default: { appenders: ["out"], level: "OFF" } } });
    configuration.addListener(setup);
    var configForCategory = (category) => {
      debug(`configForCategory: searching for config for ${category}`);
      if (categories.has(category)) {
        debug(`configForCategory: ${category} exists in config, returning it`);
        return categories.get(category);
      }
      if (category.indexOf(".") > 0) {
        debug(`configForCategory: ${category} has hierarchy, searching for parents`);
        return configForCategory(category.substring(0, category.lastIndexOf(".")));
      }
      debug("configForCategory: returning config for default category");
      return configForCategory("default");
    };
    var appendersForCategory = (category) => configForCategory(category).appenders;
    var getLevelForCategory = (category) => configForCategory(category).level;
    var setLevelForCategory = (category, level) => {
      let categoryConfig = categories.get(category);
      debug(`setLevelForCategory: found ${categoryConfig} for ${category}`);
      if (!categoryConfig) {
        const sourceCategoryConfig = configForCategory(category);
        debug(`setLevelForCategory: no config found for category, found ${sourceCategoryConfig} for parents of ${category}`);
        categoryConfig = { appenders: sourceCategoryConfig.appenders };
      }
      categoryConfig.level = level;
      categories.set(category, categoryConfig);
    };
    var getEnableCallStackForCategory = (category) => configForCategory(category).enableCallStack === true;
    var setEnableCallStackForCategory = (category, useCallStack) => {
      configForCategory(category).enableCallStack = useCallStack;
    };
    module2.exports = {
      appendersForCategory,
      getLevelForCategory,
      setLevelForCategory,
      getEnableCallStackForCategory,
      setEnableCallStackForCategory
    };
  }
});

// node_modules/log4js/lib/logger.js
var require_logger = __commonJS({
  "node_modules/log4js/lib/logger.js"(exports2, module2) {
    var debug = require_src()("log4js:logger");
    var LoggingEvent = require_LoggingEvent();
    var levels = require_levels();
    var clustering = require_clustering();
    var categories = require_categories();
    var configuration = require_configuration();
    var stackReg = /at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/;
    function defaultParseCallStack(data, skipIdx = 4) {
      const stacklines = data.stack.split("\n").slice(skipIdx);
      const lineMatch = stackReg.exec(stacklines[0]);
      if (lineMatch && lineMatch.length === 6) {
        return {
          functionName: lineMatch[1],
          fileName: lineMatch[2],
          lineNumber: parseInt(lineMatch[3], 10),
          columnNumber: parseInt(lineMatch[4], 10),
          callStack: stacklines.join("\n")
        };
      }
      return null;
    }
    var Logger2 = class {
      constructor(name2) {
        if (!name2) {
          throw new Error("No category provided.");
        }
        this.category = name2;
        this.context = {};
        this.parseCallStack = defaultParseCallStack;
        debug(`Logger created (${this.category}, ${this.level})`);
      }
      get level() {
        return levels.getLevel(categories.getLevelForCategory(this.category), levels.TRACE);
      }
      set level(level) {
        categories.setLevelForCategory(this.category, levels.getLevel(level, this.level));
      }
      get useCallStack() {
        return categories.getEnableCallStackForCategory(this.category);
      }
      set useCallStack(bool) {
        categories.setEnableCallStackForCategory(this.category, bool === true);
      }
      log(level, ...args) {
        const logLevel = levels.getLevel(level, levels.INFO);
        if (this.isLevelEnabled(logLevel)) {
          this._log(logLevel, args);
        }
      }
      isLevelEnabled(otherLevel) {
        return this.level.isLessThanOrEqualTo(otherLevel);
      }
      _log(level, data) {
        debug(`sending log data (${level}) to appenders`);
        const loggingEvent = new LoggingEvent(this.category, level, data, this.context, this.useCallStack && this.parseCallStack(new Error()));
        clustering.send(loggingEvent);
      }
      addContext(key, value) {
        this.context[key] = value;
      }
      removeContext(key) {
        delete this.context[key];
      }
      clearContext() {
        this.context = {};
      }
      setParseCallStackFunction(parseFunction) {
        this.parseCallStack = parseFunction;
      }
    };
    function addLevelMethods(target) {
      const level = levels.getLevel(target);
      const levelStrLower = level.toString().toLowerCase();
      const levelMethod = levelStrLower.replace(/_([a-z])/g, (g) => g[1].toUpperCase());
      const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);
      Logger2.prototype[`is${isLevelMethod}Enabled`] = function() {
        return this.isLevelEnabled(level);
      };
      Logger2.prototype[levelMethod] = function(...args) {
        this.log(level, ...args);
      };
    }
    levels.levels.forEach(addLevelMethods);
    configuration.addListener(() => {
      levels.levels.forEach(addLevelMethods);
    });
    module2.exports = Logger2;
  }
});

// node_modules/log4js/lib/connect-logger.js
var require_connect_logger = __commonJS({
  "node_modules/log4js/lib/connect-logger.js"(exports2, module2) {
    var levels = require_levels();
    var DEFAULT_FORMAT = ':remote-addr - - ":method :url HTTP/:http-version" :status :content-length ":referrer" ":user-agent"';
    function getUrl(req) {
      return req.originalUrl || req.url;
    }
    function assembleTokens(req, res, customTokens) {
      const arrayUniqueTokens = (array) => {
        const a = array.concat();
        for (let i = 0; i < a.length; ++i) {
          for (let j = i + 1; j < a.length; ++j) {
            if (a[i].token == a[j].token) {
              a.splice(j--, 1);
            }
          }
        }
        return a;
      };
      const defaultTokens = [];
      defaultTokens.push({ token: ":url", replacement: getUrl(req) });
      defaultTokens.push({ token: ":protocol", replacement: req.protocol });
      defaultTokens.push({ token: ":hostname", replacement: req.hostname });
      defaultTokens.push({ token: ":method", replacement: req.method });
      defaultTokens.push({
        token: ":status",
        replacement: res.__statusCode || res.statusCode
      });
      defaultTokens.push({
        token: ":response-time",
        replacement: res.responseTime
      });
      defaultTokens.push({ token: ":date", replacement: new Date().toUTCString() });
      defaultTokens.push({
        token: ":referrer",
        replacement: req.headers.referer || req.headers.referrer || ""
      });
      defaultTokens.push({
        token: ":http-version",
        replacement: `${req.httpVersionMajor}.${req.httpVersionMinor}`
      });
      defaultTokens.push({
        token: ":remote-addr",
        replacement: req.headers["x-forwarded-for"] || req.ip || req._remoteAddress || req.socket && (req.socket.remoteAddress || req.socket.socket && req.socket.socket.remoteAddress)
      });
      defaultTokens.push({
        token: ":user-agent",
        replacement: req.headers["user-agent"]
      });
      defaultTokens.push({
        token: ":content-length",
        replacement: res.getHeader("content-length") || res.__headers && res.__headers["Content-Length"] || "-"
      });
      defaultTokens.push({
        token: /:req\[([^\]]+)]/g,
        replacement(_, field) {
          return req.headers[field.toLowerCase()];
        }
      });
      defaultTokens.push({
        token: /:res\[([^\]]+)]/g,
        replacement(_, field) {
          return res.getHeader(field.toLowerCase()) || res.__headers && res.__headers[field];
        }
      });
      return arrayUniqueTokens(customTokens.concat(defaultTokens));
    }
    function format2(str, tokens) {
      for (let i = 0; i < tokens.length; i++) {
        str = str.replace(tokens[i].token, tokens[i].replacement);
      }
      return str;
    }
    function createNoLogCondition(nolog) {
      let regexp = null;
      if (nolog instanceof RegExp) {
        regexp = nolog;
      }
      if (typeof nolog === "string") {
        regexp = new RegExp(nolog);
      }
      if (Array.isArray(nolog)) {
        const regexpsAsStrings = nolog.map((reg) => reg.source ? reg.source : reg);
        regexp = new RegExp(regexpsAsStrings.join("|"));
      }
      return regexp;
    }
    function matchRules(statusCode, currentLevel, ruleSet) {
      let level = currentLevel;
      if (ruleSet) {
        const matchedRule = ruleSet.find((rule) => {
          let ruleMatched = false;
          if (rule.from && rule.to) {
            ruleMatched = statusCode >= rule.from && statusCode <= rule.to;
          } else {
            ruleMatched = rule.codes.indexOf(statusCode) !== -1;
          }
          return ruleMatched;
        });
        if (matchedRule) {
          level = levels.getLevel(matchedRule.level, level);
        }
      }
      return level;
    }
    module2.exports = function getLogger(logger4js, options) {
      if (typeof options === "string" || typeof options === "function") {
        options = { format: options };
      } else {
        options = options || {};
      }
      const thisLogger = logger4js;
      let level = levels.getLevel(options.level, levels.INFO);
      const fmt = options.format || DEFAULT_FORMAT;
      const nolog = createNoLogCondition(options.nolog);
      return (req, res, next) => {
        if (req._logging)
          return next();
        if (nolog && nolog.test(req.originalUrl))
          return next();
        if (thisLogger.isLevelEnabled(level) || options.level === "auto") {
          const start = new Date();
          const { writeHead } = res;
          req._logging = true;
          res.writeHead = (code, headers) => {
            res.writeHead = writeHead;
            res.writeHead(code, headers);
            res.__statusCode = code;
            res.__headers = headers || {};
          };
          res.on("finish", () => {
            res.responseTime = new Date() - start;
            if (res.statusCode && options.level === "auto") {
              level = levels.INFO;
              if (res.statusCode >= 300)
                level = levels.WARN;
              if (res.statusCode >= 400)
                level = levels.ERROR;
            }
            level = matchRules(res.statusCode, level, options.statusRules);
            const combinedTokens = assembleTokens(req, res, options.tokens || []);
            if (options.context)
              thisLogger.addContext("res", res);
            if (typeof fmt === "function") {
              const line = fmt(req, res, (str) => format2(str, combinedTokens));
              if (line)
                thisLogger.log(level, line);
            } else {
              thisLogger.log(level, format2(fmt, combinedTokens));
            }
            if (options.context)
              thisLogger.removeContext("res");
          });
        }
        return next();
      };
    };
  }
});

// node_modules/log4js/lib/log4js.js
var require_log4js = __commonJS({
  "node_modules/log4js/lib/log4js.js"(exports2, module2) {
    var debug = require_src()("log4js:main");
    var fs26 = require("fs");
    var deepClone2 = require_rfdc()({ proto: true });
    var configuration = require_configuration();
    var layouts = require_layouts();
    var levels = require_levels();
    var appenders = require_appenders();
    var categories = require_categories();
    var Logger2 = require_logger();
    var clustering = require_clustering();
    var connectLogger = require_connect_logger();
    var enabled = false;
    function sendLogEventToAppender(logEvent) {
      if (!enabled)
        return;
      debug("Received log event ", logEvent);
      const categoryAppenders = categories.appendersForCategory(logEvent.categoryName);
      categoryAppenders.forEach((appender) => {
        appender(logEvent);
      });
    }
    function loadConfigurationFile(filename) {
      debug(`Loading configuration from ${filename}`);
      try {
        return JSON.parse(fs26.readFileSync(filename, "utf8"));
      } catch (e) {
        throw new Error(`Problem reading config from file "${filename}". Error was ${e.message}`, e);
      }
    }
    function configure(configurationFileOrObject) {
      let configObject = configurationFileOrObject;
      if (typeof configObject === "string") {
        configObject = loadConfigurationFile(configurationFileOrObject);
      }
      debug(`Configuration is ${configObject}`);
      configuration.configure(deepClone2(configObject));
      clustering.onMessage(sendLogEventToAppender);
      enabled = true;
      return log4js2;
    }
    function shutdown(cb) {
      debug("Shutdown called. Disabling all log writing.");
      enabled = false;
      const appendersToCheck = Array.from(appenders.values());
      const shutdownFunctions = appendersToCheck.reduceRight((accum, next) => next.shutdown ? accum + 1 : accum, 0);
      let completed = 0;
      let error;
      debug(`Found ${shutdownFunctions} appenders with shutdown functions.`);
      function complete2(err) {
        error = error || err;
        completed += 1;
        debug(`Appender shutdowns complete: ${completed} / ${shutdownFunctions}`);
        if (completed >= shutdownFunctions) {
          debug("All shutdown functions completed.");
          if (cb) {
            cb(error);
          }
        }
      }
      if (shutdownFunctions === 0) {
        debug("No appenders with shutdown functions found.");
        return cb !== void 0 && cb();
      }
      appendersToCheck.filter((a) => a.shutdown).forEach((a) => a.shutdown(complete2));
      return null;
    }
    function getLogger(category) {
      if (!enabled) {
        configure(process.env.LOG4JS_CONFIG || {
          appenders: { out: { type: "stdout" } },
          categories: { default: { appenders: ["out"], level: "OFF" } }
        });
      }
      return new Logger2(category || "default");
    }
    var log4js2 = {
      getLogger,
      configure,
      shutdown,
      connectLogger,
      levels,
      addLayout: layouts.addLayout
    };
    module2.exports = log4js2;
  }
});

// node_modules/universalify/index.js
var require_universalify2 = __commonJS({
  "node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve3, reject) => {
            fn.apply(this, args.concat([(err, res) => err ? reject(err) : resolve3(res)]));
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else
          fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs2 = __commonJS({
  "node_modules/fs-extra/lib/fs/index.js"(exports2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var fs26 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs26[key] === "function";
    });
    Object.keys(fs26).forEach((key) => {
      if (key === "promises") {
        return;
      }
      exports2[key] = fs26[key];
    });
    api.forEach((method) => {
      exports2[method] = u(fs26[method]);
    });
    exports2.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs26.exists(filename, callback);
      }
      return new Promise((resolve3) => {
        return fs26.exists(filename, resolve3);
      });
    };
    exports2.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs26.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve3, reject) => {
        fs26.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve3({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports2.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs26.write(fd, buffer, ...args);
      }
      return new Promise((resolve3, reject) => {
        fs26.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve3({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    if (typeof fs26.writev === "function") {
      exports2.writev = function(fd, buffers, ...args) {
        if (typeof args[args.length - 1] === "function") {
          return fs26.writev(fd, buffers, ...args);
        }
        return new Promise((resolve3, reject) => {
          fs26.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
            if (err)
              return reject(err);
            resolve3({ bytesWritten, buffers: buffers2 });
          });
        });
      };
    }
    if (typeof fs26.realpath.native === "function") {
      exports2.realpath.native = u(fs26.realpath.native);
    }
  }
});

// node_modules/at-least-node/index.js
var require_at_least_node = __commonJS({
  "node_modules/at-least-node/index.js"(exports2, module2) {
    module2.exports = (r) => {
      const n = process.versions.node.split(".").map((x) => parseInt(x, 10));
      r = r.split(".").map((x) => parseInt(x, 10));
      return n[0] > r[0] || n[0] === r[0] && (n[1] > r[1] || n[1] === r[1] && n[2] >= r[2]);
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports2, module2) {
    "use strict";
    var fs26 = require_fs2();
    var path34 = require("path");
    var atLeastNode = require_at_least_node();
    var useNativeRecursiveOption = atLeastNode("10.12.0");
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path34.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
    var processOptions = (options) => {
      const defaults2 = { mode: 511 };
      if (typeof options === "number")
        options = { mode: options };
      return __spreadValues(__spreadValues({}, defaults2), options);
    };
    var permissionError = (pth) => {
      const error = new Error(`operation not permitted, mkdir '${pth}'`);
      error.code = "EPERM";
      error.errno = -4048;
      error.path = pth;
      error.syscall = "mkdir";
      return error;
    };
    module2.exports.makeDir = async (input, options) => {
      checkPath(input);
      options = processOptions(options);
      if (useNativeRecursiveOption) {
        const pth = path34.resolve(input);
        return fs26.mkdir(pth, {
          mode: options.mode,
          recursive: true
        });
      }
      const make = async (pth) => {
        try {
          await fs26.mkdir(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path34.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            await make(path34.dirname(pth));
            return make(pth);
          }
          try {
            const stats = await fs26.stat(pth);
            if (!stats.isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch {
            throw error;
          }
        }
      };
      return make(path34.resolve(input));
    };
    module2.exports.makeDirSync = (input, options) => {
      checkPath(input);
      options = processOptions(options);
      if (useNativeRecursiveOption) {
        const pth = path34.resolve(input);
        return fs26.mkdirSync(pth, {
          mode: options.mode,
          recursive: true
        });
      }
      const make = (pth) => {
        try {
          fs26.mkdirSync(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path34.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            make(path34.dirname(pth));
            return make(pth);
          }
          try {
            if (!fs26.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch {
            throw error;
          }
        }
      };
      return make(path34.resolve(input));
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs3 = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes2 = __commonJS({
  "node_modules/fs-extra/lib/util/utimes.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    function utimesMillis(path34, atime, mtime, callback) {
      fs26.open(path34, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs26.futimes(fd, atime, mtime, (futimesErr) => {
          fs26.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path34, atime, mtime) {
      const fd = fs26.openSync(path34, "r+");
      fs26.futimesSync(fd, atime, mtime);
      return fs26.closeSync(fd);
    }
    module2.exports = {
      utimesMillis,
      utimesMillisSync
    };
  }
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat2 = __commonJS({
  "node_modules/fs-extra/lib/util/stat.js"(exports2, module2) {
    "use strict";
    var fs26 = require_fs2();
    var path34 = require("path");
    var util4 = require("util");
    var atLeastNode = require_at_least_node();
    var nodeSupportsBigInt = atLeastNode("10.5.0");
    var stat = (file) => nodeSupportsBigInt ? fs26.stat(file, { bigint: true }) : fs26.stat(file);
    var statSync = (file) => nodeSupportsBigInt ? fs26.statSync(file, { bigint: true }) : fs26.statSync(file);
    function getStats(src, dest) {
      return Promise.all([
        stat(src),
        stat(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest) {
      let destStat;
      const srcStat = statSync(src);
      try {
        destStat = statSync(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, cb) {
      util4.callbackify(getStats)(src, dest, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat && areIdentical(srcStat, destStat)) {
          return cb(new Error("Source and destination must not be the same."));
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName) {
      const { srcStat, destStat } = getStatsSync(src, dest);
      if (destStat && areIdentical(srcStat, destStat)) {
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      const srcParent = path34.resolve(path34.dirname(src));
      const destParent = path34.resolve(path34.dirname(dest));
      if (destParent === srcParent || destParent === path34.parse(destParent).root)
        return cb();
      const callback = (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT")
            return cb();
          return cb(err);
        }
        if (areIdentical(srcStat, destStat)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      };
      if (nodeSupportsBigInt)
        fs26.stat(destParent, { bigint: true }, callback);
      else
        fs26.stat(destParent, callback);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path34.resolve(path34.dirname(src));
      const destParent = path34.resolve(path34.dirname(dest));
      if (destParent === srcParent || destParent === path34.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = statSync(destParent);
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {
          return true;
        }
        if (destStat.size === srcStat.size && destStat.mode === srcStat.mode && destStat.nlink === srcStat.nlink && destStat.atimeMs === srcStat.atimeMs && destStat.mtimeMs === srcStat.mtimeMs && destStat.ctimeMs === srcStat.ctimeMs && destStat.birthtimeMs === srcStat.birthtimeMs) {
          return true;
        }
      }
      return false;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path34.resolve(src).split(path34.sep).filter((i) => i);
      const destArr = path34.resolve(dest).split(path34.sep).filter((i) => i);
      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir
    };
  }
});

// node_modules/fs-extra/lib/copy-sync/copy-sync.js
var require_copy_sync3 = __commonJS({
  "node_modules/fs-extra/lib/copy-sync/copy-sync.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var mkdirsSync = require_mkdirs3().mkdirsSync;
    var utimesMillisSync = require_utimes2().utimesMillisSync;
    var stat = require_stat2();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy");
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      return handleFilterAndCopy(destStat, src, dest, opts);
    }
    function handleFilterAndCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path34.dirname(dest);
      if (!fs26.existsSync(destParent))
        mkdirsSync(destParent);
      return startCopy(destStat, src, dest, opts);
    }
    function startCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs26.statSync : fs26.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs26.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs26.copyFileSync(src, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs26.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs26.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      if (destStat && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs26.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs26.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path34.join(src, item);
      const destItem = path34.join(dest, item);
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy");
      return startCopy(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs26.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path34.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs26.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs26.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs26.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path34.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (fs26.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs26.unlinkSync(dest);
      return fs26.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// node_modules/fs-extra/lib/copy-sync/index.js
var require_copy_sync4 = __commonJS({
  "node_modules/fs-extra/lib/copy-sync/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      copySync: require_copy_sync3()
    };
  }
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists2 = __commonJS({
  "node_modules/fs-extra/lib/path-exists/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    var fs26 = require_fs2();
    function pathExists(path34) {
      return fs26.access(path34).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs26.existsSync
    };
  }
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy3 = __commonJS({
  "node_modules/fs-extra/lib/copy/copy.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var mkdirs = require_mkdirs3().mkdirs;
    var pathExists = require_path_exists2().pathExists;
    var utimesMillis = require_utimes2().utimesMillis;
    var stat = require_stat2();
    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      stat.checkPaths(src, dest, "copy", (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2)
            return cb(err2);
          if (opts.filter)
            return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
          return checkParentDir(destStat, src, dest, opts, cb);
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path34.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return startCopy(destStat, src, dest, opts, cb);
        mkdirs(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return startCopy(destStat, src, dest, opts, cb);
        });
      });
    }
    function handleFilter(onInclude, destStat, src, dest, opts, cb) {
      Promise.resolve(opts.filter(src, dest)).then((include) => {
        if (include)
          return onInclude(destStat, src, dest, opts, cb);
        return cb();
      }, (error) => cb(error));
    }
    function startCopy(destStat, src, dest, opts, cb) {
      if (opts.filter)
        return handleFilter(getStats, destStat, src, dest, opts, cb);
      return getStats(destStat, src, dest, opts, cb);
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat2 = opts.dereference ? fs26.stat : fs26.lstat;
      stat2(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs26.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
      fs26.copyFile(src, dest, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps)
          return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
        return setDestMode(dest, srcStat.mode, cb);
      });
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
      if (fileIsNotWritable(srcMode)) {
        return makeFileWritable(dest, srcMode, (err) => {
          if (err)
            return cb(err);
          return setDestTimestampsAndMode(srcMode, src, dest, cb);
        });
      }
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, (err) => {
        if (err)
          return cb(err);
        return setDestMode(dest, srcMode, cb);
      });
    }
    function setDestMode(dest, srcMode, cb) {
      return fs26.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
      fs26.stat(src, (err, updatedSrcStat) => {
        if (err)
          return cb(err);
        return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
      if (destStat && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
      fs26.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return setDestMode(dest, srcMode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs26.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path34.join(src, item);
      const destItem = path34.join(dest, item);
      stat.checkPaths(srcItem, destItem, "copy", (err, stats) => {
        if (err)
          return cb(err);
        const { destStat } = stats;
        startCopy(destStat, srcItem, destItem, opts, (err2) => {
          if (err2)
            return cb(err2);
          return copyDirItems(items, src, dest, opts, cb);
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs26.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path34.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
          return fs26.symlink(resolvedSrc, dest, cb);
        } else {
          fs26.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs26.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path34.resolve(process.cwd(), resolvedDest);
            }
            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs26.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs26.symlink(resolvedSrc, dest, cb);
      });
    }
    module2.exports = copy;
  }
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy4 = __commonJS({
  "node_modules/fs-extra/lib/copy/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    module2.exports = {
      copy: u(require_copy3())
    };
  }
});

// node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf2 = __commonJS({
  "node_modules/fs-extra/lib/remove/rimraf.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var assert = require("assert");
    var isWindows4 = process.platform === "win32";
    function defaults2(options) {
      const methods2 = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods2.forEach((m) => {
        options[m] = options[m] || fs26[m];
        m = m + "Sync";
        options[m] = options[m] || fs26[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
    }
    function rimraf(p, options, cb) {
      let busyTries = 0;
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      defaults2(options);
      rimraf_(p, options, function CB(er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
            busyTries++;
            const time = busyTries * 100;
            return setTimeout(() => rimraf_(p, options, CB), time);
          }
          if (er.code === "ENOENT")
            er = null;
        }
        cb(er);
      });
    }
    function rimraf_(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT") {
          return cb(null);
        }
        if (er && er.code === "EPERM" && isWindows4) {
          return fixWinEPERM(p, options, er, cb);
        }
        if (st && st.isDirectory()) {
          return rmdir(p, options, er, cb);
        }
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT") {
              return cb(null);
            }
            if (er2.code === "EPERM") {
              return isWindows4 ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            }
            if (er2.code === "EISDIR") {
              return rmdir(p, options, er2, cb);
            }
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p, 438, (er2) => {
        if (er2) {
          cb(er2.code === "ENOENT" ? null : er);
        } else {
          options.stat(p, (er3, stats) => {
            if (er3) {
              cb(er3.code === "ENOENT" ? null : er);
            } else if (stats.isDirectory()) {
              rmdir(p, options, er, cb);
            } else {
              options.unlink(p, cb);
            }
          });
        }
      });
    }
    function fixWinEPERMSync(p, options, er) {
      let stats;
      assert(p);
      assert(options);
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      if (stats.isDirectory()) {
        rmdirSync(p, options, er);
      } else {
        options.unlinkSync(p);
      }
    }
    function rmdir(p, options, originalEr, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
          rmkids(p, options, cb);
        } else if (er && er.code === "ENOTDIR") {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }
    function rmkids(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        let errState;
        if (n === 0)
          return options.rmdir(p, cb);
        files.forEach((f) => {
          rimraf(path34.join(p, f), options, (er2) => {
            if (errState) {
              return;
            }
            if (er2)
              return cb(errState = er2);
            if (--n === 0) {
              options.rmdir(p, cb);
            }
          });
        });
      });
    }
    function rimrafSync(p, options) {
      let st;
      options = options || {};
      defaults2(options);
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      try {
        st = options.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        }
        if (er.code === "EPERM" && isWindows4) {
          fixWinEPERMSync(p, options, er);
        }
      }
      try {
        if (st && st.isDirectory()) {
          rmdirSync(p, options, null);
        } else {
          options.unlinkSync(p);
        }
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        } else if (er.code === "EPERM") {
          return isWindows4 ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
        } else if (er.code !== "EISDIR") {
          throw er;
        }
        rmdirSync(p, options, er);
      }
    }
    function rmdirSync(p, options, originalEr) {
      assert(p);
      assert(options);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOTDIR") {
          throw originalEr;
        } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
          rmkidsSync(p, options);
        } else if (er.code !== "ENOENT") {
          throw er;
        }
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path34.join(p, f), options));
      if (isWindows4) {
        const startTime = Date.now();
        do {
          try {
            const ret = options.rmdirSync(p, options);
            return ret;
          } catch {
          }
        } while (Date.now() - startTime < 500);
      } else {
        const ret = options.rmdirSync(p, options);
        return ret;
      }
    }
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove2 = __commonJS({
  "node_modules/fs-extra/lib/remove/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var rimraf = require_rimraf2();
    module2.exports = {
      remove: u(rimraf),
      removeSync: rimraf.sync
    };
  }
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty2 = __commonJS({
  "node_modules/fs-extra/lib/empty/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var mkdir = require_mkdirs3();
    var remove = require_remove2();
    var emptyDir = u(function emptyDir2(dir, callback) {
      callback = callback || function() {
      };
      fs26.readdir(dir, (err, items) => {
        if (err)
          return mkdir.mkdirs(dir, callback);
        items = items.map((item) => path34.join(dir, item));
        deleteItem();
        function deleteItem() {
          const item = items.pop();
          if (!item)
            return callback();
          remove.remove(item, (err2) => {
            if (err2)
              return callback(err2);
            deleteItem();
          });
        }
      });
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs26.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path34.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file3 = __commonJS({
  "node_modules/fs-extra/lib/ensure/file.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var path34 = require("path");
    var fs26 = require_graceful_fs();
    var mkdir = require_mkdirs3();
    function createFile(file, callback) {
      function makeFile() {
        fs26.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs26.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path34.dirname(file);
        fs26.stat(dir, (err2, stats2) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return mkdir.mkdirs(dir, (err3) => {
                if (err3)
                  return callback(err3);
                makeFile();
              });
            }
            return callback(err2);
          }
          if (stats2.isDirectory())
            makeFile();
          else {
            fs26.readdir(dir, (err3) => {
              if (err3)
                return callback(err3);
            });
          }
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs26.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path34.dirname(file);
      try {
        if (!fs26.statSync(dir).isDirectory()) {
          fs26.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir.mkdirsSync(dir);
        else
          throw err;
      }
      fs26.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/link.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var path34 = require("path");
    var fs26 = require_graceful_fs();
    var mkdir = require_mkdirs3();
    var pathExists = require_path_exists2().pathExists;
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs26.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        fs26.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureLink");
            return callback(err2);
          }
          const dir = path34.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir.mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      const destinationExists = fs26.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      try {
        fs26.lstatSync(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path34.dirname(dstpath);
      const dirExists = fs26.existsSync(dir);
      if (dirExists)
        return fs26.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs26.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports2, module2) {
    "use strict";
    var path34 = require("path");
    var fs26 = require_graceful_fs();
    var pathExists = require_path_exists2().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path34.isAbsolute(srcpath)) {
        return fs26.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: srcpath
          });
        });
      } else {
        const dstdir = path34.dirname(dstpath);
        const relativeToDst = path34.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists) => {
          if (err)
            return callback(err);
          if (exists) {
            return callback(null, {
              toCwd: relativeToDst,
              toDst: srcpath
            });
          } else {
            return fs26.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: path34.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path34.isAbsolute(srcpath)) {
        exists = fs26.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      } else {
        const dstdir = path34.dirname(dstpath);
        const relativeToDst = path34.join(dstdir, srcpath);
        exists = fs26.existsSync(relativeToDst);
        if (exists) {
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          };
        } else {
          exists = fs26.existsSync(srcpath);
          if (!exists)
            throw new Error("relative srcpath does not exist");
          return {
            toCwd: srcpath,
            toDst: path34.relative(dstdir, srcpath)
          };
        }
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-type.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type)
        return callback(null, type);
      fs26.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs26.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var path34 = require("path");
    var fs26 = require_graceful_fs();
    var _mkdirs = require_mkdirs3();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths2();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type2();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists2().pathExists;
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        symlinkPaths(srcpath, dstpath, (err2, relative) => {
          if (err2)
            return callback(err2);
          srcpath = relative.toDst;
          symlinkType(relative.toCwd, type, (err3, type2) => {
            if (err3)
              return callback(err3);
            const dir = path34.dirname(dstpath);
            pathExists(dir, (err4, dirExists) => {
              if (err4)
                return callback(err4);
              if (dirExists)
                return fs26.symlink(srcpath, dstpath, type2, callback);
              mkdirs(dir, (err5) => {
                if (err5)
                  return callback(err5);
                fs26.symlink(srcpath, dstpath, type2, callback);
              });
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      const destinationExists = fs26.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path34.dirname(dstpath);
      const exists = fs26.existsSync(dir);
      if (exists)
        return fs26.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs26.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/index.js"(exports2, module2) {
    "use strict";
    var file = require_file3();
    var link = require_link2();
    var symlink = require_symlink2();
    module2.exports = {
      createFile: file.createFile,
      createFileSync: file.createFileSync,
      ensureFile: file.createFile,
      ensureFileSync: file.createFileSync,
      createLink: link.createLink,
      createLinkSync: link.createLinkSync,
      ensureLink: link.createLink,
      ensureLinkSync: link.createLinkSync,
      createSymlink: symlink.createSymlink,
      createSymlinkSync: symlink.createSymlinkSync,
      ensureSymlink: symlink.createSymlink,
      ensureSymlinkSync: symlink.createSymlinkSync
    };
  }
});

// node_modules/jsonfile/node_modules/universalify/index.js
var require_universalify3 = __commonJS({
  "node_modules/jsonfile/node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve3, reject) => {
            fn.call(this, ...args, (err, res) => err != null ? reject(err) : resolve3(res));
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else
          fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/jsonfile/utils.js
var require_utils = __commonJS({
  "node_modules/jsonfile/utils.js"(exports2, module2) {
    function stringify3(obj, { EOL: EOL2 = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL2 : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL2) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify: stringify3, stripBom };
  }
});

// node_modules/jsonfile/index.js
var require_jsonfile3 = __commonJS({
  "node_modules/jsonfile/index.js"(exports2, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = require("fs");
    }
    var universalify = require_universalify3();
    var { stringify: stringify3, stripBom } = require_utils();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs26 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs26.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile2 = universalify.fromPromise(_readFile);
    function readFileSync(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs26 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs26.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs26 = options.fs || _fs;
      const str = stringify3(obj, options);
      await universalify.fromCallback(fs26.writeFile)(file, str, options);
    }
    var writeFile2 = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
      const fs26 = options.fs || _fs;
      const str = stringify3(obj, options);
      return fs26.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile: readFile2,
      readFileSync,
      writeFile: writeFile2,
      writeFileSync
    };
    module2.exports = jsonfile;
  }
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile4 = __commonJS({
  "node_modules/fs-extra/lib/json/jsonfile.js"(exports2, module2) {
    "use strict";
    var jsonFile = require_jsonfile3();
    module2.exports = {
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/fs-extra/lib/output/index.js
var require_output2 = __commonJS({
  "node_modules/fs-extra/lib/output/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var mkdir = require_mkdirs3();
    var pathExists = require_path_exists2().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path34.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs26.writeFile(file, data, encoding, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs26.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path34.dirname(file);
      if (fs26.existsSync(dir)) {
        return fs26.writeFileSync(file, ...args);
      }
      mkdir.mkdirsSync(dir);
      fs26.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json2 = __commonJS({
  "node_modules/fs-extra/lib/json/output-json.js"(exports2, module2) {
    "use strict";
    var { stringify: stringify3 } = require_utils();
    var { outputFile } = require_output2();
    async function outputJson(file, data, options = {}) {
      const str = stringify3(data, options);
      await outputFile(file, str, options);
    }
    module2.exports = outputJson;
  }
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync2 = __commonJS({
  "node_modules/fs-extra/lib/json/output-json-sync.js"(exports2, module2) {
    "use strict";
    var { stringify: stringify3 } = require_utils();
    var { outputFileSync } = require_output2();
    function outputJsonSync(file, data, options) {
      const str = stringify3(data, options);
      outputFileSync(file, str, options);
    }
    module2.exports = outputJsonSync;
  }
});

// node_modules/fs-extra/lib/json/index.js
var require_json2 = __commonJS({
  "node_modules/fs-extra/lib/json/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    var jsonFile = require_jsonfile4();
    jsonFile.outputJson = u(require_output_json2());
    jsonFile.outputJsonSync = require_output_json_sync2();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// node_modules/fs-extra/lib/move-sync/move-sync.js
var require_move_sync3 = __commonJS({
  "node_modules/fs-extra/lib/move-sync/move-sync.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var copySync = require_copy_sync4().copySync;
    var removeSync = require_remove2().removeSync;
    var mkdirpSync = require_mkdirs3().mkdirpSync;
    var stat = require_stat2();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat } = stat.checkPathsSync(src, dest, "move");
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      mkdirpSync(path34.dirname(dest));
      return doRename(src, dest, overwrite);
    }
    function doRename(src, dest, overwrite) {
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs26.existsSync(dest))
        throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs26.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// node_modules/fs-extra/lib/move-sync/index.js
var require_move_sync4 = __commonJS({
  "node_modules/fs-extra/lib/move-sync/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      moveSync: require_move_sync3()
    };
  }
});

// node_modules/fs-extra/lib/move/move.js
var require_move3 = __commonJS({
  "node_modules/fs-extra/lib/move/move.js"(exports2, module2) {
    "use strict";
    var fs26 = require_graceful_fs();
    var path34 = require("path");
    var copy = require_copy4().copy;
    var remove = require_remove2().remove;
    var mkdirp = require_mkdirs3().mkdirp;
    var pathExists = require_path_exists2().pathExists;
    var stat = require_stat2();
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const overwrite = opts.overwrite || opts.clobber || false;
      stat.checkPaths(src, dest, "move", (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2)
            return cb(err2);
          mkdirp(path34.dirname(dest), (err3) => {
            if (err3)
              return cb(err3);
            return doRename(src, dest, overwrite, cb);
          });
        });
      });
    }
    function doRename(src, dest, overwrite, cb) {
      if (overwrite) {
        return remove(dest, (err) => {
          if (err)
            return cb(err);
          return rename(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename(src, dest, overwrite, cb);
      });
    }
    function rename(src, dest, overwrite, cb) {
      fs26.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copy(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove(src, cb);
      });
    }
    module2.exports = move;
  }
});

// node_modules/fs-extra/lib/move/index.js
var require_move4 = __commonJS({
  "node_modules/fs-extra/lib/move/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    module2.exports = {
      move: u(require_move3())
    };
  }
});

// node_modules/fs-extra/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/fs-extra/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, require_fs2()), require_copy_sync4()), require_copy4()), require_empty2()), require_ensure2()), require_json2()), require_mkdirs3()), require_move_sync4()), require_move4()), require_output2()), require_path_exists2()), require_remove2());
    var fs26 = require("fs");
    if (Object.getOwnPropertyDescriptor(fs26, "promises")) {
      Object.defineProperty(module2.exports, "promises", {
        get() {
          return fs26.promises;
        }
      });
    }
  }
});

// src/util/logger.ts
var require_logger2 = __commonJS({
  "src/util/logger.ts"(exports2, module2) {
    var import_fs35 = __toModule(require("fs"));
    var import_log4js2 = __toModule(require_log4js());
    var import_path35 = __toModule(require("path"));
    var import_os11 = __toModule(require("os"));
    var import_fs_extra10 = __toModule(require_lib5());
    function getLogFile() {
      let file = process.env.NVIM_COC_LOG_FILE;
      if (file)
        return file;
      let dir = process.env.XDG_RUNTIME_DIR;
      if (dir) {
        try {
          import_fs35.default.accessSync(dir, import_fs35.default.constants.R_OK | import_fs35.default.constants.W_OK);
          return import_path35.default.join(dir, `coc-nvim-${process.pid}.log`);
        } catch (err) {
        }
      }
      let tmpdir = import_os11.default.tmpdir();
      dir = import_path35.default.join(tmpdir, `coc.nvim-${process.pid}`);
      if (!import_fs35.default.existsSync(dir))
        (0, import_fs_extra10.mkdirpSync)(dir);
      return import_path35.default.join(dir, `coc-nvim.log`);
    }
    var MAX_LOG_SIZE = 1024 * 1024;
    var MAX_LOG_BACKUPS = 10;
    var logfile = getLogFile();
    var level = process.env.NVIM_COC_LOG_LEVEL || "info";
    if (import_fs35.default.existsSync(logfile)) {
      try {
        import_fs35.default.writeFileSync(logfile, "", { encoding: "utf8", mode: 438 });
      } catch (e) {
      }
    }
    import_log4js2.default.configure({
      disableClustering: true,
      appenders: {
        out: {
          type: "file",
          mode: 438,
          filename: logfile,
          maxLogSize: MAX_LOG_SIZE,
          backups: MAX_LOG_BACKUPS,
          layout: {
            type: "pattern",
            pattern: `%d{ISO8601} %p (pid:${process.pid}) [%c] - %m`
          }
        }
      },
      categories: {
        default: { appenders: ["out"], level }
      }
    });
    module2.exports = (name2 = "coc-nvim") => {
      let logger96 = import_log4js2.default.getLogger(name2);
      logger96.getLogFile = () => logfile;
      return logger96;
    };
  }
});

// src/util/extensions.ts
var require_extensions = __commonJS({
  "src/util/extensions.ts"() {
    Promise.prototype.logError = function() {
      this.catch((e) => {
        require_logger2()("extensions").error(e);
      });
    };
  }
});

// node_modules/msgpack-lite/lib/buffer-global.js
var require_buffer_global = __commonJS({
  "node_modules/msgpack-lite/lib/buffer-global.js"(exports2, module2) {
    module2.exports = c(typeof Buffer !== "undefined" && Buffer) || c(exports2.Buffer) || c(typeof window !== "undefined" && window.Buffer) || exports2.Buffer;
    function c(B) {
      return B && B.isBuffer && B;
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/msgpack-lite/lib/bufferish-array.js
var require_bufferish_array = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-array.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var exports2 = module2.exports = alloc(0);
    exports2.alloc = alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return new Array(size);
    }
    function from(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return Array.prototype.slice.call(value);
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-buffer.js
var require_bufferish_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-buffer.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var Buffer4 = Bufferish.global;
    var exports2 = module2.exports = Bufferish.hasBuffer ? alloc(0) : [];
    exports2.alloc = Bufferish.hasBuffer && Buffer4.alloc || alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return new Buffer4(size);
    }
    function from(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (Buffer4.from && Buffer4.from.length !== 1) {
        return Buffer4.from(value);
      } else {
        return new Buffer4(value);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-uint8array.js
var require_bufferish_uint8array = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-uint8array.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var exports2 = module2.exports = Bufferish.hasArrayBuffer ? alloc(0) : [];
    exports2.alloc = alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return new Uint8Array(size);
    }
    function from(value) {
      if (Bufferish.isView(value)) {
        var byteOffset = value.byteOffset;
        var byteLength2 = value.byteLength;
        value = value.buffer;
        if (value.byteLength !== byteLength2) {
          if (value.slice) {
            value = value.slice(byteOffset, byteOffset + byteLength2);
          } else {
            value = new Uint8Array(value);
            if (value.byteLength !== byteLength2) {
              value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength2);
            }
          }
        }
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return new Uint8Array(value);
    }
  }
});

// node_modules/msgpack-lite/lib/buffer-lite.js
var require_buffer_lite = __commonJS({
  "node_modules/msgpack-lite/lib/buffer-lite.js"(exports2) {
    exports2.copy = copy;
    exports2.toString = toString;
    exports2.write = write;
    function write(string2, offset) {
      var buffer = this;
      var index = offset || (offset |= 0);
      var length = string2.length;
      var chr = 0;
      var i = 0;
      while (i < length) {
        chr = string2.charCodeAt(i++);
        if (chr < 128) {
          buffer[index++] = chr;
        } else if (chr < 2048) {
          buffer[index++] = 192 | chr >>> 6;
          buffer[index++] = 128 | chr & 63;
        } else if (chr < 55296 || chr > 57343) {
          buffer[index++] = 224 | chr >>> 12;
          buffer[index++] = 128 | chr >>> 6 & 63;
          buffer[index++] = 128 | chr & 63;
        } else {
          chr = (chr - 55296 << 10 | string2.charCodeAt(i++) - 56320) + 65536;
          buffer[index++] = 240 | chr >>> 18;
          buffer[index++] = 128 | chr >>> 12 & 63;
          buffer[index++] = 128 | chr >>> 6 & 63;
          buffer[index++] = 128 | chr & 63;
        }
      }
      return index - offset;
    }
    function toString(encoding, start, end) {
      var buffer = this;
      var index = start | 0;
      if (!end)
        end = buffer.length;
      var string2 = "";
      var chr = 0;
      while (index < end) {
        chr = buffer[index++];
        if (chr < 128) {
          string2 += String.fromCharCode(chr);
          continue;
        }
        if ((chr & 224) === 192) {
          chr = (chr & 31) << 6 | buffer[index++] & 63;
        } else if ((chr & 240) === 224) {
          chr = (chr & 15) << 12 | (buffer[index++] & 63) << 6 | buffer[index++] & 63;
        } else if ((chr & 248) === 240) {
          chr = (chr & 7) << 18 | (buffer[index++] & 63) << 12 | (buffer[index++] & 63) << 6 | buffer[index++] & 63;
        }
        if (chr >= 65536) {
          chr -= 65536;
          string2 += String.fromCharCode((chr >>> 10) + 55296, (chr & 1023) + 56320);
        } else {
          string2 += String.fromCharCode(chr);
        }
      }
      return string2;
    }
    function copy(target, targetStart, start, end) {
      var i;
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (!targetStart)
        targetStart = 0;
      var len = end - start;
      if (target === this && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; i--) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        for (i = 0; i < len; i++) {
          target[i + targetStart] = this[i + start];
        }
      }
      return len;
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-proto.js
var require_bufferish_proto = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-proto.js"(exports2) {
    var BufferLite = require_buffer_lite();
    exports2.copy = copy;
    exports2.slice = slice;
    exports2.toString = toString;
    exports2.write = gen("write");
    var Bufferish = require_bufferish();
    var Buffer4 = Bufferish.global;
    var isBufferShim = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer4;
    var brokenTypedArray = isBufferShim && !Buffer4.TYPED_ARRAY_SUPPORT;
    function copy(target, targetStart, start, end) {
      var thisIsBuffer = Bufferish.isBuffer(this);
      var targetIsBuffer = Bufferish.isBuffer(target);
      if (thisIsBuffer && targetIsBuffer) {
        return this.copy(target, targetStart, start, end);
      } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish.isView(this) && Bufferish.isView(target)) {
        var buffer = start || end != null ? slice.call(this, start, end) : this;
        target.set(buffer, targetStart);
        return buffer.length;
      } else {
        return BufferLite.copy.call(this, target, targetStart, start, end);
      }
    }
    function slice(start, end) {
      var f = this.slice || !brokenTypedArray && this.subarray;
      if (f)
        return f.call(this, start, end);
      var target = Bufferish.alloc.call(this, end - start);
      copy.call(this, target, 0, start, end);
      return target;
    }
    function toString(encoding, start, end) {
      var f = !isBufferShim && Bufferish.isBuffer(this) ? this.toString : BufferLite.toString;
      return f.apply(this, arguments);
    }
    function gen(method) {
      return wrap;
      function wrap() {
        var f = this[method] || BufferLite[method];
        return f.apply(this, arguments);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish.js
var require_bufferish = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish.js"(exports2) {
    var Buffer4 = exports2.global = require_buffer_global();
    var hasBuffer = exports2.hasBuffer = Buffer4 && !!Buffer4.isBuffer;
    var hasArrayBuffer = exports2.hasArrayBuffer = typeof ArrayBuffer !== "undefined";
    var isArray = exports2.isArray = require_isarray();
    exports2.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;
    var isBuffer = exports2.isBuffer = hasBuffer ? Buffer4.isBuffer : _false;
    var isView = exports2.isView = hasArrayBuffer ? ArrayBuffer.isView || _is("ArrayBuffer", "buffer") : _false;
    exports2.alloc = alloc;
    exports2.concat = concat;
    exports2.from = from;
    var BufferArray = exports2.Array = require_bufferish_array();
    var BufferBuffer = exports2.Buffer = require_bufferish_buffer();
    var BufferUint8Array = exports2.Uint8Array = require_bufferish_uint8array();
    var BufferProto = exports2.prototype = require_bufferish_proto();
    function from(value) {
      if (typeof value === "string") {
        return fromString.call(this, value);
      } else {
        return auto(this).from(value);
      }
    }
    function alloc(size) {
      return auto(this).alloc(size);
    }
    function concat(list2, length) {
      if (!length) {
        length = 0;
        Array.prototype.forEach.call(list2, dryrun);
      }
      var ref = this !== exports2 && this || list2[0];
      var result = alloc.call(ref, length);
      var offset = 0;
      Array.prototype.forEach.call(list2, append);
      return result;
      function dryrun(buffer) {
        length += buffer.length;
      }
      function append(buffer) {
        offset += BufferProto.copy.call(buffer, result, offset);
      }
    }
    var _isArrayBuffer = _is("ArrayBuffer");
    function isArrayBuffer(value) {
      return value instanceof ArrayBuffer || _isArrayBuffer(value);
    }
    function fromString(value) {
      var expected = value.length * 3;
      var that = alloc.call(this, expected);
      var actual = BufferProto.write.call(that, value);
      if (expected !== actual) {
        that = BufferProto.slice.call(that, 0, actual);
      }
      return that;
    }
    function auto(that) {
      return isBuffer(that) ? BufferBuffer : isView(that) ? BufferUint8Array : isArray(that) ? BufferArray : hasBuffer ? BufferBuffer : hasArrayBuffer ? BufferUint8Array : BufferArray;
    }
    function _false() {
      return false;
    }
    function _is(name2, key) {
      name2 = "[object " + name2 + "]";
      return function(value) {
        return value != null && {}.toString.call(key ? value[key] : value) === name2;
      };
    }
  }
});

// node_modules/msgpack-lite/lib/ext-buffer.js
var require_ext_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/ext-buffer.js"(exports2) {
    exports2.ExtBuffer = ExtBuffer;
    var Bufferish = require_bufferish();
    function ExtBuffer(buffer, type) {
      if (!(this instanceof ExtBuffer))
        return new ExtBuffer(buffer, type);
      this.buffer = Bufferish.from(buffer);
      this.type = type;
    }
  }
});

// node_modules/msgpack-lite/lib/ext-packer.js
var require_ext_packer = __commonJS({
  "node_modules/msgpack-lite/lib/ext-packer.js"(exports2) {
    exports2.setExtPackers = setExtPackers;
    var Bufferish = require_bufferish();
    var Buffer4 = Bufferish.global;
    var packTypedArray = Bufferish.Uint8Array.from;
    var _encode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtPackers(codec) {
      codec.addExtPacker(14, Error, [packError, encode]);
      codec.addExtPacker(1, EvalError, [packError, encode]);
      codec.addExtPacker(2, RangeError, [packError, encode]);
      codec.addExtPacker(3, ReferenceError, [packError, encode]);
      codec.addExtPacker(4, SyntaxError, [packError, encode]);
      codec.addExtPacker(5, TypeError, [packError, encode]);
      codec.addExtPacker(6, URIError, [packError, encode]);
      codec.addExtPacker(10, RegExp, [packRegExp, encode]);
      codec.addExtPacker(11, Boolean, [packValueOf, encode]);
      codec.addExtPacker(12, String, [packValueOf, encode]);
      codec.addExtPacker(13, Date, [Number, encode]);
      codec.addExtPacker(15, Number, [packValueOf, encode]);
      if (typeof Uint8Array !== "undefined") {
        codec.addExtPacker(17, Int8Array, packTypedArray);
        codec.addExtPacker(18, Uint8Array, packTypedArray);
        codec.addExtPacker(19, Int16Array, packTypedArray);
        codec.addExtPacker(20, Uint16Array, packTypedArray);
        codec.addExtPacker(21, Int32Array, packTypedArray);
        codec.addExtPacker(22, Uint32Array, packTypedArray);
        codec.addExtPacker(23, Float32Array, packTypedArray);
        if (typeof Float64Array !== "undefined") {
          codec.addExtPacker(24, Float64Array, packTypedArray);
        }
        if (typeof Uint8ClampedArray !== "undefined") {
          codec.addExtPacker(25, Uint8ClampedArray, packTypedArray);
        }
        codec.addExtPacker(26, ArrayBuffer, packTypedArray);
        codec.addExtPacker(29, DataView, packTypedArray);
      }
      if (Bufferish.hasBuffer) {
        codec.addExtPacker(27, Buffer4, Bufferish.from);
      }
    }
    function encode(input) {
      if (!_encode)
        _encode = require_encode().encode;
      return _encode(input);
    }
    function packValueOf(value) {
      return value.valueOf();
    }
    function packRegExp(value) {
      value = RegExp.prototype.toString.call(value).split("/");
      value.shift();
      var out = [value.pop()];
      out.unshift(value.join("/"));
      return out;
    }
    function packError(value) {
      var out = {};
      for (var key in ERROR_COLUMNS) {
        out[key] = value[key];
      }
      return out;
    }
  }
});

// node_modules/int64-buffer/int64-buffer.js
var require_int64_buffer = __commonJS({
  "node_modules/int64-buffer/int64-buffer.js"(exports2) {
    var Uint64BE;
    var Int64BE;
    var Uint64LE;
    var Int64LE;
    !function(exports3) {
      var UNDEFINED = "undefined";
      var BUFFER = UNDEFINED !== typeof Buffer && Buffer;
      var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
      var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
      var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
      var isArray = Array.isArray || _isArray;
      var BIT32 = 4294967296;
      var BIT24 = 16777216;
      var storage;
      Uint64BE = factory("Uint64BE", true, true);
      Int64BE = factory("Int64BE", true, false);
      Uint64LE = factory("Uint64LE", false, true);
      Int64LE = factory("Int64LE", false, false);
      function factory(name2, bigendian, unsigned) {
        var posH = bigendian ? 0 : 4;
        var posL = bigendian ? 4 : 0;
        var pos0 = bigendian ? 0 : 3;
        var pos1 = bigendian ? 1 : 2;
        var pos2 = bigendian ? 2 : 1;
        var pos3 = bigendian ? 3 : 0;
        var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
        var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
        var proto = Int64.prototype;
        var isName = "is" + name2;
        var _isInt64 = "_" + isName;
        proto.buffer = void 0;
        proto.offset = 0;
        proto[_isInt64] = true;
        proto.toNumber = toNumber;
        proto.toString = toString;
        proto.toJSON = toNumber;
        proto.toArray = toArray;
        if (BUFFER)
          proto.toBuffer = toBuffer;
        if (UINT8ARRAY)
          proto.toArrayBuffer = toArrayBuffer;
        Int64[isName] = isInt64;
        exports3[name2] = Int64;
        return Int64;
        function Int64(buffer, offset, value, raddix) {
          if (!(this instanceof Int64))
            return new Int64(buffer, offset, value, raddix);
          return init(this, buffer, offset, value, raddix);
        }
        function isInt64(b) {
          return !!(b && b[_isInt64]);
        }
        function init(that, buffer, offset, value, raddix) {
          if (UINT8ARRAY && ARRAYBUFFER) {
            if (buffer instanceof ARRAYBUFFER)
              buffer = new UINT8ARRAY(buffer);
            if (value instanceof ARRAYBUFFER)
              value = new UINT8ARRAY(value);
          }
          if (!buffer && !offset && !value && !storage) {
            that.buffer = newArray(ZERO, 0);
            return;
          }
          if (!isValidBuffer(buffer, offset)) {
            var _storage = storage || Array;
            raddix = offset;
            value = buffer;
            offset = 0;
            buffer = new _storage(8);
          }
          that.buffer = buffer;
          that.offset = offset |= 0;
          if (UNDEFINED === typeof value)
            return;
          if (typeof value === "string") {
            fromString(buffer, offset, value, raddix || 10);
          } else if (isValidBuffer(value, raddix)) {
            fromArray(buffer, offset, value, raddix);
          } else if (typeof raddix === "number") {
            writeInt32(buffer, offset + posH, value);
            writeInt32(buffer, offset + posL, raddix);
          } else if (value > 0) {
            fromPositive(buffer, offset, value);
          } else if (value < 0) {
            fromNegative(buffer, offset, value);
          } else {
            fromArray(buffer, offset, ZERO, 0);
          }
        }
        function fromString(buffer, offset, str, raddix) {
          var pos = 0;
          var len = str.length;
          var high = 0;
          var low = 0;
          if (str[0] === "-")
            pos++;
          var sign = pos;
          while (pos < len) {
            var chr = parseInt(str[pos++], raddix);
            if (!(chr >= 0))
              break;
            low = low * raddix + chr;
            high = high * raddix + Math.floor(low / BIT32);
            low %= BIT32;
          }
          if (sign) {
            high = ~high;
            if (low) {
              low = BIT32 - low;
            } else {
              high++;
            }
          }
          writeInt32(buffer, offset + posH, high);
          writeInt32(buffer, offset + posL, low);
        }
        function toNumber() {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          if (!unsigned)
            high |= 0;
          return high ? high * BIT32 + low : low;
        }
        function toString(radix) {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          var str = "";
          var sign = !unsigned && high & 2147483648;
          if (sign) {
            high = ~high;
            low = BIT32 - low;
          }
          radix = radix || 10;
          while (1) {
            var mod = high % radix * BIT32 + low;
            high = Math.floor(high / radix);
            low = Math.floor(mod / radix);
            str = (mod % radix).toString(radix) + str;
            if (!high && !low)
              break;
          }
          if (sign) {
            str = "-" + str;
          }
          return str;
        }
        function writeInt32(buffer, offset, value) {
          buffer[offset + pos3] = value & 255;
          value = value >> 8;
          buffer[offset + pos2] = value & 255;
          value = value >> 8;
          buffer[offset + pos1] = value & 255;
          value = value >> 8;
          buffer[offset + pos0] = value & 255;
        }
        function readInt32(buffer, offset) {
          return buffer[offset + pos0] * BIT24 + (buffer[offset + pos1] << 16) + (buffer[offset + pos2] << 8) + buffer[offset + pos3];
        }
      }
      function toArray(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = null;
        if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer))
          return buffer;
        return newArray(buffer, offset);
      }
      function toBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = BUFFER;
        if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer))
          return buffer;
        var dest = new BUFFER(8);
        fromArray(dest, 0, buffer, offset);
        return dest;
      }
      function toArrayBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        var arrbuf = buffer.buffer;
        storage = UINT8ARRAY;
        if (raw !== false && offset === 0 && arrbuf instanceof ARRAYBUFFER && arrbuf.byteLength === 8)
          return arrbuf;
        var dest = new UINT8ARRAY(8);
        fromArray(dest, 0, buffer, offset);
        return dest.buffer;
      }
      function isValidBuffer(buffer, offset) {
        var len = buffer && buffer.length;
        offset |= 0;
        return len && offset + 8 <= len && typeof buffer[offset] !== "string";
      }
      function fromArray(destbuf, destoff, srcbuf, srcoff) {
        destoff |= 0;
        srcoff |= 0;
        for (var i = 0; i < 8; i++) {
          destbuf[destoff++] = srcbuf[srcoff++] & 255;
        }
      }
      function newArray(buffer, offset) {
        return Array.prototype.slice.call(buffer, offset, offset + 8);
      }
      function fromPositiveBE(buffer, offset, value) {
        var pos = offset + 8;
        while (pos > offset) {
          buffer[--pos] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeBE(buffer, offset, value) {
        var pos = offset + 8;
        value++;
        while (pos > offset) {
          buffer[--pos] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function fromPositiveLE(buffer, offset, value) {
        var end = offset + 8;
        while (offset < end) {
          buffer[offset++] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeLE(buffer, offset, value) {
        var end = offset + 8;
        value++;
        while (offset < end) {
          buffer[offset++] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function _isArray(val) {
        return !!val && Object.prototype.toString.call(val) == "[object Array]";
      }
    }(typeof exports2 === "object" && typeof exports2.nodeName !== "string" ? exports2 : exports2 || {});
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/msgpack-lite/lib/write-uint8.js
var require_write_uint8 = __commonJS({
  "node_modules/msgpack-lite/lib/write-uint8.js"(exports2) {
    var constant = exports2.uint8 = new Array(256);
    for (var i = 0; i <= 255; i++) {
      constant[i] = write0(i);
    }
    function write0(type) {
      return function(encoder) {
        var offset = encoder.reserve(1);
        encoder.buffer[offset] = type;
      };
    }
  }
});

// node_modules/msgpack-lite/lib/write-token.js
var require_write_token = __commonJS({
  "node_modules/msgpack-lite/lib/write-token.js"(exports2) {
    var ieee754 = require_ieee754();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    var uint8 = require_write_uint8().uint8;
    var Bufferish = require_bufferish();
    var Buffer4 = Bufferish.global;
    var IS_BUFFER_SHIM = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer4;
    var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer4.TYPED_ARRAY_SUPPORT;
    var Buffer_prototype = Bufferish.hasBuffer && Buffer4.prototype || {};
    exports2.getWriteToken = getWriteToken;
    function getWriteToken(options) {
      if (options && options.uint8array) {
        return init_uint8array();
      } else if (NO_TYPED_ARRAY || Bufferish.hasBuffer && options && options.safe) {
        return init_safe();
      } else {
        return init_token();
      }
    }
    function init_uint8array() {
      var token = init_token();
      token[202] = writeN(202, 4, writeFloatBE);
      token[203] = writeN(203, 8, writeDoubleBE);
      return token;
    }
    function init_token() {
      var token = uint8.slice();
      token[196] = write1(196);
      token[197] = write2(197);
      token[198] = write4(198);
      token[199] = write1(199);
      token[200] = write2(200);
      token[201] = write4(201);
      token[202] = writeN(202, 4, Buffer_prototype.writeFloatBE || writeFloatBE, true);
      token[203] = writeN(203, 8, Buffer_prototype.writeDoubleBE || writeDoubleBE, true);
      token[204] = write1(204);
      token[205] = write2(205);
      token[206] = write4(206);
      token[207] = writeN(207, 8, writeUInt64BE);
      token[208] = write1(208);
      token[209] = write2(209);
      token[210] = write4(210);
      token[211] = writeN(211, 8, writeInt64BE);
      token[217] = write1(217);
      token[218] = write2(218);
      token[219] = write4(219);
      token[220] = write2(220);
      token[221] = write4(221);
      token[222] = write2(222);
      token[223] = write4(223);
      return token;
    }
    function init_safe() {
      var token = uint8.slice();
      token[196] = writeN(196, 1, Buffer4.prototype.writeUInt8);
      token[197] = writeN(197, 2, Buffer4.prototype.writeUInt16BE);
      token[198] = writeN(198, 4, Buffer4.prototype.writeUInt32BE);
      token[199] = writeN(199, 1, Buffer4.prototype.writeUInt8);
      token[200] = writeN(200, 2, Buffer4.prototype.writeUInt16BE);
      token[201] = writeN(201, 4, Buffer4.prototype.writeUInt32BE);
      token[202] = writeN(202, 4, Buffer4.prototype.writeFloatBE);
      token[203] = writeN(203, 8, Buffer4.prototype.writeDoubleBE);
      token[204] = writeN(204, 1, Buffer4.prototype.writeUInt8);
      token[205] = writeN(205, 2, Buffer4.prototype.writeUInt16BE);
      token[206] = writeN(206, 4, Buffer4.prototype.writeUInt32BE);
      token[207] = writeN(207, 8, writeUInt64BE);
      token[208] = writeN(208, 1, Buffer4.prototype.writeInt8);
      token[209] = writeN(209, 2, Buffer4.prototype.writeInt16BE);
      token[210] = writeN(210, 4, Buffer4.prototype.writeInt32BE);
      token[211] = writeN(211, 8, writeInt64BE);
      token[217] = writeN(217, 1, Buffer4.prototype.writeUInt8);
      token[218] = writeN(218, 2, Buffer4.prototype.writeUInt16BE);
      token[219] = writeN(219, 4, Buffer4.prototype.writeUInt32BE);
      token[220] = writeN(220, 2, Buffer4.prototype.writeUInt16BE);
      token[221] = writeN(221, 4, Buffer4.prototype.writeUInt32BE);
      token[222] = writeN(222, 2, Buffer4.prototype.writeUInt16BE);
      token[223] = writeN(223, 4, Buffer4.prototype.writeUInt32BE);
      return token;
    }
    function write1(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(2);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset] = value;
      };
    }
    function write2(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(3);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset++] = value >>> 8;
        buffer[offset] = value;
      };
    }
    function write4(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(5);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset++] = value >>> 24;
        buffer[offset++] = value >>> 16;
        buffer[offset++] = value >>> 8;
        buffer[offset] = value;
      };
    }
    function writeN(type, len, method, noAssert) {
      return function(encoder, value) {
        var offset = encoder.reserve(len + 1);
        encoder.buffer[offset++] = type;
        method.call(encoder.buffer, value, offset, noAssert);
      };
    }
    function writeUInt64BE(value, offset) {
      new Uint64BE(this, offset, value);
    }
    function writeInt64BE(value, offset) {
      new Int64BE(this, offset, value);
    }
    function writeFloatBE(value, offset) {
      ieee754.write(this, value, offset, false, 23, 4);
    }
    function writeDoubleBE(value, offset) {
      ieee754.write(this, value, offset, false, 52, 8);
    }
  }
});

// node_modules/msgpack-lite/lib/write-type.js
var require_write_type = __commonJS({
  "node_modules/msgpack-lite/lib/write-type.js"(exports2) {
    var IS_ARRAY = require_isarray();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    var Bufferish = require_bufferish();
    var BufferProto = require_bufferish_proto();
    var WriteToken = require_write_token();
    var uint8 = require_write_uint8().uint8;
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var HAS_UINT8ARRAY = typeof Uint8Array !== "undefined";
    var HAS_MAP = typeof Map !== "undefined";
    var extmap = [];
    extmap[1] = 212;
    extmap[2] = 213;
    extmap[4] = 214;
    extmap[8] = 215;
    extmap[16] = 216;
    exports2.getWriteType = getWriteType;
    function getWriteType(options) {
      var token = WriteToken.getWriteToken(options);
      var useraw = options && options.useraw;
      var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;
      var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;
      var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;
      var usemap = HAS_MAP && options && options.usemap;
      var map = usemap ? map_to_map : obj_to_map;
      var writeType = {
        "boolean": bool,
        "function": nil,
        "number": number2,
        "object": useraw ? object_raw : object,
        "string": _string(useraw ? raw_head_size : str_head_size),
        "symbol": nil,
        "undefined": nil
      };
      return writeType;
      function bool(encoder, value) {
        var type = value ? 195 : 194;
        token[type](encoder, value);
      }
      function number2(encoder, value) {
        var ivalue = value | 0;
        var type;
        if (value !== ivalue) {
          type = 203;
          token[type](encoder, value);
          return;
        } else if (-32 <= ivalue && ivalue <= 127) {
          type = ivalue & 255;
        } else if (0 <= ivalue) {
          type = ivalue <= 255 ? 204 : ivalue <= 65535 ? 205 : 206;
        } else {
          type = -128 <= ivalue ? 208 : -32768 <= ivalue ? 209 : 210;
        }
        token[type](encoder, ivalue);
      }
      function uint64(encoder, value) {
        var type = 207;
        token[type](encoder, value.toArray());
      }
      function int64(encoder, value) {
        var type = 211;
        token[type](encoder, value.toArray());
      }
      function str_head_size(length) {
        return length < 32 ? 1 : length <= 255 ? 2 : length <= 65535 ? 3 : 5;
      }
      function raw_head_size(length) {
        return length < 32 ? 1 : length <= 65535 ? 3 : 5;
      }
      function _string(head_size) {
        return string2;
        function string2(encoder, value) {
          var length = value.length;
          var maxsize = 5 + length * 3;
          encoder.offset = encoder.reserve(maxsize);
          var buffer = encoder.buffer;
          var expected = head_size(length);
          var start = encoder.offset + expected;
          length = BufferProto.write.call(buffer, value, start);
          var actual = head_size(length);
          if (expected !== actual) {
            var targetStart = start + actual - expected;
            var end = start + length;
            BufferProto.copy.call(buffer, buffer, targetStart, start, end);
          }
          var type = actual === 1 ? 160 + length : actual <= 3 ? 215 + actual : 219;
          token[type](encoder, length);
          encoder.offset += length;
        }
      }
      function object(encoder, value) {
        if (value === null)
          return nil(encoder, value);
        if (isBuffer(value))
          return bin(encoder, value);
        if (IS_ARRAY(value))
          return array(encoder, value);
        if (Uint64BE.isUint64BE(value))
          return uint64(encoder, value);
        if (Int64BE.isInt64BE(value))
          return int64(encoder, value);
        var packer = encoder.codec.getExtPacker(value);
        if (packer)
          value = packer(value);
        if (value instanceof ExtBuffer)
          return ext(encoder, value);
        map(encoder, value);
      }
      function object_raw(encoder, value) {
        if (isBuffer(value))
          return raw(encoder, value);
        object(encoder, value);
      }
      function nil(encoder, value) {
        var type = 192;
        token[type](encoder, value);
      }
      function array(encoder, value) {
        var length = value.length;
        var type = length < 16 ? 144 + length : length <= 65535 ? 220 : 221;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        for (var i = 0; i < length; i++) {
          encode(encoder, value[i]);
        }
      }
      function bin_buffer(encoder, value) {
        var length = value.length;
        var type = length < 255 ? 196 : length <= 65535 ? 197 : 198;
        token[type](encoder, length);
        encoder.send(value);
      }
      function bin_arraybuffer(encoder, value) {
        bin_buffer(encoder, new Uint8Array(value));
      }
      function ext(encoder, value) {
        var buffer = value.buffer;
        var length = buffer.length;
        var type = extmap[length] || (length < 255 ? 199 : length <= 65535 ? 200 : 201);
        token[type](encoder, length);
        uint8[value.type](encoder);
        encoder.send(buffer);
      }
      function obj_to_map(encoder, value) {
        var keys = Object.keys(value);
        var length = keys.length;
        var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        keys.forEach(function(key) {
          encode(encoder, key);
          encode(encoder, value[key]);
        });
      }
      function map_to_map(encoder, value) {
        if (!(value instanceof Map))
          return obj_to_map(encoder, value);
        var length = value.size;
        var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        value.forEach(function(val, key, m) {
          encode(encoder, key);
          encode(encoder, val);
        });
      }
      function raw(encoder, value) {
        var length = value.length;
        var type = length < 32 ? 160 + length : length <= 65535 ? 218 : 219;
        token[type](encoder, length);
        encoder.send(value);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/codec-base.js
var require_codec_base = __commonJS({
  "node_modules/msgpack-lite/lib/codec-base.js"(exports2) {
    var IS_ARRAY = require_isarray();
    exports2.createCodec = createCodec;
    exports2.install = install;
    exports2.filter = filter;
    var Bufferish = require_bufferish();
    function Codec(options) {
      if (!(this instanceof Codec))
        return new Codec(options);
      this.options = options;
      this.init();
    }
    Codec.prototype.init = function() {
      var options = this.options;
      if (options && options.uint8array) {
        this.bufferish = Bufferish.Uint8Array;
      }
      return this;
    };
    function install(props) {
      for (var key in props) {
        Codec.prototype[key] = add(Codec.prototype[key], props[key]);
      }
    }
    function add(a, b) {
      return a && b ? ab : a || b;
      function ab() {
        a.apply(this, arguments);
        return b.apply(this, arguments);
      }
    }
    function join2(filters) {
      filters = filters.slice();
      return function(value) {
        return filters.reduce(iterator, value);
      };
      function iterator(value, filter2) {
        return filter2(value);
      }
    }
    function filter(filter2) {
      return IS_ARRAY(filter2) ? join2(filter2) : filter2;
    }
    function createCodec(options) {
      return new Codec(options);
    }
    exports2.preset = createCodec({ preset: true });
  }
});

// node_modules/msgpack-lite/lib/write-core.js
var require_write_core = __commonJS({
  "node_modules/msgpack-lite/lib/write-core.js"(exports2) {
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var ExtPacker = require_ext_packer();
    var WriteType = require_write_type();
    var CodecBase = require_codec_base();
    CodecBase.install({
      addExtPacker,
      getExtPacker,
      init
    });
    exports2.preset = init.call(CodecBase.preset);
    function getEncoder(options) {
      var writeType = WriteType.getWriteType(options);
      return encode;
      function encode(encoder, value) {
        var func2 = writeType[typeof value];
        if (!func2)
          throw new Error('Unsupported type "' + typeof value + '": ' + value);
        func2(encoder, value);
      }
    }
    function init() {
      var options = this.options;
      this.encode = getEncoder(options);
      if (options && options.preset) {
        ExtPacker.setExtPackers(this);
      }
      return this;
    }
    function addExtPacker(etype, Class, packer) {
      packer = CodecBase.filter(packer);
      var name2 = Class.name;
      if (name2 && name2 !== "Object") {
        var packers = this.extPackers || (this.extPackers = {});
        packers[name2] = extPacker;
      } else {
        var list2 = this.extEncoderList || (this.extEncoderList = []);
        list2.unshift([Class, extPacker]);
      }
      function extPacker(value) {
        if (packer)
          value = packer(value);
        return new ExtBuffer(value, etype);
      }
    }
    function getExtPacker(value) {
      var packers = this.extPackers || (this.extPackers = {});
      var c = value.constructor;
      var e = c && c.name && packers[c.name];
      if (e)
        return e;
      var list2 = this.extEncoderList || (this.extEncoderList = []);
      var len = list2.length;
      for (var i = 0; i < len; i++) {
        var pair = list2[i];
        if (c === pair[0])
          return pair[1];
      }
    }
  }
});

// node_modules/msgpack-lite/lib/flex-buffer.js
var require_flex_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/flex-buffer.js"(exports2) {
    exports2.FlexDecoder = FlexDecoder;
    exports2.FlexEncoder = FlexEncoder;
    var Bufferish = require_bufferish();
    var MIN_BUFFER_SIZE = 2048;
    var MAX_BUFFER_SIZE = 65536;
    var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";
    function FlexDecoder() {
      if (!(this instanceof FlexDecoder))
        return new FlexDecoder();
    }
    function FlexEncoder() {
      if (!(this instanceof FlexEncoder))
        return new FlexEncoder();
    }
    FlexDecoder.mixin = mixinFactory(getDecoderMethods());
    FlexDecoder.mixin(FlexDecoder.prototype);
    FlexEncoder.mixin = mixinFactory(getEncoderMethods());
    FlexEncoder.mixin(FlexEncoder.prototype);
    function getDecoderMethods() {
      return {
        bufferish: Bufferish,
        write: write2,
        fetch: fetch2,
        flush,
        push,
        pull,
        read,
        reserve,
        offset: 0
      };
      function write2(chunk) {
        var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;
        this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;
        this.offset = 0;
      }
      function flush() {
        while (this.offset < this.buffer.length) {
          var start = this.offset;
          var value;
          try {
            value = this.fetch();
          } catch (e) {
            if (e && e.message != BUFFER_SHORTAGE)
              throw e;
            this.offset = start;
            break;
          }
          this.push(value);
        }
      }
      function reserve(length) {
        var start = this.offset;
        var end = start + length;
        if (end > this.buffer.length)
          throw new Error(BUFFER_SHORTAGE);
        this.offset = end;
        return start;
      }
    }
    function getEncoderMethods() {
      return {
        bufferish: Bufferish,
        write,
        fetch: fetch3,
        flush,
        push,
        pull: pull2,
        read,
        reserve,
        send,
        maxBufferSize: MAX_BUFFER_SIZE,
        minBufferSize: MIN_BUFFER_SIZE,
        offset: 0,
        start: 0
      };
      function fetch3() {
        var start = this.start;
        if (start < this.offset) {
          var end = this.start = this.offset;
          return Bufferish.prototype.slice.call(this.buffer, start, end);
        }
      }
      function flush() {
        while (this.start < this.offset) {
          var value = this.fetch();
          if (value)
            this.push(value);
        }
      }
      function pull2() {
        var buffers = this.buffers || (this.buffers = []);
        var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
        buffers.length = 0;
        return chunk;
      }
      function reserve(length) {
        var req = length | 0;
        if (this.buffer) {
          var size = this.buffer.length;
          var start = this.offset | 0;
          var end = start + req;
          if (end < size) {
            this.offset = end;
            return start;
          }
          this.flush();
          length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
        }
        length = Math.max(length, this.minBufferSize);
        this.buffer = this.bufferish.alloc(length);
        this.start = 0;
        this.offset = req;
        return 0;
      }
      function send(buffer) {
        var length = buffer.length;
        if (length > this.minBufferSize) {
          this.flush();
          this.push(buffer);
        } else {
          var offset = this.reserve(length);
          Bufferish.prototype.copy.call(buffer, this.buffer, offset);
        }
      }
    }
    function write() {
      throw new Error("method not implemented: write()");
    }
    function fetch2() {
      throw new Error("method not implemented: fetch()");
    }
    function read() {
      var length = this.buffers && this.buffers.length;
      if (!length)
        return this.fetch();
      this.flush();
      return this.pull();
    }
    function push(chunk) {
      var buffers = this.buffers || (this.buffers = []);
      buffers.push(chunk);
    }
    function pull() {
      var buffers = this.buffers || (this.buffers = []);
      return buffers.shift();
    }
    function mixinFactory(source) {
      return mixin2;
      function mixin2(target) {
        for (var key in source) {
          target[key] = source[key];
        }
        return target;
      }
    }
  }
});

// node_modules/msgpack-lite/lib/encode-buffer.js
var require_encode_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/encode-buffer.js"(exports2) {
    exports2.EncodeBuffer = EncodeBuffer;
    var preset = require_write_core().preset;
    var FlexEncoder = require_flex_buffer().FlexEncoder;
    FlexEncoder.mixin(EncodeBuffer.prototype);
    function EncodeBuffer(options) {
      if (!(this instanceof EncodeBuffer))
        return new EncodeBuffer(options);
      if (options) {
        this.options = options;
        if (options.codec) {
          var codec = this.codec = options.codec;
          if (codec.bufferish)
            this.bufferish = codec.bufferish;
        }
      }
    }
    EncodeBuffer.prototype.codec = preset;
    EncodeBuffer.prototype.write = function(input) {
      this.codec.encode(this, input);
    };
  }
});

// node_modules/msgpack-lite/lib/encode.js
var require_encode = __commonJS({
  "node_modules/msgpack-lite/lib/encode.js"(exports2) {
    exports2.encode = encode;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    function encode(input, options) {
      var encoder = new EncodeBuffer(options);
      encoder.write(input);
      return encoder.read();
    }
  }
});

// node_modules/msgpack-lite/lib/ext-unpacker.js
var require_ext_unpacker = __commonJS({
  "node_modules/msgpack-lite/lib/ext-unpacker.js"(exports2) {
    exports2.setExtUnpackers = setExtUnpackers;
    var Bufferish = require_bufferish();
    var Buffer4 = Bufferish.global;
    var _decode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtUnpackers(codec) {
      codec.addExtUnpacker(14, [decode, unpackError(Error)]);
      codec.addExtUnpacker(1, [decode, unpackError(EvalError)]);
      codec.addExtUnpacker(2, [decode, unpackError(RangeError)]);
      codec.addExtUnpacker(3, [decode, unpackError(ReferenceError)]);
      codec.addExtUnpacker(4, [decode, unpackError(SyntaxError)]);
      codec.addExtUnpacker(5, [decode, unpackError(TypeError)]);
      codec.addExtUnpacker(6, [decode, unpackError(URIError)]);
      codec.addExtUnpacker(10, [decode, unpackRegExp]);
      codec.addExtUnpacker(11, [decode, unpackClass(Boolean)]);
      codec.addExtUnpacker(12, [decode, unpackClass(String)]);
      codec.addExtUnpacker(13, [decode, unpackClass(Date)]);
      codec.addExtUnpacker(15, [decode, unpackClass(Number)]);
      if (typeof Uint8Array !== "undefined") {
        codec.addExtUnpacker(17, unpackClass(Int8Array));
        codec.addExtUnpacker(18, unpackClass(Uint8Array));
        codec.addExtUnpacker(19, [unpackArrayBuffer, unpackClass(Int16Array)]);
        codec.addExtUnpacker(20, [unpackArrayBuffer, unpackClass(Uint16Array)]);
        codec.addExtUnpacker(21, [unpackArrayBuffer, unpackClass(Int32Array)]);
        codec.addExtUnpacker(22, [unpackArrayBuffer, unpackClass(Uint32Array)]);
        codec.addExtUnpacker(23, [unpackArrayBuffer, unpackClass(Float32Array)]);
        if (typeof Float64Array !== "undefined") {
          codec.addExtUnpacker(24, [unpackArrayBuffer, unpackClass(Float64Array)]);
        }
        if (typeof Uint8ClampedArray !== "undefined") {
          codec.addExtUnpacker(25, unpackClass(Uint8ClampedArray));
        }
        codec.addExtUnpacker(26, unpackArrayBuffer);
        codec.addExtUnpacker(29, [unpackArrayBuffer, unpackClass(DataView)]);
      }
      if (Bufferish.hasBuffer) {
        codec.addExtUnpacker(27, unpackClass(Buffer4));
      }
    }
    function decode(input) {
      if (!_decode)
        _decode = require_decode().decode;
      return _decode(input);
    }
    function unpackRegExp(value) {
      return RegExp.apply(null, value);
    }
    function unpackError(Class) {
      return function(value) {
        var out = new Class();
        for (var key in ERROR_COLUMNS) {
          out[key] = value[key];
        }
        return out;
      };
    }
    function unpackClass(Class) {
      return function(value) {
        return new Class(value);
      };
    }
    function unpackArrayBuffer(value) {
      return new Uint8Array(value).buffer;
    }
  }
});

// node_modules/msgpack-lite/lib/read-format.js
var require_read_format = __commonJS({
  "node_modules/msgpack-lite/lib/read-format.js"(exports2) {
    var ieee754 = require_ieee754();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    exports2.getReadFormat = getReadFormat;
    exports2.readUint8 = uint8;
    var Bufferish = require_bufferish();
    var BufferProto = require_bufferish_proto();
    var HAS_MAP = typeof Map !== "undefined";
    var NO_ASSERT = true;
    function getReadFormat(options) {
      var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;
      var int64 = options && options.int64;
      var usemap = HAS_MAP && options && options.usemap;
      var readFormat = {
        map: usemap ? map_to_map : map_to_obj,
        array,
        str,
        bin: binarraybuffer ? bin_arraybuffer : bin_buffer,
        ext,
        uint8,
        uint16,
        uint32,
        uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
        int8,
        int16,
        int32,
        int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
        float32: read(4, readFloatBE),
        float64: read(8, readDoubleBE)
      };
      return readFormat;
    }
    function map_to_obj(decoder, len) {
      var value = {};
      var i;
      var k = new Array(len);
      var v = new Array(len);
      var decode = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode(decoder);
        v[i] = decode(decoder);
      }
      for (i = 0; i < len; i++) {
        value[k[i]] = v[i];
      }
      return value;
    }
    function map_to_map(decoder, len) {
      var value = new Map();
      var i;
      var k = new Array(len);
      var v = new Array(len);
      var decode = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode(decoder);
        v[i] = decode(decoder);
      }
      for (i = 0; i < len; i++) {
        value.set(k[i], v[i]);
      }
      return value;
    }
    function array(decoder, len) {
      var value = new Array(len);
      var decode = decoder.codec.decode;
      for (var i = 0; i < len; i++) {
        value[i] = decode(decoder);
      }
      return value;
    }
    function str(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      return BufferProto.toString.call(decoder.buffer, "utf-8", start, end);
    }
    function bin_buffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.from(buf);
    }
    function bin_arraybuffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.Uint8Array.from(buf).buffer;
    }
    function ext(decoder, len) {
      var start = decoder.reserve(len + 1);
      var type = decoder.buffer[start++];
      var end = start + len;
      var unpack = decoder.codec.getExtUnpacker(type);
      if (!unpack)
        throw new Error("Invalid ext type: " + (type ? "0x" + type.toString(16) : type));
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return unpack(buf);
    }
    function uint8(decoder) {
      var start = decoder.reserve(1);
      return decoder.buffer[start];
    }
    function int8(decoder) {
      var start = decoder.reserve(1);
      var value = decoder.buffer[start];
      return value & 128 ? value - 256 : value;
    }
    function uint16(decoder) {
      var start = decoder.reserve(2);
      var buffer = decoder.buffer;
      return buffer[start++] << 8 | buffer[start];
    }
    function int16(decoder) {
      var start = decoder.reserve(2);
      var buffer = decoder.buffer;
      var value = buffer[start++] << 8 | buffer[start];
      return value & 32768 ? value - 65536 : value;
    }
    function uint32(decoder) {
      var start = decoder.reserve(4);
      var buffer = decoder.buffer;
      return buffer[start++] * 16777216 + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];
    }
    function int32(decoder) {
      var start = decoder.reserve(4);
      var buffer = decoder.buffer;
      return buffer[start++] << 24 | buffer[start++] << 16 | buffer[start++] << 8 | buffer[start];
    }
    function read(len, method) {
      return function(decoder) {
        var start = decoder.reserve(len);
        return method.call(decoder.buffer, start, NO_ASSERT);
      };
    }
    function readUInt64BE(start) {
      return new Uint64BE(this, start).toNumber();
    }
    function readInt64BE(start) {
      return new Int64BE(this, start).toNumber();
    }
    function readUInt64BE_int64(start) {
      return new Uint64BE(this, start);
    }
    function readInt64BE_int64(start) {
      return new Int64BE(this, start);
    }
    function readFloatBE(start) {
      return ieee754.read(this, start, false, 23, 4);
    }
    function readDoubleBE(start) {
      return ieee754.read(this, start, false, 52, 8);
    }
  }
});

// node_modules/msgpack-lite/lib/read-token.js
var require_read_token = __commonJS({
  "node_modules/msgpack-lite/lib/read-token.js"(exports2) {
    var ReadFormat = require_read_format();
    exports2.getReadToken = getReadToken;
    function getReadToken(options) {
      var format2 = ReadFormat.getReadFormat(options);
      if (options && options.useraw) {
        return init_useraw(format2);
      } else {
        return init_token(format2);
      }
    }
    function init_token(format2) {
      var i;
      var token = new Array(256);
      for (i = 0; i <= 127; i++) {
        token[i] = constant(i);
      }
      for (i = 128; i <= 143; i++) {
        token[i] = fix(i - 128, format2.map);
      }
      for (i = 144; i <= 159; i++) {
        token[i] = fix(i - 144, format2.array);
      }
      for (i = 160; i <= 191; i++) {
        token[i] = fix(i - 160, format2.str);
      }
      token[192] = constant(null);
      token[193] = null;
      token[194] = constant(false);
      token[195] = constant(true);
      token[196] = flex(format2.uint8, format2.bin);
      token[197] = flex(format2.uint16, format2.bin);
      token[198] = flex(format2.uint32, format2.bin);
      token[199] = flex(format2.uint8, format2.ext);
      token[200] = flex(format2.uint16, format2.ext);
      token[201] = flex(format2.uint32, format2.ext);
      token[202] = format2.float32;
      token[203] = format2.float64;
      token[204] = format2.uint8;
      token[205] = format2.uint16;
      token[206] = format2.uint32;
      token[207] = format2.uint64;
      token[208] = format2.int8;
      token[209] = format2.int16;
      token[210] = format2.int32;
      token[211] = format2.int64;
      token[212] = fix(1, format2.ext);
      token[213] = fix(2, format2.ext);
      token[214] = fix(4, format2.ext);
      token[215] = fix(8, format2.ext);
      token[216] = fix(16, format2.ext);
      token[217] = flex(format2.uint8, format2.str);
      token[218] = flex(format2.uint16, format2.str);
      token[219] = flex(format2.uint32, format2.str);
      token[220] = flex(format2.uint16, format2.array);
      token[221] = flex(format2.uint32, format2.array);
      token[222] = flex(format2.uint16, format2.map);
      token[223] = flex(format2.uint32, format2.map);
      for (i = 224; i <= 255; i++) {
        token[i] = constant(i - 256);
      }
      return token;
    }
    function init_useraw(format2) {
      var i;
      var token = init_token(format2).slice();
      token[217] = token[196];
      token[218] = token[197];
      token[219] = token[198];
      for (i = 160; i <= 191; i++) {
        token[i] = fix(i - 160, format2.bin);
      }
      return token;
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    function flex(lenFunc, decodeFunc) {
      return function(decoder) {
        var len = lenFunc(decoder);
        return decodeFunc(decoder, len);
      };
    }
    function fix(len, method) {
      return function(decoder) {
        return method(decoder, len);
      };
    }
  }
});

// node_modules/msgpack-lite/lib/read-core.js
var require_read_core = __commonJS({
  "node_modules/msgpack-lite/lib/read-core.js"(exports2) {
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var ExtUnpacker = require_ext_unpacker();
    var readUint8 = require_read_format().readUint8;
    var ReadToken = require_read_token();
    var CodecBase = require_codec_base();
    CodecBase.install({
      addExtUnpacker,
      getExtUnpacker,
      init
    });
    exports2.preset = init.call(CodecBase.preset);
    function getDecoder(options) {
      var readToken = ReadToken.getReadToken(options);
      return decode;
      function decode(decoder) {
        var type = readUint8(decoder);
        var func2 = readToken[type];
        if (!func2)
          throw new Error("Invalid type: " + (type ? "0x" + type.toString(16) : type));
        return func2(decoder);
      }
    }
    function init() {
      var options = this.options;
      this.decode = getDecoder(options);
      if (options && options.preset) {
        ExtUnpacker.setExtUnpackers(this);
      }
      return this;
    }
    function addExtUnpacker(etype, unpacker) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      unpackers[etype] = CodecBase.filter(unpacker);
    }
    function getExtUnpacker(type) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      return unpackers[type] || extUnpacker;
      function extUnpacker(buffer) {
        return new ExtBuffer(buffer, type);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/decode-buffer.js
var require_decode_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/decode-buffer.js"(exports2) {
    exports2.DecodeBuffer = DecodeBuffer;
    var preset = require_read_core().preset;
    var FlexDecoder = require_flex_buffer().FlexDecoder;
    FlexDecoder.mixin(DecodeBuffer.prototype);
    function DecodeBuffer(options) {
      if (!(this instanceof DecodeBuffer))
        return new DecodeBuffer(options);
      if (options) {
        this.options = options;
        if (options.codec) {
          var codec = this.codec = options.codec;
          if (codec.bufferish)
            this.bufferish = codec.bufferish;
        }
      }
    }
    DecodeBuffer.prototype.codec = preset;
    DecodeBuffer.prototype.fetch = function() {
      return this.codec.decode(this);
    };
  }
});

// node_modules/msgpack-lite/lib/decode.js
var require_decode = __commonJS({
  "node_modules/msgpack-lite/lib/decode.js"(exports2) {
    exports2.decode = decode;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    function decode(input, options) {
      var decoder = new DecodeBuffer(options);
      decoder.write(input);
      return decoder.read();
    }
  }
});

// node_modules/event-lite/event-lite.js
var require_event_lite = __commonJS({
  "node_modules/event-lite/event-lite.js"(exports2, module2) {
    function EventLite() {
      if (!(this instanceof EventLite))
        return new EventLite();
    }
    (function(EventLite2) {
      if (typeof module2 !== "undefined")
        module2.exports = EventLite2;
      var LISTENERS = "listeners";
      var methods2 = {
        on,
        once,
        off,
        emit
      };
      mixin2(EventLite2.prototype);
      EventLite2.mixin = mixin2;
      function mixin2(target) {
        for (var key in methods2) {
          target[key] = methods2[key];
        }
        return target;
      }
      function on(type, func2) {
        getListeners(this, type).push(func2);
        return this;
      }
      function once(type, func2) {
        var that = this;
        wrap.originalListener = func2;
        getListeners(that, type).push(wrap);
        return that;
        function wrap() {
          off.call(that, type, wrap);
          func2.apply(this, arguments);
        }
      }
      function off(type, func2) {
        var that = this;
        var listners;
        if (!arguments.length) {
          delete that[LISTENERS];
        } else if (!func2) {
          listners = that[LISTENERS];
          if (listners) {
            delete listners[type];
            if (!Object.keys(listners).length)
              return off.call(that);
          }
        } else {
          listners = getListeners(that, type, true);
          if (listners) {
            listners = listners.filter(ne);
            if (!listners.length)
              return off.call(that, type);
            that[LISTENERS][type] = listners;
          }
        }
        return that;
        function ne(test) {
          return test !== func2 && test.originalListener !== func2;
        }
      }
      function emit(type, value) {
        var that = this;
        var listeners = getListeners(that, type, true);
        if (!listeners)
          return false;
        var arglen = arguments.length;
        if (arglen === 1) {
          listeners.forEach(zeroarg);
        } else if (arglen === 2) {
          listeners.forEach(onearg);
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          listeners.forEach(moreargs);
        }
        return !!listeners.length;
        function zeroarg(func2) {
          func2.call(that);
        }
        function onearg(func2) {
          func2.call(that, value);
        }
        function moreargs(func2) {
          func2.apply(that, args);
        }
      }
      function getListeners(that, type, readonly) {
        if (readonly && !that[LISTENERS])
          return;
        var listeners = that[LISTENERS] || (that[LISTENERS] = {});
        return listeners[type] || (listeners[type] = []);
      }
    })(EventLite);
  }
});

// node_modules/msgpack-lite/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/msgpack-lite/lib/encoder.js"(exports2) {
    exports2.Encoder = Encoder;
    var EventLite = require_event_lite();
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    function Encoder(options) {
      if (!(this instanceof Encoder))
        return new Encoder(options);
      EncodeBuffer.call(this, options);
    }
    Encoder.prototype = new EncodeBuffer();
    EventLite.mixin(Encoder.prototype);
    Encoder.prototype.encode = function(chunk) {
      this.write(chunk);
      this.emit("data", this.read());
    };
    Encoder.prototype.end = function(chunk) {
      if (arguments.length)
        this.encode(chunk);
      this.flush();
      this.emit("end");
    };
  }
});

// node_modules/msgpack-lite/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/msgpack-lite/lib/decoder.js"(exports2) {
    exports2.Decoder = Decoder;
    var EventLite = require_event_lite();
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    function Decoder(options) {
      if (!(this instanceof Decoder))
        return new Decoder(options);
      DecodeBuffer.call(this, options);
    }
    Decoder.prototype = new DecodeBuffer();
    EventLite.mixin(Decoder.prototype);
    Decoder.prototype.decode = function(chunk) {
      if (arguments.length)
        this.write(chunk);
      this.flush();
    };
    Decoder.prototype.push = function(chunk) {
      this.emit("data", chunk);
    };
    Decoder.prototype.end = function(chunk) {
      this.decode(chunk);
      this.emit("end");
    };
  }
});

// node_modules/msgpack-lite/lib/encode-stream.js
var require_encode_stream = __commonJS({
  "node_modules/msgpack-lite/lib/encode-stream.js"(exports2) {
    exports2.createEncodeStream = EncodeStream;
    var util4 = require("util");
    var Transform2 = require("stream").Transform;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    util4.inherits(EncodeStream, Transform2);
    var DEFAULT_OPTIONS = { objectMode: true };
    function EncodeStream(options) {
      if (!(this instanceof EncodeStream))
        return new EncodeStream(options);
      if (options) {
        options.objectMode = true;
      } else {
        options = DEFAULT_OPTIONS;
      }
      Transform2.call(this, options);
      var stream = this;
      var encoder = this.encoder = new EncodeBuffer(options);
      encoder.push = function(chunk) {
        stream.push(chunk);
      };
    }
    EncodeStream.prototype._transform = function(chunk, encoding, callback) {
      this.encoder.write(chunk);
      if (callback)
        callback();
    };
    EncodeStream.prototype._flush = function(callback) {
      this.encoder.flush();
      if (callback)
        callback();
    };
  }
});

// node_modules/msgpack-lite/lib/decode-stream.js
var require_decode_stream = __commonJS({
  "node_modules/msgpack-lite/lib/decode-stream.js"(exports2) {
    exports2.createDecodeStream = DecodeStream;
    var util4 = require("util");
    var Transform2 = require("stream").Transform;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    util4.inherits(DecodeStream, Transform2);
    var DEFAULT_OPTIONS = { objectMode: true };
    function DecodeStream(options) {
      if (!(this instanceof DecodeStream))
        return new DecodeStream(options);
      if (options) {
        options.objectMode = true;
      } else {
        options = DEFAULT_OPTIONS;
      }
      Transform2.call(this, options);
      var stream = this;
      var decoder = this.decoder = new DecodeBuffer(options);
      decoder.push = function(chunk) {
        stream.push(chunk);
      };
    }
    DecodeStream.prototype._transform = function(chunk, encoding, callback) {
      this.decoder.write(chunk);
      this.decoder.flush();
      if (callback)
        callback();
    };
  }
});

// node_modules/msgpack-lite/lib/ext.js
var require_ext = __commonJS({
  "node_modules/msgpack-lite/lib/ext.js"(exports2) {
    require_read_core();
    require_write_core();
    exports2.createCodec = require_codec_base().createCodec;
  }
});

// node_modules/msgpack-lite/lib/codec.js
var require_codec = __commonJS({
  "node_modules/msgpack-lite/lib/codec.js"(exports2) {
    require_read_core();
    require_write_core();
    exports2.codec = {
      preset: require_codec_base().preset
    };
  }
});

// node_modules/msgpack-lite/index.js
var require_msgpack_lite = __commonJS({
  "node_modules/msgpack-lite/index.js"(exports2) {
    exports2.encode = require_encode().encode;
    exports2.decode = require_decode().decode;
    exports2.Encoder = require_encoder().Encoder;
    exports2.Decoder = require_decoder().Decoder;
    exports2.createEncodeStream = require_encode_stream().createEncodeStream;
    exports2.createDecodeStream = require_decode_stream().createDecodeStream;
    exports2.createCodec = require_ext().createCodec;
    exports2.codec = require_codec().codec;
  }
});

// node_modules/@chemzqm/neovim/lib/utils/buffered.js
var require_buffered = __commonJS({
  "node_modules/@chemzqm/neovim/lib/utils/buffered.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var Buffered = class extends stream_1.Transform {
      constructor() {
        super({
          readableHighWaterMark: 10 * 1024 * 1024,
          writableHighWaterMark: 10 * 1024 * 1024
        });
        this.chunks = null;
        this.timer = null;
      }
      sendData() {
        const { chunks } = this;
        if (chunks) {
          this.chunks = null;
          const buf = Buffer.concat(chunks);
          this.push(buf);
        }
      }
      _transform(chunk, _encoding, callback) {
        const { chunks, timer } = this;
        const MIN_SIZE = Buffer.poolSize;
        if (timer)
          clearTimeout(timer);
        if (chunk.length < MIN_SIZE) {
          if (!chunks)
            return callback(null, chunk);
          chunks.push(chunk);
          this.sendData();
          callback();
        } else {
          if (!chunks) {
            this.chunks = [chunk];
          } else {
            chunks.push(chunk);
          }
          this.timer = setTimeout(this.sendData.bind(this), 20);
          callback();
        }
      }
      _flush(callback) {
        const { chunks } = this;
        if (chunks) {
          this.chunks = null;
          const buf = Buffer.concat(chunks);
          callback(null, buf);
        } else {
          callback();
        }
      }
    };
    exports2.default = Buffered;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Base.js
var require_Base = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseApi = void 0;
    var events_1 = require("events");
    var isVim6 = process.env.VIM_NODE_RPC == "1";
    var BaseApi = class extends events_1.EventEmitter {
      constructor({ transport, data, client }) {
        super();
        this.setTransport(transport);
        this.data = data;
        this.client = client;
      }
      setTransport(transport) {
        this.transport = transport;
      }
      equals(other) {
        try {
          return String(this.data) === String(other.data);
        } catch (e) {
          return false;
        }
      }
      async request(name2, args = []) {
        let stack = Error().stack;
        return new Promise((resolve3, reject) => {
          this.transport.request(name2, this.getArgsByPrefix(args), (err, res) => {
            if (err) {
              let e = new Error(`request error ${name2} - ${err[1]}`);
              e.stack = stack;
              if (!name2.endsWith("get_var")) {
                this.client.logError(`request error on "${name2}"`, args, err[1], stack);
              }
              reject(e);
            } else {
              resolve3(res);
            }
          });
        });
      }
      getArgsByPrefix(args) {
        if (this.prefix !== "nvim_" && args[0] != this) {
          let id = isVim6 ? this.data : this;
          return [id, ...args];
        }
        return args;
      }
      getVar(name2) {
        return this.request(`${this.prefix}get_var`, [name2]).then((res) => res, (_err) => {
          return null;
        });
      }
      setVar(name2, value, isNotify = false) {
        if (isNotify) {
          this.notify(`${this.prefix}set_var`, [name2, value]);
          return;
        }
        return this.request(`${this.prefix}set_var`, [name2, value]);
      }
      deleteVar(name2) {
        this.notify(`${this.prefix}del_var`, [name2]);
      }
      getOption(name2) {
        return this.request(`${this.prefix}get_option`, [name2]);
      }
      setOption(name2, value, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}set_option`, [name2, value]);
          return;
        }
        return this.request(`${this.prefix}set_option`, [name2, value]);
      }
      notify(name2, args = []) {
        this.transport.notify(name2, this.getArgsByPrefix(args));
      }
    };
    exports2.BaseApi = BaseApi;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Buffer.js
var require_Buffer = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Buffer = void 0;
    var Base_1 = require_Base();
    var Buffer4 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_buf_";
      }
      async attach(sendBuffer = false, options = {}) {
        return await this.request(`${this.prefix}attach`, [sendBuffer, options]);
      }
      async detach() {
        return await this.request(`${this.prefix}detach`, []);
      }
      get id() {
        return this.data;
      }
      get length() {
        return this.request(`${this.prefix}line_count`, []);
      }
      get lines() {
        return this.getLines();
      }
      get changedtick() {
        return this.request(`${this.prefix}get_changedtick`, []);
      }
      get commands() {
        return this.getCommands();
      }
      getCommands(options = {}) {
        return this.request(`${this.prefix}get_commands`, [options]);
      }
      getLines({ start, end, strictIndexing } = { start: 0, end: -1, strictIndexing: true }) {
        const indexing = typeof strictIndexing === "undefined" ? true : strictIndexing;
        return this.request(`${this.prefix}get_lines`, [
          start,
          end,
          indexing
        ]);
      }
      setLines(_lines, { start: _start, end: _end, strictIndexing } = {
        strictIndexing: true
      }, notify = false) {
        const indexing = typeof strictIndexing === "undefined" ? true : strictIndexing;
        const lines = typeof _lines === "string" ? [_lines] : _lines;
        const end = typeof _end !== "undefined" ? _end : _start + 1;
        const method = notify ? "notify" : "request";
        return this[method](`${this.prefix}set_lines`, [
          _start,
          end,
          indexing,
          lines
        ]);
      }
      setVirtualText(src_id, line, chunks, opts = {}) {
        this.notify(`${this.prefix}set_virtual_text`, [
          src_id,
          line,
          chunks,
          opts
        ]);
        return Promise.resolve(src_id);
      }
      insert(lines, start) {
        return this.setLines(lines, {
          start,
          end: start,
          strictIndexing: true
        });
      }
      replace(_lines, start) {
        const lines = typeof _lines === "string" ? [_lines] : _lines;
        return this.setLines(lines, {
          start,
          end: start + lines.length,
          strictIndexing: false
        });
      }
      remove(start, end, strictIndexing = false) {
        return this.setLines([], { start, end, strictIndexing });
      }
      append(lines) {
        return this.setLines(lines, {
          start: -1,
          end: -1,
          strictIndexing: false
        });
      }
      get name() {
        return this.request(`${this.prefix}get_name`, []);
      }
      setName(value) {
        return this.request(`${this.prefix}set_name`, [value]);
      }
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      mark(name2) {
        return this.request(`${this.prefix}get_mark`, [name2]);
      }
      getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
      }
      get loaded() {
        return this.request(`${this.prefix}is_loaded`, []);
      }
      getOffset(index) {
        return this.request(`${this.prefix}get_offset`, [index]);
      }
      addHighlight({ hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId }) {
        if (!hlGroup)
          throw new Error("hlGroup should not empty");
        const colEnd = typeof _end !== "undefined" ? _end : -1;
        const colStart = typeof _start !== "undefined" ? _start : -0;
        const srcId = typeof _srcId !== "undefined" ? _srcId : -1;
        const method = srcId == 0 ? "request" : "notify";
        let res = this[method](`${this.prefix}add_highlight`, [
          srcId,
          hlGroup,
          line,
          colStart,
          colEnd
        ]);
        return method === "request" ? res : Promise.resolve(null);
      }
      clearHighlight(args = {}) {
        const defaults2 = {
          srcId: -1,
          lineStart: 0,
          lineEnd: -1
        };
        const { srcId, lineStart, lineEnd } = Object.assign({}, defaults2, args);
        return this.notify(`${this.prefix}clear_highlight`, [
          srcId,
          lineStart,
          lineEnd
        ]);
      }
      highlightRanges(srcId, hlGroup, ranges) {
        this.client.call("coc#highlight#ranges", [this.id, srcId, hlGroup, ranges], true);
      }
      clearNamespace(key, lineStart = 0, lineEnd = -1) {
        this.client.call("coc#highlight#clear_highlight", [this.id, key, lineStart, lineEnd]);
      }
      listen(eventName, cb, disposables) {
        this.client.attachBufferEvent(this, eventName, cb);
        if (disposables) {
          disposables.push({
            dispose: () => {
              this.client.detachBufferEvent(this, eventName, cb);
            }
          });
        }
      }
    };
    exports2.Buffer = Buffer4;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Window.js
var require_Window = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Window.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Window = void 0;
    var Base_1 = require_Base();
    var timers_1 = require("timers");
    var Window3 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_win_";
      }
      get id() {
        return this.data;
      }
      get buffer() {
        return this.request(`${this.prefix}get_buf`, []);
      }
      get tabpage() {
        return this.request(`${this.prefix}get_tabpage`, []);
      }
      get cursor() {
        return this.request(`${this.prefix}get_cursor`, []);
      }
      setCursor(pos, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_cursor`, [pos]);
      }
      get height() {
        return this.request(`${this.prefix}get_height`, []);
      }
      setHeight(height, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_height`, [height]);
      }
      get width() {
        return this.request(`${this.prefix}get_width`, []);
      }
      setWidth(width, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_height`, [width]);
      }
      get position() {
        return this.request(`${this.prefix}get_position`, []);
      }
      get row() {
        return this.request(`${this.prefix}get_position`, []).then((position) => position[0]);
      }
      get col() {
        return this.request(`${this.prefix}get_position`, []).then((position) => position[1]);
      }
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      get number() {
        return this.request(`${this.prefix}get_number`, []);
      }
      setConfig(options, isNotify) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_config`, [options]);
      }
      getConfig() {
        return this.request(`${this.prefix}get_config`, []);
      }
      close(force, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}close`, [force]);
          let count = 0;
          let interval = setInterval(() => {
            if (count == 5)
              return timers_1.clearInterval(interval);
            this.request(`${this.prefix}is_valid`, []).then((valid) => {
              if (!valid) {
                timers_1.clearInterval(interval);
              } else {
                this.notify(`${this.prefix}close`, [force]);
              }
            }, () => {
              timers_1.clearInterval(interval);
            });
            count++;
          }, 50);
          return null;
        }
        return this.request(`${this.prefix}close`, [force]);
      }
      highlightRanges(hlGroup, ranges, priority = 10, isNotify) {
        if (isNotify) {
          this.client.call("coc#highlight#match_ranges", [this.id, 0, ranges, hlGroup, priority], true);
          return void 0;
        }
        return this.client.call("coc#highlight#match_ranges", [this.id, 0, ranges, hlGroup, priority]);
      }
      clearMatchGroup(hlGroup) {
        this.client.call("coc#highlight#clear_match_group", [this.id, hlGroup], true);
      }
      clearMatches(ids) {
        this.client.call("coc#highlight#clear_matches", [this.id, ids], true);
      }
    };
    exports2.Window = Window3;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Tabpage.js
var require_Tabpage = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Tabpage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tabpage = void 0;
    var Base_1 = require_Base();
    var Tabpage = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_tabpage_";
      }
      get windows() {
        return this.request(`${this.prefix}list_wins`, []);
      }
      get window() {
        return this.request(`${this.prefix}get_win`, []);
      }
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      get number() {
        return this.request(`${this.prefix}get_number`, []);
      }
      getOption() {
        throw new Error("Tabpage does not have `getOption`");
      }
      setOption() {
        throw new Error("Tabpage does not have `setOption`");
      }
    };
    exports2.Tabpage = Tabpage;
  }
});

// node_modules/@chemzqm/neovim/lib/api/types.js
var require_types = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Metadata = exports2.ExtType = void 0;
    var Buffer_1 = require_Buffer();
    var Window_1 = require_Window();
    var Tabpage_1 = require_Tabpage();
    var ExtType;
    (function(ExtType2) {
      ExtType2[ExtType2["Buffer"] = 0] = "Buffer";
      ExtType2[ExtType2["Window"] = 1] = "Window";
      ExtType2[ExtType2["Tabpage"] = 2] = "Tabpage";
    })(ExtType = exports2.ExtType || (exports2.ExtType = {}));
    exports2.Metadata = [
      {
        constructor: Buffer_1.Buffer,
        name: "Buffer",
        prefix: "nvim_buf_"
      },
      {
        constructor: Window_1.Window,
        name: "Window",
        prefix: "nvim_win_"
      },
      {
        constructor: Tabpage_1.Tabpage,
        name: "Tabpage",
        prefix: "nvim_tabpage_"
      }
    ];
  }
});

// node_modules/@chemzqm/neovim/lib/utils/logger.js
var require_logger3 = __commonJS({
  "node_modules/@chemzqm/neovim/lib/utils/logger.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createLogger = void 0;
    var fs_1 = __importDefault(require("fs"));
    var os_1 = __importDefault(require("os"));
    var path_1 = __importDefault(require("path"));
    function getLogFile() {
      let file = process.env.NODE_CLIENT_LOG_FILE;
      if (file)
        return file;
      let dir = process.env.XDG_RUNTIME_DIR;
      if (dir)
        return path_1.default.join(dir, "node-client.log");
      return path_1.default.join(os_1.default.tmpdir(), `node-client-${process.pid}.log`);
    }
    var LOG_FILE_PATH = getLogFile();
    var level = process.env.NODE_CLIENT_LOG_LEVEL || "info";
    var invalid = process.getuid && process.getuid() == 0;
    if (!invalid) {
      try {
        fs_1.default.mkdirSync(path_1.default.dirname(LOG_FILE_PATH), { recursive: true });
        fs_1.default.writeFileSync(LOG_FILE_PATH, "", { encoding: "utf8", mode: 438 });
      } catch (_e) {
        invalid = true;
      }
    }
    function toObject(arg) {
      if (arg == null) {
        return arg;
      }
      if (Array.isArray(arg)) {
        return arg.map((o) => toObject(o));
      }
      if (typeof arg == "object" && typeof arg.prefix == "string" && typeof arg.data == "number") {
        return "[" + arg.prefix + arg.data + "]";
      }
      return arg;
    }
    function toString(arg) {
      if (arg == null)
        return String(arg);
      if (typeof arg == "object")
        return JSON.stringify(arg, null, 2);
      return String(arg);
    }
    var Logger2 = class {
      constructor(name2) {
        this.name = name2;
      }
      get stream() {
        if (invalid)
          return null;
        if (this._stream)
          return this._stream;
        this._stream = fs_1.default.createWriteStream(LOG_FILE_PATH, { encoding: "utf8" });
        return this._stream;
      }
      getText(level2, data, meta) {
        let more = "";
        if (meta.length) {
          let arr = toObject(meta);
          more = " " + arr.map((o) => toString(o));
        }
        return `${new Date().toLocaleTimeString()} ${level2.toUpperCase()} [${this.name}] - ${data}${more}
`;
      }
      debug(data, ...meta) {
        if (level != "debug" || this.stream == null)
          return;
        this.stream.write(this.getText("debug", data, meta));
      }
      info(data, ...meta) {
        if (this.stream == null)
          return;
        this.stream.write(this.getText("info", data, meta));
      }
      error(data, ...meta) {
        if (this.stream == null)
          return;
        this.stream.write(this.getText("error", data, meta));
      }
      trace(data, ...meta) {
        if (level != "trace" || this.stream == null)
          return;
        this.stream.write(this.getText("trace", data, meta));
      }
    };
    function createLogger3(name2) {
      return new Logger2(name2);
    }
    exports2.createLogger = createLogger3;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/base.js
var require_base = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require("events");
    var logger_1 = require_logger3();
    var debug = process.env.NODE_CLIENT_LOG_LEVEL == "debug";
    var logger96 = logger_1.createLogger("transport");
    var Transport3 = class extends events_1.EventEmitter {
      constructor(logger97) {
        super();
        this.logger = logger97;
        this.pauseLevel = 0;
        this.paused = new Map();
      }
      debug(key, ...meta) {
        if (!debug)
          return;
        logger96.debug(key, ...meta);
      }
      info(key, ...meta) {
        logger96.info(key, ...meta);
      }
      debugMessage(msg) {
        if (!debug)
          return;
        const msgType = msg[0];
        if (msgType == 0) {
          logger96.debug("receive request:", msg.slice(1));
        } else if (msgType == 1) {
        } else if (msgType == 2) {
          logger96.debug("receive notification:", msg.slice(1));
        } else {
          logger96.debug("unknown message:", msg);
        }
      }
      pauseNotification() {
        this.pauseLevel = this.pauseLevel + 1;
        this.paused.set(this.pauseLevel, []);
      }
      cancelNotification() {
        let { pauseLevel } = this;
        if (pauseLevel > 0) {
          this.paused.delete(pauseLevel);
          this.pauseLevel = pauseLevel - 1;
        }
      }
      resumeNotification(isNotify = false) {
        let { pauseLevel } = this;
        if (pauseLevel == 0)
          return isNotify ? null : Promise.resolve([null, null]);
        let stack = Error().stack;
        this.pauseLevel = pauseLevel - 1;
        let list2 = this.paused.get(pauseLevel);
        this.paused.delete(pauseLevel);
        if (list2 && list2.length) {
          return new Promise((resolve3, reject) => {
            if (!isNotify) {
              return this.request("nvim_call_atomic", [list2], (err, res) => {
                if (err) {
                  let e = new Error(`call_atomic error: ${err[1]}`);
                  e.stack = stack;
                  return reject(e);
                }
                if (Array.isArray(res) && res[1] != null) {
                  let [index, errType, message] = res[1];
                  let [fname, args] = list2[index];
                  this.logger.error(`request error ${errType} on "${fname}"`, args, message, stack);
                }
                resolve3(res);
              });
            }
            this.notify("nvim_call_atomic", [list2]);
            resolve3();
          });
        }
        return isNotify ? null : Promise.resolve([[], void 0]);
      }
    };
    exports2.default = Transport3;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/nvim.js
var require_nvim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/nvim.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NvimTransport = void 0;
    var msgpack = __importStar(require_msgpack_lite());
    var buffered_1 = __importDefault(require_buffered());
    var types_1 = require_types();
    var base_1 = __importDefault(require_base());
    var NvimTransport = class extends base_1.default {
      constructor(logger96) {
        super(logger96);
        this.pending = new Map();
        this.nextRequestId = 1;
        this.attached = false;
        const codec = this.setupCodec();
        this.encodeStream = msgpack.createEncodeStream({ codec });
        this.decodeStream = msgpack.createDecodeStream({ codec });
        this.decodeStream.on("data", (msg) => {
          this.parseMessage(msg);
        });
        this.decodeStream.on("end", () => {
          this.detach();
          this.emit("detach");
        });
      }
      parseMessage(msg) {
        const msgType = msg[0];
        this.debugMessage(msg);
        if (msgType === 0) {
          this.emit("request", msg[2].toString(), msg[3], this.createResponse(msg[1]));
        } else if (msgType === 1) {
          const id = msg[1];
          const handler = this.pending.get(id);
          if (handler) {
            this.pending.delete(id);
            let err = msg[2];
            if (err && err.length != 2) {
              err = [0, err instanceof Error ? err.message : err];
            }
            handler(err, msg[3]);
          }
        } else if (msgType === 2) {
          this.emit("notification", msg[1].toString(), msg[2]);
        } else {
          console.error(`Invalid message type ${msgType}`);
        }
      }
      setupCodec() {
        const codec = msgpack.createCodec();
        types_1.Metadata.forEach(({ constructor }, id) => {
          codec.addExtPacker(id, constructor, (obj) => msgpack.encode(obj.data));
          codec.addExtUnpacker(id, (data) => new constructor({
            transport: this,
            client: this.client,
            data: msgpack.decode(data)
          }));
        });
        this.codec = codec;
        return this.codec;
      }
      attach(writer, reader, client) {
        this.encodeStream = this.encodeStream.pipe(writer);
        const buffered = new buffered_1.default();
        reader.pipe(buffered).pipe(this.decodeStream);
        this.writer = writer;
        this.reader = reader;
        this.client = client;
        this.attached = true;
      }
      detach() {
        if (!this.attached)
          return;
        this.attached = false;
        this.encodeStream.unpipe(this.writer);
        this.reader.unpipe(this.decodeStream);
      }
      request(method, args, cb) {
        if (!this.attached)
          return;
        let id = this.nextRequestId;
        this.nextRequestId = this.nextRequestId + 1;
        let startTs = Date.now();
        this.debug("request to nvim:", id, method, args);
        this.encodeStream.write(msgpack.encode([0, id, method, args], {
          codec: this.codec
        }));
        let stack = Error().stack;
        let timer = setTimeout(() => {
          this.debug(`request to vim blocked more than 1s: ${method}`, args, stack);
        }, 1e3);
        this.pending.set(id, (err, res) => {
          clearTimeout(timer);
          this.debug("response of nvim:", id, `${Date.now() - startTs}ms`, res, err);
          cb(err, res);
        });
      }
      notify(method, args) {
        if (!this.attached)
          return;
        if (this.pauseLevel != 0) {
          let arr = this.paused.get(this.pauseLevel);
          if (arr) {
            arr.push([method, args]);
            return;
          }
        }
        this.debug("nvim notification:", method, args);
        this.encodeStream.write(msgpack.encode([2, method, args], {
          codec: this.codec
        }));
      }
      send(arr) {
        this.encodeStream.write(msgpack.encode(arr, {
          codec: this.codec
        }));
      }
      createResponse(requestId) {
        let { encodeStream } = this;
        let startTs = Date.now();
        let called = false;
        let timer = setTimeout(() => {
          this.debug(`request to client cost more than 1s`, requestId);
        }, 1e3);
        return {
          send: (resp, isError) => {
            clearTimeout(timer);
            if (called || !this.attached)
              return;
            this.debug("response of client:", requestId, `${Date.now() - startTs}ms`, resp, isError == true);
            called = true;
            encodeStream.write(msgpack.encode([
              1,
              requestId,
              isError ? resp : null,
              !isError ? resp : null
            ]));
          }
        };
      }
    };
    exports2.NvimTransport = NvimTransport;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/connection.js
var require_connection = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/connection.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = __importDefault(require("events"));
    var readline_1 = __importDefault(require("readline"));
    var logger_1 = require_logger3();
    var logger96 = logger_1.createLogger("connection");
    var debug = process.env.NODE_CLIENT_LOG_LEVEL == "debug";
    var Connection = class extends events_1.default {
      constructor(readable, writeable) {
        super();
        this.readable = readable;
        this.writeable = writeable;
        const rl = readline_1.default.createInterface(this.readable);
        rl.on("line", (line) => {
          this.parseData(line);
        });
        rl.on("close", () => {
          logger96.error("connection closed");
          process.exit(0);
        });
      }
      parseData(str) {
        if (str.length == 0)
          return;
        let arr;
        try {
          arr = JSON.parse(str);
        } catch (e) {
          console.error(`Invalid data from vim: ${str}`);
          return;
        }
        let [id, obj] = arr;
        if (id > 0) {
          logger96.debug("received request:", id, obj);
          this.emit("request", id, obj);
        } else if (id == 0) {
          logger96.debug("received notification:", obj);
          this.emit("notification", obj);
        } else {
          logger96.debug("received response:", id, obj);
          this.emit("response", id, obj);
        }
      }
      response(requestId, data) {
        this.send([requestId, data || null]);
      }
      notify(event, data) {
        this.send([0, [event, data || null]]);
      }
      send(arr) {
        logger96.debug("send to vim:", arr);
        try {
          this.writeable.write(JSON.stringify(arr) + "\n");
        } catch (e) {
          logger96.error("Send error:", arr);
        }
      }
      redraw(force = false) {
        this.send(["redraw", force ? "force" : ""]);
      }
      commmand(cmd) {
        this.send(["ex", cmd]);
      }
      expr(expr) {
        this.send(["expr", expr]);
      }
      call(func2, args, requestId) {
        if (!requestId) {
          this.send(["call", func2, args]);
          return;
        }
        this.send(["call", func2, args, requestId]);
      }
      dispose() {
        this.removeAllListeners();
      }
    };
    exports2.default = Connection;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/request.js
var require_request = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/request.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var logger_1 = require_logger3();
    var logger96 = logger_1.createLogger("request");
    var debug = process.env.NODE_CLIENT_LOG_LEVEL == "debug";
    var func2 = process.env.COC_NVIM == "1" ? "coc#api#call" : "nvim#api#call";
    var Request = class {
      constructor(connection, cb, id) {
        this.connection = connection;
        this.cb = cb;
        this.id = id;
      }
      request(method, args = []) {
        this.method = method;
        this.args = args;
        this.connection.call(func2, [method.slice(5), args], this.id);
      }
      callback(client, err, result) {
        let { method, cb } = this;
        if (debug && err) {
          logger96.debug(`request ${this.method} error:`, err, this.args);
        }
        if (err)
          return cb([0, err.toString()]);
        switch (method) {
          case "nvim_list_wins":
          case "nvim_tabpage_list_wins":
            return cb(null, result.map((o) => client.createWindow(o)));
          case "nvim_tabpage_get_win":
          case "nvim_get_current_win":
          case "nvim_open_win":
            return cb(null, client.createWindow(result));
          case "nvim_list_bufs":
            return cb(null, result.map((o) => client.createBuffer(o)));
          case "nvim_win_get_buf":
          case "nvim_create_buf":
          case "nvim_get_current_buf":
            return cb(null, client.createBuffer(result));
          case "nvim_list_tabpages":
            return cb(null, result.map((o) => client.createTabpage(o)));
          case "nvim_get_current_tabpage":
            return cb(null, client.createTabpage(result));
          default:
            return cb(null, result);
        }
      }
    };
    exports2.default = Request;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/vim.js
var require_vim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/vim.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VimTransport = void 0;
    var base_1 = __importDefault(require_base());
    var connection_1 = __importDefault(require_connection());
    var request_1 = __importDefault(require_request());
    var VimTransport = class extends base_1.default {
      constructor(logger96) {
        super(logger96);
        this.pending = new Map();
        this.nextRequestId = -1;
        this.attached = false;
        this.notifyMethod = process.env.COC_NVIM == "1" ? "coc#api#notify" : "nvim#api#notify";
      }
      attach(writer, reader, client) {
        let connection = this.connection = new connection_1.default(reader, writer);
        this.attached = true;
        this.client = client;
        connection.on("request", (id, obj) => {
          let [method, args] = obj;
          this.emit("request", method, args, this.createResponse(id));
        });
        connection.on("notification", (obj) => {
          let [event, args] = obj;
          this.emit("notification", event.toString(), args);
        });
        connection.on("response", (id, obj) => {
          let req = this.pending.get(id);
          if (req) {
            this.pending.delete(id);
            let err = null;
            let result = null;
            if (!Array.isArray(obj)) {
              err = obj;
            } else {
              err = obj[0];
              result = obj[1];
            }
            req.callback(this.client, err, result);
          }
        });
      }
      send(arr) {
        this.connection.send(arr);
      }
      detach() {
        if (!this.attached)
          return;
        this.attached = false;
        this.connection.dispose();
      }
      request(method, args, cb) {
        if (!this.attached)
          return cb([0, "transport disconnected"]);
        let id = this.nextRequestId;
        this.nextRequestId = this.nextRequestId - 1;
        let startTs = Date.now();
        this.debug("request to vim:", id, method, args);
        let timer = setTimeout(() => {
          this.debug(`request to vim cost more than 1s`, method, args);
        }, 1e3);
        let req = new request_1.default(this.connection, (err, res) => {
          clearTimeout(timer);
          this.debug(`response from vim cost:`, id, `${Date.now() - startTs}ms`);
          cb(err, res);
        }, id);
        this.pending.set(id, req);
        req.request(method, args);
      }
      notify(method, args) {
        if (!this.attached)
          return;
        if (this.pauseLevel != 0) {
          let arr = this.paused.get(this.pauseLevel);
          if (arr) {
            arr.push([method, args]);
            return;
          }
        }
        this.connection.call(this.notifyMethod, [method.slice(5), args]);
      }
      createResponse(requestId) {
        let called = false;
        let { connection } = this;
        let startTs = Date.now();
        let timer = setTimeout(() => {
          this.debug(`request to client cost more than 1s`, requestId);
        }, 1e3);
        return {
          send: (resp, isError) => {
            clearTimeout(timer);
            if (called || !this.attached)
              return;
            called = true;
            let err = null;
            if (isError)
              err = typeof resp === "string" ? resp : resp.toString();
            this.debug("response of client cost:", requestId, `${Date.now() - startTs}ms`);
            connection.response(requestId, [err, isError ? null : resp]);
          }
        };
      }
    };
    exports2.VimTransport = VimTransport;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Neovim.js
var require_Neovim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Neovim.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Neovim = void 0;
    var Base_1 = require_Base();
    var Buffer_1 = require_Buffer();
    var Tabpage_1 = require_Tabpage();
    var Window_1 = require_Window();
    var isVim6 = process.env.VIM_NODE_RPC == "1";
    var Neovim2 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_";
        this.Buffer = Buffer_1.Buffer;
        this.Window = Window_1.Window;
        this.Tabpage = Tabpage_1.Tabpage;
      }
      getArgs(args) {
        if (!args)
          return [];
        if (Array.isArray(args))
          return args;
        return [args];
      }
      get apiInfo() {
        return this.request(`${this.prefix}get_api_info`);
      }
      get buffers() {
        return this.request(`${this.prefix}list_bufs`);
      }
      get buffer() {
        return this.request(`${this.prefix}get_current_buf`);
      }
      async setBuffer(buffer) {
        await this.request(`${this.prefix}set_current_buf`, [buffer]);
      }
      get chans() {
        return this.request(`${this.prefix}list_chans`);
      }
      getChanInfo(chan) {
        return this.request(`${this.prefix}get_chan_info`, [chan]);
      }
      createNamespace(name2 = "") {
        return this.request(`${this.prefix}create_namespace`, [name2]);
      }
      get namespaces() {
        return this.request(`${this.prefix}get_namespaces`, []);
      }
      get commands() {
        return this.getCommands();
      }
      getCommands(options = {}) {
        return this.request(`${this.prefix}get_commands`, [options]);
      }
      get tabpages() {
        return this.request(`${this.prefix}list_tabpages`);
      }
      get tabpage() {
        return this.request(`${this.prefix}get_current_tabpage`);
      }
      async setTabpage(tabpage) {
        await this.request(`${this.prefix}set_current_tabpage`, [tabpage]);
      }
      get windows() {
        return this.getWindows();
      }
      get window() {
        return this.request(`${this.prefix}get_current_win`);
      }
      getWindows() {
        return this.request(`${this.prefix}list_wins`);
      }
      async setWindow(win) {
        await this.request(`${this.prefix}set_current_win`, [win]);
      }
      get runtimePaths() {
        return this.request(`${this.prefix}list_runtime_paths`);
      }
      setDirectory(dir) {
        return this.request(`${this.prefix}set_current_dir`, [dir]);
      }
      get line() {
        return this.getLine();
      }
      createNewBuffer(listed = false, scratch = false) {
        return this.request(`${this.prefix}create_buf`, [listed, scratch]);
      }
      openFloatWindow(buffer, enter, options) {
        return this.request(`${this.prefix}open_win`, [buffer, enter, options]);
      }
      getLine() {
        return this.request(`${this.prefix}get_current_line`);
      }
      setLine(line) {
        return this.request(`${this.prefix}set_current_line`, [line]);
      }
      getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
      }
      get mode() {
        return this.request(`${this.prefix}get_mode`);
      }
      get colorMap() {
        return this.request(`${this.prefix}get_color_map`);
      }
      getColorByName(name2) {
        return this.request(`${this.prefix}get_color_by_name`, [name2]);
      }
      getHighlight(nameOrId, isRgb = true) {
        const functionName = typeof nameOrId === "string" ? "by_name" : "by_id";
        return this.request(`${this.prefix}get_hl_${functionName}`, [
          nameOrId,
          isRgb
        ]);
      }
      getHighlightByName(name2, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_name`, [name2, isRgb]);
      }
      getHighlightById(id, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_id`, [id, isRgb]);
      }
      deleteCurrentLine() {
        return this.request(`${this.prefix}del_current_line`);
      }
      eval(expr) {
        return this.request(`${this.prefix}eval`, [expr]);
      }
      lua(code, args = []) {
        const _args = this.getArgs(args);
        return this.request(`${this.prefix}execute_lua`, [code, _args]);
      }
      executeLua(code, args = []) {
        return this.lua(code, args);
      }
      callDictFunction(dict, fname, args = []) {
        const _args = this.getArgs(args);
        return this.request(`${this.prefix}call_dict_function`, [
          dict,
          fname,
          _args
        ]);
      }
      call(fname, args = [], isNotify) {
        const _args = this.getArgs(args);
        if (isNotify) {
          this.notify(`${this.prefix}call_function`, [fname, _args]);
          return null;
        }
        return this.request(`${this.prefix}call_function`, [fname, _args]);
      }
      callTimer(fname, args = [], isNotify) {
        const _args = this.getArgs(args);
        if (isNotify) {
          this.notify(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
          return null;
        }
        if (isVim6) {
          this.notify(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
          return new Promise((resolve3) => {
            setTimeout(() => {
              resolve3(null);
            }, 20);
          });
        }
        return this.request(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
      }
      callAsync(fname, args = []) {
        const _args = this.getArgs(args);
        return this.client.sendAsyncRequest(fname, _args);
      }
      callFunction(fname, args = []) {
        return this.call(fname, args);
      }
      callAtomic(calls) {
        return this.request(`${this.prefix}call_atomic`, [calls]);
      }
      command(arg, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}command`, [arg]);
          return null;
        }
        return this.request(`${this.prefix}command`, [arg]);
      }
      commandOutput(arg) {
        return this.request(`${this.prefix}command_output`, [arg]);
      }
      getVvar(name2) {
        return this.request(`${this.prefix}get_vvar`, [name2]);
      }
      feedKeys(keys, mode, escapeCsi) {
        return this.request(`${this.prefix}feedkeys`, [keys, mode, escapeCsi]);
      }
      input(keys) {
        return this.request(`${this.prefix}input`, [keys]);
      }
      parseExpression(expr, flags, highlight) {
        return this.request(`${this.prefix}parse_expression`, [
          expr,
          flags,
          highlight
        ]);
      }
      getProc(pid) {
        return this.request(`${this.prefix}get_proc`, [pid]);
      }
      getProcChildren(pid) {
        return this.request(`${this.prefix}get_proc_children`, [pid]);
      }
      replaceTermcodes(str, fromPart, doIt, special) {
        return this.request(`${this.prefix}replace_termcodes`, [
          str,
          fromPart,
          doIt,
          special
        ]);
      }
      strWidth(str) {
        return this.request(`${this.prefix}strwidth`, [str]);
      }
      outWrite(str) {
        this.notify(`${this.prefix}out_write`, [str]);
      }
      outWriteLine(str) {
        this.outWrite(`${str}
`);
      }
      errWrite(str) {
        this.notify(`${this.prefix}err_write`, [str]);
      }
      errWriteLine(str) {
        this.notify(`${this.prefix}err_writeln`, [str]);
      }
      get uis() {
        return this.request(`${this.prefix}list_uis`);
      }
      uiAttach(width, height, options) {
        return this.request(`${this.prefix}ui_attach`, [width, height, options]);
      }
      uiDetach() {
        return this.request(`${this.prefix}ui_detach`, []);
      }
      uiTryResize(width, height) {
        return this.request(`${this.prefix}ui_try_resize`, [width, height]);
      }
      uiSetOption(name2, value) {
        return this.request(`${this.prefix}ui_set_option`, [name2, value]);
      }
      subscribe(event) {
        return this.request(`${this.prefix}subscribe`, [event]);
      }
      unsubscribe(event) {
        return this.request(`${this.prefix}unsubscribe`, [event]);
      }
      setClientInfo(name2, version2, type, methods2, attributes) {
        this.notify(`${this.prefix}set_client_info`, [
          name2,
          version2,
          type,
          methods2,
          attributes
        ]);
      }
      async quit() {
        this.command("qa!", true);
        if (this.transport) {
          this.transport.detach();
        }
      }
    };
    exports2.Neovim = Neovim2;
  }
});

// node_modules/@chemzqm/neovim/lib/api/client.js
var require_client = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NeovimClient = exports2.AsyncResponse = void 0;
    var nvim_1 = require_nvim();
    var vim_1 = require_vim();
    var Neovim_1 = require_Neovim();
    var Buffer_1 = require_Buffer();
    var Window_1 = require_Window();
    var Tabpage_1 = require_Tabpage();
    var logger_1 = require_logger3();
    var logger96 = logger_1.createLogger("client");
    var isVim6 = process.env.VIM_NODE_RPC == "1";
    var AsyncResponse = class {
      constructor(requestId, cb) {
        this.requestId = requestId;
        this.cb = cb;
        this.finished = false;
      }
      finish(err, res) {
        if (this.finished)
          return;
        this.finished = true;
        if (err) {
          this.cb(new Error(err));
          return;
        }
        this.cb(null, res);
      }
    };
    exports2.AsyncResponse = AsyncResponse;
    var NeovimClient2 = class extends Neovim_1.Neovim {
      constructor(logger97) {
        super({});
        this.logger = logger97;
        this.requestId = 1;
        this.responses = new Map();
        this.attachedBuffers = new Map();
        Object.defineProperty(this, "client", {
          value: this
        });
        let transport = isVim6 ? new vim_1.VimTransport(logger97) : new nvim_1.NvimTransport(logger97);
        this.setTransport(transport);
        this.transportAttached = false;
        this.handleRequest = this.handleRequest.bind(this);
        this.handleNotification = this.handleNotification.bind(this);
      }
      logError(msg, ...args) {
        if (!this.logger)
          return;
        this.logger.error(msg, ...args);
      }
      createBuffer(id) {
        return new Buffer_1.Buffer({
          transport: this.transport,
          data: id,
          client: this
        });
      }
      createWindow(id) {
        return new Window_1.Window({
          transport: this.transport,
          data: id,
          client: this
        });
      }
      createTabpage(id) {
        return new Tabpage_1.Tabpage({
          transport: this.transport,
          data: id,
          client: this
        });
      }
      send(arr) {
        this.transport.send(arr);
      }
      attach({ reader, writer }, requestApi = true) {
        this.transport.attach(writer, reader, this);
        this.transportAttached = true;
        this.setupTransport(requestApi);
      }
      detach() {
        this.transport.detach();
        this.transportAttached = false;
      }
      get isApiReady() {
        return this.transportAttached && typeof this._channelId !== "undefined";
      }
      get channelId() {
        return this._isReady.then(() => {
          return this._channelId;
        });
      }
      isAttached(bufnr) {
        return this.attachedBuffers.has(bufnr);
      }
      handleRequest(method, args, resp) {
        this.emit("request", method, args, resp);
      }
      sendAsyncRequest(method, args) {
        let id = this.requestId;
        this.requestId = id + 1;
        this.notify("nvim_call_function", ["coc#rpc#async_request", [id, method, args || []]]);
        return new Promise((resolve3, reject) => {
          let response = new AsyncResponse(id, (err, res) => {
            if (err)
              return reject(err);
            resolve3(res);
          });
          this.responses.set(id, response);
        });
      }
      emitNotification(method, args) {
        if (method.endsWith("_event")) {
          if (method.startsWith("nvim_buf_")) {
            const shortName = method.replace(/nvim_buf_(.*)_event/, "$1");
            const { id } = args[0];
            if (!this.attachedBuffers.has(id))
              return;
            const bufferMap = this.attachedBuffers.get(id);
            const cbs = bufferMap.get(shortName) || [];
            cbs.forEach((cb) => cb(...args));
            if (shortName === "detach") {
              this.attachedBuffers.delete(id);
            }
            return;
          }
          if (method.startsWith("nvim_async_request")) {
            const [id, method2, arr] = args;
            this.handleRequest(method2, arr, {
              send: (resp, isError) => {
                this.notify("nvim_call_function", ["coc#rpc#async_response", [id, resp, isError]]);
              }
            });
          }
          if (method.startsWith("nvim_async_response")) {
            const [id, err, res] = args;
            const response = this.responses.get(id);
            if (!response) {
              console.error(`Response not found for request ${id}`);
              return;
            }
            this.responses.delete(id);
            response.finish(err, res);
            return;
          }
        } else {
          this.emit("notification", method, args);
        }
      }
      handleNotification(method, args) {
        this.emitNotification(method, args);
      }
      setupTransport(requestApi = true) {
        if (!this.transportAttached) {
          throw new Error("Not attached to input/output");
        }
        this.transport.on("request", this.handleRequest);
        this.transport.on("notification", this.handleNotification);
        this.transport.on("detach", () => {
          this.emit("disconnect");
          this.transport.removeAllListeners("request");
          this.transport.removeAllListeners("notification");
          this.transport.removeAllListeners("detach");
        });
        if (requestApi) {
          this._isReady = this.generateApi();
        } else {
          this._channelId = 0;
          this._isReady = Promise.resolve(true);
        }
      }
      requestApi() {
        return new Promise((resolve3, reject) => {
          this.transport.request("nvim_get_api_info", [], (err, res) => {
            if (err) {
              reject(new Error(Array.isArray(err) ? err[1] : err.message || err.toString()));
            } else {
              resolve3(res);
            }
          });
        });
      }
      async generateApi() {
        let results;
        try {
          results = await this.requestApi();
        } catch (err) {
          console.error("Could not get vim api results");
          logger96.error(err);
        }
        if (results) {
          try {
            const [channelId, metadata] = results;
            this.functions = metadata.functions.map((f) => f.name);
            this._channelId = channelId;
            return true;
          } catch (err) {
            logger96.error(err.stack);
            return null;
          }
        }
        return null;
      }
      attachBufferEvent(buffer, eventName, cb) {
        const bufferMap = this.attachedBuffers.get(buffer.id) || new Map();
        const cbs = bufferMap.get(eventName) || [];
        if (cbs.includes(cb))
          return;
        cbs.push(cb);
        bufferMap.set(eventName, cbs);
        this.attachedBuffers.set(buffer.id, bufferMap);
        return;
      }
      detachBufferEvent(buffer, eventName, cb) {
        const bufferMap = this.attachedBuffers.get(buffer.id);
        if (!bufferMap || !bufferMap.has(eventName))
          return;
        const handlers = bufferMap.get(eventName).filter((handler) => handler !== cb);
        bufferMap.set(eventName, handlers);
      }
      pauseNotification() {
        this.transport.pauseNotification();
        let stack = Error().stack;
        process.nextTick(() => {
          if (this.transport.pauseLevel > 0) {
            this.logError(`resumeNotification not called within same tick:`, stack);
          }
        });
      }
      resumeNotification(cancel, notify) {
        if (cancel)
          return Promise.resolve(this.transport.cancelNotification());
        if (notify) {
          return Promise.resolve(this.transport.resumeNotification(true));
        }
        return Promise.resolve(this.transport.resumeNotification());
      }
      hasFunction(name2) {
        if (!this.functions)
          return true;
        return this.functions.indexOf(name2) !== -1;
      }
    };
    exports2.NeovimClient = NeovimClient2;
  }
});

// node_modules/@chemzqm/neovim/lib/attach/attach.js
var require_attach = __commonJS({
  "node_modules/@chemzqm/neovim/lib/attach/attach.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attach = void 0;
    var net_1 = require("net");
    var client_1 = require_client();
    function attach3({ reader: _reader, writer: _writer, proc, socket }, logger96 = null, requestApi = true) {
      let writer;
      let reader;
      let neovim;
      if (socket) {
        const client = net_1.createConnection(socket);
        writer = client;
        reader = client;
        client.once("close", () => {
          neovim.detach();
        });
      } else if (_reader && _writer) {
        writer = _writer;
        reader = _reader;
      } else if (proc) {
        writer = proc.stdin;
        reader = proc.stdout;
        proc.once("disconnect", () => {
          neovim.detach();
        });
      }
      writer.on("error", (err) => {
        if (err.code == "EPIPE") {
          neovim.detach();
        }
      });
      if (writer && reader) {
        neovim = new client_1.NeovimClient(logger96);
        neovim.attach({
          writer,
          reader
        }, requestApi);
        return neovim;
      }
      throw new Error("Invalid arguments, could not attach");
    }
    exports2.attach = attach3;
  }
});

// node_modules/@chemzqm/neovim/lib/api/index.js
var require_api = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tabpage = exports2.Window = exports2.Buffer = exports2.NeovimClient = exports2.Neovim = void 0;
    var client_1 = require_client();
    Object.defineProperty(exports2, "Neovim", { enumerable: true, get: function() {
      return client_1.NeovimClient;
    } });
    var client_2 = require_client();
    Object.defineProperty(exports2, "NeovimClient", { enumerable: true, get: function() {
      return client_2.NeovimClient;
    } });
    var Buffer_1 = require_Buffer();
    Object.defineProperty(exports2, "Buffer", { enumerable: true, get: function() {
      return Buffer_1.Buffer;
    } });
    var Window_1 = require_Window();
    Object.defineProperty(exports2, "Window", { enumerable: true, get: function() {
      return Window_1.Window;
    } });
    var Tabpage_1 = require_Tabpage();
    Object.defineProperty(exports2, "Tabpage", { enumerable: true, get: function() {
      return Tabpage_1.Tabpage;
    } });
  }
});

// node_modules/@chemzqm/neovim/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@chemzqm/neovim/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Window = exports2.Tabpage = exports2.Buffer = exports2.NeovimClient = exports2.Neovim = exports2.attach = void 0;
    var attach_1 = require_attach();
    Object.defineProperty(exports2, "attach", { enumerable: true, get: function() {
      return attach_1.attach;
    } });
    var index_1 = require_api();
    Object.defineProperty(exports2, "Neovim", { enumerable: true, get: function() {
      return index_1.Neovim;
    } });
    Object.defineProperty(exports2, "NeovimClient", { enumerable: true, get: function() {
      return index_1.NeovimClient;
    } });
    Object.defineProperty(exports2, "Buffer", { enumerable: true, get: function() {
      return index_1.Buffer;
    } });
    Object.defineProperty(exports2, "Tabpage", { enumerable: true, get: function() {
      return index_1.Tabpage;
    } });
    Object.defineProperty(exports2, "Window", { enumerable: true, get: function() {
      return index_1.Window;
    } });
  }
});

// node_modules/vscode-jsonrpc/lib/is.js
var require_is = __commonJS({
  "node_modules/vscode-jsonrpc/lib/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function boolean2(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean2;
    function string2(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string2;
    function number2(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number2;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func2(value) {
      return typeof value === "function";
    }
    exports2.func = func2;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string2(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var is = require_is();
    var ErrorCodes2;
    (function(ErrorCodes3) {
      ErrorCodes3.ParseError = -32700;
      ErrorCodes3.InvalidRequest = -32600;
      ErrorCodes3.MethodNotFound = -32601;
      ErrorCodes3.InvalidParams = -32602;
      ErrorCodes3.InternalError = -32603;
      ErrorCodes3.serverErrorStart = -32099;
      ErrorCodes3.serverErrorEnd = -32e3;
      ErrorCodes3.ServerNotInitialized = -32002;
      ErrorCodes3.UnknownErrorCode = -32001;
      ErrorCodes3.RequestCancelled = -32800;
      ErrorCodes3.ContentModified = -32801;
      ErrorCodes3.MessageWriteError = 1;
      ErrorCodes3.MessageReadError = 2;
    })(ErrorCodes2 = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
    var ResponseError2 = class extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes2.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError2.prototype);
      }
      toJson() {
        return {
          code: this.code,
          message: this.message,
          data: this.data
        };
      }
    };
    exports2.ResponseError = ResponseError2;
    var AbstractMessageType = class {
      constructor(_method, _numberOfParams) {
        this._method = _method;
        this._numberOfParams = _numberOfParams;
      }
      get method() {
        return this._method;
      }
      get numberOfParams() {
        return this._numberOfParams;
      }
    };
    exports2.AbstractMessageType = AbstractMessageType;
    var RequestType03 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType03;
    var RequestType3 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 1);
      }
    };
    exports2.RequestType = RequestType3;
    var RequestType1 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 1);
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType22 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType22;
    var RequestType32 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType32;
    var RequestType4 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType4 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 1);
        this._ = void 0;
      }
    };
    exports2.NotificationType = NotificationType4;
    var NotificationType03 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType03;
    var NotificationType1 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 1);
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType22 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType22;
    var NotificationType32 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType32;
    var NotificationType42 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType42;
    var NotificationType5 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageType {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    function isRequestMessage(message) {
      let candidate = message;
      return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    exports2.isRequestMessage = isRequestMessage;
    function isNotificationMessage(message) {
      let candidate = message;
      return candidate && is.string(candidate.method) && message.id === void 0;
    }
    exports2.isNotificationMessage = isNotificationMessage;
    function isResponseMessage(message) {
      let candidate = message;
      return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    exports2.isResponseMessage = isResponseMessage;
  }
});

// node_modules/vscode-jsonrpc/lib/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Disposable67;
    (function(Disposable68) {
      function create(func2) {
        return {
          dispose: func2
        };
      }
      Disposable68.create = create;
    })(Disposable67 = exports2.Disposable || (exports2.Disposable = {}));
    var Event21;
    (function(Event22) {
      const _disposable = { dispose() {
      } };
      Event22.None = function() {
        return _disposable;
      };
    })(Event21 = exports2.Event || (exports2.Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        var foundCallbackWithDifferentContext = false;
        for (var i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (var i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter22 = class {
      constructor(_options) {
        this._options = _options;
      }
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            let result;
            result = {
              dispose: () => {
                this._callbacks.remove(listener, thisArgs);
                result.dispose = Emitter22._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter22;
    Emitter22._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require_events();
    var Is5 = require_is();
    var DefaultSize = 8192;
    var CR = Buffer.from("\r", "ascii")[0];
    var LF = Buffer.from("\n", "ascii")[0];
    var CRLF = "\r\n";
    var MessageBuffer = class {
      constructor(encoding = "utf8") {
        this.encoding = encoding;
        this.index = 0;
        this.buffer = Buffer.allocUnsafe(DefaultSize);
      }
      append(chunk) {
        var toAppend = chunk;
        if (typeof chunk === "string") {
          var str = chunk;
          var bufferLen = Buffer.byteLength(str, this.encoding);
          toAppend = Buffer.allocUnsafe(bufferLen);
          toAppend.write(str, 0, bufferLen, this.encoding);
        }
        if (this.buffer.length - this.index >= toAppend.length) {
          toAppend.copy(this.buffer, this.index, 0, toAppend.length);
        } else {
          var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
          if (this.index === 0) {
            this.buffer = Buffer.allocUnsafe(newSize);
            toAppend.copy(this.buffer, 0, 0, toAppend.length);
          } else {
            this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
          }
        }
        this.index += toAppend.length;
      }
      tryReadHeaders() {
        let result = void 0;
        let current = 0;
        while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {
          current++;
        }
        if (current + 3 >= this.index) {
          return result;
        }
        result = Object.create(null);
        let headers = this.buffer.toString("ascii", 0, current).split(CRLF);
        headers.forEach((header) => {
          let index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          let key = header.substr(0, index);
          let value = header.substr(index + 1).trim();
          result[key] = value;
        });
        let nextStart = current + 4;
        this.buffer = this.buffer.slice(nextStart);
        this.index = this.index - nextStart;
        return result;
      }
      tryReadContent(length) {
        if (this.index < length) {
          return null;
        }
        let result = this.buffer.toString(this.encoding, 0, length);
        let nextStart = length;
        this.buffer.copy(this.buffer, 0, nextStart);
        this.index = this.index - nextStart;
        return result;
      }
      get numberOfBytes() {
        return this.index;
      }
    };
    var MessageReader2;
    (function(MessageReader3) {
      function is(value) {
        let candidate = value;
        return candidate && Is5.func(candidate.listen) && Is5.func(candidate.dispose) && Is5.func(candidate.onError) && Is5.func(candidate.onClose) && Is5.func(candidate.onPartialMessage);
      }
      MessageReader3.is = is;
    })(MessageReader2 = exports2.MessageReader || (exports2.MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is5.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var StreamMessageReader2 = class extends AbstractMessageReader {
      constructor(readable, encoding = "utf8") {
        super();
        this.readable = readable;
        this.buffer = new MessageBuffer(encoding);
        this._partialMessageTimeout = 1e4;
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        this.readable.on("data", (data) => {
          this.onData(data);
        });
        this.readable.on("error", (error) => this.fireError(error));
        this.readable.on("close", () => this.fireClose());
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            let headers = this.buffer.tryReadHeaders();
            if (!headers) {
              return;
            }
            let contentLength = headers["Content-Length"];
            if (!contentLength) {
              throw new Error("Header must provide a Content-Length property.");
            }
            let length = parseInt(contentLength);
            if (isNaN(length)) {
              throw new Error("Content-Length value must be a number.");
            }
            this.nextMessageLength = length;
          }
          var msg = this.buffer.tryReadContent(this.nextMessageLength);
          if (msg === null) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          this.messageToken++;
          var json = JSON.parse(msg);
          this.callback(json);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          clearTimeout(this.partialMessageTimer);
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader2;
    var IPCMessageReader2 = class extends AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
      }
    };
    exports2.IPCMessageReader = IPCMessageReader2;
    var SocketMessageReader = class extends StreamMessageReader2 {
      constructor(socket, encoding = "utf-8") {
        super(socket, encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require_events();
    var Is5 = require_is();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter2;
    (function(MessageWriter3) {
      function is(value) {
        let candidate = value;
        return candidate && Is5.func(candidate.dispose) && Is5.func(candidate.onClose) && Is5.func(candidate.onError) && Is5.func(candidate.write);
      }
      MessageWriter3.is = is;
    })(MessageWriter2 = exports2.MessageWriter || (exports2.MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is5.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var StreamMessageWriter2 = class extends AbstractMessageWriter {
      constructor(writable, encoding = "utf8") {
        super();
        this.writable = writable;
        this.encoding = encoding;
        this.errorCount = 0;
        this.writable.on("error", (error) => this.fireError(error));
        this.writable.on("close", () => this.fireClose());
      }
      write(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
          ContentLength,
          contentLength.toString(),
          CRLF,
          CRLF
        ];
        try {
          this.writable.write(headers.join(""), "ascii");
          this.writable.write(json, this.encoding);
          this.errorCount = 0;
        } catch (error) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter2;
    var IPCMessageWriter2 = class extends AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        this.queue = [];
        this.sending = false;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        if (!this.sending && this.queue.length === 0) {
          this.doWriteMessage(msg);
        } else {
          this.queue.push(msg);
        }
      }
      doWriteMessage(msg) {
        try {
          if (this.process.send) {
            this.sending = true;
            this.process.send(msg, void 0, void 0, (error) => {
              this.sending = false;
              if (error) {
                this.errorCount++;
                this.fireError(error, msg, this.errorCount);
              } else {
                this.errorCount = 0;
              }
              if (this.queue.length > 0) {
                this.doWriteMessage(this.queue.shift());
              }
            });
          }
        } catch (error) {
          this.errorCount++;
          this.fireError(error, msg, this.errorCount);
        }
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter2;
    var SocketMessageWriter = class extends AbstractMessageWriter {
      constructor(socket, encoding = "utf8") {
        super();
        this.socket = socket;
        this.queue = [];
        this.sending = false;
        this.encoding = encoding;
        this.errorCount = 0;
        this.socket.on("error", (error) => this.fireError(error));
        this.socket.on("close", () => this.fireClose());
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
      write(msg) {
        if (!this.sending && this.queue.length === 0) {
          this.doWriteMessage(msg);
        } else {
          this.queue.push(msg);
        }
      }
      doWriteMessage(msg) {
        let json = JSON.stringify(msg);
        let contentLength = Buffer.byteLength(json, this.encoding);
        let headers = [
          ContentLength,
          contentLength.toString(),
          CRLF,
          CRLF
        ];
        try {
          this.sending = true;
          this.socket.write(headers.join(""), "ascii", (error) => {
            if (error) {
              this.handleError(error, msg);
            }
            try {
              this.socket.write(json, this.encoding, (error2) => {
                this.sending = false;
                if (error2) {
                  this.handleError(error2, msg);
                } else {
                  this.errorCount = 0;
                }
                if (this.queue.length > 0) {
                  this.doWriteMessage(this.queue.shift());
                }
              });
            } catch (error2) {
              this.handleError(error2, msg);
            }
          });
        } catch (error) {
          this.handleError(error, msg);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require_events();
    var Is5 = require_is();
    var CancellationToken44;
    (function(CancellationToken45) {
      CancellationToken45.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken45.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        let candidate = value;
        return candidate && (candidate === CancellationToken45.None || candidate === CancellationToken45.Cancelled || Is5.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken45.is = is;
    })(CancellationToken44 = exports2.CancellationToken || (exports2.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      let handle = setTimeout(callback.bind(context), 0);
      return { dispose() {
        clearTimeout(handle);
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource22 = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken44.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken44.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource22;
  }
});

// node_modules/vscode-jsonrpc/lib/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/linkedMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.Last = 2;
    })(Touch = exports2.Touch || (exports2.Touch = {}));
    var LinkedMap = class {
      constructor() {
        this._map = new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
      }
      delete(key) {
        const item = this._map.get(key);
        if (!item) {
          return false;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return true;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          current = current.next;
        }
      }
      forEachReverse(callbackfn, thisArg) {
        let current = this._tail;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          current = current.previous;
        }
      }
      values() {
        let result = [];
        let current = this._head;
        while (current) {
          result.push(current.value);
          current = current.next;
        }
        return result;
      }
      keys() {
        let result = [];
        let current = this._head;
        while (current) {
          result.push(current.key);
          current = current.next;
        }
        return result;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          this._head = item.next;
        } else if (item === this._tail) {
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
  }
});

// node_modules/vscode-jsonrpc/lib/pipeSupport.js
var require_pipeSupport = __commonJS({
  "node_modules/vscode-jsonrpc/lib/pipeSupport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path_1 = require("path");
    var os_1 = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var messageReader_1 = require_messageReader();
    var messageWriter_1 = require_messageWriter();
    function generateRandomPipeName2() {
      const randomSuffix = crypto_1.randomBytes(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      } else {
        return path_1.join(os_1.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
    }
    exports2.generateRandomPipeName = generateRandomPipeName2;
    function createClientPipeTransport2(pipeName, encoding = "utf-8") {
      let connectResolve;
      let connected = new Promise((resolve3, _reject) => {
        connectResolve = resolve3;
      });
      return new Promise((resolve3, reject) => {
        let server = net_1.createServer((socket) => {
          server.close();
          connectResolve([
            new messageReader_1.SocketMessageReader(socket, encoding),
            new messageWriter_1.SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve3({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport2;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = net_1.createConnection(pipeName);
      return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
  }
});

// node_modules/vscode-jsonrpc/lib/socketSupport.js
var require_socketSupport = __commonJS({
  "node_modules/vscode-jsonrpc/lib/socketSupport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = require("net");
    var messageReader_1 = require_messageReader();
    var messageWriter_1 = require_messageWriter();
    function createClientSocketTransport2(port, encoding = "utf-8") {
      let connectResolve;
      let connected = new Promise((resolve3, _reject) => {
        connectResolve = resolve3;
      });
      return new Promise((resolve3, reject) => {
        let server = net_1.createServer((socket) => {
          server.close();
          connectResolve([
            new messageReader_1.SocketMessageReader(socket, encoding),
            new messageWriter_1.SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve3({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport2;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = net_1.createConnection(port, "127.0.0.1");
      return [
        new messageReader_1.SocketMessageReader(socket, encoding),
        new messageWriter_1.SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
  }
});

// node_modules/vscode-jsonrpc/lib/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/main.js"(exports2) {
    "use strict";
    function __export2(m) {
      for (var p in m)
        if (!exports2.hasOwnProperty(p))
          exports2[p] = m[p];
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Is5 = require_is();
    var messages_1 = require_messages();
    exports2.RequestType = messages_1.RequestType;
    exports2.RequestType0 = messages_1.RequestType0;
    exports2.RequestType1 = messages_1.RequestType1;
    exports2.RequestType2 = messages_1.RequestType2;
    exports2.RequestType3 = messages_1.RequestType3;
    exports2.RequestType4 = messages_1.RequestType4;
    exports2.RequestType5 = messages_1.RequestType5;
    exports2.RequestType6 = messages_1.RequestType6;
    exports2.RequestType7 = messages_1.RequestType7;
    exports2.RequestType8 = messages_1.RequestType8;
    exports2.RequestType9 = messages_1.RequestType9;
    exports2.ResponseError = messages_1.ResponseError;
    exports2.ErrorCodes = messages_1.ErrorCodes;
    exports2.NotificationType = messages_1.NotificationType;
    exports2.NotificationType0 = messages_1.NotificationType0;
    exports2.NotificationType1 = messages_1.NotificationType1;
    exports2.NotificationType2 = messages_1.NotificationType2;
    exports2.NotificationType3 = messages_1.NotificationType3;
    exports2.NotificationType4 = messages_1.NotificationType4;
    exports2.NotificationType5 = messages_1.NotificationType5;
    exports2.NotificationType6 = messages_1.NotificationType6;
    exports2.NotificationType7 = messages_1.NotificationType7;
    exports2.NotificationType8 = messages_1.NotificationType8;
    exports2.NotificationType9 = messages_1.NotificationType9;
    var messageReader_1 = require_messageReader();
    exports2.MessageReader = messageReader_1.MessageReader;
    exports2.StreamMessageReader = messageReader_1.StreamMessageReader;
    exports2.IPCMessageReader = messageReader_1.IPCMessageReader;
    exports2.SocketMessageReader = messageReader_1.SocketMessageReader;
    var messageWriter_1 = require_messageWriter();
    exports2.MessageWriter = messageWriter_1.MessageWriter;
    exports2.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
    exports2.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
    exports2.SocketMessageWriter = messageWriter_1.SocketMessageWriter;
    var events_1 = require_events();
    exports2.Disposable = events_1.Disposable;
    exports2.Event = events_1.Event;
    exports2.Emitter = events_1.Emitter;
    var cancellation_1 = require_cancellation();
    exports2.CancellationTokenSource = cancellation_1.CancellationTokenSource;
    exports2.CancellationToken = cancellation_1.CancellationToken;
    var linkedMap_1 = require_linkedMap();
    __export2(require_pipeSupport());
    __export2(require_socketSupport());
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressNotification2;
    (function(ProgressNotification3) {
      ProgressNotification3.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification2 || (ProgressNotification2 = {}));
    var ProgressType4 = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType4;
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace2;
    (function(Trace3) {
      Trace3[Trace3["Off"] = 0] = "Off";
      Trace3[Trace3["Messages"] = 1] = "Messages";
      Trace3[Trace3["Verbose"] = 2] = "Verbose";
    })(Trace2 = exports2.Trace || (exports2.Trace = {}));
    (function(Trace3) {
      function fromString(value) {
        if (!Is5.string(value)) {
          return Trace3.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace3.Off;
          case "messages":
            return Trace3.Messages;
          case "verbose":
            return Trace3.Verbose;
          default:
            return Trace3.Off;
        }
      }
      Trace3.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace3.Off:
            return "off";
          case Trace3.Messages:
            return "messages";
          case Trace3.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace3.toString = toString;
    })(Trace2 = exports2.Trace || (exports2.Trace = {}));
    var TraceFormat2;
    (function(TraceFormat3) {
      TraceFormat3["Text"] = "text";
      TraceFormat3["JSON"] = "json";
    })(TraceFormat2 = exports2.TraceFormat || (exports2.TraceFormat = {}));
    (function(TraceFormat3) {
      function fromString(value) {
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat3.JSON;
        } else {
          return TraceFormat3.Text;
        }
      }
      TraceFormat3.fromString = fromString;
    })(TraceFormat2 = exports2.TraceFormat || (exports2.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTraceNotification");
    })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTraceNotification");
    })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
    var ConnectionError = class extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        let candidate = value;
        return candidate && Is5.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function _createMessageConnection(messageReader, messageWriter, logger96, strategy) {
      let sequenceNumber = 0;
      let notificationSquenceNumber = 0;
      let unknownResponseSquenceNumber = 0;
      const version2 = "2.0";
      let starRequestHandler = void 0;
      let requestHandlers = Object.create(null);
      let starNotificationHandler = void 0;
      let notificationHandlers = Object.create(null);
      let progressHandlers = new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = Object.create(null);
      let requestTokens = Object.create(null);
      let trace = Trace2.Off;
      let traceFormat = TraceFormat2.Text;
      let tracer;
      let state = ConnectionState.New;
      let errorEmitter = new events_1.Emitter();
      let closeEmitter = new events_1.Emitter();
      let unhandledNotificationEmitter = new events_1.Emitter();
      let unhandledProgressEmitter = new events_1.Emitter();
      let disposeEmitter = new events_1.Emitter();
      function createRequestQueueKey(id) {
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSquenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSquenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.isResponseMessage(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        let message = messageQueue.shift();
        try {
          if (messages_1.isRequestMessage(message)) {
            handleRequest(message);
          } else if (messages_1.isNotificationMessage(message)) {
            handleNotification(message);
          } else if (messages_1.isResponseMessage(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      let callback = (message) => {
        try {
          if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
            let key = createRequestQueueKey(message.params.id);
            let toCancel = messageQueue.get(key);
            if (messages_1.isRequestMessage(toCancel)) {
              let response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response);
                return;
              }
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          let message = {
            jsonrpc: version2,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replyError(error, method, startTime2) {
          let message = {
            jsonrpc: version2,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          let message = {
            jsonrpc: version2,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        let element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        let startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          let cancellationSource = new cancellation_1.CancellationTokenSource();
          let tokenKey = String(requestMessage.id);
          requestTokens[tokenKey] = cancellationSource;
          try {
            let handlerResult;
            if (requestMessage.params === void 0 || type !== void 0 && type.numberOfParams === 0) {
              handlerResult = requestHandler ? requestHandler(cancellationSource.token) : starRequestHandler(requestMessage.method, cancellationSource.token);
            } else if (Is5.array(requestMessage.params) && (type === void 0 || type.numberOfParams > 1)) {
              handlerResult = requestHandler ? requestHandler(...requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, ...requestMessage.params, cancellationSource.token);
            } else {
              handlerResult = requestHandler ? requestHandler(requestMessage.params, cancellationSource.token) : starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            let promise = handlerResult;
            if (!handlerResult) {
              delete requestTokens[tokenKey];
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                delete requestTokens[tokenKey];
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is5.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              delete requestTokens[tokenKey];
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            delete requestTokens[tokenKey];
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is5.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger96.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger96.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          let key = String(responseMessage.id);
          let responsePromise = responsePromises[key];
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise) {
            delete responsePromises[key];
            try {
              if (responseMessage.error) {
                let error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger96.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger96.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          notificationHandler = (params) => {
            let id = params.id;
            let source = requestTokens[String(id)];
            if (source) {
              source.cancel();
            }
          };
        } else {
          let element = notificationHandlers[message.method];
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (message.params === void 0 || type !== void 0 && type.numberOfParams === 0) {
              notificationHandler ? notificationHandler() : starNotificationHandler(message.method);
            } else if (Is5.array(message.params) && (type === void 0 || type.numberOfParams > 1)) {
              notificationHandler ? notificationHandler(...message.params) : starNotificationHandler(message.method, ...message.params);
            } else {
              notificationHandler ? notificationHandler(message.params) : starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger96.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger96.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger96.error("Received empty message.");
          return;
        }
        logger96.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        let responseMessage = message;
        if (Is5.string(responseMessage.id) || Is5.number(responseMessage.id)) {
          let key = String(responseMessage.id);
          let responseHandler = responsePromises[key];
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose && message.params) {
            data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace2.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose) {
            if (message.params) {
              data = `Params: ${JSON.stringify(message.params, null, 4)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose) {
            if (message.error && message.error.data) {
              data = `Error data: ${JSON.stringify(message.error.data, null, 4)}

`;
            } else {
              if (message.result) {
                data = `Result: ${JSON.stringify(message.result, null, 4)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            let error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace2.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function computeMessageParams(type, params) {
        let result;
        let numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = null;
            break;
          case 1:
            result = undefinedToNull(params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      let connection = {
        sendNotification: (type, ...params) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is5.string(type)) {
            method = type;
            switch (params.length) {
              case 0:
                messageParams = null;
                break;
              case 1:
                messageParams = params[0];
                break;
              default:
                messageParams = params;
                break;
            }
          } else {
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          let notificationMessage = {
            jsonrpc: version2,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          if (Is5.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is5.string(type)) {
              notificationHandlers[type] = { type: void 0, handler };
            } else {
              notificationHandlers[type.method] = { type, handler };
            }
          }
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          connection.sendNotification(ProgressNotification2.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...params) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is5.string(type)) {
            method = type;
            switch (params.length) {
              case 0:
                messageParams = null;
                break;
              case 1:
                if (cancellation_1.CancellationToken.is(params[0])) {
                  messageParams = null;
                  token = params[0];
                } else {
                  messageParams = undefinedToNull(params[0]);
                }
                break;
              default:
                const last = params.length - 1;
                if (cancellation_1.CancellationToken.is(params[last])) {
                  token = params[last];
                  if (params.length === 2) {
                    messageParams = undefinedToNull(params[0]);
                  } else {
                    messageParams = params.slice(0, last).map((value) => undefinedToNull(value));
                  }
                } else {
                  messageParams = params.map((value) => undefinedToNull(value));
                }
                break;
            }
          } else {
            method = type.method;
            messageParams = computeMessageParams(type, params);
            let numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          let id = sequenceNumber++;
          let result = new Promise((resolve3, reject) => {
            let requestMessage = {
              jsonrpc: version2,
              id,
              method,
              params: messageParams
            };
            let responsePromise = { method, timerStart: Date.now(), resolve: resolve3, reject };
            traceSendingRequest(requestMessage);
            try {
              messageWriter.write(requestMessage);
            } catch (e) {
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
              responsePromise = null;
            }
            if (responsePromise) {
              responsePromises[String(id)] = responsePromise;
            }
          });
          if (token) {
            token.onCancellationRequested(() => {
              connection.sendNotification(CancelNotification.type, { id });
            });
          }
          return result;
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          if (Is5.func(type)) {
            starRequestHandler = type;
          } else if (handler) {
            if (Is5.string(type)) {
              requestHandlers[type] = { type: void 0, handler };
            } else {
              requestHandlers[type.method] = { type, handler };
            }
          }
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat2.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is5.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat2.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace2.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            connection.sendNotification(SetTraceNotification.type, { value: Trace2.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          let error = new Error("Connection got disposed.");
          Object.keys(responsePromises).forEach((key) => {
            responsePromises[key].reject(error);
          });
          responsePromises = Object.create(null);
          requestTokens = Object.create(null);
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is5.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is5.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        tracer.log(params.message, trace === Trace2.Verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification2.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    function isMessageReader(value) {
      return value.listen !== void 0 && value.read === void 0;
    }
    function isMessageWriter(value) {
      return value.write !== void 0 && value.end === void 0;
    }
    function createMessageConnection(input, output, logger96, strategy) {
      if (!logger96) {
        logger96 = exports2.NullLogger;
      }
      let reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
      let writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
      return _createMessageConnection(reader, writer, logger96, strategy);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-languageserver-types/lib/esm/main.js
var main_exports = {};
__export(main_exports, {
  CodeAction: () => CodeAction,
  CodeActionContext: () => CodeActionContext,
  CodeActionKind: () => CodeActionKind,
  CodeLens: () => CodeLens,
  Color: () => Color,
  ColorInformation: () => ColorInformation,
  ColorPresentation: () => ColorPresentation,
  Command: () => Command,
  CompletionItem: () => CompletionItem,
  CompletionItemKind: () => CompletionItemKind,
  CompletionItemTag: () => CompletionItemTag,
  CompletionList: () => CompletionList,
  CreateFile: () => CreateFile,
  DeleteFile: () => DeleteFile,
  Diagnostic: () => Diagnostic,
  DiagnosticRelatedInformation: () => DiagnosticRelatedInformation,
  DiagnosticSeverity: () => DiagnosticSeverity,
  DiagnosticTag: () => DiagnosticTag,
  DocumentHighlight: () => DocumentHighlight,
  DocumentHighlightKind: () => DocumentHighlightKind,
  DocumentLink: () => DocumentLink,
  DocumentSymbol: () => DocumentSymbol,
  EOL: () => EOL,
  FoldingRange: () => FoldingRange,
  FoldingRangeKind: () => FoldingRangeKind,
  FormattingOptions: () => FormattingOptions,
  Hover: () => Hover,
  InsertTextFormat: () => InsertTextFormat,
  Location: () => Location,
  LocationLink: () => LocationLink,
  MarkedString: () => MarkedString,
  MarkupContent: () => MarkupContent,
  MarkupKind: () => MarkupKind,
  ParameterInformation: () => ParameterInformation,
  Position: () => Position,
  Range: () => Range,
  RenameFile: () => RenameFile,
  SelectionRange: () => SelectionRange,
  SignatureInformation: () => SignatureInformation,
  SymbolInformation: () => SymbolInformation,
  SymbolKind: () => SymbolKind,
  SymbolTag: () => SymbolTag,
  TextDocument: () => TextDocument,
  TextDocumentEdit: () => TextDocumentEdit,
  TextDocumentIdentifier: () => TextDocumentIdentifier,
  TextDocumentItem: () => TextDocumentItem,
  TextEdit: () => TextEdit,
  VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier,
  WorkspaceChange: () => WorkspaceChange,
  WorkspaceEdit: () => WorkspaceEdit
});
var Position, Range, Location, LocationLink, Color, ColorInformation, ColorPresentation, FoldingRangeKind, FoldingRange, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Diagnostic, Command, TextEdit, TextDocumentEdit, CreateFile, RenameFile, DeleteFile, WorkspaceEdit, TextEditChangeImpl, WorkspaceChange, TextDocumentIdentifier, VersionedTextDocumentIdentifier, TextDocumentItem, MarkupKind, MarkupContent, CompletionItemKind, InsertTextFormat, CompletionItemTag, CompletionItem, CompletionList, MarkedString, Hover, ParameterInformation, SignatureInformation, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolTag, SymbolInformation, DocumentSymbol, CodeActionKind, CodeActionContext, CodeAction, CodeLens, FormattingOptions, DocumentLink, SelectionRange, EOL, TextDocument, FullTextDocument, Is;
var init_main = __esm({
  "node_modules/vscode-languageserver-types/lib/esm/main.js"() {
    "use strict";
    (function(Position37) {
      function create(line, character) {
        return { line, character };
      }
      Position37.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);
      }
      Position37.is = is;
    })(Position || (Position = {}));
    (function(Range30) {
      function create(one, two, three, four) {
        if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {
          return { start: Position.create(one, two), end: Position.create(three, four) };
        } else if (Position.is(one) && Position.is(two)) {
          return { start: one, end: two };
        } else {
          throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
      }
      Range30.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
      }
      Range30.is = is;
    })(Range || (Range = {}));
    (function(Location18) {
      function create(uri, range) {
        return { uri, range };
      }
      Location18.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
      }
      Location18.is = is;
    })(Location || (Location = {}));
    (function(LocationLink8) {
      function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
      }
      LocationLink8.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange)) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
      }
      LocationLink8.is = is;
    })(LocationLink || (LocationLink = {}));
    (function(Color5) {
      function create(red, green, blue2, alpha) {
        return {
          red,
          green,
          blue: blue2,
          alpha
        };
      }
      Color5.create = create;
      function is(value) {
        var candidate = value;
        return Is.number(candidate.red) && Is.number(candidate.green) && Is.number(candidate.blue) && Is.number(candidate.alpha);
      }
      Color5.is = is;
    })(Color || (Color = {}));
    (function(ColorInformation7) {
      function create(range, color) {
        return {
          range,
          color
        };
      }
      ColorInformation7.create = create;
      function is(value) {
        var candidate = value;
        return Range.is(candidate.range) && Color.is(candidate.color);
      }
      ColorInformation7.is = is;
    })(ColorInformation || (ColorInformation = {}));
    (function(ColorPresentation5) {
      function create(label, textEdit, additionalTextEdits) {
        return {
          label,
          textEdit,
          additionalTextEdits
        };
      }
      ColorPresentation5.create = create;
      function is(value) {
        var candidate = value;
        return Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
      }
      ColorPresentation5.is = is;
    })(ColorPresentation || (ColorPresentation = {}));
    (function(FoldingRangeKind2) {
      FoldingRangeKind2["Comment"] = "comment";
      FoldingRangeKind2["Imports"] = "imports";
      FoldingRangeKind2["Region"] = "region";
    })(FoldingRangeKind || (FoldingRangeKind = {}));
    (function(FoldingRange5) {
      function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
          startLine,
          endLine
        };
        if (Is.defined(startCharacter)) {
          result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
          result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
          result.kind = kind;
        }
        return result;
      }
      FoldingRange5.create = create;
      function is(value) {
        var candidate = value;
        return Is.number(candidate.startLine) && Is.number(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
      }
      FoldingRange5.is = is;
    })(FoldingRange || (FoldingRange = {}));
    (function(DiagnosticRelatedInformation2) {
      function create(location, message) {
        return {
          location,
          message
        };
      }
      DiagnosticRelatedInformation2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
      }
      DiagnosticRelatedInformation2.is = is;
    })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
    (function(DiagnosticSeverity7) {
      DiagnosticSeverity7.Error = 1;
      DiagnosticSeverity7.Warning = 2;
      DiagnosticSeverity7.Information = 3;
      DiagnosticSeverity7.Hint = 4;
    })(DiagnosticSeverity || (DiagnosticSeverity = {}));
    (function(DiagnosticTag6) {
      DiagnosticTag6.Unnecessary = 1;
      DiagnosticTag6.Deprecated = 2;
    })(DiagnosticTag || (DiagnosticTag = {}));
    (function(Diagnostic8) {
      function create(range, message, severity, code, source, relatedInformation) {
        var result = { range, message };
        if (Is.defined(severity)) {
          result.severity = severity;
        }
        if (Is.defined(code)) {
          result.code = code;
        }
        if (Is.defined(source)) {
          result.source = source;
        }
        if (Is.defined(relatedInformation)) {
          result.relatedInformation = relatedInformation;
        }
        return result;
      }
      Diagnostic8.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
      }
      Diagnostic8.is = is;
    })(Diagnostic || (Diagnostic = {}));
    (function(Command4) {
      function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var result = { title, command };
        if (Is.defined(args) && args.length > 0) {
          result.arguments = args;
        }
        return result;
      }
      Command4.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
      }
      Command4.is = is;
    })(Command || (Command = {}));
    (function(TextEdit20) {
      function replace(range, newText) {
        return { range, newText };
      }
      TextEdit20.replace = replace;
      function insert(position, newText) {
        return { range: { start: position, end: position }, newText };
      }
      TextEdit20.insert = insert;
      function del(range) {
        return { range, newText: "" };
      }
      TextEdit20.del = del;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
      }
      TextEdit20.is = is;
    })(TextEdit || (TextEdit = {}));
    (function(TextDocumentEdit6) {
      function create(textDocument, edits) {
        return { textDocument, edits };
      }
      TextDocumentEdit6.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && VersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
      }
      TextDocumentEdit6.is = is;
    })(TextDocumentEdit || (TextDocumentEdit = {}));
    (function(CreateFile3) {
      function create(uri, options) {
        var result = {
          kind: "create",
          uri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        return result;
      }
      CreateFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists)));
      }
      CreateFile3.is = is;
    })(CreateFile || (CreateFile = {}));
    (function(RenameFile3) {
      function create(oldUri, newUri, options) {
        var result = {
          kind: "rename",
          oldUri,
          newUri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        return result;
      }
      RenameFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists)));
      }
      RenameFile3.is = is;
    })(RenameFile || (RenameFile = {}));
    (function(DeleteFile3) {
      function create(uri, options) {
        var result = {
          kind: "delete",
          uri
        };
        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
          result.options = options;
        }
        return result;
      }
      DeleteFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists)));
      }
      DeleteFile3.is = is;
    })(DeleteFile || (DeleteFile = {}));
    (function(WorkspaceEdit9) {
      function is(value) {
        var candidate = value;
        return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
          if (Is.string(change.kind)) {
            return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
          } else {
            return TextDocumentEdit.is(change);
          }
        }));
      }
      WorkspaceEdit9.is = is;
    })(WorkspaceEdit || (WorkspaceEdit = {}));
    TextEditChangeImpl = function() {
      function TextEditChangeImpl2(edits) {
        this.edits = edits;
      }
      TextEditChangeImpl2.prototype.insert = function(position, newText) {
        this.edits.push(TextEdit.insert(position, newText));
      };
      TextEditChangeImpl2.prototype.replace = function(range, newText) {
        this.edits.push(TextEdit.replace(range, newText));
      };
      TextEditChangeImpl2.prototype.delete = function(range) {
        this.edits.push(TextEdit.del(range));
      };
      TextEditChangeImpl2.prototype.add = function(edit2) {
        this.edits.push(edit2);
      };
      TextEditChangeImpl2.prototype.all = function() {
        return this.edits;
      };
      TextEditChangeImpl2.prototype.clear = function() {
        this.edits.splice(0, this.edits.length);
      };
      return TextEditChangeImpl2;
    }();
    WorkspaceChange = function() {
      function WorkspaceChange2(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit) {
          this._workspaceEdit = workspaceEdit;
          if (workspaceEdit.documentChanges) {
            workspaceEdit.documentChanges.forEach(function(change) {
              if (TextDocumentEdit.is(change)) {
                var textEditChange = new TextEditChangeImpl(change.edits);
                _this._textEditChanges[change.textDocument.uri] = textEditChange;
              }
            });
          } else if (workspaceEdit.changes) {
            Object.keys(workspaceEdit.changes).forEach(function(key) {
              var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
              _this._textEditChanges[key] = textEditChange;
            });
          }
        }
      }
      Object.defineProperty(WorkspaceChange2.prototype, "edit", {
        get: function() {
          return this._workspaceEdit;
        },
        enumerable: true,
        configurable: true
      });
      WorkspaceChange2.prototype.getTextEditChange = function(key) {
        if (VersionedTextDocumentIdentifier.is(key)) {
          if (!this._workspaceEdit) {
            this._workspaceEdit = {
              documentChanges: []
            };
          }
          if (!this._workspaceEdit.documentChanges) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var textDocument = key;
          var result = this._textEditChanges[textDocument.uri];
          if (!result) {
            var edits = [];
            var textDocumentEdit = {
              textDocument,
              edits
            };
            this._workspaceEdit.documentChanges.push(textDocumentEdit);
            result = new TextEditChangeImpl(edits);
            this._textEditChanges[textDocument.uri] = result;
          }
          return result;
        } else {
          if (!this._workspaceEdit) {
            this._workspaceEdit = {
              changes: Object.create(null)
            };
          }
          if (!this._workspaceEdit.changes) {
            throw new Error("Workspace edit is not configured for normal text edit changes.");
          }
          var result = this._textEditChanges[key];
          if (!result) {
            var edits = [];
            this._workspaceEdit.changes[key] = edits;
            result = new TextEditChangeImpl(edits);
            this._textEditChanges[key] = result;
          }
          return result;
        }
      };
      WorkspaceChange2.prototype.createFile = function(uri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));
      };
      WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));
      };
      WorkspaceChange2.prototype.deleteFile = function(uri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));
      };
      WorkspaceChange2.prototype.checkDocumentChanges = function() {
        if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
      };
      return WorkspaceChange2;
    }();
    (function(TextDocumentIdentifier2) {
      function create(uri) {
        return { uri };
      }
      TextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
      }
      TextDocumentIdentifier2.is = is;
    })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
    (function(VersionedTextDocumentIdentifier2) {
      function create(uri, version2) {
        return { uri, version: version2 };
      }
      VersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));
      }
      VersionedTextDocumentIdentifier2.is = is;
    })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
    (function(TextDocumentItem2) {
      function create(uri, languageId, version2, text) {
        return { uri, languageId, version: version2, text };
      }
      TextDocumentItem2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);
      }
      TextDocumentItem2.is = is;
    })(TextDocumentItem || (TextDocumentItem = {}));
    (function(MarkupKind6) {
      MarkupKind6.PlainText = "plaintext";
      MarkupKind6.Markdown = "markdown";
    })(MarkupKind || (MarkupKind = {}));
    (function(MarkupKind6) {
      function is(value) {
        var candidate = value;
        return candidate === MarkupKind6.PlainText || candidate === MarkupKind6.Markdown;
      }
      MarkupKind6.is = is;
    })(MarkupKind || (MarkupKind = {}));
    (function(MarkupContent5) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
      }
      MarkupContent5.is = is;
    })(MarkupContent || (MarkupContent = {}));
    (function(CompletionItemKind6) {
      CompletionItemKind6.Text = 1;
      CompletionItemKind6.Method = 2;
      CompletionItemKind6.Function = 3;
      CompletionItemKind6.Constructor = 4;
      CompletionItemKind6.Field = 5;
      CompletionItemKind6.Variable = 6;
      CompletionItemKind6.Class = 7;
      CompletionItemKind6.Interface = 8;
      CompletionItemKind6.Module = 9;
      CompletionItemKind6.Property = 10;
      CompletionItemKind6.Unit = 11;
      CompletionItemKind6.Value = 12;
      CompletionItemKind6.Enum = 13;
      CompletionItemKind6.Keyword = 14;
      CompletionItemKind6.Snippet = 15;
      CompletionItemKind6.Color = 16;
      CompletionItemKind6.File = 17;
      CompletionItemKind6.Reference = 18;
      CompletionItemKind6.Folder = 19;
      CompletionItemKind6.EnumMember = 20;
      CompletionItemKind6.Constant = 21;
      CompletionItemKind6.Struct = 22;
      CompletionItemKind6.Event = 23;
      CompletionItemKind6.Operator = 24;
      CompletionItemKind6.TypeParameter = 25;
    })(CompletionItemKind || (CompletionItemKind = {}));
    (function(InsertTextFormat5) {
      InsertTextFormat5.PlainText = 1;
      InsertTextFormat5.Snippet = 2;
    })(InsertTextFormat || (InsertTextFormat = {}));
    (function(CompletionItemTag3) {
      CompletionItemTag3.Deprecated = 1;
    })(CompletionItemTag || (CompletionItemTag = {}));
    (function(CompletionItem5) {
      function create(label) {
        return { label };
      }
      CompletionItem5.create = create;
    })(CompletionItem || (CompletionItem = {}));
    (function(CompletionList4) {
      function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
      }
      CompletionList4.create = create;
    })(CompletionList || (CompletionList = {}));
    (function(MarkedString3) {
      function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
      }
      MarkedString3.fromPlainText = fromPlainText;
      function is(value) {
        var candidate = value;
        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
      }
      MarkedString3.is = is;
    })(MarkedString || (MarkedString = {}));
    (function(Hover6) {
      function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
      }
      Hover6.is = is;
    })(Hover || (Hover = {}));
    (function(ParameterInformation2) {
      function create(label, documentation) {
        return documentation ? { label, documentation } : { label };
      }
      ParameterInformation2.create = create;
    })(ParameterInformation || (ParameterInformation = {}));
    (function(SignatureInformation2) {
      function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          parameters[_i - 2] = arguments[_i];
        }
        var result = { label };
        if (Is.defined(documentation)) {
          result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
          result.parameters = parameters;
        } else {
          result.parameters = [];
        }
        return result;
      }
      SignatureInformation2.create = create;
    })(SignatureInformation || (SignatureInformation = {}));
    (function(DocumentHighlightKind4) {
      DocumentHighlightKind4.Text = 1;
      DocumentHighlightKind4.Read = 2;
      DocumentHighlightKind4.Write = 3;
    })(DocumentHighlightKind || (DocumentHighlightKind = {}));
    (function(DocumentHighlight6) {
      function create(range, kind) {
        var result = { range };
        if (Is.number(kind)) {
          result.kind = kind;
        }
        return result;
      }
      DocumentHighlight6.create = create;
    })(DocumentHighlight || (DocumentHighlight = {}));
    (function(SymbolKind5) {
      SymbolKind5.File = 1;
      SymbolKind5.Module = 2;
      SymbolKind5.Namespace = 3;
      SymbolKind5.Package = 4;
      SymbolKind5.Class = 5;
      SymbolKind5.Method = 6;
      SymbolKind5.Property = 7;
      SymbolKind5.Field = 8;
      SymbolKind5.Constructor = 9;
      SymbolKind5.Enum = 10;
      SymbolKind5.Interface = 11;
      SymbolKind5.Function = 12;
      SymbolKind5.Variable = 13;
      SymbolKind5.Constant = 14;
      SymbolKind5.String = 15;
      SymbolKind5.Number = 16;
      SymbolKind5.Boolean = 17;
      SymbolKind5.Array = 18;
      SymbolKind5.Object = 19;
      SymbolKind5.Key = 20;
      SymbolKind5.Null = 21;
      SymbolKind5.EnumMember = 22;
      SymbolKind5.Struct = 23;
      SymbolKind5.Event = 24;
      SymbolKind5.Operator = 25;
      SymbolKind5.TypeParameter = 26;
    })(SymbolKind || (SymbolKind = {}));
    (function(SymbolTag3) {
      SymbolTag3.Deprecated = 1;
    })(SymbolTag || (SymbolTag = {}));
    (function(SymbolInformation8) {
      function create(name2, kind, range, uri, containerName) {
        var result = {
          name: name2,
          kind,
          location: { uri, range }
        };
        if (containerName) {
          result.containerName = containerName;
        }
        return result;
      }
      SymbolInformation8.create = create;
    })(SymbolInformation || (SymbolInformation = {}));
    (function(DocumentSymbol9) {
      function create(name2, detail, kind, range, selectionRange, children) {
        var result = {
          name: name2,
          detail,
          kind,
          range,
          selectionRange
        };
        if (children !== void 0) {
          result.children = children;
        }
        return result;
      }
      DocumentSymbol9.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children));
      }
      DocumentSymbol9.is = is;
    })(DocumentSymbol || (DocumentSymbol = {}));
    (function(CodeActionKind8) {
      CodeActionKind8.Empty = "";
      CodeActionKind8.QuickFix = "quickfix";
      CodeActionKind8.Refactor = "refactor";
      CodeActionKind8.RefactorExtract = "refactor.extract";
      CodeActionKind8.RefactorInline = "refactor.inline";
      CodeActionKind8.RefactorRewrite = "refactor.rewrite";
      CodeActionKind8.Source = "source";
      CodeActionKind8.SourceOrganizeImports = "source.organizeImports";
      CodeActionKind8.SourceFixAll = "source.fixAll";
    })(CodeActionKind || (CodeActionKind = {}));
    (function(CodeActionContext6) {
      function create(diagnostics, only) {
        var result = { diagnostics };
        if (only !== void 0 && only !== null) {
          result.only = only;
        }
        return result;
      }
      CodeActionContext6.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
      }
      CodeActionContext6.is = is;
    })(CodeActionContext || (CodeActionContext = {}));
    (function(CodeAction4) {
      function create(title, commandOrEdit, kind) {
        var result = { title };
        if (Command.is(commandOrEdit)) {
          result.command = commandOrEdit;
        } else {
          result.edit = commandOrEdit;
        }
        if (kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      CodeAction4.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
      }
      CodeAction4.is = is;
    })(CodeAction || (CodeAction = {}));
    (function(CodeLens6) {
      function create(range, data) {
        var result = { range };
        if (Is.defined(data)) {
          result.data = data;
        }
        return result;
      }
      CodeLens6.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
      }
      CodeLens6.is = is;
    })(CodeLens || (CodeLens = {}));
    (function(FormattingOptions7) {
      function create(tabSize, insertSpaces) {
        return { tabSize, insertSpaces };
      }
      FormattingOptions7.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
      }
      FormattingOptions7.is = is;
    })(FormattingOptions || (FormattingOptions = {}));
    (function(DocumentLink7) {
      function create(range, target, data) {
        return { range, target, data };
      }
      DocumentLink7.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
      }
      DocumentLink7.is = is;
    })(DocumentLink || (DocumentLink = {}));
    (function(SelectionRange6) {
      function create(range, parent) {
        return { range, parent };
      }
      SelectionRange6.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange6.is(candidate.parent));
      }
      SelectionRange6.is = is;
    })(SelectionRange || (SelectionRange = {}));
    EOL = ["\n", "\r\n", "\r"];
    (function(TextDocument4) {
      function create(uri, languageId, version2, content) {
        return new FullTextDocument(uri, languageId, version2, content);
      }
      TextDocument4.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
      }
      TextDocument4.is = is;
      function applyEdits2(document2, edits) {
        var text = document2.getText();
        var sortedEdits = mergeSort2(edits, function(a, b) {
          var diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
          var e = sortedEdits[i];
          var startOffset = document2.offsetAt(e.range.start);
          var endOffset = document2.offsetAt(e.range.end);
          if (endOffset <= lastModifiedOffset) {
            text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
          } else {
            throw new Error("Overlapping edit");
          }
          lastModifiedOffset = startOffset;
        }
        return text;
      }
      TextDocument4.applyEdits = applyEdits2;
      function mergeSort2(data, compare) {
        if (data.length <= 1) {
          return data;
        }
        var p = data.length / 2 | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort2(left, compare);
        mergeSort2(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          var ret = compare(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
    })(TextDocument || (TextDocument = {}));
    FullTextDocument = function() {
      function FullTextDocument3(uri, languageId, version2, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version2;
        this._content = content;
        this._lineOffsets = void 0;
      }
      Object.defineProperty(FullTextDocument3.prototype, "uri", {
        get: function() {
          return this._uri;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "version", {
        get: function() {
          return this._version;
        },
        enumerable: true,
        configurable: true
      });
      FullTextDocument3.prototype.getText = function(range) {
        if (range) {
          var start = this.offsetAt(range.start);
          var end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      };
      FullTextDocument3.prototype.update = function(event, version2) {
        this._content = event.text;
        this._version = version2;
        this._lineOffsets = void 0;
      };
      FullTextDocument3.prototype.getLineOffsets = function() {
        if (this._lineOffsets === void 0) {
          var lineOffsets = [];
          var text = this._content;
          var isLineStart = true;
          for (var i = 0; i < text.length; i++) {
            if (isLineStart) {
              lineOffsets.push(i);
              isLineStart = false;
            }
            var ch = text.charAt(i);
            isLineStart = ch === "\r" || ch === "\n";
            if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
              i++;
            }
          }
          if (isLineStart && text.length > 0) {
            lineOffsets.push(text.length);
          }
          this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
      };
      FullTextDocument3.prototype.positionAt = function(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
          return Position.create(0, offset);
        }
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
      };
      FullTextDocument3.prototype.offsetAt = function(position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      };
      Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
        get: function() {
          return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
      });
      return FullTextDocument3;
    }();
    (function(Is5) {
      var toString = Object.prototype.toString;
      function defined(value) {
        return typeof value !== "undefined";
      }
      Is5.defined = defined;
      function undefined2(value) {
        return typeof value === "undefined";
      }
      Is5.undefined = undefined2;
      function boolean2(value) {
        return value === true || value === false;
      }
      Is5.boolean = boolean2;
      function string2(value) {
        return toString.call(value) === "[object String]";
      }
      Is5.string = string2;
      function number2(value) {
        return toString.call(value) === "[object Number]";
      }
      Is5.number = number2;
      function func2(value) {
        return toString.call(value) === "[object Function]";
      }
      Is5.func = func2;
      function objectLiteral2(value) {
        return value !== null && typeof value === "object";
      }
      Is5.objectLiteral = objectLiteral2;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      Is5.typedArray = typedArray;
    })(Is || (Is = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/utils/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function boolean2(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean2;
    function string2(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string2;
    function number2(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number2;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func2(value) {
      return typeof value === "function";
    }
    exports2.func = func2;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string2(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral2(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral2;
  }
});

// node_modules/vscode-languageserver-protocol/lib/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var vscode_jsonrpc_1 = require_main();
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var ImplementationRequest3;
    (function(ImplementationRequest4) {
      ImplementationRequest4.method = "textDocument/implementation";
      ImplementationRequest4.type = new messages_1.ProtocolRequestType(ImplementationRequest4.method);
      ImplementationRequest4.resultType = new vscode_jsonrpc_1.ProgressType();
    })(ImplementationRequest3 = exports2.ImplementationRequest || (exports2.ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var TypeDefinitionRequest3;
    (function(TypeDefinitionRequest4) {
      TypeDefinitionRequest4.method = "textDocument/typeDefinition";
      TypeDefinitionRequest4.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest4.method);
      TypeDefinitionRequest4.resultType = new vscode_jsonrpc_1.ProgressType();
    })(TypeDefinitionRequest3 = exports2.TypeDefinitionRequest || (exports2.TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js
var require_protocol_workspaceFolders = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.workspaceFolders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest2;
    (function(WorkspaceFoldersRequest3) {
      WorkspaceFoldersRequest3.type = new messages_1.ProtocolRequestType0("workspace/workspaceFolders");
    })(WorkspaceFoldersRequest2 = exports2.WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification2;
    (function(DidChangeWorkspaceFoldersNotification3) {
      DidChangeWorkspaceFoldersNotification3.type = new messages_1.ProtocolNotificationType("workspace/didChangeWorkspaceFolders");
    })(DidChangeWorkspaceFoldersNotification2 = exports2.DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var messages_1 = require_messages2();
    var ConfigurationRequest2;
    (function(ConfigurationRequest3) {
      ConfigurationRequest3.type = new messages_1.ProtocolRequestType("workspace/configuration");
    })(ConfigurationRequest2 = exports2.ConfigurationRequest || (exports2.ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var DocumentColorRequest3;
    (function(DocumentColorRequest4) {
      DocumentColorRequest4.method = "textDocument/documentColor";
      DocumentColorRequest4.type = new messages_1.ProtocolRequestType(DocumentColorRequest4.method);
      DocumentColorRequest4.resultType = new vscode_jsonrpc_1.ProgressType();
    })(DocumentColorRequest3 = exports2.DocumentColorRequest || (exports2.DocumentColorRequest = {}));
    var ColorPresentationRequest2;
    (function(ColorPresentationRequest3) {
      ColorPresentationRequest3.type = new messages_1.ProtocolRequestType("textDocument/colorPresentation");
    })(ColorPresentationRequest2 = exports2.ColorPresentationRequest || (exports2.ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var FoldingRangeKind2;
    (function(FoldingRangeKind3) {
      FoldingRangeKind3["Comment"] = "comment";
      FoldingRangeKind3["Imports"] = "imports";
      FoldingRangeKind3["Region"] = "region";
    })(FoldingRangeKind2 = exports2.FoldingRangeKind || (exports2.FoldingRangeKind = {}));
    var FoldingRangeRequest3;
    (function(FoldingRangeRequest4) {
      FoldingRangeRequest4.method = "textDocument/foldingRange";
      FoldingRangeRequest4.type = new messages_1.ProtocolRequestType(FoldingRangeRequest4.method);
      FoldingRangeRequest4.resultType = new vscode_jsonrpc_1.ProgressType();
    })(FoldingRangeRequest3 = exports2.FoldingRangeRequest || (exports2.FoldingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var DeclarationRequest3;
    (function(DeclarationRequest4) {
      DeclarationRequest4.method = "textDocument/declaration";
      DeclarationRequest4.type = new messages_1.ProtocolRequestType(DeclarationRequest4.method);
      DeclarationRequest4.resultType = new vscode_jsonrpc_1.ProgressType();
    })(DeclarationRequest3 = exports2.DeclarationRequest || (exports2.DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var SelectionRangeRequest3;
    (function(SelectionRangeRequest4) {
      SelectionRangeRequest4.method = "textDocument/selectionRange";
      SelectionRangeRequest4.type = new messages_1.ProtocolRequestType(SelectionRangeRequest4.method);
      SelectionRangeRequest4.resultType = new vscode_jsonrpc_1.ProgressType();
    })(SelectionRangeRequest3 = exports2.SelectionRangeRequest || (exports2.SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress3;
    (function(WorkDoneProgress4) {
      WorkDoneProgress4.type = new vscode_jsonrpc_1.ProgressType();
    })(WorkDoneProgress3 = exports2.WorkDoneProgress || (exports2.WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest2;
    (function(WorkDoneProgressCreateRequest3) {
      WorkDoneProgressCreateRequest3.type = new messages_1.ProtocolRequestType("window/workDoneProgress/create");
    })(WorkDoneProgressCreateRequest2 = exports2.WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType("window/workDoneProgress/cancel");
    })(WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Is5 = require_is2();
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var protocol_implementation_1 = require_protocol_implementation();
    exports2.ImplementationRequest = protocol_implementation_1.ImplementationRequest;
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    exports2.TypeDefinitionRequest = protocol_typeDefinition_1.TypeDefinitionRequest;
    var protocol_workspaceFolders_1 = require_protocol_workspaceFolders();
    exports2.WorkspaceFoldersRequest = protocol_workspaceFolders_1.WorkspaceFoldersRequest;
    exports2.DidChangeWorkspaceFoldersNotification = protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification;
    var protocol_configuration_1 = require_protocol_configuration();
    exports2.ConfigurationRequest = protocol_configuration_1.ConfigurationRequest;
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    exports2.DocumentColorRequest = protocol_colorProvider_1.DocumentColorRequest;
    exports2.ColorPresentationRequest = protocol_colorProvider_1.ColorPresentationRequest;
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    exports2.FoldingRangeRequest = protocol_foldingRange_1.FoldingRangeRequest;
    var protocol_declaration_1 = require_protocol_declaration();
    exports2.DeclarationRequest = protocol_declaration_1.DeclarationRequest;
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    exports2.SelectionRangeRequest = protocol_selectionRange_1.SelectionRangeRequest;
    var protocol_progress_1 = require_protocol_progress();
    exports2.WorkDoneProgress = protocol_progress_1.WorkDoneProgress;
    exports2.WorkDoneProgressCreateRequest = protocol_progress_1.WorkDoneProgressCreateRequest;
    exports2.WorkDoneProgressCancelNotification = protocol_progress_1.WorkDoneProgressCancelNotification;
    var DocumentFilter;
    (function(DocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is5.string(candidate.language) || Is5.string(candidate.scheme) || Is5.string(candidate.pattern);
      }
      DocumentFilter2.is = is;
    })(DocumentFilter = exports2.DocumentFilter || (exports2.DocumentFilter = {}));
    var DocumentSelector31;
    (function(DocumentSelector32) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is5.string(elem) && !DocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector32.is = is;
    })(DocumentSelector31 = exports2.DocumentSelector || (exports2.DocumentSelector = {}));
    var RegistrationRequest2;
    (function(RegistrationRequest3) {
      RegistrationRequest3.type = new messages_1.ProtocolRequestType("client/registerCapability");
    })(RegistrationRequest2 = exports2.RegistrationRequest || (exports2.RegistrationRequest = {}));
    var UnregistrationRequest2;
    (function(UnregistrationRequest3) {
      UnregistrationRequest3.type = new messages_1.ProtocolRequestType("client/unregisterCapability");
    })(UnregistrationRequest2 = exports2.UnregistrationRequest || (exports2.UnregistrationRequest = {}));
    var ResourceOperationKind2;
    (function(ResourceOperationKind3) {
      ResourceOperationKind3.Create = "create";
      ResourceOperationKind3.Rename = "rename";
      ResourceOperationKind3.Delete = "delete";
    })(ResourceOperationKind2 = exports2.ResourceOperationKind || (exports2.ResourceOperationKind = {}));
    var FailureHandlingKind2;
    (function(FailureHandlingKind3) {
      FailureHandlingKind3.Abort = "abort";
      FailureHandlingKind3.Transactional = "transactional";
      FailureHandlingKind3.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind3.Undo = "undo";
    })(FailureHandlingKind2 = exports2.FailureHandlingKind || (exports2.FailureHandlingKind = {}));
    var StaticRegistrationOptions2;
    (function(StaticRegistrationOptions3) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is5.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions3.hasId = hasId;
    })(StaticRegistrationOptions2 = exports2.StaticRegistrationOptions || (exports2.StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions2;
    (function(TextDocumentRegistrationOptions3) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector31.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions3.is = is;
    })(TextDocumentRegistrationOptions2 = exports2.TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions2;
    (function(WorkDoneProgressOptions3) {
      function is(value) {
        const candidate = value;
        return Is5.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is5.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions3.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is5.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions3.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions2 = exports2.WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = {}));
    var InitializeRequest2;
    (function(InitializeRequest3) {
      InitializeRequest3.type = new messages_1.ProtocolRequestType("initialize");
    })(InitializeRequest2 = exports2.InitializeRequest || (exports2.InitializeRequest = {}));
    var InitializeError2;
    (function(InitializeError3) {
      InitializeError3.unknownProtocolVersion = 1;
    })(InitializeError2 = exports2.InitializeError || (exports2.InitializeError = {}));
    var InitializedNotification2;
    (function(InitializedNotification3) {
      InitializedNotification3.type = new messages_1.ProtocolNotificationType("initialized");
    })(InitializedNotification2 = exports2.InitializedNotification || (exports2.InitializedNotification = {}));
    var ShutdownRequest2;
    (function(ShutdownRequest3) {
      ShutdownRequest3.type = new messages_1.ProtocolRequestType0("shutdown");
    })(ShutdownRequest2 = exports2.ShutdownRequest || (exports2.ShutdownRequest = {}));
    var ExitNotification2;
    (function(ExitNotification3) {
      ExitNotification3.type = new messages_1.ProtocolNotificationType0("exit");
    })(ExitNotification2 = exports2.ExitNotification || (exports2.ExitNotification = {}));
    var DidChangeConfigurationNotification2;
    (function(DidChangeConfigurationNotification3) {
      DidChangeConfigurationNotification3.type = new messages_1.ProtocolNotificationType("workspace/didChangeConfiguration");
    })(DidChangeConfigurationNotification2 = exports2.DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = {}));
    var MessageType2;
    (function(MessageType3) {
      MessageType3.Error = 1;
      MessageType3.Warning = 2;
      MessageType3.Info = 3;
      MessageType3.Log = 4;
    })(MessageType2 = exports2.MessageType || (exports2.MessageType = {}));
    var ShowMessageNotification2;
    (function(ShowMessageNotification3) {
      ShowMessageNotification3.type = new messages_1.ProtocolNotificationType("window/showMessage");
    })(ShowMessageNotification2 = exports2.ShowMessageNotification || (exports2.ShowMessageNotification = {}));
    var ShowMessageRequest2;
    (function(ShowMessageRequest3) {
      ShowMessageRequest3.type = new messages_1.ProtocolRequestType("window/showMessageRequest");
    })(ShowMessageRequest2 = exports2.ShowMessageRequest || (exports2.ShowMessageRequest = {}));
    var LogMessageNotification2;
    (function(LogMessageNotification3) {
      LogMessageNotification3.type = new messages_1.ProtocolNotificationType("window/logMessage");
    })(LogMessageNotification2 = exports2.LogMessageNotification || (exports2.LogMessageNotification = {}));
    var TelemetryEventNotification2;
    (function(TelemetryEventNotification3) {
      TelemetryEventNotification3.type = new messages_1.ProtocolNotificationType("telemetry/event");
    })(TelemetryEventNotification2 = exports2.TelemetryEventNotification || (exports2.TelemetryEventNotification = {}));
    var TextDocumentSyncKind2;
    (function(TextDocumentSyncKind3) {
      TextDocumentSyncKind3.None = 0;
      TextDocumentSyncKind3.Full = 1;
      TextDocumentSyncKind3.Incremental = 2;
    })(TextDocumentSyncKind2 = exports2.TextDocumentSyncKind || (exports2.TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification2;
    (function(DidOpenTextDocumentNotification3) {
      DidOpenTextDocumentNotification3.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification3.method);
    })(DidOpenTextDocumentNotification2 = exports2.DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = {}));
    var DidChangeTextDocumentNotification2;
    (function(DidChangeTextDocumentNotification3) {
      DidChangeTextDocumentNotification3.method = "textDocument/didChange";
      DidChangeTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification3.method);
    })(DidChangeTextDocumentNotification2 = exports2.DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification2;
    (function(DidCloseTextDocumentNotification3) {
      DidCloseTextDocumentNotification3.method = "textDocument/didClose";
      DidCloseTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification3.method);
    })(DidCloseTextDocumentNotification2 = exports2.DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification2;
    (function(DidSaveTextDocumentNotification3) {
      DidSaveTextDocumentNotification3.method = "textDocument/didSave";
      DidSaveTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification3.method);
    })(DidSaveTextDocumentNotification2 = exports2.DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason2;
    (function(TextDocumentSaveReason3) {
      TextDocumentSaveReason3.Manual = 1;
      TextDocumentSaveReason3.AfterDelay = 2;
      TextDocumentSaveReason3.FocusOut = 3;
    })(TextDocumentSaveReason2 = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification2;
    (function(WillSaveTextDocumentNotification3) {
      WillSaveTextDocumentNotification3.method = "textDocument/willSave";
      WillSaveTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification3.method);
    })(WillSaveTextDocumentNotification2 = exports2.WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest2;
    (function(WillSaveTextDocumentWaitUntilRequest3) {
      WillSaveTextDocumentWaitUntilRequest3.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest3.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest3.method);
    })(WillSaveTextDocumentWaitUntilRequest2 = exports2.WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification2;
    (function(DidChangeWatchedFilesNotification3) {
      DidChangeWatchedFilesNotification3.type = new messages_1.ProtocolNotificationType("workspace/didChangeWatchedFiles");
    })(DidChangeWatchedFilesNotification2 = exports2.DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = {}));
    var FileChangeType3;
    (function(FileChangeType4) {
      FileChangeType4.Created = 1;
      FileChangeType4.Changed = 2;
      FileChangeType4.Deleted = 3;
    })(FileChangeType3 = exports2.FileChangeType || (exports2.FileChangeType = {}));
    var WatchKind2;
    (function(WatchKind3) {
      WatchKind3.Create = 1;
      WatchKind3.Change = 2;
      WatchKind3.Delete = 4;
    })(WatchKind2 = exports2.WatchKind || (exports2.WatchKind = {}));
    var PublishDiagnosticsNotification2;
    (function(PublishDiagnosticsNotification3) {
      PublishDiagnosticsNotification3.type = new messages_1.ProtocolNotificationType("textDocument/publishDiagnostics");
    })(PublishDiagnosticsNotification2 = exports2.PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind3;
    (function(CompletionTriggerKind4) {
      CompletionTriggerKind4.Invoked = 1;
      CompletionTriggerKind4.TriggerCharacter = 2;
      CompletionTriggerKind4.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind3 = exports2.CompletionTriggerKind || (exports2.CompletionTriggerKind = {}));
    var CompletionRequest2;
    (function(CompletionRequest3) {
      CompletionRequest3.method = "textDocument/completion";
      CompletionRequest3.type = new messages_1.ProtocolRequestType(CompletionRequest3.method);
      CompletionRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
    })(CompletionRequest2 = exports2.CompletionRequest || (exports2.CompletionRequest = {}));
    var CompletionResolveRequest2;
    (function(CompletionResolveRequest3) {
      CompletionResolveRequest3.method = "completionItem/resolve";
      CompletionResolveRequest3.type = new messages_1.ProtocolRequestType(CompletionResolveRequest3.method);
    })(CompletionResolveRequest2 = exports2.CompletionResolveRequest || (exports2.CompletionResolveRequest = {}));
    var HoverRequest2;
    (function(HoverRequest3) {
      HoverRequest3.method = "textDocument/hover";
      HoverRequest3.type = new messages_1.ProtocolRequestType(HoverRequest3.method);
    })(HoverRequest2 = exports2.HoverRequest || (exports2.HoverRequest = {}));
    var SignatureHelpTriggerKind3;
    (function(SignatureHelpTriggerKind4) {
      SignatureHelpTriggerKind4.Invoked = 1;
      SignatureHelpTriggerKind4.TriggerCharacter = 2;
      SignatureHelpTriggerKind4.ContentChange = 3;
    })(SignatureHelpTriggerKind3 = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest2;
    (function(SignatureHelpRequest3) {
      SignatureHelpRequest3.method = "textDocument/signatureHelp";
      SignatureHelpRequest3.type = new messages_1.ProtocolRequestType(SignatureHelpRequest3.method);
    })(SignatureHelpRequest2 = exports2.SignatureHelpRequest || (exports2.SignatureHelpRequest = {}));
    var DefinitionRequest2;
    (function(DefinitionRequest3) {
      DefinitionRequest3.method = "textDocument/definition";
      DefinitionRequest3.type = new messages_1.ProtocolRequestType(DefinitionRequest3.method);
      DefinitionRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
    })(DefinitionRequest2 = exports2.DefinitionRequest || (exports2.DefinitionRequest = {}));
    var ReferencesRequest2;
    (function(ReferencesRequest3) {
      ReferencesRequest3.method = "textDocument/references";
      ReferencesRequest3.type = new messages_1.ProtocolRequestType(ReferencesRequest3.method);
      ReferencesRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
    })(ReferencesRequest2 = exports2.ReferencesRequest || (exports2.ReferencesRequest = {}));
    var DocumentHighlightRequest2;
    (function(DocumentHighlightRequest3) {
      DocumentHighlightRequest3.method = "textDocument/documentHighlight";
      DocumentHighlightRequest3.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest3.method);
      DocumentHighlightRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
    })(DocumentHighlightRequest2 = exports2.DocumentHighlightRequest || (exports2.DocumentHighlightRequest = {}));
    var DocumentSymbolRequest2;
    (function(DocumentSymbolRequest3) {
      DocumentSymbolRequest3.method = "textDocument/documentSymbol";
      DocumentSymbolRequest3.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest3.method);
      DocumentSymbolRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
    })(DocumentSymbolRequest2 = exports2.DocumentSymbolRequest || (exports2.DocumentSymbolRequest = {}));
    var CodeActionRequest2;
    (function(CodeActionRequest3) {
      CodeActionRequest3.method = "textDocument/codeAction";
      CodeActionRequest3.type = new messages_1.ProtocolRequestType(CodeActionRequest3.method);
      CodeActionRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
    })(CodeActionRequest2 = exports2.CodeActionRequest || (exports2.CodeActionRequest = {}));
    var WorkspaceSymbolRequest2;
    (function(WorkspaceSymbolRequest3) {
      WorkspaceSymbolRequest3.method = "workspace/symbol";
      WorkspaceSymbolRequest3.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest3.method);
      WorkspaceSymbolRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceSymbolRequest2 = exports2.WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = {}));
    var CodeLensRequest2;
    (function(CodeLensRequest3) {
      CodeLensRequest3.type = new messages_1.ProtocolRequestType("textDocument/codeLens");
      CodeLensRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
    })(CodeLensRequest2 = exports2.CodeLensRequest || (exports2.CodeLensRequest = {}));
    var CodeLensResolveRequest2;
    (function(CodeLensResolveRequest3) {
      CodeLensResolveRequest3.type = new messages_1.ProtocolRequestType("codeLens/resolve");
    })(CodeLensResolveRequest2 = exports2.CodeLensResolveRequest || (exports2.CodeLensResolveRequest = {}));
    var DocumentLinkRequest2;
    (function(DocumentLinkRequest3) {
      DocumentLinkRequest3.method = "textDocument/documentLink";
      DocumentLinkRequest3.type = new messages_1.ProtocolRequestType(DocumentLinkRequest3.method);
      DocumentLinkRequest3.resultType = new vscode_jsonrpc_1.ProgressType();
    })(DocumentLinkRequest2 = exports2.DocumentLinkRequest || (exports2.DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest2;
    (function(DocumentLinkResolveRequest3) {
      DocumentLinkResolveRequest3.type = new messages_1.ProtocolRequestType("documentLink/resolve");
    })(DocumentLinkResolveRequest2 = exports2.DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest2;
    (function(DocumentFormattingRequest3) {
      DocumentFormattingRequest3.method = "textDocument/formatting";
      DocumentFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest3.method);
    })(DocumentFormattingRequest2 = exports2.DocumentFormattingRequest || (exports2.DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest2;
    (function(DocumentRangeFormattingRequest3) {
      DocumentRangeFormattingRequest3.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest3.method);
    })(DocumentRangeFormattingRequest2 = exports2.DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest2;
    (function(DocumentOnTypeFormattingRequest3) {
      DocumentOnTypeFormattingRequest3.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest3.method);
    })(DocumentOnTypeFormattingRequest2 = exports2.DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = {}));
    var RenameRequest2;
    (function(RenameRequest3) {
      RenameRequest3.method = "textDocument/rename";
      RenameRequest3.type = new messages_1.ProtocolRequestType(RenameRequest3.method);
    })(RenameRequest2 = exports2.RenameRequest || (exports2.RenameRequest = {}));
    var PrepareRenameRequest2;
    (function(PrepareRenameRequest3) {
      PrepareRenameRequest3.method = "textDocument/prepareRename";
      PrepareRenameRequest3.type = new messages_1.ProtocolRequestType(PrepareRenameRequest3.method);
    })(PrepareRenameRequest2 = exports2.PrepareRenameRequest || (exports2.PrepareRenameRequest = {}));
    var ExecuteCommandRequest3;
    (function(ExecuteCommandRequest4) {
      ExecuteCommandRequest4.type = new messages_1.ProtocolRequestType("workspace/executeCommand");
    })(ExecuteCommandRequest3 = exports2.ExecuteCommandRequest || (exports2.ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest2;
    (function(ApplyWorkspaceEditRequest3) {
      ApplyWorkspaceEditRequest3.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest2 = exports2.ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js
var require_protocol_callHierarchy_proposed = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.callHierarchy.proposed.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest = exports2.CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest = exports2.CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js
var require_protocol_sematicTokens_proposed = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/protocol.sematicTokens.proposed.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var messages_1 = require_messages2();
    var SemanticTokenTypes;
    (function(SemanticTokenTypes2) {
      SemanticTokenTypes2["comment"] = "comment";
      SemanticTokenTypes2["keyword"] = "keyword";
      SemanticTokenTypes2["string"] = "string";
      SemanticTokenTypes2["number"] = "number";
      SemanticTokenTypes2["regexp"] = "regexp";
      SemanticTokenTypes2["operator"] = "operator";
      SemanticTokenTypes2["namespace"] = "namespace";
      SemanticTokenTypes2["type"] = "type";
      SemanticTokenTypes2["struct"] = "struct";
      SemanticTokenTypes2["class"] = "class";
      SemanticTokenTypes2["interface"] = "interface";
      SemanticTokenTypes2["enum"] = "enum";
      SemanticTokenTypes2["typeParameter"] = "typeParameter";
      SemanticTokenTypes2["function"] = "function";
      SemanticTokenTypes2["member"] = "member";
      SemanticTokenTypes2["property"] = "property";
      SemanticTokenTypes2["macro"] = "macro";
      SemanticTokenTypes2["variable"] = "variable";
      SemanticTokenTypes2["parameter"] = "parameter";
      SemanticTokenTypes2["label"] = "label";
    })(SemanticTokenTypes = exports2.SemanticTokenTypes || (exports2.SemanticTokenTypes = {}));
    var SemanticTokenModifiers;
    (function(SemanticTokenModifiers2) {
      SemanticTokenModifiers2["documentation"] = "documentation";
      SemanticTokenModifiers2["declaration"] = "declaration";
      SemanticTokenModifiers2["definition"] = "definition";
      SemanticTokenModifiers2["reference"] = "reference";
      SemanticTokenModifiers2["static"] = "static";
      SemanticTokenModifiers2["abstract"] = "abstract";
      SemanticTokenModifiers2["deprecated"] = "deprecated";
      SemanticTokenModifiers2["async"] = "async";
      SemanticTokenModifiers2["volatile"] = "volatile";
      SemanticTokenModifiers2["readonly"] = "readonly";
    })(SemanticTokenModifiers = exports2.SemanticTokenModifiers || (exports2.SemanticTokenModifiers = {}));
    var SemanticTokens;
    (function(SemanticTokens2) {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
      }
      SemanticTokens2.is = is;
    })(SemanticTokens = exports2.SemanticTokens || (exports2.SemanticTokens = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens";
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
    })(SemanticTokensRequest = exports2.SemanticTokensRequest || (exports2.SemanticTokensRequest = {}));
    var SemanticTokensEditsRequest;
    (function(SemanticTokensEditsRequest2) {
      SemanticTokensEditsRequest2.method = "textDocument/semanticTokens/edits";
      SemanticTokensEditsRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensEditsRequest2.method);
    })(SemanticTokensEditsRequest = exports2.SemanticTokensEditsRequest || (exports2.SemanticTokensEditsRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
    })(SemanticTokensRangeRequest = exports2.SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/main.js"(exports2) {
    "use strict";
    function __export2(m) {
      for (var p in m)
        if (!exports2.hasOwnProperty(p))
          exports2[p] = m[p];
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    var vscode_jsonrpc_1 = require_main();
    exports2.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
    exports2.ResponseError = vscode_jsonrpc_1.ResponseError;
    exports2.CancellationToken = vscode_jsonrpc_1.CancellationToken;
    exports2.CancellationTokenSource = vscode_jsonrpc_1.CancellationTokenSource;
    exports2.Disposable = vscode_jsonrpc_1.Disposable;
    exports2.Event = vscode_jsonrpc_1.Event;
    exports2.Emitter = vscode_jsonrpc_1.Emitter;
    exports2.Trace = vscode_jsonrpc_1.Trace;
    exports2.TraceFormat = vscode_jsonrpc_1.TraceFormat;
    exports2.SetTraceNotification = vscode_jsonrpc_1.SetTraceNotification;
    exports2.LogTraceNotification = vscode_jsonrpc_1.LogTraceNotification;
    exports2.RequestType = vscode_jsonrpc_1.RequestType;
    exports2.RequestType0 = vscode_jsonrpc_1.RequestType0;
    exports2.NotificationType = vscode_jsonrpc_1.NotificationType;
    exports2.NotificationType0 = vscode_jsonrpc_1.NotificationType0;
    exports2.MessageReader = vscode_jsonrpc_1.MessageReader;
    exports2.MessageWriter = vscode_jsonrpc_1.MessageWriter;
    exports2.ConnectionStrategy = vscode_jsonrpc_1.ConnectionStrategy;
    exports2.StreamMessageReader = vscode_jsonrpc_1.StreamMessageReader;
    exports2.StreamMessageWriter = vscode_jsonrpc_1.StreamMessageWriter;
    exports2.IPCMessageReader = vscode_jsonrpc_1.IPCMessageReader;
    exports2.IPCMessageWriter = vscode_jsonrpc_1.IPCMessageWriter;
    exports2.createClientPipeTransport = vscode_jsonrpc_1.createClientPipeTransport;
    exports2.createServerPipeTransport = vscode_jsonrpc_1.createServerPipeTransport;
    exports2.generateRandomPipeName = vscode_jsonrpc_1.generateRandomPipeName;
    exports2.createClientSocketTransport = vscode_jsonrpc_1.createClientSocketTransport;
    exports2.createServerSocketTransport = vscode_jsonrpc_1.createServerSocketTransport;
    exports2.ProgressType = vscode_jsonrpc_1.ProgressType;
    __export2((init_main(), main_exports));
    __export2(require_protocol());
    var callHierarchy = require_protocol_callHierarchy_proposed();
    var st = require_protocol_sematicTokens_proposed();
    var Proposed2;
    (function(Proposed3) {
      let CallHierarchyPrepareRequest;
      (function(CallHierarchyPrepareRequest2) {
        CallHierarchyPrepareRequest2.method = callHierarchy.CallHierarchyPrepareRequest.method;
        CallHierarchyPrepareRequest2.type = callHierarchy.CallHierarchyPrepareRequest.type;
      })(CallHierarchyPrepareRequest = Proposed3.CallHierarchyPrepareRequest || (Proposed3.CallHierarchyPrepareRequest = {}));
      let CallHierarchyIncomingCallsRequest;
      (function(CallHierarchyIncomingCallsRequest2) {
        CallHierarchyIncomingCallsRequest2.method = callHierarchy.CallHierarchyIncomingCallsRequest.method;
        CallHierarchyIncomingCallsRequest2.type = callHierarchy.CallHierarchyIncomingCallsRequest.type;
      })(CallHierarchyIncomingCallsRequest = Proposed3.CallHierarchyIncomingCallsRequest || (Proposed3.CallHierarchyIncomingCallsRequest = {}));
      let CallHierarchyOutgoingCallsRequest;
      (function(CallHierarchyOutgoingCallsRequest2) {
        CallHierarchyOutgoingCallsRequest2.method = callHierarchy.CallHierarchyOutgoingCallsRequest.method;
        CallHierarchyOutgoingCallsRequest2.type = callHierarchy.CallHierarchyOutgoingCallsRequest.type;
      })(CallHierarchyOutgoingCallsRequest = Proposed3.CallHierarchyOutgoingCallsRequest || (Proposed3.CallHierarchyOutgoingCallsRequest = {}));
      Proposed3.SemanticTokenTypes = st.SemanticTokenTypes;
      Proposed3.SemanticTokenModifiers = st.SemanticTokenModifiers;
      Proposed3.SemanticTokens = st.SemanticTokens;
      let SemanticTokensRequest;
      (function(SemanticTokensRequest2) {
        SemanticTokensRequest2.method = st.SemanticTokensRequest.method;
        SemanticTokensRequest2.type = st.SemanticTokensRequest.type;
      })(SemanticTokensRequest = Proposed3.SemanticTokensRequest || (Proposed3.SemanticTokensRequest = {}));
      let SemanticTokensEditsRequest;
      (function(SemanticTokensEditsRequest2) {
        SemanticTokensEditsRequest2.method = st.SemanticTokensEditsRequest.method;
        SemanticTokensEditsRequest2.type = st.SemanticTokensEditsRequest.type;
      })(SemanticTokensEditsRequest = Proposed3.SemanticTokensEditsRequest || (Proposed3.SemanticTokensEditsRequest = {}));
      let SemanticTokensRangeRequest;
      (function(SemanticTokensRangeRequest2) {
        SemanticTokensRangeRequest2.method = st.SemanticTokensRangeRequest.method;
        SemanticTokensRangeRequest2.type = st.SemanticTokensRangeRequest.type;
      })(SemanticTokensRangeRequest = Proposed3.SemanticTokensRangeRequest || (Proposed3.SemanticTokensRangeRequest = {}));
    })(Proposed2 = exports2.Proposed || (exports2.Proposed = {}));
    function createProtocolConnection2(reader, writer, logger96, strategy) {
      return vscode_jsonrpc_1.createMessageConnection(reader, writer, logger96, strategy);
    }
    exports2.createProtocolConnection = createProtocolConnection2;
  }
});

// node_modules/debounce/index.js
var require_debounce = __commonJS({
  "node_modules/debounce/index.js"(exports2, module2) {
    function debounce13(func2, wait2, immediate) {
      var timeout, args, context, timestamp, result;
      if (wait2 == null)
        wait2 = 100;
      function later() {
        var last = Date.now() - timestamp;
        if (last < wait2 && last >= 0) {
          timeout = setTimeout(later, wait2 - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func2.apply(context, args);
            context = args = null;
          }
        }
      }
      ;
      var debounced = function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout)
          timeout = setTimeout(later, wait2);
        if (callNow) {
          result = func2.apply(context, args);
          context = args = null;
        }
        return result;
      };
      debounced.clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
      };
      debounced.flush = function() {
        if (timeout) {
          result = func2.apply(context, args);
          context = args = null;
          clearTimeout(timeout);
          timeout = null;
        }
      };
      return debounced;
    }
    debounce13.debounce = debounce13;
    module2.exports = debounce13;
  }
});

// node_modules/rfc-3986/index.js
var require_rfc_3986 = __commonJS({
  "node_modules/rfc-3986/index.js"(exports2, module2) {
    "use strict";
    var internals = {
      rfc3986: {}
    };
    internals.generate = function() {
      var or = "|";
      var digit = "0-9";
      var digitOnly = "[" + digit + "]";
      var alpha = "a-zA-Z";
      var alphaOnly = "[" + alpha + "]";
      internals.rfc3986.cidr = digitOnly + or + "[1-2]" + digitOnly + or + "3[0-2]";
      var hexDigit = digit + "A-Fa-f";
      var hexDigitOnly = "[" + hexDigit + "]";
      var unreserved = alpha + digit + "-\\._~";
      var subDelims = "!\\$&'\\(\\)\\*\\+,;=";
      var pctEncoded = "%" + hexDigit;
      var pchar = unreserved + pctEncoded + subDelims + ":@";
      var pcharOnly = "[" + pchar + "]";
      var zeroPad = "0?";
      var decOctect = "(?:" + zeroPad + zeroPad + digitOnly + or + zeroPad + "[1-9]" + digitOnly + or + "1" + digitOnly + digitOnly + or + "2[0-4]" + digitOnly + or + "25[0-5])";
      internals.rfc3986.IPv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
      var h16 = hexDigitOnly + "{1,4}";
      var ls32 = "(?:" + h16 + ":" + h16 + "|" + internals.rfc3986.IPv4address + ")";
      var IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
      var IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
      var IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
      var IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
      var IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
      var IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
      var IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
      var IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
      var IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
      internals.rfc3986.IPv6address = "(?:" + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ")";
      internals.rfc3986.IPvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
      internals.rfc3986.scheme = alphaOnly + "[" + alpha + digit + "+-\\.]*";
      var userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
      internals.rfc3986.IPLiteral = "\\[(?:" + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ")\\]";
      var regName = "[" + unreserved + pctEncoded + subDelims + "]{0,255}";
      var host = "(?:" + internals.rfc3986.IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ")";
      var port = digitOnly + "*";
      var authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
      var segment = pcharOnly + "*";
      var segmentNz = pcharOnly + "+";
      var pathAbEmpty = "(?:\\/" + segment + ")*";
      var pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
      var pathRootless = segmentNz + pathAbEmpty;
      internals.rfc3986.hierPart = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")" + or + pathAbsolute + or + pathRootless + ")";
      internals.rfc3986.query = "[" + pchar + "\\/\\?]*(?=#|$)";
      internals.rfc3986.fragment = "[" + pchar + "\\/\\?]*";
      internals.rfc3986.uri = "^(?:" + internals.rfc3986.scheme + ":" + internals.rfc3986.hierPart + ")(?:\\?" + internals.rfc3986.query + ")?(?:#" + internals.rfc3986.fragment + ")?$";
    };
    internals.generate();
    module2.exports = internals.rfc3986;
  }
});

// node_modules/isuri/index.js
var require_isuri = __commonJS({
  "node_modules/isuri/index.js"(exports2, module2) {
    "use strict";
    var rfc3986 = require_rfc_3986();
    function escapeRegex(string2) {
      return string2.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
    }
    var internals = {
      Uri: {
        createUriRegex: function(options) {
          options = options || {};
          if (typeof options !== "object" || Array.isArray(options)) {
            throw new Error("options must be an object");
          }
          var customScheme = "";
          if (options.scheme) {
            if (!Array.isArray(options.scheme)) {
              options.scheme = [options.scheme];
            }
            if (options.scheme.length <= 0) {
              throw new Error("scheme must have at least 1 scheme specified");
            }
            for (var i = 0; i < options.scheme.length; ++i) {
              var currentScheme = options.scheme[i];
              if (!(currentScheme instanceof RegExp || typeof currentScheme === "string")) {
                throw new Error("scheme must only contain Regular Expressions or Strings");
              }
              customScheme = customScheme + (customScheme ? "|" : "");
              if (currentScheme instanceof RegExp) {
                customScheme = customScheme + currentScheme.source;
              } else {
                if (!/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(currentScheme)) {
                  throw new Error("scheme at position " + i + " must be a valid scheme");
                }
                customScheme = customScheme + escapeRegex(currentScheme);
              }
            }
          }
          var scheme = "(?:" + (customScheme || rfc3986.scheme) + ")";
          return new RegExp("^(?:" + scheme + ":" + rfc3986.hierPart + ")(?:\\?" + rfc3986.query + ")?(?:#" + rfc3986.fragment + ")?$");
        },
        uriRegex: new RegExp(rfc3986.uri)
      }
    };
    internals.Uri.isValid = function(val) {
      return internals.Uri.uriRegex.test(val);
    };
    module2.exports = {
      createUriRegex: internals.Uri.createUriRegex,
      uriRegex: internals.Uri.uriRegex,
      isValid: internals.Uri.isValid
    };
  }
});

// node_modules/vscode-uri/lib/esm/index.js
function _validateUri(ret, _strict) {
  if (!ret.scheme && _strict) {
    throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "' + ret.authority + '", path: "' + ret.path + '", query: "' + ret.query + '", fragment: "' + ret.fragment + '"}');
  }
  if (ret.scheme && !_schemePattern.test(ret.scheme)) {
    throw new Error("[UriError]: Scheme contains illegal characters.");
  }
  if (ret.path) {
    if (ret.authority) {
      if (!_singleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      }
    } else {
      if (_doubleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
  }
}
function _schemeFix(scheme, _strict) {
  if (!scheme && !_strict) {
    return "file";
  }
  return scheme;
}
function _referenceResolution(scheme, path34) {
  switch (scheme) {
    case "https":
    case "http":
    case "file":
      if (!path34) {
        path34 = _slash;
      } else if (path34[0] !== _slash) {
        path34 = _slash + path34;
      }
      break;
  }
  return path34;
}
function encodeURIComponentFast(uriComponent, allowSlash) {
  var res = void 0;
  var nativeEncodePos = -1;
  for (var pos = 0; pos < uriComponent.length; pos++) {
    var code = uriComponent.charCodeAt(pos);
    if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || allowSlash && code === 47) {
      if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
        nativeEncodePos = -1;
      }
      if (res !== void 0) {
        res += uriComponent.charAt(pos);
      }
    } else {
      if (res === void 0) {
        res = uriComponent.substr(0, pos);
      }
      var escaped = encodeTable[code];
      if (escaped !== void 0) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        res += escaped;
      } else if (nativeEncodePos === -1) {
        nativeEncodePos = pos;
      }
    }
  }
  if (nativeEncodePos !== -1) {
    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
  }
  return res !== void 0 ? res : uriComponent;
}
function encodeURIComponentMinimal(path34) {
  var res = void 0;
  for (var pos = 0; pos < path34.length; pos++) {
    var code = path34.charCodeAt(pos);
    if (code === 35 || code === 63) {
      if (res === void 0) {
        res = path34.substr(0, pos);
      }
      res += encodeTable[code];
    } else {
      if (res !== void 0) {
        res += path34[pos];
      }
    }
  }
  return res !== void 0 ? res : path34;
}
function uriToFsPath(uri, keepDriveLetterCasing) {
  var value;
  if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
    value = "//" + uri.authority + uri.path;
  } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
    if (!keepDriveLetterCasing) {
      value = uri.path[1].toLowerCase() + uri.path.substr(2);
    } else {
      value = uri.path.substr(1);
    }
  } else {
    value = uri.path;
  }
  if (isWindows) {
    value = value.replace(/\//g, "\\");
  }
  return value;
}
function _asFormatted(uri, skipEncoding) {
  var encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
  var res = "";
  var scheme = uri.scheme, authority = uri.authority, path34 = uri.path, query = uri.query, fragment = uri.fragment;
  if (scheme) {
    res += scheme;
    res += ":";
  }
  if (authority || scheme === "file") {
    res += _slash;
    res += _slash;
  }
  if (authority) {
    var idx = authority.indexOf("@");
    if (idx !== -1) {
      var userinfo = authority.substr(0, idx);
      authority = authority.substr(idx + 1);
      idx = userinfo.indexOf(":");
      if (idx === -1) {
        res += encoder(userinfo, false);
      } else {
        res += encoder(userinfo.substr(0, idx), false);
        res += ":";
        res += encoder(userinfo.substr(idx + 1), false);
      }
      res += "@";
    }
    authority = authority.toLowerCase();
    idx = authority.indexOf(":");
    if (idx === -1) {
      res += encoder(authority, false);
    } else {
      res += encoder(authority.substr(0, idx), false);
      res += authority.substr(idx);
    }
  }
  if (path34) {
    if (path34.length >= 3 && path34.charCodeAt(0) === 47 && path34.charCodeAt(2) === 58) {
      var code = path34.charCodeAt(1);
      if (code >= 65 && code <= 90) {
        path34 = "/" + String.fromCharCode(code + 32) + ":" + path34.substr(3);
      }
    } else if (path34.length >= 2 && path34.charCodeAt(1) === 58) {
      var code = path34.charCodeAt(0);
      if (code >= 65 && code <= 90) {
        path34 = String.fromCharCode(code + 32) + ":" + path34.substr(2);
      }
    }
    res += encoder(path34, true);
  }
  if (query) {
    res += "?";
    res += encoder(query, false);
  }
  if (fragment) {
    res += "#";
    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
  }
  return res;
}
function decodeURIComponentGraceful(str) {
  try {
    return decodeURIComponent(str);
  } catch (_a2) {
    if (str.length > 3) {
      return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
    } else {
      return str;
    }
  }
}
function percentDecode(str) {
  if (!str.match(_rEncodedAsHex)) {
    return str;
  }
  return str.replace(_rEncodedAsHex, function(match) {
    return decodeURIComponentGraceful(match);
  });
}
var __extends, _a, isWindows, userAgent, _schemePattern, _singleSlashStart, _doubleSlashStart, _empty, _slash, _regexp, URI, _pathSepMarker, _URI, encodeTable, _rEncodedAsHex;
var init_esm2 = __esm({
  "node_modules/vscode-uri/lib/esm/index.js"() {
    "use strict";
    __extends = function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    if (typeof process === "object") {
      isWindows = process.platform === "win32";
    } else if (typeof navigator === "object") {
      userAgent = navigator.userAgent;
      isWindows = userAgent.indexOf("Windows") >= 0;
    }
    _schemePattern = /^\w[\w\d+.-]*$/;
    _singleSlashStart = /^\//;
    _doubleSlashStart = /^\/\//;
    _empty = "";
    _slash = "/";
    _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    URI = function() {
      function URI2(schemeOrData, authority, path34, query, fragment, _strict) {
        if (_strict === void 0) {
          _strict = false;
        }
        if (typeof schemeOrData === "object") {
          this.scheme = schemeOrData.scheme || _empty;
          this.authority = schemeOrData.authority || _empty;
          this.path = schemeOrData.path || _empty;
          this.query = schemeOrData.query || _empty;
          this.fragment = schemeOrData.fragment || _empty;
        } else {
          this.scheme = _schemeFix(schemeOrData, _strict);
          this.authority = authority || _empty;
          this.path = _referenceResolution(this.scheme, path34 || _empty);
          this.query = query || _empty;
          this.fragment = fragment || _empty;
          _validateUri(this, _strict);
        }
      }
      URI2.isUri = function(thing) {
        if (thing instanceof URI2) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "function" && typeof thing.with === "function" && typeof thing.toString === "function";
      };
      Object.defineProperty(URI2.prototype, "fsPath", {
        get: function() {
          return uriToFsPath(this, false);
        },
        enumerable: true,
        configurable: true
      });
      URI2.prototype.with = function(change) {
        if (!change) {
          return this;
        }
        var scheme = change.scheme, authority = change.authority, path34 = change.path, query = change.query, fragment = change.fragment;
        if (scheme === void 0) {
          scheme = this.scheme;
        } else if (scheme === null) {
          scheme = _empty;
        }
        if (authority === void 0) {
          authority = this.authority;
        } else if (authority === null) {
          authority = _empty;
        }
        if (path34 === void 0) {
          path34 = this.path;
        } else if (path34 === null) {
          path34 = _empty;
        }
        if (query === void 0) {
          query = this.query;
        } else if (query === null) {
          query = _empty;
        }
        if (fragment === void 0) {
          fragment = this.fragment;
        } else if (fragment === null) {
          fragment = _empty;
        }
        if (scheme === this.scheme && authority === this.authority && path34 === this.path && query === this.query && fragment === this.fragment) {
          return this;
        }
        return new _URI(scheme, authority, path34, query, fragment);
      };
      URI2.parse = function(value, _strict) {
        if (_strict === void 0) {
          _strict = false;
        }
        var match = _regexp.exec(value);
        if (!match) {
          return new _URI(_empty, _empty, _empty, _empty, _empty);
        }
        return new _URI(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
      };
      URI2.file = function(path34) {
        var authority = _empty;
        if (isWindows) {
          path34 = path34.replace(/\\/g, _slash);
        }
        if (path34[0] === _slash && path34[1] === _slash) {
          var idx = path34.indexOf(_slash, 2);
          if (idx === -1) {
            authority = path34.substring(2);
            path34 = _slash;
          } else {
            authority = path34.substring(2, idx);
            path34 = path34.substring(idx) || _slash;
          }
        }
        return new _URI("file", authority, path34, _empty, _empty);
      };
      URI2.from = function(components) {
        return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);
      };
      URI2.prototype.toString = function(skipEncoding) {
        if (skipEncoding === void 0) {
          skipEncoding = false;
        }
        return _asFormatted(this, skipEncoding);
      };
      URI2.prototype.toJSON = function() {
        return this;
      };
      URI2.revive = function(data) {
        if (!data) {
          return data;
        } else if (data instanceof URI2) {
          return data;
        } else {
          var result = new _URI(data);
          result._formatted = data.external;
          result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
          return result;
        }
      };
      return URI2;
    }();
    _pathSepMarker = isWindows ? 1 : void 0;
    _URI = function(_super) {
      __extends(_URI2, _super);
      function _URI2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._formatted = null;
        _this._fsPath = null;
        return _this;
      }
      Object.defineProperty(_URI2.prototype, "fsPath", {
        get: function() {
          if (!this._fsPath) {
            this._fsPath = uriToFsPath(this, false);
          }
          return this._fsPath;
        },
        enumerable: true,
        configurable: true
      });
      _URI2.prototype.toString = function(skipEncoding) {
        if (skipEncoding === void 0) {
          skipEncoding = false;
        }
        if (!skipEncoding) {
          if (!this._formatted) {
            this._formatted = _asFormatted(this, false);
          }
          return this._formatted;
        } else {
          return _asFormatted(this, true);
        }
      };
      _URI2.prototype.toJSON = function() {
        var res = {
          $mid: 1
        };
        if (this._fsPath) {
          res.fsPath = this._fsPath;
          res._sep = _pathSepMarker;
        }
        if (this._formatted) {
          res.external = this._formatted;
        }
        if (this.path) {
          res.path = this.path;
        }
        if (this.scheme) {
          res.scheme = this.scheme;
        }
        if (this.authority) {
          res.authority = this.authority;
        }
        if (this.query) {
          res.query = this.query;
        }
        if (this.fragment) {
          res.fragment = this.fragment;
        }
        return res;
      };
      return _URI2;
    }(URI);
    encodeTable = (_a = {}, _a[58] = "%3A", _a[47] = "%2F", _a[63] = "%3F", _a[35] = "%23", _a[91] = "%5B", _a[93] = "%5D", _a[64] = "%40", _a[33] = "%21", _a[36] = "%24", _a[38] = "%26", _a[39] = "%27", _a[40] = "%28", _a[41] = "%29", _a[42] = "%2A", _a[43] = "%2B", _a[44] = "%2C", _a[59] = "%3B", _a[61] = "%3D", _a[32] = "%20", _a);
    _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  }
});

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs26 = require("fs");
    function checkPathExt(path34, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path34.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path34, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path34, options);
    }
    function isexe(path34, options, cb) {
      fs26.stat(path34, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path34, options));
      });
    }
    function sync(path34, options) {
      return checkStat(fs26.statSync(path34), path34, options);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs26 = require("fs");
    function isexe(path34, options, cb) {
      fs26.stat(path34, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path34, options) {
      return checkStat(fs26.statSync(path34), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports2, module2) {
    var fs26 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path34, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve3, reject) {
          isexe(path34, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve3(is);
            }
          });
        });
      }
      core(path34, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path34, options) {
      try {
        return core.sync(path34, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/which/which.js"(exports2, module2) {
    var isWindows4 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path34 = require("path");
    var COLON = isWindows4 ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows4 && cmd.match(/\\/) ? [""] : [
        ...isWindows4 ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || "").split(colon)
      ];
      const pathExtExe = isWindows4 ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows4 ? pathExtExe.split(colon) : [""];
      if (isWindows4) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which6 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve3, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve3(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path34.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve3(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve3, reject) => {
        if (ii === pathExt.length)
          return resolve3(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve3(p + ext);
          }
          return resolve3(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path34.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which6;
    which6.sync = whichSync;
  }
});

// src/util/platform.ts
var platform_exports = {};
__export(platform_exports, {
  OS: () => OS,
  OperatingSystem: () => OperatingSystem,
  Platform: () => Platform,
  globals: () => globals,
  isLinux: () => isLinux,
  isMacintosh: () => isMacintosh,
  isNative: () => isNative,
  isWeb: () => isWeb,
  isWindows: () => isWindows2,
  language: () => language,
  platform: () => platform
});
var _isWindows, _isMacintosh, _isLinux, _isNative, _isWeb, language, Platform, _platform, isWindows2, isMacintosh, isLinux, isNative, isWeb, platform, _globals, globals, OperatingSystem, OS;
var init_platform = __esm({
  "src/util/platform.ts"() {
    _isWindows = false;
    _isMacintosh = false;
    _isLinux = false;
    _isNative = false;
    _isWeb = false;
    language = "en";
    if (typeof process === "object" && typeof process.nextTick === "function" && typeof process.platform === "string") {
      _isWindows = process.platform === "win32";
      _isMacintosh = process.platform === "darwin";
      _isLinux = process.platform === "linux";
      _isNative = true;
    }
    (function(Platform2) {
      Platform2[Platform2["Web"] = 0] = "Web";
      Platform2[Platform2["Mac"] = 1] = "Mac";
      Platform2[Platform2["Linux"] = 2] = "Linux";
      Platform2[Platform2["Windows"] = 3] = "Windows";
    })(Platform || (Platform = {}));
    _platform = 0;
    if (_isNative) {
      if (_isMacintosh) {
        _platform = 1;
      } else if (_isWindows) {
        _platform = 3;
      } else if (_isLinux) {
        _platform = 2;
      }
    }
    isWindows2 = _isWindows;
    isMacintosh = _isMacintosh;
    isLinux = _isLinux;
    isNative = _isNative;
    isWeb = _isWeb;
    platform = _platform;
    _globals = typeof self === "object" ? self : typeof global === "object" ? global : {};
    globals = _globals;
    (function(OperatingSystem2) {
      OperatingSystem2[OperatingSystem2["Windows"] = 1] = "Windows";
      OperatingSystem2[OperatingSystem2["Macintosh"] = 2] = "Macintosh";
      OperatingSystem2[OperatingSystem2["Linux"] = 3] = "Linux";
    })(OperatingSystem || (OperatingSystem = {}));
    OS = _isMacintosh ? 2 : _isWindows ? 1 : 3;
  }
});

// src/util/index.ts
function wait(ms) {
  return new Promise((resolve3) => {
    setTimeout(() => {
      resolve3(void 0);
    }, ms);
  });
}
function getUri(fullpath, id, buftype, isCygwin) {
  if (!fullpath)
    return `untitled:${id}`;
  if (isWindows2 && !isCygwin && !fullpath.startsWith("jdt://"))
    fullpath = import_path.default.win32.normalize(fullpath);
  if (import_path.default.isAbsolute(fullpath))
    return URI.file(fullpath).toString();
  if (import_isuri.default.isValid(fullpath))
    return URI.parse(fullpath).toString();
  if (buftype != "")
    return `${buftype}:${id}`;
  return `unknown:${id}`;
}
function disposeAll(disposables) {
  while (disposables.length) {
    const item = disposables.pop();
    if (item) {
      item.dispose();
    }
  }
}
function executable(command) {
  try {
    import_which.default.sync(command);
  } catch (e) {
    return false;
  }
  return true;
}
function runCommand(cmd, opts = {}, timeout) {
  if (!isWindows2) {
    opts.shell = opts.shell || process.env.SHELL;
  }
  opts.maxBuffer = 500 * 1024;
  return new Promise((resolve3, reject) => {
    let timer;
    if (timeout) {
      timer = setTimeout(() => {
        reject(new Error(`timeout after ${timeout}s`));
      }, timeout * 1e3);
    }
    (0, import_child_process.exec)(cmd, opts, (err, stdout, stderr) => {
      if (timer)
        clearTimeout(timer);
      if (err) {
        reject(new Error(`exited with ${err.code}
${err}
${stderr}`));
        return;
      }
      resolve3(stdout);
    });
  });
}
function watchFile(filepath, onChange) {
  let callback = (0, import_debounce.default)(onChange, 100);
  try {
    let watcher = import_fs.default.watch(filepath, {
      persistent: true,
      recursive: false,
      encoding: "utf8"
    }, () => {
      callback();
    });
    return import_vscode_languageserver_protocol.Disposable.create(() => {
      callback.clear();
      watcher.close();
    });
  } catch (e) {
    return import_vscode_languageserver_protocol.Disposable.create(() => {
      callback.clear();
    });
  }
}
function isRunning(pid) {
  try {
    let res = process.kill(pid, 0);
    return res == true;
  } catch (e) {
    return e.code === "EPERM";
  }
}
function getKeymapModifier(mode) {
  if (mode == "n" || mode == "o" || mode == "x" || mode == "v")
    return "<C-U>";
  if (mode == "i")
    return "<C-o>";
  if (mode == "s")
    return "<Esc>";
  return "";
}
function concurrent(arr, fn, limit = 3) {
  if (arr.length == 0)
    return Promise.resolve();
  let finished = 0;
  let total = arr.length;
  let remain = arr.slice();
  return new Promise((resolve3) => {
    let run = (val) => {
      let cb = () => {
        finished = finished + 1;
        if (finished == total) {
          resolve3();
        } else if (remain.length) {
          let next = remain.shift();
          run(next);
        }
      };
      fn(val).then(cb, cb);
    };
    for (let i = 0; i < Math.min(limit, remain.length); i++) {
      let val = remain.shift();
      run(val);
    }
  });
}
var import_child_process, import_debounce, import_fs, import_isuri, import_path, import_vscode_languageserver_protocol, import_which, logger, CONFIG_FILE_NAME;
var init_util = __esm({
  "src/util/index.ts"() {
    import_child_process = __toModule(require("child_process"));
    import_debounce = __toModule(require_debounce());
    import_fs = __toModule(require("fs"));
    import_isuri = __toModule(require_isuri());
    import_path = __toModule(require("path"));
    import_vscode_languageserver_protocol = __toModule(require_main2());
    init_esm2();
    import_which = __toModule(require_which());
    init_platform();
    logger = require_logger2()("util-index");
    CONFIG_FILE_NAME = "coc-settings.json";
  }
});

// src/util/is.ts
function boolean(value) {
  return typeof value === "boolean";
}
function string(value) {
  return typeof value === "string";
}
function number(value) {
  return typeof value === "number";
}
function func(value) {
  return typeof value == "function";
}
function objectLiteral(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
}
function emptyObject(obj) {
  if (!objectLiteral(obj)) {
    return false;
  }
  for (let key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
var hasOwnProperty;
var init_is = __esm({
  "src/util/is.ts"() {
    hasOwnProperty = Object.prototype.hasOwnProperty;
  }
});

// src/util/object.ts
function deepClone(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof RegExp) {
    return obj;
  }
  const result = Array.isArray(obj) ? [] : {};
  Object.keys(obj).forEach((key) => {
    if (obj[key] && typeof obj[key] === "object") {
      result[key] = deepClone(obj[key]);
    } else {
      result[key] = obj[key];
    }
  });
  return result;
}
function deepFreeze(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  const stack = [obj];
  while (stack.length > 0) {
    let obj2 = stack.shift();
    Object.freeze(obj2);
    for (const key in obj2) {
      if (_hasOwnProperty.call(obj2, key)) {
        let prop = obj2[key];
        if (typeof prop === "object" && !Object.isFrozen(prop)) {
          stack.push(prop);
        }
      }
    }
  }
  return obj;
}
function mixin(destination, source, overwrite = true) {
  if (!objectLiteral(destination)) {
    return source;
  }
  if (objectLiteral(source)) {
    Object.keys(source).forEach((key) => {
      if (key in destination) {
        if (overwrite) {
          if (objectLiteral(destination[key]) && objectLiteral(source[key])) {
            mixin(destination[key], source[key], overwrite);
          } else {
            destination[key] = source[key];
          }
        }
      } else {
        destination[key] = source[key];
      }
    });
  }
  return destination;
}
function equals(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  let i;
  let key;
  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }
    for (i = 0; i < one.length; i++) {
      if (!equals(one[i], other[i])) {
        return false;
      }
    }
  } else {
    const oneKeys = [];
    for (key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    const otherKeys = [];
    for (key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals(oneKeys, otherKeys)) {
      return false;
    }
    for (i = 0; i < oneKeys.length; i++) {
      if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }
  return true;
}
var _hasOwnProperty;
var init_object = __esm({
  "src/util/object.ts"() {
    init_is();
    _hasOwnProperty = Object.prototype.hasOwnProperty;
  }
});

// src/events.ts
var import_vscode_languageserver_protocol2, logger2, Events, events_default;
var init_events = __esm({
  "src/events.ts"() {
    import_vscode_languageserver_protocol2 = __toModule(require_main2());
    init_util();
    init_object();
    logger2 = require_logger2()("events");
    Events = class {
      constructor() {
        this.handlers = new Map();
        this.insertMode = false;
      }
      get cursor() {
        return this._cursor;
      }
      async fire(event, args) {
        let cbs = this.handlers.get(event);
        if (event == "InsertEnter") {
          this.insertMode = true;
        } else if (event == "InsertLeave") {
          this.insertMode = false;
        } else if (!this.insertMode && (event == "CursorHoldI" || event == "CursorMovedI")) {
          this.insertMode = true;
          await this.fire("InsertEnter", [args[0]]);
        } else if (this.insertMode && (event == "CursorHold" || event == "CursorMoved")) {
          this.insertMode = false;
          await this.fire("InsertLeave", [args[0]]);
        }
        if (event == "CursorMoved" || event == "CursorMovedI") {
          let cursor = {
            bufnr: args[0],
            lnum: args[1][0],
            col: args[1][1],
            insert: event == "CursorMovedI"
          };
          if (this._cursor && equals(this._cursor, cursor))
            return;
          this._cursor = cursor;
        }
        if (cbs) {
          try {
            await Promise.all(cbs.map((fn) => fn(args)));
          } catch (e) {
            if (e.message && e.message.indexOf("transport disconnected") == -1) {
              console.error(`Error on ${event}: ${e.message}${e.stack ? "\n" + e.stack : ""} `);
            }
            logger2.error(`Handler Error on ${event}`, e.stack);
          }
        }
      }
      on(event, handler, thisArg, disposables) {
        if (Array.isArray(event)) {
          let arr = disposables || [];
          for (let ev of event) {
            this.on(ev, handler, thisArg, arr);
          }
          return import_vscode_languageserver_protocol2.Disposable.create(() => {
            disposeAll(arr);
          });
        } else {
          let arr = this.handlers.get(event) || [];
          let stack = Error().stack;
          let wrappedhandler = (args) => new Promise((resolve3, reject) => {
            let timer;
            try {
              Promise.resolve(handler.apply(thisArg || null, args)).then(() => {
                if (timer)
                  clearTimeout(timer);
                resolve3(void 0);
              }, (e) => {
                if (timer)
                  clearTimeout(timer);
                reject(e);
              });
              timer = setTimeout(() => {
                logger2.warn(`Handler of ${event} blocked more than 2s:`, stack);
              }, 2e3);
            } catch (e) {
              reject(e);
            }
          });
          arr.push(wrappedhandler);
          this.handlers.set(event, arr);
          let disposable = import_vscode_languageserver_protocol2.Disposable.create(() => {
            let idx = arr.indexOf(wrappedhandler);
            if (idx !== -1) {
              arr.splice(idx, 1);
            }
          });
          if (disposables) {
            disposables.push(disposable);
          }
          return disposable;
        }
      }
    };
    events_default = new Events();
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var createToken = (name2, value, isGlobal) => {
      const index = R++;
      debug(index, value);
      t[name2] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { re, t } = require_re();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version2, options) {
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (version2 instanceof SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    var { MAX_LENGTH } = require_constants();
    var { re, t } = require_re();
    var SemVer = require_semver();
    var parse5 = (version2, options) => {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      if (version2.length > MAX_LENGTH) {
        return null;
      }
      const r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version2)) {
        return null;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        return null;
      }
    };
    module2.exports = parse5;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse5 = require_parse();
    var valid = (version2, options) => {
      const v = parse5(version2, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse5 = require_parse();
    var clean = (version2, options) => {
      const s = parse5(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier) => {
      if (typeof options === "string") {
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(version2, options).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse5 = require_parse();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v12 = parse5(version1);
        const v2 = parse5(version2);
        const hasPre = v12.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v12) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v12[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse5 = require_parse();
    var prerelease = (version2, options) => {
      const parsed = parse5(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list2, loose) => list2.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list2, loose) => list2.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse5 = require_parse();
    var { re, t } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null)
        return null;
      return parse5(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    var Range30 = class {
      constructor(range, options) {
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (range instanceof Range30) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range30(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range;
        this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const loose = this.options.loose;
        range = range.trim();
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range, re[t.COMPARATORTRIM]);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        return range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
      }
      intersects(range, options) {
        if (!(range instanceof Range30)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range30;
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceTilde(comp2, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceCaret(comp2, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((comp2) => {
        return replaceXRange(comp2, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<")
            pr = "-0";
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range30(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range30(this.value, options).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module2.exports = Comparator;
    var { re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range30 = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range30 = require_range();
    var satisfies = (version2, range, options) => {
      try {
        range = new Range30(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range30 = require_range();
    var toComparators = (range, options) => new Range30(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range30 = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range30(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range30 = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range30(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range30 = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range30(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range30 = require_range();
    var validRange = (range, options) => {
      try {
        return new Range30(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range30 = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range30(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range30 = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range30(r1, options);
      r2 = new Range30(r2, options);
      return r1.intersects(r2);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let min = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range, options);
        if (included) {
          prev = version2;
          if (!min)
            min = version2;
        } else {
          if (prev) {
            set.push([min, prev]);
          }
          prev = null;
          min = null;
        }
      }
      if (min)
        set.push([min, null]);
      const ranges = [];
      for (const [min2, max] of set) {
        if (min2 === max)
          ranges.push(min2);
        else if (!max && min2 === v[0])
          ranges.push("*");
        else if (!max)
          ranges.push(`>=${min2}`);
        else if (min2 === v[0])
          ranges.push(`<=${max}`);
        else
          ranges.push(`${min2} - ${max}`);
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range30 = require_range();
    var { ANY } = require_comparator();
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options) => {
      sub = new Range30(sub, options);
      dom = new Range30(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub)
              continue OUTER;
          }
          if (sawNonNull)
            return false;
        }
      return true;
    };
    var simpleSubset = (sub, dom, options) => {
      if (sub.length === 1 && sub[0].semver === ANY)
        return dom.length === 1 && dom[0].semver === ANY;
      const eqSet = new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=")
          gt = higherGT(gt, c, options);
        else if (c.operator === "<" || c.operator === "<=")
          lt = lowerLT(lt, c, options);
        else
          eqSet.add(c.semver);
      }
      if (eqSet.size > 1)
        return null;
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0)
          return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
          return null;
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options))
          return null;
        if (lt && !satisfies(eq, String(lt), options))
          return null;
        for (const c of dom) {
          if (!satisfies(eq, String(c), options))
            return false;
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c)
              return false;
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options))
            return false;
        }
        if (lt) {
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c)
              return false;
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options))
            return false;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0)
          return false;
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0)
        return false;
      if (lt && hasDomGT && !gt && gtltComp !== 0)
        return false;
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    module2.exports = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
      SemVer: require_semver(),
      compareIdentifiers: require_identifiers().compareIdentifiers,
      rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
      parse: require_parse(),
      valid: require_valid(),
      clean: require_clean(),
      inc: require_inc(),
      diff: require_diff(),
      major: require_major(),
      minor: require_minor(),
      patch: require_patch(),
      prerelease: require_prerelease(),
      compare: require_compare(),
      rcompare: require_rcompare(),
      compareLoose: require_compare_loose(),
      compareBuild: require_compare_build(),
      sort: require_sort(),
      rsort: require_rsort(),
      gt: require_gt(),
      lt: require_lt(),
      eq: require_eq(),
      neq: require_neq(),
      gte: require_gte(),
      lte: require_lte(),
      cmp: require_cmp(),
      coerce: require_coerce(),
      Comparator: require_comparator(),
      Range: require_range(),
      satisfies: require_satisfies(),
      toComparators: require_to_comparators(),
      maxSatisfying: require_max_satisfying(),
      minSatisfying: require_min_satisfying(),
      minVersion: require_min_version(),
      validRange: require_valid2(),
      outside: require_outside(),
      gtr: require_gtr(),
      ltr: require_ltr(),
      intersects: require_intersects(),
      simplifyRange: require_simplify(),
      subset: require_subset()
    };
  }
});

// node_modules/marked/src/defaults.js
var require_defaults = __commonJS({
  "node_modules/marked/src/defaults.js"(exports2, module2) {
    function getDefaults() {
      return {
        baseUrl: null,
        breaks: false,
        gfm: true,
        headerIds: true,
        headerPrefix: "",
        highlight: null,
        langPrefix: "language-",
        mangle: true,
        pedantic: false,
        renderer: null,
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartLists: false,
        smartypants: false,
        tokenizer: null,
        walkTokens: null,
        xhtml: false
      };
    }
    function changeDefaults(newDefaults) {
      module2.exports.defaults = newDefaults;
    }
    module2.exports = {
      defaults: getDefaults(),
      getDefaults,
      changeDefaults
    };
  }
});

// node_modules/marked/src/helpers.js
var require_helpers = __commonJS({
  "node_modules/marked/src/helpers.js"(exports2, module2) {
    var escapeTest = /[&<>"']/;
    var escapeReplace = /[&<>"']/g;
    var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
    var escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var getEscapeReplacement = (ch) => escapeReplacements[ch];
    function escape(html, encode) {
      if (encode) {
        if (escapeTest.test(html)) {
          return html.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html)) {
          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html;
    }
    var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape2(html) {
      return html.replace(unescapeTest, (_, n) => {
        n = n.toLowerCase();
        if (n === "colon")
          return ":";
        if (n.charAt(0) === "#") {
          return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
        }
        return "";
      });
    }
    var caret = /(^|[^\[])\^/g;
    function edit2(regex, opt) {
      regex = regex.source || regex;
      opt = opt || "";
      const obj = {
        replace: (name2, val) => {
          val = val.source || val;
          val = val.replace(caret, "$1");
          regex = regex.replace(name2, val);
          return obj;
        },
        getRegex: () => {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }
    var nonWordAndColonTest = /[^\w:]/g;
    var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    function cleanUrl(sanitize, base, href) {
      if (sanitize) {
        let prot;
        try {
          prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase();
        } catch (e) {
          return null;
        }
        if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, "%");
      } catch (e) {
        return null;
      }
      return href;
    }
    var baseUrls = {};
    var justDomain = /^[^:]+:\/*[^/]*$/;
    var protocol = /^([^:]+:)[\s\S]*$/;
    var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    function resolveUrl(base, href) {
      if (!baseUrls[" " + base]) {
        if (justDomain.test(base)) {
          baseUrls[" " + base] = base + "/";
        } else {
          baseUrls[" " + base] = rtrim(base, "/", true);
        }
      }
      base = baseUrls[" " + base];
      const relativeBase = base.indexOf(":") === -1;
      if (href.substring(0, 2) === "//") {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, "$1") + href;
      } else if (href.charAt(0) === "/") {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, "$1") + href;
      } else {
        return base + href;
      }
    }
    var noopTest = { exec: function noopTest2() {
    } };
    function merge(obj) {
      let i = 1, target, key;
      for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }
      return obj;
    }
    function splitCells(tableRow, count) {
      const row = tableRow.replace(/\|/g, (match, offset, str) => {
        let escaped = false, curr = offset;
        while (--curr >= 0 && str[curr] === "\\")
          escaped = !escaped;
        if (escaped) {
          return "|";
        } else {
          return " |";
        }
      }), cells = row.split(/ \|/);
      let i = 0;
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count)
          cells.push("");
      }
      for (; i < cells.length; i++) {
        cells[i] = cells[i].trim().replace(/\\\|/g, "|");
      }
      return cells;
    }
    function rtrim(str, c, invert) {
      const l = str.length;
      if (l === 0) {
        return "";
      }
      let suffLen = 0;
      while (suffLen < l) {
        const currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }
      return str.substr(0, l - suffLen);
    }
    function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      const l = str.length;
      let level = 0, i = 0;
      for (; i < l; i++) {
        if (str[i] === "\\") {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }
    function checkSanitizeDeprecation(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
      }
    }
    function repeatString(pattern, count) {
      if (count < 1) {
        return "";
      }
      let result = "";
      while (count > 1) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result + pattern;
    }
    module2.exports = {
      escape,
      unescape: unescape2,
      edit: edit2,
      cleanUrl,
      resolveUrl,
      noopTest,
      merge,
      splitCells,
      rtrim,
      findClosingBracket,
      checkSanitizeDeprecation,
      repeatString
    };
  }
});

// node_modules/marked/src/Tokenizer.js
var require_Tokenizer = __commonJS({
  "node_modules/marked/src/Tokenizer.js"(exports2, module2) {
    var { defaults: defaults2 } = require_defaults();
    var {
      rtrim,
      splitCells,
      escape,
      findClosingBracket
    } = require_helpers();
    function outputLink(cap, link, raw) {
      const href = link.href;
      const title = link.title ? escape(link.title) : null;
      const text = cap[1].replace(/\\([\[\]])/g, "$1");
      if (cap[0].charAt(0) !== "!") {
        return {
          type: "link",
          raw,
          href,
          title,
          text
        };
      } else {
        return {
          type: "image",
          raw,
          href,
          title,
          text: escape(text)
        };
      }
    }
    function indentCodeCompensation(raw, text) {
      const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
        return text;
      }
      const indentToCode = matchIndentToCode[1];
      return text.split("\n").map((node) => {
        const matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
          return node;
        }
        const [indentInNode] = matchIndentInNode;
        if (indentInNode.length >= indentToCode.length) {
          return node.slice(indentToCode.length);
        }
        return node;
      }).join("\n");
    }
    module2.exports = class Tokenizer {
      constructor(options) {
        this.options = options || defaults2;
      }
      space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap) {
          if (cap[0].length > 1) {
            return {
              type: "space",
              raw: cap[0]
            };
          }
          return { raw: "\n" };
        }
      }
      code(src, tokens) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
          const lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "paragraph") {
            return {
              raw: cap[0],
              text: cap[0].trimRight()
            };
          }
          const text = cap[0].replace(/^ {4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text, "\n") : text
          };
        }
      }
      fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
          const raw = cap[0];
          const text = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim() : cap[2],
            text
          };
        }
      }
      heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text: cap[2]
          };
        }
      }
      nptable(src) {
        const cap = this.rules.block.nptable.exec(src);
        if (cap) {
          const item = {
            type: "table",
            header: splitCells(cap[1].replace(/^ *| *\| *$/g, "")),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, "").split("\n") : [],
            raw: cap[0]
          };
          if (item.header.length === item.align.length) {
            let l = item.align.length;
            let i;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
            l = item.cells.length;
            for (i = 0; i < l; i++) {
              item.cells[i] = splitCells(item.cells[i], item.header.length);
            }
            return item;
          }
        }
      }
      hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      }
      blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ *> ?/gm, "");
          return {
            type: "blockquote",
            raw: cap[0],
            text
          };
        }
      }
      list(src) {
        const cap = this.rules.block.list.exec(src);
        if (cap) {
          let raw = cap[0];
          const bull = cap[2];
          const isordered = bull.length > 1;
          const list2 = {
            type: "list",
            raw,
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          const itemMatch = cap[0].match(this.rules.block.item);
          let next = false, item, space, bcurr, bnext, addBack, loose, istask, ischecked;
          let l = itemMatch.length;
          bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);
          for (let i = 0; i < l; i++) {
            item = itemMatch[i];
            raw = item;
            if (i !== l - 1) {
              bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);
              if (bnext[1].length > bcurr[0].length || bnext[1].length > 3) {
                itemMatch.splice(i, 2, itemMatch[i] + "\n" + itemMatch[i + 1]);
                i--;
                l--;
                continue;
              } else {
                if (!this.options.pedantic || this.options.smartLists ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1] : isordered === (bnext[2].length === 1)) {
                  addBack = itemMatch.slice(i + 1).join("\n");
                  list2.raw = list2.raw.substring(0, list2.raw.length - addBack.length);
                  i = l - 1;
                }
              }
              bcurr = bnext;
            }
            space = item.length;
            item = item.replace(/^ *([*+-]|\d+[.)]) ?/, "");
            if (~item.indexOf("\n ")) {
              space -= item.length;
              item = !this.options.pedantic ? item.replace(new RegExp("^ {1," + space + "}", "gm"), "") : item.replace(/^ {1,4}/gm, "");
            }
            loose = next || /\n\n(?!\s*$)/.test(item);
            if (i !== l - 1) {
              next = item.charAt(item.length - 1) === "\n";
              if (!loose)
                loose = next;
            }
            if (loose) {
              list2.loose = true;
            }
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.test(item);
              ischecked = void 0;
              if (istask) {
                ischecked = item[1] !== " ";
                item = item.replace(/^\[[ xX]\] +/, "");
              }
            }
            list2.items.push({
              type: "list_item",
              raw,
              task: istask,
              checked: ischecked,
              loose,
              text: item
            });
          }
          return list2;
        }
      }
      html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
          return {
            type: this.options.sanitize ? "paragraph" : "html",
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
          };
        }
      }
      def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
          if (cap[3])
            cap[3] = cap[3].substring(1, cap[3].length - 1);
          const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          return {
            tag,
            raw: cap[0],
            href: cap[2],
            title: cap[3]
          };
        }
      }
      table(src) {
        const cap = this.rules.block.table.exec(src);
        if (cap) {
          const item = {
            type: "table",
            header: splitCells(cap[1].replace(/^ *| *\| *$/g, "")),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            item.raw = cap[0];
            let l = item.align.length;
            let i;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
            l = item.cells.length;
            for (i = 0; i < l; i++) {
              item.cells[i] = splitCells(item.cells[i].replace(/^ *\| *| *\| *$/g, ""), item.header.length);
            }
            return item;
          }
        }
      }
      lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1]
          };
        }
      }
      paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          return {
            type: "paragraph",
            raw: cap[0],
            text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1]
          };
        }
      }
      text(src, tokens) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
          const lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            return {
              raw: cap[0],
              text: cap[0]
            };
          }
          return {
            type: "text",
            raw: cap[0],
            text: cap[0]
          };
        }
      }
      escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: escape(cap[1])
          };
        }
      }
      tag(src, inLink, inRawBlock) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!inLink && /^<a /i.test(cap[0])) {
            inLink = true;
          } else if (inLink && /^<\/a>/i.test(cap[0])) {
            inLink = false;
          }
          if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            inRawBlock = true;
          } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink,
            inRawBlock,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
          };
        }
      }
      link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
          const lastParenIndex = findClosingBracket(cap[2], "()");
          if (lastParenIndex > -1) {
            const start = cap[0].indexOf("!") === 0 ? 5 : 4;
            const linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = "";
          }
          let href = cap[2];
          let title = "";
          if (this.options.pedantic) {
            const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link) {
              href = link[1];
              title = link[3];
            } else {
              title = "";
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim().replace(/^<([\s\S]*)>$/, "$1");
          const token = outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0]);
          return token;
        }
      }
      reflink(src, links2) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link = links2[link.toLowerCase()];
          if (!link || !link.href) {
            const text = cap[0].charAt(0);
            return {
              type: "text",
              raw: text,
              text
            };
          }
          const token = outputLink(cap, link, cap[0]);
          return token;
        }
      }
      strong(src, maskedSrc, prevChar = "") {
        let match = this.rules.inline.strong.start.exec(src);
        if (match && (!match[1] || match[1] && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar)))) {
          maskedSrc = maskedSrc.slice(-1 * src.length);
          const endReg = match[0] === "**" ? this.rules.inline.strong.endAst : this.rules.inline.strong.endUnd;
          endReg.lastIndex = 0;
          let cap;
          while ((match = endReg.exec(maskedSrc)) != null) {
            cap = this.rules.inline.strong.middle.exec(maskedSrc.slice(0, match.index + 3));
            if (cap) {
              return {
                type: "strong",
                raw: src.slice(0, cap[0].length),
                text: src.slice(2, cap[0].length - 2)
              };
            }
          }
        }
      }
      em(src, maskedSrc, prevChar = "") {
        let match = this.rules.inline.em.start.exec(src);
        if (match && (!match[1] || match[1] && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar)))) {
          maskedSrc = maskedSrc.slice(-1 * src.length);
          const endReg = match[0] === "*" ? this.rules.inline.em.endAst : this.rules.inline.em.endUnd;
          endReg.lastIndex = 0;
          let cap;
          while ((match = endReg.exec(maskedSrc)) != null) {
            cap = this.rules.inline.em.middle.exec(maskedSrc.slice(0, match.index + 2));
            if (cap) {
              return {
                type: "em",
                raw: src.slice(0, cap[0].length),
                text: src.slice(1, cap[0].length - 1)
              };
            }
          }
        }
      }
      codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
          let text = cap[2].replace(/\n/g, " ");
          const hasNonSpaceChars = /[^ ]/.test(text);
          const hasSpaceCharsOnBothEnds = text.startsWith(" ") && text.endsWith(" ");
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = escape(text, true);
          return {
            type: "codespan",
            raw: cap[0],
            text
          };
        }
      }
      br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      }
      del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2]
          };
        }
      }
      autolink(src, mangle) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          let text, href;
          if (cap[2] === "@") {
            text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
            href = "mailto:" + text;
          } else {
            text = escape(cap[1]);
            href = text;
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      url(src, mangle) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
          let text, href;
          if (cap[2] === "@") {
            text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
            href = "mailto:" + text;
          } else {
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + text;
            } else {
              href = text;
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      inlineText(src, inRawBlock, smartypants) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
          let text;
          if (inRawBlock) {
            text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
          } else {
            text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text
          };
        }
      }
    };
  }
});

// node_modules/marked/src/rules.js
var require_rules = __commonJS({
  "node_modules/marked/src/rules.js"(exports2, module2) {
    var {
      noopTest,
      edit: edit2,
      merge
    } = require_helpers();
    var block = {
      newline: /^\n+/,
      code: /^( {4}[^\n]+\n*)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?! {0,3}bull )\n*|\s*$)/,
      html: "^ {0,3}(?:<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$))",
      def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
      nptable: noopTest,
      table: noopTest,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit2(block.def).replace("label", block._label).replace("title", block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
    block.item = edit2(block.item, "gm").replace(/bull/g, block.bullet).getRegex();
    block.listItemStart = edit2(/^( *)(bull)/).replace("bull", block.bullet).getRegex();
    block.list = edit2(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
    block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit2(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.paragraph = edit2(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", block._tag).getRegex();
    block.blockquote = edit2(block.blockquote).replace("paragraph", block.paragraph).getRegex();
    block.normal = merge({}, block);
    block.gfm = merge({}, block.normal, {
      nptable: "^ *([^|\\n ].*\\|.*)\\n {0,3}([-:]+ *\\|[-| :]*)(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
      table: "^ *\\|(.+)\\n {0,3}\\|?( *[-:]+[-| :]*)(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
    });
    block.gfm.nptable = edit2(block.gfm.nptable).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", block._tag).getRegex();
    block.gfm.table = edit2(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", block._tag).getRegex();
    block.pedantic = merge({}, block.normal, {
      html: edit2(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
      fences: noopTest,
      paragraph: edit2(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    var inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
      nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      strong: {
        start: /^(?:(\*\*(?=[*punctuation]))|\*\*)(?![\s])|__/,
        middle: /^\*\*(?:(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)|\*(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)*?\*)+?\*\*$|^__(?![\s])((?:(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)*?_)+?)__$/,
        endAst: /[^punctuation\s]\*\*(?!\*)|[punctuation]\*\*(?!\*)(?:(?=[punctuation_\s]|$))/,
        endUnd: /[^\s]__(?!_)(?:(?=[punctuation*\s])|$)/
      },
      em: {
        start: /^(?:(\*(?=[punctuation]))|\*)(?![*\s])|_/,
        middle: /^\*(?:(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)|\*(?:(?!overlapSkip)(?:[^*]|\\\*)|overlapSkip)*?\*)+?\*$|^_(?![_\s])(?:(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\_)|overlapSkip)*?_)+?_$/,
        endAst: /[^punctuation\s]\*(?!\*)|[punctuation]\*(?!\*)(?:(?=[punctuation_\s]|$))/,
        endUnd: /[^\s]_(?!_)(?:(?=[punctuation*\s])|$)/
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\s*punctuation])/
    };
    inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
    inline.punctuation = edit2(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
    inline._blockSkip = "\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>";
    inline._overlapSkip = "__[^_]*?__|\\*\\*\\[^\\*\\]*?\\*\\*";
    inline._comment = edit2(block._comment).replace("(?:-->|$)", "-->").getRegex();
    inline.em.start = edit2(inline.em.start).replace(/punctuation/g, inline._punctuation).getRegex();
    inline.em.middle = edit2(inline.em.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();
    inline.em.endAst = edit2(inline.em.endAst, "g").replace(/punctuation/g, inline._punctuation).getRegex();
    inline.em.endUnd = edit2(inline.em.endUnd, "g").replace(/punctuation/g, inline._punctuation).getRegex();
    inline.strong.start = edit2(inline.strong.start).replace(/punctuation/g, inline._punctuation).getRegex();
    inline.strong.middle = edit2(inline.strong.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();
    inline.strong.endAst = edit2(inline.strong.endAst, "g").replace(/punctuation/g, inline._punctuation).getRegex();
    inline.strong.endUnd = edit2(inline.strong.endUnd, "g").replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = edit2(inline._blockSkip, "g").getRegex();
    inline.overlapSkip = edit2(inline._overlapSkip, "g").getRegex();
    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit2(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit2(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit2(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
    inline.reflink = edit2(inline.reflink).replace("label", inline._label).getRegex();
    inline.reflinkSearch = edit2(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
    inline.normal = merge({}, inline);
    inline.pedantic = merge({}, inline.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit2(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
      reflink: edit2(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
    });
    inline.gfm = merge({}, inline.normal, {
      escape: edit2(inline.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
    });
    inline.gfm.url = edit2(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
    inline.breaks = merge({}, inline.gfm, {
      br: edit2(inline.br).replace("{2,}", "*").getRegex(),
      text: edit2(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    module2.exports = {
      block,
      inline
    };
  }
});

// node_modules/marked/src/Lexer.js
var require_Lexer = __commonJS({
  "node_modules/marked/src/Lexer.js"(exports2, module2) {
    var Tokenizer = require_Tokenizer();
    var { defaults: defaults2 } = require_defaults();
    var { block, inline } = require_rules();
    var { repeatString } = require_helpers();
    function smartypants(text) {
      return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
    }
    function mangle(text) {
      let out = "", i, ch;
      const l = text.length;
      for (i = 0; i < l; i++) {
        ch = text.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = "x" + ch.toString(16);
        }
        out += "&#" + ch + ";";
      }
      return out;
    }
    module2.exports = class Lexer {
      constructor(options) {
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options || defaults2;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        const rules = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }
      static get rules() {
        return {
          block,
          inline
        };
      }
      static lex(src, options) {
        const lexer = new Lexer(options);
        return lexer.lex(src);
      }
      static lexInline(src, options) {
        const lexer = new Lexer(options);
        return lexer.inlineTokens(src);
      }
      lex(src) {
        src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
        this.blockTokens(src, this.tokens, true);
        this.inline(this.tokens);
        return this.tokens;
      }
      blockTokens(src, tokens = [], top = true) {
        src = src.replace(/^ +$/gm, "");
        let token, i, l, lastToken;
        while (src) {
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.type) {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src, tokens)) {
            src = src.substring(token.raw.length);
            if (token.type) {
              tokens.push(token);
            } else {
              lastToken = tokens[tokens.length - 1];
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.nptable(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            token.tokens = this.blockTokens(token.text, [], top);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            l = token.items.length;
            for (i = 0; i < l; i++) {
              token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);
            }
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (top && (token = this.tokenizer.def(src))) {
            src = src.substring(token.raw.length);
            if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (top && (token = this.tokenizer.paragraph(src))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.text(src, tokens)) {
            src = src.substring(token.raw.length);
            if (token.type) {
              tokens.push(token);
            } else {
              lastToken = tokens[tokens.length - 1];
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
      inline(tokens) {
        let i, j, k, l2, row, token;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          switch (token.type) {
            case "paragraph":
            case "text":
            case "heading": {
              token.tokens = [];
              this.inlineTokens(token.text, token.tokens);
              break;
            }
            case "table": {
              token.tokens = {
                header: [],
                cells: []
              };
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                token.tokens.header[j] = [];
                this.inlineTokens(token.header[j], token.tokens.header[j]);
              }
              l2 = token.cells.length;
              for (j = 0; j < l2; j++) {
                row = token.cells[j];
                token.tokens.cells[j] = [];
                for (k = 0; k < row.length; k++) {
                  token.tokens.cells[j][k] = [];
                  this.inlineTokens(row[k], token.tokens.cells[j][k]);
                }
              }
              break;
            }
            case "blockquote": {
              this.inline(token.tokens);
              break;
            }
            case "list": {
              l2 = token.items.length;
              for (j = 0; j < l2; j++) {
                this.inline(token.items[j].tokens);
              }
              break;
            }
            default: {
            }
          }
        }
        return tokens;
      }
      inlineTokens(src, tokens = [], inLink = false, inRawBlock = false) {
        let token;
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;
        if (this.tokens.links) {
          const links2 = Object.keys(this.tokens.links);
          if (links2.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links2.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {
            src = src.substring(token.raw.length);
            inLink = token.inLink;
            inRawBlock = token.inRawBlock;
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            if (token.type === "link") {
              token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
            }
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            if (token.type === "link") {
              token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
            }
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.strong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.em(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {
            src = src.substring(token.raw.length);
            prevChar = token.raw.slice(-1);
            keepPrevChar = true;
            tokens.push(token);
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
    };
  }
});

// node_modules/marked/src/Renderer.js
var require_Renderer = __commonJS({
  "node_modules/marked/src/Renderer.js"(exports2, module2) {
    var { defaults: defaults2 } = require_defaults();
    var {
      cleanUrl,
      escape
    } = require_helpers();
    module2.exports = class Renderer {
      constructor(options) {
        this.options = options || defaults2;
      }
      code(code, infostring, escaped) {
        const lang = (infostring || "").match(/\S*/)[0];
        if (this.options.highlight) {
          const out = this.options.highlight(code, lang);
          if (out != null && out !== code) {
            escaped = true;
            code = out;
          }
        }
        if (!lang) {
          return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
      }
      blockquote(quote) {
        return "<blockquote>\n" + quote + "</blockquote>\n";
      }
      html(html) {
        return html;
      }
      heading(text, level, raw, slugger) {
        if (this.options.headerIds) {
          return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + "</h" + level + ">\n";
        }
        return "<h" + level + ">" + text + "</h" + level + ">\n";
      }
      hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      }
      list(body, ordered, start) {
        const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
      }
      listitem(text) {
        return "<li>" + text + "</li>\n";
      }
      checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      }
      paragraph(text) {
        return "<p>" + text + "</p>\n";
      }
      table(header, body) {
        if (body)
          body = "<tbody>" + body + "</tbody>";
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      }
      tablerow(content) {
        return "<tr>\n" + content + "</tr>\n";
      }
      tablecell(content, flags) {
        const type = flags.header ? "th" : "td";
        const tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
        return tag + content + "</" + type + ">\n";
      }
      strong(text) {
        return "<strong>" + text + "</strong>";
      }
      em(text) {
        return "<em>" + text + "</em>";
      }
      codespan(text) {
        return "<code>" + text + "</code>";
      }
      br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      }
      del(text) {
        return "<del>" + text + "</del>";
      }
      link(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        let out = '<a href="' + escape(href) + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text + "</a>";
        return out;
      }
      image(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        let out = '<img src="' + href + '" alt="' + text + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      }
      text(text) {
        return text;
      }
    };
  }
});

// node_modules/marked/src/TextRenderer.js
var require_TextRenderer = __commonJS({
  "node_modules/marked/src/TextRenderer.js"(exports2, module2) {
    module2.exports = class TextRenderer {
      strong(text) {
        return text;
      }
      em(text) {
        return text;
      }
      codespan(text) {
        return text;
      }
      del(text) {
        return text;
      }
      html(text) {
        return text;
      }
      text(text) {
        return text;
      }
      link(href, title, text) {
        return "" + text;
      }
      image(href, title, text) {
        return "" + text;
      }
      br() {
        return "";
      }
    };
  }
});

// node_modules/marked/src/Slugger.js
var require_Slugger = __commonJS({
  "node_modules/marked/src/Slugger.js"(exports2, module2) {
    module2.exports = class Slugger {
      constructor() {
        this.seen = {};
      }
      serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      }
      getNextSafeSlug(originalSlug, isDryRun) {
        let slug = originalSlug;
        let occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      }
      slug(value, options = {}) {
        const slug = this.serialize(value);
        return this.getNextSafeSlug(slug, options.dryrun);
      }
    };
  }
});

// node_modules/marked/src/Parser.js
var require_Parser = __commonJS({
  "node_modules/marked/src/Parser.js"(exports2, module2) {
    var Renderer2 = require_Renderer();
    var TextRenderer = require_TextRenderer();
    var Slugger = require_Slugger();
    var { defaults: defaults2 } = require_defaults();
    var {
      unescape: unescape2
    } = require_helpers();
    module2.exports = class Parser {
      constructor(options) {
        this.options = options || defaults2;
        this.options.renderer = this.options.renderer || new Renderer2();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer();
        this.slugger = new Slugger();
      }
      static parse(tokens, options) {
        const parser2 = new Parser(options);
        return parser2.parse(tokens);
      }
      static parseInline(tokens, options) {
        const parser2 = new Parser(options);
        return parser2.parseInline(tokens);
      }
      parse(tokens, top = true) {
        let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape2(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }
            case "code": {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }
            case "table": {
              header = "";
              cell = "";
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j]), { header: true, align: token.align[j] });
              }
              header += this.renderer.tablerow(cell);
              body = "";
              l2 = token.cells.length;
              for (j = 0; j < l2; j++) {
                row = token.tokens.cells[j];
                cell = "";
                l3 = row.length;
                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k]), { header: false, align: token.align[k] });
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = "";
              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = "";
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "text") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }
              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case "html": {
              out += this.renderer.html(token.text);
              continue;
            }
            case "paragraph": {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case "text": {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i + 1 < l && tokens[i + 1].type === "text") {
                token = tokens[++i];
                body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = "", i, token;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          switch (token.type) {
            case "escape": {
              out += renderer.text(token.text);
              break;
            }
            case "html": {
              out += renderer.html(token.text);
              break;
            }
            case "link": {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case "image": {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case "strong": {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case "em": {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case "codespan": {
              out += renderer.codespan(token.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case "text": {
              out += renderer.text(token.text);
              break;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
    };
  }
});

// node_modules/marked/src/marked.js
var require_marked = __commonJS({
  "node_modules/marked/src/marked.js"(exports2, module2) {
    var Lexer = require_Lexer();
    var Parser = require_Parser();
    var Tokenizer = require_Tokenizer();
    var Renderer2 = require_Renderer();
    var TextRenderer = require_TextRenderer();
    var Slugger = require_Slugger();
    var {
      merge,
      checkSanitizeDeprecation,
      escape
    } = require_helpers();
    var {
      getDefaults,
      changeDefaults,
      defaults: defaults2
    } = require_defaults();
    function marked2(src, opt, callback) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      if (typeof opt === "function") {
        callback = opt;
        opt = null;
      }
      opt = merge({}, marked2.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      if (callback) {
        const highlight = opt.highlight;
        let tokens;
        try {
          tokens = Lexer.lex(src, opt);
        } catch (e) {
          return callback(e);
        }
        const done = function(err) {
          let out;
          if (!err) {
            try {
              out = Parser.parse(tokens, opt);
            } catch (e) {
              err = e;
            }
          }
          opt.highlight = highlight;
          return err ? callback(err) : callback(null, out);
        };
        if (!highlight || highlight.length < 3) {
          return done();
        }
        delete opt.highlight;
        if (!tokens.length)
          return done();
        let pending = 0;
        marked2.walkTokens(tokens, function(token) {
          if (token.type === "code") {
            pending++;
            setTimeout(() => {
              highlight(token.text, token.lang, function(err, code) {
                if (err) {
                  return done(err);
                }
                if (code != null && code !== token.text) {
                  token.text = code;
                  token.escaped = true;
                }
                pending--;
                if (pending === 0) {
                  done();
                }
              });
            }, 0);
          }
        });
        if (pending === 0) {
          done();
        }
        return;
      }
      try {
        const tokens = Lexer.lex(src, opt);
        if (opt.walkTokens) {
          marked2.walkTokens(tokens, opt.walkTokens);
        }
        return Parser.parse(tokens, opt);
      } catch (e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        }
        throw e;
      }
    }
    marked2.options = marked2.setOptions = function(opt) {
      merge(marked2.defaults, opt);
      changeDefaults(marked2.defaults);
      return marked2;
    };
    marked2.getDefaults = getDefaults;
    marked2.defaults = defaults2;
    marked2.use = function(extension) {
      const opts = merge({}, extension);
      if (extension.renderer) {
        const renderer = marked2.defaults.renderer || new Renderer2();
        for (const prop in extension.renderer) {
          const prevRenderer = renderer[prop];
          renderer[prop] = (...args) => {
            let ret = extension.renderer[prop].apply(renderer, args);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args);
            }
            return ret;
          };
        }
        opts.renderer = renderer;
      }
      if (extension.tokenizer) {
        const tokenizer = marked2.defaults.tokenizer || new Tokenizer();
        for (const prop in extension.tokenizer) {
          const prevTokenizer = tokenizer[prop];
          tokenizer[prop] = (...args) => {
            let ret = extension.tokenizer[prop].apply(tokenizer, args);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (extension.walkTokens) {
        const walkTokens = marked2.defaults.walkTokens;
        opts.walkTokens = (token) => {
          extension.walkTokens(token);
          if (walkTokens) {
            walkTokens(token);
          }
        };
      }
      marked2.setOptions(opts);
    };
    marked2.walkTokens = function(tokens, callback) {
      for (const token of tokens) {
        callback(token);
        switch (token.type) {
          case "table": {
            for (const cell of token.tokens.header) {
              marked2.walkTokens(cell, callback);
            }
            for (const row of token.tokens.cells) {
              for (const cell of row) {
                marked2.walkTokens(cell, callback);
              }
            }
            break;
          }
          case "list": {
            marked2.walkTokens(token.items, callback);
            break;
          }
          default: {
            if (token.tokens) {
              marked2.walkTokens(token.tokens, callback);
            }
          }
        }
      }
    };
    marked2.parseInline = function(src, opt) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked.parseInline(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      opt = merge({}, marked2.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      try {
        const tokens = Lexer.lexInline(src, opt);
        if (opt.walkTokens) {
          marked2.walkTokens(tokens, opt.walkTokens);
        }
        return Parser.parseInline(tokens, opt);
      } catch (e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        }
        throw e;
      }
    };
    marked2.Parser = Parser;
    marked2.parser = Parser.parse;
    marked2.Renderer = Renderer2;
    marked2.TextRenderer = TextRenderer;
    marked2.Lexer = Lexer;
    marked2.lexer = Lexer.lex;
    marked2.Tokenizer = Tokenizer;
    marked2.Slugger = Slugger;
    marked2.parse = marked2;
    module2.exports = marked2;
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/cli-table/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/cli-table/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/cli-table/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/cli-table/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (var key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (var model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string2 = integer.toString(16).toUpperCase();
      return "000000".substring(string2.length) + string2;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray2) {
      return [0, 100, gray2[0]];
    };
    convert.gray.cmyk = function(gray2) {
      return [0, 0, 0, gray2[0]];
    };
    convert.gray.lab = function(gray2) {
      return [gray2[0], 0, 0];
    };
    convert.gray.hex = function(gray2) {
      var val = Math.round(gray2[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string2 = integer.toString(16).toUpperCase();
      return "000000".substring(string2.length) + string2;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/cli-table/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/cli-table/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path34 = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path34.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path34;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/cli-table/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/cli-table/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/cli-table/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/cli-table/node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var colorConvert = require_color_convert();
    var wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes = new Map();
      const styles3 = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles3.color.grey = styles3.color.gray;
      for (const groupName of Object.keys(styles3)) {
        const group2 = styles3[groupName];
        for (const styleName of Object.keys(group2)) {
          const style2 = group2[styleName];
          styles3[styleName] = {
            open: `[${style2[0]}m`,
            close: `[${style2[1]}m`
          };
          group2[styleName] = styles3[styleName];
          codes.set(style2[0], style2[1]);
        }
        Object.defineProperty(styles3, groupName, {
          value: group2,
          enumerable: false
        });
        Object.defineProperty(styles3, "codes", {
          value: codes,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles3.color.close = "[39m";
      styles3.bgColor.close = "[49m";
      styles3.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles3.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles3.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles3.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles3.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles3.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== "object") {
          continue;
        }
        const suite = colorConvert[key];
        if (key === "ansi16") {
          key = "ansi";
        }
        if ("ansi16" in suite) {
          styles3.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles3.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles3.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles3.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles3.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles3.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles3;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/cli-table/node_modules/has-flag/index.js
var require_has_flag2 = __commonJS({
  "node_modules/cli-table/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/cli-table/node_modules/supports-color/index.js
var require_supports_color2 = __commonJS({
  "node_modules/cli-table/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os11 = require("os");
    var hasFlag = require_has_flag2();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os11.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/cli-table/node_modules/chalk/templates.js
var require_templates = __commonJS({
  "node_modules/cli-table/node_modules/chalk/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", ""],
      ["a", "\x07"]
    ]);
    function unescape2(c) {
      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name2, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape2(escape) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
        }
      }
      return results;
    }
    function parseStyle(style2) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style2)) !== null) {
        const name2 = matches[1];
        if (matches[2]) {
          const args = parseArguments(name2, matches[2]);
          results.push([name2].concat(args));
        } else {
          results.push([name2]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles3) {
      const enabled = {};
      for (const layer of styles3) {
        for (const style2 of layer.styles) {
          enabled[style2[0]] = layer.inverse ? null : style2.slice(1);
        }
      }
      let current = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module2.exports = (chalk, tmp) => {
      const styles3 = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style2, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape2(escapeChar));
        } else if (style2) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles3.length === 0 ? str : buildStyle(chalk, styles3)(str));
          styles3.push({ inverse, styles: parseStyle(style2) });
        } else if (close) {
          if (styles3.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles3)(chunk.join("")));
          chunk = [];
          styles3.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles3.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles3.length} closing bracket${styles3.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// node_modules/cli-table/node_modules/chalk/index.js
var require_chalk = __commonJS({
  "node_modules/cli-table/node_modules/chalk/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles();
    var stdoutColor = require_supports_color2().stdout;
    var template = require_templates();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = new Set(["gray"]);
    var styles3 = Object.create(null);
    function applyOptions(obj, options) {
      options = options || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level;
      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      styles3[key] = {
        get() {
          const codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
        }
      };
    }
    styles3.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles3[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles3[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles3);
    function build(_styles, _empty2, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty2;
      const self2 = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self2.level;
        },
        set(level) {
          self2.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self2.enabled;
        },
        set(enabled) {
          self2.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? "" : str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles3);
    module2.exports = Chalk();
    module2.exports.supportsColor = stdoutColor;
    module2.exports.default = module2.exports;
  }
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
  }
});

// node_modules/string-width/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS({
  "node_modules/string-width/node_modules/is-fullwidth-code-point/index.js"(exports2, module2) {
    "use strict";
    var isFullwidthCodePoint = (codePoint) => {
      if (Number.isNaN(codePoint)) {
        return false;
      }
      if (codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141)) {
        return true;
      }
      return false;
    };
    module2.exports = isFullwidthCodePoint;
    module2.exports.default = isFullwidthCodePoint;
  }
});

// node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "node_modules/emoji-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// node_modules/string-width/index.js
var require_string_width = __commonJS({
  "node_modules/string-width/index.js"(exports2, module2) {
    "use strict";
    var stripAnsi3 = require_strip_ansi();
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    var emojiRegex = require_emoji_regex();
    var stringWidth = (string2) => {
      string2 = string2.replace(emojiRegex(), "  ");
      if (typeof string2 !== "string" || string2.length === 0) {
        return 0;
      }
      string2 = stripAnsi3(string2);
      let width = 0;
      for (let i = 0; i < string2.length; i++) {
        const code = string2.codePointAt(i);
        if (code <= 31 || code >= 127 && code <= 159) {
          continue;
        }
        if (code >= 768 && code <= 879) {
          continue;
        }
        if (code > 65535) {
          i++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
      }
      return width;
    };
    module2.exports = stringWidth;
    module2.exports.default = stringWidth;
  }
});

// node_modules/cli-table/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/cli-table/lib/utils.js"(exports2) {
    var stringWidth = require_string_width();
    exports2.repeat = function(str, times) {
      return Array(times + 1).join(str);
    };
    exports2.pad = function(str, len, pad2, dir) {
      if (len + 1 >= str.length)
        switch (dir) {
          case "left":
            str = Array(len + 1 - str.length).join(pad2) + str;
            break;
          case "both":
            var right = Math.ceil((padlen = len - str.length) / 2);
            var left = padlen - right;
            str = Array(left + 1).join(pad2) + str + Array(right + 1).join(pad2);
            break;
          default:
            str = str + Array(len + 1 - str.length).join(pad2);
        }
      ;
      return str;
    };
    exports2.truncate = function(str, length, chr) {
      chr = chr || "\u2026";
      return str.length >= length ? str.substr(0, length - chr.length) + chr : str;
    };
    function options(defaults2, opts) {
      for (var p in opts) {
        if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {
          defaults2[p] = defaults2[p] || {};
          options(defaults2[p], opts[p]);
        } else {
          defaults2[p] = opts[p];
        }
      }
      return defaults2;
    }
    exports2.options = options;
    exports2.strlen = function(str) {
      var code = /\u001b\[(?:\d*;){0,5}\d*m/g;
      var stripped = ("" + (str != null ? str : "")).replace(code, "");
      var split = stripped.split("\n");
      return split.reduce(function(memo, s) {
        var len = stringWidth(s);
        return len > memo ? len : memo;
      }, 0);
    };
  }
});

// node_modules/cli-table/package.json
var require_package = __commonJS({
  "node_modules/cli-table/package.json"(exports2, module2) {
    module2.exports = {
      name: "cli-table",
      description: "Pretty unicode tables for the CLI",
      version: "0.3.4",
      license: "MIT",
      author: "Guillermo Rauch <guillermo@learnboost.com>",
      contributors: [
        "Sonny Michaud <michaud.sonny@gmail.com> (http://github.com/sonnym)",
        "Gabriel Sambarino <gabriel.sambarino@gmail.com> (http://github.com/chrean)"
      ],
      repository: {
        type: "git",
        url: "https://github.com/Automattic/cli-table.git"
      },
      keywords: [
        "cli",
        "colors",
        "table"
      ],
      dependencies: {
        chalk: "^2.4.1",
        "string-width": "^4.2.0"
      },
      devDependencies: {
        "@babel/core": "^7.12.9",
        "@babel/preset-env": "^7.12.7",
        "@babel/preset-typescript": "^7.12.7",
        "babel-jest": "^26.6.3",
        expect: "^26.6.2",
        expresso: "~0.9",
        jest: "^26.6.3",
        "jest-mock": "^26.6.2",
        "publish-please": "^5.5.2",
        "ts-node": "^9.1.0",
        typescript: "^4.1.2"
      },
      main: "lib",
      files: [
        "lib"
      ],
      scripts: {
        test: "jest",
        "publish-please": "publish-please --access public"
      },
      engines: {
        node: ">= 10.0.0"
      }
    };
  }
});

// node_modules/cli-table/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/cli-table/lib/index.js"(exports2, module2) {
    var colors = require_chalk();
    var utils = require_utils2();
    var repeat2 = utils.repeat;
    var truncate = utils.truncate;
    var pad2 = utils.pad;
    function Table2(options) {
      this.options = utils.options({
        chars: {
          "top": "\u2500",
          "top-mid": "\u252C",
          "top-left": "\u250C",
          "top-right": "\u2510",
          "bottom": "\u2500",
          "bottom-mid": "\u2534",
          "bottom-left": "\u2514",
          "bottom-right": "\u2518",
          "left": "\u2502",
          "left-mid": "\u251C",
          "mid": "\u2500",
          "mid-mid": "\u253C",
          "right": "\u2502",
          "right-mid": "\u2524",
          "middle": "\u2502"
        },
        truncate: "\u2026",
        colors: true,
        colWidths: [],
        colAligns: [],
        style: {
          "padding-left": 1,
          "padding-right": 1,
          head: ["red"],
          border: ["white"],
          compact: false
        },
        head: []
      }, options);
    }
    Table2.prototype.__proto__ = Array.prototype;
    Table2.prototype.__defineGetter__("width", function() {
      var str = this.toString().split("\n");
      if (str.length)
        return str[0].length;
      return 0;
    });
    Table2.prototype.render;
    Table2.prototype.toString = function() {
      var ret = "", options = this.options, style2 = options.style, head = options.head, chars = options.chars, truncater = options.truncate, colWidths = options.colWidths || new Array(this.head.length), totalWidth = 0;
      if (!head.length && !this.length)
        return "";
      if (!colWidths.length) {
        var all_rows = this.slice(0);
        if (head.length) {
          all_rows = all_rows.concat([head]);
        }
        ;
        all_rows.forEach(function(cells) {
          if (Array.isArray(cells) && cells.length) {
            extractColumnWidths(cells);
          } else {
            var header_cell = Object.keys(cells)[0], value_cell = cells[header_cell];
            colWidths[0] = Math.max(colWidths[0] || 0, get_width(header_cell) || 0);
            if (Array.isArray(value_cell) && value_cell.length) {
              extractColumnWidths(value_cell, 1);
            } else {
              colWidths[1] = Math.max(colWidths[1] || 0, get_width(value_cell) || 0);
            }
          }
        });
      }
      ;
      totalWidth = (colWidths.length == 1 ? colWidths[0] : colWidths.reduce(function(a, b) {
        return a + b;
      })) + colWidths.length + 1;
      function extractColumnWidths(arr, offset) {
        var offset = offset || 0;
        arr.forEach(function(cell, i) {
          colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, get_width(cell) || 0);
        });
      }
      ;
      function get_width(obj) {
        return typeof obj == "object" && obj && obj.width != void 0 ? obj.width : (typeof obj == "object" && obj !== null ? utils.strlen(obj.text) : utils.strlen(obj)) + (style2["padding-left"] || 0) + (style2["padding-right"] || 0);
      }
      function line(line2, left, right, intersection) {
        var width = 0, line2 = left + repeat2(line2, totalWidth - 2) + right;
        colWidths.forEach(function(w, i) {
          if (i == colWidths.length - 1)
            return;
          width += w + 1;
          line2 = line2.substr(0, width) + intersection + line2.substr(width + 1);
        });
        return applyStyles(options.style.border, line2);
      }
      ;
      function lineTop() {
        var l2 = line(chars.top, chars["top-left"] || chars.top, chars["top-right"] || chars.top, chars["top-mid"]);
        if (l2)
          ret += l2 + "\n";
      }
      ;
      function generateRow(items, style3) {
        var cells = [], max_height = 0;
        if (!Array.isArray(items) && typeof items === "object") {
          var key = Object.keys(items)[0], value = items[key], first_cell_head = true;
          if (Array.isArray(value)) {
            items = value;
            items.unshift(key);
          } else {
            items = [key, value];
          }
        }
        items.forEach(function(item, i) {
          var contents = (item == null ? "" : item).toString().split("\n").reduce(function(memo, l2) {
            memo.push(string2(l2, i));
            return memo;
          }, []);
          var height = contents.length;
          if (height > max_height) {
            max_height = height;
          }
          ;
          cells.push({ contents, height });
        });
        var lines = new Array(max_height);
        cells.forEach(function(cell, i) {
          cell.contents.forEach(function(line2, j2) {
            if (!lines[j2]) {
              lines[j2] = [];
            }
            ;
            if (style3 || first_cell_head && i === 0 && options.style.head) {
              line2 = applyStyles(options.style.head, line2);
            }
            lines[j2].push(line2);
          });
          for (var j = cell.height, l2 = max_height; j < l2; j++) {
            if (!lines[j]) {
              lines[j] = [];
            }
            ;
            lines[j].push(string2("", i));
          }
        });
        var ret2 = "";
        lines.forEach(function(line2, index) {
          if (ret2.length > 0) {
            ret2 += "\n" + applyStyles(options.style.border, chars.left);
          }
          ret2 += line2.join(applyStyles(options.style.border, chars.middle)) + applyStyles(options.style.border, chars.right);
        });
        return applyStyles(options.style.border, chars.left) + ret2;
      }
      ;
      function applyStyles(styles3, subject) {
        if (!subject)
          return "";
        if (!options.colors)
          return subject;
        styles3.forEach(function(style3) {
          subject = colors[style3](subject);
        });
        return subject;
      }
      ;
      function string2(str, index) {
        var str = String(typeof str == "object" && str.text ? str.text : str), length = utils.strlen(str), width = colWidths[index] - (style2["padding-left"] || 0) - (style2["padding-right"] || 0), align = options.colAligns[index] || "left";
        return repeat2(" ", style2["padding-left"] || 0) + (length == width ? str : length < width ? pad2(str, width + (str.length - length), " ", align == "left" ? "right" : align == "middle" ? "both" : "left") : truncater ? truncate(str, width, truncater) : str) + repeat2(" ", style2["padding-right"] || 0);
      }
      ;
      if (head.length) {
        lineTop();
        ret += generateRow(head, style2.head) + "\n";
      }
      if (this.length)
        this.forEach(function(cells, i) {
          if (!head.length && i == 0)
            lineTop();
          else {
            if (!style2.compact || i < !!head.length ? 1 : cells.length == 0) {
              var l2 = line(chars.mid, chars["left-mid"], chars["right-mid"], chars["mid-mid"]);
              if (l2)
                ret += l2 + "\n";
            }
          }
          if (Array.isArray(cells) && !cells.length) {
            return;
          } else {
            ret += generateRow(cells) + "\n";
          }
          ;
        });
      var l = line(chars.bottom, chars["bottom-left"] || chars.bottom, chars["bottom-right"] || chars.bottom, chars["bottom-mid"]);
      if (l)
        ret += l;
      else
        ret = ret.slice(0, -1);
      return ret;
    };
    module2.exports = Table2;
    module2.exports.version = require_package().version;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles2 = __commonJS({
  "node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi256 = (offset = 0) => (code) => `[${38 + offset};5;${code}m`;
    var wrapAnsi16m = (offset = 0) => (red, green, blue2) => `[${38 + offset};2;${red};${green};${blue2}m`;
    function assembleStyles() {
      const codes = new Map();
      const styles3 = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles3.color.gray = styles3.color.blackBright;
      styles3.bgColor.bgGray = styles3.bgColor.bgBlackBright;
      styles3.color.grey = styles3.color.blackBright;
      styles3.bgColor.bgGrey = styles3.bgColor.bgBlackBright;
      for (const [groupName, group2] of Object.entries(styles3)) {
        for (const [styleName, style2] of Object.entries(group2)) {
          styles3[styleName] = {
            open: `[${style2[0]}m`,
            close: `[${style2[1]}m`
          };
          group2[styleName] = styles3[styleName];
          codes.set(style2[0], style2[1]);
        }
        Object.defineProperty(styles3, groupName, {
          value: group2,
          enumerable: false
        });
      }
      Object.defineProperty(styles3, "codes", {
        value: codes,
        enumerable: false
      });
      styles3.color.close = "[39m";
      styles3.bgColor.close = "[49m";
      styles3.color.ansi256 = wrapAnsi256();
      styles3.color.ansi16m = wrapAnsi16m();
      styles3.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles3.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      styles3.rgbToAnsi256 = (red, green, blue2) => {
        if (red === green && green === blue2) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue2 / 255 * 5);
      };
      styles3.hexToRgb = (hex) => {
        const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let { colorString } = matches.groups;
        if (colorString.length === 3) {
          colorString = colorString.split("").map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      };
      styles3.hexToAnsi256 = (hex) => styles3.rgbToAnsi256(...styles3.hexToRgb(hex));
      return styles3;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// src/markdown/styles.ts
function gray(str) {
  return `${import_ansi_styles.default.gray.open}${str}${import_ansi_styles.default.gray.close}`;
}
function magenta(str) {
  return `${import_ansi_styles.default.magenta.open}${str}${import_ansi_styles.default.magenta.close}`;
}
function bold(str) {
  return `${import_ansi_styles.default.bold.open}${str}${import_ansi_styles.default.bold.close}`;
}
function underline(str) {
  return `${import_ansi_styles.default.underline.open}${str}${import_ansi_styles.default.underline.close}`;
}
function strikethrough(str) {
  return `${import_ansi_styles.default.strikethrough.open}${str}${import_ansi_styles.default.strikethrough.close}`;
}
function italic(str) {
  return `${import_ansi_styles.default.italic.open}${str}${import_ansi_styles.default.italic.close}`;
}
function yellow(str) {
  return `${import_ansi_styles.default.yellow.open}${str}${import_ansi_styles.default.yellow.close}`;
}
function blue(str) {
  return `${import_ansi_styles.default.blue.open}${str}${import_ansi_styles.default.blue.close}`;
}
var import_ansi_styles;
var init_styles = __esm({
  "src/markdown/styles.ts"() {
    import_ansi_styles = __toModule(require_ansi_styles2());
  }
});

// src/markdown/renderer.ts
function fixHardReturn(text, reflow) {
  return reflow ? text.replace(HARD_RETURN, /\n/g) : text;
}
function sanitizeTab(tab, fallbackTab) {
  if (typeof tab === "number") {
    return new Array(tab + 1).join(" ");
  } else if (typeof tab === "string" && isAllowedTabString(tab)) {
    return tab;
  } else {
    return new Array(fallbackTab + 1).join(" ");
  }
}
function isAllowedTabString(str) {
  return TAB_ALLOWED_CHARACTERS.some(function(char) {
    return str.match("^(" + char + ")+$");
  });
}
function indentLines(indent, text) {
  return text.replace(/(^|\n)(.+)/g, "$1" + indent + "$2");
}
function indentify(indent, text) {
  if (!text)
    return text;
  return indent + text.split("\n").join("\n" + indent);
}
function fixNestedLists(body, indent) {
  let regex = new RegExp("(\\S(?: |  )?)((?:" + indent + ")+)(" + POINT_REGEX + "(?:.*)+)$", "gm");
  return body.replace(regex, "$1\n" + indent + "$2$3");
}
function toSpaces(str) {
  return " ".repeat(str.length);
}
function bulletPointLine(indent, line) {
  return isPointedLine(line, indent) ? line : toSpaces(BULLET_POINT) + line;
}
function bulletPointLines(lines, indent) {
  let transform = bulletPointLine.bind(null, indent);
  return lines.split("\n").filter(identity).map(transform).join("\n");
}
function numberedLine(indent, line, num) {
  return isPointedLine(line, indent) ? {
    num: num + 1,
    line: line.replace(BULLET_POINT, numberedPoint(num + 1))
  } : {
    num,
    line: toSpaces(numberedPoint(num)) + line
  };
}
function numberedLines(lines, indent) {
  let transform = numberedLine.bind(null, indent);
  let num = 0;
  return lines.split("\n").filter(identity).map((line) => {
    const numbered = transform(line, num);
    num = numbered.num;
    return numbered.line;
  }).join("\n");
}
function list(body, ordered, indent) {
  body = body.trim();
  body = ordered ? numberedLines(body, indent) : bulletPointLines(body, indent);
  return body;
}
function section(text) {
  return text + "\n\n";
}
function undoColon(str) {
  return str.replace(COLON_REPLACER_REGEXP, ":");
}
function generateTableRow(text, escape = null) {
  if (!text)
    return [];
  escape = escape || identity;
  let lines = escape(text).split("\n");
  let data = [];
  lines.forEach(function(line) {
    if (!line)
      return;
    let parsed = line.replace(TABLE_ROW_WRAP_REGEXP, "").split(TABLE_CELL_SPLIT);
    data.push(parsed.splice(0, parsed.length - 1));
  });
  return data;
}
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function unescapeEntities(html) {
  return html.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
}
function identity(str) {
  return str;
}
var import_cli_table, logger3, TABLE_CELL_SPLIT, TABLE_ROW_WRAP, TABLE_ROW_WRAP_REGEXP, COLON_REPLACER, COLON_REPLACER_REGEXP, TAB_ALLOWED_CHARACTERS, HARD_RETURN, defaultOptions, BULLET_POINT_REGEX, NUMBERED_POINT_REGEX, POINT_REGEX, isPointedLine, BULLET_POINT, numberedPoint, links, Renderer, renderer_default;
var init_renderer = __esm({
  "src/markdown/renderer.ts"() {
    import_cli_table = __toModule(require_lib7());
    init_styles();
    logger3 = require_logger2()("markdown-renderer");
    TABLE_CELL_SPLIT = "^*||*^";
    TABLE_ROW_WRAP = "*|*|*|*";
    TABLE_ROW_WRAP_REGEXP = new RegExp(escapeRegExp(TABLE_ROW_WRAP), "g");
    COLON_REPLACER = "*#COLON|*";
    COLON_REPLACER_REGEXP = new RegExp(escapeRegExp(COLON_REPLACER), "g");
    TAB_ALLOWED_CHARACTERS = ["	"];
    HARD_RETURN = "\r";
    defaultOptions = {
      code: identity,
      blockquote: identity,
      html: gray,
      heading: magenta,
      firstHeading: magenta,
      hr: identity,
      listitem: identity,
      list,
      table: identity,
      paragraph: identity,
      strong: bold,
      em: italic,
      codespan: yellow,
      del: strikethrough,
      link: underline,
      href: underline,
      text: identity,
      unescape: true,
      emoji: false,
      width: 80,
      showSectionPrefix: true,
      tab: 2,
      tableOptions: {}
    };
    BULLET_POINT_REGEX = "\\*";
    NUMBERED_POINT_REGEX = "\\d+\\.";
    POINT_REGEX = "(?:" + [BULLET_POINT_REGEX, NUMBERED_POINT_REGEX].join("|") + ")";
    isPointedLine = function(line, indent) {
      return line.match("^(?:" + indent + ")*" + POINT_REGEX);
    };
    BULLET_POINT = "* ";
    numberedPoint = function(n) {
      return n + ". ";
    };
    links = new Map();
    Renderer = class {
      constructor(options = {}, highlightOptions = {}) {
        this.options = options;
        this.highlightOptions = highlightOptions;
        this.o = Object.assign({}, defaultOptions, options);
        this.tab = sanitizeTab(this.o.tab, defaultOptions.tab);
        this.tableSettings = this.o.tableOptions;
        this.unescape = this.o.unescape ? unescapeEntities : identity;
        this.highlightOptions = highlightOptions || {};
        this.transform = this.compose(undoColon, this.unescape);
      }
      textLength(str) {
        return str.replace(/\u001b\[(?:\d{1,3})(?:;\d{1,3})*m/g, "").length;
      }
      text(t) {
        return this.o.text(t);
      }
      code(code, lang, _escaped) {
        return "``` " + lang + "\n" + code + "\n```\n";
      }
      blockquote(quote) {
        return section(this.o.blockquote(indentify(this.tab, quote.trim())));
      }
      html(html) {
        return this.o.html(html);
      }
      heading(text, level, _raw) {
        text = this.transform(text);
        let prefix = this.o.showSectionPrefix ? new Array(level + 1).join("#") + " " : "";
        text = prefix + text;
        return section(level === 1 ? this.o.firstHeading(text) : this.o.heading(text));
      }
      hr() {
        return `---

`;
      }
      list(body, ordered) {
        body = this.o.list(body, ordered, this.tab);
        return section(fixNestedLists(indentLines(this.tab, body), this.tab));
      }
      listitem(text) {
        let transform = this.compose(this.o.listitem, this.transform);
        let isNested = text.indexOf("\n") !== -1;
        if (isNested)
          text = text.trim();
        return "\n" + BULLET_POINT + transform(text);
      }
      checkbox(checked) {
        return "[" + (checked ? "X" : " ") + "] ";
      }
      paragraph(text) {
        let transform = this.compose(this.o.paragraph, this.transform);
        text = transform(text);
        return section(text);
      }
      table(header, body) {
        let table = new import_cli_table.default(Object.assign({}, {
          head: generateTableRow(header)[0]
        }, this.tableSettings));
        generateTableRow(body, this.transform).forEach(function(row) {
          table.push(row);
        });
        return section(this.o.table(table.toString()));
      }
      tablerow(content) {
        return TABLE_ROW_WRAP + content + TABLE_ROW_WRAP + "\n";
      }
      tablecell(content, _flags) {
        return content + TABLE_CELL_SPLIT;
      }
      strong(text) {
        return this.o.strong(text);
      }
      em(text) {
        text = fixHardReturn(text, this.o.reflowText);
        return this.o.em(text);
      }
      codespan(text) {
        text = fixHardReturn(text, this.o.reflowText);
        return this.o.codespan(text.replace(/:/g, COLON_REPLACER));
      }
      br() {
        return "\n";
      }
      del(text) {
        return this.o.del(text);
      }
      link(href, title, text) {
        let prot;
        if (this.options.sanitize) {
          try {
            prot = decodeURIComponent(unescape(href)).replace(/[^\w:]/g, "").toLowerCase();
          } catch (e) {
            return "";
          }
          if (prot.startsWith("javascript:")) {
            return "";
          }
        }
        if (text && href && text != href) {
          links.set(text, href);
        }
        if (text && text != href)
          return blue(text);
        let out = this.o.href(href);
        return this.o.link(out);
      }
      image(href, title, text) {
        if (typeof this.o.image === "function") {
          return this.o.image(href, title, text);
        }
        let out = "![" + text;
        if (title)
          out += " \u2013 " + title;
        return out + "](" + href + ")\n";
      }
      compose(...funcs) {
        return (...args) => {
          for (let i = funcs.length; i-- > 0; ) {
            args = [funcs[i].apply(this, args)];
          }
          return args[0];
        };
      }
      static getLinks() {
        let res = [];
        for (let [text, href] of links.entries()) {
          res.push(`${blue(text)}: ${href}`);
        }
        links.clear();
        return res;
      }
    };
    renderer_default = Renderer;
  }
});

// src/util/string.ts
function byteLength(str) {
  return Buffer.byteLength(str);
}
function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.slice(1) : "";
}
function byteIndex(content, index) {
  let s = content.slice(0, index);
  return Buffer.byteLength(s);
}
function characterIndex(content, byteIndex2) {
  let buf = Buffer.from(content, "utf8");
  return buf.slice(0, byteIndex2).toString("utf8").length;
}
function byteSlice(content, start, end) {
  let buf = Buffer.from(content, "utf8");
  return buf.slice(start, end).toString("utf8");
}
function isWord(character) {
  let code = character.charCodeAt(0);
  if (code > 128)
    return false;
  if (code == 95)
    return true;
  if (code >= 48 && code <= 57)
    return true;
  if (code >= 65 && code <= 90)
    return true;
  if (code >= 97 && code <= 122)
    return true;
  return false;
}
var init_string = __esm({
  "src/util/string.ts"() {
  }
});

// src/util/ansiparse.ts
function parseAnsiHighlights(line, markdown = false) {
  let items = ansiparse(line);
  let highlights = [];
  let newLabel = "";
  for (let item of items) {
    if (!item.text)
      continue;
    let { foreground, background, bold: bold2, italic: italic2, underline: underline2 } = item;
    let len = byteLength(newLabel);
    if (foreground || background || bold2 || italic2 || underline2) {
      let span = [len, len + byteLength(item.text)];
      let hlGroup = "";
      if (foreground && background) {
        hlGroup = `CocList${upperFirst(foreground)}${upperFirst(background)}`;
      } else if (foreground) {
        if (markdown) {
          if (foreground == "yellow") {
            hlGroup = "CocMarkdownCode";
          } else if (foreground == "blue") {
            hlGroup = "CocMarkdownLink";
          } else if (foreground == "magenta") {
            hlGroup = "CocMarkdownHeader";
          } else {
            hlGroup = `CocListFg${upperFirst(foreground)}`;
          }
        } else {
          hlGroup = `CocListFg${upperFirst(foreground)}`;
        }
      } else if (background) {
        hlGroup = `CocListBg${upperFirst(background)}`;
      } else if (bold2) {
        hlGroup = "CocBold";
      } else if (italic2) {
        hlGroup = "CocItalic";
      } else if (underline2) {
        hlGroup = "CocUnderline";
      }
      highlights.push({ span, hlGroup });
    }
    newLabel = newLabel + item.text;
  }
  return { line: newLabel, highlights };
}
function ansiparse(str) {
  let matchingControl = null;
  let matchingData = null;
  let matchingText = "";
  let ansiState = [];
  let result = [];
  let state = {};
  let eraseChar;
  eraseChar = () => {
    let index;
    let text;
    if (matchingText.length) {
      matchingText = matchingText.substr(0, matchingText.length - 1);
    } else if (result.length) {
      index = result.length - 1;
      text = result[index].text;
      if (text.length === 1) {
        result.pop();
      } else {
        result[index].text = text.substr(0, text.length - 1);
      }
    }
  };
  for (let i = 0; i < str.length; i++) {
    if (matchingControl != null) {
      if (matchingControl == "" && str[i] == "[") {
        if (matchingText) {
          state.text = matchingText;
          result.push(state);
          state = {};
          matchingText = "";
        }
        if (matchingText == "" && (str[i + 1] == "m" || str[i + 1] == "K")) {
          if (state.foreground || state.background) {
            state.text = "";
            result.push(state);
          }
          state = {};
        }
        matchingControl = null;
        matchingData = "";
      } else {
        matchingText += matchingControl + str[i];
        matchingControl = null;
      }
      continue;
    } else if (matchingData != null) {
      if (str[i] == ";") {
        ansiState.push(matchingData);
        matchingData = "";
      } else if (str[i] == "m" || str[i] == "K") {
        ansiState.push(matchingData);
        matchingData = null;
        matchingText = "";
        ansiState.forEach((ansiCode) => {
          if (foregroundColors[ansiCode]) {
            state.foreground = foregroundColors[ansiCode];
          } else if (backgroundColors[ansiCode]) {
            state.background = backgroundColors[ansiCode];
          } else if (ansiCode == 39) {
            delete state.foreground;
          } else if (ansiCode == 49) {
            delete state.background;
          } else if (styles2[ansiCode]) {
            state[styles2[ansiCode]] = true;
          } else if (ansiCode == 22) {
            state.bold = false;
          } else if (ansiCode == 23) {
            state.italic = false;
          } else if (ansiCode == 24) {
            state.underline = false;
          }
        });
        ansiState = [];
      } else {
        matchingData += str[i];
      }
      continue;
    }
    if (str[i] == "") {
      matchingControl = str[i];
    } else if (str[i] == "\b") {
      eraseChar();
    } else {
      matchingText += str[i];
    }
  }
  if (matchingText) {
    state.text = matchingText + (matchingControl ? matchingControl : "");
    result.push(state);
  }
  return result;
}
var foregroundColors, backgroundColors, styles2;
var init_ansiparse = __esm({
  "src/util/ansiparse.ts"() {
    init_string();
    foregroundColors = {
      30: "black",
      31: "red",
      32: "green",
      33: "yellow",
      34: "blue",
      35: "magenta",
      36: "cyan",
      37: "white",
      90: "grey"
    };
    backgroundColors = {
      40: "black",
      41: "red",
      42: "green",
      43: "yellow",
      44: "blue",
      45: "magenta",
      46: "cyan",
      47: "white"
    };
    styles2 = {
      1: "bold",
      3: "italic",
      4: "underline"
    };
  }
});

// src/markdown/index.ts
function parseDocuments(docs, opts = {}) {
  let lines = [];
  let highlights = [];
  let codes = [];
  let idx = 0;
  for (let doc of docs) {
    let currline = lines.length;
    let { content, filetype } = doc;
    if (filetype == "markdown") {
      let info = parseMarkdown(content, opts);
      codes.push(...info.codes.map((o) => {
        o.startLine = o.startLine + currline;
        o.endLine = o.endLine + currline;
        return o;
      }));
      highlights.push(...info.highlights.map((o) => {
        o.lnum = o.lnum + currline;
        return o;
      }));
      lines.push(...info.lines);
    } else {
      let parts = content.trim().split(/\r?\n/);
      if (diagnosticFiletypes.includes(doc.filetype)) {
        codes.push({ hlGroup: `Coc${filetype}Float`, startLine: currline, endLine: currline + parts.length });
      } else {
        codes.push({ filetype: doc.filetype, startLine: currline, endLine: currline + parts.length });
      }
      lines.push(...parts);
    }
    if (doc.active) {
      let arr = getHighlightItems(content, currline, doc.active);
      if (arr.length)
        highlights.push(...arr);
    }
    if (idx != docs.length - 1) {
      lines.push("\u2014");
    }
    idx = idx + 1;
  }
  return { lines, highlights, codes };
}
function getHighlightItems(content, currline, active) {
  let res = [];
  let [start, end] = active;
  let lines = content.split(/\r?\n/);
  let used = 0;
  let inRange = false;
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    if (!inRange) {
      if (used + line.length > start) {
        inRange = true;
        let colStart = byteLength(line.slice(0, start - used));
        if (used + line.length > end) {
          let colEnd = byteLength(line.slice(0, end - used));
          inRange = false;
          res.push({ colStart, colEnd, lnum: i + currline, hlGroup: "CocUnderline" });
          break;
        } else {
          let colEnd = byteLength(line);
          res.push({ colStart, colEnd, lnum: i + currline, hlGroup: "CocUnderline" });
        }
      }
    } else {
      if (used + line.length > end) {
        let colEnd = byteLength(line.slice(0, end - used));
        res.push({ colStart: 0, colEnd, lnum: i + currline, hlGroup: "CocUnderline" });
        inRange = false;
        break;
      } else {
        let colEnd = byteLength(line);
        res.push({ colStart: 0, colEnd, lnum: i + currline, hlGroup: "CocUnderline" });
      }
    }
    used = used + line.length + 1;
  }
  return res;
}
function parseMarkdown(content, opts) {
  import_marked.default.setOptions({
    renderer: new renderer_default(),
    gfm: true
  });
  let lines = [];
  let highlights = [];
  let codes = [];
  let currline = 0;
  let inCodeBlock = false;
  let filetype;
  let startLnum = 0;
  let parsed = (0, import_marked.default)(content);
  let links2 = renderer_default.getLinks();
  if (links2.length) {
    parsed = parsed + "\n\n" + links2.join("\n");
  }
  parsed = parsed.replace(/\s*$/, "");
  let parsedLines = parsed.split(/\n/);
  for (let i = 0; i < parsedLines.length; i++) {
    let line = parsedLines[i];
    if (!line.length) {
      let pre = lines[lines.length - 1];
      if (pre && pre.length) {
        lines.push(line);
        currline++;
      }
      continue;
    }
    if (opts.excludeImages && line.indexOf("![") !== -1) {
      line = line.replace(/\s*!\[.*?\]\(.*?\)/g, "");
      if (!(0, import_strip_ansi.default)(line).trim().length)
        continue;
    }
    if (/\s*```\s*([A-Za-z0-9_,]+)?$/.test(line)) {
      if (!inCodeBlock) {
        let pre = parsedLines[i - 1];
        if (pre && /^\s*```\s*/.test(pre)) {
          lines.push("");
          currline++;
        }
        inCodeBlock = true;
        filetype = line.replace(/^\s*```\s*/, "");
        if (filetype == "js")
          filetype = "javascript";
        if (filetype == "ts")
          filetype = "typescript";
        if (filetype == "bash")
          filetype = "sh";
        startLnum = currline;
      } else {
        inCodeBlock = false;
        codes.push({
          filetype,
          startLine: startLnum,
          endLine: currline
        });
      }
      continue;
    }
    if (inCodeBlock) {
      lines.push(line);
      currline++;
      continue;
    }
    let res = parseAnsiHighlights(line, true);
    if (res.highlights) {
      for (let hi of res.highlights) {
        let { hlGroup, span } = hi;
        highlights.push({
          hlGroup,
          lnum: currline,
          colStart: span[0],
          colEnd: span[1]
        });
      }
    }
    lines.push(res.line);
    currline++;
  }
  return { lines, highlights, codes };
}
var import_marked, import_strip_ansi, diagnosticFiletypes, logger4;
var init_markdown = __esm({
  "src/markdown/index.ts"() {
    import_marked = __toModule(require_marked());
    init_renderer();
    init_ansiparse();
    init_string();
    import_strip_ansi = __toModule(require_strip_ansi());
    diagnosticFiletypes = ["Error", "Warning", "Info", "Hint"];
    logger4 = require_logger2()("markdown-index");
  }
});

// src/util/mutex.ts
var Mutex;
var init_mutex = __esm({
  "src/util/mutex.ts"() {
    Mutex = class {
      constructor() {
        this.tasks = [];
        this.count = 1;
      }
      sched() {
        if (this.count > 0 && this.tasks.length > 0) {
          this.count--;
          let next = this.tasks.shift();
          next();
        }
      }
      get busy() {
        return this.count == 0;
      }
      acquire() {
        return new Promise((res) => {
          let task = () => {
            let released = false;
            res(() => {
              if (!released) {
                released = true;
                this.count++;
                this.sched();
              }
            });
          };
          this.tasks.push(task);
          process.nextTick(this.sched.bind(this));
        });
      }
      use(f) {
        return this.acquire().then((release) => f().then((res) => {
          release();
          return res;
        }).catch((err) => {
          release();
          throw err;
        }));
      }
    };
  }
});

// src/model/floatFactory.ts
var import_debounce2, import_vscode_languageserver_protocol3, isVim, logger5, FloatFactory;
var init_floatFactory = __esm({
  "src/model/floatFactory.ts"() {
    import_debounce2 = __toModule(require_debounce());
    import_vscode_languageserver_protocol3 = __toModule(require_main2());
    init_events();
    init_markdown();
    init_util();
    init_mutex();
    init_object();
    isVim = process.env.VIM_NODE_RPC == "1";
    logger5 = require_logger2()("model-float");
    FloatFactory = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.winid = 0;
        this._bufnr = 0;
        this.mutex = new Mutex();
        this.disposables = [];
        this.alignTop = false;
        this.pumAlignTop = false;
        this.autoHide = true;
        this.mutex = new Mutex();
        events_default.on("BufEnter", (bufnr) => {
          if (bufnr == this._bufnr || bufnr == this.targetBufnr)
            return;
          this.close();
        }, null, this.disposables);
        events_default.on("InsertEnter", (bufnr) => {
          if (bufnr == this._bufnr || !this.autoHide)
            return;
          this.close();
        }, null, this.disposables);
        events_default.on("InsertLeave", () => {
          this.close();
        }, null, this.disposables);
        events_default.on("MenuPopupChanged", (ev, cursorline) => {
          let pumAlignTop = this.pumAlignTop = cursorline > ev.row;
          if (pumAlignTop == this.alignTop) {
            this.close();
          }
        }, null, this.disposables);
        this.onCursorMoved = (0, import_debounce2.default)(this._onCursorMoved.bind(this), 300);
        events_default.on("CursorMoved", this.onCursorMoved.bind(this, false), null, this.disposables);
        events_default.on("CursorMovedI", this.onCursorMoved.bind(this, true), null, this.disposables);
        this.disposables.push(import_vscode_languageserver_protocol3.Disposable.create(() => {
          this.onCursorMoved.clear();
          this.cancel();
        }));
      }
      _onCursorMoved(insertMode, bufnr, cursor) {
        if (bufnr == this._bufnr)
          return;
        if (bufnr == this.targetBufnr && equals(cursor, this.cursor)) {
          return;
        }
        if (this.autoHide) {
          this.close();
          return;
        }
        if (!insertMode || bufnr != this.targetBufnr) {
          this.close();
          return;
        }
      }
      async create(docs, _allowSelection = false, offsetX = 0) {
        this.onCursorMoved.clear();
        if (docs.length == 0 || docs.every((doc) => doc.content.length == 0)) {
          this.close();
          return;
        }
        let release = await this.mutex.acquire();
        try {
          await this.createPopup(docs, { offsetX });
          release();
        } catch (e) {
          release();
          logger5.error(`Error on create popup:`, e.message);
          this.close();
        }
      }
      async show(docs, config = {}) {
        this.onCursorMoved.clear();
        if (docs.length == 0 || docs.every((doc) => doc.content.length == 0)) {
          this.close();
          return;
        }
        let release = await this.mutex.acquire();
        try {
          await this.createPopup(docs, config);
          release();
        } catch (e) {
          release();
          logger5.error(`Error on create popup:`, e.message);
          this.close();
        }
      }
      async createPopup(docs, opts) {
        let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol3.CancellationTokenSource();
        let token = tokenSource.token;
        docs = docs.filter((o) => o.content.trim().length > 0);
        let { lines, codes, highlights } = parseDocuments(docs);
        let config = {
          pumAlignTop: this.pumAlignTop,
          preferTop: typeof opts.preferTop === "boolean" ? opts.preferTop : false,
          offsetX: opts.offsetX || 0,
          title: opts.title || "",
          close: opts.close ? 1 : 0,
          codes,
          highlights,
          modes: opts.modes || ["n", "i", "ic", "s"]
        };
        if (opts.maxHeight)
          config.maxHeight = opts.maxHeight;
        if (opts.maxWidth)
          config.maxWidth = opts.maxWidth;
        if (opts.border && !opts.border.every((o) => o == 0)) {
          config.border = opts.border;
        }
        if (opts.title && !config.border)
          config.border = [1, 1, 1, 1];
        if (opts.highlight)
          config.highlight = opts.highlight;
        if (opts.borderhighlight)
          config.borderhighlight = [opts.borderhighlight];
        if (opts.cursorline)
          config.cursorline = 1;
        this.autoHide = opts.autoHide == false ? false : true;
        if (this.autoHide)
          config.autohide = 1;
        let arr = await this.nvim.call("coc#float#create_cursor_float", [this.winid, this._bufnr, lines, config]);
        if (isVim)
          this.nvim.command("redraw", true);
        if (!arr || arr.length == 0) {
          this.winid = null;
          return;
        }
        let [targetBufnr, cursor, winid, bufnr] = arr;
        this.winid = winid;
        if (token.isCancellationRequested) {
          this.close();
          return;
        }
        let pos = await this.nvim.call("coc#float#cursor_relative", [winid]);
        if (pos)
          this.alignTop = pos.row < 0;
        this._bufnr = bufnr;
        this.tokenSource.dispose();
        this.tokenSource = null;
        this.targetBufnr = targetBufnr;
        this.cursor = cursor;
        this.onCursorMoved.clear();
      }
      close() {
        let { winid, nvim } = this;
        this.cancel();
        if (winid) {
          this.winid = 0;
          nvim.pauseNotification();
          nvim.call("coc#float#close", [winid], true);
          if (isVim)
            this.nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        }
      }
      cancel() {
        let { tokenSource } = this;
        if (tokenSource) {
          tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      dispose() {
        disposeAll(this.disposables);
      }
      get bufnr() {
        return this._bufnr;
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : null;
      }
      get window() {
        return this.winid ? this.nvim.createWindow(this.winid) : null;
      }
      async activated() {
        if (!this.winid)
          return false;
        return await this.nvim.call("coc#float#valid", [this.winid]) != 0;
      }
    };
  }
});

// src/util/position.ts
function rangeInRange(r, range) {
  return positionInRange(r.start, range) === 0 && positionInRange(r.end, range) === 0;
}
function rangeOverlap(r, range) {
  let { start, end } = r;
  if (comparePosition(end, range.start) <= 0) {
    return false;
  }
  if (comparePosition(start, range.end) >= 0) {
    return false;
  }
  return true;
}
function rangeIntersect(r, range) {
  if (positionInRange(r.start, range) == 0) {
    return true;
  }
  if (positionInRange(r.end, range) == 0) {
    return true;
  }
  if (rangeInRange(range, r)) {
    return true;
  }
  return false;
}
function lineInRange(line, range) {
  let { start, end } = range;
  return line >= start.line && line <= end.line;
}
function emptyRange(range) {
  let { start, end } = range;
  return start.line == end.line && start.character == end.character;
}
function positionInRange(position, range) {
  let { start, end } = range;
  if (comparePosition(position, start) < 0)
    return -1;
  if (comparePosition(position, end) > 0)
    return 1;
  return 0;
}
function comparePosition(position, other) {
  if (position.line > other.line)
    return 1;
  if (other.line == position.line && position.character > other.character)
    return 1;
  if (other.line == position.line && position.character == other.character)
    return 0;
  return -1;
}
function isSingleLine(range) {
  return range.start.line == range.end.line;
}
function getChangedPosition(start, edit2) {
  let { range, newText } = edit2;
  if (comparePosition(range.end, start) <= 0) {
    let lines = newText.split("\n");
    let lineCount = lines.length - (range.end.line - range.start.line) - 1;
    let characterCount = 0;
    if (range.end.line == start.line) {
      let single = isSingleLine(range) && lineCount == 0;
      let removed = single ? range.end.character - range.start.character : range.end.character;
      let added = single ? newText.length : lines[lines.length - 1].length;
      characterCount = added - removed;
    }
    return { line: lineCount, character: characterCount };
  }
  return { line: 0, character: 0 };
}
function adjustPosition(pos, edit2) {
  let { range, newText } = edit2;
  if (comparePosition(range.start, pos) > 1)
    return pos;
  let { start, end } = range;
  let newLines = newText.split("\n");
  let delta = end.line - start.line - newLines.length + 1;
  let lastLine = newLines[newLines.length - 1];
  let line = pos.line - delta;
  if (pos.line != end.line)
    return { line, character: pos.character };
  let pre = newLines.length == 1 && start.line != end.line ? start.character : 0;
  let removed = start.line == end.line && newLines.length == 1 ? end.character - start.character : end.character;
  let character = pre + pos.character + lastLine.length - removed;
  return {
    line,
    character
  };
}
function positionToOffset(lines, line, character) {
  let offset = 0;
  for (let i = 0; i <= line; i++) {
    if (i == line) {
      offset += character;
    } else {
      offset += lines[i].length + 1;
    }
  }
  return offset;
}
function editRange(range, text, edit2) {
  if (!rangeInRange(edit2.range, range))
    return text;
  let { start, end } = edit2.range;
  let lines = text.split("\n");
  let character = start.line == range.start.line ? start.character - range.start.character : start.character;
  let startOffset = positionToOffset(lines, start.line - range.start.line, character);
  character = end.line == range.start.line ? end.character - range.start.character : end.character;
  let endOffset = positionToOffset(lines, end.line - range.start.line, character);
  return `${text.slice(0, startOffset)}${edit2.newText}${text.slice(endOffset, text.length)}`;
}
function getChangedFromEdits(start, edits) {
  let changed = { line: 0, character: 0 };
  for (let edit2 of edits) {
    let d = getChangedPosition(start, edit2);
    changed = { line: changed.line + d.line, character: changed.character + d.character };
  }
  return changed.line == 0 && changed.character == 0 ? null : changed;
}
var init_position = __esm({
  "src/util/position.ts"() {
  }
});

// src/model/outputChannel.ts
var logger6, BufferChannel;
var init_outputChannel = __esm({
  "src/model/outputChannel.ts"() {
    init_util();
    logger6 = require_logger2()("outpubChannel");
    BufferChannel = class {
      constructor(name2, nvim, onDispose) {
        this.name = name2;
        this.nvim = nvim;
        this.onDispose = onDispose;
        this._disposed = false;
        this.lines = [""];
        this.disposables = [];
      }
      get content() {
        return this.lines.join("\n");
      }
      _append(value) {
        let { nvim } = this;
        let idx = this.lines.length - 1;
        let newlines = value.split(/\r?\n/);
        let lastline = this.lines[idx] + newlines[0];
        this.lines[idx] = lastline;
        let append = newlines.slice(1);
        this.lines = this.lines.concat(append);
        nvim.pauseNotification();
        nvim.call("setbufline", [this.bufname, "$", lastline], true);
        if (append.length) {
          nvim.call("appendbufline", [this.bufname, "$", append], true);
        }
        nvim.resumeNotification(false, true);
      }
      append(value) {
        if (!this.validate())
          return;
        this._append(value);
      }
      appendLine(value) {
        if (!this.validate())
          return;
        this._append(value + "\n");
      }
      clear(keep) {
        if (!this.validate())
          return;
        let { nvim } = this;
        this.lines = keep ? this.lines.slice(-keep) : [];
        nvim.pauseNotification();
        nvim.call("deletebufline", [this.bufname, 1, "$"], true);
        if (this.lines.length) {
          nvim.call("appendbufline", [this.bufname, "$", this.lines], true);
        }
        nvim.resumeNotification(false, true);
      }
      hide() {
        this.nvim.command(`exe 'silent! bd! '.fnameescape('${this.bufname}')`, true);
      }
      get bufname() {
        return `output:///${this.name}`;
      }
      show(preserveFocus) {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command(`exe 'vsplit '.fnameescape('${this.bufname}')`, true);
        if (preserveFocus) {
          nvim.command("wincmd p", true);
        }
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      validate() {
        if (this._disposed)
          return false;
        return true;
      }
      dispose() {
        if (this._disposed)
          return;
        if (this.onDispose)
          this.onDispose();
        this._disposed = true;
        this.hide();
        this.lines = [];
        disposeAll(this.disposables);
      }
    };
  }
});

// src/channels.ts
var outputChannels, Channels, channels_default;
var init_channels = __esm({
  "src/channels.ts"() {
    init_outputChannel();
    outputChannels = new Map();
    Channels = class {
      getProvider(nvim) {
        let provider = {
          onDidChange: null,
          provideTextDocumentContent: async (uri) => {
            let channel = this.get(uri.path.slice(1));
            if (!channel)
              return "";
            nvim.pauseNotification();
            nvim.command("setlocal nospell nofoldenable nowrap noswapfile", true);
            nvim.command("setlocal buftype=nofile bufhidden=hide", true);
            nvim.command("setfiletype log", true);
            await nvim.resumeNotification();
            return channel.content;
          }
        };
        return provider;
      }
      get names() {
        return Array.from(outputChannels.keys());
      }
      get(channelName) {
        return outputChannels.get(channelName);
      }
      create(name2, nvim) {
        if (outputChannels.has(name2))
          return outputChannels.get(name2);
        if (!/^[\w\s-.]+$/.test(name2))
          throw new Error(`Invalid channel name "${name2}", only word characters and white space allowed.`);
        let channel = new BufferChannel(name2, nvim, () => {
          outputChannels.delete(name2);
        });
        outputChannels.set(name2, channel);
        return channel;
      }
      show(name2, preserveFocus) {
        let channel = outputChannels.get(name2);
        if (!channel)
          return;
        channel.show(preserveFocus);
      }
      dispose() {
        for (let channel of outputChannels.values()) {
          channel.dispose();
        }
        outputChannels.clear();
      }
    };
    channels_default = new Channels();
  }
});

// src/model/dialog.ts
var logger7, Dialog;
var init_dialog = __esm({
  "src/model/dialog.ts"() {
    init_events();
    init_util();
    logger7 = require_logger2()("model-dialog");
    Dialog = class {
      constructor(nvim, config) {
        this.nvim = nvim;
        this.config = config;
        this.disposables = [];
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this.dispose();
            if (config.callback)
              config.callback(-1);
          }
        }, null, this.disposables);
        events_default.on("FloatBtnClick", (bufnr, idx) => {
          if (bufnr == this.bufnr) {
            this.dispose();
            let btns = config == null ? void 0 : config.buttons.filter((o) => o.disabled != true);
            if (config.callback)
              config.callback(btns[idx].index);
          }
        }, null, this.disposables);
      }
      get lines() {
        return [...this.config.content.split(/\r?\n/)];
      }
      async show(preferences) {
        let { nvim } = this;
        let { title, close, buttons } = this.config;
        let borderhighlight = this.config.borderhighlight || preferences.floatBorderHighlight;
        let highlight = this.config.highlight || preferences.floatHighlight;
        let opts = { maxwidth: preferences.maxWidth || 80 };
        if (title)
          opts.title = title;
        if (close || typeof close === "undefined")
          opts.close = 1;
        if (preferences.maxHeight)
          opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
          opts.maxWidth = preferences.maxWidth;
        if (highlight)
          opts.highlight = highlight;
        if (borderhighlight)
          opts.borderhighlight = [borderhighlight];
        if (buttons)
          opts.buttons = buttons.filter((o) => !o.disabled).map((o) => o.text);
        let res = await nvim.call("coc#float#create_dialog", [this.lines, opts]);
        if (!res[1])
          return;
        this.bufnr = res[1];
        nvim.command("redraw", true);
      }
      get winid() {
        if (!this.bufnr)
          return Promise.resolve(null);
        return this.nvim.call("bufwinid", [this.bufnr]);
      }
      dispose() {
        this.bufnr = void 0;
        disposeAll(this.disposables);
        this.disposables = [];
      }
    };
  }
});

// src/model/popup.ts
var isVim2, Popup;
var init_popup = __esm({
  "src/model/popup.ts"() {
    isVim2 = process.env.VIM_NODE_RPC == "1";
    Popup = class {
      constructor(nvim, winid, bufnr) {
        this.nvim = nvim;
        this.winid = winid;
        this.bufnr = bufnr;
      }
      get valid() {
        return this.nvim.call("coc#float#valid", [this.winid]).then((res) => {
          return !!res;
        });
      }
      close() {
        this.nvim.call("coc#float#close", [this.winid], true);
      }
      refreshScrollbar() {
        if (!isVim2)
          this.nvim.call("coc#float#nvim_scrollbar", [this.winid], true);
      }
      execute(cmd) {
        this.nvim.call("coc#float#execute", [this.winid, cmd], true);
      }
      click(lnum, col) {
        let { nvim } = this;
        nvim.call("win_gotoid", [this.winid], true);
        nvim.call("cursor", [lnum, col], true);
        nvim.call("coc#float#nvim_float_click", [], true);
      }
      async scrollForward() {
        let { nvim, bufnr, winid } = this;
        let buf = nvim.createBuffer(bufnr);
        let total = await buf.length;
        let botline;
        if (!isVim2) {
          let infos = await nvim.call("getwininfo", [winid]);
          if (!infos || !infos.length)
            return;
          botline = infos[0].botline;
        } else {
          botline = await nvim.eval(`get(popup_getpos(${winid}), 'lastline', 0)`);
        }
        if (botline >= total || botline == 0)
          return;
        nvim.pauseNotification();
        this.setCursor(botline - 1);
        this.execute(`normal! ${botline}Gzt`);
        this.refreshScrollbar();
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      async scrollBackward() {
        let { nvim, winid } = this;
        let topline;
        if (!isVim2) {
          let infos = await nvim.call("getwininfo", [winid]);
          if (!infos || !infos.length)
            return;
          topline = infos[0].topline;
        } else {
          topline = await nvim.eval(`get(popup_getpos(${winid}), 'firstline', 0)`);
        }
        if (topline == 1)
          return;
        nvim.pauseNotification();
        this.setCursor(topline - 1);
        this.execute(`normal! ${topline}Gzb`);
        this.refreshScrollbar();
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      setCursor(index) {
        let { nvim, bufnr, winid } = this;
        if (isVim2) {
          nvim.call("win_execute", [winid, `exe ${index + 1}`], true);
        } else {
          let win = nvim.createWindow(winid);
          win.notify("nvim_win_set_cursor", [[index + 1, 0]]);
          nvim.command(`sign unplace 6 buffer=${bufnr}`, true);
          nvim.command(`sign place 6 line=${index + 1} name=CocCurrentLine buffer=${bufnr}`, true);
        }
      }
    };
  }
});

// src/model/menu.ts
var import_vscode_languageserver_protocol4, logger8, Menu;
var init_menu = __esm({
  "src/model/menu.ts"() {
    import_vscode_languageserver_protocol4 = __toModule(require_main2());
    init_events();
    init_util();
    init_popup();
    logger8 = require_logger2()("model-menu");
    Menu = class {
      constructor(nvim, config, token) {
        this.nvim = nvim;
        this.config = config;
        this.currIndex = 0;
        this.disposables = [];
        this.keyMappings = new Map();
        this._onDidClose = new import_vscode_languageserver_protocol4.Emitter();
        this.onDidClose = this._onDidClose.event;
        this.total = config.items.length;
        if (token) {
          token.onCancellationRequested(() => {
            var _a2;
            (_a2 = this.win) == null ? void 0 : _a2.close();
          });
        }
        this.disposables.push(this._onDidClose);
        this.addKeymappings();
      }
      attachEvents() {
        events_default.on("InputChar", this.onInputChar.bind(this), null, this.disposables);
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this._onDidClose.fire(-1);
            this.bufnr = void 0;
            this.win = void 0;
            this.dispose();
          }
        }, null, this.disposables);
      }
      addKeymappings() {
        let { nvim } = this;
        this.addKeys(["<esc>", "<C-c>"], () => {
          this._onDidClose.fire(-1);
          this.dispose();
        });
        this.addKeys(["\r", "<cr>"], () => {
          this._onDidClose.fire(this.currIndex);
          this.dispose();
        });
        let setCursorIndex = (idx) => {
          var _a2;
          if (!this.win)
            return;
          nvim.pauseNotification();
          this.setCursor(idx);
          (_a2 = this.win) == null ? void 0 : _a2.refreshScrollbar();
          nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        };
        this.addKeys("<C-f>", async () => {
          var _a2;
          await ((_a2 = this.win) == null ? void 0 : _a2.scrollForward());
        });
        this.addKeys("<C-b>", async () => {
          var _a2;
          await ((_a2 = this.win) == null ? void 0 : _a2.scrollBackward());
        });
        this.addKeys(["j", "<down>", "<tab>", "<C-n>"], () => {
          let idx = this.currIndex == this.total - 1 ? 0 : this.currIndex + 1;
          setCursorIndex(idx);
        });
        this.addKeys(["k", "<up>", "<s-tab>", "<C-p>"], () => {
          let idx = this.currIndex == 0 ? this.total - 1 : this.currIndex - 1;
          setCursorIndex(idx);
        });
        this.addKeys(["g"], () => {
          setCursorIndex(0);
        });
        this.addKeys(["G"], () => {
          setCursorIndex(this.total - 1);
        });
        let timer;
        let firstNumber;
        this.addKeys(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], (character) => {
          if (timer)
            clearTimeout(timer);
          let n = parseInt(character, 10);
          if (isNaN(n) || n > this.total)
            return;
          if (firstNumber == null && n == 0)
            return;
          if (firstNumber) {
            let count = firstNumber * 10 + n;
            firstNumber = void 0;
            this._onDidClose.fire(count - 1);
            this.dispose();
            return;
          }
          if (this.total < 10 || n * 10 > this.total) {
            this._onDidClose.fire(n - 1);
            this.dispose();
            return;
          }
          timer = setTimeout(async () => {
            this._onDidClose.fire(n - 1);
            this.dispose();
          }, 200);
          firstNumber = n;
        });
      }
      async show(preferences = {}) {
        let { nvim } = this;
        let { title, items } = this.config;
        let opts = {};
        if (title)
          opts.title = title;
        if (preferences.maxHeight)
          opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
          opts.maxWidth = preferences.maxWidth;
        if (preferences.floatHighlight)
          opts.highlight = preferences.floatHighlight;
        if (preferences.floatBorderHighlight)
          opts.borderhighlight = [preferences.floatBorderHighlight];
        let lines = items.map((v, i) => {
          if (i < 99)
            return `${i + 1}. ${v}`;
          return v;
        });
        if (preferences.confirmKey && preferences.confirmKey != "<cr>") {
          this.addKeys(preferences.confirmKey, () => {
            this._onDidClose.fire(this.currIndex);
            this.dispose();
          });
        }
        let res = await nvim.call("coc#float#create_menu", [lines, opts]);
        this.win = new Popup(nvim, res[0], res[1]);
        this.bufnr = res[1];
        this.attachEvents();
        nvim.call("coc#prompt#start_prompt", ["menu"], true);
        return res[0];
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
      }
      dispose() {
        var _a2;
        disposeAll(this.disposables);
        this.disposables = [];
        this.nvim.call("coc#prompt#stop_prompt", ["menu"], true);
        (_a2 = this.win) == null ? void 0 : _a2.close();
        this.win = void 0;
      }
      async onInputChar(session, character) {
        if (session != "menu" || !this.win)
          return;
        let fn = this.keyMappings.get(character);
        if (fn) {
          await Promise.resolve(fn(character));
        } else {
          logger8.warn(`Ignored key press: ${character}`);
        }
      }
      setCursor(index) {
        if (!this.win)
          return;
        this.currIndex = index;
        this.win.setCursor(index);
      }
      addKeys(keys, fn) {
        if (Array.isArray(keys)) {
          for (let key of keys) {
            this.keyMappings.set(key, fn);
          }
        } else {
          this.keyMappings.set(keys, fn);
        }
      }
    };
  }
});

// src/model/notification.ts
var isVim3, logger9, Notification;
var init_notification = __esm({
  "src/model/notification.ts"() {
    init_events();
    init_util();
    isVim3 = process.env.VIM_NODE_RPC == "1";
    logger9 = require_logger2()("model-notification");
    Notification = class {
      constructor(nvim, config, attachEvents = true) {
        this.nvim = nvim;
        this.config = config;
        this.disposables = [];
        this._disposed = false;
        if (attachEvents) {
          events_default.on("BufWinLeave", (bufnr) => {
            if (bufnr == this.bufnr) {
              this.dispose();
              if (config.callback)
                config.callback(-1);
            }
          }, null, this.disposables);
          events_default.on("FloatBtnClick", (bufnr, idx) => {
            if (bufnr == this.bufnr) {
              this.dispose();
              let btns = config == null ? void 0 : config.buttons.filter((o) => o.disabled != true);
              if (config.callback)
                config.callback(btns[idx].index);
            }
          }, null, this.disposables);
        }
      }
      get lines() {
        return this.config.content.split(/\r?\n/);
      }
      async show(preferences) {
        let { nvim } = this;
        let { title, close, timeout, buttons, borderhighlight } = this.config;
        let opts = Object.assign({}, preferences);
        opts.close = close ? 1 : 0;
        if (title)
          opts.title = title;
        if (borderhighlight)
          opts.borderhighlight = borderhighlight;
        if (buttons)
          opts.buttons = buttons.filter((o) => !o.disabled).map((o) => o.text);
        if (timeout)
          opts.timeout = timeout;
        let res = await nvim.call("coc#float#create_notification", [this.lines, opts]);
        if (!res)
          return false;
        if (this._disposed) {
          this.nvim.call("coc#float#close", [res[0]], true);
          if (isVim3)
            this.nvim.command("redraw", true);
        } else {
          this._winid = res[0];
          this.bufnr = res[1];
        }
        return this._winid != void 0;
      }
      get winid() {
        return this._winid;
      }
      dispose() {
        if (this._disposed)
          return;
        this._disposed = true;
        let { winid } = this;
        if (winid) {
          this.nvim.call("coc#float#close", [winid], true);
          if (isVim3)
            this.nvim.command("redraw", true);
        }
        this.bufnr = void 0;
        this._winid = void 0;
        disposeAll(this.disposables);
        this.disposables = [];
      }
    };
  }
});

// src/model/picker.ts
var import_vscode_languageserver_protocol5, logger10, isVim4, Picker;
var init_picker = __esm({
  "src/model/picker.ts"() {
    import_vscode_languageserver_protocol5 = __toModule(require_main2());
    init_events();
    init_util();
    init_string();
    init_popup();
    logger10 = require_logger2()("model-dialog");
    isVim4 = process.env.VIM_NODE_RPC == "1";
    Picker = class {
      constructor(nvim, config, token) {
        this.nvim = nvim;
        this.config = config;
        this.picked = new Set();
        this.currIndex = 0;
        this.disposables = [];
        this.keyMappings = new Map();
        this._onDidClose = new import_vscode_languageserver_protocol5.Emitter();
        this.onDidClose = this._onDidClose.event;
        for (let i = 0; i < config.items.length; i++) {
          let item = config.items[i];
          if (item.picked)
            this.picked.add(i);
        }
        this.total = config.items.length;
        if (token) {
          token.onCancellationRequested(() => {
            var _a2;
            (_a2 = this.win) == null ? void 0 : _a2.close();
          });
        }
        this.disposables.push(this._onDidClose);
        this.addKeymappings();
      }
      attachEvents() {
        events_default.on("InputChar", this.onInputChar.bind(this), null, this.disposables);
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this._onDidClose.fire(void 0);
            this.bufnr = void 0;
            this.win = void 0;
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("FloatBtnClick", (bufnr, idx) => {
          if (bufnr == this.bufnr) {
            if (idx == 0) {
              let selected = Array.from(this.picked);
              this._onDidClose.fire(selected.length ? selected : void 0);
            } else {
              this._onDidClose.fire(void 0);
            }
            this.dispose();
          }
        }, null, this.disposables);
      }
      addKeymappings() {
        let { nvim } = this;
        const toggleSelect = (idx) => {
          if (this.picked.has(idx)) {
            this.picked.delete(idx);
          } else {
            this.picked.add(idx);
          }
        };
        this.addKeys("<LeftRelease>", async () => {
          if (isVim4 || !this.win)
            return;
          let [winid, lnum, col] = await nvim.eval("[v:mouse_winid,v:mouse_lnum,v:mouse_col]");
          if (global.hasOwnProperty("__TEST__")) {
            let res = await nvim.getVar("mouse_position");
            winid = res[0];
            lnum = res[1];
            col = res[2];
          }
          nvim.pauseNotification();
          if (winid == this.win.winid) {
            if (col <= 3) {
              toggleSelect(lnum - 1);
              this.changeLine(lnum - 1);
            } else {
              this.setCursor(lnum - 1);
            }
          }
          nvim.call("win_gotoid", [winid], true);
          nvim.call("cursor", [lnum, col], true);
          nvim.call("coc#float#nvim_float_click", [], true);
          nvim.command("redraw", true);
          await nvim.resumeNotification();
        });
        this.addKeys(["<esc>", "<C-c>"], () => {
          this._onDidClose.fire(void 0);
          this.dispose();
        });
        this.addKeys("<cr>", () => {
          if (this.picked.size == 0) {
            this._onDidClose.fire(void 0);
          } else {
            let selected = Array.from(this.picked);
            this._onDidClose.fire(selected);
          }
          this.dispose();
        });
        let setCursorIndex = (idx) => {
          nvim.pauseNotification();
          this.setCursor(idx);
          this.win.refreshScrollbar();
          nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        };
        this.addKeys(["j", "<down>", "<tab>", "<C-n>"], () => {
          let idx = this.currIndex == this.total - 1 ? 0 : this.currIndex + 1;
          setCursorIndex(idx);
        });
        this.addKeys(["k", "<up>", "<s-tab>", "<C-p>"], () => {
          let idx = this.currIndex == 0 ? this.total - 1 : this.currIndex - 1;
          setCursorIndex(idx);
        });
        this.addKeys(["g"], () => {
          setCursorIndex(0);
        });
        this.addKeys(["G"], () => {
          setCursorIndex(this.total - 1);
        });
        this.addKeys(" ", async () => {
          let idx = this.currIndex;
          toggleSelect(idx);
          nvim.pauseNotification();
          this.changeLine(idx);
          if (this.currIndex != this.total - 1) {
            this.setCursor(this.currIndex + 1);
          }
          nvim.command("redraw", true);
          await nvim.resumeNotification();
        });
        this.addKeys("<C-f>", async () => {
          var _a2;
          await ((_a2 = this.win) == null ? void 0 : _a2.scrollForward());
        });
        this.addKeys("<C-b>", async () => {
          var _a2;
          await ((_a2 = this.win) == null ? void 0 : _a2.scrollBackward());
        });
      }
      async show(preferences = {}) {
        let { nvim } = this;
        let { title, items } = this.config;
        let opts = { close: 1, cursorline: 1 };
        if (preferences.maxHeight)
          opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
          opts.maxWidth = preferences.maxWidth;
        if (title)
          opts.title = title;
        opts.close = 1;
        opts.cursorline = 1;
        if (preferences.floatHighlight) {
          opts.highlight = preferences.floatHighlight;
        }
        if (preferences.floatBorderHighlight) {
          opts.borderhighlight = [preferences.floatBorderHighlight];
        }
        if (preferences.pickerButtons) {
          let shortcut = preferences.pickerButtonShortcut;
          opts.buttons = ["Submit" + (shortcut ? " <cr>" : ""), "Cancel" + (shortcut ? " <esc>" : "")];
        }
        if (preferences.confirmKey && preferences.confirmKey != "<cr>") {
          this.addKeys(preferences.confirmKey, () => {
            this._onDidClose.fire(void 0);
            this.dispose();
          });
        }
        let lines = [];
        let positions2 = [];
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          let line = `[${item.picked ? "x" : " "}] ${item.label}`;
          positions2.push([i, byteLength(line)]);
          if (item.description)
            line = line + ` ${item.description}`;
          lines.push(line);
        }
        let res = await nvim.call("coc#float#create_dialog", [lines, opts]);
        this.win = new Popup(nvim, res[0], res[1]);
        this.bufnr = res[1];
        this.attachEvents();
        let buf = nvim.createBuffer(this.bufnr);
        nvim.pauseNotification();
        for (let pos of positions2) {
          buf.addHighlight({ hlGroup: "Comment", line: pos[0], srcId: 1, colStart: pos[1], colEnd: -1 });
        }
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
        nvim.call("coc#prompt#start_prompt", ["picker"], true);
        return res[0];
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
      }
      dispose() {
        var _a2;
        disposeAll(this.disposables);
        this.disposables = [];
        this.nvim.call("coc#prompt#stop_prompt", ["picker"], true);
        (_a2 = this.win) == null ? void 0 : _a2.close();
        this.win = void 0;
      }
      async onInputChar(session, character) {
        if (session != "picker" || !this.win)
          return;
        let fn = this.keyMappings.get(character);
        if (fn) {
          await Promise.resolve(fn(character));
        } else {
          logger10.warn(`Ignored key press: ${character}`);
        }
      }
      changeLine(index) {
        let { nvim } = this;
        let item = this.config.items[index];
        if (!item)
          return;
        let line = `[${this.picked.has(index) ? "x" : " "}] ${item.label}`;
        let col = byteLength(line);
        if (item.description)
          line = line + ` ${item.description}`;
        nvim.call("setbufline", [this.bufnr, index + 1, line], true);
        if (!isVim4) {
          let buf = nvim.createBuffer(this.bufnr);
          buf.addHighlight({ hlGroup: "Comment", line: index, srcId: 1, colStart: col, colEnd: -1 });
        }
      }
      setCursor(index) {
        if (!this.win)
          return;
        this.currIndex = index;
        this.win.setCursor(index);
      }
      addKeys(keys, fn) {
        if (Array.isArray(keys)) {
          for (let key of keys) {
            this.keyMappings.set(key, fn);
          }
        } else {
          this.keyMappings.set(keys, fn);
        }
      }
    };
  }
});

// src/model/progress.ts
var import_vscode_languageserver_protocol6, ProgressNotification;
var init_progress = __esm({
  "src/model/progress.ts"() {
    init_notification();
    import_vscode_languageserver_protocol6 = __toModule(require_main2());
    init_events();
    ProgressNotification = class extends Notification {
      constructor(nvim, option) {
        super(nvim, {
          content: "\n",
          close: option.cancellable == true,
          title: option.title
        }, false);
        this.option = option;
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            if (this.tokenSource) {
              this.tokenSource.cancel();
            }
            this.dispose();
          }
        }, null, this.disposables);
      }
      async show(preferences) {
        let { task } = this.option;
        let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol6.CancellationTokenSource();
        this.disposables.push(tokenSource);
        let total = 0;
        let res = await new Promise((resolve3, reject) => {
          tokenSource.token.onCancellationRequested(() => {
            resolve3(void 0);
          });
          super.show(Object.assign({ minWidth: preferences.minProgressWidth || 30, progress: 1 }, preferences)).then((shown) => {
            if (!shown)
              reject(new Error("Failed to create float window"));
          }).catch(reject);
          task({
            report: (p) => {
              if (!this.bufnr)
                return;
              let text = "";
              if (p.message)
                text += p.message.replace(/\r?\n/g, " ");
              if (p.increment) {
                total += p.increment;
                text = text + (text.length ? ` ${total}%` : `${total}%`);
              }
              this.nvim.call("setbufline", [this.bufnr, 2, text], true);
            }
          }, tokenSource.token).then((res2) => {
            if (this._disposed)
              return;
            setTimeout(() => {
              this.dispose();
            }, 100);
            resolve3(res2);
          }, (err) => {
            if (this._disposed)
              return;
            this.dispose();
            if (err instanceof Error) {
              reject(err);
            } else {
              resolve3(void 0);
            }
          });
        });
        return res;
      }
      dispose() {
        super.dispose();
        this.tokenSource = void 0;
      }
    };
  }
});

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  return import_crypto.default.randomBytes(16);
}
var import_crypto;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    import_crypto = __toModule(require("crypto"));
  }
});

// node_modules/uuid/dist/esm-node/bytesToUuid.js
function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join("");
}
var byteToHex, bytesToUuid_default;
var init_bytesToUuid = __esm({
  "node_modules/uuid/dist/esm-node/bytesToUuid.js"() {
    byteToHex = [];
    for (var i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    bytesToUuid_default = bytesToUuid;
  }
});

// node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf ? buf : bytesToUuid_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_bytesToUuid();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  var i = buf && offset || 0;
  if (typeof options == "string") {
    buf = options === "binary" ? new Array(16) : null;
    options = null;
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }
  return buf || bytesToUuid_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    init_rng();
    init_bytesToUuid();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-node/index.js
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    init_v1();
    init_v4();
  }
});

// src/model/status.ts
var logger11, frames, StatusLine;
var init_status = __esm({
  "src/model/status.ts"() {
    init_esm_node();
    logger11 = require_logger2()("model-status");
    frames = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
    StatusLine = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.items = new Map();
        this.shownIds = new Set();
        this._text = "";
        this.interval = setInterval(() => {
          this.setStatusText().logError();
        }, 100);
      }
      dispose() {
        clearInterval(this.interval);
      }
      createStatusBarItem(priority = 0, isProgress = false) {
        let uid = v1_default();
        let item = {
          text: "",
          priority,
          isProgress,
          show: () => {
            this.shownIds.add(uid);
          },
          hide: () => {
            this.shownIds.delete(uid);
          },
          dispose: () => {
            this.shownIds.delete(uid);
            this.items.delete(uid);
          }
        };
        this.items.set(uid, item);
        return item;
      }
      getText() {
        if (this.shownIds.size == 0)
          return "";
        let d = new Date();
        let idx = Math.floor(d.getMilliseconds() / 100);
        let text = "";
        let items = [];
        for (let [id, item] of this.items) {
          if (this.shownIds.has(id)) {
            items.push(item);
          }
        }
        items.sort((a, b) => a.priority - b.priority);
        for (let item of items) {
          if (!item.isProgress) {
            text = `${text} ${item.text}`;
          } else {
            text = `${text} ${frames[idx]} ${item.text}`;
          }
        }
        return text;
      }
      async setStatusText() {
        let text = this.getText();
        let { nvim } = this;
        if (text != this._text) {
          this._text = text;
          nvim.pauseNotification();
          this.nvim.setVar("coc_status", text, true);
          this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
          await nvim.resumeNotification(false, true);
        }
      }
    };
  }
});

// src/types.ts
var PatternType, ExtensionType, SourceType, MessageLevel, ConfigurationTarget, ServiceStat;
var init_types = __esm({
  "src/types.ts"() {
    (function(PatternType2) {
      PatternType2[PatternType2["Buffer"] = 0] = "Buffer";
      PatternType2[PatternType2["LanguageServer"] = 1] = "LanguageServer";
      PatternType2[PatternType2["Global"] = 2] = "Global";
    })(PatternType || (PatternType = {}));
    (function(ExtensionType2) {
      ExtensionType2[ExtensionType2["Global"] = 0] = "Global";
      ExtensionType2[ExtensionType2["Local"] = 1] = "Local";
      ExtensionType2[ExtensionType2["SingleFile"] = 2] = "SingleFile";
      ExtensionType2[ExtensionType2["Internal"] = 3] = "Internal";
    })(ExtensionType || (ExtensionType = {}));
    (function(SourceType2) {
      SourceType2[SourceType2["Native"] = 0] = "Native";
      SourceType2[SourceType2["Remote"] = 1] = "Remote";
      SourceType2[SourceType2["Service"] = 2] = "Service";
    })(SourceType || (SourceType = {}));
    (function(MessageLevel2) {
      MessageLevel2[MessageLevel2["More"] = 0] = "More";
      MessageLevel2[MessageLevel2["Warning"] = 1] = "Warning";
      MessageLevel2[MessageLevel2["Error"] = 2] = "Error";
    })(MessageLevel || (MessageLevel = {}));
    (function(ConfigurationTarget3) {
      ConfigurationTarget3[ConfigurationTarget3["Global"] = 0] = "Global";
      ConfigurationTarget3[ConfigurationTarget3["User"] = 1] = "User";
      ConfigurationTarget3[ConfigurationTarget3["Workspace"] = 2] = "Workspace";
    })(ConfigurationTarget || (ConfigurationTarget = {}));
    (function(ServiceStat2) {
      ServiceStat2[ServiceStat2["Initial"] = 0] = "Initial";
      ServiceStat2[ServiceStat2["Starting"] = 1] = "Starting";
      ServiceStat2[ServiceStat2["StartFailed"] = 2] = "StartFailed";
      ServiceStat2[ServiceStat2["Running"] = 3] = "Running";
      ServiceStat2[ServiceStat2["Stopping"] = 4] = "Stopping";
      ServiceStat2[ServiceStat2["Stopped"] = 5] = "Stopped";
    })(ServiceStat || (ServiceStat = {}));
  }
});

// node_modules/bytes/index.js
var require_bytes = __commonJS({
  "node_modules/bytes/index.js"(exports2, module2) {
    "use strict";
    module2.exports = bytes2;
    module2.exports.format = format2;
    module2.exports.parse = parse5;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes2(value, options) {
      if (typeof value === "string") {
        return parse5(value);
      }
      if (typeof value === "number") {
        return format2(value, options);
      }
      return null;
    }
    function format2(value, options) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.pb) {
          unit = "PB";
        } else if (mag >= map.tb) {
          unit = "TB";
        } else if (mag >= map.gb) {
          unit = "GB";
        } else if (mag >= map.mb) {
          unit = "MB";
        } else if (mag >= map.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.replace(formatThousandsRegExp, thousandsSeparator);
      }
      return str + unitSeparator + unit;
    }
    function parse5(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      return Math.floor(map[unit] * floatValue);
    }
  }
});

// node_modules/fast-diff/diff.js
var require_diff2 = __commonJS({
  "node_modules/fast-diff/diff.js"(exports2, module2) {
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    function diff_main(text1, text2, cursor_pos, _fix_unicode) {
      if (text1 === text2) {
        if (text1) {
          return [[DIFF_EQUAL, text1]];
        }
        return [];
      }
      if (cursor_pos != null) {
        var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
        if (editdiff) {
          return editdiff;
        }
      }
      var commonlength = diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = diff_compute_(text1, text2);
      if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
      }
      if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
      }
      diff_cleanupMerge(diffs, _fix_unicode);
      return diffs;
    }
    function diff_compute_(text1, text2) {
      var diffs;
      if (!text1) {
        return [[DIFF_INSERT, text2]];
      }
      if (!text2) {
        return [[DIFF_DELETE, text1]];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i !== -1) {
        diffs = [
          [DIFF_INSERT, longtext.substring(0, i)],
          [DIFF_EQUAL, shorttext],
          [DIFF_INSERT, longtext.substring(i + shorttext.length)]
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length === 1) {
        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
      }
      var hm = diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = diff_main(text1_a, text2_a);
        var diffs_b = diff_main(text1_b, text2_b);
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
      }
      return diff_bisect_(text1, text2);
    }
    function diff_bisect_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v12 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v12[x] = -1;
        v2[x] = -1;
      }
      v12[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 !== 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 === -d || k1 !== d && v12[k1_offset - 1] < v12[k1_offset + 1]) {
            x1 = v12[k1_offset + 1];
          } else {
            x1 = v12[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v12[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v12[k1_offset] !== -1) {
              var x1 = v12[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
      }
      return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
    }
    function diff_bisectSplit_(text1, text2, x, y) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = diff_main(text1a, text2a);
      var diffsb = diff_main(text1b, text2b);
      return diffs.concat(diffsb);
    }
    function diff_commonPrefix(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_commonSuffix(text1, text2) {
      if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_halfMatch_(text1, text2) {
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
          var prefixLength = diff_commonPrefix(longtext2.substring(i), shorttext2.substring(j));
          var suffixLength = diff_commonSuffix(longtext2.substring(0, i), shorttext2.substring(0, j));
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
      var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    }
    function diff_cleanupMerge(diffs, fix_unicode) {
      diffs.push([DIFF_EQUAL, ""]);
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
          diffs.splice(pointer, 1);
          continue;
        }
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            var previous_equality = pointer - count_insert - count_delete - 1;
            if (fix_unicode) {
              if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                var stray = diffs[previous_equality][1].slice(-1);
                diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);
                text_delete = stray + text_delete;
                text_insert = stray + text_insert;
                if (!diffs[previous_equality][1]) {
                  diffs.splice(previous_equality, 1);
                  pointer--;
                  var k = previous_equality - 1;
                  if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                    count_insert++;
                    text_insert = diffs[k][1] + text_insert;
                    k--;
                  }
                  if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                    count_delete++;
                    text_delete = diffs[k][1] + text_delete;
                    k--;
                  }
                  previous_equality = k;
                }
              }
              if (starts_with_pair_end(diffs[pointer][1])) {
                var stray = diffs[pointer][1].charAt(0);
                diffs[pointer][1] = diffs[pointer][1].slice(1);
                text_delete += stray;
                text_insert += stray;
              }
            }
            if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
              diffs.splice(pointer, 1);
              break;
            }
            if (text_delete.length > 0 || text_insert.length > 0) {
              if (text_delete.length > 0 && text_insert.length > 0) {
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (previous_equality >= 0) {
                    diffs[previous_equality][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length - commonlength);
                  text_delete = text_delete.substring(0, text_delete.length - commonlength);
                }
              }
              var n = count_insert + count_delete;
              if (text_delete.length === 0 && text_insert.length === 0) {
                diffs.splice(pointer - n, n);
                pointer = pointer - n;
              } else if (text_delete.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 1;
              } else if (text_insert.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
                pointer = pointer - n + 1;
              } else {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 2;
              }
            }
            if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
          if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs, fix_unicode);
      }
    }
    function is_surrogate_pair_start(charCode) {
      return charCode >= 55296 && charCode <= 56319;
    }
    function is_surrogate_pair_end(charCode) {
      return charCode >= 56320 && charCode <= 57343;
    }
    function starts_with_pair_end(str) {
      return is_surrogate_pair_end(str.charCodeAt(0));
    }
    function ends_with_pair_start(str) {
      return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
    }
    function remove_empty_tuples(tuples) {
      var ret = [];
      for (var i = 0; i < tuples.length; i++) {
        if (tuples[i][1].length > 0) {
          ret.push(tuples[i]);
        }
      }
      return ret;
    }
    function make_edit_splice(before, oldMiddle, newMiddle, after) {
      if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
        return null;
      }
      return remove_empty_tuples([
        [DIFF_EQUAL, before],
        [DIFF_DELETE, oldMiddle],
        [DIFF_INSERT, newMiddle],
        [DIFF_EQUAL, after]
      ]);
    }
    function find_cursor_edit_diff(oldText, newText, cursor_pos) {
      var oldRange = typeof cursor_pos === "number" ? { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
      var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
      var oldLength = oldText.length;
      var newLength = newText.length;
      if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
        var oldCursor = oldRange.index;
        var oldBefore = oldText.slice(0, oldCursor);
        var oldAfter = oldText.slice(oldCursor);
        var maybeNewCursor = newRange ? newRange.index : null;
        editBefore: {
          var newCursor = oldCursor + newLength - oldLength;
          if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
            break editBefore;
          }
          if (newCursor < 0 || newCursor > newLength) {
            break editBefore;
          }
          var newBefore = newText.slice(0, newCursor);
          var newAfter = newText.slice(newCursor);
          if (newAfter !== oldAfter) {
            break editBefore;
          }
          var prefixLength = Math.min(oldCursor, newCursor);
          var oldPrefix = oldBefore.slice(0, prefixLength);
          var newPrefix = newBefore.slice(0, prefixLength);
          if (oldPrefix !== newPrefix) {
            break editBefore;
          }
          var oldMiddle = oldBefore.slice(prefixLength);
          var newMiddle = newBefore.slice(prefixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
        }
        editAfter: {
          if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
            break editAfter;
          }
          var cursor = oldCursor;
          var newBefore = newText.slice(0, cursor);
          var newAfter = newText.slice(cursor);
          if (newBefore !== oldBefore) {
            break editAfter;
          }
          var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
          var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
          var newSuffix = newAfter.slice(newAfter.length - suffixLength);
          if (oldSuffix !== newSuffix) {
            break editAfter;
          }
          var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
          var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
          return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
        }
      }
      if (oldRange.length > 0 && newRange && newRange.length === 0) {
        replaceRange: {
          var oldPrefix = oldText.slice(0, oldRange.index);
          var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
          var prefixLength = oldPrefix.length;
          var suffixLength = oldSuffix.length;
          if (newLength < prefixLength + suffixLength) {
            break replaceRange;
          }
          var newPrefix = newText.slice(0, prefixLength);
          var newSuffix = newText.slice(newLength - suffixLength);
          if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
            break replaceRange;
          }
          var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
          var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
        }
      }
      return null;
    }
    function diff(text1, text2, cursor_pos) {
      return diff_main(text1, text2, cursor_pos, true);
    }
    diff.INSERT = DIFF_INSERT;
    diff.DELETE = DIFF_DELETE;
    diff.EQUAL = DIFF_EQUAL;
    module2.exports = diff;
  }
});

// node_modules/vscode-languageserver-textdocument/lib/esm/main.js
function mergeSort(data, compare) {
  if (data.length <= 1) {
    return data;
  }
  var p = data.length / 2 | 0;
  var left = data.slice(0, p);
  var right = data.slice(p);
  mergeSort(left, compare);
  mergeSort(right, compare);
  var leftIdx = 0;
  var rightIdx = 0;
  var i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    var ret = compare(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset) {
  if (textOffset === void 0) {
    textOffset = 0;
  }
  var result = isAtLineStart ? [textOffset] : [];
  for (var i = 0; i < text.length; i++) {
    var ch = text.charCodeAt(i);
    if (ch === 13 || ch === 10) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function getWellformedRange(range) {
  var start = range.start;
  var end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  var range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}
var FullTextDocument2, TextDocument2;
var init_main2 = __esm({
  "node_modules/vscode-languageserver-textdocument/lib/esm/main.js"() {
    "use strict";
    FullTextDocument2 = function() {
      function FullTextDocument3(uri, languageId, version2, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version2;
        this._content = content;
        this._lineOffsets = void 0;
      }
      Object.defineProperty(FullTextDocument3.prototype, "uri", {
        get: function() {
          return this._uri;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "version", {
        get: function() {
          return this._version;
        },
        enumerable: true,
        configurable: true
      });
      FullTextDocument3.prototype.getText = function(range) {
        if (range) {
          var start = this.offsetAt(range.start);
          var end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      };
      FullTextDocument3.prototype.update = function(changes, version2) {
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
          var change = changes_1[_i];
          if (FullTextDocument3.isIncremental(change)) {
            var range = getWellformedRange(change.range);
            var startOffset = this.offsetAt(range.start);
            var endOffset = this.offsetAt(range.end);
            this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
            var startLine = Math.max(range.start.line, 0);
            var endLine = Math.max(range.end.line, 0);
            var lineOffsets = this._lineOffsets;
            var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
            if (endLine - startLine === addedLineOffsets.length) {
              for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
                lineOffsets[i + startLine + 1] = addedLineOffsets[i];
              }
            } else {
              if (addedLineOffsets.length < 1e4) {
                lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));
              } else {
                this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
              }
            }
            var diff = change.text.length - (endOffset - startOffset);
            if (diff !== 0) {
              for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                lineOffsets[i] = lineOffsets[i] + diff;
              }
            }
          } else if (FullTextDocument3.isFull(change)) {
            this._content = change.text;
            this._lineOffsets = void 0;
          } else {
            throw new Error("Unknown change event received");
          }
        }
        this._version = version2;
      };
      FullTextDocument3.prototype.getLineOffsets = function() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
      };
      FullTextDocument3.prototype.positionAt = function(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        var line = low - 1;
        return { line, character: offset - lineOffsets[line] };
      };
      FullTextDocument3.prototype.offsetAt = function(position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      };
      Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
        get: function() {
          return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
      });
      FullTextDocument3.isIncremental = function(event) {
        var candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      };
      FullTextDocument3.isFull = function(event) {
        var candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      };
      return FullTextDocument3;
    }();
    (function(TextDocument4) {
      function create(uri, languageId, version2, content) {
        return new FullTextDocument2(uri, languageId, version2, content);
      }
      TextDocument4.create = create;
      function update(document2, changes, version2) {
        if (document2 instanceof FullTextDocument2) {
          document2.update(changes, version2);
          return document2;
        } else {
          throw new Error("TextDocument.update: document must be created by TextDocument.create");
        }
      }
      TextDocument4.update = update;
      function applyEdits2(document2, edits) {
        var text = document2.getText();
        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a, b) {
          var diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        var lastModifiedOffset = 0;
        var spans = [];
        for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {
          var e = sortedEdits_1[_i];
          var startOffset = document2.offsetAt(e.range.start);
          if (startOffset < lastModifiedOffset) {
            throw new Error("Overlapping edit");
          } else if (startOffset > lastModifiedOffset) {
            spans.push(text.substring(lastModifiedOffset, startOffset));
          }
          if (e.newText.length) {
            spans.push(e.newText);
          }
          lastModifiedOffset = document2.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join("");
      }
      TextDocument4.applyEdits = applyEdits2;
    })(TextDocument2 || (TextDocument2 = {}));
  }
});

// node_modules/jsonc-parser/lib/esm/impl/scanner.js
function createScanner(text, ignoreTrivia) {
  if (ignoreTrivia === void 0) {
    ignoreTrivia = false;
  }
  var len = text.length;
  var pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
  function scanHexDigits(count, exact) {
    var digits = 0;
    var value2 = 0;
    while (digits < count || !exact) {
      var ch = text.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        value2 = value2 * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        value2 = value2 * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        value2 = value2 * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count) {
      value2 = -1;
    }
    return value2;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token = 16;
    scanError = 0;
  }
  function scanNumber() {
    var start = pos;
    if (text.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text.length && text.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text.substring(start, pos);
      }
    }
    var end = pos;
    if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
        end = pos;
      } else {
        scanError = 3;
      }
    }
    return text.substring(start, end);
  }
  function scanString() {
    var result = "", start = pos;
    while (true) {
      if (pos >= len) {
        result += text.substring(start, pos);
        scanError = 2;
        break;
      }
      var ch = text.charCodeAt(pos);
      if (ch === 34) {
        result += text.substring(start, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text.substring(start, pos);
        pos++;
        if (pos >= len) {
          scanError = 2;
          break;
        }
        var ch2 = text.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117:
            var ch3 = scanHexDigits(4, true);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          default:
            scanError = 5;
        }
        start = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text.substring(start, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    lineStartOffset = lineNumber;
    prevTokenLineStartOffset = tokenLineStartOffset;
    if (pos >= len) {
      tokenOffset = len;
      return token = 17;
    }
    var code = text.charCodeAt(pos);
    if (isWhiteSpace(code)) {
      do {
        pos++;
        value += String.fromCharCode(code);
        code = text.charCodeAt(pos);
      } while (isWhiteSpace(code));
      return token = 15;
    }
    if (isLineBreak(code)) {
      pos++;
      value += String.fromCharCode(code);
      if (code === 13 && text.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      lineNumber++;
      tokenLineStartOffset = pos;
      return token = 14;
    }
    switch (code) {
      case 123:
        pos++;
        return token = 1;
      case 125:
        pos++;
        return token = 2;
      case 91:
        pos++;
        return token = 3;
      case 93:
        pos++;
        return token = 4;
      case 58:
        pos++;
        return token = 6;
      case 44:
        pos++;
        return token = 5;
      case 34:
        pos++;
        value = scanString();
        return token = 10;
      case 47:
        var start = pos - 1;
        if (text.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len) {
            if (isLineBreak(text.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text.substring(start, pos);
          return token = 12;
        }
        if (text.charCodeAt(pos + 1) === 42) {
          pos += 2;
          var safeLength = len - 1;
          var commentClosed = false;
          while (pos < safeLength) {
            var ch = text.charCodeAt(pos);
            if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
            if (isLineBreak(ch)) {
              if (ch === 13 && text.charCodeAt(pos) === 10) {
                pos++;
              }
              lineNumber++;
              tokenLineStartOffset = pos;
            }
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text.substring(start, pos);
          return token = 13;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
      case 45:
        value += String.fromCharCode(code);
        pos++;
        if (pos === len || !isDigit(text.charCodeAt(pos))) {
          return token = 16;
        }
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token = 11;
      default:
        while (pos < len && isUnknownContentCharacter(code)) {
          pos++;
          code = text.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token = 8;
            case "false":
              return token = 9;
            case "null":
              return token = 7;
          }
          return token = 16;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
    }
  }
  function isUnknownContentCharacter(code) {
    if (isWhiteSpace(code) || isLineBreak(code)) {
      return false;
    }
    switch (code) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    var result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: function() {
      return pos;
    },
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: function() {
      return token;
    },
    getTokenValue: function() {
      return value;
    },
    getTokenOffset: function() {
      return tokenOffset;
    },
    getTokenLength: function() {
      return pos - tokenOffset;
    },
    getTokenStartLine: function() {
      return lineStartOffset;
    },
    getTokenStartCharacter: function() {
      return tokenOffset - prevTokenLineStartOffset;
    },
    getTokenError: function() {
      return scanError;
    }
  };
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch === 5760 || ch >= 8192 && ch <= 8203 || ch === 8239 || ch === 8287 || ch === 12288 || ch === 65279;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
var init_scanner = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/scanner.js"() {
    "use strict";
  }
});

// node_modules/jsonc-parser/lib/esm/impl/format.js
function format(documentText, range, options) {
  var initialIndentLevel;
  var formatText;
  var formatTextStart;
  var rangeStart;
  var rangeEnd;
  if (range) {
    rangeStart = range.offset;
    rangeEnd = rangeStart + range.length;
    formatTextStart = rangeStart;
    while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {
      formatTextStart--;
    }
    var endOffset = rangeEnd;
    while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {
      endOffset++;
    }
    formatText = documentText.substring(formatTextStart, endOffset);
    initialIndentLevel = computeIndentLevel(formatText, options);
  } else {
    formatText = documentText;
    initialIndentLevel = 0;
    formatTextStart = 0;
    rangeStart = 0;
    rangeEnd = documentText.length;
  }
  var eol = getEOL(options, documentText);
  var lineBreak = false;
  var indentLevel = 0;
  var indentValue;
  if (options.insertSpaces) {
    indentValue = repeat(" ", options.tabSize || 4);
  } else {
    indentValue = "	";
  }
  var scanner2 = createScanner(formatText, false);
  var hasError = false;
  function newLineAndIndent() {
    return eol + repeat(indentValue, initialIndentLevel + indentLevel);
  }
  function scanNext() {
    var token = scanner2.scan();
    lineBreak = false;
    while (token === 15 || token === 14) {
      lineBreak = lineBreak || token === 14;
      token = scanner2.scan();
    }
    hasError = token === 16 || scanner2.getTokenError() !== 0;
    return token;
  }
  var editOperations = [];
  function addEdit(text, startOffset, endOffset2) {
    if (!hasError && startOffset < rangeEnd && endOffset2 > rangeStart && documentText.substring(startOffset, endOffset2) !== text) {
      editOperations.push({ offset: startOffset, length: endOffset2 - startOffset, content: text });
    }
  }
  var firstToken = scanNext();
  if (firstToken !== 17) {
    var firstTokenStart = scanner2.getTokenOffset() + formatTextStart;
    var initialIndent = repeat(indentValue, initialIndentLevel);
    addEdit(initialIndent, formatTextStart, firstTokenStart);
  }
  while (firstToken !== 17) {
    var firstTokenEnd = scanner2.getTokenOffset() + scanner2.getTokenLength() + formatTextStart;
    var secondToken = scanNext();
    var replaceContent = "";
    while (!lineBreak && (secondToken === 12 || secondToken === 13)) {
      var commentTokenStart = scanner2.getTokenOffset() + formatTextStart;
      addEdit(" ", firstTokenEnd, commentTokenStart);
      firstTokenEnd = scanner2.getTokenOffset() + scanner2.getTokenLength() + formatTextStart;
      replaceContent = secondToken === 12 ? newLineAndIndent() : "";
      secondToken = scanNext();
    }
    if (secondToken === 2) {
      if (firstToken !== 1) {
        indentLevel--;
        replaceContent = newLineAndIndent();
      }
    } else if (secondToken === 4) {
      if (firstToken !== 3) {
        indentLevel--;
        replaceContent = newLineAndIndent();
      }
    } else {
      switch (firstToken) {
        case 3:
        case 1:
          indentLevel++;
          replaceContent = newLineAndIndent();
          break;
        case 5:
        case 12:
          replaceContent = newLineAndIndent();
          break;
        case 13:
          if (lineBreak) {
            replaceContent = newLineAndIndent();
          } else {
            replaceContent = " ";
          }
          break;
        case 6:
          replaceContent = " ";
          break;
        case 10:
          if (secondToken === 6) {
            replaceContent = "";
            break;
          }
        case 7:
        case 8:
        case 9:
        case 11:
        case 2:
        case 4:
          if (secondToken === 12 || secondToken === 13) {
            replaceContent = " ";
          } else if (secondToken !== 5 && secondToken !== 17) {
            hasError = true;
          }
          break;
        case 16:
          hasError = true;
          break;
      }
      if (lineBreak && (secondToken === 12 || secondToken === 13)) {
        replaceContent = newLineAndIndent();
      }
    }
    var secondTokenStart = scanner2.getTokenOffset() + formatTextStart;
    addEdit(replaceContent, firstTokenEnd, secondTokenStart);
    firstToken = secondToken;
  }
  return editOperations;
}
function repeat(s, count) {
  var result = "";
  for (var i = 0; i < count; i++) {
    result += s;
  }
  return result;
}
function computeIndentLevel(content, options) {
  var i = 0;
  var nChars = 0;
  var tabSize = options.tabSize || 4;
  while (i < content.length) {
    var ch = content.charAt(i);
    if (ch === " ") {
      nChars++;
    } else if (ch === "	") {
      nChars += tabSize;
    } else {
      break;
    }
    i++;
  }
  return Math.floor(nChars / tabSize);
}
function getEOL(options, text) {
  for (var i = 0; i < text.length; i++) {
    var ch = text.charAt(i);
    if (ch === "\r") {
      if (i + 1 < text.length && text.charAt(i + 1) === "\n") {
        return "\r\n";
      }
      return "\r";
    } else if (ch === "\n") {
      return "\n";
    }
  }
  return options && options.eol || "\n";
}
function isEOL(text, offset) {
  return "\r\n".indexOf(text.charAt(offset)) !== -1;
}
var init_format = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/format.js"() {
    init_scanner();
    "use strict";
  }
});

// node_modules/jsonc-parser/lib/esm/impl/parser.js
function parse2(text, errors, options) {
  if (errors === void 0) {
    errors = [];
  }
  if (options === void 0) {
    options = ParseOptions.DEFAULT;
  }
  var currentProperty = null;
  var currentParent = [];
  var previousParents = [];
  function onValue(value) {
    if (Array.isArray(currentParent)) {
      currentParent.push(value);
    } else if (currentProperty !== null) {
      currentParent[currentProperty] = value;
    }
  }
  var visitor = {
    onObjectBegin: function() {
      var object = {};
      onValue(object);
      previousParents.push(currentParent);
      currentParent = object;
      currentProperty = null;
    },
    onObjectProperty: function(name2) {
      currentProperty = name2;
    },
    onObjectEnd: function() {
      currentParent = previousParents.pop();
    },
    onArrayBegin: function() {
      var array = [];
      onValue(array);
      previousParents.push(currentParent);
      currentParent = array;
      currentProperty = null;
    },
    onArrayEnd: function() {
      currentParent = previousParents.pop();
    },
    onLiteralValue: onValue,
    onError: function(error, offset, length) {
      errors.push({ error, offset, length });
    }
  };
  visit(text, visitor, options);
  return currentParent[0];
}
function parseTree(text, errors, options) {
  if (errors === void 0) {
    errors = [];
  }
  if (options === void 0) {
    options = ParseOptions.DEFAULT;
  }
  var currentParent = { type: "array", offset: -1, length: -1, children: [], parent: void 0 };
  function ensurePropertyComplete(endOffset) {
    if (currentParent.type === "property") {
      currentParent.length = endOffset - currentParent.offset;
      currentParent = currentParent.parent;
    }
  }
  function onValue(valueNode) {
    currentParent.children.push(valueNode);
    return valueNode;
  }
  var visitor = {
    onObjectBegin: function(offset) {
      currentParent = onValue({ type: "object", offset, length: -1, parent: currentParent, children: [] });
    },
    onObjectProperty: function(name2, offset, length) {
      currentParent = onValue({ type: "property", offset, length: -1, parent: currentParent, children: [] });
      currentParent.children.push({ type: "string", value: name2, offset, length, parent: currentParent });
    },
    onObjectEnd: function(offset, length) {
      ensurePropertyComplete(offset + length);
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onArrayBegin: function(offset, length) {
      currentParent = onValue({ type: "array", offset, length: -1, parent: currentParent, children: [] });
    },
    onArrayEnd: function(offset, length) {
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onLiteralValue: function(value, offset, length) {
      onValue({ type: getNodeType(value), offset, length, parent: currentParent, value });
      ensurePropertyComplete(offset + length);
    },
    onSeparator: function(sep, offset, length) {
      if (currentParent.type === "property") {
        if (sep === ":") {
          currentParent.colonOffset = offset;
        } else if (sep === ",") {
          ensurePropertyComplete(offset);
        }
      }
    },
    onError: function(error, offset, length) {
      errors.push({ error, offset, length });
    }
  };
  visit(text, visitor, options);
  var result = currentParent.children[0];
  if (result) {
    delete result.parent;
  }
  return result;
}
function findNodeAtLocation(root, path34) {
  if (!root) {
    return void 0;
  }
  var node = root;
  for (var _i = 0, path_1 = path34; _i < path_1.length; _i++) {
    var segment = path_1[_i];
    if (typeof segment === "string") {
      if (node.type !== "object" || !Array.isArray(node.children)) {
        return void 0;
      }
      var found = false;
      for (var _a2 = 0, _b = node.children; _a2 < _b.length; _a2++) {
        var propertyNode = _b[_a2];
        if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {
          node = propertyNode.children[1];
          found = true;
          break;
        }
      }
      if (!found) {
        return void 0;
      }
    } else {
      var index = segment;
      if (node.type !== "array" || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
        return void 0;
      }
      node = node.children[index];
    }
  }
  return node;
}
function visit(text, visitor, options) {
  if (options === void 0) {
    options = ParseOptions.DEFAULT;
  }
  var _scanner = createScanner(text, false);
  function toNoArgVisit(visitFunction) {
    return visitFunction ? function() {
      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? function(arg) {
      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
  var disallowComments = options && options.disallowComments;
  var allowTrailingComma = options && options.allowTrailingComma;
  function scanNext() {
    while (true) {
      var token = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError(14);
          break;
        case 5:
          handleError(15);
          break;
        case 3:
          handleError(13);
          break;
        case 1:
          if (!disallowComments) {
            handleError(11);
          }
          break;
        case 2:
          handleError(12);
          break;
        case 6:
          handleError(16);
          break;
      }
      switch (token) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError(10);
          } else {
            onComment();
          }
          break;
        case 16:
          handleError(1);
          break;
        case 15:
        case 14:
          break;
        default:
          return token;
      }
    }
  }
  function handleError(error, skipUntilAfter, skipUntil) {
    if (skipUntilAfter === void 0) {
      skipUntilAfter = [];
    }
    if (skipUntil === void 0) {
      skipUntil = [];
    }
    onError(error);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      var token = _scanner.getToken();
      while (token !== 17) {
        if (skipUntilAfter.indexOf(token) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token) !== -1) {
          break;
        }
        token = scanNext();
      }
    }
  }
  function parseString(isValue) {
    var value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11:
        var tokenValue = _scanner.getTokenValue();
        var value = Number(tokenValue);
        if (isNaN(value)) {
          handleError(2);
          value = 0;
        }
        onLiteralValue(value);
        break;
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError(3, [], [2, 5]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue()) {
        handleError(4, [], [2, 5]);
      }
    } else {
      handleError(5, [], [2, 5]);
    }
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseProperty()) {
        handleError(4, [], [2, 5]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError(7, [2], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseValue()) {
        handleError(4, [], [4, 5]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (_scanner.getToken() !== 4) {
      handleError(8, [4], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options.allowEmptyContent) {
      return true;
    }
    handleError(4, [], []);
    return false;
  }
  if (!parseValue()) {
    handleError(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError(9, [], []);
  }
  return true;
}
function getNodeType(value) {
  switch (typeof value) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
    case "object": {
      if (!value) {
        return "null";
      } else if (Array.isArray(value)) {
        return "array";
      }
      return "object";
    }
    default:
      return "null";
  }
}
var ParseOptions;
var init_parser = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/parser.js"() {
    init_scanner();
    "use strict";
    (function(ParseOptions2) {
      ParseOptions2.DEFAULT = {
        allowTrailingComma: false
      };
    })(ParseOptions || (ParseOptions = {}));
  }
});

// node_modules/jsonc-parser/lib/esm/impl/edit.js
function setProperty(text, originalPath, value, options) {
  var _a2;
  var path34 = originalPath.slice();
  var errors = [];
  var root = parseTree(text, errors);
  var parent = void 0;
  var lastSegment = void 0;
  while (path34.length > 0) {
    lastSegment = path34.pop();
    parent = findNodeAtLocation(root, path34);
    if (parent === void 0 && value !== void 0) {
      if (typeof lastSegment === "string") {
        value = (_a2 = {}, _a2[lastSegment] = value, _a2);
      } else {
        value = [value];
      }
    } else {
      break;
    }
  }
  if (!parent) {
    if (value === void 0) {
      throw new Error("Can not delete in empty document");
    }
    return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options);
  } else if (parent.type === "object" && typeof lastSegment === "string" && Array.isArray(parent.children)) {
    var existing = findNodeAtLocation(parent, [lastSegment]);
    if (existing !== void 0) {
      if (value === void 0) {
        if (!existing.parent) {
          throw new Error("Malformed AST");
        }
        var propertyIndex = parent.children.indexOf(existing.parent);
        var removeBegin = void 0;
        var removeEnd = existing.parent.offset + existing.parent.length;
        if (propertyIndex > 0) {
          var previous = parent.children[propertyIndex - 1];
          removeBegin = previous.offset + previous.length;
        } else {
          removeBegin = parent.offset + 1;
          if (parent.children.length > 1) {
            var next = parent.children[1];
            removeEnd = next.offset;
          }
        }
        return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: "" }, options);
      } else {
        return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options);
      }
    } else {
      if (value === void 0) {
        return [];
      }
      var newProperty = JSON.stringify(lastSegment) + ": " + JSON.stringify(value);
      var index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map(function(p) {
        return p.children[0].value;
      })) : parent.children.length;
      var edit2 = void 0;
      if (index > 0) {
        var previous = parent.children[index - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      } else if (parent.children.length === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty };
      } else {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty + "," };
      }
      return withFormatting(text, edit2, options);
    }
  } else if (parent.type === "array" && typeof lastSegment === "number" && Array.isArray(parent.children)) {
    var insertIndex = lastSegment;
    if (insertIndex === -1) {
      var newProperty = "" + JSON.stringify(value);
      var edit2 = void 0;
      if (parent.children.length === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty };
      } else {
        var previous = parent.children[parent.children.length - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      }
      return withFormatting(text, edit2, options);
    } else if (value === void 0 && parent.children.length >= 0) {
      var removalIndex = lastSegment;
      var toRemove = parent.children[removalIndex];
      var edit2 = void 0;
      if (parent.children.length === 1) {
        edit2 = { offset: parent.offset + 1, length: parent.length - 2, content: "" };
      } else if (parent.children.length - 1 === removalIndex) {
        var previous = parent.children[removalIndex - 1];
        var offset = previous.offset + previous.length;
        var parentEndOffset = parent.offset + parent.length;
        edit2 = { offset, length: parentEndOffset - 2 - offset, content: "" };
      } else {
        edit2 = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: "" };
      }
      return withFormatting(text, edit2, options);
    } else if (value !== void 0) {
      var edit2 = void 0;
      var newProperty = "" + JSON.stringify(value);
      if (!options.isArrayInsertion && parent.children.length > lastSegment) {
        var toModify = parent.children[lastSegment];
        edit2 = { offset: toModify.offset, length: toModify.length, content: newProperty };
      } else if (parent.children.length === 0 || lastSegment === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + "," };
      } else {
        var index = lastSegment > parent.children.length ? parent.children.length : lastSegment;
        var previous = parent.children[index - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      }
      return withFormatting(text, edit2, options);
    } else {
      throw new Error("Can not " + (value === void 0 ? "remove" : options.isArrayInsertion ? "insert" : "modify") + " Array index " + insertIndex + " as length is not sufficient");
    }
  } else {
    throw new Error("Can not add " + (typeof lastSegment !== "number" ? "index" : "property") + " to parent of type " + parent.type);
  }
}
function withFormatting(text, edit2, options) {
  if (!options.formattingOptions) {
    return [edit2];
  }
  var newText = applyEdit(text, edit2);
  var begin = edit2.offset;
  var end = edit2.offset + edit2.content.length;
  if (edit2.length === 0 || edit2.content.length === 0) {
    while (begin > 0 && !isEOL(newText, begin - 1)) {
      begin--;
    }
    while (end < newText.length && !isEOL(newText, end)) {
      end++;
    }
  }
  var edits = format(newText, { offset: begin, length: end - begin }, options.formattingOptions);
  for (var i = edits.length - 1; i >= 0; i--) {
    var edit_1 = edits[i];
    newText = applyEdit(newText, edit_1);
    begin = Math.min(begin, edit_1.offset);
    end = Math.max(end, edit_1.offset + edit_1.length);
    end += edit_1.content.length - edit_1.length;
  }
  var editLength = text.length - (newText.length - end) - begin;
  return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];
}
function applyEdit(text, edit2) {
  return text.substring(0, edit2.offset) + edit2.content + text.substring(edit2.offset + edit2.length);
}
var init_edit = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/edit.js"() {
    init_format();
    init_parser();
    "use strict";
  }
});

// node_modules/jsonc-parser/lib/esm/main.js
function modify(text, path34, value, options) {
  return setProperty(text, path34, value, options);
}
function applyEdits(text, edits) {
  for (var i = edits.length - 1; i >= 0; i--) {
    text = applyEdit(text, edits[i]);
  }
  return text;
}
var parse3;
var init_main3 = __esm({
  "node_modules/jsonc-parser/lib/esm/main.js"() {
    init_format();
    init_edit();
    init_scanner();
    init_parser();
    "use strict";
    parse3 = parse2;
  }
});

// src/configuration/util.ts
function parseContentFromFile(filepath, onError) {
  if (!filepath || !import_fs2.default.existsSync(filepath))
    return { contents: {} };
  let content;
  let uri = URI.file(filepath).toString();
  try {
    content = import_fs2.default.readFileSync(filepath, "utf8");
  } catch (_e) {
    content = "";
  }
  let [errors, contents] = parseConfiguration(content);
  if (errors && errors.length) {
    onError(convertErrors(uri, content, errors));
  }
  return { contents };
}
function parseConfiguration(content) {
  if (content.length == 0)
    return [[], {}];
  let errors = [];
  let data = parse3(content, errors, { allowTrailingComma: true });
  function addProperty(current, key, remains, value) {
    if (remains.length == 0) {
      current[key] = convert(value);
    } else {
      if (!current[key])
        current[key] = {};
      let o = current[key];
      let first = remains.shift();
      addProperty(o, first, remains, value);
    }
  }
  function convert(obj, split = false) {
    if (!objectLiteral(obj))
      return obj;
    if (emptyObject(obj))
      return {};
    let dest = {};
    for (let key of Object.keys(obj)) {
      if (split && key.includes(".")) {
        let parts = key.split(".");
        let first = parts.shift();
        addProperty(dest, first, parts, obj[key]);
      } else {
        dest[key] = convert(obj[key]);
      }
    }
    return dest;
  }
  return [errors, convert(data, true)];
}
function convertErrors(uri, content, errors) {
  let items = [];
  let document2 = TextDocument2.create(uri, "json", 0, content);
  for (let err of errors) {
    let msg = "parse error";
    switch (err.error) {
      case 2:
        msg = "invalid number";
        break;
      case 8:
        msg = "close brace expected";
        break;
      case 5:
        msg = "colon expected";
        break;
      case 6:
        msg = "comma expected";
        break;
      case 9:
        msg = "end of file expected";
        break;
      case 16:
        msg = "invaliad character";
        break;
      case 10:
        msg = "invalid commment token";
        break;
      case 15:
        msg = "invalid escape character";
        break;
      case 1:
        msg = "invalid symbol";
        break;
      case 14:
        msg = "invalid unicode";
        break;
      case 3:
        msg = "property name expected";
        break;
      case 13:
        msg = "unexpected end of number";
        break;
      case 12:
        msg = "unexpected end of string";
        break;
      case 11:
        msg = "unexpected end of comment";
        break;
      case 4:
        msg = "value expected";
        break;
      default:
        msg = "Unknwn error";
        break;
    }
    let range = {
      start: document2.positionAt(err.offset),
      end: document2.positionAt(err.offset + err.length)
    };
    let loc = import_vscode_languageserver_protocol7.Location.create(uri, range);
    items.push({ location: loc, message: msg });
  }
  return items;
}
function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
  const segments = key.split(".");
  const last = segments.pop();
  let curr = settingsTreeRoot;
  for (let i = 0; i < segments.length; i++) {
    let s = segments[i];
    let obj = curr[s];
    switch (typeof obj) {
      case "function": {
        obj = curr[s] = {};
        break;
      }
      case "undefined": {
        obj = curr[s] = {};
        break;
      }
      case "object":
        break;
      default:
        conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join(".")} is ${JSON.stringify(obj)}`);
        return;
    }
    curr = obj;
  }
  if (typeof curr === "object") {
    curr[last] = value;
  } else {
    conflictReporter(`Ignoring ${key} as ${segments.join(".")} is ${JSON.stringify(curr)}`);
  }
}
function removeFromValueTree(valueTree, key) {
  const segments = key.split(".");
  doRemoveFromValueTree(valueTree, segments);
}
function doRemoveFromValueTree(valueTree, segments) {
  const first = segments.shift();
  if (segments.length === 0) {
    delete valueTree[first];
    return;
  }
  if (Object.keys(valueTree).includes(first)) {
    const value = valueTree[first];
    if (typeof value === "object" && !Array.isArray(value)) {
      doRemoveFromValueTree(value, segments);
      if (Object.keys(value).length === 0) {
        delete valueTree[first];
      }
    }
  }
}
function getConfigurationValue(config, settingPath, defaultValue) {
  function accessSetting(config2, path35) {
    let current = config2;
    for (let i = 0; i < path35.length; i++) {
      if (typeof current !== "object" || current === null) {
        return void 0;
      }
      current = current[path35[i]];
    }
    return current;
  }
  const path34 = settingPath.split(".");
  const result = accessSetting(config, path34);
  return typeof result === "undefined" ? defaultValue : result;
}
function loadDefaultConfigurations() {
  let file = import_path2.default.join(pluginRoot, "data/schema.json");
  if (!import_fs2.default.existsSync(file)) {
    console.error("schema.json not found, reinstall coc.nvim to fix this!");
    return { contents: {} };
  }
  let content = import_fs2.default.readFileSync(file, "utf8");
  let { properties } = JSON.parse(content);
  let config = {};
  Object.keys(properties).forEach((key) => {
    let value = properties[key].default;
    if (value !== void 0) {
      addToValueTree(config, key, value, (message) => {
        logger12.error(message);
      });
    }
  });
  return { contents: config };
}
function getKeys(obj, curr) {
  let keys = [];
  for (let key of Object.keys(obj)) {
    let val = obj[key];
    let newKey = curr ? `${curr}.${key}` : key;
    keys.push(newKey);
    if (objectLiteral(val)) {
      keys.push(...getKeys(val, newKey));
    }
  }
  return keys;
}
function getChangedKeys(from, to) {
  let keys = [];
  let fromKeys = getKeys(from);
  let toKeys = getKeys(to);
  const added = toKeys.filter((key) => !fromKeys.includes(key));
  const removed = fromKeys.filter((key) => !toKeys.includes(key));
  keys.push(...added);
  keys.push(...removed);
  for (const key of fromKeys) {
    if (!toKeys.includes(key))
      continue;
    const value1 = getConfigurationValue(from, key);
    const value2 = getConfigurationValue(to, key);
    if (!equals(value1, value2)) {
      keys.push(key);
    }
  }
  return keys;
}
var import_vscode_languageserver_protocol7, import_fs2, import_path2, logger12, pluginRoot;
var init_util2 = __esm({
  "src/configuration/util.ts"() {
    import_vscode_languageserver_protocol7 = __toModule(require_main2());
    init_main2();
    init_main3();
    init_is();
    init_object();
    import_fs2 = __toModule(require("fs"));
    init_esm2();
    import_path2 = __toModule(require("path"));
    logger12 = require_logger2()("configuration-util");
    pluginRoot = false ? resolve(__dirname, "../..") : (0, import_path2.dirname)(__dirname);
  }
});

// src/configuration/model.ts
var ConfigurationModel;
var init_model = __esm({
  "src/configuration/model.ts"() {
    init_is();
    init_object();
    init_util2();
    ConfigurationModel = class {
      constructor(_contents = {}) {
        this._contents = _contents;
      }
      get contents() {
        return this._contents;
      }
      clone() {
        return new ConfigurationModel(deepClone(this._contents));
      }
      getValue(section2) {
        let res = section2 ? getConfigurationValue(this.contents, section2) : this.contents;
        return res;
      }
      merge(...others) {
        const contents = deepClone(this.contents);
        for (const other of others) {
          this.mergeContents(contents, other.contents);
        }
        return new ConfigurationModel(contents);
      }
      freeze() {
        if (!Object.isFrozen(this._contents)) {
          Object.freeze(this._contents);
        }
        return this;
      }
      mergeContents(source, target) {
        for (const key of Object.keys(target)) {
          if (key in source) {
            if (objectLiteral(source[key]) && objectLiteral(target[key])) {
              this.mergeContents(source[key], target[key]);
              continue;
            }
          }
          source[key] = deepClone(target[key]);
        }
      }
      setValue(key, value) {
        addToValueTree(this.contents, key, value, (message) => {
          console.error(message);
        });
      }
      removeValue(key) {
        removeFromValueTree(this.contents, key);
      }
    };
  }
});

// src/configuration/configuration.ts
var Configuration;
var init_configuration = __esm({
  "src/configuration/configuration.ts"() {
    init_model();
    Configuration = class {
      constructor(_defaultConfiguration, _userConfiguration, _workspaceConfiguration, _memoryConfiguration = new ConfigurationModel()) {
        this._defaultConfiguration = _defaultConfiguration;
        this._userConfiguration = _userConfiguration;
        this._workspaceConfiguration = _workspaceConfiguration;
        this._memoryConfiguration = _memoryConfiguration;
      }
      getConsolidateConfiguration() {
        if (!this._consolidateConfiguration) {
          this._consolidateConfiguration = this._defaultConfiguration.merge(this._userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
          this._consolidateConfiguration = this._consolidateConfiguration.freeze();
        }
        return this._consolidateConfiguration;
      }
      getValue(section2) {
        let configuration = this.getConsolidateConfiguration();
        return configuration.getValue(section2);
      }
      inspect(key) {
        const consolidateConfigurationModel = this.getConsolidateConfiguration();
        const { _workspaceConfiguration, _memoryConfiguration } = this;
        return {
          default: this._defaultConfiguration.freeze().getValue(key),
          user: this._userConfiguration.freeze().getValue(key),
          workspace: _workspaceConfiguration.freeze().getValue(key),
          memory: _memoryConfiguration.freeze().getValue(key),
          value: consolidateConfigurationModel.getValue(key)
        };
      }
      get defaults() {
        return this._defaultConfiguration;
      }
      get user() {
        return this._userConfiguration;
      }
      get workspace() {
        return this._workspaceConfiguration;
      }
      toData() {
        return {
          defaults: {
            contents: this._defaultConfiguration.contents
          },
          user: {
            contents: this._userConfiguration.contents
          },
          workspace: {
            contents: this._workspaceConfiguration.contents
          }
        };
      }
    };
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad2 = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad2) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch7;
    minimatch7.Minimatch = Minimatch;
    var path34 = { sep: "/" };
    try {
      path34 = require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch7.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch7.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list2) {
        return minimatch7(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch7.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch7;
      var orig = minimatch7;
      var m = function minimatch8(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch7.defaults(def).Minimatch;
    };
    function minimatch7(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path34.sep !== "/") {
        pattern = pattern.split(path34.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch7.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse5;
    var SUBPARSE = {};
    function parse5(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch7.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch7.match = function(list2, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list2 = list2.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list2.length) {
        list2.push(pattern);
      }
      return list2;
    };
    Minimatch.prototype.match = match;
    function match(f, partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path34.sep !== "/") {
        f = f.split(path34.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { "this": this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// src/util/fs.ts
async function statAsync(filepath) {
  let stat = null;
  try {
    stat = await import_fs_extra.default.stat(filepath);
  } catch (e) {
  }
  return stat;
}
function renameAsync(oldPath, newPath) {
  return new Promise((resolve3, reject) => {
    import_fs_extra.default.rename(oldPath, newPath, (err) => {
      if (err)
        return reject(err);
      resolve3();
    });
  });
}
function resolveRoot(folder, subs, cwd, bottomup = false, checkCwd = true) {
  let home = import_os.default.homedir();
  let dir = fixDriver(folder);
  if (isParentFolder(dir, home, true))
    return null;
  if (checkCwd && cwd && isParentFolder(cwd, dir, true) && inDirectory(cwd, subs))
    return cwd;
  let parts = dir.split(import_path3.default.sep);
  if (bottomup) {
    while (parts.length > 0) {
      let dir2 = parts.join(import_path3.default.sep);
      if (dir2 == home) {
        break;
      }
      if (dir2 != home && inDirectory(dir2, subs)) {
        return dir2;
      }
      parts.pop();
    }
    return null;
  } else {
    let curr = [parts.shift()];
    for (let part of parts) {
      curr.push(part);
      let dir2 = curr.join(import_path3.default.sep);
      if (dir2 != home && inDirectory(dir2, subs)) {
        return dir2;
      }
    }
    return null;
  }
}
function inDirectory(dir, subs) {
  try {
    let files = import_fs_extra.default.readdirSync(dir);
    for (let pattern of subs) {
      let is_wildcard = pattern.includes("*");
      let res = is_wildcard ? import_minimatch.default.match(files, pattern, { nobrace: true, noext: true, nocomment: true, nonegate: true, dot: true }).length !== 0 : files.includes(pattern);
      if (res)
        return true;
    }
  } catch (e) {
  }
  return false;
}
function findUp(name2, cwd) {
  let root = import_path3.default.parse(cwd).root;
  let subs = Array.isArray(name2) ? name2 : [name2];
  while (cwd && cwd !== root) {
    let find = inDirectory(cwd, subs);
    if (find) {
      for (let sub of subs) {
        let filepath = import_path3.default.join(cwd, sub);
        if (import_fs_extra.default.existsSync(filepath)) {
          return filepath;
        }
      }
    }
    cwd = import_path3.default.dirname(cwd);
  }
  return null;
}
function readFile(fullpath, encoding) {
  return new Promise((resolve3, reject) => {
    import_fs_extra.default.readFile(fullpath, encoding, (err, content) => {
      if (err)
        reject(err);
      resolve3(content);
    });
  });
}
function getFileLineCount(filepath) {
  let i;
  let count = 0;
  return new Promise((resolve3, reject) => {
    import_fs_extra.default.createReadStream(filepath).on("error", (e) => reject(e)).on("data", (chunk) => {
      for (i = 0; i < chunk.length; ++i)
        if (chunk[i] == 10)
          count++;
    }).on("end", () => resolve3(count));
  });
}
function readFileLines(fullpath, start, end) {
  if (!import_fs_extra.default.existsSync(fullpath)) {
    return Promise.reject(new Error(`file does not exist: ${fullpath}`));
  }
  let res = [];
  const rl = import_readline.default.createInterface({
    input: import_fs_extra.default.createReadStream(fullpath, { encoding: "utf8" }),
    crlfDelay: Infinity,
    terminal: false
  });
  let n = 0;
  return new Promise((resolve3, reject) => {
    rl.on("line", (line) => {
      if (n == 0 && line.startsWith("\uFEFF")) {
        line = line.slice(1);
      }
      if (n >= start && n <= end) {
        res.push(line);
      }
      if (n == end) {
        rl.close();
      }
      n = n + 1;
    });
    rl.on("close", () => {
      resolve3(res);
    });
    rl.on("error", reject);
  });
}
function readFileLine(fullpath, count) {
  if (!import_fs_extra.default.existsSync(fullpath)) {
    return Promise.reject(new Error(`file does not exist: ${fullpath}`));
  }
  const rl = import_readline.default.createInterface({
    input: import_fs_extra.default.createReadStream(fullpath, { encoding: "utf8" }),
    crlfDelay: Infinity,
    terminal: false
  });
  let n = 0;
  return new Promise((resolve3, reject) => {
    rl.on("line", (line) => {
      if (n == count) {
        if (n == 0 && line.startsWith("\uFEFF")) {
          line = line.slice(1);
        }
        rl.close();
        resolve3(line);
        return;
      }
      n = n + 1;
    });
    rl.on("error", reject);
  });
}
async function writeFile(fullpath, content) {
  await import_fs_extra.default.writeFile(fullpath, content, { encoding: "utf8" });
}
function isFile(uri) {
  return uri.startsWith("file:");
}
function isParentFolder(folder, filepath, checkEqual = false) {
  let pdir = fixDriver(import_path3.default.resolve(import_path3.default.normalize(folder)));
  let dir = fixDriver(import_path3.default.resolve(import_path3.default.normalize(filepath)));
  if (pdir == "//")
    pdir = "/";
  if (pdir == dir)
    return checkEqual ? true : false;
  if (pdir.endsWith(import_path3.default.sep))
    return dir.startsWith(pdir);
  return dir.startsWith(pdir) && dir[pdir.length] == import_path3.default.sep;
}
function fixDriver(filepath) {
  if (import_os.default.platform() != "win32" || filepath[1] != ":")
    return filepath;
  return filepath[0].toUpperCase() + filepath.slice(1);
}
var import_child_process2, import_fs_extra, import_net, import_os, import_path3, import_readline, import_util9, import_minimatch, logger13;
var init_fs = __esm({
  "src/util/fs.ts"() {
    import_child_process2 = __toModule(require("child_process"));
    import_fs_extra = __toModule(require_lib5());
    import_net = __toModule(require("net"));
    import_os = __toModule(require("os"));
    import_path3 = __toModule(require("path"));
    import_readline = __toModule(require("readline"));
    import_util9 = __toModule(require("util"));
    import_minimatch = __toModule(require_minimatch());
    logger13 = require_logger2()("util-fs");
  }
});

// src/configuration/index.ts
function lookUp(tree, key) {
  if (key) {
    if (tree && tree.hasOwnProperty(key))
      return tree[key];
    const parts = key.split(".");
    let node = tree;
    for (let i = 0; node && i < parts.length; i++) {
      node = node[parts[i]];
    }
    return node;
  }
  return tree;
}
var import_os2, import_fs3, import_path4, import_vscode_languageserver_protocol8, logger14, Configurations;
var init_configuration2 = __esm({
  "src/configuration/index.ts"() {
    import_os2 = __toModule(require("os"));
    import_fs3 = __toModule(require("fs"));
    import_path4 = __toModule(require("path"));
    import_vscode_languageserver_protocol8 = __toModule(require_main2());
    init_esm2();
    init_types();
    init_object();
    init_util();
    init_configuration();
    init_model();
    init_util2();
    init_is();
    init_fs();
    logger14 = require_logger2()("configurations");
    Configurations = class {
      constructor(userConfigFile, _proxy) {
        this.userConfigFile = userConfigFile;
        this._proxy = _proxy;
        this._errorItems = [];
        this._folderConfigurations = new Map();
        this._onError = new import_vscode_languageserver_protocol8.Emitter();
        this._onChange = new import_vscode_languageserver_protocol8.Emitter();
        this.disposables = [];
        this.onError = this._onError.event;
        this.onDidChange = this._onChange.event;
        let user = this.parseContentFromFile(userConfigFile);
        let data = {
          defaults: loadDefaultConfigurations(),
          user,
          workspace: { contents: {} }
        };
        this._configuration = Configurations.parse(data);
        this.watchFile(userConfigFile, ConfigurationTarget.User);
        let folderConfigFile = import_path4.default.join(process.cwd(), `.vim/${CONFIG_FILE_NAME}`);
        if (folderConfigFile != userConfigFile && import_fs3.default.existsSync(folderConfigFile)) {
          this.addFolderFile(folderConfigFile);
        }
      }
      parseContentFromFile(filepath) {
        if (!filepath)
          return { contents: {} };
        let uri = URI.file(filepath).toString();
        this._errorItems = this._errorItems.filter((o) => o.location.uri != uri);
        let res = parseContentFromFile(filepath, (errors) => {
          this._errorItems.push(...errors);
        });
        this._onError.fire(this._errorItems);
        return res;
      }
      get errorItems() {
        return this._errorItems;
      }
      get foldConfigurations() {
        return this._folderConfigurations;
      }
      extendsDefaults(props) {
        let { defaults: defaults2 } = this._configuration;
        let { contents } = defaults2;
        contents = deepClone(contents);
        Object.keys(props).forEach((key) => {
          addToValueTree(contents, key, props[key], (msg) => {
            logger14.error(msg);
          });
        });
        let data = {
          defaults: { contents },
          user: this._configuration.user,
          workspace: this._configuration.workspace
        };
        this._configuration = Configurations.parse(data);
      }
      updateUserConfig(props) {
        if (!props || Object.keys(props).length == 0)
          return;
        let { user } = this._configuration;
        let model = user.clone();
        Object.keys(props).forEach((key) => {
          let val = props[key];
          if (val === void 0) {
            model.removeValue(key);
          } else if (objectLiteral(val)) {
            for (let k of Object.keys(val)) {
              model.setValue(`${key}.${k}`, val[k]);
            }
          } else {
            model.setValue(key, val);
          }
        });
        this.changeConfiguration(ConfigurationTarget.User, model);
      }
      get defaults() {
        return this._configuration.defaults;
      }
      get user() {
        return this._configuration.user;
      }
      get workspace() {
        return this._configuration.workspace;
      }
      addFolderFile(filepath) {
        let { _folderConfigurations } = this;
        if (_folderConfigurations.has(filepath))
          return;
        if (import_path4.default.resolve(filepath, "../..") == import_os2.default.homedir())
          return;
        let model = this.parseContentFromFile(filepath);
        this.watchFile(filepath, ConfigurationTarget.Workspace);
        this.changeConfiguration(ConfigurationTarget.Workspace, model, filepath);
      }
      watchFile(filepath, target) {
        if (!import_fs3.default.existsSync(filepath) || global.hasOwnProperty("__TEST__"))
          return;
        let disposable = watchFile(filepath, () => {
          let model = this.parseContentFromFile(filepath);
          this.changeConfiguration(target, model, filepath);
        });
        this.disposables.push(disposable);
      }
      changeConfiguration(target, model, configFile) {
        let { defaults: defaults2, user, workspace } = this._configuration;
        let { workspaceConfigFile } = this;
        let data = {
          defaults: target == ConfigurationTarget.Global ? model : defaults2,
          user: target == ConfigurationTarget.User ? model : user,
          workspace: target == ConfigurationTarget.Workspace ? model : workspace
        };
        let configuration = Configurations.parse(data);
        let changed = getChangedKeys(this._configuration.getValue(), configuration.getValue());
        if (target == ConfigurationTarget.Workspace && configFile) {
          this._folderConfigurations.set(configFile, new ConfigurationModel(model.contents));
          this.workspaceConfigFile = configFile;
        }
        if (changed.length == 0)
          return;
        this._configuration = configuration;
        this._onChange.fire({
          affectsConfiguration: (section2, resource) => {
            if (!resource || target != ConfigurationTarget.Workspace)
              return changed.includes(section2);
            let u = URI.parse(resource);
            if (u.scheme !== "file")
              return changed.includes(section2);
            let filepath = u.fsPath;
            let preRoot = workspaceConfigFile ? import_path4.default.resolve(workspaceConfigFile, "../..") : "";
            if (configFile && !isParentFolder(preRoot, filepath, true) && !isParentFolder(import_path4.default.resolve(configFile, "../.."), filepath)) {
              return false;
            }
            return changed.includes(section2);
          }
        });
      }
      setFolderConfiguration(uri) {
        let u = URI.parse(uri);
        if (u.scheme != "file")
          return;
        let filepath = u.fsPath;
        for (let [configFile, model] of this.foldConfigurations) {
          let root = import_path4.default.resolve(configFile, "../..");
          if (isParentFolder(root, filepath, true) && this.workspaceConfigFile != configFile) {
            this.changeConfiguration(ConfigurationTarget.Workspace, model, configFile);
            break;
          }
        }
      }
      hasFolderConfiguration(filepath) {
        let { folders } = this;
        return folders.findIndex((f) => isParentFolder(f, filepath, true)) !== -1;
      }
      getConfigFile(target) {
        if (target == ConfigurationTarget.Global)
          return null;
        if (target == ConfigurationTarget.User)
          return this.userConfigFile;
        return this.workspaceConfigFile;
      }
      get folders() {
        let res = [];
        let { _folderConfigurations } = this;
        for (let folder of _folderConfigurations.keys()) {
          res.push(import_path4.default.resolve(folder, "../.."));
        }
        return res;
      }
      get configuration() {
        return this._configuration;
      }
      getConfiguration(section2, resource) {
        let configuration;
        if (resource) {
          let { defaults: defaults2, user } = this._configuration;
          configuration = new Configuration(defaults2, user, this.getFolderConfiguration(resource));
        } else {
          configuration = this._configuration;
        }
        const config = Object.freeze(lookUp(configuration.getValue(null), section2));
        const result = {
          has(key) {
            return typeof lookUp(config, key) !== "undefined";
          },
          get: (key, defaultValue) => {
            let result2 = lookUp(config, key);
            if (result2 == null)
              return defaultValue;
            return result2;
          },
          update: (key, value, isUser = false) => {
            let s = section2 ? `${section2}.${key}` : key;
            let target = isUser ? ConfigurationTarget.User : ConfigurationTarget.Workspace;
            let model = target == ConfigurationTarget.User ? this.user.clone() : this.workspace.clone();
            if (value == void 0) {
              model.removeValue(s);
            } else {
              model.setValue(s, value);
            }
            if (target == ConfigurationTarget.Workspace && !this.workspaceConfigFile && this._proxy) {
              let file = this.workspaceConfigFile = this._proxy.workspaceConfigFile;
              if (!import_fs3.default.existsSync(file)) {
                let folder = import_path4.default.dirname(file);
                if (!import_fs3.default.existsSync(folder))
                  import_fs3.default.mkdirSync(folder);
                import_fs3.default.writeFileSync(file, "{}", { encoding: "utf8" });
              }
            }
            this.changeConfiguration(target, model, target == ConfigurationTarget.Workspace ? this.workspaceConfigFile : this.userConfigFile);
            if (this._proxy && !global.hasOwnProperty("__TEST__")) {
              if (value == void 0) {
                this._proxy.$removeConfigurationOption(target, s);
              } else {
                this._proxy.$updateConfigurationOption(target, s, value);
              }
            }
          },
          inspect: (key) => {
            key = section2 ? `${section2}.${key}` : key;
            const config2 = this._configuration.inspect(key);
            if (config2) {
              return {
                key,
                defaultValue: config2.default,
                globalValue: config2.user,
                workspaceValue: config2.workspace
              };
            }
            return void 0;
          }
        };
        Object.defineProperty(result, "has", {
          enumerable: false
        });
        Object.defineProperty(result, "get", {
          enumerable: false
        });
        Object.defineProperty(result, "update", {
          enumerable: false
        });
        Object.defineProperty(result, "inspect", {
          enumerable: false
        });
        if (typeof config === "object") {
          mixin(result, config, false);
        }
        return deepFreeze(result);
      }
      getFolderConfiguration(uri) {
        let u = URI.parse(uri);
        if (u.scheme != "file")
          return new ConfigurationModel();
        let filepath = u.fsPath;
        for (let [configFile, model] of this.foldConfigurations) {
          let root = import_path4.default.resolve(configFile, "../..");
          if (isParentFolder(root, filepath, true))
            return model;
        }
        return new ConfigurationModel();
      }
      checkFolderConfiguration(uri) {
        let u = URI.parse(uri);
        if (u.scheme != "file")
          return;
        let rootPath = import_path4.default.dirname(u.fsPath);
        if (!this.hasFolderConfiguration(rootPath)) {
          let folder = findUp(".vim", rootPath);
          if (folder && folder != import_os2.default.homedir()) {
            let file = import_path4.default.join(folder, CONFIG_FILE_NAME);
            if (import_fs3.default.existsSync(file)) {
              this.addFolderFile(file);
            }
          }
        } else {
          this.setFolderConfiguration(uri);
        }
      }
      static parse(data) {
        const defaultConfiguration = new ConfigurationModel(data.defaults.contents);
        const userConfiguration = new ConfigurationModel(data.user.contents);
        const workspaceConfiguration = new ConfigurationModel(data.workspace.contents);
        return new Configuration(defaultConfiguration, userConfiguration, workspaceConfiguration, new ConfigurationModel());
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/configuration/shape.ts
var import_fs5, import_path5, logger15, ConfigurationProxy;
var init_shape = __esm({
  "src/configuration/shape.ts"() {
    import_fs5 = __toModule(require("fs"));
    init_main3();
    import_path5 = __toModule(require("path"));
    init_esm2();
    init_util();
    logger15 = require_logger2()("configuration-shape");
    ConfigurationProxy = class {
      constructor(workspace) {
        this.workspace = workspace;
      }
      get nvim() {
        return this.workspace.nvim;
      }
      async modifyConfiguration(target, key, value) {
        let { nvim, workspace } = this;
        let file = workspace.getConfigFile(target);
        if (!file)
          return;
        let formattingOptions = { tabSize: 2, insertSpaces: true };
        let content = import_fs5.default.readFileSync(file, "utf8");
        value = value == null ? void 0 : value;
        let edits = modify(content, [key], value, { formattingOptions });
        content = applyEdits(content, edits);
        import_fs5.default.writeFileSync(file, content, "utf8");
        let doc = workspace.getDocument(URI.file(file).toString());
        if (doc)
          nvim.command("checktime", true);
        return;
      }
      get workspaceConfigFile() {
        let folder = import_path5.default.join(this.workspace.root, ".vim");
        return import_path5.default.join(folder, CONFIG_FILE_NAME);
      }
      $updateConfigurationOption(target, key, value) {
        this.modifyConfiguration(target, key, value).logError();
      }
      $removeConfigurationOption(target, key) {
        this.modifyConfiguration(target, key).logError();
      }
    };
  }
});

// src/model/db.ts
var import_fs_extra2, import_path6, DB;
var init_db = __esm({
  "src/model/db.ts"() {
    import_fs_extra2 = __toModule(require_lib5());
    import_path6 = __toModule(require("path"));
    DB = class {
      constructor(filepath) {
        this.filepath = filepath;
      }
      fetch(key) {
        let obj = this.load();
        if (!key)
          return obj;
        let parts = key.split(".");
        for (let part of parts) {
          if (typeof obj[part] == "undefined") {
            return void 0;
          }
          obj = obj[part];
        }
        return obj;
      }
      exists(key) {
        let obj = this.load();
        let parts = key.split(".");
        for (let part of parts) {
          if (typeof obj[part] == "undefined") {
            return false;
          }
          obj = obj[part];
        }
        return true;
      }
      delete(key) {
        let obj = this.load();
        let origin = obj;
        let parts = key.split(".");
        let len = parts.length;
        for (let i = 0; i < len; i++) {
          if (typeof obj[parts[i]] == "undefined") {
            break;
          }
          if (i == len - 1) {
            delete obj[parts[i]];
            import_fs_extra2.default.writeFileSync(this.filepath, JSON.stringify(origin, null, 2), "utf8");
            break;
          }
          obj = obj[parts[i]];
        }
      }
      push(key, data) {
        let origin = this.load() || {};
        let obj = origin;
        let parts = key.split(".");
        let len = parts.length;
        if (obj == null) {
          let dir = import_path6.default.dirname(this.filepath);
          import_fs_extra2.default.mkdirpSync(dir);
          obj = origin;
        }
        for (let i = 0; i < len; i++) {
          let key2 = parts[i];
          if (i == len - 1) {
            obj[key2] = data;
            import_fs_extra2.default.writeFileSync(this.filepath, JSON.stringify(origin, null, 2));
            break;
          }
          if (typeof obj[key2] == "undefined") {
            obj[key2] = {};
            obj = obj[key2];
          } else {
            obj = obj[key2];
          }
        }
      }
      load() {
        let dir = import_path6.default.dirname(this.filepath);
        let stat = import_fs_extra2.default.statSync(dir);
        if (!stat || !stat.isDirectory()) {
          import_fs_extra2.default.mkdirpSync(dir);
          import_fs_extra2.default.writeFileSync(this.filepath, "{}", "utf8");
          return {};
        }
        try {
          let content = import_fs_extra2.default.readFileSync(this.filepath, "utf8");
          return JSON.parse(content.trim());
        } catch (e) {
          import_fs_extra2.default.writeFileSync(this.filepath, "{}", "utf8");
          return {};
        }
      }
      clear() {
        let stat = import_fs_extra2.default.statSync(this.filepath);
        if (!stat || !stat.isFile())
          return;
        import_fs_extra2.default.writeFileSync(this.filepath, "{}", "utf8");
      }
      destroy() {
        if (import_fs_extra2.default.existsSync(this.filepath)) {
          import_fs_extra2.default.unlinkSync(this.filepath);
        }
      }
    };
  }
});

// src/util/diff.ts
function diffLines(oldLines, newLines) {
  let start = 0;
  let end = oldLines.length;
  let oldLen = end;
  let len = newLines.length;
  for (let i = 0; i <= end; i++) {
    if (newLines[i] !== oldLines[i]) {
      start = i;
      break;
    }
    if (i == end) {
      start = end;
    }
  }
  if (start != newLines.length) {
    let maxRemain = Math.min(end - start, len - start);
    for (let j = 0; j < maxRemain; j++) {
      if (oldLines[oldLen - j - 1] != newLines[len - j - 1]) {
        break;
      }
      end = end - 1;
    }
  }
  return {
    start,
    end,
    replacement: newLines.slice(start, len - (oldLen - end))
  };
}
function getChange(oldStr, newStr, cursorEnd) {
  let ol = oldStr.length;
  let nl = newStr.length;
  let max = Math.min(ol, nl);
  let newText = "";
  let startOffset = 0;
  let endOffset = -1;
  let shouldLimit = false;
  for (let i = 0; i <= max; i++) {
    if (cursorEnd != null && i == cursorEnd) {
      endOffset = i;
      shouldLimit = true;
      break;
    }
    if (oldStr[ol - i - 1] != newStr[nl - i - 1]) {
      endOffset = i;
      break;
    }
  }
  if (endOffset == -1)
    return null;
  let remain = max - endOffset;
  if (remain == 0) {
    startOffset = 0;
  } else {
    for (let i = 0; i <= remain; i++) {
      if (oldStr[i] != newStr[i] || i == remain) {
        startOffset = i;
        break;
      }
    }
  }
  remain = remain - startOffset;
  if (shouldLimit && remain > 0) {
    let end2 = endOffset;
    for (let i = 0; i < remain; i++) {
      let oc = oldStr[ol - end2 - 1 - i];
      let nc = newStr[nl - end2 - 1 - i];
      if (oc == nc) {
        endOffset = endOffset + 1;
      } else {
        break;
      }
    }
  }
  let end = ol - endOffset;
  if (ol == nl && startOffset == end)
    return null;
  newText = newStr.slice(startOffset, nl - endOffset);
  if (startOffset == end) {
    let pre = startOffset == 0 ? "" : newStr[startOffset - 1];
    if (pre && pre != "\n" && oldStr[startOffset] == "\n" && newText.startsWith("\n")) {
      return { start: startOffset + 1, end: end + 1, newText: newText.slice(1) + "\n" };
    }
  }
  return { start: startOffset, end, newText };
}
function patchLine(from, to, fill = " ") {
  if (from == to)
    return to;
  let idx = to.indexOf(from);
  if (idx !== -1)
    return fill.repeat(idx) + from;
  let result = (0, import_fast_diff.default)(from, to);
  let str = "";
  for (let item of result) {
    if (item[0] == import_fast_diff.default.DELETE) {
      return to;
    } else if (item[0] == import_fast_diff.default.INSERT) {
      str = str + fill.repeat(byteLength(item[1]));
    } else {
      str = str + item[1];
    }
  }
  return str;
}
var import_fast_diff, logger16;
var init_diff = __esm({
  "src/util/diff.ts"() {
    import_fast_diff = __toModule(require_diff2());
    init_string();
    logger16 = require_logger2()("util-diff");
  }
});

// src/model/chars.ts
var logger17, Range3, Chars;
var init_chars = __esm({
  "src/model/chars.ts"() {
    logger17 = require_logger2()("model-chars");
    Range3 = class {
      constructor(start, end) {
        this.start = start;
        this.end = end ? end : start;
      }
      static fromKeywordOption(keywordOption) {
        let parts = keywordOption.split(",");
        let ranges = [];
        for (let part of parts) {
          if (part == "@") {
            ranges.push(new Range3(65, 90));
            ranges.push(new Range3(97, 122));
          } else if (part == "@-@") {
            ranges.push(new Range3(64));
          } else if (/^([A-Za-z])-([A-Za-z])$/.test(part)) {
            let ms = part.match(/^([A-Za-z])-([A-Za-z])$/);
            ranges.push(new Range3(ms[1].charCodeAt(0), ms[2].charCodeAt(0)));
          } else if (/^\d+-\d+$/.test(part)) {
            let ms = part.match(/^(\d+)-(\d+)$/);
            ranges.push(new Range3(Number(ms[1]), Number(ms[2])));
          } else if (/^\d+$/.test(part)) {
            ranges.push(new Range3(Number(part)));
          } else {
            let c = part.charCodeAt(0);
            if (!ranges.some((o) => o.contains(c))) {
              ranges.push(new Range3(c));
            }
          }
        }
        return ranges;
      }
      contains(c) {
        return c >= this.start && c <= this.end;
      }
    };
    Chars = class {
      constructor(keywordOption) {
        this.ranges = [];
        if (keywordOption)
          this.ranges = Range3.fromKeywordOption(keywordOption);
      }
      addKeyword(ch) {
        let c = ch.charCodeAt(0);
        let { ranges } = this;
        if (!ranges.some((o) => o.contains(c))) {
          ranges.push(new Range3(c));
        }
      }
      clone() {
        let chars = new Chars();
        chars.ranges = this.ranges.slice();
        return chars;
      }
      setKeywordOption(keywordOption) {
        this.ranges = Range3.fromKeywordOption(keywordOption);
      }
      matchKeywords(content, min = 3) {
        let length = content.length;
        if (length == 0)
          return [];
        let res = new Set();
        let str = "";
        let len = 0;
        for (let i = 0; i < length; i++) {
          let ch = content[i];
          let code = ch.codePointAt(0);
          if (len == 0 && code == 45)
            continue;
          let isKeyword = this.isKeywordCode(code);
          if (isKeyword) {
            if (len == 48)
              continue;
            str = str + ch;
            len = len + 1;
          } else {
            if (len >= min && len < 48)
              res.add(str);
            str = "";
            len = 0;
          }
        }
        if (len != 0)
          res.add(str);
        return Array.from(res);
      }
      isKeywordCode(code) {
        if (code > 255)
          return true;
        if (code < 33)
          return false;
        return this.ranges.some((r) => r.contains(code));
      }
      isKeywordChar(ch) {
        let { ranges } = this;
        let c = ch.charCodeAt(0);
        if (c > 255)
          return true;
        if (c < 33)
          return false;
        return ranges.some((r) => r.contains(c));
      }
      isKeyword(word) {
        let { ranges } = this;
        for (let i = 0, l = word.length; i < l; i++) {
          let ch = word.charCodeAt(i);
          if (ch > 255)
            return false;
          if (ranges.some((r) => r.contains(ch)))
            continue;
          return false;
        }
        return true;
      }
    };
  }
});

// src/model/textdocument.ts
function computeLineOffsets2(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    let ch = text.charCodeAt(i);
    if (ch === 13 || ch === 10) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
var LinesTextDocument;
var init_textdocument = __esm({
  "src/model/textdocument.ts"() {
    LinesTextDocument = class {
      constructor(uri, languageId, version2, lines, eol) {
        this.uri = uri;
        this.languageId = languageId;
        this.version = version2;
        this.lines = lines;
        this.eol = eol;
      }
      get _content() {
        return this.lines.join("\n") + (this.eol ? "\n" : "");
      }
      get lineCount() {
        return this.lines.length + (this.eol ? 1 : 0);
      }
      getText(range) {
        if (range) {
          const start = this.offsetAt(range.start);
          const end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0;
        let high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          let mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        let line = low - 1;
        return { line, character: offset - lineOffsets[line] };
      }
      offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLineOffsets2(this._content, true);
        }
        return this._lineOffsets;
      }
    };
  }
});

// src/model/document.ts
var import_debounce3, import_vscode_languageserver_protocol9, logger18, Document;
var init_document = __esm({
  "src/model/document.ts"() {
    import_debounce3 = __toModule(require_debounce());
    import_vscode_languageserver_protocol9 = __toModule(require_main2());
    init_main2();
    init_esm2();
    init_events();
    init_diff();
    init_util();
    init_mutex();
    init_object();
    init_platform();
    init_string();
    init_chars();
    init_textdocument();
    logger18 = require_logger2()("model-document");
    Document = class {
      constructor(buffer, env, maxFileSize) {
        this.buffer = buffer;
        this.env = env;
        this.maxFileSize = maxFileSize;
        this.isIgnored = false;
        this.mutex = new Mutex();
        this._version = 1;
        this.size = 0;
        this.eol = true;
        this.lines = [];
        this.syncLines = [];
        this._attached = false;
        this._previewwindow = false;
        this._winid = -1;
        this._words = [];
        this._onDocumentChange = new import_vscode_languageserver_protocol9.Emitter();
        this._onDocumentDetach = new import_vscode_languageserver_protocol9.Emitter();
        this.disposables = [];
        this.onDocumentChange = this._onDocumentChange.event;
        this.onDocumentDetach = this._onDocumentDetach.event;
        this.fireContentChanges = (0, import_debounce3.default)(() => {
          this._fireContentChanges();
        }, 100);
        this.fetchContent = (0, import_debounce3.default)(() => {
          this._fetchContent().logError();
        }, 100);
      }
      get content() {
        return this.syncLines.join("\n") + (this.eol ? "\n" : "");
      }
      get version() {
        return this._version;
      }
      get bufnr() {
        return this.buffer.id;
      }
      get filetype() {
        return this._filetype;
      }
      get uri() {
        return this._uri;
      }
      get shouldAttach() {
        let { buftype, maxFileSize } = this;
        if (!this.getVar("enabled", true))
          return false;
        if (this.uri.endsWith("%5BCommand%20Line%5D"))
          return true;
        if (this.size == -2)
          return false;
        if (maxFileSize && this.size > maxFileSize)
          return false;
        return buftype == "" || buftype == "acwrite";
      }
      get isCommandLine() {
        return this.uri && this.uri.endsWith("%5BCommand%20Line%5D");
      }
      get enabled() {
        return this.getVar("enabled", true);
      }
      get words() {
        return this._words;
      }
      convertFiletype(filetype) {
        let map = this.env.filetypeMap;
        if (filetype == "javascript.jsx")
          return "javascriptreact";
        if (filetype == "typescript.jsx" || filetype == "typescript.tsx")
          return "typescriptreact";
        return map[filetype] || filetype;
      }
      get changedtick() {
        return this._changedtick;
      }
      get schema() {
        return URI.parse(this.uri).scheme;
      }
      get lineCount() {
        return this.lines.length;
      }
      get winid() {
        return this._winid;
      }
      get previewwindow() {
        return this._previewwindow;
      }
      async init(nvim, token) {
        this.nvim = nvim;
        let opts = await nvim.call("coc#util#get_bufoptions", [this.bufnr, this.maxFileSize]);
        if (opts == null)
          return false;
        let buftype = this.buftype = opts.buftype;
        this._previewwindow = opts.previewwindow;
        this._winid = opts.winid;
        this.size = typeof opts.size == "number" ? opts.size : 0;
        this.variables = opts.variables || {};
        this._changedtick = opts.changedtick;
        this.eol = opts.eol == 1;
        this._uri = getUri(opts.fullpath, this.bufnr, buftype, this.env.isCygwin);
        if (token.isCancellationRequested)
          return false;
        if (this.shouldAttach) {
          this.lines = opts.lines;
          this.syncLines = this.lines;
          let res = await this.attach();
          if (!res)
            return false;
          this._attached = true;
        }
        this._filetype = this.convertFiletype(opts.filetype);
        this.setIskeyword(opts.iskeyword);
        if (token.isCancellationRequested) {
          this.detach();
          return false;
        }
        return true;
      }
      async attach() {
        let attached = await this.buffer.attach(true);
        if (!attached)
          return false;
        this.buffer.listen("lines", this.onChange.bind(this), this.disposables);
        this.buffer.listen("detach", async (buf) => {
          this._onDocumentDetach.fire(buf.id);
        }, this.disposables);
        return true;
      }
      async onChange(buf, tick, firstline, lastline, linedata) {
        if (buf.id !== this.bufnr || !this._attached || tick == null)
          return;
        if (this.mutex.busy)
          return;
        if (tick > this._changedtick) {
          this._changedtick = tick;
          this.lines = [...this.lines.slice(0, firstline), ...linedata, ...this.lines.slice(lastline)];
          this.fireContentChanges();
        }
      }
      async checkDocument() {
        let { buffer } = this;
        let release = await this.mutex.acquire();
        this.fireContentChanges.clear();
        this._changedtick = await buffer.changedtick;
        this.lines = await buffer.lines;
        let changed = this._fireContentChanges();
        if (changed)
          await wait(30);
        release();
      }
      get dirty() {
        if (this.lines === this.syncLines)
          return false;
        return !equals(this.lines, this.syncLines);
      }
      _fireContentChanges() {
        let { cursor } = events_default;
        let { textDocument } = this;
        try {
          let endOffset = null;
          if (cursor && cursor.bufnr == this.bufnr) {
            endOffset = this.getEndOffset(cursor.lnum, cursor.col, cursor.insert);
          }
          let content = this.getDocumentContent();
          let change = getChange(textDocument.getText(), content, endOffset);
          if (change == null)
            return;
          let start = textDocument.positionAt(change.start);
          let end = textDocument.positionAt(change.end);
          let original = textDocument.getText(import_vscode_languageserver_protocol9.Range.create(start, end));
          this._version = this._version + 1;
          this.syncLines = this.lines;
          let changes = [{
            range: { start, end },
            rangeLength: change.end - change.start,
            text: change.newText
          }];
          this._onDocumentChange.fire({
            bufnr: this.bufnr,
            original,
            textDocument: { version: this.version, uri: this.uri },
            contentChanges: changes
          });
          this._words = this.chars.matchKeywords(content);
          return true;
        } catch (e) {
          logger18.error(e.message);
        }
        return false;
      }
      async applyEdits(edits) {
        if (!Array.isArray(arguments[0]) && Array.isArray(arguments[1])) {
          edits = arguments[1];
        }
        if (edits.length == 0)
          return;
        let current = this.getDocumentContent();
        let textDocument = TextDocument2.create(this.uri, this.filetype, 1, current);
        let applied = TextDocument2.applyEdits(textDocument, edits);
        if (isWindows2) {
          applied = applied.replace(/\r\n/g, "\n");
        }
        if (current !== applied) {
          let newLines = (this.eol && applied.endsWith("\n") ? applied.slice(0, -1) : applied).split("\n");
          let d = diffLines(this.lines, newLines);
          let release = await this.mutex.acquire();
          try {
            let res = await this.nvim.call("coc#util#set_lines", [this.bufnr, d.replacement, d.start, d.end]);
            this._changedtick = res.changedtick;
            this.lines = newLines;
            this.fireContentChanges.clear();
            this._fireContentChanges();
            if (!equals(newLines, res.lines)) {
              process.nextTick(() => {
                this.lines = res.lines;
                this.fireContentChanges.clear();
                this._fireContentChanges();
              });
            }
            release();
          } catch (e) {
            logger18.error("Error on applyEdits: ", e);
            release();
          }
        }
      }
      async changeLines(lines) {
        let filtered = [];
        let newLines = this.lines.slice();
        for (let [lnum, text] of lines) {
          if (newLines[lnum] != text) {
            filtered.push([lnum, text]);
            newLines[lnum] = text;
          }
        }
        if (!filtered.length)
          return;
        let release = await this.mutex.acquire();
        try {
          let res = await this.nvim.call("coc#util#change_lines", [this.bufnr, filtered]);
          if (res != null) {
            this.lines = newLines;
            this._changedtick = res.changedtick;
            this.fireContentChanges.clear();
            this._fireContentChanges();
            if (!equals(newLines, res.lines)) {
              process.nextTick(() => {
                this.lines = res.lines;
                this.fireContentChanges.clear();
                this._fireContentChanges();
              });
            }
          }
          release();
        } catch (e) {
          release();
        }
      }
      forceSync() {
        if (this.mutex.busy)
          return;
        this.fireContentChanges.clear();
        this._fireContentChanges();
      }
      getOffset(lnum, col) {
        return this.textDocument.offsetAt({
          line: lnum - 1,
          character: col
        });
      }
      isWord(word) {
        return this.chars.isKeyword(word);
      }
      getMoreWords() {
        let res = [];
        let { words, chars } = this;
        if (!chars.isKeywordChar("-"))
          return res;
        for (let word of words) {
          word = word.replace(/^-+/, "");
          if (word.includes("-")) {
            let parts = word.split("-");
            for (let part of parts) {
              if (part.length > 2 && !res.includes(part) && !words.includes(part)) {
                res.push(part);
              }
            }
          }
        }
        return res;
      }
      getWordRangeAtPosition(position, extraChars, current = true) {
        let chars = this.chars.clone();
        if (extraChars && extraChars.length) {
          for (let ch of extraChars) {
            chars.addKeyword(ch);
          }
        }
        let line = this.getline(position.line, current);
        if (line.length == 0 || position.character >= line.length)
          return null;
        if (!chars.isKeywordChar(line[position.character]))
          return null;
        let start = position.character;
        let end = position.character + 1;
        if (!chars.isKeywordChar(line[start])) {
          return import_vscode_languageserver_protocol9.Range.create(position, { line: position.line, character: position.character + 1 });
        }
        while (start >= 0) {
          let ch = line[start - 1];
          if (!ch || !chars.isKeyword(ch))
            break;
          start = start - 1;
        }
        while (end <= line.length) {
          let ch = line[end];
          if (!ch || !chars.isKeywordChar(ch))
            break;
          end = end + 1;
        }
        return import_vscode_languageserver_protocol9.Range.create(position.line, start, position.line, end);
      }
      get textDocument() {
        let { version: version2, filetype, uri } = this;
        return new LinesTextDocument(uri, filetype, version2, this.syncLines, this.eol);
      }
      async _fetchContent() {
        if (!this.env.isVim || !this._attached)
          return;
        let { nvim, bufnr, changedtick } = this;
        let release = await this.mutex.acquire();
        let o = await nvim.call("coc#util#get_buf_lines", [bufnr, changedtick]);
        if (o && o.changedtick >= this._changedtick) {
          this._changedtick = o.changedtick;
          this.lines = o.lines;
          this.fireContentChanges.clear();
          this._fireContentChanges();
        }
        release();
      }
      async patchChange(currentLine) {
        if (!this._attached)
          return;
        if (this.env.isVim) {
          if (currentLine) {
            let change = await this.nvim.call("coc#util#get_changeinfo", []);
            if (change.changedtick < this._changedtick)
              return;
            let { lnum, line, changedtick } = change;
            let newLines = this.lines.slice();
            this._changedtick = changedtick;
            if (newLines[lnum - 1] == line)
              return;
            newLines[lnum - 1] = line;
            this.lines = newLines;
            this.forceSync();
          } else {
            this.fetchContent.clear();
            await this._fetchContent();
          }
        } else {
          this._changedtick = await this.buffer.getVar("changedtick");
          this.forceSync();
        }
      }
      getSymbolRanges(word) {
        this.forceSync();
        let res = [];
        let { textDocument } = this;
        let content = textDocument.getText();
        let str = "";
        for (let i = 0, l = content.length; i < l; i++) {
          let ch = content[i];
          if (ch == "-" && str.length == 0) {
            continue;
          }
          let isKeyword = this.chars.isKeywordChar(ch);
          if (isKeyword) {
            str = str + ch;
          }
          if (str.length > 0 && !isKeyword && str == word) {
            res.push(import_vscode_languageserver_protocol9.Range.create(textDocument.positionAt(i - str.length), textDocument.positionAt(i)));
          }
          if (!isKeyword) {
            str = "";
          }
        }
        return res;
      }
      fixStartcol(position, valids) {
        let line = this.getline(position.line);
        if (!line)
          return null;
        let { character } = position;
        let start = line.slice(0, character);
        let col = byteLength(start);
        let { chars } = this;
        for (let i = start.length - 1; i >= 0; i--) {
          let c = start[i];
          if (c == " ")
            break;
          if (!chars.isKeywordChar(c) && !valids.includes(c)) {
            break;
          }
          col = col - byteLength(c);
        }
        return col;
      }
      getline(line, current = true) {
        if (current)
          return this.lines[line] || "";
        return this.syncLines[line] || "";
      }
      getLines(start, end) {
        return this.lines.slice(start, end);
      }
      getDocumentContent() {
        let content = this.lines.join("\n");
        return this.eol ? content + "\n" : content;
      }
      getVar(key, defaultValue) {
        let val = this.variables[`coc_${key}`];
        return val === void 0 ? defaultValue : val;
      }
      getPosition(lnum, col) {
        let line = this.getline(lnum - 1);
        if (!line || col == 0)
          return { line: lnum - 1, character: 0 };
        let pre = byteSlice(line, 0, col - 1);
        return { line: lnum - 1, character: pre.length };
      }
      getEndOffset(lnum, col, insert) {
        let total = 0;
        let len = this.lines.length;
        for (let i = lnum - 1; i < len; i++) {
          let line = this.lines[i];
          let l = line.length;
          if (i == lnum - 1 && l != 0) {
            let buf = global.Buffer.from(line, "utf8");
            let isEnd = buf.byteLength <= col - 1;
            if (!isEnd) {
              total = total + buf.slice(col - 1, buf.length).toString("utf8").length;
              if (!insert)
                total = total - 1;
            }
          } else {
            total = total + l;
          }
          if (!this.eol && i == len - 1)
            break;
          total = total + 1;
        }
        return total;
      }
      setFiletype(filetype) {
        this._filetype = this.convertFiletype(filetype);
        this._version = this._version + 1;
      }
      setIskeyword(iskeyword) {
        let chars = this.chars = new Chars(iskeyword);
        let additional = this.getVar("additional_keywords", []);
        if (additional && Array.isArray(additional)) {
          for (let ch of additional) {
            chars.addKeyword(ch);
          }
        }
        let lines = this.lines.length > 3e4 ? this.lines.slice(0, 3e4) : this.lines;
        this._words = this.chars.matchKeywords(lines.join("\n"));
      }
      get attached() {
        return this._attached;
      }
      detach() {
        this._attached = false;
        disposeAll(this.disposables);
        this.disposables = [];
        this.fetchContent.clear();
        this.fireContentChanges.clear();
        this._onDocumentChange.dispose();
        this._onDocumentDetach.dispose();
      }
      getLocalifyBonus(sp, ep) {
        let res = new Map();
        let { chars } = this;
        let startLine = Math.max(0, sp.line - 100);
        let endLine = Math.min(this.lineCount, sp.line + 100);
        let content = this.lines.slice(startLine, endLine).join("\n");
        sp = import_vscode_languageserver_protocol9.Position.create(sp.line - startLine, sp.character);
        ep = import_vscode_languageserver_protocol9.Position.create(ep.line - startLine, ep.character);
        let doc = TextDocument2.create(this.uri, this.filetype, 1, content);
        let headCount = doc.offsetAt(sp);
        let len = content.length;
        let tailCount = len - doc.offsetAt(ep);
        let start = 0;
        let preKeyword = false;
        for (let i = 0; i < headCount; i++) {
          let iskeyword = chars.isKeyword(content[i]);
          if (!preKeyword && iskeyword) {
            start = i;
          } else if (preKeyword && (!iskeyword || i == headCount - 1)) {
            if (i - start > 1) {
              let str = content.slice(start, i);
              res.set(str, i / headCount);
            }
          }
          preKeyword = iskeyword;
        }
        start = len - tailCount;
        preKeyword = false;
        for (let i = start; i < content.length; i++) {
          let iskeyword = chars.isKeyword(content[i]);
          if (!preKeyword && iskeyword) {
            start = i;
          } else if (preKeyword && (!iskeyword || i == len - 1)) {
            if (i - start > 1) {
              let end = i == len - 1 ? i + 1 : i;
              let str = content.slice(start, end);
              let score5 = res.get(str) || 0;
              res.set(str, Math.max(score5, (len - i + (end - start)) / tailCount));
            }
          }
          preKeyword = iskeyword;
        }
        return res;
      }
    };
  }
});

// src/util/array.ts
function splitArray(array, fn) {
  let res = [[], []];
  for (let item of array) {
    if (fn(item)) {
      res[0].push(item);
    } else {
      res[1].push(item);
    }
  }
  return res;
}
function group(array, size) {
  let len = array.length;
  let res = [];
  for (let i = 0; i < Math.ceil(len / size); i++) {
    res.push(array.slice(i * size, (i + 1) * size));
  }
  return res;
}
function distinct(array, keyFn) {
  if (!keyFn) {
    return array.filter((element, position) => array.indexOf(element) === position);
  }
  const seen = Object.create(null);
  return array.filter((elem) => {
    const key = keyFn(elem);
    if (seen[key]) {
      return false;
    }
    seen[key] = true;
    return true;
  });
}
var init_array = __esm({
  "src/util/array.ts"() {
  }
});

// src/model/fileSystemWatcher.ts
var import_vscode_languageserver_protocol10, import_minimatch2, import_path7, logger19, FileSystemWatcher;
var init_fileSystemWatcher = __esm({
  "src/model/fileSystemWatcher.ts"() {
    import_vscode_languageserver_protocol10 = __toModule(require_main2());
    init_esm2();
    import_minimatch2 = __toModule(require_minimatch());
    import_path7 = __toModule(require("path"));
    init_util();
    init_array();
    logger19 = require_logger2()("filesystem-watcher");
    FileSystemWatcher = class {
      constructor(clientPromise, globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        this.globPattern = globPattern;
        this.ignoreCreateEvents = ignoreCreateEvents;
        this.ignoreChangeEvents = ignoreChangeEvents;
        this.ignoreDeleteEvents = ignoreDeleteEvents;
        this._onDidCreate = new import_vscode_languageserver_protocol10.Emitter();
        this._onDidChange = new import_vscode_languageserver_protocol10.Emitter();
        this._onDidDelete = new import_vscode_languageserver_protocol10.Emitter();
        this._onDidRename = new import_vscode_languageserver_protocol10.Emitter();
        this.onDidCreate = this._onDidCreate.event;
        this.onDidChange = this._onDidChange.event;
        this.onDidDelete = this._onDidDelete.event;
        this.onDidRename = this._onDidRename.event;
        this.disposables = [];
        if (!clientPromise)
          return;
        clientPromise.then((client) => {
          if (client)
            return this.listen(client);
        }).catch((error) => {
          logger19.error("watchman initialize failed");
          logger19.error(error.stack);
        });
      }
      async listen(client) {
        let {
          globPattern,
          ignoreCreateEvents,
          ignoreChangeEvents,
          ignoreDeleteEvents
        } = this;
        let disposable = await client.subscribe(globPattern, (change) => {
          let { root, files } = change;
          files = files.filter((f) => f.type == "f" && (0, import_minimatch2.default)(f.name, globPattern, { dot: true }));
          for (let file of files) {
            let uri = URI.file(import_path7.default.join(root, file.name));
            if (!file.exists) {
              if (!ignoreDeleteEvents)
                this._onDidDelete.fire(uri);
            } else {
              if (file.new === true) {
                if (!ignoreCreateEvents)
                  this._onDidCreate.fire(uri);
              } else {
                if (!ignoreChangeEvents)
                  this._onDidChange.fire(uri);
              }
            }
          }
          if (files.length == 2 && !files[0].exists && files[1].exists) {
            let oldFile = files[0];
            let newFile = files[1];
            if (oldFile.size == newFile.size) {
              this._onDidRename.fire({
                oldUri: URI.file(import_path7.default.join(root, oldFile.name)),
                newUri: URI.file(import_path7.default.join(root, newFile.name))
              });
            }
          }
          if (files.length >= 2) {
            let [oldFiles, newFiles] = splitArray(files, (o) => o.exists === false);
            if (oldFiles.length == newFiles.length) {
              for (let oldFile of oldFiles) {
                let newFile = newFiles.find((o) => o.size == oldFile.size && o.mtime_ms == oldFile.mtime_ms);
                if (newFile) {
                  this._onDidRename.fire({
                    oldUri: URI.file(import_path7.default.join(root, oldFile.name)),
                    newUri: URI.file(import_path7.default.join(root, newFile.name))
                  });
                }
              }
            }
          }
        });
        this.disposables.push(disposable);
        return disposable;
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/model/mru.ts
var import_path8, import_fs_extra3, Mru;
var init_mru = __esm({
  "src/model/mru.ts"() {
    import_path8 = __toModule(require("path"));
    import_fs_extra3 = __toModule(require_lib5());
    Mru = class {
      constructor(name2, base) {
        this.name = name2;
        this.file = import_path8.default.join(base || process.env.COC_DATA_HOME, name2);
      }
      async load() {
        let dir = import_path8.default.dirname(this.file);
        try {
          import_fs_extra3.default.mkdirpSync(dir);
          if (!import_fs_extra3.default.existsSync(this.file)) {
            import_fs_extra3.default.writeFileSync(this.file, "", "utf8");
          }
          let content = await import_fs_extra3.default.readFile(this.file, "utf8");
          content = content.trim();
          return content.length ? content.trim().split("\n") : [];
        } catch (e) {
          return [];
        }
      }
      async add(item) {
        let items = await this.load();
        let idx = items.indexOf(item);
        if (idx !== -1)
          items.splice(idx, 1);
        items.unshift(item);
        import_fs_extra3.default.writeFileSync(this.file, items.join("\n"), "utf8");
      }
      async remove(item) {
        let items = await this.load();
        let idx = items.indexOf(item);
        if (idx !== -1) {
          items.splice(idx, 1);
          import_fs_extra3.default.writeFileSync(this.file, items.join("\n"), "utf8");
        }
      }
      async clean() {
        try {
          await import_fs_extra3.default.unlink(this.file);
        } catch (e) {
        }
      }
    };
  }
});

// src/util/decorator.ts
function memorize(_target, key, descriptor) {
  let fn = descriptor.value;
  if (typeof fn !== "function")
    return;
  let memoKey = "$" + key;
  descriptor.value = function(...args) {
    if (this.hasOwnProperty(memoKey))
      return Promise.resolve(this[memoKey]);
    return new Promise((resolve3, reject) => {
      Promise.resolve(fn.apply(this, args)).then((res) => {
        this[memoKey] = res;
        resolve3(res);
      }, (e) => {
        reject(e);
      });
    });
  };
}
var logger20;
var init_decorator = __esm({
  "src/util/decorator.ts"() {
    logger20 = require_logger2()("util-decorator");
  }
});

// src/model/resolver.ts
var import_path9, import_fs6, import_strip_ansi2, logger21, Resolver;
var init_resolver = __esm({
  "src/model/resolver.ts"() {
    import_path9 = __toModule(require("path"));
    import_fs6 = __toModule(require("fs"));
    init_util();
    init_fs();
    init_decorator();
    import_strip_ansi2 = __toModule(require_strip_ansi());
    logger21 = require_logger2()("model-resolver");
    Resolver = class {
      get nodeFolder() {
        if (!executable("npm"))
          return Promise.resolve("");
        return runCommand("npm --loglevel silent root -g", {}, 3e3).then((root) => {
          return (0, import_strip_ansi2.default)(root).trim();
        });
      }
      get yarnFolder() {
        if (!executable("yarnpkg"))
          return Promise.resolve("");
        return runCommand("yarnpkg global dir", {}, 3e3).then((root) => {
          let folder = import_path9.default.join((0, import_strip_ansi2.default)(root).trim(), "node_modules");
          let exists = import_fs6.default.existsSync(folder);
          return exists ? folder : "";
        });
      }
      async resolveModule(mod) {
        let nodeFolder = await this.nodeFolder;
        let yarnFolder = await this.yarnFolder;
        if (yarnFolder) {
          let s = await statAsync(import_path9.default.join(yarnFolder, mod, "package.json"));
          if (s && s.isFile())
            return import_path9.default.join(yarnFolder, mod);
        }
        if (nodeFolder) {
          let s = await statAsync(import_path9.default.join(nodeFolder, mod, "package.json"));
          if (s && s.isFile())
            return import_path9.default.join(nodeFolder, mod);
        }
        return null;
      }
    };
    __decorateClass([
      memorize
    ], Resolver.prototype, "nodeFolder", 1);
    __decorateClass([
      memorize
    ], Resolver.prototype, "yarnFolder", 1);
  }
});

// src/model/task.ts
var import_vscode_languageserver_protocol11, Task;
var init_task = __esm({
  "src/model/task.ts"() {
    init_events();
    import_vscode_languageserver_protocol11 = __toModule(require_main2());
    init_util();
    Task = class {
      constructor(nvim, id) {
        this.nvim = nvim;
        this.id = id;
        this.disposables = [];
        this._onExit = new import_vscode_languageserver_protocol11.Emitter();
        this._onStderr = new import_vscode_languageserver_protocol11.Emitter();
        this._onStdout = new import_vscode_languageserver_protocol11.Emitter();
        this.onExit = this._onExit.event;
        this.onStdout = this._onStdout.event;
        this.onStderr = this._onStderr.event;
        events_default.on("TaskExit", (id2, code) => {
          if (id2 == this.id) {
            this._onExit.fire(code);
          }
        }, null, this.disposables);
        events_default.on("TaskStderr", (id2, lines) => {
          if (id2 == this.id) {
            this._onStderr.fire(lines);
          }
        }, null, this.disposables);
        let stdout = [];
        let timer;
        events_default.on("TaskStdout", (id2, lines) => {
          if (id2 == this.id) {
            if (timer)
              clearTimeout(timer);
            stdout.push(...lines);
            timer = setTimeout(() => {
              this._onStdout.fire(stdout);
              stdout = [];
            }, 100);
          }
        }, null, this.disposables);
      }
      async start(opts) {
        let { nvim } = this;
        return await nvim.call("coc#task#start", [this.id, opts]);
      }
      async stop() {
        let { nvim } = this;
        await nvim.call("coc#task#stop", [this.id]);
      }
      get running() {
        let { nvim } = this;
        return nvim.call("coc#task#running", [this.id]);
      }
      dispose() {
        let { nvim } = this;
        nvim.call("coc#task#stop", [this.id], true);
        this._onStdout.dispose();
        this._onStderr.dispose();
        this._onExit.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/model/terminal.ts
var logger22, TerminalModel;
var init_terminal = __esm({
  "src/model/terminal.ts"() {
    logger22 = require_logger2()("model-terminal");
    TerminalModel = class {
      constructor(cmd, args, nvim, _name) {
        this.cmd = cmd;
        this.args = args;
        this.nvim = nvim;
        this._name = _name;
        this.pid = 0;
      }
      async start(cwd, env) {
        let { nvim } = this;
        let cmd = [this.cmd, ...this.args];
        let [bufnr, pid] = await nvim.call("coc#terminal#start", [cmd, cwd, env || {}]);
        this.bufnr = bufnr;
        this.pid = pid;
      }
      get name() {
        return this._name || this.cmd;
      }
      get processId() {
        return Promise.resolve(this.pid);
      }
      sendText(text, addNewLine = true) {
        if (!this.bufnr)
          return;
        this.nvim.call("coc#terminal#send", [this.bufnr, text, addNewLine], true);
      }
      async show(preserveFocus) {
        let { bufnr, nvim } = this;
        if (!bufnr)
          return;
        let [loaded, winid, curr] = await nvim.eval(`[bufloaded(${bufnr}),bufwinid(${bufnr}),win_getid()]`);
        if (!loaded)
          return false;
        if (curr == winid)
          return true;
        nvim.pauseNotification();
        if (winid == -1) {
          nvim.command(`below ${bufnr}sb`, true);
          nvim.command("resize 8", true);
          nvim.call("coc#util#do_autocmd", ["CocTerminalOpen"], true);
        } else {
          nvim.call("win_gotoid", [winid], true);
        }
        nvim.command("normal! G", true);
        if (preserveFocus) {
          nvim.command("wincmd p", true);
        }
        await nvim.resumeNotification();
        return true;
      }
      async hide() {
        let { bufnr, nvim } = this;
        if (!bufnr)
          return;
        let winnr = await nvim.call("bufwinnr", bufnr);
        if (winnr == -1)
          return;
        await nvim.command(`${winnr}close!`);
      }
      dispose() {
        let { bufnr, nvim } = this;
        if (!bufnr)
          return;
        nvim.call("coc#terminal#close", [bufnr], true);
      }
    };
  }
});

// src/model/bufferSync.ts
var BufferSync;
var init_bufferSync = __esm({
  "src/model/bufferSync.ts"() {
    init_util();
    BufferSync = class {
      constructor(_create, workspace) {
        this._create = _create;
        this.workspace = workspace;
        this.disposables = [];
        this.itemsMap = new Map();
        let { disposables } = this;
        for (let doc of workspace.documents) {
          this.create(doc);
        }
        workspace.onDidOpenTextDocument((e) => {
          let doc = workspace.getDocument(e.bufnr);
          if (doc)
            this.create(doc);
        }, null, disposables);
        workspace.onDidChangeTextDocument((e) => {
          this.onChange(e);
        }, null, disposables);
        workspace.onDidCloseTextDocument((e) => {
          this.delete(e.bufnr);
        }, null, disposables);
      }
      get items() {
        return Array.from(this.itemsMap.values()).map((x) => x.item);
      }
      getItem(bufnr) {
        var _a2;
        if (typeof bufnr === "number") {
          return (_a2 = this.itemsMap.get(bufnr)) == null ? void 0 : _a2.item;
        }
        let o = Array.from(this.itemsMap.values()).find((v) => {
          return v.uri == bufnr;
        });
        return o ? o.item : void 0;
      }
      create(doc) {
        if (!doc || doc.isCommandLine || !doc.attached)
          return;
        let o = this.itemsMap.get(doc.bufnr);
        if (o)
          o.item.dispose();
        let item = this._create(doc);
        if (item)
          this.itemsMap.set(doc.bufnr, { uri: doc.uri, item });
      }
      onChange(e) {
        let o = this.itemsMap.get(e.bufnr);
        if (o && typeof o.item.onChange == "function") {
          o.item.onChange(e);
        }
      }
      delete(bufnr) {
        let o = this.itemsMap.get(bufnr);
        if (o) {
          this.itemsMap.delete(bufnr);
          o.item.dispose();
        }
      }
      reset() {
        for (let o of this.itemsMap.values()) {
          o.item.dispose();
        }
        this.itemsMap.clear();
      }
      dispose() {
        disposeAll(this.disposables);
        for (let o of this.itemsMap.values()) {
          o.item.dispose();
        }
        this.itemsMap.clear();
      }
    };
  }
});

// src/util/match.ts
function score(selector, uri, languageId) {
  if (Array.isArray(selector)) {
    let ret = 0;
    for (const filter of selector) {
      const value = score(filter, uri, languageId);
      if (value === 10) {
        return value;
      }
      if (value > ret) {
        ret = value;
      }
    }
    return ret;
  } else if (typeof selector === "string") {
    if (selector === "*") {
      return 5;
    } else if (selector === languageId) {
      return 10;
    } else {
      return 0;
    }
  } else if (selector) {
    let u = URI.parse(uri);
    const { language: language2, pattern, scheme } = selector;
    let ret = 0;
    if (scheme) {
      if (scheme === u.scheme) {
        ret = 5;
      } else if (scheme === "*") {
        ret = 3;
      } else {
        return 0;
      }
    }
    if (language2) {
      if (language2 === languageId) {
        ret = 10;
      } else if (language2 === "*") {
        ret = Math.max(ret, 5);
      } else {
        return 0;
      }
    }
    if (pattern) {
      let caseInsensitive = isWindows2 || isMacintosh;
      let p = caseInsensitive ? pattern.toLowerCase() : pattern;
      let f = caseInsensitive ? u.fsPath.toLowerCase() : u.fsPath;
      if (p === f || (0, import_minimatch3.default)(f, p, { dot: true })) {
        ret = 5;
      } else {
        return 0;
      }
    }
    return ret;
  } else {
    return 0;
  }
}
var import_minimatch3;
var init_match = __esm({
  "src/util/match.ts"() {
    import_minimatch3 = __toModule(require_minimatch());
    init_esm2();
    init_platform();
  }
});

// node_modules/node-int64/Int64.js
var require_Int64 = __commonJS({
  "node_modules/node-int64/Int64.js"(exports2, module2) {
    var VAL32 = 4294967296;
    var _HEX = [];
    for (var i = 0; i < 256; i++) {
      _HEX[i] = (i > 15 ? "" : "0") + i.toString(16);
    }
    var Int64 = module2.exports = function(a1, a2) {
      if (a1 instanceof Buffer) {
        this.buffer = a1;
        this.offset = a2 || 0;
      } else if (Object.prototype.toString.call(a1) == "[object Uint8Array]") {
        this.buffer = new Buffer(a1);
        this.offset = a2 || 0;
      } else {
        this.buffer = this.buffer || new Buffer(8);
        this.offset = 0;
        this.setValue.apply(this, arguments);
      }
    };
    Int64.MAX_INT = Math.pow(2, 53);
    Int64.MIN_INT = -Math.pow(2, 53);
    Int64.prototype = {
      constructor: Int64,
      _2scomp: function() {
        var b = this.buffer, o = this.offset, carry = 1;
        for (var i2 = o + 7; i2 >= o; i2--) {
          var v = (b[i2] ^ 255) + carry;
          b[i2] = v & 255;
          carry = v >> 8;
        }
      },
      setValue: function(hi, lo) {
        var negate = false;
        if (arguments.length == 1) {
          if (typeof hi == "number") {
            negate = hi < 0;
            hi = Math.abs(hi);
            lo = hi % VAL32;
            hi = hi / VAL32;
            if (hi > VAL32)
              throw new RangeError(hi + " is outside Int64 range");
            hi = hi | 0;
          } else if (typeof hi == "string") {
            hi = (hi + "").replace(/^0x/, "");
            lo = hi.substr(-8);
            hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : "";
            hi = parseInt(hi, 16);
            lo = parseInt(lo, 16);
          } else {
            throw new Error(hi + " must be a Number or String");
          }
        }
        var b = this.buffer, o = this.offset;
        for (var i2 = 7; i2 >= 0; i2--) {
          b[o + i2] = lo & 255;
          lo = i2 == 4 ? hi : lo >>> 8;
        }
        if (negate)
          this._2scomp();
      },
      toNumber: function(allowImprecise) {
        var b = this.buffer, o = this.offset;
        var negate = b[o] & 128, x = 0, carry = 1;
        for (var i2 = 7, m = 1; i2 >= 0; i2--, m *= 256) {
          var v = b[o + i2];
          if (negate) {
            v = (v ^ 255) + carry;
            carry = v >> 8;
            v = v & 255;
          }
          x += v * m;
        }
        if (!allowImprecise && x >= Int64.MAX_INT) {
          return negate ? -Infinity : Infinity;
        }
        return negate ? -x : x;
      },
      valueOf: function() {
        return this.toNumber(false);
      },
      toString: function(radix) {
        return this.valueOf().toString(radix || 10);
      },
      toOctetString: function(sep) {
        var out = new Array(8);
        var b = this.buffer, o = this.offset;
        for (var i2 = 0; i2 < 8; i2++) {
          out[i2] = _HEX[b[o + i2]];
        }
        return out.join(sep || "");
      },
      toBuffer: function(rawBuffer) {
        if (rawBuffer && this.offset === 0)
          return this.buffer;
        var out = new Buffer(8);
        this.buffer.copy(out, 0, this.offset, this.offset + 8);
        return out;
      },
      copy: function(targetBuffer, targetOffset) {
        this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);
      },
      compare: function(other) {
        if ((this.buffer[this.offset] & 128) != (other.buffer[other.offset] & 128)) {
          return other.buffer[other.offset] - this.buffer[this.offset];
        }
        for (var i2 = 0; i2 < 8; i2++) {
          if (this.buffer[this.offset + i2] !== other.buffer[other.offset + i2]) {
            return this.buffer[this.offset + i2] - other.buffer[other.offset + i2];
          }
        }
        return 0;
      },
      equals: function(other) {
        return this.compare(other) === 0;
      },
      inspect: function() {
        return "[Int64 value:" + this + " octets:" + this.toOctetString(" ") + "]";
      }
    };
  }
});

// node_modules/bser/index.js
var require_bser = __commonJS({
  "node_modules/bser/index.js"(exports2) {
    var EE = require("events").EventEmitter;
    var util4 = require("util");
    var os11 = require("os");
    var assert = require("assert");
    var Int64 = require_Int64();
    var isBigEndian = os11.endianness() == "BE";
    function nextPow2(size) {
      return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));
    }
    function Accumulator(initsize) {
      this.buf = Buffer.alloc(nextPow2(initsize || 8192));
      this.readOffset = 0;
      this.writeOffset = 0;
    }
    exports2.Accumulator = Accumulator;
    Accumulator.prototype.writeAvail = function() {
      return this.buf.length - this.writeOffset;
    };
    Accumulator.prototype.readAvail = function() {
      return this.writeOffset - this.readOffset;
    };
    Accumulator.prototype.reserve = function(size) {
      if (size < this.writeAvail()) {
        return;
      }
      if (this.readOffset > 0) {
        this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);
        this.writeOffset -= this.readOffset;
        this.readOffset = 0;
      }
      if (size < this.writeAvail()) {
        return;
      }
      var buf = Buffer.alloc(nextPow2(this.buf.length + size - this.writeAvail()));
      this.buf.copy(buf);
      this.buf = buf;
    };
    Accumulator.prototype.append = function(buf) {
      if (Buffer.isBuffer(buf)) {
        this.reserve(buf.length);
        buf.copy(this.buf, this.writeOffset, 0, buf.length);
        this.writeOffset += buf.length;
      } else {
        var size = Buffer.byteLength(buf);
        this.reserve(size);
        this.buf.write(buf, this.writeOffset);
        this.writeOffset += size;
      }
    };
    Accumulator.prototype.assertReadableSize = function(size) {
      if (this.readAvail() < size) {
        throw new Error("wanted to read " + size + " bytes but only have " + this.readAvail());
      }
    };
    Accumulator.prototype.peekString = function(size) {
      this.assertReadableSize(size);
      return this.buf.toString("utf-8", this.readOffset, this.readOffset + size);
    };
    Accumulator.prototype.readString = function(size) {
      var str = this.peekString(size);
      this.readOffset += size;
      return str;
    };
    Accumulator.prototype.peekInt = function(size) {
      this.assertReadableSize(size);
      switch (size) {
        case 1:
          return this.buf.readInt8(this.readOffset, size);
        case 2:
          return isBigEndian ? this.buf.readInt16BE(this.readOffset, size) : this.buf.readInt16LE(this.readOffset, size);
        case 4:
          return isBigEndian ? this.buf.readInt32BE(this.readOffset, size) : this.buf.readInt32LE(this.readOffset, size);
        case 8:
          var big = this.buf.slice(this.readOffset, this.readOffset + 8);
          if (isBigEndian) {
            return new Int64(big);
          }
          return new Int64(byteswap64(big));
        default:
          throw new Error("invalid integer size " + size);
      }
    };
    Accumulator.prototype.readInt = function(bytes2) {
      var ival = this.peekInt(bytes2);
      if (ival instanceof Int64 && isFinite(ival.valueOf())) {
        ival = ival.valueOf();
      }
      this.readOffset += bytes2;
      return ival;
    };
    Accumulator.prototype.peekDouble = function() {
      this.assertReadableSize(8);
      return isBigEndian ? this.buf.readDoubleBE(this.readOffset) : this.buf.readDoubleLE(this.readOffset);
    };
    Accumulator.prototype.readDouble = function() {
      var dval = this.peekDouble();
      this.readOffset += 8;
      return dval;
    };
    Accumulator.prototype.readAdvance = function(size) {
      if (size > 0) {
        this.assertReadableSize(size);
      } else if (size < 0 && this.readOffset + size < 0) {
        throw new Error("advance with negative offset " + size + " would seek off the start of the buffer");
      }
      this.readOffset += size;
    };
    Accumulator.prototype.writeByte = function(value) {
      this.reserve(1);
      this.buf.writeInt8(value, this.writeOffset);
      ++this.writeOffset;
    };
    Accumulator.prototype.writeInt = function(value, size) {
      this.reserve(size);
      switch (size) {
        case 1:
          this.buf.writeInt8(value, this.writeOffset);
          break;
        case 2:
          if (isBigEndian) {
            this.buf.writeInt16BE(value, this.writeOffset);
          } else {
            this.buf.writeInt16LE(value, this.writeOffset);
          }
          break;
        case 4:
          if (isBigEndian) {
            this.buf.writeInt32BE(value, this.writeOffset);
          } else {
            this.buf.writeInt32LE(value, this.writeOffset);
          }
          break;
        default:
          throw new Error("unsupported integer size " + size);
      }
      this.writeOffset += size;
    };
    Accumulator.prototype.writeDouble = function(value) {
      this.reserve(8);
      if (isBigEndian) {
        this.buf.writeDoubleBE(value, this.writeOffset);
      } else {
        this.buf.writeDoubleLE(value, this.writeOffset);
      }
      this.writeOffset += 8;
    };
    var BSER_ARRAY = 0;
    var BSER_OBJECT = 1;
    var BSER_STRING = 2;
    var BSER_INT8 = 3;
    var BSER_INT16 = 4;
    var BSER_INT32 = 5;
    var BSER_INT64 = 6;
    var BSER_REAL = 7;
    var BSER_TRUE = 8;
    var BSER_FALSE = 9;
    var BSER_NULL = 10;
    var BSER_TEMPLATE = 11;
    var BSER_SKIP = 12;
    var ST_NEED_PDU = 0;
    var ST_FILL_PDU = 1;
    var MAX_INT8 = 127;
    var MAX_INT16 = 32767;
    var MAX_INT32 = 2147483647;
    function BunserBuf() {
      EE.call(this);
      this.buf = new Accumulator();
      this.state = ST_NEED_PDU;
    }
    util4.inherits(BunserBuf, EE);
    exports2.BunserBuf = BunserBuf;
    BunserBuf.prototype.append = function(buf, synchronous) {
      if (synchronous) {
        this.buf.append(buf);
        return this.process(synchronous);
      }
      try {
        this.buf.append(buf);
      } catch (err) {
        this.emit("error", err);
        return;
      }
      this.processLater();
    };
    BunserBuf.prototype.processLater = function() {
      var self2 = this;
      process.nextTick(function() {
        try {
          self2.process(false);
        } catch (err) {
          self2.emit("error", err);
        }
      });
    };
    BunserBuf.prototype.process = function(synchronous) {
      if (this.state == ST_NEED_PDU) {
        if (this.buf.readAvail() < 2) {
          return;
        }
        this.expectCode(0);
        this.expectCode(1);
        this.pduLen = this.decodeInt(true);
        if (this.pduLen === false) {
          this.buf.readAdvance(-2);
          return;
        }
        this.buf.reserve(this.pduLen);
        this.state = ST_FILL_PDU;
      }
      if (this.state == ST_FILL_PDU) {
        if (this.buf.readAvail() < this.pduLen) {
          return;
        }
        var val = this.decodeAny();
        if (synchronous) {
          return val;
        }
        this.emit("value", val);
        this.state = ST_NEED_PDU;
      }
      if (!synchronous && this.buf.readAvail() > 0) {
        this.processLater();
      }
    };
    BunserBuf.prototype.raise = function(reason) {
      throw new Error(reason + ", in Buffer of length " + this.buf.buf.length + " (" + this.buf.readAvail() + " readable) at offset " + this.buf.readOffset + " buffer: " + JSON.stringify(this.buf.buf.slice(this.buf.readOffset, this.buf.readOffset + 32).toJSON()));
    };
    BunserBuf.prototype.expectCode = function(expected) {
      var code = this.buf.readInt(1);
      if (code != expected) {
        this.raise("expected bser opcode " + expected + " but got " + code);
      }
    };
    BunserBuf.prototype.decodeAny = function() {
      var code = this.buf.peekInt(1);
      switch (code) {
        case BSER_INT8:
        case BSER_INT16:
        case BSER_INT32:
        case BSER_INT64:
          return this.decodeInt();
        case BSER_REAL:
          this.buf.readAdvance(1);
          return this.buf.readDouble();
        case BSER_TRUE:
          this.buf.readAdvance(1);
          return true;
        case BSER_FALSE:
          this.buf.readAdvance(1);
          return false;
        case BSER_NULL:
          this.buf.readAdvance(1);
          return null;
        case BSER_STRING:
          return this.decodeString();
        case BSER_ARRAY:
          return this.decodeArray();
        case BSER_OBJECT:
          return this.decodeObject();
        case BSER_TEMPLATE:
          return this.decodeTemplate();
        default:
          this.raise("unhandled bser opcode " + code);
      }
    };
    BunserBuf.prototype.decodeArray = function() {
      this.expectCode(BSER_ARRAY);
      var nitems = this.decodeInt();
      var arr = [];
      for (var i = 0; i < nitems; ++i) {
        arr.push(this.decodeAny());
      }
      return arr;
    };
    BunserBuf.prototype.decodeObject = function() {
      this.expectCode(BSER_OBJECT);
      var nitems = this.decodeInt();
      var res = {};
      for (var i = 0; i < nitems; ++i) {
        var key = this.decodeString();
        var val = this.decodeAny();
        res[key] = val;
      }
      return res;
    };
    BunserBuf.prototype.decodeTemplate = function() {
      this.expectCode(BSER_TEMPLATE);
      var keys = this.decodeArray();
      var nitems = this.decodeInt();
      var arr = [];
      for (var i = 0; i < nitems; ++i) {
        var obj = {};
        for (var keyidx = 0; keyidx < keys.length; ++keyidx) {
          if (this.buf.peekInt(1) == BSER_SKIP) {
            this.buf.readAdvance(1);
            continue;
          }
          var val = this.decodeAny();
          obj[keys[keyidx]] = val;
        }
        arr.push(obj);
      }
      return arr;
    };
    BunserBuf.prototype.decodeString = function() {
      this.expectCode(BSER_STRING);
      var len = this.decodeInt();
      return this.buf.readString(len);
    };
    BunserBuf.prototype.decodeInt = function(relaxSizeAsserts) {
      if (relaxSizeAsserts && this.buf.readAvail() < 1) {
        return false;
      } else {
        this.buf.assertReadableSize(1);
      }
      var code = this.buf.peekInt(1);
      var size = 0;
      switch (code) {
        case BSER_INT8:
          size = 1;
          break;
        case BSER_INT16:
          size = 2;
          break;
        case BSER_INT32:
          size = 4;
          break;
        case BSER_INT64:
          size = 8;
          break;
        default:
          this.raise("invalid bser int encoding " + code);
      }
      if (relaxSizeAsserts && this.buf.readAvail() < 1 + size) {
        return false;
      }
      this.buf.readAdvance(1);
      return this.buf.readInt(size);
    };
    function loadFromBuffer(input) {
      var buf = new BunserBuf();
      var result = buf.append(input, true);
      if (buf.buf.readAvail()) {
        throw Error("excess data found after input buffer, use BunserBuf instead");
      }
      if (typeof result === "undefined") {
        throw Error("no bser found in string and no error raised!?");
      }
      return result;
    }
    exports2.loadFromBuffer = loadFromBuffer;
    function byteswap64(buf) {
      var swap = Buffer.alloc(buf.length);
      for (var i = 0; i < buf.length; i++) {
        swap[i] = buf[buf.length - 1 - i];
      }
      return swap;
    }
    function dump_int64(buf, val) {
      var be = val.toBuffer();
      if (isBigEndian) {
        buf.writeByte(BSER_INT64);
        buf.append(be);
        return;
      }
      var le = byteswap64(be);
      buf.writeByte(BSER_INT64);
      buf.append(le);
    }
    function dump_int(buf, val) {
      var abs = Math.abs(val);
      if (abs <= MAX_INT8) {
        buf.writeByte(BSER_INT8);
        buf.writeInt(val, 1);
      } else if (abs <= MAX_INT16) {
        buf.writeByte(BSER_INT16);
        buf.writeInt(val, 2);
      } else if (abs <= MAX_INT32) {
        buf.writeByte(BSER_INT32);
        buf.writeInt(val, 4);
      } else {
        dump_int64(buf, new Int64(val));
      }
    }
    function dump_any(buf, val) {
      switch (typeof val) {
        case "number":
          if (isFinite(val) && Math.floor(val) === val) {
            dump_int(buf, val);
          } else {
            buf.writeByte(BSER_REAL);
            buf.writeDouble(val);
          }
          return;
        case "string":
          buf.writeByte(BSER_STRING);
          dump_int(buf, Buffer.byteLength(val));
          buf.append(val);
          return;
        case "boolean":
          buf.writeByte(val ? BSER_TRUE : BSER_FALSE);
          return;
        case "object":
          if (val === null) {
            buf.writeByte(BSER_NULL);
            return;
          }
          if (val instanceof Int64) {
            dump_int64(buf, val);
            return;
          }
          if (Array.isArray(val)) {
            buf.writeByte(BSER_ARRAY);
            dump_int(buf, val.length);
            for (var i = 0; i < val.length; ++i) {
              dump_any(buf, val[i]);
            }
            return;
          }
          buf.writeByte(BSER_OBJECT);
          var keys = Object.keys(val);
          var num_keys = keys.length;
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var v = val[key];
            if (typeof v == "undefined") {
              num_keys--;
            }
          }
          dump_int(buf, num_keys);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var v = val[key];
            if (typeof v == "undefined") {
              continue;
            }
            dump_any(buf, key);
            try {
              dump_any(buf, v);
            } catch (e) {
              throw new Error(e.message + " (while serializing object property with name `" + key + "')");
            }
          }
          return;
        default:
          throw new Error("cannot serialize type " + typeof val + " to BSER");
      }
    }
    function dumpToBuffer(val) {
      var buf = new Accumulator();
      buf.writeByte(0);
      buf.writeByte(1);
      buf.writeByte(BSER_INT32);
      buf.writeInt(0, 4);
      dump_any(buf, val);
      var off = buf.writeOffset;
      var len = off - 7;
      buf.writeOffset = 3;
      buf.writeInt(len, 4);
      buf.writeOffset = off;
      return buf.buf.slice(0, off);
    }
    exports2.dumpToBuffer = dumpToBuffer;
  }
});

// node_modules/fb-watchman/index.js
var require_fb_watchman = __commonJS({
  "node_modules/fb-watchman/index.js"(exports2, module2) {
    "use strict";
    var net3 = require("net");
    var EE = require("events").EventEmitter;
    var util4 = require("util");
    var childProcess = require("child_process");
    var bser = require_bser();
    var unilateralTags = ["subscription", "log"];
    function Client2(options) {
      var self2 = this;
      EE.call(this);
      this.watchmanBinaryPath = "watchman";
      if (options && options.watchmanBinaryPath) {
        this.watchmanBinaryPath = options.watchmanBinaryPath.trim();
      }
      ;
      this.commands = [];
    }
    util4.inherits(Client2, EE);
    module2.exports.Client = Client2;
    Client2.prototype.sendNextCommand = function() {
      if (this.currentCommand) {
        return;
      }
      this.currentCommand = this.commands.shift();
      if (!this.currentCommand) {
        return;
      }
      this.socket.write(bser.dumpToBuffer(this.currentCommand.cmd));
    };
    Client2.prototype.cancelCommands = function(why) {
      var error = new Error(why);
      var cmds = this.commands;
      this.commands = [];
      if (this.currentCommand) {
        cmds.unshift(this.currentCommand);
        this.currentCommand = null;
      }
      cmds.forEach(function(cmd) {
        cmd.cb(error);
      });
    };
    Client2.prototype.connect = function() {
      var self2 = this;
      function makeSock(sockname) {
        self2.bunser = new bser.BunserBuf();
        self2.bunser.on("value", function(obj) {
          var unilateral = false;
          for (var i = 0; i < unilateralTags.length; i++) {
            var tag = unilateralTags[i];
            if (tag in obj) {
              unilateral = tag;
            }
          }
          if (unilateral) {
            self2.emit(unilateral, obj);
          } else if (self2.currentCommand) {
            var cmd = self2.currentCommand;
            self2.currentCommand = null;
            if ("error" in obj) {
              var error = new Error(obj.error);
              error.watchmanResponse = obj;
              cmd.cb(error);
            } else {
              cmd.cb(null, obj);
            }
          }
          self2.sendNextCommand();
        });
        self2.bunser.on("error", function(err) {
          self2.emit("error", err);
        });
        self2.socket = net3.createConnection(sockname);
        self2.socket.on("connect", function() {
          self2.connecting = false;
          self2.emit("connect");
          self2.sendNextCommand();
        });
        self2.socket.on("error", function(err) {
          self2.connecting = false;
          self2.emit("error", err);
        });
        self2.socket.on("data", function(buf) {
          if (self2.bunser) {
            self2.bunser.append(buf);
          }
        });
        self2.socket.on("end", function() {
          self2.socket = null;
          self2.bunser = null;
          self2.cancelCommands("The watchman connection was closed");
          self2.emit("end");
        });
      }
      if (process.env.WATCHMAN_SOCK) {
        makeSock(process.env.WATCHMAN_SOCK);
        return;
      }
      var args = ["--no-pretty", "get-sockname"];
      var proc = null;
      var spawnFailed = false;
      function spawnError(error) {
        if (spawnFailed) {
          return;
        }
        spawnFailed = true;
        if (error.errno === "EACCES") {
          error.message = "The Watchman CLI is installed but cannot be spawned because of a permission problem";
        } else if (error.errno === "ENOENT") {
          error.message = "Watchman was not found in PATH.  See https://facebook.github.io/watchman/docs/install.html for installation instructions";
        }
        console.error("Watchman: ", error.message);
        self2.emit("error", error);
      }
      try {
        proc = childProcess.spawn(this.watchmanBinaryPath, args, {
          stdio: ["ignore", "pipe", "pipe"]
        });
      } catch (error) {
        spawnError(error);
        return;
      }
      var stdout = [];
      var stderr = [];
      proc.stdout.on("data", function(data) {
        stdout.push(data);
      });
      proc.stderr.on("data", function(data) {
        data = data.toString("utf8");
        stderr.push(data);
        console.error(data);
      });
      proc.on("error", function(error) {
        spawnError(error);
      });
      proc.on("close", function(code, signal) {
        if (code !== 0) {
          spawnError(new Error(self2.watchmanBinaryPath + " " + args.join(" ") + " returned with exit code=" + code + ", signal=" + signal + ", stderr= " + stderr.join("")));
          return;
        }
        try {
          var obj = JSON.parse(stdout.join(""));
          if ("error" in obj) {
            var error = new Error(obj.error);
            error.watchmanResponse = obj;
            self2.emit("error", error);
            return;
          }
          makeSock(obj.sockname);
        } catch (e) {
          self2.emit("error", e);
        }
      });
    };
    Client2.prototype.command = function(args, done) {
      done = done || function() {
      };
      this.commands.push({ cmd: args, cb: done });
      if (!this.socket) {
        if (!this.connecting) {
          this.connecting = true;
          this.connect();
          return;
        }
        return;
      }
      this.sendNextCommand();
    };
    var cap_versions = {
      "cmd-watch-del-all": "3.1.1",
      "cmd-watch-project": "3.1",
      "relative_root": "3.3",
      "term-dirname": "3.1",
      "term-idirname": "3.1",
      "wildmatch": "3.7"
    };
    function vers_compare(a, b) {
      a = a.split(".");
      b = b.split(".");
      for (var i = 0; i < 3; i++) {
        var d = parseInt(a[i] || "0") - parseInt(b[i] || "0");
        if (d != 0) {
          return d;
        }
      }
      return 0;
    }
    function have_cap(vers, name2) {
      if (name2 in cap_versions) {
        return vers_compare(vers, cap_versions[name2]) >= 0;
      }
      return false;
    }
    Client2.prototype._synthesizeCapabilityCheck = function(resp, optional, required) {
      resp.capabilities = {};
      var version2 = resp.version;
      optional.forEach(function(name2) {
        resp.capabilities[name2] = have_cap(version2, name2);
      });
      required.forEach(function(name2) {
        var have = have_cap(version2, name2);
        resp.capabilities[name2] = have;
        if (!have) {
          resp.error = "client required capability `" + name2 + "` is not supported by this server";
        }
      });
      return resp;
    };
    Client2.prototype.capabilityCheck = function(caps, done) {
      var optional = caps.optional || [];
      var required = caps.required || [];
      var self2 = this;
      this.command(["version", {
        optional,
        required
      }], function(error, resp) {
        if (error) {
          done(error);
          return;
        }
        if (!("capabilities" in resp)) {
          resp = self2._synthesizeCapabilityCheck(resp, optional, required);
          if (resp.error) {
            error = new Error(resp.error);
            error.watchmanResponse = resp;
            done(error);
            return;
          }
        }
        done(null, resp);
      });
    };
    Client2.prototype.end = function() {
      this.cancelCommands("The client was ended");
      if (this.socket) {
        this.socket.end();
        this.socket = null;
      }
      this.bunser = null;
    };
  }
});

// src/watchman.ts
function isValidWatchRoot(root) {
  if (root == "/" || root == "/tmp" || root == "/private/tmp")
    return false;
  if (root.toLowerCase() === import_os3.default.homedir().toLowerCase())
    return false;
  if (import_path10.default.parse(root).base == root)
    return false;
  if (root.startsWith("/tmp/") || root.startsWith("/private/tmp/"))
    return false;
  if (isParentFolder(import_os3.default.tmpdir(), root, true))
    return false;
  return true;
}
var import_fb_watchman, import_os3, import_path10, import_vscode_languageserver_protocol12, import_minimatch4, logger23, requiredCapabilities, clientsMap, Watchman;
var init_watchman = __esm({
  "src/watchman.ts"() {
    import_fb_watchman = __toModule(require_fb_watchman());
    import_os3 = __toModule(require("os"));
    import_path10 = __toModule(require("path"));
    init_esm_node();
    import_vscode_languageserver_protocol12 = __toModule(require_main2());
    import_minimatch4 = __toModule(require_minimatch());
    init_fs();
    logger23 = require_logger2()("watchman");
    requiredCapabilities = ["relative_root", "cmd-watch-project", "wildmatch", "field-new"];
    clientsMap = new Map();
    Watchman = class {
      constructor(binaryPath, channel) {
        this.channel = channel;
        this._disposed = false;
        this.client = new import_fb_watchman.default.Client({
          watchmanBinaryPath: binaryPath
        });
        this.client.setMaxListeners(300);
      }
      checkCapability() {
        let { client } = this;
        return new Promise((resolve3, reject) => {
          client.capabilityCheck({
            optional: [],
            required: requiredCapabilities
          }, (error, resp) => {
            if (error)
              return reject(error);
            let { capabilities } = resp;
            for (let key of Object.keys(capabilities)) {
              if (!capabilities[key])
                return resolve3(false);
            }
            resolve3(true);
          });
        });
      }
      async watchProject(root) {
        try {
          let resp = await this.command(["watch-project", root]);
          let { watch, warning, relative_path } = resp;
          if (warning)
            logger23.warn(warning);
          this.watch = watch;
          this.relative_path = relative_path;
          logger23.info(`watchman watching project: ${root}`);
          this.appendOutput(`watchman watching project: ${root}`);
        } catch (e) {
          logger23.error(e);
          return false;
        }
        return true;
      }
      command(args) {
        return new Promise((resolve3, reject) => {
          this.client.command(args, (error, resp) => {
            if (error)
              return reject(error);
            resolve3(resp);
          });
        });
      }
      async subscribe(globPattern, cb) {
        let { watch, relative_path } = this;
        if (!watch) {
          this.appendOutput(`watchman not watching: ${watch}`, "Error");
          return null;
        }
        let { clock } = await this.command(["clock", watch]);
        let uid = v1_default();
        let sub = {
          expression: ["allof", ["match", "**/*", "wholename"]],
          fields: ["name", "size", "new", "exists", "type", "mtime_ms", "ctime_ms"],
          since: clock
        };
        let root = watch;
        if (relative_path) {
          sub.relative_root = relative_path;
          root = import_path10.default.join(watch, relative_path);
        }
        let { subscribe } = await this.command(["subscribe", watch, uid, sub]);
        if (global.hasOwnProperty("__TEST__"))
          global.subscribe = subscribe;
        this.appendOutput(`subscribing "${globPattern}" in ${root}`);
        this.client.on("subscription", (resp) => {
          if (!resp || resp.subscription != uid)
            return;
          let { files } = resp;
          if (!files)
            return;
          files = files.filter((f) => f.type == "f" && (0, import_minimatch4.default)(f.name, globPattern, { dot: true }));
          if (!files.length)
            return;
          let ev = Object.assign({}, resp);
          if (this.relative_path)
            ev.root = import_path10.default.resolve(resp.root, this.relative_path);
          this.appendOutput(`file change detected: ${JSON.stringify(ev, null, 2)}`);
          cb(ev);
        });
        return import_vscode_languageserver_protocol12.Disposable.create(() => this.unsubscribe(subscribe));
      }
      unsubscribe(subscription) {
        if (this._disposed)
          return Promise.resolve();
        let { watch } = this;
        if (!watch)
          return;
        this.appendOutput(`unsubscribe "${subscription}" in: ${watch}`);
        return this.command(["unsubscribe", watch, subscription]).catch((e) => {
          logger23.error(e);
        });
      }
      dispose() {
        if (this._disposed)
          return;
        this._disposed = true;
        this.client.removeAllListeners();
        this.client.end();
      }
      appendOutput(message, type = "Info") {
        if (this.channel) {
          this.channel.appendLine(`[${type}  - ${new Date().toLocaleTimeString()}] ${message}`);
        }
      }
      static dispose() {
        for (let promise of clientsMap.values()) {
          promise.then((client) => {
            client.dispose();
          }, (_e) => {
          });
        }
      }
      static createClient(binaryPath, root, channel) {
        if (!isValidWatchRoot(root))
          return null;
        let client = clientsMap.get(root);
        if (client)
          return client;
        let promise = new Promise(async (resolve3, reject) => {
          try {
            let watchman2 = new Watchman(binaryPath, channel);
            let valid = await watchman2.checkCapability();
            if (!valid)
              return resolve3(null);
            let watching = await watchman2.watchProject(root);
            if (!watching)
              return resolve3(null);
            resolve3(watchman2);
          } catch (e) {
            reject(e);
          }
        });
        clientsMap.set(root, promise);
        return promise;
      }
    };
  }
});

// package.json
var version;
var init_package = __esm({
  "package.json"() {
    version = "0.0.80";
  }
});

// src/workspace.ts
var import_bytes, import_fast_diff2, import_fs_extra4, import_os4, import_path11, import_vscode_languageserver_protocol13, import_which2, APIVERSION, logger24, NAME_SPACE, methods, Workspace, workspace_default;
var init_workspace = __esm({
  "src/workspace.ts"() {
    import_bytes = __toModule(require_bytes());
    import_fast_diff2 = __toModule(require_diff2());
    import_fs_extra4 = __toModule(require_lib5());
    import_os4 = __toModule(require("os"));
    import_path11 = __toModule(require("path"));
    init_esm_node();
    import_vscode_languageserver_protocol13 = __toModule(require_main2());
    init_esm2();
    import_which2 = __toModule(require_which());
    init_channels();
    init_configuration2();
    init_shape();
    init_events();
    init_db();
    init_document();
    init_fileSystemWatcher();
    init_mru();
    init_resolver();
    init_task();
    init_terminal();
    init_bufferSync();
    init_types();
    init_array();
    init_fs();
    init_util();
    init_match();
    init_position();
    init_string();
    init_watchman();
    init_window();
    init_package();
    APIVERSION = 8;
    logger24 = require_logger2()("workspace");
    NAME_SPACE = 2e3;
    methods = [
      "showMessage",
      "runTerminalCommand",
      "openTerminal",
      "showQuickpick",
      "menuPick",
      "openLocalConfig",
      "showPrompt",
      "createStatusBarItem",
      "createOutputChannel",
      "showOutputChannel",
      "requestInput",
      "echoLines",
      "getCursorPosition",
      "moveTo",
      "getOffset"
    ];
    Workspace = class {
      constructor() {
        this.keymaps = new Map();
        this.resolver = new Resolver();
        this.rootPatterns = new Map();
        this._workspaceFolders = [];
        this._insertMode = false;
        this._cwd = process.cwd();
        this._initialized = false;
        this._attached = false;
        this.buffers = new Map();
        this.autocmdMaxId = 0;
        this.autocmds = new Map();
        this.terminals = new Map();
        this.creatingSources = new Map();
        this.schemeProviderMap = new Map();
        this.namespaceMap = new Map();
        this.disposables = [];
        this.watchedOptions = new Set();
        this._dynAutocmd = false;
        this._disposed = false;
        this._onDidOpenDocument = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidCloseDocument = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidChangeDocument = new import_vscode_languageserver_protocol13.Emitter();
        this._onWillSaveDocument = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidSaveDocument = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidChangeWorkspaceFolders = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidChangeConfiguration = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidWorkspaceInitialized = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidOpenTerminal = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidCloseTerminal = new import_vscode_languageserver_protocol13.Emitter();
        this._onDidRuntimePathChange = new import_vscode_languageserver_protocol13.Emitter();
        this.onDidCloseTerminal = this._onDidCloseTerminal.event;
        this.onDidOpenTerminal = this._onDidOpenTerminal.event;
        this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
        this.onDidOpenTextDocument = this._onDidOpenDocument.event;
        this.onDidCloseTextDocument = this._onDidCloseDocument.event;
        this.onDidChangeTextDocument = this._onDidChangeDocument.event;
        this.onWillSaveTextDocument = this._onWillSaveDocument.event;
        this.onDidSaveTextDocument = this._onDidSaveDocument.event;
        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
        this.onDidWorkspaceInitialized = this._onDidWorkspaceInitialized.event;
        this.onDidRuntimePathChange = this._onDidRuntimePathChange.event;
        this.version = version;
        this.configurations = this.createConfigurations();
        let cwd = process.cwd();
        if (cwd != import_os4.default.homedir() && inDirectory(cwd, [".vim"])) {
          this._workspaceFolders.push({
            uri: URI.file(cwd).toString(),
            name: import_path11.default.basename(cwd)
          });
        }
      }
      async init() {
        let { nvim } = this;
        for (let method of methods) {
          Object.defineProperty(this, method, {
            get: () => {
              return (...args) => {
                return window_default[method].apply(window_default, args);
              };
            }
          });
        }
        this._env = await nvim.call("coc#util#vim_info");
        if (this._env.apiversion != APIVERSION) {
          console.error(`API version ${this._env.apiversion} is not ${APIVERSION}, please build coc.nvim by 'yarn install' after pull source code.`);
          process.exit();
        }
        this._insertMode = this._env.mode.startsWith("insert");
        let preferences = this.getConfiguration("coc.preferences");
        let maxFileSize = preferences.get("maxFileSize", "10MB");
        this.maxFileSize = import_bytes.default.parse(maxFileSize);
        if (this._env.workspaceFolders && Array.isArray(this._env.workspaceFolders)) {
          this._workspaceFolders = this._env.workspaceFolders.map((f) => ({
            uri: URI.file(f).toString(),
            name: import_path11.default.dirname(f)
          }));
        }
        this.configurations.updateUserConfig(this._env.config);
        events_default.on(["InsertEnter", "CursorMovedI"], () => {
          this._insertMode = true;
        }, null, this.disposables);
        events_default.on(["InsertLeave", "CursorMoved"], () => {
          this._insertMode = false;
        }, null, this.disposables);
        let forceSync = async (bufnr) => {
          let doc = this.getDocument(bufnr);
          if (doc)
            doc.forceSync();
        };
        events_default.on("InsertLeave", forceSync, null, this.disposables);
        events_default.on("CursorHold", forceSync, null, this.disposables);
        events_default.on("BufEnter", this.onBufEnter, this, this.disposables);
        events_default.on("CursorMoved", this.checkCurrentBuffer, this, this.disposables);
        events_default.on("CursorMovedI", this.checkCurrentBuffer, this, this.disposables);
        events_default.on("DirChanged", this.onDirChanged, this, this.disposables);
        events_default.on("BufCreate", this.onBufCreate, this, this.disposables);
        events_default.on("BufUnload", this.onBufUnload, this, this.disposables);
        events_default.on("TermOpen", this.onBufCreate, this, this.disposables);
        events_default.on("TermClose", this.onBufUnload, this, this.disposables);
        events_default.on("BufWritePost", this.onBufWritePost, this, this.disposables);
        events_default.on("BufWritePre", this.onBufWritePre, this, this.disposables);
        events_default.on("FileType", this.onFileTypeChange, this, this.disposables);
        events_default.on("CursorHold", this.checkCurrentBuffer, this, this.disposables);
        events_default.on("TextChanged", this.checkBuffer, this, this.disposables);
        events_default.on("BufReadCmd", this.onBufReadCmd, this, this.disposables);
        events_default.on("VimResized", (columns, lines) => {
          Object.assign(this._env, { columns, lines });
        }, null, this.disposables);
        await this.attach();
        this.attachChangedEvents();
        this.configurations.onDidChange((e) => {
          this._onDidChangeConfiguration.fire(e);
        }, null, this.disposables);
        this.watchOption("runtimepath", (oldValue, newValue) => {
          let result = (0, import_fast_diff2.default)(oldValue, newValue);
          for (let [changeType, value] of result) {
            if (changeType == 1) {
              let paths = value.replace(/,$/, "").split(",");
              this._onDidRuntimePathChange.fire(paths);
            }
          }
          this._env.runtimepath = newValue;
        }, this.disposables);
        this.watchOption("completeopt", async (_, newValue) => {
          this.env.completeOpt = newValue;
          if (!this._attached)
            return;
          if (this.insertMode) {
            let suggest = this.getConfiguration("suggest");
            if (suggest.get("autoTrigger") == "always") {
              let content = await this.nvim.call("execute", ["verbose set completeopt"]);
              let lines = content.split(/\r?\n/);
              console.error(`Some plugin change completeopt on insert mode: ${lines[lines.length - 1].trim()}!`);
            }
          }
        }, this.disposables);
        this.watchGlobal("coc_sources_disable_map", async (_, newValue) => {
          this.env.disabledSources = newValue;
        });
        this.disposables.push(this.registerTextDocumentContentProvider("output", channels_default.getProvider(nvim)));
      }
      getConfigFile(target) {
        return this.configurations.getConfigFile(target);
      }
      registerAutocmd(autocmd) {
        this.autocmdMaxId += 1;
        let id = this.autocmdMaxId;
        this.autocmds.set(id, autocmd);
        this.setupDynamicAutocmd();
        return import_vscode_languageserver_protocol13.Disposable.create(() => {
          this.autocmds.delete(id);
          this.setupDynamicAutocmd();
        });
      }
      watchOption(key, callback, disposables) {
        let watching = this.watchedOptions.has(key);
        if (!watching) {
          this.watchedOptions.add(key);
          this.setupDynamicAutocmd();
        }
        let disposable = events_default.on("OptionSet", async (changed, oldValue, newValue) => {
          if (changed == key && callback) {
            await Promise.resolve(callback(oldValue, newValue));
          }
        });
        if (disposables) {
          disposables.push(import_vscode_languageserver_protocol13.Disposable.create(() => {
            disposable.dispose();
            if (watching)
              return;
            this.watchedOptions.delete(key);
            this.setupDynamicAutocmd();
          }));
        }
      }
      watchGlobal(key, callback, disposables) {
        let { nvim } = this;
        nvim.call("coc#_watch", key, true);
        let disposable = events_default.on("GlobalChange", async (changed, oldValue, newValue) => {
          if (changed == key && callback) {
            await Promise.resolve(callback(oldValue, newValue));
          }
        });
        if (disposables) {
          disposables.push(import_vscode_languageserver_protocol13.Disposable.create(() => {
            disposable.dispose();
            nvim.call("coc#_unwatch", key, true);
          }));
        }
      }
      get cwd() {
        return this._cwd;
      }
      get env() {
        return this._env;
      }
      get root() {
        return this._root || this.cwd;
      }
      get rootPath() {
        return this.root;
      }
      get workspaceFolders() {
        return this._workspaceFolders;
      }
      get uri() {
        let { bufnr } = this;
        if (bufnr) {
          let document2 = this.getDocument(bufnr);
          if (document2 && document2.schema == "file") {
            return document2.uri;
          }
        }
        return null;
      }
      get workspaceFolder() {
        let { rootPath } = this;
        if (rootPath == import_os4.default.homedir())
          return null;
        return {
          uri: URI.file(rootPath).toString(),
          name: import_path11.default.basename(rootPath)
        };
      }
      get textDocuments() {
        let docs = [];
        for (let b of this.buffers.values()) {
          docs.push(b.textDocument);
        }
        return docs;
      }
      get documents() {
        return Array.from(this.buffers.values());
      }
      createNameSpace(name2 = "") {
        if (this.namespaceMap.has(name2))
          return this.namespaceMap.get(name2);
        NAME_SPACE = NAME_SPACE + 1;
        this.namespaceMap.set(name2, NAME_SPACE);
        return NAME_SPACE;
      }
      get channelNames() {
        return channels_default.names;
      }
      get pluginRoot() {
        return import_path11.default.dirname(__dirname);
      }
      get isVim() {
        return this._env.isVim;
      }
      get isNvim() {
        return !this._env.isVim;
      }
      get completeOpt() {
        return this._env.completeOpt;
      }
      get initialized() {
        return this._initialized;
      }
      get ready() {
        if (this._initialized)
          return Promise.resolve();
        return new Promise((resolve3) => {
          let disposable = this.onDidWorkspaceInitialized(() => {
            disposable.dispose();
            resolve3();
          });
        });
      }
      get filetypes() {
        let res = new Set();
        for (let doc of this.documents) {
          res.add(doc.filetype);
        }
        return res;
      }
      match(selector, document2) {
        return score(selector, document2.uri, document2.languageId);
      }
      async findUp(filename) {
        let { cwd } = this;
        let filepath = await this.nvim.call("expand", "%:p");
        filepath = import_path11.default.normalize(filepath);
        let isFile2 = filepath && import_path11.default.isAbsolute(filepath);
        if (isFile2 && !isParentFolder(cwd, filepath, true)) {
          return findUp(filename, import_path11.default.dirname(filepath));
        }
        let res = findUp(filename, cwd);
        if (res && res != import_os4.default.homedir())
          return res;
        if (isFile2)
          return findUp(filename, import_path11.default.dirname(filepath));
        return null;
      }
      async resolveRootFolder(uri, patterns) {
        let { cwd } = this;
        if (uri.scheme != "file")
          return cwd;
        let filepath = import_path11.default.normalize(uri.fsPath);
        let dir = import_path11.default.dirname(filepath);
        return resolveRoot(dir, patterns) || dir;
      }
      createFileSystemWatcher(globPattern, ignoreCreate, ignoreChange, ignoreDelete) {
        let watchmanPath = global.hasOwnProperty("__TEST__") ? null : this.getWatchmanPath();
        let channel = watchmanPath ? window_default.createOutputChannel("watchman") : null;
        let promise = watchmanPath ? Watchman.createClient(watchmanPath, this.root, channel) : Promise.resolve(null);
        let watcher = new FileSystemWatcher(promise, globPattern, !!ignoreCreate, !!ignoreChange, !!ignoreDelete);
        return watcher;
      }
      getWatchmanPath() {
        const preferences = this.getConfiguration("coc.preferences");
        let watchmanPath = preferences.get("watchmanPath", "watchman");
        try {
          return import_which2.default.sync(watchmanPath);
        } catch (e) {
          return null;
        }
      }
      getConfiguration(section2, resource) {
        return this.configurations.getConfiguration(section2, resource);
      }
      getDocument(uri) {
        if (typeof uri === "number") {
          return this.buffers.get(uri);
        }
        const caseInsensitive = platform_exports.isWindows || platform_exports.isMacintosh;
        uri = URI.parse(uri).toString();
        for (let doc of this.buffers.values()) {
          if (!doc)
            continue;
          if (doc.uri === uri)
            return doc;
          if (import_path11.default.resolve(doc.uri) === import_path11.default.resolve(uri))
            return doc;
          if (caseInsensitive && doc.uri.toLowerCase() === uri.toLowerCase())
            return doc;
        }
        return null;
      }
      async applyEdit(edit2) {
        let { nvim } = this;
        let { documentChanges, changes } = edit2;
        let [bufnr, cursor] = await nvim.eval('[bufnr("%"),coc#util#cursor()]');
        let document2 = this.getDocument(bufnr);
        let uri = document2 ? document2.uri : null;
        let currEdits = null;
        let locations = [];
        let changeCount = 0;
        const preferences = this.getConfiguration("coc.preferences");
        let promptUser = !global.hasOwnProperty("__TEST__") && preferences.get("promptWorkspaceEdit", true);
        let listTarget = preferences.get("listOfWorkspaceEdit", "quickfix");
        try {
          if (documentChanges && documentChanges.length) {
            let changedUris = this.getChangedUris(documentChanges);
            changeCount = changedUris.length;
            if (promptUser) {
              let diskCount = changedUris.reduce((p, c) => {
                return p + (this.getDocument(c) == null ? 1 : 0);
              }, 0);
              if (diskCount) {
                let res = await window_default.showPrompt(`${diskCount} documents on disk would be loaded for change, confirm?`);
                if (!res)
                  return;
              }
            }
            let changedMap = new Map();
            for (const change of documentChanges) {
              if (import_vscode_languageserver_protocol13.TextDocumentEdit.is(change)) {
                let { textDocument, edits } = change;
                let doc = await this.loadFile(textDocument.uri);
                if (textDocument.uri == uri)
                  currEdits = edits;
                await doc.applyEdits(edits);
                for (let edit3 of edits) {
                  locations.push({ uri: doc.uri, range: edit3.range });
                }
              } else if (import_vscode_languageserver_protocol13.CreateFile.is(change)) {
                let file = URI.parse(change.uri).fsPath;
                await this.createFile(file, change.options);
              } else if (import_vscode_languageserver_protocol13.RenameFile.is(change)) {
                changedMap.set(change.oldUri, change.newUri);
                await this.renameFile(URI.parse(change.oldUri).fsPath, URI.parse(change.newUri).fsPath, change.options);
              } else if (import_vscode_languageserver_protocol13.DeleteFile.is(change)) {
                await this.deleteFile(URI.parse(change.uri).fsPath, change.options);
              }
            }
            if (changedMap.size) {
              locations.forEach((location) => {
                let newUri = changedMap.get(location.uri);
                if (newUri)
                  location.uri = newUri;
              });
            }
          } else if (changes) {
            let uris = Object.keys(changes);
            let unloaded = uris.filter((uri2) => this.getDocument(uri2) == null);
            if (unloaded.length) {
              if (promptUser) {
                let res = await window_default.showPrompt(`${unloaded.length} documents on disk would be loaded for change, confirm?`);
                if (!res)
                  return;
              }
              await this.loadFiles(unloaded);
            }
            for (let uri2 of Object.keys(changes)) {
              let document3 = this.getDocument(uri2);
              if (URI.parse(uri2).toString() == uri2)
                currEdits = changes[uri2];
              let edits = changes[uri2];
              for (let edit3 of edits) {
                locations.push({ uri: document3.uri, range: edit3.range });
              }
              await document3.applyEdits(edits);
            }
            changeCount = uris.length;
          }
          if (currEdits) {
            let changed = getChangedFromEdits({ line: cursor[0], character: cursor[1] }, currEdits);
            if (changed)
              await window_default.moveTo({
                line: cursor[0] + changed.line,
                character: cursor[1] + changed.character
              });
          }
          if (locations.length) {
            let items = await Promise.all(locations.map((loc) => this.getQuickfixItem(loc)));
            let silent = locations.every((l) => l.uri == uri);
            if (listTarget == "quickfix") {
              await this.nvim.call("setqflist", [items]);
              if (!silent)
                window_default.showMessage(`changed ${changeCount} buffers, use :wa to save changes to disk and :copen to open quickfix list`, "more");
            } else if (listTarget == "location") {
              await nvim.setVar("coc_jump_locations", items);
              if (!silent)
                window_default.showMessage(`changed ${changeCount} buffers, use :wa to save changes to disk and :CocList location to manage changed locations`, "more");
            }
          }
        } catch (e) {
          logger24.error(e);
          window_default.showMessage(`Error on applyEdits: ${e.message}`, "error");
          return false;
        }
        await wait(50);
        return true;
      }
      async getQuickfixItem(loc, text, type = "", module2) {
        if (import_vscode_languageserver_protocol13.LocationLink.is(loc)) {
          loc = import_vscode_languageserver_protocol13.Location.create(loc.targetUri, loc.targetRange);
        }
        let doc = this.getDocument(loc.uri);
        let { uri, range } = loc;
        let { line, character } = range.start;
        let u = URI.parse(uri);
        let bufnr = doc ? doc.bufnr : -1;
        if (!text && u.scheme == "file") {
          text = await this.getLine(uri, line);
          character = byteIndex(text, character);
        }
        let item = {
          uri,
          filename: u.scheme == "file" ? u.fsPath : uri,
          lnum: line + 1,
          col: character + 1,
          text: text || "",
          range
        };
        if (module2)
          item.module = module2;
        if (type)
          item.type = type;
        if (bufnr != -1)
          item.bufnr = bufnr;
        return item;
      }
      createMru(name2) {
        return new Mru(name2);
      }
      async getSelectedRange(mode, document2) {
        let { nvim } = this;
        if (mode === "line") {
          let line = await nvim.call("line", ["."]);
          let content = document2.getline(line - 1);
          if (!content.length)
            return null;
          return import_vscode_languageserver_protocol13.Range.create(line - 1, 0, line - 1, content.length);
        }
        if (mode === "cursor") {
          let [line, character] = await nvim.eval("coc#util#cursor()");
          return import_vscode_languageserver_protocol13.Range.create(line, character, line, character);
        }
        if (!["v", "V", "char", "line", ""].includes(mode)) {
          throw new Error(`Mode '${mode}' not supported`);
        }
        let isVisual = ["v", "V", ""].includes(mode);
        let [, sl, sc] = await nvim.call("getpos", isVisual ? `'<` : `'[`);
        let [, el, ec] = await nvim.call("getpos", isVisual ? `'>` : `']`);
        let range = import_vscode_languageserver_protocol13.Range.create(document2.getPosition(sl, sc), document2.getPosition(el, ec));
        if (mode == "v" || mode == "") {
          range.end.character = range.end.character + 1;
        }
        return range;
      }
      async selectRange(range) {
        let { nvim } = this;
        let { start, end } = range;
        let [bufnr, ve, selection] = await nvim.eval(`[bufnr('%'), &virtualedit, &selection]`);
        let doc = this.getDocument(bufnr);
        if (!doc || !doc.attached)
          return;
        let line = doc.getline(start.line);
        let col = line ? byteLength(line.slice(0, start.character)) : 0;
        let endLine = doc.getline(end.line);
        let endCol = endLine ? byteLength(endLine.slice(0, end.character)) : 0;
        let move_cmd = "";
        let resetVirtualEdit = false;
        move_cmd += "v";
        endCol = await nvim.eval(`virtcol([${end.line + 1}, ${endCol}])`);
        if (selection == "inclusive") {
          if (end.character == 0) {
            move_cmd += `${end.line}G`;
          } else {
            move_cmd += `${end.line + 1}G${endCol}|`;
          }
        } else if (selection == "old") {
          move_cmd += `${end.line + 1}G${endCol}|`;
        } else {
          move_cmd += `${end.line + 1}G${endCol + 1}|`;
        }
        col = await nvim.eval(`virtcol([${start.line + 1}, ${col}])`);
        move_cmd += `o${start.line + 1}G${col + 1}|o`;
        nvim.pauseNotification();
        if (ve != "onemore") {
          resetVirtualEdit = true;
          nvim.setOption("virtualedit", "onemore", true);
        }
        nvim.command(`noa call cursor(${start.line + 1},${col + (move_cmd == "a" ? 0 : 1)})`, true);
        nvim.command(`normal! ${move_cmd}`, true);
        if (resetVirtualEdit)
          nvim.setOption("virtualedit", ve, true);
        if (this.isVim)
          nvim.command("redraw", true);
        await nvim.resumeNotification();
      }
      async showLocations(locations) {
        let items = await Promise.all(locations.map((loc) => this.getQuickfixItem(loc)));
        let { nvim } = this;
        const preferences = this.getConfiguration("coc.preferences");
        if (preferences.get("useQuickfixForLocations", false)) {
          let openCommand = await nvim.getVar("coc_quickfix_open_command");
          if (typeof openCommand != "string") {
            openCommand = items.length < 10 ? `copen ${items.length}` : "copen";
          }
          nvim.pauseNotification();
          nvim.call("setqflist", [items], true);
          nvim.command(openCommand, true);
          nvim.resumeNotification(false, true);
        } else {
          await nvim.setVar("coc_jump_locations", items);
          if (this.env.locationlist) {
            nvim.command("CocList --normal --auto-preview location", true);
          } else {
            nvim.call("coc#util#do_autocmd", ["CocLocationsChange"], true);
          }
        }
      }
      async getLine(uri, line) {
        let document2 = this.getDocument(uri);
        if (document2)
          return document2.getline(line) || "";
        if (!uri.startsWith("file:"))
          return "";
        let fsPath = URI.parse(uri).fsPath;
        if (!import_fs_extra4.default.existsSync(fsPath))
          return "";
        return await readFileLine(fsPath, line);
      }
      getWorkspaceFolder(uri) {
        this.workspaceFolders.sort((a, b) => b.uri.length - a.uri.length);
        let filepath = URI.parse(uri).fsPath;
        return this.workspaceFolders.find((folder) => isParentFolder(URI.parse(folder.uri).fsPath, filepath, true));
      }
      async readFile(uri) {
        let document2 = this.getDocument(uri);
        if (document2) {
          await document2.patchChange();
          return document2.content;
        }
        let u = URI.parse(uri);
        if (u.scheme != "file")
          return "";
        let lines = await this.nvim.call("readfile", [u.fsPath]);
        return lines.join("\n") + "\n";
      }
      get document() {
        return new Promise((resolve3, reject) => {
          this.nvim.buffer.then((buf) => {
            let bufnr = buf.id;
            this.bufnr = bufnr;
            if (this.buffers.has(bufnr)) {
              resolve3(this.buffers.get(bufnr));
              return;
            }
            this.onBufCreate(bufnr).catch(reject);
            let disposable = this.onDidOpenTextDocument((doc) => {
              disposable.dispose();
              resolve3(this.getDocument(doc.uri));
            });
          }, reject);
        });
      }
      async getCurrentState() {
        let document2 = await this.document;
        let position = await window_default.getCursorPosition();
        return {
          document: document2.textDocument,
          position
        };
      }
      async getFormatOptions(uri) {
        let doc;
        if (uri)
          doc = this.getDocument(uri);
        let bufnr = doc ? doc.bufnr : 0;
        let [tabSize, insertSpaces] = await this.nvim.call("coc#util#get_format_opts", [bufnr]);
        return {
          tabSize,
          insertSpaces: insertSpaces == 1
        };
      }
      async jumpTo(uri, position, openCommand) {
        const preferences = this.getConfiguration("coc.preferences");
        let jumpCommand = openCommand || preferences.get("jumpCommand", "edit");
        let { nvim } = this;
        let doc = this.getDocument(uri);
        let bufnr = doc ? doc.bufnr : -1;
        if (bufnr != -1 && jumpCommand == "edit") {
          nvim.pauseNotification();
          nvim.command(`silent! normal! m'`, true);
          nvim.command(`buffer ${bufnr}`, true);
          if (position) {
            let line = doc.getline(position.line);
            let col = byteLength(line.slice(0, position.character)) + 1;
            nvim.call("cursor", [position.line + 1, col], true);
          }
          if (this.isVim)
            nvim.command("redraw", true);
          await nvim.resumeNotification();
        } else {
          let { fsPath, scheme } = URI.parse(uri);
          let pos = position == null ? null : [position.line, position.character];
          if (scheme == "file") {
            let bufname = fixDriver(import_path11.default.normalize(fsPath));
            await this.nvim.call("coc#util#jump", [jumpCommand, bufname, pos]);
          } else {
            if (import_os4.default.platform() == "win32") {
              uri = uri.replace(/\/?/, "?");
            }
            await this.nvim.call("coc#util#jump", [jumpCommand, uri, pos]);
          }
        }
      }
      async createFile(filepath, opts = {}) {
        let stat = await statAsync(filepath);
        if (stat && !opts.overwrite && !opts.ignoreIfExists) {
          window_default.showMessage(`${filepath} already exists!`, "error");
          return;
        }
        if (!stat || opts.overwrite) {
          if (filepath.endsWith("/")) {
            try {
              filepath = this.expand(filepath);
              await import_fs_extra4.default.mkdirp(filepath);
            } catch (e) {
              window_default.showMessage(`Can't create ${filepath}: ${e.message}`, "error");
            }
          } else {
            let uri = URI.file(filepath).toString();
            let doc = this.getDocument(uri);
            if (doc)
              return;
            if (!import_fs_extra4.default.existsSync(import_path11.default.dirname(filepath))) {
              import_fs_extra4.default.mkdirpSync(import_path11.default.dirname(filepath));
            }
            import_fs_extra4.default.writeFileSync(filepath, "", "utf8");
            await this.loadFile(uri);
          }
        }
      }
      async loadFile(uri) {
        let doc = this.getDocument(uri);
        if (doc)
          return doc;
        let { nvim } = this;
        let filepath = uri.startsWith("file") ? URI.parse(uri).fsPath : uri;
        nvim.call("coc#util#open_files", [[filepath]], true);
        return await new Promise((resolve3, reject) => {
          let disposable = this.onDidOpenTextDocument((textDocument) => {
            let fsPath = URI.parse(textDocument.uri).fsPath;
            if (textDocument.uri == uri || fsPath == filepath) {
              clearTimeout(timer);
              disposable.dispose();
              resolve3(this.getDocument(uri));
            }
          });
          let timer = setTimeout(() => {
            disposable.dispose();
            reject(new Error(`Create document ${uri} timeout after 1s.`));
          }, 1e3);
        });
      }
      async loadFiles(uris) {
        uris = uris.filter((uri) => this.getDocument(uri) == null);
        if (!uris.length)
          return;
        let bufnrs = await this.nvim.call("coc#util#open_files", [uris.map((u) => URI.parse(u).fsPath)]);
        let create = bufnrs.filter((bufnr) => this.getDocument(bufnr) == null);
        if (!create.length)
          return;
        return new Promise((resolve3, reject) => {
          let timer = setTimeout(() => {
            disposable.dispose();
            reject(new Error(`Create document timeout after 2s.`));
          }, 2e3);
          let disposable = this.onDidOpenTextDocument(() => {
            if (uris.every((uri) => this.getDocument(uri) != null)) {
              clearTimeout(timer);
              disposable.dispose();
              resolve3();
            }
          });
        });
      }
      async renameFile(oldPath, newPath, opts = {}) {
        let { overwrite, ignoreIfExists } = opts;
        let { nvim } = this;
        try {
          let stat = await statAsync(newPath);
          if (stat && !overwrite && !ignoreIfExists) {
            throw new Error(`${newPath} already exists`);
          }
          if (!stat || overwrite) {
            let uri = URI.file(oldPath).toString();
            let newUri = URI.file(newPath).toString();
            let doc = this.getDocument(uri);
            if (doc != null) {
              let isCurrent = doc.bufnr == this.bufnr;
              let newDoc = this.getDocument(newUri);
              if (newDoc)
                await this.nvim.command(`silent ${newDoc.bufnr}bwipeout!`);
              let content = doc.getDocumentContent();
              await import_fs_extra4.default.writeFile(newPath, content, "utf8");
              if (!isCurrent) {
                await nvim.call("coc#util#open_files", [[newPath]]);
                await nvim.command(`silent ${doc.bufnr}bwipeout!`);
              } else {
                let view = await nvim.call("winsaveview");
                nvim.pauseNotification();
                nvim.call("coc#util#open_file", ["keepalt edit", newPath], true);
                nvim.command(`silent ${doc.bufnr}bwipeout!`, true);
                nvim.call("winrestview", [view], true);
                await nvim.resumeNotification();
              }
              await import_fs_extra4.default.unlink(oldPath);
            } else {
              await renameAsync(oldPath, newPath);
            }
          }
        } catch (e) {
          window_default.showMessage(`Rename error: ${e.message}`, "error");
        }
      }
      async deleteFile(filepath, opts = {}) {
        let { ignoreIfNotExists, recursive } = opts;
        let stat = await statAsync(filepath.replace(/\/$/, ""));
        let isDir = stat && stat.isDirectory();
        if (filepath.endsWith("/") && !isDir) {
          window_default.showMessage(`${filepath} is not directory`, "error");
          return;
        }
        if (!stat && !ignoreIfNotExists) {
          window_default.showMessage(`${filepath} not exists`, "error");
          return;
        }
        if (stat == null)
          return;
        if (isDir && !recursive) {
          window_default.showMessage(`Can't remove directory, recursive not set`, "error");
          return;
        }
        try {
          if (isDir && recursive) {
            await import_fs_extra4.default.remove(filepath);
          } else if (isDir) {
            await import_fs_extra4.default.rmdir(filepath);
          } else {
            await import_fs_extra4.default.unlink(filepath);
          }
          if (!isDir) {
            let uri = URI.file(filepath).toString();
            let doc = this.getDocument(uri);
            if (doc)
              await this.nvim.command(`silent! bwipeout! ${doc.bufnr}`);
          }
        } catch (e) {
          window_default.showMessage(`Error on delete ${filepath}: ${e.message}`, "error");
        }
      }
      async openResource(uri) {
        let { nvim } = this;
        if (uri.startsWith("http")) {
          await nvim.call("coc#util#open_url", uri);
          return;
        }
        let wildignore = await nvim.getOption("wildignore");
        await nvim.setOption("wildignore", "");
        await this.jumpTo(uri);
        await nvim.setOption("wildignore", wildignore);
      }
      async resolveModule(name2) {
        return await this.resolver.resolveModule(name2);
      }
      async runCommand(cmd, cwd, timeout) {
        cwd = cwd || this.cwd;
        return runCommand(cmd, { cwd }, timeout);
      }
      expand(filepath) {
        if (!filepath)
          return filepath;
        if (filepath.startsWith("~")) {
          filepath = import_os4.default.homedir() + filepath.slice(1);
        }
        if (filepath.includes("$")) {
          let doc = this.getDocument(this.bufnr);
          let fsPath = doc ? URI.parse(doc.uri).fsPath : "";
          filepath = filepath.replace(/\$\{(.*?)\}/g, (match, name2) => {
            if (name2.startsWith("env:")) {
              let key = name2.split(":")[1];
              let val = key ? process.env[key] : "";
              return val;
            }
            switch (name2) {
              case "workspace":
              case "workspaceRoot":
              case "workspaceFolder":
                return this.root;
              case "workspaceFolderBasename":
                return import_path11.default.dirname(this.root);
              case "cwd":
                return this.cwd;
              case "file":
                return fsPath;
              case "fileDirname":
                return fsPath ? import_path11.default.dirname(fsPath) : "";
              case "fileExtname":
                return fsPath ? import_path11.default.extname(fsPath) : "";
              case "fileBasename":
                return fsPath ? import_path11.default.basename(fsPath) : "";
              case "fileBasenameNoExtension": {
                let basename = fsPath ? import_path11.default.basename(fsPath) : "";
                return basename ? basename.slice(0, basename.length - import_path11.default.extname(basename).length) : "";
              }
              default:
                return match;
            }
          });
          filepath = filepath.replace(/\$[\w]+/g, (match) => {
            if (match == "$HOME")
              return import_os4.default.homedir();
            return process.env[match.slice(1)] || match;
          });
        }
        return filepath;
      }
      async createTerminal(opts) {
        let cmd = opts.shellPath;
        let args = opts.shellArgs;
        if (!cmd)
          cmd = await this.nvim.getOption("shell");
        let terminal = new TerminalModel(cmd, args || [], this.nvim, opts.name);
        await terminal.start(opts.cwd || this.cwd, opts.env);
        this.terminals.set(terminal.bufnr, terminal);
        this._onDidOpenTerminal.fire(terminal);
        return terminal;
      }
      async callAsync(method, args) {
        if (this.isNvim)
          return await this.nvim.call(method, args);
        return await this.nvim.callAsync("coc#util#with_callback", [method, args]);
      }
      registerTextDocumentContentProvider(scheme, provider) {
        this.schemeProviderMap.set(scheme, provider);
        this.setupDynamicAutocmd();
        let disposables = [];
        if (provider.onDidChange) {
          provider.onDidChange(async (uri) => {
            let doc = this.getDocument(uri.toString());
            if (doc) {
              let { buffer } = doc;
              let tokenSource = new import_vscode_languageserver_protocol13.CancellationTokenSource();
              let content = await Promise.resolve(provider.provideTextDocumentContent(uri, tokenSource.token));
              await buffer.setLines(content.split(/\r?\n/), {
                start: 0,
                end: -1,
                strictIndexing: false
              });
            }
          }, null, disposables);
        }
        return import_vscode_languageserver_protocol13.Disposable.create(() => {
          this.schemeProviderMap.delete(scheme);
          disposeAll(disposables);
          this.setupDynamicAutocmd();
        });
      }
      registerKeymap(modes, key, fn, opts = {}) {
        if (!key)
          throw new Error(`Invalid key ${key} of registerKeymap`);
        if (this.keymaps.has(key))
          throw new Error(`${key} already exists.`);
        opts = Object.assign({ sync: true, cancel: true, silent: true, repeat: false }, opts);
        let { nvim } = this;
        this.keymaps.set(key, [fn, !!opts.repeat]);
        let method = opts.sync ? "request" : "notify";
        let silent = opts.silent ? "<silent>" : "";
        for (let m of modes) {
          if (m == "i") {
            nvim.command(`inoremap ${silent}<expr> <Plug>(coc-${key}) coc#_insert_key('${method}', '${key}', ${opts.cancel ? 1 : 0})`, true);
          } else {
            let modify2 = getKeymapModifier(m);
            nvim.command(`${m}noremap ${silent} <Plug>(coc-${key}) :${modify2}call coc#rpc#${method}('doKeymap', ['${key}'])<cr>`, true);
          }
        }
        return import_vscode_languageserver_protocol13.Disposable.create(() => {
          this.keymaps.delete(key);
          for (let m of modes) {
            nvim.command(`${m}unmap <Plug>(coc-${key})`, true);
          }
        });
      }
      registerExprKeymap(mode, key, fn, buffer = false) {
        if (!key)
          return;
        let id = `${mode}${global.Buffer.from(key).toString("base64")}${buffer ? "1" : "0"}`;
        let { nvim } = this;
        this.keymaps.set(id, [fn, false]);
        if (mode == "i") {
          nvim.command(`inoremap <silent><expr>${buffer ? "<nowait><buffer>" : ""} ${key} coc#_insert_key('request', '${id}')`, true);
        } else {
          nvim.command(`${mode}noremap <silent><expr>${buffer ? "<nowait><buffer>" : ""} ${key} coc#rpc#request('doKeymap', ['${id}'])`, true);
        }
        return import_vscode_languageserver_protocol13.Disposable.create(() => {
          this.keymaps.delete(id);
          nvim.command(`${mode}unmap ${buffer ? "<buffer>" : ""} ${key}`, true);
        });
      }
      registerLocalKeymap(mode, key, fn, notify = false) {
        let id = v1_default();
        let { nvim } = this;
        this.keymaps.set(id, [fn, false]);
        let buf = this.nvim.createBuffer(this.bufnr);
        let method = notify ? "notify" : "request";
        let modify2 = getKeymapModifier(mode);
        let escaped = key.startsWith("<") && key.endsWith(">") ? `{${key.slice(1, -1)}}` : key;
        if (this.isNvim && !global.hasOwnProperty("__TEST__")) {
          buf.notify("nvim_buf_set_keymap", [mode, key, `:${modify2}call coc#rpc#${method}('doKeymap', ['${id}', '', '${escaped}'])<CR>`, {
            silent: true,
            nowait: true
          }]);
        } else {
          let cmd = `${mode}noremap <silent><nowait><buffer> ${key} :${modify2}call coc#rpc#${method}('doKeymap', ['${id}', '', '${escaped}'])<CR>`;
          nvim.command(cmd, true);
        }
        return import_vscode_languageserver_protocol13.Disposable.create(() => {
          this.keymaps.delete(id);
          nvim.call("coc#compat#buf_del_keymap", [buf.id, mode, key], true);
        });
      }
      createDatabase(name2) {
        let root;
        if (global.hasOwnProperty("__TEST__")) {
          root = import_path11.default.join(import_os4.default.tmpdir(), `coc-${process.pid}`);
          import_fs_extra4.default.mkdirpSync(root);
        } else {
          root = import_path11.default.dirname(this.env.extensionRoot);
        }
        let filepath = import_path11.default.join(root, name2 + ".json");
        return new DB(filepath);
      }
      createTask(id) {
        return new Task(this.nvim, id);
      }
      registerBufferSync(create) {
        return new BufferSync(create, this);
      }
      setupDynamicAutocmd(initialize = false) {
        if (!initialize && !this._dynAutocmd)
          return;
        this._dynAutocmd = true;
        let schemes = this.schemeProviderMap.keys();
        let cmds = [];
        for (let scheme of schemes) {
          cmds.push(`autocmd BufReadCmd,FileReadCmd,SourceCmd ${scheme}:/* call coc#rpc#request('CocAutocmd', ['BufReadCmd','${scheme}', expand('<amatch>')])`);
        }
        for (let [id, autocmd] of this.autocmds.entries()) {
          let args = autocmd.arglist && autocmd.arglist.length ? ", " + autocmd.arglist.join(", ") : "";
          let event = Array.isArray(autocmd.event) ? autocmd.event.join(",") : autocmd.event;
          let pattern = autocmd.pattern != null ? autocmd.pattern : "*";
          if (/\buser\b/i.test(event)) {
            pattern = "";
          }
          cmds.push(`autocmd ${event} ${pattern} call coc#rpc#${autocmd.request ? "request" : "notify"}('doAutocmd', [${id}${args}])`);
        }
        for (let key of this.watchedOptions) {
          cmds.push(`autocmd OptionSet ${key} call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])`);
        }
        let content = `
augroup coc_dynamic_autocmd
  autocmd!
  ${cmds.join("\n  ")}
augroup end`;
        try {
          let dir = import_path11.default.join(process.env.TMPDIR, `coc.nvim-${process.pid}`);
          if (!import_fs_extra4.default.existsSync(dir))
            import_fs_extra4.default.mkdirpSync(dir);
          let filepath = import_path11.default.join(dir, `coc-${process.pid}.vim`);
          import_fs_extra4.default.writeFileSync(filepath, content, "utf8");
          let cmd = `source ${filepath}`;
          if (this.env.isCygwin && platform_exports.isWindows) {
            cmd = `execute "source" . substitute(system('cygpath ${filepath.replace(/\\/g, "/")}'), '\\n', '', 'g')`;
          }
          this.nvim.command(cmd).logError();
        } catch (e) {
          window_default.showMessage(`Can't create tmp file: ${e.message}`, "error");
        }
      }
      async onBufReadCmd(scheme, uri) {
        let provider = this.schemeProviderMap.get(scheme);
        if (!provider) {
          window_default.showMessage(`Provider for ${scheme} not found`, "error");
          return;
        }
        let tokenSource = new import_vscode_languageserver_protocol13.CancellationTokenSource();
        let content = await Promise.resolve(provider.provideTextDocumentContent(URI.parse(uri), tokenSource.token));
        let buf = await this.nvim.buffer;
        await buf.setLines(content.split(/\r?\n/), {
          start: 0,
          end: -1,
          strictIndexing: false
        });
        setTimeout(async () => {
          await events_default.fire("BufCreate", [buf.id]);
        }, 30);
      }
      async attach() {
        if (this._attached)
          return;
        this._attached = true;
        let [bufs, bufnr, winid] = await this.nvim.eval(`[map(getbufinfo({'bufloaded': 1}),'v:val["bufnr"]'),bufnr('%'),win_getid()]`);
        this.bufnr = bufnr;
        await Promise.all(bufs.map((buf) => this.onBufCreate(buf)));
        if (!this._initialized) {
          this._onDidWorkspaceInitialized.fire(void 0);
          this._initialized = true;
        }
        await events_default.fire("BufEnter", [bufnr]);
        await events_default.fire("BufWinEnter", [bufnr, winid]);
      }
      getChangedUris(documentChanges) {
        let uris = new Set();
        let createUris = new Set();
        for (let change of documentChanges) {
          if (import_vscode_languageserver_protocol13.TextDocumentEdit.is(change)) {
            let { textDocument } = change;
            let { uri, version: version2 } = textDocument;
            uris.add(uri);
            if (version2 != null && version2 > 0) {
              let doc = this.getDocument(uri);
              if (!doc) {
                throw new Error(`${uri} not loaded`);
              }
              if (doc.version != version2) {
                throw new Error(`${uri} changed before apply edit`);
              }
            }
          } else if (import_vscode_languageserver_protocol13.CreateFile.is(change) || import_vscode_languageserver_protocol13.DeleteFile.is(change)) {
            if (!isFile(change.uri)) {
              throw new Error(`change of scheme ${change.uri} not supported`);
            }
            createUris.add(change.uri);
            uris.add(change.uri);
          } else if (import_vscode_languageserver_protocol13.RenameFile.is(change)) {
            if (!isFile(change.oldUri) || !isFile(change.newUri)) {
              throw new Error(`change of scheme ${change.oldUri} not supported`);
            }
            let newFile = URI.parse(change.newUri).fsPath;
            if (import_fs_extra4.default.existsSync(newFile)) {
              throw new Error(`file "${newFile}" already exists for rename`);
            }
            uris.add(change.oldUri);
          } else {
            throw new Error(`Invalid document change: ${JSON.stringify(change, null, 2)}`);
          }
        }
        return Array.from(uris);
      }
      createConfigurations() {
        let home = import_path11.default.normalize(process.env.COC_VIMCONFIG) || import_path11.default.join(import_os4.default.homedir(), ".vim");
        let userConfigFile = import_path11.default.join(home, CONFIG_FILE_NAME);
        return new Configurations(userConfigFile, new ConfigurationProxy(this));
      }
      attachChangedEvents() {
        if (this.isVim) {
          const onChange = (bufnr) => {
            let doc = this.getDocument(bufnr);
            if (doc && doc.attached)
              doc.fetchContent();
          };
          events_default.on("TextChangedI", onChange, null, this.disposables);
          events_default.on("TextChanged", onChange, null, this.disposables);
        }
      }
      async onBufCreate(buf) {
        let buffer = typeof buf === "number" ? this.nvim.createBuffer(buf) : buf;
        let bufnr = buffer.id;
        if (this.creatingSources.has(bufnr))
          return;
        let document2 = this.getDocument(bufnr);
        let source = new import_vscode_languageserver_protocol13.CancellationTokenSource();
        try {
          if (document2)
            this.onBufUnload(bufnr, true);
          document2 = new Document(buffer, this._env, this.maxFileSize);
          let token = source.token;
          this.creatingSources.set(bufnr, source);
          let created = await document2.init(this.nvim, token);
          if (!created)
            document2 = null;
        } catch (e) {
          logger24.error("Error on create buffer:", e);
          document2 = null;
        }
        if (this.creatingSources.get(bufnr) == source) {
          source.dispose();
          this.creatingSources.delete(bufnr);
        }
        if (!document2 || !document2.textDocument)
          return;
        this.buffers.set(bufnr, document2);
        if (document2.attached) {
          document2.onDocumentDetach((bufnr2) => {
            let doc = this.getDocument(bufnr2);
            if (doc)
              this.onBufUnload(doc.bufnr);
          });
        }
        if (document2.buftype == "" && document2.schema == "file") {
          this.configurations.checkFolderConfiguration(document2.uri);
          let config = this.getConfiguration("workspace");
          let filetypes = config.get("ignoredFiletypes", []);
          if (!filetypes.includes(document2.filetype)) {
            let root = this.resolveRoot(document2);
            if (root) {
              this.addWorkspaceFolder(root);
              if (this.bufnr == buffer.id) {
                this._root = root;
              }
            }
          }
        }
        if (document2.enabled) {
          let textDocument = Object.assign(document2.textDocument, { bufnr });
          this._onDidOpenDocument.fire(textDocument);
          document2.onDocumentChange((e) => this._onDidChangeDocument.fire(e));
        }
        logger24.debug("buffer created", buffer.id);
      }
      onBufEnter(bufnr) {
        this.bufnr = bufnr;
        let doc = this.getDocument(bufnr);
        if (doc) {
          this.configurations.setFolderConfiguration(doc.uri);
          let workspaceFolder = this.getWorkspaceFolder(doc.uri);
          if (workspaceFolder)
            this._root = URI.parse(workspaceFolder.uri).fsPath;
        }
      }
      async checkCurrentBuffer(bufnr) {
        this.bufnr = bufnr;
        await this.checkBuffer(bufnr);
      }
      onBufWritePost(bufnr) {
        let doc = this.buffers.get(bufnr);
        if (!doc)
          return;
        this._onDidSaveDocument.fire(doc.textDocument);
      }
      onBufUnload(bufnr, recreate = false) {
        logger24.debug("buffer unload", bufnr);
        if (!recreate) {
          let source = this.creatingSources.get(bufnr);
          if (source) {
            source.cancel();
            this.creatingSources.delete(bufnr);
          }
        }
        if (this.terminals.has(bufnr)) {
          let terminal = this.terminals.get(bufnr);
          this._onDidCloseTerminal.fire(terminal);
          this.terminals.delete(bufnr);
        }
        let doc = this.buffers.get(bufnr);
        if (doc) {
          let textDocument = Object.assign(doc.textDocument, { bufnr });
          this._onDidCloseDocument.fire(textDocument);
          this.buffers.delete(bufnr);
          doc.detach();
        }
      }
      async onBufWritePre(bufnr) {
        let doc = this.buffers.get(bufnr);
        if (!doc || !doc.attached)
          return;
        await doc.checkDocument();
        let firing = true;
        let thenables = [];
        let event = {
          document: doc.textDocument,
          reason: import_vscode_languageserver_protocol13.TextDocumentSaveReason.Manual,
          waitUntil: (thenable) => {
            if (!firing) {
              logger24.error(`Can't call waitUntil in async manner:`, Error().stack);
              window_default.showMessage(`waitUntil can't be used in async manner, check log for details`, "error");
            } else {
              thenables.push(thenable);
            }
          }
        };
        this._onWillSaveDocument.fire(event);
        firing = false;
        let total = thenables.length;
        if (total) {
          let promise = new Promise((resolve3) => {
            const preferences = this.getConfiguration("coc.preferences");
            const willSaveHandlerTimeout = preferences.get("willSaveHandlerTimeout", 500);
            let timer = setTimeout(() => {
              window_default.showMessage(`Will save handler timeout after ${willSaveHandlerTimeout}ms`, "warning");
              resolve3(void 0);
            }, willSaveHandlerTimeout);
            let i = 0;
            let called = false;
            for (let p of thenables) {
              let cb = (res) => {
                if (called)
                  return;
                called = true;
                clearTimeout(timer);
                resolve3(res);
              };
              p.then((res) => {
                if (Array.isArray(res) && res.length && import_vscode_languageserver_protocol13.TextEdit.is(res[0])) {
                  return cb(res);
                }
                i = i + 1;
                if (i == total)
                  cb(void 0);
              }, () => {
                i = i + 1;
                if (i == total)
                  cb(void 0);
              });
            }
          });
          let edits = await promise;
          if (edits)
            await doc.applyEdits(edits);
        }
      }
      onDirChanged(cwd) {
        if (cwd == this._cwd)
          return;
        this._cwd = cwd;
      }
      onFileTypeChange(filetype, bufnr) {
        let doc = this.getDocument(bufnr);
        if (!doc)
          return;
        let converted = doc.convertFiletype(filetype);
        if (converted == doc.filetype)
          return;
        let textDocument = Object.assign(doc.textDocument, { bufnr });
        this._onDidCloseDocument.fire(textDocument);
        doc.setFiletype(filetype);
        this._onDidOpenDocument.fire(Object.assign(doc.textDocument, { bufnr }));
      }
      async checkBuffer(bufnr) {
        if (this._disposed || !bufnr)
          return;
        let doc = this.getDocument(bufnr);
        if (!doc && !this.creatingSources.has(bufnr))
          await this.onBufCreate(bufnr);
      }
      resolveRoot(document2) {
        let types = [PatternType.Buffer, PatternType.LanguageServer, PatternType.Global];
        let u = URI.parse(document2.uri);
        let dir = import_path11.default.dirname(u.fsPath);
        let { cwd } = this;
        let config = this.getConfiguration("workspace");
        let bottomUpFileTypes = config.get("bottomUpFiletypes", []);
        let checkCwd = config.get("workspaceFolderCheckCwd", true);
        for (let patternType of types) {
          let patterns = this.getRootPatterns(document2, patternType);
          if (patterns && patterns.length) {
            let isBottomUp = bottomUpFileTypes.includes(document2.filetype);
            let root = resolveRoot(dir, patterns, cwd, isBottomUp, checkCwd);
            if (root)
              return root;
          }
        }
        if (this.cwd != import_os4.default.homedir() && isParentFolder(this.cwd, dir, true))
          return this.cwd;
        return null;
      }
      getRootPatterns(document2, patternType) {
        let { uri } = document2;
        if (patternType == PatternType.Buffer)
          return document2.getVar("root_patterns", []) || [];
        if (patternType == PatternType.LanguageServer)
          return this.getServerRootPatterns(document2.filetype);
        const preferences = this.getConfiguration("coc.preferences", uri);
        return preferences.get("rootPatterns", [".git", ".hg", ".projections.json"]).slice();
      }
      async renameCurrent() {
        let { nvim } = this;
        let bufnr = await nvim.call("bufnr", "%");
        let cwd = await nvim.call("getcwd");
        let doc = this.getDocument(bufnr);
        if (!doc || doc.buftype != "" || doc.schema != "file") {
          nvim.errWriteLine("current buffer is not file.");
          return;
        }
        let oldPath = URI.parse(doc.uri).fsPath;
        let newPath = await nvim.callAsync("coc#util#with_callback", ["input", ["New path: ", oldPath, "file"]]);
        newPath = newPath ? newPath.trim() : null;
        if (newPath == oldPath || !newPath)
          return;
        let lines = await doc.buffer.lines;
        let exists = import_fs_extra4.default.existsSync(oldPath);
        if (exists) {
          let modified = await nvim.eval("&modified");
          if (modified)
            await nvim.command("noa w");
          if (oldPath.toLowerCase() != newPath.toLowerCase() && import_fs_extra4.default.existsSync(newPath)) {
            let overwrite = await window_default.showPrompt(`${newPath} exists, overwrite?`);
            if (!overwrite)
              return;
            import_fs_extra4.default.unlinkSync(newPath);
          }
          import_fs_extra4.default.renameSync(oldPath, newPath);
        }
        let filepath = isParentFolder(cwd, newPath) ? import_path11.default.relative(cwd, newPath) : newPath;
        let view = await nvim.call("winsaveview");
        nvim.pauseNotification();
        if (oldPath.toLowerCase() == newPath.toLowerCase()) {
          nvim.command(`keepalt ${bufnr}bwipeout!`, true);
          nvim.call("coc#util#open_file", ["keepalt edit", filepath], true);
        } else {
          nvim.call("coc#util#open_file", ["keepalt edit", filepath], true);
          nvim.command(`${bufnr}bwipeout!`, true);
        }
        if (!exists && lines.join("\n") != "\n") {
          nvim.call("append", [0, lines], true);
          nvim.command("normal! Gdd", true);
        }
        nvim.call("winrestview", [view], true);
        await nvim.resumeNotification();
      }
      get folderPaths() {
        return this.workspaceFolders.map((f) => URI.parse(f.uri).fsPath);
      }
      get floatSupported() {
        let { env } = this;
        return env.floating || env.textprop;
      }
      removeWorkspaceFolder(fsPath) {
        let idx = this._workspaceFolders.findIndex((f) => URI.parse(f.uri).fsPath == fsPath);
        if (idx != -1) {
          let folder = this._workspaceFolders[idx];
          this._workspaceFolders.splice(idx, 1);
          this._onDidChangeWorkspaceFolders.fire({
            removed: [folder],
            added: []
          });
        }
      }
      renameWorkspaceFolder(oldPath, newPath) {
        let idx = this._workspaceFolders.findIndex((f) => URI.parse(f.uri).fsPath == oldPath);
        if (idx == -1)
          return;
        let removed = this._workspaceFolders[idx];
        let added = {
          uri: URI.file(newPath).toString(),
          name: import_path11.default.dirname(newPath)
        };
        this._workspaceFolders.splice(idx, 1);
        this._workspaceFolders.push(added);
        this._onDidChangeWorkspaceFolders.fire({
          removed: [removed],
          added: [added]
        });
      }
      addRootPattern(filetype, rootPatterns) {
        let patterns = this.rootPatterns.get(filetype) || [];
        for (let p of rootPatterns) {
          if (!patterns.includes(p)) {
            patterns.push(p);
          }
        }
        this.rootPatterns.set(filetype, patterns);
      }
      get insertMode() {
        return this._insertMode;
      }
      async detach() {
        if (!this._attached)
          return;
        this._attached = false;
        channels_default.dispose();
        for (let bufnr of this.buffers.keys()) {
          await events_default.fire("BufUnload", [bufnr]);
        }
      }
      dispose() {
        this._disposed = true;
        for (let doc of this.documents) {
          doc.detach();
        }
        disposeAll(this.disposables);
        Watchman.dispose();
        this.configurations.dispose();
        this.buffers.clear();
      }
      addWorkspaceFolder(rootPath) {
        if (rootPath == import_os4.default.homedir())
          return;
        let { _workspaceFolders } = this;
        let uri = URI.file(rootPath).toString();
        let workspaceFolder = { uri, name: import_path11.default.basename(rootPath) };
        if (_workspaceFolders.findIndex((o) => o.uri == uri) == -1) {
          _workspaceFolders.push(workspaceFolder);
          if (this._initialized) {
            this._onDidChangeWorkspaceFolders.fire({
              added: [workspaceFolder],
              removed: []
            });
          }
        }
        return workspaceFolder;
      }
      getServerRootPatterns(filetype) {
        let lspConfig = this.getConfiguration().get("languageserver", {});
        let patterns = [];
        for (let key of Object.keys(lspConfig)) {
          let config = lspConfig[key];
          let { filetypes, rootPatterns } = config;
          if (filetypes && rootPatterns && filetypes.includes(filetype)) {
            patterns.push(...rootPatterns);
          }
        }
        patterns = patterns.concat(this.rootPatterns.get(filetype) || []);
        return patterns.length ? distinct(patterns) : null;
      }
    };
    workspace_default = new Workspace();
  }
});

// src/window.ts
var import_fs10, import_os5, import_path12, import_vscode_languageserver_protocol14, logger25, Window, window_default;
var init_window = __esm({
  "src/window.ts"() {
    import_fs10 = __toModule(require("fs"));
    import_os5 = __toModule(require("os"));
    import_path12 = __toModule(require("path"));
    import_vscode_languageserver_protocol14 = __toModule(require_main2());
    init_esm2();
    init_channels();
    init_events();
    init_dialog();
    init_menu();
    init_notification();
    init_picker();
    init_progress();
    init_status();
    init_types();
    init_util();
    init_mutex();
    init_platform();
    init_workspace();
    logger25 = require_logger2()("window");
    Window = class {
      constructor() {
        this.mutex = new Mutex();
      }
      get nvim() {
        return workspace_default.nvim;
      }
      dispose() {
        var _a2;
        (_a2 = this.statusLine) == null ? void 0 : _a2.dispose();
      }
      showMessage(msg, messageType = "more") {
        if (this.mutex.busy || !this.nvim)
          return;
        let { messageLevel } = this;
        let method = process.env.VIM_NODE_RPC == "1" ? "callTimer" : "call";
        if (global.hasOwnProperty("__TEST__"))
          logger25.info(msg);
        let hl = "Error";
        let level = MessageLevel.Error;
        switch (messageType) {
          case "more":
            level = MessageLevel.More;
            hl = "MoreMsg";
            break;
          case "warning":
            level = MessageLevel.Warning;
            hl = "WarningMsg";
            break;
        }
        if (level >= messageLevel) {
          this.nvim[method]("coc#util#echo_messages", [hl, ("[coc.nvim] " + msg).split("\n")], true);
        }
      }
      async runTerminalCommand(cmd, cwd, keepfocus = false) {
        cwd = cwd || workspace_default.cwd;
        return await this.nvim.callAsync("coc#util#run_terminal", { cmd, cwd, keepfocus: keepfocus ? 1 : 0 });
      }
      async openTerminal(cmd, opts = {}) {
        let bufnr = await this.nvim.call("coc#util#open_terminal", __spreadValues({ cmd }, opts));
        return bufnr;
      }
      async showQuickpick(items, placeholder = "Choose by number") {
        let release = await this.mutex.acquire();
        try {
          let title = placeholder + ":";
          items = items.map((s, idx) => `${idx + 1}. ${s}`);
          let res = await this.nvim.callAsync("coc#util#quickpick", [title, items.map((s) => s.trim())]);
          release();
          let n = parseInt(res, 10);
          if (isNaN(n) || n <= 0 || n > items.length)
            return -1;
          return n - 1;
        } catch (e) {
          release();
          return -1;
        }
      }
      async showMenuPicker(items, title, token) {
        if (workspace_default.env.dialog) {
          let release = await this.mutex.acquire();
          if (token && token.isCancellationRequested) {
            release();
            return void 0;
          }
          try {
            let menu = new Menu(this.nvim, { items: items.map((s) => s.trim()), title }, token);
            let promise = new Promise((resolve3) => {
              menu.onDidClose((selected) => {
                resolve3(selected);
              });
            });
            await menu.show(this.dialogPreference);
            let res = await promise;
            release();
            return res;
          } catch (e) {
            logger25.error(`Error on showMenuPicker:`, e);
            release();
          }
        }
        return await this.showQuickpick(items);
      }
      async openLocalConfig() {
        let { root } = workspace_default;
        if (root == import_os5.default.homedir()) {
          this.showMessage(`Can't create local config in home directory`, "warning");
          return;
        }
        let dir = import_path12.default.join(root, ".vim");
        if (!import_fs10.default.existsSync(dir)) {
          let res = await this.showPrompt(`Would you like to create folder'${root}/.vim'?`);
          if (!res)
            return;
          import_fs10.default.mkdirSync(dir);
        }
        await workspace_default.jumpTo(URI.file(import_path12.default.join(dir, CONFIG_FILE_NAME)).toString());
      }
      async showPrompt(title) {
        let release = await this.mutex.acquire();
        try {
          let res = await this.nvim.callAsync("coc#float#prompt_confirm", [title]);
          release();
          return res == 1;
        } catch (e) {
          release();
          return false;
        }
      }
      async showDialog(config) {
        if (!this.checkDialog())
          return null;
        let dialog = new Dialog(this.nvim, config);
        await dialog.show(this.dialogPreference);
        return dialog;
      }
      async requestInput(title, defaultValue) {
        let { nvim } = this;
        const preferences = workspace_default.getConfiguration("coc.preferences");
        if (workspace_default.env.dialog && preferences.get("promptInput", true) && !isWindows2) {
          let release = await this.mutex.acquire();
          let preferences2 = this.dialogPreference;
          try {
            let opts = {};
            if (preferences2.floatHighlight)
              opts.highlight = preferences2.floatHighlight;
            if (preferences2.floatBorderHighlight)
              opts.borderhighlight = preferences2.floatBorderHighlight;
            let arr = await nvim.call("coc#float#create_prompt_win", [title, defaultValue || "", opts]);
            let [bufnr, winid] = arr;
            let res = await new Promise((resolve3) => {
              let disposables = [];
              events_default.on("BufWinLeave", (nr) => {
                if (nr == bufnr) {
                  disposeAll(disposables);
                  resolve3(null);
                }
              }, null, disposables);
              events_default.on("PromptInsert", async (value) => {
                disposeAll(disposables);
                await nvim.call("coc#float#close", [winid]);
                if (!value) {
                  this.showMessage("Empty word, canceled", "warning");
                  resolve3(null);
                } else {
                  resolve3(value);
                }
              }, null, disposables);
            });
            release();
            return res;
          } catch (e) {
            logger25.error("Error on requestInput:", e);
            release();
          }
        } else {
          let res = await workspace_default.callAsync("input", [title + ": ", defaultValue || ""]);
          nvim.command("normal! :<C-u>", true);
          if (!res) {
            this.showMessage("Empty word, canceled", "warning");
            return null;
          }
          return res;
        }
      }
      createStatusBarItem(priority = 0, option = {}) {
        if (!workspace_default.env) {
          let fn = () => {
          };
          return { text: "", show: fn, dispose: fn, hide: fn, priority: 0, isProgress: false };
        }
        if (!this.statusLine) {
          this.statusLine = new StatusLine(this.nvim);
        }
        return this.statusLine.createStatusBarItem(priority, option.progress || false);
      }
      createOutputChannel(name2) {
        return channels_default.create(name2, this.nvim);
      }
      showOutputChannel(name2, preserveFocus) {
        channels_default.show(name2, preserveFocus);
      }
      async echoLines(lines, truncate = false) {
        let { nvim } = this;
        let cmdHeight = workspace_default.env.cmdheight;
        if (lines.length > cmdHeight && truncate) {
          lines = lines.slice(0, cmdHeight);
        }
        let maxLen = workspace_default.env.columns - 12;
        lines = lines.map((line) => {
          line = line.replace(/\n/g, " ");
          if (truncate)
            line = line.slice(0, maxLen);
          return line;
        });
        if (truncate && lines.length == cmdHeight) {
          let last = lines[lines.length - 1];
          lines[cmdHeight - 1] = `${last.length == maxLen ? last.slice(0, -4) : last} ...`;
        }
        await nvim.call("coc#util#echo_lines", [lines]);
      }
      async getCursorPosition() {
        let [line, content] = await this.nvim.eval(`[line('.')-1, strpart(getline('.'), 0, col('.') - 1)]`);
        return import_vscode_languageserver_protocol14.Position.create(line, content.length);
      }
      async moveTo(position) {
        await this.nvim.call("coc#util#jumpTo", [position.line, position.character]);
        if (workspace_default.env.isVim)
          this.nvim.command("redraw", true);
      }
      async getOffset() {
        return await this.nvim.call("coc#util#get_offset");
      }
      async getCursorScreenPosition() {
        let [row, col] = await this.nvim.call("coc#util#cursor_pos");
        return { row, col };
      }
      async showPickerDialog(items, title, token) {
        if (!this.checkDialog())
          return void 0;
        let release = await this.mutex.acquire();
        if (token && token.isCancellationRequested) {
          release();
          return void 0;
        }
        try {
          let useString = typeof items[0] === "string";
          let picker = new Picker(this.nvim, {
            title,
            items: useString ? items.map((s) => {
              return { label: s };
            }) : items
          }, token);
          let promise = new Promise((resolve3) => {
            picker.onDidClose((selected) => {
              resolve3(selected);
            });
          });
          await picker.show(this.dialogPreference);
          let picked = await promise;
          let res = picked == void 0 ? void 0 : items.filter((_, i) => picked.includes(i));
          release();
          return res;
        } catch (e) {
          logger25.error(`Error on showPickerDialog:`, e);
          release();
        }
      }
      async showInformationMessage(message, ...items) {
        if (!this.enableMessageDialog)
          return await this.showConfirm(message, items, "Info");
        let texts = typeof items[0] === "string" ? items : items.map((s) => s.title);
        let idx = await this.createNotification("CocInfoFloat", message, texts);
        return idx == -1 ? void 0 : items[idx];
      }
      async showWarningMessage(message, ...items) {
        if (!this.enableMessageDialog)
          return await this.showConfirm(message, items, "Warning");
        let texts = typeof items[0] === "string" ? items : items.map((s) => s.title);
        let idx = await this.createNotification("CocWarningFloat", message, texts);
        return idx == -1 ? void 0 : items[idx];
      }
      async showErrorMessage(message, ...items) {
        if (!this.enableMessageDialog)
          return await this.showConfirm(message, items, "Error");
        let texts = typeof items[0] === "string" ? items : items.map((s) => s.title);
        let idx = await this.createNotification("CocErrorFloat", message, texts);
        return idx == -1 ? void 0 : items[idx];
      }
      async showNotification(config) {
        if (!this.checkDialog())
          return false;
        let notification = new Notification(this.nvim, config);
        return await notification.show(this.notificationPreference);
      }
      async showConfirm(message, items, kind) {
        if (!items || items.length == 0) {
          let msgType = kind == "Info" ? "more" : kind == "Error" ? "error" : "warning";
          this.showMessage(message, msgType);
          return void 0;
        }
        let titles = typeof items[0] === "string" ? items.slice() : items.map((o) => o.title);
        let choices = titles.map((s, i) => `${i + 1}${s}`);
        let res = await this.nvim.callAsync("coc#util#with_callback", ["confirm", [message, choices.join("\n"), 0, kind]]);
        return items[res - 1];
      }
      async withProgress(options, task) {
        if (!this.checkDialog())
          return void 0;
        let progress = new ProgressNotification(this.nvim, {
          task,
          title: options.title,
          cancellable: options.cancellable
        });
        return await progress.show(this.notificationPreference);
      }
      createNotification(borderhighlight, message, items) {
        return new Promise((resolve3) => {
          let config = {
            content: message,
            borderhighlight,
            close: true,
            buttons: items.map((s, index) => {
              return { text: s, index };
            }),
            callback: (idx) => {
              resolve3(idx);
            }
          };
          let notification = new Notification(this.nvim, config);
          notification.show(this.notificationPreference).then((shown) => {
            if (!shown) {
              logger25.error("Unable to open notification window");
              resolve3(-1);
            }
            if (!items.length)
              resolve3(-1);
          }, (e) => {
            logger25.error("Unable to open notification window", e);
            resolve3(-1);
          });
        });
      }
      get dialogPreference() {
        let config = workspace_default.getConfiguration("dialog");
        return {
          maxWidth: config.get("maxWidth"),
          maxHeight: config.get("maxHeight"),
          floatHighlight: config.get("floatHighlight"),
          floatBorderHighlight: config.get("floatBorderHighlight"),
          pickerButtons: config.get("pickerButtons"),
          pickerButtonShortcut: config.get("pickerButtonShortcut"),
          confirmKey: config.get("confirmKey")
        };
      }
      get notificationPreference() {
        let config = workspace_default.getConfiguration("notification");
        return {
          top: config.get("marginTop"),
          right: config.get("marginRight"),
          maxWidth: config.get("maxWidth"),
          maxHeight: config.get("maxHeight"),
          highlight: config.get("highlightGroup"),
          minProgressWidth: config.get("minProgressWidth")
        };
      }
      checkDialog() {
        if (workspace_default.env.dialog)
          return true;
        this.showMessage("Dialog requires vim >= 8.2.0750 or neovim >= 0.4.0, please upgrade your vim", "warning");
        return false;
      }
      get enableMessageDialog() {
        if (!workspace_default.env.dialog)
          return false;
        let config = workspace_default.getConfiguration("coc.preferences");
        return config.get("enableMessageDialog", false);
      }
      get messageLevel() {
        let config = workspace_default.getConfiguration("coc.preferences");
        let level = config.get("messageLevel", "more");
        switch (level) {
          case "error":
            return MessageLevel.Error;
          case "warning":
            return MessageLevel.Warning;
          default:
            return MessageLevel.More;
        }
      }
    };
    window_default = new Window();
  }
});

// src/diagnostic/util.ts
function getSeverityName(severity) {
  switch (severity) {
    case import_vscode_languageserver_protocol15.DiagnosticSeverity.Error:
      return "Error";
    case import_vscode_languageserver_protocol15.DiagnosticSeverity.Warning:
      return "Warning";
    case import_vscode_languageserver_protocol15.DiagnosticSeverity.Information:
      return "Information";
    case import_vscode_languageserver_protocol15.DiagnosticSeverity.Hint:
      return "Hint";
    default:
      return "Error";
  }
}
function getSeverityType(severity) {
  switch (severity) {
    case import_vscode_languageserver_protocol15.DiagnosticSeverity.Error:
      return "E";
    case import_vscode_languageserver_protocol15.DiagnosticSeverity.Warning:
      return "W";
    case import_vscode_languageserver_protocol15.DiagnosticSeverity.Information:
      return "I";
    case import_vscode_languageserver_protocol15.DiagnosticSeverity.Hint:
      return "I";
    default:
      return "Error";
  }
}
function severityLevel(level) {
  switch (level) {
    case "hint":
      return import_vscode_languageserver_protocol15.DiagnosticSeverity.Hint;
    case "information":
      return import_vscode_languageserver_protocol15.DiagnosticSeverity.Information;
    case "warning":
      return import_vscode_languageserver_protocol15.DiagnosticSeverity.Warning;
    case "error":
      return import_vscode_languageserver_protocol15.DiagnosticSeverity.Error;
    default:
      return import_vscode_languageserver_protocol15.DiagnosticSeverity.Hint;
  }
}
function getNameFromSeverity(severity) {
  switch (severity) {
    case import_vscode_languageserver_protocol15.DiagnosticSeverity.Error:
      return "CocError";
    case import_vscode_languageserver_protocol15.DiagnosticSeverity.Warning:
      return "CocWarning";
    case import_vscode_languageserver_protocol15.DiagnosticSeverity.Information:
      return "CocInfo";
    case import_vscode_languageserver_protocol15.DiagnosticSeverity.Hint:
      return "CocHint";
    default:
      return "CocError";
  }
}
function getLocationListItem(bufnr, diagnostic) {
  let { start } = diagnostic.range;
  let owner = diagnostic.source || "coc.nvim";
  let msg = diagnostic.message.split("\n")[0];
  let type = getSeverityName(diagnostic.severity).slice(0, 1).toUpperCase();
  return {
    bufnr,
    lnum: start.line + 1,
    col: start.character + 1,
    text: `[${owner}${diagnostic.code ? " " + diagnostic.code : ""}] ${msg} [${type}]`,
    type
  };
}
var import_vscode_languageserver_protocol15;
var init_util3 = __esm({
  "src/diagnostic/util.ts"() {
    import_vscode_languageserver_protocol15 = __toModule(require_main2());
  }
});

// src/diagnostic/buffer.ts
function getHighlightGroup(diagnostic) {
  let tags = diagnostic.tags || [];
  if (tags.includes(import_vscode_languageserver_protocol16.DiagnosticTag.Deprecated)) {
    return DiagnosticHighlight.Deprecated;
  }
  if (tags.includes(import_vscode_languageserver_protocol16.DiagnosticTag.Unnecessary)) {
    return DiagnosticHighlight.Unused;
  }
  switch (diagnostic.severity) {
    case import_vscode_languageserver_protocol16.DiagnosticSeverity.Error:
      return DiagnosticHighlight.Error;
    case import_vscode_languageserver_protocol16.DiagnosticSeverity.Warning:
      return DiagnosticHighlight.Warning;
    case import_vscode_languageserver_protocol16.DiagnosticSeverity.Information:
      return DiagnosticHighlight.Information;
    case import_vscode_languageserver_protocol16.DiagnosticSeverity.Hint:
      return DiagnosticHighlight.Hint;
    default:
      return DiagnosticHighlight.Error;
  }
}
function getCollections(diagnostics) {
  let res = new Set();
  diagnostics.forEach((o) => {
    res.add(o.collection);
  });
  return res;
}
function getSymbol(severity) {
  if (severity == import_vscode_languageserver_protocol16.DiagnosticSeverity.Error) {
    return ErrorSymbol;
  }
  if (severity == import_vscode_languageserver_protocol16.DiagnosticSeverity.Warning) {
    return WarningSymbol;
  }
  if (severity == import_vscode_languageserver_protocol16.DiagnosticSeverity.Information) {
    return InformationSymbol;
  }
  return HintSymbol;
}
var import_debounce4, import_vscode_languageserver_protocol16, isVim5, logger26, signGroup, DiagnosticState, DiagnosticHighlight, ErrorSymbol, WarningSymbol, InformationSymbol, HintSymbol, DiagnosticBuffer;
var init_buffer = __esm({
  "src/diagnostic/buffer.ts"() {
    import_debounce4 = __toModule(require_debounce());
    import_vscode_languageserver_protocol16 = __toModule(require_main2());
    init_object();
    init_position();
    init_util3();
    isVim5 = process.env.VIM_NODE_RPC == "1";
    logger26 = require_logger2()("diagnostic-buffer");
    signGroup = "CocDiagnostic";
    (function(DiagnosticState2) {
      DiagnosticState2[DiagnosticState2["Enabled"] = 0] = "Enabled";
      DiagnosticState2[DiagnosticState2["Disabled"] = 1] = "Disabled";
    })(DiagnosticState || (DiagnosticState = {}));
    (function(DiagnosticHighlight2) {
      DiagnosticHighlight2["Error"] = "CocErrorHighlight";
      DiagnosticHighlight2["Warning"] = "CocWarningHighlight";
      DiagnosticHighlight2["Information"] = "CocInfoHighlight";
      DiagnosticHighlight2["Hint"] = "CocHintFloat";
      DiagnosticHighlight2["Deprecated"] = "CocStrikeThrough";
      DiagnosticHighlight2["Unused"] = "CocFadeOut";
    })(DiagnosticHighlight || (DiagnosticHighlight = {}));
    ErrorSymbol = Symbol("CocError");
    WarningSymbol = Symbol("CocWarning");
    InformationSymbol = Symbol("CocInformation");
    HintSymbol = Symbol("CocHint");
    DiagnosticBuffer = class {
      constructor(nvim, bufnr, uri, config, onRefresh) {
        this.nvim = nvim;
        this.bufnr = bufnr;
        this.uri = uri;
        this.config = config;
        this.onRefresh = onRefresh;
        this.diagnostics = [];
        this._disposed = false;
        this._state = 0;
        this.refresh = (0, import_debounce4.default)((diagnostics) => {
          this._refresh(diagnostics).logError();
        }, 300);
      }
      get displayByAle() {
        return this.config.displayByAle;
      }
      onChange() {
        this.refresh.clear();
      }
      changeState(state) {
        this._state = state;
      }
      get enabled() {
        return this._state == 0;
      }
      forceRefresh(diagnostics) {
        this.refresh.clear();
        this._refresh(diagnostics).logError();
      }
      refreshAle(diagnostics) {
        let collections = getCollections(this.diagnostics);
        this.diagnostics = diagnostics;
        let map = new Map();
        diagnostics.forEach((o) => {
          let exists = map.get(o.collection) || [];
          exists.push(o);
          map.set(o.collection, exists);
        });
        for (let name2 of collections) {
          if (!map.has(name2)) {
            map.set(name2, []);
          }
        }
        this.nvim.pauseNotification();
        for (let [collection, diagnostics2] of map.entries()) {
          let aleItems = diagnostics2.map((o) => {
            let range = o.range || import_vscode_languageserver_protocol16.Range.create(0, 0, 1, 0);
            return {
              text: o.message,
              code: o.code,
              lnum: range.start.line + 1,
              col: range.start.character + 1,
              end_lnum: range.end.line + 1,
              end_col: range.end.character,
              type: getSeverityType(o.severity)
            };
          });
          let method = global.hasOwnProperty("__TEST__") ? "MockAleResults" : "ale#other_source#ShowResults";
          this.nvim.call(method, [this.bufnr, collection, aleItems], true);
        }
        this.nvim.resumeNotification().then((res) => {
          if (Array.isArray(res) && res[1] != null) {
            logger26.error(`Error on displayByAle:`, res[1][2]);
          }
        }).logError();
      }
      async _refresh(diagnostics) {
        if (equals(this.diagnostics, diagnostics))
          return;
        let { refreshOnInsertMode } = this.config;
        let { nvim } = this;
        if (this._state == 1)
          return;
        let arr = await nvim.eval(`[coc#util#check_refresh(${this.bufnr}),mode(),line("."),getloclist(bufwinid(${this.bufnr}),{'title':1})]`);
        if (arr[0] == 0 || this._disposed)
          return;
        let mode = arr[1];
        if (!refreshOnInsertMode && mode.startsWith("i") && diagnostics.length)
          return;
        if (this.displayByAle) {
          this.refreshAle(diagnostics);
        } else {
          this.diagnostics = diagnostics;
          let lnum = arr[2];
          nvim.pauseNotification();
          this.setDiagnosticInfo(diagnostics);
          this.addSigns(diagnostics);
          this.addHighlight(diagnostics);
          this.updateLocationList(arr[3], diagnostics);
          this.showVirtualText(diagnostics, lnum);
          if (isVim5)
            this.nvim.command("redraw", true);
          let res = await this.nvim.resumeNotification();
          if (Array.isArray(res) && res[1])
            throw new Error(res[1]);
        }
        this.onRefresh(diagnostics);
      }
      updateLocationList(curr, diagnostics) {
        if (!this.config.locationlistUpdate)
          return;
        if (!curr || curr.title !== "Diagnostics of coc")
          return;
        let items = [];
        for (let diagnostic of diagnostics) {
          let item = getLocationListItem(this.bufnr, diagnostic);
          items.push(item);
        }
        this.nvim.call("setloclist", [0, [], "r", { title: "Diagnostics of coc", items }], true);
      }
      addSigns(diagnostics) {
        if (!this.config.enableSign)
          return;
        this.clearSigns();
        let { nvim, bufnr } = this;
        let signsMap = new Map();
        for (let diagnostic of diagnostics) {
          let { range, severity } = diagnostic;
          let line = range.start.line;
          let name2 = getNameFromSeverity(severity);
          let exists = signsMap.get(line) || [];
          let s = getSymbol(severity);
          if (exists.includes(s)) {
            continue;
          }
          exists.push(s);
          signsMap.set(line, exists);
          nvim.call("sign_place", [0, signGroup, name2, bufnr, { lnum: line + 1, priority: 14 - (severity || 0) }], true);
        }
      }
      clearSigns() {
        let { nvim, bufnr } = this;
        nvim.call("sign_unplace", [signGroup, { buffer: bufnr }], true);
      }
      setDiagnosticInfo(diagnostics) {
        let lnums = [0, 0, 0, 0];
        let info = { error: 0, warning: 0, information: 0, hint: 0, lnums };
        for (let diagnostic of diagnostics) {
          switch (diagnostic.severity) {
            case import_vscode_languageserver_protocol16.DiagnosticSeverity.Warning:
              info.warning = info.warning + 1;
              lnums[1] = lnums[1] || diagnostic.range.start.line + 1;
              break;
            case import_vscode_languageserver_protocol16.DiagnosticSeverity.Information:
              info.information = info.information + 1;
              lnums[2] = lnums[2] || diagnostic.range.start.line + 1;
              break;
            case import_vscode_languageserver_protocol16.DiagnosticSeverity.Hint:
              info.hint = info.hint + 1;
              lnums[3] = lnums[3] || diagnostic.range.start.line + 1;
              break;
            default:
              lnums[0] = lnums[0] || diagnostic.range.start.line + 1;
              info.error = info.error + 1;
          }
        }
        this.nvim.call("coc#util#set_buf_var", [this.bufnr, "coc_diagnostic_info", info], true);
        this.nvim.call("coc#util#do_autocmd", ["CocDiagnosticChange"], true);
      }
      showVirtualText(diagnostics, lnum) {
        let { buffer, config } = this;
        if (!config.virtualText)
          return;
        let srcId = this.config.virtualTextSrcId;
        let prefix = this.config.virtualTextPrefix;
        if (this.config.virtualTextCurrentLineOnly) {
          diagnostics = diagnostics.filter((d) => {
            let { start, end } = d.range;
            return start.line <= lnum - 1 && end.line >= lnum - 1;
          });
        }
        buffer.clearNamespace(srcId);
        for (let diagnostic of [...diagnostics].reverse()) {
          let { line } = diagnostic.range.start;
          let highlight = getNameFromSeverity(diagnostic.severity) + "VirtualText";
          let msg = diagnostic.message.split(/\n/).map((l) => l.trim()).filter((l) => l.length > 0).slice(0, this.config.virtualTextLines).join(this.config.virtualTextLineSeparator);
          buffer.setVirtualText(srcId, line, [[prefix + msg, highlight]], {}).logError();
        }
      }
      addHighlight(diagnostics) {
        this.clearHighlight();
        if (diagnostics.length == 0)
          return;
        const highlights = new Map();
        for (let diagnostic of diagnostics) {
          let { range } = diagnostic;
          let hi = getHighlightGroup(diagnostic);
          let ranges = highlights.get(hi) || [];
          ranges.push(range);
          highlights.set(hi, ranges);
        }
        for (let hlGroup of highlights.keys()) {
          let ranges = highlights.get(hlGroup) || [];
          if (ranges.length)
            this.buffer.highlightRanges("diagnostic", hlGroup, ranges);
        }
      }
      clearHighlight() {
        this.buffer.clearNamespace("diagnostic");
      }
      get buffer() {
        return this.nvim.createBuffer(this.bufnr);
      }
      clear() {
        this.refresh.clear();
        let { nvim } = this;
        if (this.displayByAle) {
          let collections = getCollections(this.diagnostics);
          this.diagnostics = [];
          if (collections.size > 0) {
            for (let collection of collections) {
              let method = global.hasOwnProperty("__TEST__") ? "MockAleResults" : "ale#other_source#ShowResults";
              this.nvim.call(method, [this.bufnr, collection, []], true);
            }
          }
        } else {
          this.diagnostics = [];
          nvim.pauseNotification();
          this.clearHighlight();
          if (this.config.enableSign) {
            this.clearSigns();
          }
          if (this.config.virtualText) {
            this.buffer.clearNamespace(this.config.virtualTextSrcId);
          }
          this.setDiagnosticInfo([]);
          nvim.resumeNotification(false, true);
        }
      }
      getDiagnosticsAt(pos, checkCurrentLine) {
        let diagnostics = this.diagnostics.slice();
        if (checkCurrentLine) {
          diagnostics = diagnostics.filter((o) => lineInRange(pos.line, o.range));
        } else {
          diagnostics = diagnostics.filter((o) => positionInRange(pos, o.range) == 0);
        }
        diagnostics.sort((a, b) => a.severity - b.severity);
        return diagnostics;
      }
      dispose() {
        this._disposed = true;
        this.clear();
      }
    };
  }
});

// src/diagnostic/collection.ts
var import_vscode_languageserver_protocol17, logger27, Collection;
var init_collection = __esm({
  "src/diagnostic/collection.ts"() {
    import_vscode_languageserver_protocol17 = __toModule(require_main2());
    init_esm2();
    init_position();
    init_workspace();
    logger27 = require_logger2()("diagnostic-collection");
    Collection = class {
      constructor(owner) {
        this.diagnosticsMap = new Map();
        this._onDispose = new import_vscode_languageserver_protocol17.Emitter();
        this._onDidDiagnosticsChange = new import_vscode_languageserver_protocol17.Emitter();
        this._onDidDiagnosticsClear = new import_vscode_languageserver_protocol17.Emitter();
        this.onDispose = this._onDispose.event;
        this.onDidDiagnosticsChange = this._onDidDiagnosticsChange.event;
        this.onDidDiagnosticsClear = this._onDidDiagnosticsClear.event;
        this.name = owner;
      }
      set(entries, diagnostics) {
        let diagnosticsPerFile = new Map();
        if (!Array.isArray(entries)) {
          let doc = workspace_default.getDocument(entries);
          let uri = doc ? doc.uri : entries;
          diagnosticsPerFile.set(uri, diagnostics || []);
        } else {
          for (let item of entries) {
            let [uri, diagnostics2] = item;
            let doc = workspace_default.getDocument(uri);
            uri = doc ? doc.uri : uri;
            if (diagnostics2 == null) {
              diagnostics2 = [];
            } else {
              diagnostics2 = (diagnosticsPerFile.get(uri) || []).concat(diagnostics2);
            }
            diagnosticsPerFile.set(uri, diagnostics2);
          }
        }
        for (let item of diagnosticsPerFile) {
          let [uri, diagnostics2] = item;
          uri = URI.parse(uri).toString();
          diagnostics2.forEach((o) => {
            o.range = o.range || import_vscode_languageserver_protocol17.Range.create(0, 0, 1, 0);
            o.message = o.message || "Empty error message";
            if (emptyRange(o.range)) {
              o.range.end = {
                line: o.range.end.line,
                character: o.range.end.character + 1
              };
            }
            let { start, end } = o.range;
            if (end.character == 0 && end.line - start.line == 1 && start.character > 0) {
              let doc = workspace_default.getDocument(uri);
              if (doc) {
                let line = doc.getline(start.line);
                if (start.character == line.length) {
                  o.range.start.character = start.character - 1;
                }
              }
            }
            o.source = o.source || this.name;
          });
          this.diagnosticsMap.set(uri, diagnostics2);
          this._onDidDiagnosticsChange.fire(uri);
        }
        return;
      }
      delete(uri) {
        this.diagnosticsMap.delete(uri);
      }
      clear() {
        let uris = Array.from(this.diagnosticsMap.keys());
        this.diagnosticsMap.clear();
        this._onDidDiagnosticsClear.fire(uris);
      }
      forEach(callback, thisArg) {
        for (let uri of this.diagnosticsMap.keys()) {
          let diagnostics = this.diagnosticsMap.get(uri);
          callback.call(thisArg, uri, diagnostics, this);
        }
      }
      get(uri) {
        let arr = this.diagnosticsMap.get(uri);
        return arr == null ? [] : arr;
      }
      has(uri) {
        return this.diagnosticsMap.has(uri);
      }
      dispose() {
        this.clear();
        this._onDispose.fire(void 0);
        this._onDispose.dispose();
        this._onDidDiagnosticsClear.dispose();
        this._onDidDiagnosticsChange.dispose();
      }
    };
  }
});

// src/diagnostic/manager.ts
var import_debounce5, import_semver, import_vscode_languageserver_protocol18, logger28, DiagnosticManager, manager_default;
var init_manager = __esm({
  "src/diagnostic/manager.ts"() {
    import_debounce5 = __toModule(require_debounce());
    import_semver = __toModule(require_semver2());
    import_vscode_languageserver_protocol18 = __toModule(require_main2());
    init_esm2();
    init_events();
    init_floatFactory();
    init_util();
    init_position();
    init_window();
    init_workspace();
    init_buffer();
    init_collection();
    init_util3();
    logger28 = require_logger2()("diagnostic-manager");
    DiagnosticManager = class {
      constructor() {
        this.enabled = true;
        this._onDidRefresh = new import_vscode_languageserver_protocol18.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this.lastMessage = "";
        this.collections = [];
        this.disposables = [];
      }
      init() {
        this.setConfiguration();
        workspace_default.onDidChangeConfiguration((e) => {
          this.setConfiguration(e);
        }, null, this.disposables);
        this.floatFactory = new FloatFactory(this.nvim);
        this.buffers = workspace_default.registerBufferSync((doc) => {
          if (doc.buftype !== "")
            return void 0;
          let buf = new DiagnosticBuffer(this.nvim, doc.bufnr, doc.uri, this.config, (diagnostics2) => {
            this._onDidRefresh.fire({ diagnostics: diagnostics2, uri: buf.uri, bufnr: buf.bufnr });
            if (["never", "jump"].includes(this.config.enableMessage)) {
              return;
            }
            this.echoMessage(true).logError();
          });
          let diagnostics = this.getDiagnostics(doc.uri);
          if (this.enabled)
            buf.forceRefresh(diagnostics);
          return buf;
        });
        events_default.on("CursorMoved", (bufnr) => {
          if (this.config.enableMessage != "always")
            return;
          if (this.timer)
            clearTimeout(this.timer);
          if (bufnr == this.floatFactory.bufnr)
            return;
          this.timer = setTimeout(async () => {
            await this.echoMessage(true);
          }, this.config.messageDelay);
        }, null, this.disposables);
        let fn = (0, import_debounce5.default)((bufnr, cursor) => {
          if (!this.config.virtualText || !this.config.virtualTextCurrentLineOnly) {
            return;
          }
          let buf = this.buffers.getItem(bufnr);
          if (buf) {
            let diagnostics = this.getDiagnostics(buf.uri);
            buf.showVirtualText(diagnostics, cursor[0]);
          }
        }, 100);
        events_default.on("CursorMoved", fn, null, this.disposables);
        this.disposables.push(import_vscode_languageserver_protocol18.Disposable.create(() => {
          fn.clear();
        }));
        events_default.on("InsertLeave", async (bufnr) => {
          if (!this.config.refreshOnInsertMode) {
            this.refreshBuffer(bufnr);
          }
        }, null, this.disposables);
        events_default.on("BufEnter", async () => {
          if (this.timer)
            clearTimeout(this.timer);
        }, null, this.disposables);
        this.setConfigurationErrors(true);
        workspace_default.configurations.onError(() => {
          this.setConfigurationErrors();
        }, null, this.disposables);
      }
      defineSigns() {
        let { nvim } = this;
        let { enableHighlightLineNumber, enableSign } = this.config;
        if (!enableSign)
          return;
        nvim.pauseNotification();
        for (let kind of ["Error", "Warning", "Info", "Hint"]) {
          let signText = this.config[kind.toLowerCase() + "Sign"];
          let cmd = `sign define Coc${kind} linehl=Coc${kind}Line`;
          if (signText)
            cmd += ` texthl=Coc${kind}Sign text=${signText}`;
          if (enableHighlightLineNumber)
            cmd += ` numhl=Coc${kind}Sign`;
          nvim.command(cmd, true);
        }
        nvim.resumeNotification(false, true);
      }
      async setLocationlist(bufnr) {
        let buf = this.buffers.getItem(bufnr);
        let diagnostics = buf ? this.getDiagnostics(buf.uri) : [];
        let items = [];
        for (let diagnostic of diagnostics) {
          let item = getLocationListItem(bufnr, diagnostic);
          items.push(item);
        }
        let curr = await this.nvim.call("getloclist", [0, { title: 1 }]);
        let action = curr.title && curr.title.indexOf("Diagnostics of coc") != -1 ? "r" : " ";
        await this.nvim.call("setloclist", [0, [], action, { title: "Diagnostics of coc", items }]);
      }
      setConfigurationErrors(init) {
        let collections = this.collections;
        let collection = collections.find((o) => o.name == "config");
        if (!collection) {
          collection = this.create("config");
        } else {
          collection.clear();
        }
        let { errorItems } = workspace_default.configurations;
        if (errorItems && errorItems.length) {
          if (init)
            window_default.showMessage(`settings file parse error, run ':CocList diagnostics'`, "error");
          let entries = new Map();
          for (let item of errorItems) {
            let { uri } = item.location;
            let diagnostics = entries.get(uri) || [];
            diagnostics.push(import_vscode_languageserver_protocol18.Diagnostic.create(item.location.range, item.message, import_vscode_languageserver_protocol18.DiagnosticSeverity.Error));
            entries.set(uri, diagnostics);
          }
          collection.set(Array.from(entries));
        }
      }
      create(name2) {
        let collection = this.getCollectionByName(name2);
        if (collection)
          return collection;
        collection = new Collection(name2);
        this.collections.push(collection);
        collection.onDidDiagnosticsChange((uri) => {
          this.refreshBuffer(uri);
        });
        collection.onDidDiagnosticsClear((uris) => {
          for (let uri of uris) {
            this.refreshBuffer(uri, true);
          }
        });
        collection.onDispose(() => {
          let idx = this.collections.findIndex((o) => o == collection);
          if (idx !== -1)
            this.collections.splice(idx, 1);
        });
        return collection;
      }
      getSortedRanges(uri, severity) {
        let collections = this.getCollections(uri);
        let res = [];
        let level = severity ? severityLevel(severity) : 0;
        for (let collection of collections) {
          let diagnostics = collection.get(uri);
          if (level)
            diagnostics = diagnostics.filter((o) => o.severity == level);
          let ranges = diagnostics.map((o) => o.range);
          res.push(...ranges);
        }
        res.sort((a, b) => {
          if (a.start.line != b.start.line) {
            return a.start.line - b.start.line;
          }
          return a.start.character - b.start.character;
        });
        return res;
      }
      getDiagnostics(uri) {
        let collections = this.getCollections(uri);
        let { level, showUnused, showDeprecated } = this.config;
        let res = [];
        for (let collection of collections) {
          let items = collection.get(uri);
          if (!items)
            continue;
          items = items.filter((d) => {
            var _a2, _b;
            if (level && level < import_vscode_languageserver_protocol18.DiagnosticSeverity.Hint && d.severity && d.severity > level) {
              return false;
            }
            if (!showUnused && ((_a2 = d.tags) == null ? void 0 : _a2.includes(import_vscode_languageserver_protocol18.DiagnosticTag.Unnecessary))) {
              return false;
            }
            if (!showDeprecated && ((_b = d.tags) == null ? void 0 : _b.includes(import_vscode_languageserver_protocol18.DiagnosticTag.Deprecated))) {
              return false;
            }
            return true;
          });
          items.forEach((item) => {
            res.push(Object.assign({ collection: collection.name }, item));
          });
        }
        res.sort((a, b) => {
          if (a.severity == b.severity) {
            let d = comparePosition(a.range.start, b.range.start);
            if (d != 0)
              return d;
            if (a.source == b.source)
              return a.message > b.message ? 1 : -1;
            return a.source > b.source ? 1 : -1;
          }
          return a.severity - b.severity;
        });
        return res;
      }
      getDiagnosticsInRange(document2, range) {
        let collections = this.getCollections(document2.uri);
        let res = [];
        for (let collection of collections) {
          let items = collection.get(document2.uri);
          if (!items)
            continue;
          for (let item of items) {
            if (rangeIntersect(item.range, range)) {
              res.push(item);
            }
          }
        }
        return res;
      }
      async preview() {
        let [bufnr, cursor] = await this.nvim.eval('[bufnr("%"),coc#util#cursor()]');
        let { nvim } = this;
        let diagnostics = this.getDiagnosticsAt(bufnr, cursor);
        if (diagnostics.length == 0) {
          nvim.command("pclose", true);
          window_default.showMessage(`Empty diagnostics`, "warning");
          return;
        }
        let lines = [];
        for (let diagnostic of diagnostics) {
          let { source, code, severity, message } = diagnostic;
          let s = getSeverityName(severity)[0];
          lines.push(`[${source}${code ? " " + code : ""}] [${s}]`);
          lines.push(...message.split(/\r?\n/));
          lines.push("");
        }
        nvim.call("coc#util#preview_info", [lines, "txt"], true);
      }
      async jumpPrevious(severity) {
        let buffer = await this.nvim.buffer;
        let document2 = workspace_default.getDocument(buffer.id);
        if (!document2)
          return;
        let curpos = await window_default.getCursorPosition();
        let ranges = this.getSortedRanges(document2.uri, severity);
        if (ranges.length == 0) {
          window_default.showMessage("Empty diagnostics", "warning");
          return;
        }
        let pos;
        for (let i = ranges.length - 1; i >= 0; i--) {
          let end = ranges[i].end;
          if (comparePosition(end, curpos) < 0) {
            pos = ranges[i].start;
            break;
          } else if (i == 0) {
            let wrapscan = await this.nvim.getOption("wrapscan");
            if (wrapscan)
              pos = ranges[ranges.length - 1].start;
          }
        }
        if (pos) {
          await window_default.moveTo(pos);
          if (this.config.enableMessage == "never")
            return;
          await this.echoMessage(false);
        }
      }
      async jumpNext(severity) {
        let buffer = await this.nvim.buffer;
        let document2 = workspace_default.getDocument(buffer.id);
        let curpos = await window_default.getCursorPosition();
        let ranges = this.getSortedRanges(document2.uri, severity);
        if (ranges.length == 0) {
          window_default.showMessage("Empty diagnostics", "warning");
          return;
        }
        let pos;
        for (let i = 0; i <= ranges.length - 1; i++) {
          let start = ranges[i].start;
          if (comparePosition(start, curpos) > 0) {
            pos = ranges[i].start;
            break;
          } else if (i == ranges.length - 1) {
            let wrapscan = await this.nvim.getOption("wrapscan");
            if (wrapscan)
              pos = ranges[0].start;
          }
        }
        if (pos) {
          await window_default.moveTo(pos);
          if (this.config.enableMessage == "never")
            return;
          await this.echoMessage(false);
        }
      }
      getDiagnosticList() {
        let res = [];
        const { level, showUnused, showDeprecated } = this.config;
        for (let collection of this.collections) {
          collection.forEach((uri, diagnostics) => {
            var _a2, _b;
            let file = URI.parse(uri).fsPath;
            for (let diagnostic of diagnostics) {
              if (diagnostic.severity && diagnostic.severity > level) {
                continue;
              }
              if (!showUnused && ((_a2 = diagnostic.tags) == null ? void 0 : _a2.includes(import_vscode_languageserver_protocol18.DiagnosticTag.Unnecessary))) {
                continue;
              }
              if (!showDeprecated && ((_b = diagnostic.tags) == null ? void 0 : _b.includes(import_vscode_languageserver_protocol18.DiagnosticTag.Deprecated))) {
                continue;
              }
              let { start } = diagnostic.range;
              let o = {
                file,
                lnum: start.line + 1,
                col: start.character + 1,
                code: diagnostic.code,
                source: diagnostic.source || collection.name,
                message: diagnostic.message,
                severity: getSeverityName(diagnostic.severity),
                level: diagnostic.severity || 0,
                location: import_vscode_languageserver_protocol18.Location.create(uri, diagnostic.range)
              };
              res.push(o);
            }
          });
        }
        res.sort((a, b) => {
          if (a.level !== b.level) {
            return a.level - b.level;
          }
          if (a.file !== b.file) {
            return a.file > b.file ? 1 : -1;
          } else {
            if (a.lnum != b.lnum) {
              return a.lnum - b.lnum;
            }
            return a.col - b.col;
          }
        });
        return res;
      }
      getDiagnosticsAt(bufnr, cursor) {
        let buffer = this.buffers.getItem(bufnr);
        if (!buffer)
          return [];
        let pos = import_vscode_languageserver_protocol18.Position.create(cursor[0], cursor[1]);
        return buffer.getDiagnosticsAt(pos, this.config.checkCurrentLine);
      }
      async getCurrentDiagnostics() {
        let [bufnr, cursor] = await this.nvim.eval('[bufnr("%"),coc#util#cursor()]');
        return this.getDiagnosticsAt(bufnr, cursor);
      }
      async echoMessage(truncate = false) {
        const config = this.config;
        if (!this.enabled || config.displayByAle)
          return;
        if (this.timer)
          clearTimeout(this.timer);
        let useFloat = config.messageTarget == "float";
        let [bufnr, cursor, filetype, mode] = await this.nvim.eval('[bufnr("%"),coc#util#cursor(),&filetype,mode()]');
        if (mode != "n")
          return;
        let diagnostics = this.getDiagnosticsAt(bufnr, cursor);
        if (diagnostics.length == 0) {
          if (useFloat) {
            this.floatFactory.close();
          } else {
            let echoLine = await this.nvim.call("coc#util#echo_line");
            if (this.lastMessage && echoLine.startsWith(this.lastMessage)) {
              this.nvim.command('echo ""', true);
            }
          }
          return;
        }
        if (truncate && workspace_default.insertMode)
          return;
        let docs = [];
        let ft = "";
        if (Object.keys(config.filetypeMap).length > 0) {
          const defaultFiletype = config.filetypeMap["default"] || "";
          ft = config.filetypeMap[filetype] || (defaultFiletype == "bufferType" ? filetype : defaultFiletype);
        }
        diagnostics.forEach((diagnostic) => {
          let { source, code, severity, message } = diagnostic;
          let s = getSeverityName(severity)[0];
          const codeStr = code ? " " + code : "";
          const str = config.format.replace("%source", source).replace("%code", codeStr).replace("%severity", s).replace("%message", message);
          let filetype2 = "Error";
          if (ft === "") {
            switch (severity) {
              case import_vscode_languageserver_protocol18.DiagnosticSeverity.Hint:
                filetype2 = "Hint";
                break;
              case import_vscode_languageserver_protocol18.DiagnosticSeverity.Warning:
                filetype2 = "Warning";
                break;
              case import_vscode_languageserver_protocol18.DiagnosticSeverity.Information:
                filetype2 = "Info";
                break;
            }
          } else {
            filetype2 = ft;
          }
          docs.push({ filetype: filetype2, content: str });
        });
        if (useFloat) {
          let { maxWindowHeight, maxWindowWidth } = this.config;
          await this.floatFactory.show(docs, { maxWidth: maxWindowWidth, maxHeight: maxWindowHeight, modes: ["n"] });
        } else {
          let lines = docs.map((d) => d.content).join("\n").split(/\r?\n/);
          if (lines.length) {
            await this.nvim.command('echo ""');
            this.lastMessage = lines[0].slice(0, 30);
            await window_default.echoLines(lines, truncate);
          }
        }
      }
      async jumpRelated() {
        let diagnostics = await this.getCurrentDiagnostics();
        if (!diagnostics)
          return;
        let diagnostic = diagnostics.find((o) => o.relatedInformation != null);
        if (!diagnostic)
          return;
        let locations = diagnostic.relatedInformation.map((o) => o.location);
        if (locations.length == 1) {
          await workspace_default.jumpTo(locations[0].uri, locations[0].range.start);
        } else if (locations.length > 1) {
          await workspace_default.showLocations(locations);
        }
      }
      reset() {
        if (this.timer) {
          clearTimeout(this.timer);
        }
        this.buffers.reset();
        for (let collection of this.collections) {
          collection.dispose();
        }
        this.collections = [];
      }
      dispose() {
        var _a2;
        this.buffers.dispose();
        if (this.timer) {
          clearTimeout(this.timer);
        }
        for (let collection of this.collections) {
          collection.dispose();
        }
        (_a2 = this.floatFactory) == null ? void 0 : _a2.close();
        this.collections = [];
        disposeAll(this.disposables);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      setConfiguration(event) {
        if (event && !event.affectsConfiguration("diagnostic"))
          return;
        let config = workspace_default.getConfiguration("diagnostic");
        let messageTarget = config.get("messageTarget", "float");
        if (messageTarget == "float" && !workspace_default.env.floating && !workspace_default.env.textprop) {
          messageTarget = "echo";
        }
        let enableHighlightLineNumber = config.get("enableHighlightLineNumber", true);
        if (!workspace_default.isNvim || import_semver.default.lt(workspace_default.env.version, "v0.3.2")) {
          enableHighlightLineNumber = false;
        }
        this.config = {
          messageTarget,
          enableHighlightLineNumber,
          virtualTextSrcId: workspace_default.createNameSpace("diagnostic-virtualText"),
          checkCurrentLine: config.get("checkCurrentLine", false),
          enableSign: workspace_default.env.sign && config.get("enableSign", true),
          locationlistUpdate: config.get("locationlistUpdate", true),
          maxWindowHeight: config.get("maxWindowHeight", 10),
          maxWindowWidth: config.get("maxWindowWidth", 80),
          enableMessage: config.get("enableMessage", "always"),
          messageDelay: config.get("messageDelay", 200),
          virtualText: config.get("virtualText", false) && this.nvim.hasFunction("nvim_buf_set_virtual_text"),
          virtualTextCurrentLineOnly: config.get("virtualTextCurrentLineOnly", true),
          virtualTextPrefix: config.get("virtualTextPrefix", " "),
          virtualTextLineSeparator: config.get("virtualTextLineSeparator", " \\ "),
          virtualTextLines: config.get("virtualTextLines", 3),
          displayByAle: config.get("displayByAle", false),
          level: severityLevel(config.get("level", "hint")),
          signPriority: config.get("signPriority", 10),
          errorSign: config.get("errorSign", ">>"),
          warningSign: config.get("warningSign", ">>"),
          infoSign: config.get("infoSign", ">>"),
          hintSign: config.get("hintSign", ">>"),
          refreshOnInsertMode: config.get("refreshOnInsertMode", false),
          filetypeMap: config.get("filetypeMap", {}),
          showUnused: config.get("showUnused", true),
          showDeprecated: config.get("showDeprecated", true),
          format: config.get("format", "[%source%code] [%severity] %message")
        };
        this.enabled = config.get("enable", true);
        this.defineSigns();
      }
      getCollectionByName(name2) {
        return this.collections.find((o) => o.name == name2);
      }
      getCollections(uri) {
        return this.collections.filter((c) => c.has(uri));
      }
      toggleDiagnostic() {
        let { enabled } = this;
        this.enabled = !enabled;
        for (let buf of this.buffers.items) {
          if (this.enabled) {
            let diagnostics = this.getDiagnostics(buf.uri);
            buf.forceRefresh(diagnostics);
          } else {
            buf.clear();
          }
        }
      }
      toggleDiagnosticBuffer(bufnr) {
        if (!this.enabled)
          return;
        let buf = this.buffers.getItem(bufnr);
        if (buf) {
          if (buf.enabled) {
            buf.changeState(DiagnosticState.Disabled);
            buf.clear();
          } else {
            buf.changeState(DiagnosticState.Enabled);
            let diagnostics = this.getDiagnostics(buf.uri);
            buf.forceRefresh(diagnostics);
          }
        }
      }
      refreshBuffer(uri, force = false) {
        if (!this.enabled)
          return false;
        let buf = this.buffers.getItem(uri);
        if (!buf)
          return false;
        let diagnostics = this.getDiagnostics(buf.uri);
        if (force) {
          buf.forceRefresh(diagnostics);
        } else {
          buf.refresh(diagnostics);
        }
        return true;
      }
    };
    manager_default = new DiagnosticManager();
  }
});

// src/util/charCode.ts
var CharCode;
var init_charCode = __esm({
  "src/util/charCode.ts"() {
    (function(CharCode2) {
      CharCode2[CharCode2["Null"] = 0] = "Null";
      CharCode2[CharCode2["Backspace"] = 8] = "Backspace";
      CharCode2[CharCode2["Tab"] = 9] = "Tab";
      CharCode2[CharCode2["LineFeed"] = 10] = "LineFeed";
      CharCode2[CharCode2["CarriageReturn"] = 13] = "CarriageReturn";
      CharCode2[CharCode2["Space"] = 32] = "Space";
      CharCode2[CharCode2["ExclamationMark"] = 33] = "ExclamationMark";
      CharCode2[CharCode2["DoubleQuote"] = 34] = "DoubleQuote";
      CharCode2[CharCode2["Hash"] = 35] = "Hash";
      CharCode2[CharCode2["DollarSign"] = 36] = "DollarSign";
      CharCode2[CharCode2["PercentSign"] = 37] = "PercentSign";
      CharCode2[CharCode2["Ampersand"] = 38] = "Ampersand";
      CharCode2[CharCode2["SingleQuote"] = 39] = "SingleQuote";
      CharCode2[CharCode2["OpenParen"] = 40] = "OpenParen";
      CharCode2[CharCode2["CloseParen"] = 41] = "CloseParen";
      CharCode2[CharCode2["Asterisk"] = 42] = "Asterisk";
      CharCode2[CharCode2["Plus"] = 43] = "Plus";
      CharCode2[CharCode2["Comma"] = 44] = "Comma";
      CharCode2[CharCode2["Dash"] = 45] = "Dash";
      CharCode2[CharCode2["Period"] = 46] = "Period";
      CharCode2[CharCode2["Slash"] = 47] = "Slash";
      CharCode2[CharCode2["Digit0"] = 48] = "Digit0";
      CharCode2[CharCode2["Digit1"] = 49] = "Digit1";
      CharCode2[CharCode2["Digit2"] = 50] = "Digit2";
      CharCode2[CharCode2["Digit3"] = 51] = "Digit3";
      CharCode2[CharCode2["Digit4"] = 52] = "Digit4";
      CharCode2[CharCode2["Digit5"] = 53] = "Digit5";
      CharCode2[CharCode2["Digit6"] = 54] = "Digit6";
      CharCode2[CharCode2["Digit7"] = 55] = "Digit7";
      CharCode2[CharCode2["Digit8"] = 56] = "Digit8";
      CharCode2[CharCode2["Digit9"] = 57] = "Digit9";
      CharCode2[CharCode2["Colon"] = 58] = "Colon";
      CharCode2[CharCode2["Semicolon"] = 59] = "Semicolon";
      CharCode2[CharCode2["LessThan"] = 60] = "LessThan";
      CharCode2[CharCode2["Equals"] = 61] = "Equals";
      CharCode2[CharCode2["GreaterThan"] = 62] = "GreaterThan";
      CharCode2[CharCode2["QuestionMark"] = 63] = "QuestionMark";
      CharCode2[CharCode2["AtSign"] = 64] = "AtSign";
      CharCode2[CharCode2["A"] = 65] = "A";
      CharCode2[CharCode2["B"] = 66] = "B";
      CharCode2[CharCode2["C"] = 67] = "C";
      CharCode2[CharCode2["D"] = 68] = "D";
      CharCode2[CharCode2["E"] = 69] = "E";
      CharCode2[CharCode2["F"] = 70] = "F";
      CharCode2[CharCode2["G"] = 71] = "G";
      CharCode2[CharCode2["H"] = 72] = "H";
      CharCode2[CharCode2["I"] = 73] = "I";
      CharCode2[CharCode2["J"] = 74] = "J";
      CharCode2[CharCode2["K"] = 75] = "K";
      CharCode2[CharCode2["L"] = 76] = "L";
      CharCode2[CharCode2["M"] = 77] = "M";
      CharCode2[CharCode2["N"] = 78] = "N";
      CharCode2[CharCode2["O"] = 79] = "O";
      CharCode2[CharCode2["P"] = 80] = "P";
      CharCode2[CharCode2["Q"] = 81] = "Q";
      CharCode2[CharCode2["R"] = 82] = "R";
      CharCode2[CharCode2["S"] = 83] = "S";
      CharCode2[CharCode2["T"] = 84] = "T";
      CharCode2[CharCode2["U"] = 85] = "U";
      CharCode2[CharCode2["V"] = 86] = "V";
      CharCode2[CharCode2["W"] = 87] = "W";
      CharCode2[CharCode2["X"] = 88] = "X";
      CharCode2[CharCode2["Y"] = 89] = "Y";
      CharCode2[CharCode2["Z"] = 90] = "Z";
      CharCode2[CharCode2["OpenSquareBracket"] = 91] = "OpenSquareBracket";
      CharCode2[CharCode2["Backslash"] = 92] = "Backslash";
      CharCode2[CharCode2["CloseSquareBracket"] = 93] = "CloseSquareBracket";
      CharCode2[CharCode2["Caret"] = 94] = "Caret";
      CharCode2[CharCode2["Underline"] = 95] = "Underline";
      CharCode2[CharCode2["BackTick"] = 96] = "BackTick";
      CharCode2[CharCode2["a"] = 97] = "a";
      CharCode2[CharCode2["b"] = 98] = "b";
      CharCode2[CharCode2["c"] = 99] = "c";
      CharCode2[CharCode2["d"] = 100] = "d";
      CharCode2[CharCode2["e"] = 101] = "e";
      CharCode2[CharCode2["f"] = 102] = "f";
      CharCode2[CharCode2["g"] = 103] = "g";
      CharCode2[CharCode2["h"] = 104] = "h";
      CharCode2[CharCode2["i"] = 105] = "i";
      CharCode2[CharCode2["j"] = 106] = "j";
      CharCode2[CharCode2["k"] = 107] = "k";
      CharCode2[CharCode2["l"] = 108] = "l";
      CharCode2[CharCode2["m"] = 109] = "m";
      CharCode2[CharCode2["n"] = 110] = "n";
      CharCode2[CharCode2["o"] = 111] = "o";
      CharCode2[CharCode2["p"] = 112] = "p";
      CharCode2[CharCode2["q"] = 113] = "q";
      CharCode2[CharCode2["r"] = 114] = "r";
      CharCode2[CharCode2["s"] = 115] = "s";
      CharCode2[CharCode2["t"] = 116] = "t";
      CharCode2[CharCode2["u"] = 117] = "u";
      CharCode2[CharCode2["v"] = 118] = "v";
      CharCode2[CharCode2["w"] = 119] = "w";
      CharCode2[CharCode2["x"] = 120] = "x";
      CharCode2[CharCode2["y"] = 121] = "y";
      CharCode2[CharCode2["z"] = 122] = "z";
      CharCode2[CharCode2["OpenCurlyBrace"] = 123] = "OpenCurlyBrace";
      CharCode2[CharCode2["Pipe"] = 124] = "Pipe";
      CharCode2[CharCode2["CloseCurlyBrace"] = 125] = "CloseCurlyBrace";
      CharCode2[CharCode2["Tilde"] = 126] = "Tilde";
      CharCode2[CharCode2["U_Combining_Grave_Accent"] = 768] = "U_Combining_Grave_Accent";
      CharCode2[CharCode2["U_Combining_Acute_Accent"] = 769] = "U_Combining_Acute_Accent";
      CharCode2[CharCode2["U_Combining_Circumflex_Accent"] = 770] = "U_Combining_Circumflex_Accent";
      CharCode2[CharCode2["U_Combining_Tilde"] = 771] = "U_Combining_Tilde";
      CharCode2[CharCode2["U_Combining_Macron"] = 772] = "U_Combining_Macron";
      CharCode2[CharCode2["U_Combining_Overline"] = 773] = "U_Combining_Overline";
      CharCode2[CharCode2["U_Combining_Breve"] = 774] = "U_Combining_Breve";
      CharCode2[CharCode2["U_Combining_Dot_Above"] = 775] = "U_Combining_Dot_Above";
      CharCode2[CharCode2["U_Combining_Diaeresis"] = 776] = "U_Combining_Diaeresis";
      CharCode2[CharCode2["U_Combining_Hook_Above"] = 777] = "U_Combining_Hook_Above";
      CharCode2[CharCode2["U_Combining_Ring_Above"] = 778] = "U_Combining_Ring_Above";
      CharCode2[CharCode2["U_Combining_Double_Acute_Accent"] = 779] = "U_Combining_Double_Acute_Accent";
      CharCode2[CharCode2["U_Combining_Caron"] = 780] = "U_Combining_Caron";
      CharCode2[CharCode2["U_Combining_Vertical_Line_Above"] = 781] = "U_Combining_Vertical_Line_Above";
      CharCode2[CharCode2["U_Combining_Double_Vertical_Line_Above"] = 782] = "U_Combining_Double_Vertical_Line_Above";
      CharCode2[CharCode2["U_Combining_Double_Grave_Accent"] = 783] = "U_Combining_Double_Grave_Accent";
      CharCode2[CharCode2["U_Combining_Candrabindu"] = 784] = "U_Combining_Candrabindu";
      CharCode2[CharCode2["U_Combining_Inverted_Breve"] = 785] = "U_Combining_Inverted_Breve";
      CharCode2[CharCode2["U_Combining_Turned_Comma_Above"] = 786] = "U_Combining_Turned_Comma_Above";
      CharCode2[CharCode2["U_Combining_Comma_Above"] = 787] = "U_Combining_Comma_Above";
      CharCode2[CharCode2["U_Combining_Reversed_Comma_Above"] = 788] = "U_Combining_Reversed_Comma_Above";
      CharCode2[CharCode2["U_Combining_Comma_Above_Right"] = 789] = "U_Combining_Comma_Above_Right";
      CharCode2[CharCode2["U_Combining_Grave_Accent_Below"] = 790] = "U_Combining_Grave_Accent_Below";
      CharCode2[CharCode2["U_Combining_Acute_Accent_Below"] = 791] = "U_Combining_Acute_Accent_Below";
      CharCode2[CharCode2["U_Combining_Left_Tack_Below"] = 792] = "U_Combining_Left_Tack_Below";
      CharCode2[CharCode2["U_Combining_Right_Tack_Below"] = 793] = "U_Combining_Right_Tack_Below";
      CharCode2[CharCode2["U_Combining_Left_Angle_Above"] = 794] = "U_Combining_Left_Angle_Above";
      CharCode2[CharCode2["U_Combining_Horn"] = 795] = "U_Combining_Horn";
      CharCode2[CharCode2["U_Combining_Left_Half_Ring_Below"] = 796] = "U_Combining_Left_Half_Ring_Below";
      CharCode2[CharCode2["U_Combining_Up_Tack_Below"] = 797] = "U_Combining_Up_Tack_Below";
      CharCode2[CharCode2["U_Combining_Down_Tack_Below"] = 798] = "U_Combining_Down_Tack_Below";
      CharCode2[CharCode2["U_Combining_Plus_Sign_Below"] = 799] = "U_Combining_Plus_Sign_Below";
      CharCode2[CharCode2["U_Combining_Minus_Sign_Below"] = 800] = "U_Combining_Minus_Sign_Below";
      CharCode2[CharCode2["U_Combining_Palatalized_Hook_Below"] = 801] = "U_Combining_Palatalized_Hook_Below";
      CharCode2[CharCode2["U_Combining_Retroflex_Hook_Below"] = 802] = "U_Combining_Retroflex_Hook_Below";
      CharCode2[CharCode2["U_Combining_Dot_Below"] = 803] = "U_Combining_Dot_Below";
      CharCode2[CharCode2["U_Combining_Diaeresis_Below"] = 804] = "U_Combining_Diaeresis_Below";
      CharCode2[CharCode2["U_Combining_Ring_Below"] = 805] = "U_Combining_Ring_Below";
      CharCode2[CharCode2["U_Combining_Comma_Below"] = 806] = "U_Combining_Comma_Below";
      CharCode2[CharCode2["U_Combining_Cedilla"] = 807] = "U_Combining_Cedilla";
      CharCode2[CharCode2["U_Combining_Ogonek"] = 808] = "U_Combining_Ogonek";
      CharCode2[CharCode2["U_Combining_Vertical_Line_Below"] = 809] = "U_Combining_Vertical_Line_Below";
      CharCode2[CharCode2["U_Combining_Bridge_Below"] = 810] = "U_Combining_Bridge_Below";
      CharCode2[CharCode2["U_Combining_Inverted_Double_Arch_Below"] = 811] = "U_Combining_Inverted_Double_Arch_Below";
      CharCode2[CharCode2["U_Combining_Caron_Below"] = 812] = "U_Combining_Caron_Below";
      CharCode2[CharCode2["U_Combining_Circumflex_Accent_Below"] = 813] = "U_Combining_Circumflex_Accent_Below";
      CharCode2[CharCode2["U_Combining_Breve_Below"] = 814] = "U_Combining_Breve_Below";
      CharCode2[CharCode2["U_Combining_Inverted_Breve_Below"] = 815] = "U_Combining_Inverted_Breve_Below";
      CharCode2[CharCode2["U_Combining_Tilde_Below"] = 816] = "U_Combining_Tilde_Below";
      CharCode2[CharCode2["U_Combining_Macron_Below"] = 817] = "U_Combining_Macron_Below";
      CharCode2[CharCode2["U_Combining_Low_Line"] = 818] = "U_Combining_Low_Line";
      CharCode2[CharCode2["U_Combining_Double_Low_Line"] = 819] = "U_Combining_Double_Low_Line";
      CharCode2[CharCode2["U_Combining_Tilde_Overlay"] = 820] = "U_Combining_Tilde_Overlay";
      CharCode2[CharCode2["U_Combining_Short_Stroke_Overlay"] = 821] = "U_Combining_Short_Stroke_Overlay";
      CharCode2[CharCode2["U_Combining_Long_Stroke_Overlay"] = 822] = "U_Combining_Long_Stroke_Overlay";
      CharCode2[CharCode2["U_Combining_Short_Solidus_Overlay"] = 823] = "U_Combining_Short_Solidus_Overlay";
      CharCode2[CharCode2["U_Combining_Long_Solidus_Overlay"] = 824] = "U_Combining_Long_Solidus_Overlay";
      CharCode2[CharCode2["U_Combining_Right_Half_Ring_Below"] = 825] = "U_Combining_Right_Half_Ring_Below";
      CharCode2[CharCode2["U_Combining_Inverted_Bridge_Below"] = 826] = "U_Combining_Inverted_Bridge_Below";
      CharCode2[CharCode2["U_Combining_Square_Below"] = 827] = "U_Combining_Square_Below";
      CharCode2[CharCode2["U_Combining_Seagull_Below"] = 828] = "U_Combining_Seagull_Below";
      CharCode2[CharCode2["U_Combining_X_Above"] = 829] = "U_Combining_X_Above";
      CharCode2[CharCode2["U_Combining_Vertical_Tilde"] = 830] = "U_Combining_Vertical_Tilde";
      CharCode2[CharCode2["U_Combining_Double_Overline"] = 831] = "U_Combining_Double_Overline";
      CharCode2[CharCode2["U_Combining_Grave_Tone_Mark"] = 832] = "U_Combining_Grave_Tone_Mark";
      CharCode2[CharCode2["U_Combining_Acute_Tone_Mark"] = 833] = "U_Combining_Acute_Tone_Mark";
      CharCode2[CharCode2["U_Combining_Greek_Perispomeni"] = 834] = "U_Combining_Greek_Perispomeni";
      CharCode2[CharCode2["U_Combining_Greek_Koronis"] = 835] = "U_Combining_Greek_Koronis";
      CharCode2[CharCode2["U_Combining_Greek_Dialytika_Tonos"] = 836] = "U_Combining_Greek_Dialytika_Tonos";
      CharCode2[CharCode2["U_Combining_Greek_Ypogegrammeni"] = 837] = "U_Combining_Greek_Ypogegrammeni";
      CharCode2[CharCode2["U_Combining_Bridge_Above"] = 838] = "U_Combining_Bridge_Above";
      CharCode2[CharCode2["U_Combining_Equals_Sign_Below"] = 839] = "U_Combining_Equals_Sign_Below";
      CharCode2[CharCode2["U_Combining_Double_Vertical_Line_Below"] = 840] = "U_Combining_Double_Vertical_Line_Below";
      CharCode2[CharCode2["U_Combining_Left_Angle_Below"] = 841] = "U_Combining_Left_Angle_Below";
      CharCode2[CharCode2["U_Combining_Not_Tilde_Above"] = 842] = "U_Combining_Not_Tilde_Above";
      CharCode2[CharCode2["U_Combining_Homothetic_Above"] = 843] = "U_Combining_Homothetic_Above";
      CharCode2[CharCode2["U_Combining_Almost_Equal_To_Above"] = 844] = "U_Combining_Almost_Equal_To_Above";
      CharCode2[CharCode2["U_Combining_Left_Right_Arrow_Below"] = 845] = "U_Combining_Left_Right_Arrow_Below";
      CharCode2[CharCode2["U_Combining_Upwards_Arrow_Below"] = 846] = "U_Combining_Upwards_Arrow_Below";
      CharCode2[CharCode2["U_Combining_Grapheme_Joiner"] = 847] = "U_Combining_Grapheme_Joiner";
      CharCode2[CharCode2["U_Combining_Right_Arrowhead_Above"] = 848] = "U_Combining_Right_Arrowhead_Above";
      CharCode2[CharCode2["U_Combining_Left_Half_Ring_Above"] = 849] = "U_Combining_Left_Half_Ring_Above";
      CharCode2[CharCode2["U_Combining_Fermata"] = 850] = "U_Combining_Fermata";
      CharCode2[CharCode2["U_Combining_X_Below"] = 851] = "U_Combining_X_Below";
      CharCode2[CharCode2["U_Combining_Left_Arrowhead_Below"] = 852] = "U_Combining_Left_Arrowhead_Below";
      CharCode2[CharCode2["U_Combining_Right_Arrowhead_Below"] = 853] = "U_Combining_Right_Arrowhead_Below";
      CharCode2[CharCode2["U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below"] = 854] = "U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below";
      CharCode2[CharCode2["U_Combining_Right_Half_Ring_Above"] = 855] = "U_Combining_Right_Half_Ring_Above";
      CharCode2[CharCode2["U_Combining_Dot_Above_Right"] = 856] = "U_Combining_Dot_Above_Right";
      CharCode2[CharCode2["U_Combining_Asterisk_Below"] = 857] = "U_Combining_Asterisk_Below";
      CharCode2[CharCode2["U_Combining_Double_Ring_Below"] = 858] = "U_Combining_Double_Ring_Below";
      CharCode2[CharCode2["U_Combining_Zigzag_Above"] = 859] = "U_Combining_Zigzag_Above";
      CharCode2[CharCode2["U_Combining_Double_Breve_Below"] = 860] = "U_Combining_Double_Breve_Below";
      CharCode2[CharCode2["U_Combining_Double_Breve"] = 861] = "U_Combining_Double_Breve";
      CharCode2[CharCode2["U_Combining_Double_Macron"] = 862] = "U_Combining_Double_Macron";
      CharCode2[CharCode2["U_Combining_Double_Macron_Below"] = 863] = "U_Combining_Double_Macron_Below";
      CharCode2[CharCode2["U_Combining_Double_Tilde"] = 864] = "U_Combining_Double_Tilde";
      CharCode2[CharCode2["U_Combining_Double_Inverted_Breve"] = 865] = "U_Combining_Double_Inverted_Breve";
      CharCode2[CharCode2["U_Combining_Double_Rightwards_Arrow_Below"] = 866] = "U_Combining_Double_Rightwards_Arrow_Below";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_A"] = 867] = "U_Combining_Latin_Small_Letter_A";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_E"] = 868] = "U_Combining_Latin_Small_Letter_E";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_I"] = 869] = "U_Combining_Latin_Small_Letter_I";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_O"] = 870] = "U_Combining_Latin_Small_Letter_O";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_U"] = 871] = "U_Combining_Latin_Small_Letter_U";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_C"] = 872] = "U_Combining_Latin_Small_Letter_C";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_D"] = 873] = "U_Combining_Latin_Small_Letter_D";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_H"] = 874] = "U_Combining_Latin_Small_Letter_H";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_M"] = 875] = "U_Combining_Latin_Small_Letter_M";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_R"] = 876] = "U_Combining_Latin_Small_Letter_R";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_T"] = 877] = "U_Combining_Latin_Small_Letter_T";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_V"] = 878] = "U_Combining_Latin_Small_Letter_V";
      CharCode2[CharCode2["U_Combining_Latin_Small_Letter_X"] = 879] = "U_Combining_Latin_Small_Letter_X";
      CharCode2[CharCode2["LINE_SEPARATOR_2028"] = 8232] = "LINE_SEPARATOR_2028";
      CharCode2[CharCode2["U_CIRCUMFLEX"] = 94] = "U_CIRCUMFLEX";
      CharCode2[CharCode2["U_GRAVE_ACCENT"] = 96] = "U_GRAVE_ACCENT";
      CharCode2[CharCode2["U_DIAERESIS"] = 168] = "U_DIAERESIS";
      CharCode2[CharCode2["U_MACRON"] = 175] = "U_MACRON";
      CharCode2[CharCode2["U_ACUTE_ACCENT"] = 180] = "U_ACUTE_ACCENT";
      CharCode2[CharCode2["U_CEDILLA"] = 184] = "U_CEDILLA";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LEFT_ARROWHEAD"] = 706] = "U_MODIFIER_LETTER_LEFT_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_RIGHT_ARROWHEAD"] = 707] = "U_MODIFIER_LETTER_RIGHT_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_UP_ARROWHEAD"] = 708] = "U_MODIFIER_LETTER_UP_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_DOWN_ARROWHEAD"] = 709] = "U_MODIFIER_LETTER_DOWN_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING"] = 722] = "U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING";
      CharCode2[CharCode2["U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING"] = 723] = "U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING";
      CharCode2[CharCode2["U_MODIFIER_LETTER_UP_TACK"] = 724] = "U_MODIFIER_LETTER_UP_TACK";
      CharCode2[CharCode2["U_MODIFIER_LETTER_DOWN_TACK"] = 725] = "U_MODIFIER_LETTER_DOWN_TACK";
      CharCode2[CharCode2["U_MODIFIER_LETTER_PLUS_SIGN"] = 726] = "U_MODIFIER_LETTER_PLUS_SIGN";
      CharCode2[CharCode2["U_MODIFIER_LETTER_MINUS_SIGN"] = 727] = "U_MODIFIER_LETTER_MINUS_SIGN";
      CharCode2[CharCode2["U_BREVE"] = 728] = "U_BREVE";
      CharCode2[CharCode2["U_DOT_ABOVE"] = 729] = "U_DOT_ABOVE";
      CharCode2[CharCode2["U_RING_ABOVE"] = 730] = "U_RING_ABOVE";
      CharCode2[CharCode2["U_OGONEK"] = 731] = "U_OGONEK";
      CharCode2[CharCode2["U_SMALL_TILDE"] = 732] = "U_SMALL_TILDE";
      CharCode2[CharCode2["U_DOUBLE_ACUTE_ACCENT"] = 733] = "U_DOUBLE_ACUTE_ACCENT";
      CharCode2[CharCode2["U_MODIFIER_LETTER_RHOTIC_HOOK"] = 734] = "U_MODIFIER_LETTER_RHOTIC_HOOK";
      CharCode2[CharCode2["U_MODIFIER_LETTER_CROSS_ACCENT"] = 735] = "U_MODIFIER_LETTER_CROSS_ACCENT";
      CharCode2[CharCode2["U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR"] = 741] = "U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR";
      CharCode2[CharCode2["U_MODIFIER_LETTER_HIGH_TONE_BAR"] = 742] = "U_MODIFIER_LETTER_HIGH_TONE_BAR";
      CharCode2[CharCode2["U_MODIFIER_LETTER_MID_TONE_BAR"] = 743] = "U_MODIFIER_LETTER_MID_TONE_BAR";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_TONE_BAR"] = 744] = "U_MODIFIER_LETTER_LOW_TONE_BAR";
      CharCode2[CharCode2["U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR"] = 745] = "U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR";
      CharCode2[CharCode2["U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK"] = 746] = "U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK";
      CharCode2[CharCode2["U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK"] = 747] = "U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK";
      CharCode2[CharCode2["U_MODIFIER_LETTER_UNASPIRATED"] = 749] = "U_MODIFIER_LETTER_UNASPIRATED";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD"] = 751] = "U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_UP_ARROWHEAD"] = 752] = "U_MODIFIER_LETTER_LOW_UP_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD"] = 753] = "U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD"] = 754] = "U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_RING"] = 755] = "U_MODIFIER_LETTER_LOW_RING";
      CharCode2[CharCode2["U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT"] = 756] = "U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT";
      CharCode2[CharCode2["U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT"] = 757] = "U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT";
      CharCode2[CharCode2["U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT"] = 758] = "U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_TILDE"] = 759] = "U_MODIFIER_LETTER_LOW_TILDE";
      CharCode2[CharCode2["U_MODIFIER_LETTER_RAISED_COLON"] = 760] = "U_MODIFIER_LETTER_RAISED_COLON";
      CharCode2[CharCode2["U_MODIFIER_LETTER_BEGIN_HIGH_TONE"] = 761] = "U_MODIFIER_LETTER_BEGIN_HIGH_TONE";
      CharCode2[CharCode2["U_MODIFIER_LETTER_END_HIGH_TONE"] = 762] = "U_MODIFIER_LETTER_END_HIGH_TONE";
      CharCode2[CharCode2["U_MODIFIER_LETTER_BEGIN_LOW_TONE"] = 763] = "U_MODIFIER_LETTER_BEGIN_LOW_TONE";
      CharCode2[CharCode2["U_MODIFIER_LETTER_END_LOW_TONE"] = 764] = "U_MODIFIER_LETTER_END_LOW_TONE";
      CharCode2[CharCode2["U_MODIFIER_LETTER_SHELF"] = 765] = "U_MODIFIER_LETTER_SHELF";
      CharCode2[CharCode2["U_MODIFIER_LETTER_OPEN_SHELF"] = 766] = "U_MODIFIER_LETTER_OPEN_SHELF";
      CharCode2[CharCode2["U_MODIFIER_LETTER_LOW_LEFT_ARROW"] = 767] = "U_MODIFIER_LETTER_LOW_LEFT_ARROW";
      CharCode2[CharCode2["U_GREEK_LOWER_NUMERAL_SIGN"] = 885] = "U_GREEK_LOWER_NUMERAL_SIGN";
      CharCode2[CharCode2["U_GREEK_TONOS"] = 900] = "U_GREEK_TONOS";
      CharCode2[CharCode2["U_GREEK_DIALYTIKA_TONOS"] = 901] = "U_GREEK_DIALYTIKA_TONOS";
      CharCode2[CharCode2["U_GREEK_KORONIS"] = 8125] = "U_GREEK_KORONIS";
      CharCode2[CharCode2["U_GREEK_PSILI"] = 8127] = "U_GREEK_PSILI";
      CharCode2[CharCode2["U_GREEK_PERISPOMENI"] = 8128] = "U_GREEK_PERISPOMENI";
      CharCode2[CharCode2["U_GREEK_DIALYTIKA_AND_PERISPOMENI"] = 8129] = "U_GREEK_DIALYTIKA_AND_PERISPOMENI";
      CharCode2[CharCode2["U_GREEK_PSILI_AND_VARIA"] = 8141] = "U_GREEK_PSILI_AND_VARIA";
      CharCode2[CharCode2["U_GREEK_PSILI_AND_OXIA"] = 8142] = "U_GREEK_PSILI_AND_OXIA";
      CharCode2[CharCode2["U_GREEK_PSILI_AND_PERISPOMENI"] = 8143] = "U_GREEK_PSILI_AND_PERISPOMENI";
      CharCode2[CharCode2["U_GREEK_DASIA_AND_VARIA"] = 8157] = "U_GREEK_DASIA_AND_VARIA";
      CharCode2[CharCode2["U_GREEK_DASIA_AND_OXIA"] = 8158] = "U_GREEK_DASIA_AND_OXIA";
      CharCode2[CharCode2["U_GREEK_DASIA_AND_PERISPOMENI"] = 8159] = "U_GREEK_DASIA_AND_PERISPOMENI";
      CharCode2[CharCode2["U_GREEK_DIALYTIKA_AND_VARIA"] = 8173] = "U_GREEK_DIALYTIKA_AND_VARIA";
      CharCode2[CharCode2["U_GREEK_DIALYTIKA_AND_OXIA"] = 8174] = "U_GREEK_DIALYTIKA_AND_OXIA";
      CharCode2[CharCode2["U_GREEK_VARIA"] = 8175] = "U_GREEK_VARIA";
      CharCode2[CharCode2["U_GREEK_OXIA"] = 8189] = "U_GREEK_OXIA";
      CharCode2[CharCode2["U_GREEK_DASIA"] = 8190] = "U_GREEK_DASIA";
      CharCode2[CharCode2["U_OVERLINE"] = 8254] = "U_OVERLINE";
      CharCode2[CharCode2["UTF8_BOM"] = 65279] = "UTF8_BOM";
    })(CharCode || (CharCode = {}));
  }
});

// src/snippets/parser.ts
function walk(marker, visitor) {
  const stack = [...marker];
  while (stack.length > 0) {
    const marker2 = stack.shift();
    const recurse = visitor(marker2);
    if (!recurse) {
      break;
    }
    stack.unshift(...marker2.children);
  }
}
var logger29, TokenType, _Scanner, Scanner, Marker, Text, TransformableMarker, Placeholder, Choice, Transform, FormatString, Variable, TextmateSnippet, SnippetParser;
var init_parser2 = __esm({
  "src/snippets/parser.ts"() {
    init_charCode();
    init_main2();
    logger29 = require_logger2()("snippets-parser");
    (function(TokenType2) {
      TokenType2[TokenType2["Dollar"] = 0] = "Dollar";
      TokenType2[TokenType2["Colon"] = 1] = "Colon";
      TokenType2[TokenType2["Comma"] = 2] = "Comma";
      TokenType2[TokenType2["CurlyOpen"] = 3] = "CurlyOpen";
      TokenType2[TokenType2["CurlyClose"] = 4] = "CurlyClose";
      TokenType2[TokenType2["Backslash"] = 5] = "Backslash";
      TokenType2[TokenType2["Forwardslash"] = 6] = "Forwardslash";
      TokenType2[TokenType2["Pipe"] = 7] = "Pipe";
      TokenType2[TokenType2["Int"] = 8] = "Int";
      TokenType2[TokenType2["VariableName"] = 9] = "VariableName";
      TokenType2[TokenType2["Format"] = 10] = "Format";
      TokenType2[TokenType2["Plus"] = 11] = "Plus";
      TokenType2[TokenType2["Dash"] = 12] = "Dash";
      TokenType2[TokenType2["QuestionMark"] = 13] = "QuestionMark";
      TokenType2[TokenType2["EOF"] = 14] = "EOF";
    })(TokenType || (TokenType = {}));
    _Scanner = class {
      static isDigitCharacter(ch) {
        return ch >= CharCode.Digit0 && ch <= CharCode.Digit9;
      }
      static isVariableCharacter(ch) {
        return ch === CharCode.Underline || ch >= CharCode.a && ch <= CharCode.z || ch >= CharCode.A && ch <= CharCode.Z;
      }
      constructor() {
        this.text("");
      }
      text(value) {
        this.value = value;
        this.pos = 0;
      }
      tokenText(token) {
        return this.value.substr(token.pos, token.len);
      }
      next() {
        if (this.pos >= this.value.length) {
          return { type: 14, pos: this.pos, len: 0 };
        }
        let pos = this.pos;
        let len = 0;
        let ch = this.value.charCodeAt(pos);
        let type;
        type = _Scanner._table[ch];
        if (typeof type === "number") {
          this.pos += 1;
          return { type, pos, len: 1 };
        }
        if (_Scanner.isDigitCharacter(ch)) {
          type = 8;
          do {
            len += 1;
            ch = this.value.charCodeAt(pos + len);
          } while (_Scanner.isDigitCharacter(ch));
          this.pos += len;
          return { type, pos, len };
        }
        if (_Scanner.isVariableCharacter(ch)) {
          type = 9;
          do {
            ch = this.value.charCodeAt(pos + ++len);
          } while (_Scanner.isVariableCharacter(ch) || _Scanner.isDigitCharacter(ch));
          this.pos += len;
          return { type, pos, len };
        }
        type = 10;
        do {
          len += 1;
          ch = this.value.charCodeAt(pos + len);
        } while (!isNaN(ch) && typeof _Scanner._table[ch] === "undefined" && !_Scanner.isDigitCharacter(ch) && !_Scanner.isVariableCharacter(ch));
        this.pos += len;
        return { type, pos, len };
      }
    };
    Scanner = _Scanner;
    Scanner._table = {
      [CharCode.DollarSign]: 0,
      [CharCode.Colon]: 1,
      [CharCode.Comma]: 2,
      [CharCode.OpenCurlyBrace]: 3,
      [CharCode.CloseCurlyBrace]: 4,
      [CharCode.Backslash]: 5,
      [CharCode.Slash]: 6,
      [CharCode.Pipe]: 7,
      [CharCode.Plus]: 11,
      [CharCode.Dash]: 12,
      [CharCode.QuestionMark]: 13
    };
    Marker = class {
      constructor() {
        this._children = [];
      }
      appendChild(child) {
        if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
          this._children[this._children.length - 1].value += child.value;
        } else {
          child.parent = this;
          this._children.push(child);
        }
        return this;
      }
      setOnlyChild(child) {
        child.parent = this;
        this._children = [child];
      }
      replace(child, others) {
        const { parent } = child;
        const idx = parent.children.indexOf(child);
        const newChildren = parent.children.slice(0);
        newChildren.splice(idx, 1, ...others);
        parent._children = newChildren;
        (function _fixParent(children, parent2) {
          for (const child2 of children) {
            child2.parent = parent2;
            _fixParent(child2.children, child2);
          }
        })(others, parent);
      }
      get children() {
        return this._children;
      }
      get snippet() {
        let candidate = this;
        while (true) {
          if (!candidate) {
            return void 0;
          }
          if (candidate instanceof TextmateSnippet) {
            return candidate;
          }
          candidate = candidate.parent;
        }
      }
      toString() {
        return this.children.reduce((prev, cur) => prev + cur.toString(), "");
      }
      len() {
        return 0;
      }
      get next() {
        let { parent } = this;
        let { children } = parent;
        let idx = children.indexOf(this);
        return children[idx + 1];
      }
    };
    Text = class extends Marker {
      constructor(value) {
        super();
        this.value = value;
      }
      static escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      toString() {
        return this.value;
      }
      toTextmateString() {
        return Text.escape(this.value);
      }
      len() {
        return this.value.length;
      }
      clone() {
        return new Text(this.value);
      }
    };
    TransformableMarker = class extends Marker {
    };
    Placeholder = class extends TransformableMarker {
      constructor(index) {
        super();
        this.index = index;
      }
      static compareByIndex(a, b) {
        if (a.index === b.index) {
          return 0;
        } else if (a.isFinalTabstop) {
          return 1;
        } else if (b.isFinalTabstop) {
          return -1;
        } else if (a.index < b.index) {
          return -1;
        } else if (a.index > b.index) {
          return 1;
        } else {
          return 0;
        }
      }
      get isFinalTabstop() {
        return this.index === 0;
      }
      get choice() {
        return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
      }
      toTextmateString() {
        let transformString = "";
        if (this.transform) {
          transformString = this.transform.toTextmateString();
        }
        if (this.children.length === 0 && !this.transform) {
          return `$${this.index}`;
        } else if (this.children.length === 0) {
          return `\${${this.index}${transformString}}`;
        } else if (this.choice) {
          return `\${${this.index}|${this.choice.toTextmateString()}|${transformString}}`;
        } else {
          return `\${${this.index}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
        }
      }
      clone() {
        let ret = new Placeholder(this.index);
        if (this.transform) {
          ret.transform = this.transform.clone();
        }
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    Choice = class extends Marker {
      constructor() {
        super(...arguments);
        this.options = [];
      }
      appendChild(marker) {
        if (marker instanceof Text) {
          marker.parent = this;
          this.options.push(marker);
        }
        return this;
      }
      toString() {
        return this.options[0].value;
      }
      toTextmateString() {
        return this.options.map((option) => option.value.replace(/\||,/g, "\\$&")).join(",");
      }
      len() {
        return this.options[0].len();
      }
      clone() {
        let ret = new Choice();
        for (let opt of this.options) {
          ret.appendChild(opt);
        }
        return ret;
      }
    };
    Transform = class extends Marker {
      resolve(value) {
        let didMatch = false;
        let ret = value.replace(this.regexp, (...args) => {
          didMatch = true;
          return this._replace(args.slice(0, -2));
        });
        if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) {
          ret = this._replace([]);
        }
        return ret;
      }
      _replace(groups) {
        let ret = "";
        for (const marker of this._children) {
          if (marker instanceof FormatString) {
            let value = groups[marker.index] || "";
            value = marker.resolve(value);
            ret += value;
          } else {
            ret += marker.toString();
          }
        }
        return ret;
      }
      toString() {
        return "";
      }
      toTextmateString() {
        return `/${this.regexp.source}/${this.children.map((c) => c.toTextmateString())}/${(this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : "")}`;
      }
      clone() {
        let ret = new Transform();
        ret.regexp = new RegExp(this.regexp.source, "" + (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    FormatString = class extends Marker {
      constructor(index, shorthandName, ifValue, elseValue) {
        super();
        this.index = index;
        this.shorthandName = shorthandName;
        this.ifValue = ifValue;
        this.elseValue = elseValue;
      }
      resolve(value) {
        if (this.shorthandName === "upcase") {
          return !value ? "" : value.toLocaleUpperCase();
        } else if (this.shorthandName === "downcase") {
          return !value ? "" : value.toLocaleLowerCase();
        } else if (this.shorthandName === "capitalize") {
          return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
        } else if (this.shorthandName === "pascalcase") {
          return !value ? "" : this._toPascalCase(value);
        } else if (Boolean(value) && typeof this.ifValue === "string") {
          return this.ifValue;
        } else if (!value && typeof this.elseValue === "string") {
          return this.elseValue;
        } else {
          return value || "";
        }
      }
      _toPascalCase(value) {
        const match = value.match(/[a-z]+/gi);
        if (!match) {
          return value;
        }
        return match.map((word) => word.charAt(0).toUpperCase() + word.substr(1).toLowerCase()).join("");
      }
      toTextmateString() {
        let value = "${";
        value += this.index;
        if (this.shorthandName) {
          value += `:/${this.shorthandName}`;
        } else if (this.ifValue && this.elseValue) {
          value += `:?${this.ifValue}:${this.elseValue}`;
        } else if (this.ifValue) {
          value += `:+${this.ifValue}`;
        } else if (this.elseValue) {
          value += `:-${this.elseValue}`;
        }
        value += "}";
        return value;
      }
      clone() {
        let ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
        return ret;
      }
    };
    Variable = class extends TransformableMarker {
      constructor(name2) {
        super();
        this.name = name2;
      }
      async resolve(resolver) {
        let value = await resolver.resolve(this);
        if (value && value.includes("\n")) {
          let indent = "";
          this.snippet.walk((m) => {
            if (m == this) {
              return false;
            }
            if (m instanceof Text) {
              let lines2 = m.toString().split(/\r?\n/);
              indent = lines2[lines2.length - 1].match(/^\s*/)[0];
            }
            return true;
          });
          let lines = value.split("\n");
          let indents = lines.filter((s) => s.length > 0).map((s) => s.match(/^\s*/)[0]);
          let minIndent = indents.length == 0 ? "" : indents.reduce((p, c) => p.length < c.length ? p : c);
          let newLines = lines.map((s, i) => i == 0 || s.length == 0 || !s.startsWith(minIndent) ? s : indent + s.slice(minIndent.length));
          value = newLines.join("\n");
        }
        if (this.transform) {
          value = this.transform.resolve(value || "");
        }
        if (value !== void 0) {
          this._children = [new Text(value)];
          return true;
        }
        return false;
      }
      toTextmateString() {
        let transformString = "";
        if (this.transform) {
          transformString = this.transform.toTextmateString();
        }
        if (this.children.length === 0) {
          return `\${${this.name}${transformString}}`;
        } else {
          return `\${${this.name}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
        }
      }
      clone() {
        const ret = new Variable(this.name);
        if (this.transform) {
          ret.transform = this.transform.clone();
        }
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    TextmateSnippet = class extends Marker {
      get placeholderInfo() {
        if (!this._placeholders) {
          this._variables = [];
          let all = [];
          let last;
          this.walk((candidate) => {
            if (candidate instanceof Placeholder) {
              all.push(candidate);
              last = !last || last.index < candidate.index ? candidate : last;
            } else if (candidate instanceof Variable) {
              let first = candidate.name.charCodeAt(0);
              if (first < 65 || first > 90) {
                this._variables.push(candidate);
              }
            }
            return true;
          });
          this._placeholders = { all, last };
        }
        return this._placeholders;
      }
      get variables() {
        return this._variables;
      }
      get placeholders() {
        const { all } = this.placeholderInfo;
        return all;
      }
      get maxIndexNumber() {
        let { placeholders } = this;
        return placeholders.reduce((curr, p) => Math.max(curr, p.index), 0);
      }
      get minIndexNumber() {
        let { placeholders } = this;
        let nums = placeholders.map((p) => p.index);
        nums.sort((a, b) => a - b);
        if (nums.length > 1 && nums[0] == 0)
          return nums[1];
        return nums[0] || 0;
      }
      insertSnippet(snippet, id, range) {
        let placeholder = this.placeholders[id];
        if (!placeholder)
          return;
        let { index } = placeholder;
        const document2 = TextDocument2.create("untitled:/1", "snippet", 0, placeholder.toString());
        snippet = TextDocument2.applyEdits(document2, [{ range, newText: snippet }]);
        let nested = new SnippetParser().parse(snippet, true);
        let maxIndexAdded = nested.maxIndexNumber + 1;
        let indexes = [];
        for (let p of nested.placeholders) {
          if (p.isFinalTabstop) {
            p.index = maxIndexAdded + index;
          } else {
            p.index = p.index + index;
          }
          indexes.push(p.index);
        }
        this.walk((m) => {
          if (m instanceof Placeholder && m.index > index) {
            m.index = m.index + maxIndexAdded;
          }
          return true;
        });
        this.replace(placeholder, nested.children);
        return Math.min.apply(null, indexes);
      }
      updatePlaceholder(id, val) {
        const placeholder = this.placeholders[id];
        for (let p of this.placeholders) {
          if (p.index == placeholder.index) {
            let child = p.children[0];
            let newText = p.transform ? p.transform.resolve(val) : val;
            if (child) {
              p.setOnlyChild(new Text(newText));
            } else {
              p.appendChild(new Text(newText));
            }
          }
        }
        this._placeholders = void 0;
      }
      updateVariable(id, val) {
        const find = this.variables[id - this.maxIndexNumber - 1];
        if (find) {
          let variables = this.variables.filter((o) => o.name == find.name);
          for (let variable of variables) {
            let newText = variable.transform ? variable.transform.resolve(val) : val;
            variable.setOnlyChild(new Text(newText));
          }
        }
      }
      getPlaceholderText(id, value) {
        const placeholder = this.placeholders[id];
        if (!placeholder)
          return value;
        return placeholder.transform ? placeholder.transform.resolve(value) : value;
      }
      offset(marker) {
        let pos = 0;
        let found = false;
        this.walk((candidate) => {
          if (candidate === marker) {
            found = true;
            return false;
          }
          pos += candidate.len();
          return true;
        });
        if (!found) {
          return -1;
        }
        return pos;
      }
      fullLen(marker) {
        let ret = 0;
        walk([marker], (marker2) => {
          ret += marker2.len();
          return true;
        });
        return ret;
      }
      enclosingPlaceholders(placeholder) {
        let ret = [];
        let { parent } = placeholder;
        while (parent) {
          if (parent instanceof Placeholder) {
            ret.push(parent);
          }
          parent = parent.parent;
        }
        return ret;
      }
      async resolveVariables(resolver) {
        let items = [];
        this.walk((candidate) => {
          if (candidate instanceof Variable) {
            items.push(candidate);
          }
          return true;
        });
        await Promise.all(items.map((o) => o.resolve(resolver)));
      }
      appendChild(child) {
        this._placeholders = void 0;
        return super.appendChild(child);
      }
      replace(child, others) {
        this._placeholders = void 0;
        return super.replace(child, others);
      }
      toTextmateString() {
        return this.children.reduce((prev, cur) => prev + cur.toTextmateString(), "");
      }
      clone() {
        let ret = new TextmateSnippet();
        this._children = this.children.map((child) => child.clone());
        return ret;
      }
      walk(visitor) {
        walk(this.children, visitor);
      }
    };
    SnippetParser = class {
      constructor() {
        this._scanner = new Scanner();
      }
      static escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      text(value) {
        return this.parse(value).toString();
      }
      parse(value, insertFinalTabstop) {
        this._scanner.text(value);
        this._token = this._scanner.next();
        const snippet = new TextmateSnippet();
        while (this._parse(snippet)) {
        }
        const placeholderDefaultValues = new Map();
        const incompletePlaceholders = [];
        snippet.walk((marker) => {
          if (marker instanceof Placeholder) {
            if (marker.isFinalTabstop) {
              placeholderDefaultValues.set(0, void 0);
            } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {
              placeholderDefaultValues.set(marker.index, marker.children);
            } else {
              incompletePlaceholders.push(marker);
            }
          }
          return true;
        });
        for (const placeholder of incompletePlaceholders) {
          if (placeholderDefaultValues.has(placeholder.index)) {
            const clone = new Placeholder(placeholder.index);
            clone.transform = placeholder.transform;
            for (const child of placeholderDefaultValues.get(placeholder.index)) {
              let marker = child.clone();
              if (clone.transform) {
                if (marker instanceof Text) {
                  marker = new Text(clone.transform.resolve(marker.value));
                } else {
                  for (let child2 of marker.children) {
                    if (child2 instanceof Text) {
                      marker.replace(child2, [new Text(clone.transform.resolve(child2.value))]);
                      break;
                    }
                  }
                }
              }
              clone.appendChild(marker);
            }
            snippet.replace(placeholder, [clone]);
          }
        }
        if (!placeholderDefaultValues.has(0) && insertFinalTabstop) {
          snippet.appendChild(new Placeholder(0));
        }
        return snippet;
      }
      _accept(type, value) {
        if (type === void 0 || this._token.type === type) {
          let ret = !value ? true : this._scanner.tokenText(this._token);
          this._token = this._scanner.next();
          return ret;
        }
        return false;
      }
      _backTo(token) {
        this._scanner.pos = token.pos + token.len;
        this._token = token;
        return false;
      }
      _until(type) {
        if (this._token.type === 14) {
          return false;
        }
        let start = this._token;
        while (this._token.type !== type) {
          this._token = this._scanner.next();
          if (this._token.type === 14) {
            return false;
          }
        }
        let value = this._scanner.value.substring(start.pos, this._token.pos);
        this._token = this._scanner.next();
        return value;
      }
      _parse(marker) {
        return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
      }
      _parseEscaped(marker) {
        let value;
        if (value = this._accept(5, true)) {
          value = this._accept(0, true) || this._accept(4, true) || this._accept(5, true) || value;
          marker.appendChild(new Text(value));
          return true;
        }
        return false;
      }
      _parseTabstopOrVariableName(parent) {
        let value;
        const token = this._token;
        const match = this._accept(0) && (value = this._accept(9, true) || this._accept(8, true));
        if (!match) {
          return this._backTo(token);
        }
        parent.appendChild(/^\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value));
        return true;
      }
      _parseComplexPlaceholder(parent) {
        let index;
        const token = this._token;
        const match = this._accept(0) && this._accept(3) && (index = this._accept(8, true));
        if (!match) {
          return this._backTo(token);
        }
        const placeholder = new Placeholder(Number(index));
        if (this._accept(1)) {
          while (true) {
            if (this._accept(4)) {
              parent.appendChild(placeholder);
              return true;
            }
            if (this._parse(placeholder)) {
              continue;
            }
            parent.appendChild(new Text("${" + index + ":"));
            placeholder.children.forEach(parent.appendChild, parent);
            return true;
          }
        } else if (placeholder.index > 0 && this._accept(7)) {
          const choice = new Choice();
          while (true) {
            if (this._parseChoiceElement(choice)) {
              if (this._accept(2)) {
                continue;
              }
              if (this._accept(7)) {
                placeholder.appendChild(choice);
                if (this._accept(4)) {
                  parent.appendChild(placeholder);
                  return true;
                }
              }
            }
            this._backTo(token);
            return false;
          }
        } else if (this._accept(6)) {
          if (this._parseTransform(placeholder)) {
            parent.appendChild(placeholder);
            return true;
          }
          this._backTo(token);
          return false;
        } else if (this._accept(4)) {
          parent.appendChild(placeholder);
          return true;
        } else {
          return this._backTo(token);
        }
      }
      _parseChoiceElement(parent) {
        const token = this._token;
        const values = [];
        while (true) {
          if (this._token.type === 2 || this._token.type === 7) {
            break;
          }
          let value;
          if (value = this._accept(5, true)) {
            value = this._accept(2, true) || this._accept(7, true) || this._accept(5, true) || value;
          } else {
            value = this._accept(void 0, true);
          }
          if (!value) {
            this._backTo(token);
            return false;
          }
          values.push(value);
        }
        if (values.length === 0) {
          this._backTo(token);
          return false;
        }
        parent.appendChild(new Text(values.join("")));
        return true;
      }
      _parseComplexVariable(parent) {
        let name2;
        const token = this._token;
        const match = this._accept(0) && this._accept(3) && (name2 = this._accept(9, true));
        if (!match) {
          return this._backTo(token);
        }
        const variable = new Variable(name2);
        if (this._accept(1)) {
          while (true) {
            if (this._accept(4)) {
              parent.appendChild(variable);
              return true;
            }
            if (this._parse(variable)) {
              continue;
            }
            parent.appendChild(new Text("${" + name2 + ":"));
            variable.children.forEach(parent.appendChild, parent);
            return true;
          }
        } else if (this._accept(6)) {
          if (this._parseTransform(variable)) {
            parent.appendChild(variable);
            return true;
          }
          this._backTo(token);
          return false;
        } else if (this._accept(4)) {
          parent.appendChild(variable);
          return true;
        } else {
          return this._backTo(token);
        }
      }
      _parseTransform(parent) {
        let transform = new Transform();
        let regexValue = "";
        let regexOptions = "";
        while (true) {
          if (this._accept(6)) {
            break;
          }
          let escaped;
          if (escaped = this._accept(5, true)) {
            escaped = this._accept(6, true) || escaped;
            regexValue += escaped;
            continue;
          }
          if (this._token.type !== 14) {
            regexValue += this._accept(void 0, true);
            continue;
          }
          return false;
        }
        while (true) {
          if (this._accept(6)) {
            break;
          }
          let escaped;
          if (escaped = this._accept(5, true)) {
            escaped = this._accept(6, true) || escaped;
            transform.appendChild(new Text(escaped));
            continue;
          }
          if (this._parseFormatString(transform) || this._parseAnything(transform)) {
            let text = transform.children[0];
            if (text && text.value && text.value.includes("\\n")) {
              text.value = text.value.replace(/\\n/g, "\n");
            }
            continue;
          }
          return false;
        }
        while (true) {
          if (this._accept(4)) {
            break;
          }
          if (this._token.type !== 14) {
            regexOptions += this._accept(void 0, true);
            continue;
          }
          return false;
        }
        try {
          transform.regexp = new RegExp(regexValue, regexOptions);
        } catch (e) {
          return false;
        }
        parent.transform = transform;
        return true;
      }
      _parseFormatString(parent) {
        const token = this._token;
        if (!this._accept(0)) {
          return false;
        }
        let complex = false;
        if (this._accept(3)) {
          complex = true;
        }
        let index = this._accept(8, true);
        if (!index) {
          this._backTo(token);
          return false;
        } else if (!complex) {
          parent.appendChild(new FormatString(Number(index)));
          return true;
        } else if (this._accept(4)) {
          parent.appendChild(new FormatString(Number(index)));
          return true;
        } else if (!this._accept(1)) {
          this._backTo(token);
          return false;
        }
        if (this._accept(6)) {
          let shorthand = this._accept(9, true);
          if (!shorthand || !this._accept(4)) {
            this._backTo(token);
            return false;
          } else {
            parent.appendChild(new FormatString(Number(index), shorthand));
            return true;
          }
        } else if (this._accept(11)) {
          let ifValue = this._until(4);
          if (ifValue) {
            parent.appendChild(new FormatString(Number(index), void 0, ifValue, void 0));
            return true;
          }
        } else if (this._accept(12)) {
          let elseValue = this._until(4);
          if (elseValue) {
            parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
            return true;
          }
        } else if (this._accept(13)) {
          let ifValue = this._until(1);
          if (ifValue) {
            let elseValue = this._until(4);
            if (elseValue) {
              parent.appendChild(new FormatString(Number(index), void 0, ifValue, elseValue));
              return true;
            }
          }
        } else {
          let elseValue = this._until(4);
          if (elseValue) {
            parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
            return true;
          }
        }
        this._backTo(token);
        return false;
      }
      _parseAnything(marker) {
        if (this._token.type !== 14) {
          let text = this._scanner.tokenText(this._token);
          marker.appendChild(new Text(text));
          this._accept(void 0);
          return true;
        }
        return false;
      }
    };
  }
});

// src/model/installBuffer.ts
var import_events12, logger30, State, InstallBuffer;
var init_installBuffer = __esm({
  "src/model/installBuffer.ts"() {
    import_events12 = __toModule(require("events"));
    init_status();
    logger30 = require_logger2()("model-installBuffer");
    (function(State3) {
      State3[State3["Waiting"] = 0] = "Waiting";
      State3[State3["Faild"] = 1] = "Faild";
      State3[State3["Progressing"] = 2] = "Progressing";
      State3[State3["Success"] = 3] = "Success";
    })(State || (State = {}));
    InstallBuffer = class extends import_events12.EventEmitter {
      constructor(isUpdate = false, isSync = false, channel = void 0) {
        super();
        this.isUpdate = isUpdate;
        this.isSync = isSync;
        this.channel = channel;
        this.statMap = new Map();
        this.messagesMap = new Map();
        this.names = [];
      }
      setExtensions(names) {
        this.statMap.clear();
        this.names = names;
        for (let name2 of names) {
          this.statMap.set(name2, 0);
        }
      }
      addMessage(name2, msg, isProgress = false) {
        if (isProgress && this.channel)
          return;
        let lines = this.messagesMap.get(name2) || [];
        this.messagesMap.set(name2, lines.concat(msg.trim().split(/\r?\n/)));
        if (this.channel)
          this.channel.appendLine(`[${name2}] ${msg}`);
      }
      startProgress(names) {
        for (let name2 of names) {
          this.statMap.set(name2, 2);
        }
      }
      finishProgress(name2, succeed = true) {
        if (this.channel) {
          if (succeed) {
            this.channel.appendLine(`[${name2}] install succeed!`);
          } else {
            this.channel.appendLine(`[${name2}] install failed!`);
          }
        }
        this.statMap.set(name2, succeed ? 3 : 1);
      }
      get remains() {
        let count = 0;
        for (let name2 of this.names) {
          let stat = this.statMap.get(name2);
          if (![3, 1].includes(stat)) {
            count = count + 1;
          }
        }
        return count;
      }
      getLines() {
        let lines = [];
        for (let name2 of this.names) {
          let state = this.statMap.get(name2);
          let processText = "*";
          switch (state) {
            case 2: {
              let d = new Date();
              let idx = Math.floor(d.getMilliseconds() / 100);
              processText = frames[idx];
              break;
            }
            case 1:
              processText = "\u2717";
              break;
            case 3:
              processText = "\u2713";
              break;
          }
          let msgs = this.messagesMap.get(name2) || [];
          lines.push(`- ${processText} ${name2} ${msgs.length ? msgs[msgs.length - 1] : ""}`);
        }
        return lines;
      }
      getMessages(line) {
        if (line <= 1)
          return [];
        let name2 = this.names[line - 2];
        if (!name2)
          return [];
        return this.messagesMap.get(name2);
      }
      draw(nvim, buffer) {
        let { remains } = this;
        let first = remains == 0 ? `${this.isUpdate ? "Update" : "Install"} finished` : `Installing, ${remains} remains...`;
        let lines = [first, "", ...this.getLines()];
        buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false }, true);
        if (remains == 0 && this.interval) {
          clearInterval(this.interval);
          this.interval = null;
        }
        if (process.env.VIM_NODE_RPC) {
          nvim.command("redraw", true);
        }
      }
      highlight(nvim) {
        nvim.call("matchadd", ["CocListFgCyan", "^\\-\\s\\zs\\*"], true);
        nvim.call("matchadd", ["CocListFgGreen", "^\\-\\s\\zs\u2713"], true);
        nvim.call("matchadd", ["CocListFgRed", "^\\-\\s\\zs\u2717"], true);
        nvim.call("matchadd", ["CocListFgYellow", "^-.\\{3\\}\\zs\\S\\+"], true);
      }
      async show(nvim) {
        let { isSync } = this;
        if (this.channel)
          return;
        nvim.pauseNotification();
        nvim.command(isSync ? "enew" : "vs +enew", true);
        nvim.call("bufnr", ["%"], true);
        nvim.command("setl buftype=nofile bufhidden=wipe noswapfile nobuflisted wrap undolevels=-1", true);
        if (!isSync) {
          nvim.command("nnoremap <silent><nowait><buffer> q :q<CR>", true);
        }
        this.highlight(nvim);
        let res = await nvim.resumeNotification();
        let bufnr = res && res[1] == null ? res[0][1] : null;
        if (!bufnr)
          return;
        this.bufnr = bufnr;
        let buffer = nvim.createBuffer(bufnr);
        this.interval = setInterval(() => {
          this.draw(nvim, buffer);
        }, 100);
      }
      dispose() {
        if (this.interval) {
          clearInterval(this.interval);
        }
      }
    };
  }
});

// node_modules/ini/ini.js
var require_ini = __commonJS({
  "node_modules/ini/ini.js"(exports2) {
    exports2.parse = exports2.decode = decode;
    exports2.stringify = exports2.encode = encode;
    exports2.safe = safe;
    exports2.unsafe = unsafe;
    var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
    function encode(obj, opt) {
      var children = [];
      var out = "";
      if (typeof opt === "string") {
        opt = {
          section: opt,
          whitespace: false
        };
      } else {
        opt = opt || {};
        opt.whitespace = opt.whitespace === true;
      }
      var separator = opt.whitespace ? " = " : "=";
      Object.keys(obj).forEach(function(k, _, __) {
        var val = obj[k];
        if (val && Array.isArray(val)) {
          val.forEach(function(item) {
            out += safe(k + "[]") + separator + safe(item) + "\n";
          });
        } else if (val && typeof val === "object") {
          children.push(k);
        } else {
          out += safe(k) + separator + safe(val) + eol;
        }
      });
      if (opt.section && out.length) {
        out = "[" + safe(opt.section) + "]" + eol + out;
      }
      children.forEach(function(k, _, __) {
        var nk = dotSplit(k).join("\\.");
        var section2 = (opt.section ? opt.section + "." : "") + nk;
        var child = encode(obj[k], {
          section: section2,
          whitespace: opt.whitespace
        });
        if (out.length && child.length) {
          out += eol;
        }
        out += child;
      });
      return out;
    }
    function dotSplit(str) {
      return str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
        return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
      });
    }
    function decode(str) {
      var out = {};
      var p = out;
      var section2 = null;
      var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
      var lines = str.split(/[\r\n]+/g);
      lines.forEach(function(line, _, __) {
        if (!line || line.match(/^\s*[;#]/))
          return;
        var match = line.match(re);
        if (!match)
          return;
        if (match[1] !== void 0) {
          section2 = unsafe(match[1]);
          p = out[section2] = out[section2] || {};
          return;
        }
        var key = unsafe(match[2]);
        var value = match[3] ? unsafe(match[4]) : true;
        switch (value) {
          case "true":
          case "false":
          case "null":
            value = JSON.parse(value);
        }
        if (key.length > 2 && key.slice(-2) === "[]") {
          key = key.substring(0, key.length - 2);
          if (!p[key]) {
            p[key] = [];
          } else if (!Array.isArray(p[key])) {
            p[key] = [p[key]];
          }
        }
        if (Array.isArray(p[key])) {
          p[key].push(value);
        } else {
          p[key] = value;
        }
      });
      Object.keys(out).filter(function(k, _, __) {
        if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k])) {
          return false;
        }
        var parts = dotSplit(k);
        var p2 = out;
        var l = parts.pop();
        var nl = l.replace(/\\\./g, ".");
        parts.forEach(function(part, _2, __2) {
          if (!p2[part] || typeof p2[part] !== "object")
            p2[part] = {};
          p2 = p2[part];
        });
        if (p2 === out && nl === l) {
          return false;
        }
        p2[nl] = out[k];
        return true;
      }).forEach(function(del, _, __) {
        delete out[del];
      });
      return out;
    }
    function isQuoted(val) {
      return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
    }
    function safe(val) {
      return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
    }
    function unsafe(val, doUnesc) {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'") {
          val = val.substr(1, val.length - 2);
        }
        try {
          val = JSON.parse(val);
        } catch (_) {
        }
      } else {
        var esc = false;
        var unesc = "";
        for (var i = 0, l = val.length; i < l; i++) {
          var c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1) {
              unesc += c;
            } else {
              unesc += "\\" + c;
            }
            esc = false;
          } else if (";#".indexOf(c) !== -1) {
            break;
          } else if (c === "\\") {
            esc = true;
          } else {
            unesc += c;
          }
        }
        if (esc) {
          unesc += "\\";
        }
        return unesc.trim();
      }
      return val;
    }
  }
});

// node_modules/rc/node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS({
  "node_modules/rc/node_modules/strip-json-comments/index.js"(exports2, module2) {
    "use strict";
    var singleComment = 1;
    var multiComment = 2;
    function stripWithoutWhitespace() {
      return "";
    }
    function stripWithWhitespace(str, start, end) {
      return str.slice(start, end).replace(/\S/g, " ");
    }
    module2.exports = function(str, opts) {
      opts = opts || {};
      var currentChar;
      var nextChar;
      var insideString = false;
      var insideComment = false;
      var offset = 0;
      var ret = "";
      var strip = opts.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
      for (var i = 0; i < str.length; i++) {
        currentChar = str[i];
        nextChar = str[i + 1];
        if (!insideComment && currentChar === '"') {
          var escaped = str[i - 1] === "\\" && str[i - 2] !== "\\";
          if (!escaped) {
            insideString = !insideString;
          }
        }
        if (insideString) {
          continue;
        }
        if (!insideComment && currentChar + nextChar === "//") {
          ret += str.slice(offset, i);
          offset = i;
          insideComment = singleComment;
          i++;
        } else if (insideComment === singleComment && currentChar + nextChar === "\r\n") {
          i++;
          insideComment = false;
          ret += strip(str, offset, i);
          offset = i;
          continue;
        } else if (insideComment === singleComment && currentChar === "\n") {
          insideComment = false;
          ret += strip(str, offset, i);
          offset = i;
        } else if (!insideComment && currentChar + nextChar === "/*") {
          ret += str.slice(offset, i);
          offset = i;
          insideComment = multiComment;
          i++;
          continue;
        } else if (insideComment === multiComment && currentChar + nextChar === "*/") {
          i++;
          insideComment = false;
          ret += strip(str, offset, i + 1);
          offset = i + 1;
          continue;
        }
      }
      return ret + (insideComment ? strip(str.substr(offset)) : str.substr(offset));
    };
  }
});

// node_modules/rc/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/rc/lib/utils.js"(exports2) {
    "use strict";
    var fs26 = require("fs");
    var ini = require_ini();
    var path34 = require("path");
    var stripJsonComments = require_strip_json_comments();
    var parse5 = exports2.parse = function(content) {
      if (/^\s*{/.test(content))
        return JSON.parse(stripJsonComments(content));
      return ini.parse(content);
    };
    var file = exports2.file = function() {
      var args = [].slice.call(arguments).filter(function(arg) {
        return arg != null;
      });
      for (var i in args)
        if (typeof args[i] !== "string")
          return;
      var file2 = path34.join.apply(null, args);
      var content;
      try {
        return fs26.readFileSync(file2, "utf-8");
      } catch (err) {
        return;
      }
    };
    var json = exports2.json = function() {
      var content = file.apply(null, arguments);
      return content ? parse5(content) : null;
    };
    var env = exports2.env = function(prefix, env2) {
      env2 = env2 || process.env;
      var obj = {};
      var l = prefix.length;
      for (var k in env2) {
        if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
          var keypath = k.substring(l).split("__");
          var _emptyStringIndex;
          while ((_emptyStringIndex = keypath.indexOf("")) > -1) {
            keypath.splice(_emptyStringIndex, 1);
          }
          var cursor = obj;
          keypath.forEach(function _buildSubObj(_subkey, i) {
            if (!_subkey || typeof cursor !== "object")
              return;
            if (i === keypath.length - 1)
              cursor[_subkey] = env2[k];
            if (cursor[_subkey] === void 0)
              cursor[_subkey] = {};
            cursor = cursor[_subkey];
          });
        }
      }
      return obj;
    };
    var find = exports2.find = function() {
      var rel = path34.join.apply(null, [].slice.call(arguments));
      function find2(start, rel2) {
        var file2 = path34.join(start, rel2);
        try {
          fs26.statSync(file2);
          return file2;
        } catch (err) {
          if (path34.dirname(start) !== start)
            return find2(path34.dirname(start), rel2);
        }
      }
      return find2(process.cwd(), rel);
    };
  }
});

// node_modules/deep-extend/lib/deep-extend.js
var require_deep_extend = __commonJS({
  "node_modules/deep-extend/lib/deep-extend.js"(exports2, module2) {
    "use strict";
    function isSpecificValue(val) {
      return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
    }
    function cloneSpecificValue(val) {
      if (val instanceof Buffer) {
        var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
        val.copy(x);
        return x;
      } else if (val instanceof Date) {
        return new Date(val.getTime());
      } else if (val instanceof RegExp) {
        return new RegExp(val);
      } else {
        throw new Error("Unexpected situation");
      }
    }
    function deepCloneArray(arr) {
      var clone = [];
      arr.forEach(function(item, index) {
        if (typeof item === "object" && item !== null) {
          if (Array.isArray(item)) {
            clone[index] = deepCloneArray(item);
          } else if (isSpecificValue(item)) {
            clone[index] = cloneSpecificValue(item);
          } else {
            clone[index] = deepExtend({}, item);
          }
        } else {
          clone[index] = item;
        }
      });
      return clone;
    }
    function safeGetProperty(object, property) {
      return property === "__proto__" ? void 0 : object[property];
    }
    var deepExtend = module2.exports = function() {
      if (arguments.length < 1 || typeof arguments[0] !== "object") {
        return false;
      }
      if (arguments.length < 2) {
        return arguments[0];
      }
      var target = arguments[0];
      var args = Array.prototype.slice.call(arguments, 1);
      var val, src, clone;
      args.forEach(function(obj) {
        if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
          return;
        }
        Object.keys(obj).forEach(function(key) {
          src = safeGetProperty(target, key);
          val = safeGetProperty(obj, key);
          if (val === target) {
            return;
          } else if (typeof val !== "object" || val === null) {
            target[key] = val;
            return;
          } else if (Array.isArray(val)) {
            target[key] = deepCloneArray(val);
            return;
          } else if (isSpecificValue(val)) {
            target[key] = cloneSpecificValue(val);
            return;
          } else if (typeof src !== "object" || src === null || Array.isArray(src)) {
            target[key] = deepExtend({}, val);
            return;
          } else {
            target[key] = deepExtend(src, val);
            return;
          }
        });
      });
      return target;
    };
  }
});

// node_modules/minimist/index.js
var require_minimist = __commonJS({
  "node_modules/minimist/index.js"(exports2, module2) {
    module2.exports = function(args, opts) {
      if (!opts)
        opts = {};
      var flags = { bools: {}, strings: {}, unknownFn: null };
      if (typeof opts["unknown"] === "function") {
        flags.unknownFn = opts["unknown"];
      }
      if (typeof opts["boolean"] === "boolean" && opts["boolean"]) {
        flags.allBools = true;
      } else {
        [].concat(opts["boolean"]).filter(Boolean).forEach(function(key2) {
          flags.bools[key2] = true;
        });
      }
      var aliases = {};
      Object.keys(opts.alias || {}).forEach(function(key2) {
        aliases[key2] = [].concat(opts.alias[key2]);
        aliases[key2].forEach(function(x) {
          aliases[x] = [key2].concat(aliases[key2].filter(function(y) {
            return x !== y;
          }));
        });
      });
      [].concat(opts.string).filter(Boolean).forEach(function(key2) {
        flags.strings[key2] = true;
        if (aliases[key2]) {
          flags.strings[aliases[key2]] = true;
        }
      });
      var defaults2 = opts["default"] || {};
      var argv = { _: [] };
      Object.keys(flags.bools).forEach(function(key2) {
        setArg(key2, defaults2[key2] === void 0 ? false : defaults2[key2]);
      });
      var notFlags = [];
      if (args.indexOf("--") !== -1) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
      }
      function argDefined(key2, arg2) {
        return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key2] || flags.bools[key2] || aliases[key2];
      }
      function setArg(key2, val, arg2) {
        if (arg2 && flags.unknownFn && !argDefined(key2, arg2)) {
          if (flags.unknownFn(arg2) === false)
            return;
        }
        var value2 = !flags.strings[key2] && isNumber(val) ? Number(val) : val;
        setKey(argv, key2.split("."), value2);
        (aliases[key2] || []).forEach(function(x) {
          setKey(argv, x.split("."), value2);
        });
      }
      function setKey(obj, keys, value2) {
        var o = obj;
        for (var i2 = 0; i2 < keys.length - 1; i2++) {
          var key2 = keys[i2];
          if (key2 === "__proto__")
            return;
          if (o[key2] === void 0)
            o[key2] = {};
          if (o[key2] === Object.prototype || o[key2] === Number.prototype || o[key2] === String.prototype)
            o[key2] = {};
          if (o[key2] === Array.prototype)
            o[key2] = [];
          o = o[key2];
        }
        var key2 = keys[keys.length - 1];
        if (key2 === "__proto__")
          return;
        if (o === Object.prototype || o === Number.prototype || o === String.prototype)
          o = {};
        if (o === Array.prototype)
          o = [];
        if (o[key2] === void 0 || flags.bools[key2] || typeof o[key2] === "boolean") {
          o[key2] = value2;
        } else if (Array.isArray(o[key2])) {
          o[key2].push(value2);
        } else {
          o[key2] = [o[key2], value2];
        }
      }
      function aliasIsBoolean(key2) {
        return aliases[key2].some(function(x) {
          return flags.bools[x];
        });
      }
      for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        if (/^--.+=/.test(arg)) {
          var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
          var key = m[1];
          var value = m[2];
          if (flags.bools[key]) {
            value = value !== "false";
          }
          setArg(key, value, arg);
        } else if (/^--no-.+/.test(arg)) {
          var key = arg.match(/^--no-(.+)/)[1];
          setArg(key, false, arg);
        } else if (/^--.+/.test(arg)) {
          var key = arg.match(/^--(.+)/)[1];
          var next = args[i + 1];
          if (next !== void 0 && !/^-/.test(next) && !flags.bools[key] && !flags.allBools && (aliases[key] ? !aliasIsBoolean(key) : true)) {
            setArg(key, next, arg);
            i++;
          } else if (/^(true|false)$/.test(next)) {
            setArg(key, next === "true", arg);
            i++;
          } else {
            setArg(key, flags.strings[key] ? "" : true, arg);
          }
        } else if (/^-[^-]+/.test(arg)) {
          var letters = arg.slice(1, -1).split("");
          var broken = false;
          for (var j = 0; j < letters.length; j++) {
            var next = arg.slice(j + 2);
            if (next === "-") {
              setArg(letters[j], next, arg);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
              setArg(letters[j], next.split("=")[1], arg);
              broken = true;
              break;
            }
            if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next, arg);
              broken = true;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2), arg);
              broken = true;
              break;
            } else {
              setArg(letters[j], flags.strings[letters[j]] ? "" : true, arg);
            }
          }
          var key = arg.slice(-1)[0];
          if (!broken && key !== "-") {
            if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (aliases[key] ? !aliasIsBoolean(key) : true)) {
              setArg(key, args[i + 1], arg);
              i++;
            } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
              setArg(key, args[i + 1] === "true", arg);
              i++;
            } else {
              setArg(key, flags.strings[key] ? "" : true, arg);
            }
          }
        } else {
          if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
            argv._.push(flags.strings["_"] || !isNumber(arg) ? arg : Number(arg));
          }
          if (opts.stopEarly) {
            argv._.push.apply(argv._, args.slice(i + 1));
            break;
          }
        }
      }
      Object.keys(defaults2).forEach(function(key2) {
        if (!hasKey(argv, key2.split("."))) {
          setKey(argv, key2.split("."), defaults2[key2]);
          (aliases[key2] || []).forEach(function(x) {
            setKey(argv, x.split("."), defaults2[key2]);
          });
        }
      });
      if (opts["--"]) {
        argv["--"] = new Array();
        notFlags.forEach(function(key2) {
          argv["--"].push(key2);
        });
      } else {
        notFlags.forEach(function(key2) {
          argv._.push(key2);
        });
      }
      return argv;
    };
    function hasKey(obj, keys) {
      var o = obj;
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      var key = keys[keys.length - 1];
      return key in o;
    }
    function isNumber(x) {
      if (typeof x === "number")
        return true;
      if (/^0x[0-9a-f]+$/i.test(x))
        return true;
      return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
  }
});

// node_modules/rc/index.js
var require_rc = __commonJS({
  "node_modules/rc/index.js"(exports2, module2) {
    var cc = require_utils3();
    var join2 = require("path").join;
    var deepExtend = require_deep_extend();
    var etc = "/etc";
    var win = process.platform === "win32";
    var home = win ? process.env.USERPROFILE : process.env.HOME;
    module2.exports = function(name2, defaults2, argv, parse5) {
      if (typeof name2 !== "string")
        throw new Error("rc(name): name *must* be string");
      if (!argv)
        argv = require_minimist()(process.argv.slice(2));
      defaults2 = (typeof defaults2 === "string" ? cc.json(defaults2) : defaults2) || {};
      parse5 = parse5 || cc.parse;
      var env = cc.env(name2 + "_");
      var configs = [defaults2];
      var configFiles = [];
      function addConfigFile(file) {
        if (configFiles.indexOf(file) >= 0)
          return;
        var fileConfig = cc.file(file);
        if (fileConfig) {
          configs.push(parse5(fileConfig));
          configFiles.push(file);
        }
      }
      if (!win)
        [
          join2(etc, name2, "config"),
          join2(etc, name2 + "rc")
        ].forEach(addConfigFile);
      if (home)
        [
          join2(home, ".config", name2, "config"),
          join2(home, ".config", name2),
          join2(home, "." + name2, "config"),
          join2(home, "." + name2 + "rc")
        ].forEach(addConfigFile);
      addConfigFile(cc.find("." + name2 + "rc"));
      if (env.config)
        addConfigFile(env.config);
      if (argv.config)
        addConfigFile(argv.config);
      return deepExtend.apply(null, configs.concat([
        env,
        argv,
        configFiles.length ? { configs: configFiles, config: configFiles[configFiles.length - 1] } : void 0
      ]));
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer4 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer4(arg, encodingOrOffset, length);
    }
    copyProps(Buffer4, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer4(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer4(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer4(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/content-disposition/index.js
var require_content_disposition = __commonJS({
  "node_modules/content-disposition/index.js"(exports2, module2) {
    "use strict";
    module2.exports = contentDisposition2;
    module2.exports.parse = parse5;
    var basename = require("path").basename;
    var Buffer4 = require_safe_buffer().Buffer;
    var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
    var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
    var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
    var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
    var QESC_REGEXP = /\\([\u0000-\u007f])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
    var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
    var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
    var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
    function contentDisposition2(filename, options) {
      var opts = options || {};
      var type = opts.type || "attachment";
      var params = createparams(filename, opts.fallback);
      return format2(new ContentDisposition(type, params));
    }
    function createparams(filename, fallback) {
      if (filename === void 0) {
        return;
      }
      var params = {};
      if (typeof filename !== "string") {
        throw new TypeError("filename must be a string");
      }
      if (fallback === void 0) {
        fallback = true;
      }
      if (typeof fallback !== "string" && typeof fallback !== "boolean") {
        throw new TypeError("fallback must be a string or boolean");
      }
      if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
        throw new TypeError("fallback must be ISO-8859-1 string");
      }
      var name2 = basename(filename);
      var isQuotedString = TEXT_REGEXP.test(name2);
      var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name2) : basename(fallback);
      var hasFallback = typeof fallbackName === "string" && fallbackName !== name2;
      if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name2)) {
        params["filename*"] = name2;
      }
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name2;
      }
      return params;
    }
    function format2(obj) {
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string2 = String(type).toLowerCase();
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
          string2 += "; " + param + "=" + val;
        }
      }
      return string2;
    }
    function decodefield(str) {
      var match = EXT_VALUE_REGEXP.exec(str);
      if (!match) {
        throw new TypeError("invalid extended field value");
      }
      var charset = match[1].toLowerCase();
      var encoded = match[2];
      var value;
      var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
      switch (charset) {
        case "iso-8859-1":
          value = getlatin1(binary);
          break;
        case "utf-8":
          value = Buffer4.from(binary, "binary").toString("utf8");
          break;
        default:
          throw new TypeError("unsupported charset in extended field");
      }
      return value;
    }
    function getlatin1(val) {
      return String(val).replace(NON_LATIN1_REGEXP, "?");
    }
    function parse5(string2) {
      if (!string2 || typeof string2 !== "string") {
        throw new TypeError("argument string is required");
      }
      var match = DISPOSITION_TYPE_REGEXP.exec(string2);
      if (!match) {
        throw new TypeError("invalid type format");
      }
      var index = match[0].length;
      var type = match[1].toLowerCase();
      var key;
      var names = [];
      var params = {};
      var value;
      index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
      while (match = PARAM_REGEXP.exec(string2)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (names.indexOf(key) !== -1) {
          throw new TypeError("invalid duplicate parameter");
        }
        names.push(key);
        if (key.indexOf("*") + 1 === key.length) {
          key = key.slice(0, -1);
          value = decodefield(value);
          params[key] = value;
          continue;
        }
        if (typeof params[key] === "string") {
          continue;
        }
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
        }
        params[key] = value;
      }
      if (index !== -1 && index !== string2.length) {
        throw new TypeError("invalid parameter format");
      }
      return new ContentDisposition(type, params);
    }
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16));
    }
    function pencode(char) {
      return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
    }
    function qstring(val) {
      var str = String(val);
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ustring(val) {
      var str = String(val);
      var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
      return "UTF-8''" + encoded;
    }
    function ContentDisposition(type, parameters) {
      this.type = type;
      this.parameters = parameters;
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    try {
      debug = require_src()("follow-redirects");
    } catch (error) {
      debug = function() {
      };
    }
    module2.exports = debug;
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    var url = require("url");
    var URL = url.URL;
    var http3 = require("http");
    var https3 = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug2();
    var eventHandlers = Object.create(null);
    ["abort", "aborted", "connect", "error", "socket", "timeout"].forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "");
    var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
    var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
    var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (typeof data === "function") {
        callback = data;
        data = encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name2, value) {
      this._options.headers[name2] = value;
      this._currentRequest.setHeader(name2, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name2) {
      delete this._options.headers[name2];
      this._currentRequest.removeHeader(name2);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      if (callback) {
        this.once("timeout", callback);
      }
      if (this.socket) {
        startTimer(this, msecs);
      } else {
        var self2 = this;
        this._currentRequest.once("socket", function() {
          startTimer(self2, msecs);
        });
      }
      this.once("response", clearTimer);
      this.once("error", clearTimer);
      return this;
    };
    function startTimer(request2, msecs) {
      clearTimeout(request2._timeout);
      request2._timeout = setTimeout(function() {
        request2.emit("timeout");
      }, msecs);
    }
    function clearTimer() {
      clearTimeout(this._timeout);
    }
    [
      "abort",
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.substr(0, protocol.length - 1);
        this._options.agent = this._options.agents[scheme];
      }
      var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      this._currentUrl = url.format(this._options);
      request2._redirectable = this;
      for (var event in eventHandlers) {
        if (event) {
          request2.on(event, eventHandlers[event]);
        }
      }
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request2 === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request2.finished) {
                request2.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request2.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (location && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {
        this._currentRequest.removeAllListeners();
        this._currentRequest.on("error", noop);
        this._currentRequest.abort();
        response.destroy();
        if (++this._redirectCount > this._options.maxRedirects) {
          this.emit("error", new TooManyRedirectsError());
          return;
        }
        if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
          this._options.method = "GET";
          this._requestBodyBuffers = [];
          removeMatchingHeaders(/^content-/i, this._options.headers);
        }
        var previousHostName = removeMatchingHeaders(/^host$/i, this._options.headers) || url.parse(this._currentUrl).hostname;
        var redirectUrl = url.resolve(this._currentUrl, location);
        debug("redirecting to", redirectUrl);
        this._isRedirect = true;
        var redirectUrlParts = url.parse(redirectUrl);
        Object.assign(this._options, redirectUrlParts);
        if (redirectUrlParts.hostname !== previousHostName) {
          removeMatchingHeaders(/^authorization$/i, this._options.headers);
        }
        if (typeof this._options.beforeRedirect === "function") {
          var responseDetails = { headers: response.headers };
          try {
            this._options.beforeRedirect.call(null, this._options, responseDetails);
          } catch (err) {
            this.emit("error", err);
            return;
          }
          this._sanitizeOptions(this._options);
        }
        try {
          this._performRequest();
        } catch (cause) {
          var error = new RedirectionError("Redirected request failed: " + cause.message);
          error.cause = cause;
          this.emit("error", error);
        }
      } else {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
      }
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        wrappedProtocol.request = function(input, options, callback) {
          if (typeof input === "string") {
            var urlStr = input;
            try {
              input = urlToOptions(new URL(urlStr));
            } catch (err) {
              input = url.parse(urlStr);
            }
          } else if (URL && input instanceof URL) {
            input = urlToOptions(input);
          } else {
            callback = options;
            options = input;
            input = { protocol };
          }
          if (typeof options === "function") {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        };
        wrappedProtocol.get = function(input, options, callback) {
          var request2 = wrappedProtocol.request(input, options, callback);
          request2.end();
          return request2;
        };
      });
      return exports3;
    }
    function noop() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue;
    }
    function createErrorType(code, defaultMessage) {
      function CustomError(message) {
        Error.captureStackTrace(this, this.constructor);
        this.message = message || defaultMessage;
      }
      CustomError.prototype = new Error();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      CustomError.prototype.code = code;
      return CustomError;
    }
    module2.exports = wrap({ http: http3, https: https3 });
    module2.exports.wrap = wrap;
  }
});

// node_modules/tar/lib/high-level-opt.js
var require_high_level_opt = __commonJS({
  "node_modules/tar/lib/high-level-opt.js"(exports2, module2) {
    "use strict";
    var argmap = new Map([
      ["C", "cwd"],
      ["f", "file"],
      ["z", "gzip"],
      ["P", "preservePaths"],
      ["U", "unlink"],
      ["strip-components", "strip"],
      ["stripComponents", "strip"],
      ["keep-newer", "newer"],
      ["keepNewer", "newer"],
      ["keep-newer-files", "newer"],
      ["keepNewerFiles", "newer"],
      ["k", "keep"],
      ["keep-existing", "keep"],
      ["keepExisting", "keep"],
      ["m", "noMtime"],
      ["no-mtime", "noMtime"],
      ["p", "preserveOwner"],
      ["L", "follow"],
      ["h", "follow"]
    ]);
    var parse5 = module2.exports = (opt) => opt ? Object.keys(opt).map((k) => [
      argmap.has(k) ? argmap.get(k) : k,
      opt[k]
    ]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {};
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list2) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list2 && typeof list2.forEach === "function") {
        list2.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list2) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list2);
      }
      this.list = list2;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/minipass/index.js
var require_minipass = __commonJS({
  "node_modules/minipass/index.js"(exports2, module2) {
    "use strict";
    var EE = require("events");
    var Stream = require("stream");
    var Yallist = require_yallist();
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    module2.exports = class Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = new Yallist();
        this.buffer = new Yallist();
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(\u0950) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!\u0950;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (!this.objectMode && !chunk.length) {
          const ret = this.flowing;
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            cb();
          return ret;
        }
        if (typeof chunk === "string" && !this[OBJECTMODE] && !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        try {
          return this.flowing ? (this.emit("data", chunk), this.flowing) : (this[BUFFERPUSH](chunk), false);
        } finally {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            cb();
        }
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        try {
          if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])
            return null;
          if (this[OBJECTMODE])
            n = null;
          if (this.buffer.length > 1 && !this[OBJECTMODE]) {
            if (this.encoding)
              this.buffer = new Yallist([
                Array.from(this.buffer).join("")
              ]);
            else
              this.buffer = new Yallist([
                Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])
              ]);
          }
          return this[READ](n || null, this.buffer.head.value);
        } finally {
          this[MAYBE_EMIT_END]();
        }
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer.head.value = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        return this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer.head.value.length;
        }
        return this.buffer.shift();
      }
      [FLUSH]() {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === process.stdout || dest === process.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        const p = { dest, opts, ondrain: (_) => this[RESUME]() };
        this.pipes.push(p);
        dest.on("drain", p.ondrain);
        this[RESUME]();
        if (ended && p.opts.end)
          p.dest.end();
        return dest;
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        try {
          return super.on(ev, fn);
        } finally {
          if (ev === "data" && !this.pipes.length && !this.flowing)
            this[RESUME]();
          else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
          }
        }
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          if (!data)
            return;
          if (this.pipes.length)
            this.pipes.forEach((p) => p.dest.write(data) === false && this.pause());
        } else if (ev === "end") {
          if (this[EMITTED_END] === true)
            return;
          this[EMITTED_END] = true;
          this.readable = false;
          if (this[DECODER]) {
            data = this[DECODER].end();
            if (data) {
              this.pipes.forEach((p) => p.dest.write(data));
              super.emit("data", data);
            }
          }
          this.pipes.forEach((p) => {
            p.dest.removeListener("drain", p.ondrain);
            if (p.opts.end)
              p.dest.end();
          });
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
        }
        const args = new Array(arguments.length);
        args[0] = ev;
        args[1] = data;
        if (arguments.length > 2) {
          for (let i = 2; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
        }
        try {
          return super.emit.apply(this, args);
        } finally {
          if (!isEndish(ev))
            this[MAYBE_EMIT_END]();
          else
            this.removeAllListeners(ev);
        }
      }
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      promise() {
        return new Promise((resolve3, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("end", () => resolve3());
          this.on("error", (er) => reject(er));
        });
      }
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve3 = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve3({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve3({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve3 = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer = new Yallist();
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/minizlib/constants.js
var require_constants2 = __commonJS({
  "node_modules/minizlib/constants.js"(exports2, module2) {
    var realZlibConstants = require("zlib").constants || { ZLIB_VERNUM: 4736 };
    module2.exports = Object.freeze(Object.assign(Object.create(null), {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31
    }, realZlibConstants));
  }
});

// node_modules/minizlib/index.js
var require_minizlib = __commonJS({
  "node_modules/minizlib/index.js"(exports2) {
    "use strict";
    var assert = require("assert");
    var Buffer4 = require("buffer").Buffer;
    var realZlib = require("zlib");
    var constants = exports2.constants = require_constants2();
    var Minipass = require_minipass();
    var OriginalBufferConcat = Buffer4.concat;
    var _superWrite = Symbol("_superWrite");
    var ZlibError = class extends Error {
      constructor(err) {
        super("zlib: " + err.message);
        this.code = err.code;
        this.errno = err.errno;
        if (!this.code)
          this.code = "ZLIB_ERROR";
        this.message = "zlib: " + err.message;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "ZlibError";
      }
    };
    var _opts = Symbol("opts");
    var _flushFlag = Symbol("flushFlag");
    var _finishFlushFlag = Symbol("finishFlushFlag");
    var _fullFlushFlag = Symbol("fullFlushFlag");
    var _handle = Symbol("handle");
    var _onError = Symbol("onError");
    var _sawError = Symbol("sawError");
    var _level = Symbol("level");
    var _strategy = Symbol("strategy");
    var _ended = Symbol("ended");
    var _defaultFullFlush = Symbol("_defaultFullFlush");
    var ZlibBase = class extends Minipass {
      constructor(opts, mode) {
        if (!opts || typeof opts !== "object")
          throw new TypeError("invalid options for ZlibBase constructor");
        super(opts);
        this[_sawError] = false;
        this[_ended] = false;
        this[_opts] = opts;
        this[_flushFlag] = opts.flush;
        this[_finishFlushFlag] = opts.finishFlush;
        try {
          this[_handle] = new realZlib[mode](opts);
        } catch (er) {
          throw new ZlibError(er);
        }
        this[_onError] = (err) => {
          if (this[_sawError])
            return;
          this[_sawError] = true;
          this.close();
          this.emit("error", err);
        };
        this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        this.once("end", () => this.close);
      }
      close() {
        if (this[_handle]) {
          this[_handle].close();
          this[_handle] = null;
          this.emit("close");
        }
      }
      reset() {
        if (!this[_sawError]) {
          assert(this[_handle], "zlib binding closed");
          return this[_handle].reset();
        }
      }
      flush(flushFlag) {
        if (this.ended)
          return;
        if (typeof flushFlag !== "number")
          flushFlag = this[_fullFlushFlag];
        this.write(Object.assign(Buffer4.alloc(0), { [_flushFlag]: flushFlag }));
      }
      end(chunk, encoding, cb) {
        if (chunk)
          this.write(chunk, encoding);
        this.flush(this[_finishFlushFlag]);
        this[_ended] = true;
        return super.end(null, null, cb);
      }
      get ended() {
        return this[_ended];
      }
      write(chunk, encoding, cb) {
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (typeof chunk === "string")
          chunk = Buffer4.from(chunk, encoding);
        if (this[_sawError])
          return;
        assert(this[_handle], "zlib binding closed");
        const nativeHandle = this[_handle]._handle;
        const originalNativeClose = nativeHandle.close;
        nativeHandle.close = () => {
        };
        const originalClose = this[_handle].close;
        this[_handle].close = () => {
        };
        Buffer4.concat = (args) => args;
        let result;
        try {
          const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
          result = this[_handle]._processChunk(chunk, flushFlag);
          Buffer4.concat = OriginalBufferConcat;
        } catch (err) {
          Buffer4.concat = OriginalBufferConcat;
          this[_onError](new ZlibError(err));
        } finally {
          if (this[_handle]) {
            this[_handle]._handle = nativeHandle;
            nativeHandle.close = originalNativeClose;
            this[_handle].close = originalClose;
            this[_handle].removeAllListeners("error");
          }
        }
        if (this[_handle])
          this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        let writeReturn;
        if (result) {
          if (Array.isArray(result) && result.length > 0) {
            writeReturn = this[_superWrite](Buffer4.from(result[0]));
            for (let i = 1; i < result.length; i++) {
              writeReturn = this[_superWrite](result[i]);
            }
          } else {
            writeReturn = this[_superWrite](Buffer4.from(result));
          }
        }
        if (cb)
          cb();
        return writeReturn;
      }
      [_superWrite](data) {
        return super.write(data);
      }
    };
    var Zlib = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.Z_NO_FLUSH;
        opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
        this[_level] = opts.level;
        this[_strategy] = opts.strategy;
      }
      params(level, strategy) {
        if (this[_sawError])
          return;
        if (!this[_handle])
          throw new Error("cannot switch params when binding is closed");
        if (!this[_handle].params)
          throw new Error("not supported in this implementation");
        if (this[_level] !== level || this[_strategy] !== strategy) {
          this.flush(constants.Z_SYNC_FLUSH);
          assert(this[_handle], "zlib binding closed");
          const origFlush = this[_handle].flush;
          this[_handle].flush = (flushFlag, cb) => {
            this.flush(flushFlag);
            cb();
          };
          try {
            this[_handle].params(level, strategy);
          } finally {
            this[_handle].flush = origFlush;
          }
          if (this[_handle]) {
            this[_level] = level;
            this[_strategy] = strategy;
          }
        }
      }
    };
    var Deflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Deflate");
      }
    };
    var Inflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Inflate");
      }
    };
    var _portable = Symbol("_portable");
    var Gzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gzip");
        this[_portable] = opts && !!opts.portable;
      }
      [_superWrite](data) {
        if (!this[_portable])
          return super[_superWrite](data);
        this[_portable] = false;
        data[9] = 255;
        return super[_superWrite](data);
      }
    };
    var Gunzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gunzip");
      }
    };
    var DeflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "DeflateRaw");
      }
    };
    var InflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "InflateRaw");
      }
    };
    var Unzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Unzip");
      }
    };
    var Brotli = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
        opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
      }
    };
    var BrotliCompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliCompress");
      }
    };
    var BrotliDecompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliDecompress");
      }
    };
    exports2.Deflate = Deflate;
    exports2.Inflate = Inflate;
    exports2.Gzip = Gzip;
    exports2.Gunzip = Gunzip;
    exports2.DeflateRaw = DeflateRaw;
    exports2.InflateRaw = InflateRaw;
    exports2.Unzip = Unzip;
    if (typeof realZlib.BrotliCompress === "function") {
      exports2.BrotliCompress = BrotliCompress;
      exports2.BrotliDecompress = BrotliDecompress;
    } else {
      exports2.BrotliCompress = exports2.BrotliDecompress = class {
        constructor() {
          throw new Error("Brotli is not supported in this version of Node.js");
        }
      };
    }
  }
});

// node_modules/tar/lib/types.js
var require_types2 = __commonJS({
  "node_modules/tar/lib/types.js"(exports2) {
    "use strict";
    exports2.name = new Map([
      ["0", "File"],
      ["", "OldFile"],
      ["1", "Link"],
      ["2", "SymbolicLink"],
      ["3", "CharacterDevice"],
      ["4", "BlockDevice"],
      ["5", "Directory"],
      ["6", "FIFO"],
      ["7", "ContiguousFile"],
      ["g", "GlobalExtendedHeader"],
      ["x", "ExtendedHeader"],
      ["A", "SolarisACL"],
      ["D", "GNUDumpDir"],
      ["I", "Inode"],
      ["K", "NextFileHasLongLinkpath"],
      ["L", "NextFileHasLongPath"],
      ["M", "ContinuationFile"],
      ["N", "OldGnuLongPath"],
      ["S", "SparseFile"],
      ["V", "TapeVolumeHeader"],
      ["X", "OldExtendedHeader"]
    ]);
    exports2.code = new Map(Array.from(exports2.name).map((kv) => [kv[1], kv[0]]));
  }
});

// node_modules/tar/lib/read-entry.js
var require_read_entry = __commonJS({
  "node_modules/tar/lib/read-entry.js"(exports2, module2) {
    "use strict";
    var types = require_types2();
    var MiniPass = require_minipass();
    var SLURP = Symbol("slurp");
    module2.exports = class ReadEntry extends MiniPass {
      constructor(header, ex, gex) {
        super();
        this.pause();
        this.extended = ex;
        this.globalExtended = gex;
        this.header = header;
        this.startBlockSize = 512 * Math.ceil(header.size / 512);
        this.blockRemain = this.startBlockSize;
        this.remain = header.size;
        this.type = header.type;
        this.meta = false;
        this.ignore = false;
        switch (this.type) {
          case "File":
          case "OldFile":
          case "Link":
          case "SymbolicLink":
          case "CharacterDevice":
          case "BlockDevice":
          case "Directory":
          case "FIFO":
          case "ContiguousFile":
          case "GNUDumpDir":
            break;
          case "NextFileHasLongLinkpath":
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
          case "GlobalExtendedHeader":
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this.meta = true;
            break;
          default:
            this.ignore = true;
        }
        this.path = header.path;
        this.mode = header.mode;
        if (this.mode)
          this.mode = this.mode & 4095;
        this.uid = header.uid;
        this.gid = header.gid;
        this.uname = header.uname;
        this.gname = header.gname;
        this.size = header.size;
        this.mtime = header.mtime;
        this.atime = header.atime;
        this.ctime = header.ctime;
        this.linkpath = header.linkpath;
        this.uname = header.uname;
        this.gname = header.gname;
        if (ex)
          this[SLURP](ex);
        if (gex)
          this[SLURP](gex, true);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain)
          throw new Error("writing more to entry than is appropriate");
        const r = this.remain;
        const br = this.blockRemain;
        this.remain = Math.max(0, r - writeLen);
        this.blockRemain = Math.max(0, br - writeLen);
        if (this.ignore)
          return true;
        if (r >= writeLen)
          return super.write(data);
        return super.write(data.slice(0, r));
      }
      [SLURP](ex, global2) {
        for (let k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
            this[k] = ex[k];
        }
      }
    };
  }
});

// node_modules/tar/lib/large-numbers.js
var require_large_numbers = __commonJS({
  "node_modules/tar/lib/large-numbers.js"(exports2) {
    "use strict";
    var encode = exports2.encode = (num, buf) => {
      if (!Number.isSafeInteger(num))
        throw Error("cannot encode number outside of javascript safe integer range");
      else if (num < 0)
        encodeNegative(num, buf);
      else
        encodePositive(num, buf);
      return buf;
    };
    var encodePositive = (num, buf) => {
      buf[0] = 128;
      for (var i = buf.length; i > 1; i--) {
        buf[i - 1] = num & 255;
        num = Math.floor(num / 256);
      }
    };
    var encodeNegative = (num, buf) => {
      buf[0] = 255;
      var flipped = false;
      num = num * -1;
      for (var i = buf.length; i > 1; i--) {
        var byte = num & 255;
        num = Math.floor(num / 256);
        if (flipped)
          buf[i - 1] = onesComp(byte);
        else if (byte === 0)
          buf[i - 1] = 0;
        else {
          flipped = true;
          buf[i - 1] = twosComp(byte);
        }
      }
    };
    var parse5 = exports2.parse = (buf) => {
      var post = buf[buf.length - 1];
      var pre = buf[0];
      var value;
      if (pre === 128)
        value = pos(buf.slice(1, buf.length));
      else if (pre === 255)
        value = twos(buf);
      else
        throw Error("invalid base256 encoding");
      if (!Number.isSafeInteger(value))
        throw Error("parsed number outside of javascript safe integer range");
      return value;
    };
    var twos = (buf) => {
      var len = buf.length;
      var sum = 0;
      var flipped = false;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        var f;
        if (flipped)
          f = onesComp(byte);
        else if (byte === 0)
          f = byte;
        else {
          flipped = true;
          f = twosComp(byte);
        }
        if (f !== 0)
          sum -= f * Math.pow(256, len - i - 1);
      }
      return sum;
    };
    var pos = (buf) => {
      var len = buf.length;
      var sum = 0;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        if (byte !== 0)
          sum += byte * Math.pow(256, len - i - 1);
      }
      return sum;
    };
    var onesComp = (byte) => (255 ^ byte) & 255;
    var twosComp = (byte) => (255 ^ byte) + 1 & 255;
  }
});

// node_modules/tar/lib/header.js
var require_header = __commonJS({
  "node_modules/tar/lib/header.js"(exports2, module2) {
    "use strict";
    var types = require_types2();
    var pathModule = require("path").posix;
    var large = require_large_numbers();
    var SLURP = Symbol("slurp");
    var TYPE = Symbol("type");
    var Header = class {
      constructor(data, off, ex, gex) {
        this.cksumValid = false;
        this.needPax = false;
        this.nullBlock = false;
        this.block = null;
        this.path = null;
        this.mode = null;
        this.uid = null;
        this.gid = null;
        this.size = null;
        this.mtime = null;
        this.cksum = null;
        this[TYPE] = "0";
        this.linkpath = null;
        this.uname = null;
        this.gname = null;
        this.devmaj = 0;
        this.devmin = 0;
        this.atime = null;
        this.ctime = null;
        if (Buffer.isBuffer(data))
          this.decode(data, off || 0, ex, gex);
        else if (data)
          this.set(data);
      }
      decode(buf, off, ex, gex) {
        if (!off)
          off = 0;
        if (!buf || !(buf.length >= off + 512))
          throw new Error("need 512 bytes for header");
        this.path = decString(buf, off, 100);
        this.mode = decNumber(buf, off + 100, 8);
        this.uid = decNumber(buf, off + 108, 8);
        this.gid = decNumber(buf, off + 116, 8);
        this.size = decNumber(buf, off + 124, 12);
        this.mtime = decDate(buf, off + 136, 12);
        this.cksum = decNumber(buf, off + 148, 12);
        this[SLURP](ex);
        this[SLURP](gex, true);
        this[TYPE] = decString(buf, off + 156, 1);
        if (this[TYPE] === "")
          this[TYPE] = "0";
        if (this[TYPE] === "0" && this.path.substr(-1) === "/")
          this[TYPE] = "5";
        if (this[TYPE] === "5")
          this.size = 0;
        this.linkpath = decString(buf, off + 157, 100);
        if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
          this.uname = decString(buf, off + 265, 32);
          this.gname = decString(buf, off + 297, 32);
          this.devmaj = decNumber(buf, off + 329, 8);
          this.devmin = decNumber(buf, off + 337, 8);
          if (buf[off + 475] !== 0) {
            const prefix = decString(buf, off + 345, 155);
            this.path = prefix + "/" + this.path;
          } else {
            const prefix = decString(buf, off + 345, 130);
            if (prefix)
              this.path = prefix + "/" + this.path;
            this.atime = decDate(buf, off + 476, 12);
            this.ctime = decDate(buf, off + 488, 12);
          }
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++) {
          sum += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
          sum += buf[i];
        }
        this.cksumValid = sum === this.cksum;
        if (this.cksum === null && sum === 8 * 32)
          this.nullBlock = true;
      }
      [SLURP](ex, global2) {
        for (let k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
            this[k] = ex[k];
        }
      }
      encode(buf, off) {
        if (!buf) {
          buf = this.block = Buffer.alloc(512);
          off = 0;
        }
        if (!off)
          off = 0;
        if (!(buf.length >= off + 512))
          throw new Error("need 512 bytes for header");
        const prefixSize = this.ctime || this.atime ? 130 : 155;
        const split = splitPrefix(this.path || "", prefixSize);
        const path34 = split[0];
        const prefix = split[1];
        this.needPax = split[2];
        this.needPax = encString(buf, off, 100, path34) || this.needPax;
        this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
        this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
        this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
        this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
        this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
        buf[off + 156] = this[TYPE].charCodeAt(0);
        this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
        buf.write("ustar\x0000", off + 257, 8);
        this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
        this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
        this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
        this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
        this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
        if (buf[off + 475] !== 0)
          this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
        else {
          this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
          this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
          this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++) {
          sum += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
          sum += buf[i];
        }
        this.cksum = sum;
        encNumber(buf, off + 148, 8, this.cksum);
        this.cksumValid = true;
        return this.needPax;
      }
      set(data) {
        for (let i in data) {
          if (data[i] !== null && data[i] !== void 0)
            this[i] = data[i];
        }
      }
      get type() {
        return types.name.get(this[TYPE]) || this[TYPE];
      }
      get typeKey() {
        return this[TYPE];
      }
      set type(type) {
        if (types.code.has(type))
          this[TYPE] = types.code.get(type);
        else
          this[TYPE] = type;
      }
    };
    var splitPrefix = (p, prefixSize) => {
      const pathSize = 100;
      let pp = p;
      let prefix = "";
      let ret;
      const root = pathModule.parse(p).root || ".";
      if (Buffer.byteLength(pp) < pathSize)
        ret = [pp, prefix, false];
      else {
        prefix = pathModule.dirname(pp);
        pp = pathModule.basename(pp);
        do {
          if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize)
            ret = [pp, prefix, false];
          else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize)
            ret = [pp.substr(0, pathSize - 1), prefix, true];
          else {
            pp = pathModule.join(pathModule.basename(prefix), pp);
            prefix = pathModule.dirname(prefix);
          }
        } while (prefix !== root && !ret);
        if (!ret)
          ret = [p.substr(0, pathSize - 1), "", true];
      }
      return ret;
    };
    var decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
    var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
    var numToDate = (num) => num === null ? null : new Date(num * 1e3);
    var decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
    var nanNull = (value) => isNaN(value) ? null : value;
    var decSmallNumber = (buf, off, size) => nanNull(parseInt(buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(), 8));
    var MAXNUM = {
      12: 8589934591,
      8: 2097151
    };
    var encNumber = (buf, off, size, number2) => number2 === null ? false : number2 > MAXNUM[size] || number2 < 0 ? (large.encode(number2, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number2), false);
    var encSmallNumber = (buf, off, size, number2) => buf.write(octalString(number2, size), off, size, "ascii");
    var octalString = (number2, size) => padOctal(Math.floor(number2).toString(8), size);
    var padOctal = (string2, size) => (string2.length === size - 1 ? string2 : new Array(size - string2.length - 1).join("0") + string2 + " ") + "\0";
    var encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1e3);
    var NULLS = new Array(156).join("\0");
    var encString = (buf, off, size, string2) => string2 === null ? false : (buf.write(string2 + NULLS, off, size, "utf8"), string2.length !== Buffer.byteLength(string2) || string2.length > size);
    module2.exports = Header;
  }
});

// node_modules/tar/lib/pax.js
var require_pax = __commonJS({
  "node_modules/tar/lib/pax.js"(exports2, module2) {
    "use strict";
    var Header = require_header();
    var path34 = require("path");
    var Pax = class {
      constructor(obj, global2) {
        this.atime = obj.atime || null;
        this.charset = obj.charset || null;
        this.comment = obj.comment || null;
        this.ctime = obj.ctime || null;
        this.gid = obj.gid || null;
        this.gname = obj.gname || null;
        this.linkpath = obj.linkpath || null;
        this.mtime = obj.mtime || null;
        this.path = obj.path || null;
        this.size = obj.size || null;
        this.uid = obj.uid || null;
        this.uname = obj.uname || null;
        this.dev = obj.dev || null;
        this.ino = obj.ino || null;
        this.nlink = obj.nlink || null;
        this.global = global2 || false;
      }
      encode() {
        const body = this.encodeBody();
        if (body === "")
          return null;
        const bodyLen = Buffer.byteLength(body);
        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
        const buf = Buffer.allocUnsafe(bufLen);
        for (let i = 0; i < 512; i++) {
          buf[i] = 0;
        }
        new Header({
          path: ("PaxHeader/" + path34.basename(this.path)).slice(0, 99),
          mode: this.mode || 420,
          uid: this.uid || null,
          gid: this.gid || null,
          size: bodyLen,
          mtime: this.mtime || null,
          type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
          linkpath: "",
          uname: this.uname || "",
          gname: this.gname || "",
          devmaj: 0,
          devmin: 0,
          atime: this.atime || null,
          ctime: this.ctime || null
        }).encode(buf);
        buf.write(body, 512, bodyLen, "utf8");
        for (let i = bodyLen + 512; i < buf.length; i++) {
          buf[i] = 0;
        }
        return buf;
      }
      encodeBody() {
        return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
      }
      encodeField(field) {
        if (this[field] === null || this[field] === void 0)
          return "";
        const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
        const s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
        const byteLen = Buffer.byteLength(s);
        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
        if (byteLen + digits >= Math.pow(10, digits))
          digits += 1;
        const len = digits + byteLen;
        return len + s;
      }
    };
    Pax.parse = (string2, ex, g) => new Pax(merge(parseKV(string2), ex), g);
    var merge = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a;
    var parseKV = (string2) => string2.replace(/\n$/, "").split("\n").reduce(parseKVLine, Object.create(null));
    var parseKVLine = (set, line) => {
      const n = parseInt(line, 10);
      if (n !== Buffer.byteLength(line) + 1)
        return set;
      line = line.substr((n + " ").length);
      const kv = line.split("=");
      const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
      if (!k)
        return set;
      const v = kv.join("=");
      set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
      return set;
    };
    module2.exports = Pax;
  }
});

// node_modules/tar/lib/warn-mixin.js
var require_warn_mixin = __commonJS({
  "node_modules/tar/lib/warn-mixin.js"(exports2, module2) {
    "use strict";
    module2.exports = (Base) => class extends Base {
      warn(code, message, data = {}) {
        if (this.file)
          data.file = this.file;
        if (this.cwd)
          data.cwd = this.cwd;
        data.code = message instanceof Error && message.code || code;
        data.tarCode = code;
        if (!this.strict && data.recoverable !== false) {
          if (message instanceof Error) {
            data = Object.assign(message, data);
            message = message.message;
          }
          this.emit("warn", data.tarCode, message, data);
        } else if (message instanceof Error) {
          this.emit("error", Object.assign(message, data));
        } else
          this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
      }
    };
  }
});

// node_modules/tar/lib/winchars.js
var require_winchars = __commonJS({
  "node_modules/tar/lib/winchars.js"(exports2, module2) {
    "use strict";
    var raw = [
      "|",
      "<",
      ">",
      "?",
      ":"
    ];
    var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
    var toWin = new Map(raw.map((char, i) => [char, win[i]]));
    var toRaw = new Map(win.map((char, i) => [char, raw[i]]));
    module2.exports = {
      encode: (s) => raw.reduce((s2, c) => s2.split(c).join(toWin.get(c)), s),
      decode: (s) => win.reduce((s2, c) => s2.split(c).join(toRaw.get(c)), s)
    };
  }
});

// node_modules/tar/lib/mode-fix.js
var require_mode_fix = __commonJS({
  "node_modules/tar/lib/mode-fix.js"(exports2, module2) {
    "use strict";
    module2.exports = (mode, isDir, portable) => {
      mode &= 4095;
      if (portable) {
        mode = (mode | 384) & ~18;
      }
      if (isDir) {
        if (mode & 256)
          mode |= 64;
        if (mode & 32)
          mode |= 8;
        if (mode & 4)
          mode |= 1;
      }
      return mode;
    };
  }
});

// node_modules/tar/lib/write-entry.js
var require_write_entry = __commonJS({
  "node_modules/tar/lib/write-entry.js"(exports2, module2) {
    "use strict";
    var MiniPass = require_minipass();
    var Pax = require_pax();
    var Header = require_header();
    var ReadEntry = require_read_entry();
    var fs26 = require("fs");
    var path34 = require("path");
    var types = require_types2();
    var maxReadSize = 16 * 1024 * 1024;
    var PROCESS = Symbol("process");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var HEADER = Symbol("header");
    var READ = Symbol("read");
    var LSTAT = Symbol("lstat");
    var ONLSTAT = Symbol("onlstat");
    var ONREAD = Symbol("onread");
    var ONREADLINK = Symbol("onreadlink");
    var OPENFILE = Symbol("openfile");
    var ONOPENFILE = Symbol("onopenfile");
    var CLOSE = Symbol("close");
    var MODE = Symbol("mode");
    var warner = require_warn_mixin();
    var winchars = require_winchars();
    var modeFix = require_mode_fix();
    var WriteEntry = warner(class WriteEntry extends MiniPass {
      constructor(p, opt) {
        opt = opt || {};
        super(opt);
        if (typeof p !== "string")
          throw new TypeError("path is required");
        this.path = p;
        this.portable = !!opt.portable;
        this.myuid = process.getuid && process.getuid();
        this.myuser = process.env.USER || "";
        this.maxReadSize = opt.maxReadSize || maxReadSize;
        this.linkCache = opt.linkCache || new Map();
        this.statCache = opt.statCache || new Map();
        this.preservePaths = !!opt.preservePaths;
        this.cwd = opt.cwd || process.cwd();
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        let pathWarn = false;
        if (!this.preservePaths && path34.win32.isAbsolute(p)) {
          const parsed = path34.win32.parse(p);
          this.path = p.substr(parsed.root.length);
          pathWarn = parsed.root;
        }
        this.win32 = !!opt.win32 || process.platform === "win32";
        if (this.win32) {
          this.path = winchars.decode(this.path.replace(/\\/g, "/"));
          p = p.replace(/\\/g, "/");
        }
        this.absolute = opt.absolute || path34.resolve(this.cwd, p);
        if (this.path === "")
          this.path = "./";
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.statCache.has(this.absolute))
          this[ONLSTAT](this.statCache.get(this.absolute));
        else
          this[LSTAT]();
      }
      [LSTAT]() {
        fs26.lstat(this.absolute, (er, stat) => {
          if (er)
            return this.emit("error", er);
          this[ONLSTAT](stat);
        });
      }
      [ONLSTAT](stat) {
        this.statCache.set(this.absolute, stat);
        this.stat = stat;
        if (!stat.isFile())
          stat.size = 0;
        this.type = getType(stat);
        this.emit("stat", stat);
        this[PROCESS]();
      }
      [PROCESS]() {
        switch (this.type) {
          case "File":
            return this[FILE]();
          case "Directory":
            return this[DIRECTORY]();
          case "SymbolicLink":
            return this[SYMLINK]();
          default:
            return this.end();
        }
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      [HEADER]() {
        if (this.type === "Directory" && this.portable)
          this.noMtime = true;
        this.header = new Header({
          path: this.path,
          linkpath: this.linkpath,
          mode: this[MODE](this.stat.mode),
          uid: this.portable ? null : this.stat.uid,
          gid: this.portable ? null : this.stat.gid,
          size: this.stat.size,
          mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
          type: this.type,
          uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
          atime: this.portable ? null : this.stat.atime,
          ctime: this.portable ? null : this.stat.ctime
        });
        if (this.header.encode() && !this.noPax)
          this.write(new Pax({
            atime: this.portable ? null : this.header.atime,
            ctime: this.portable ? null : this.header.ctime,
            gid: this.portable ? null : this.header.gid,
            mtime: this.noMtime ? null : this.mtime || this.header.mtime,
            path: this.path,
            linkpath: this.linkpath,
            size: this.header.size,
            uid: this.portable ? null : this.header.uid,
            uname: this.portable ? null : this.header.uname,
            dev: this.portable ? null : this.stat.dev,
            ino: this.portable ? null : this.stat.ino,
            nlink: this.portable ? null : this.stat.nlink
          }).encode());
        this.write(this.header.block);
      }
      [DIRECTORY]() {
        if (this.path.substr(-1) !== "/")
          this.path += "/";
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [SYMLINK]() {
        fs26.readlink(this.absolute, (er, linkpath) => {
          if (er)
            return this.emit("error", er);
          this[ONREADLINK](linkpath);
        });
      }
      [ONREADLINK](linkpath) {
        this.linkpath = linkpath.replace(/\\/g, "/");
        this[HEADER]();
        this.end();
      }
      [HARDLINK](linkpath) {
        this.type = "Link";
        this.linkpath = path34.relative(this.cwd, linkpath).replace(/\\/g, "/");
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [FILE]() {
        if (this.stat.nlink > 1) {
          const linkKey = this.stat.dev + ":" + this.stat.ino;
          if (this.linkCache.has(linkKey)) {
            const linkpath = this.linkCache.get(linkKey);
            if (linkpath.indexOf(this.cwd) === 0)
              return this[HARDLINK](linkpath);
          }
          this.linkCache.set(linkKey, this.absolute);
        }
        this[HEADER]();
        if (this.stat.size === 0)
          return this.end();
        this[OPENFILE]();
      }
      [OPENFILE]() {
        fs26.open(this.absolute, "r", (er, fd) => {
          if (er)
            return this.emit("error", er);
          this[ONOPENFILE](fd);
        });
      }
      [ONOPENFILE](fd) {
        const blockLen = 512 * Math.ceil(this.stat.size / 512);
        const bufLen = Math.min(blockLen, this.maxReadSize);
        const buf = Buffer.allocUnsafe(bufLen);
        this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen);
      }
      [READ](fd, buf, offset, length, pos, remain, blockRemain) {
        fs26.read(fd, buf, offset, length, pos, (er, bytesRead) => {
          if (er) {
            return this[CLOSE](fd, () => this.emit("error", er));
          }
          this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);
        });
      }
      [CLOSE](fd, cb) {
        fs26.close(fd, cb);
      }
      [ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {
        if (bytesRead <= 0 && remain > 0) {
          const er = new Error("encountered unexpected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](fd, () => this.emit("error", er));
        }
        if (bytesRead > remain) {
          const er = new Error("did not encounter expected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](fd, () => this.emit("error", er));
        }
        if (bytesRead === remain) {
          for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {
            buf[i + offset] = 0;
            bytesRead++;
            remain++;
          }
        }
        const writeBuf = offset === 0 && bytesRead === buf.length ? buf : buf.slice(offset, offset + bytesRead);
        remain -= bytesRead;
        blockRemain -= bytesRead;
        pos += bytesRead;
        offset += bytesRead;
        this.write(writeBuf);
        if (!remain) {
          if (blockRemain)
            this.write(Buffer.alloc(blockRemain));
          return this[CLOSE](fd, (er) => er ? this.emit("error", er) : this.end());
        }
        if (offset >= length) {
          buf = Buffer.allocUnsafe(length);
          offset = 0;
        }
        length = buf.length - offset;
        this[READ](fd, buf, offset, length, pos, remain, blockRemain);
      }
    });
    var WriteEntrySync = class extends WriteEntry {
      constructor(path35, opt) {
        super(path35, opt);
      }
      [LSTAT]() {
        this[ONLSTAT](fs26.lstatSync(this.absolute));
      }
      [SYMLINK]() {
        this[ONREADLINK](fs26.readlinkSync(this.absolute));
      }
      [OPENFILE]() {
        this[ONOPENFILE](fs26.openSync(this.absolute, "r"));
      }
      [READ](fd, buf, offset, length, pos, remain, blockRemain) {
        let threw = true;
        try {
          const bytesRead = fs26.readSync(fd, buf, offset, length, pos);
          this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);
          threw = false;
        } finally {
          if (threw)
            try {
              this[CLOSE](fd, () => {
              });
            } catch (er) {
            }
        }
      }
      [CLOSE](fd, cb) {
        fs26.closeSync(fd);
        cb();
      }
    };
    var WriteEntryTar = warner(class WriteEntryTar extends MiniPass {
      constructor(readEntry, opt) {
        opt = opt || {};
        super(opt);
        this.preservePaths = !!opt.preservePaths;
        this.portable = !!opt.portable;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.readEntry = readEntry;
        this.type = readEntry.type;
        if (this.type === "Directory" && this.portable)
          this.noMtime = true;
        this.path = readEntry.path;
        this.mode = this[MODE](readEntry.mode);
        this.uid = this.portable ? null : readEntry.uid;
        this.gid = this.portable ? null : readEntry.gid;
        this.uname = this.portable ? null : readEntry.uname;
        this.gname = this.portable ? null : readEntry.gname;
        this.size = readEntry.size;
        this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
        this.atime = this.portable ? null : readEntry.atime;
        this.ctime = this.portable ? null : readEntry.ctime;
        this.linkpath = readEntry.linkpath;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        let pathWarn = false;
        if (path34.isAbsolute(this.path) && !this.preservePaths) {
          const parsed = path34.parse(this.path);
          pathWarn = parsed.root;
          this.path = this.path.substr(parsed.root.length);
        }
        this.remain = readEntry.size;
        this.blockRemain = readEntry.startBlockSize;
        this.header = new Header({
          path: this.path,
          linkpath: this.linkpath,
          mode: this.mode,
          uid: this.portable ? null : this.uid,
          gid: this.portable ? null : this.gid,
          size: this.size,
          mtime: this.noMtime ? null : this.mtime,
          type: this.type,
          uname: this.portable ? null : this.uname,
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime
        });
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.header.encode() && !this.noPax)
          super.write(new Pax({
            atime: this.portable ? null : this.atime,
            ctime: this.portable ? null : this.ctime,
            gid: this.portable ? null : this.gid,
            mtime: this.noMtime ? null : this.mtime,
            path: this.path,
            linkpath: this.linkpath,
            size: this.size,
            uid: this.portable ? null : this.uid,
            uname: this.portable ? null : this.uname,
            dev: this.portable ? null : this.readEntry.dev,
            ino: this.portable ? null : this.readEntry.ino,
            nlink: this.portable ? null : this.readEntry.nlink
          }).encode());
        super.write(this.header.block);
        readEntry.pipe(this);
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain)
          throw new Error("writing more to entry than is appropriate");
        this.blockRemain -= writeLen;
        return super.write(data);
      }
      end() {
        if (this.blockRemain)
          this.write(Buffer.alloc(this.blockRemain));
        return super.end();
      }
    });
    WriteEntry.Sync = WriteEntrySync;
    WriteEntry.Tar = WriteEntryTar;
    var getType = (stat) => stat.isFile() ? "File" : stat.isDirectory() ? "Directory" : stat.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
    module2.exports = WriteEntry;
  }
});

// node_modules/tar/lib/pack.js
var require_pack = __commonJS({
  "node_modules/tar/lib/pack.js"(exports2, module2) {
    "use strict";
    var PackJob = class {
      constructor(path35, absolute) {
        this.path = path35 || "./";
        this.absolute = absolute;
        this.entry = null;
        this.stat = null;
        this.readdir = null;
        this.pending = false;
        this.ignore = false;
        this.piped = false;
      }
    };
    var MiniPass = require_minipass();
    var zlib = require_minizlib();
    var ReadEntry = require_read_entry();
    var WriteEntry = require_write_entry();
    var WriteEntrySync = WriteEntry.Sync;
    var WriteEntryTar = WriteEntry.Tar;
    var Yallist = require_yallist();
    var EOF = Buffer.alloc(1024);
    var ONSTAT = Symbol("onStat");
    var ENDED = Symbol("ended");
    var QUEUE = Symbol("queue");
    var CURRENT = Symbol("current");
    var PROCESS = Symbol("process");
    var PROCESSING = Symbol("processing");
    var PROCESSJOB = Symbol("processJob");
    var JOBS = Symbol("jobs");
    var JOBDONE = Symbol("jobDone");
    var ADDFSENTRY = Symbol("addFSEntry");
    var ADDTARENTRY = Symbol("addTarEntry");
    var STAT = Symbol("stat");
    var READDIR = Symbol("readdir");
    var ONREADDIR = Symbol("onreaddir");
    var PIPE = Symbol("pipe");
    var ENTRY = Symbol("entry");
    var ENTRYOPT = Symbol("entryOpt");
    var WRITEENTRYCLASS = Symbol("writeEntryClass");
    var WRITE = Symbol("write");
    var ONDRAIN = Symbol("ondrain");
    var fs26 = require("fs");
    var path34 = require("path");
    var warner = require_warn_mixin();
    var Pack = warner(class Pack extends MiniPass {
      constructor(opt) {
        super(opt);
        opt = opt || Object.create(null);
        this.opt = opt;
        this.file = opt.file || "";
        this.cwd = opt.cwd || process.cwd();
        this.maxReadSize = opt.maxReadSize;
        this.preservePaths = !!opt.preservePaths;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.prefix = (opt.prefix || "").replace(/(\\|\/)+$/, "");
        this.linkCache = opt.linkCache || new Map();
        this.statCache = opt.statCache || new Map();
        this.readdirCache = opt.readdirCache || new Map();
        this[WRITEENTRYCLASS] = WriteEntry;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        this.portable = !!opt.portable;
        this.zip = null;
        if (opt.gzip) {
          if (typeof opt.gzip !== "object")
            opt.gzip = {};
          if (this.portable)
            opt.gzip.portable = true;
          this.zip = new zlib.Gzip(opt.gzip);
          this.zip.on("data", (chunk) => super.write(chunk));
          this.zip.on("end", (_) => super.end());
          this.zip.on("drain", (_) => this[ONDRAIN]());
          this.on("resume", (_) => this.zip.resume());
        } else
          this.on("drain", this[ONDRAIN]);
        this.noDirRecurse = !!opt.noDirRecurse;
        this.follow = !!opt.follow;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;
        this[QUEUE] = new Yallist();
        this[JOBS] = 0;
        this.jobs = +opt.jobs || 4;
        this[PROCESSING] = false;
        this[ENDED] = false;
      }
      [WRITE](chunk) {
        return super.write(chunk);
      }
      add(path35) {
        this.write(path35);
        return this;
      }
      end(path35) {
        if (path35)
          this.write(path35);
        this[ENDED] = true;
        this[PROCESS]();
        return this;
      }
      write(path35) {
        if (this[ENDED])
          throw new Error("write after end");
        if (path35 instanceof ReadEntry)
          this[ADDTARENTRY](path35);
        else
          this[ADDFSENTRY](path35);
        return this.flowing;
      }
      [ADDTARENTRY](p) {
        const absolute = path34.resolve(this.cwd, p.path);
        if (this.prefix)
          p.path = this.prefix + "/" + p.path.replace(/^\.(\/+|$)/, "");
        if (!this.filter(p.path, p))
          p.resume();
        else {
          const job = new PackJob(p.path, absolute, false);
          job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
          job.entry.on("end", (_) => this[JOBDONE](job));
          this[JOBS] += 1;
          this[QUEUE].push(job);
        }
        this[PROCESS]();
      }
      [ADDFSENTRY](p) {
        const absolute = path34.resolve(this.cwd, p);
        if (this.prefix)
          p = this.prefix + "/" + p.replace(/^\.(\/+|$)/, "");
        this[QUEUE].push(new PackJob(p, absolute));
        this[PROCESS]();
      }
      [STAT](job) {
        job.pending = true;
        this[JOBS] += 1;
        const stat = this.follow ? "stat" : "lstat";
        fs26[stat](job.absolute, (er, stat2) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er)
            this.emit("error", er);
          else
            this[ONSTAT](job, stat2);
        });
      }
      [ONSTAT](job, stat) {
        this.statCache.set(job.absolute, stat);
        job.stat = stat;
        if (!this.filter(job.path, stat))
          job.ignore = true;
        this[PROCESS]();
      }
      [READDIR](job) {
        job.pending = true;
        this[JOBS] += 1;
        fs26.readdir(job.absolute, (er, entries) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er)
            return this.emit("error", er);
          this[ONREADDIR](job, entries);
        });
      }
      [ONREADDIR](job, entries) {
        this.readdirCache.set(job.absolute, entries);
        job.readdir = entries;
        this[PROCESS]();
      }
      [PROCESS]() {
        if (this[PROCESSING])
          return;
        this[PROCESSING] = true;
        for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {
          this[PROCESSJOB](w.value);
          if (w.value.ignore) {
            const p = w.next;
            this[QUEUE].removeNode(w);
            w.next = p;
          }
        }
        this[PROCESSING] = false;
        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
          if (this.zip)
            this.zip.end(EOF);
          else {
            super.write(EOF);
            super.end();
          }
        }
      }
      get [CURRENT]() {
        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
      }
      [JOBDONE](job) {
        this[QUEUE].shift();
        this[JOBS] -= 1;
        this[PROCESS]();
      }
      [PROCESSJOB](job) {
        if (job.pending)
          return;
        if (job.entry) {
          if (job === this[CURRENT] && !job.piped)
            this[PIPE](job);
          return;
        }
        if (!job.stat) {
          if (this.statCache.has(job.absolute))
            this[ONSTAT](job, this.statCache.get(job.absolute));
          else
            this[STAT](job);
        }
        if (!job.stat)
          return;
        if (job.ignore)
          return;
        if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
          if (this.readdirCache.has(job.absolute))
            this[ONREADDIR](job, this.readdirCache.get(job.absolute));
          else
            this[READDIR](job);
          if (!job.readdir)
            return;
        }
        job.entry = this[ENTRY](job);
        if (!job.entry) {
          job.ignore = true;
          return;
        }
        if (job === this[CURRENT] && !job.piped)
          this[PIPE](job);
      }
      [ENTRYOPT](job) {
        return {
          onwarn: (code, msg, data) => this.warn(code, msg, data),
          noPax: this.noPax,
          cwd: this.cwd,
          absolute: job.absolute,
          preservePaths: this.preservePaths,
          maxReadSize: this.maxReadSize,
          strict: this.strict,
          portable: this.portable,
          linkCache: this.linkCache,
          statCache: this.statCache,
          noMtime: this.noMtime,
          mtime: this.mtime
        };
      }
      [ENTRY](job) {
        this[JOBS] += 1;
        try {
          return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
        } catch (er) {
          this.emit("error", er);
        }
      }
      [ONDRAIN]() {
        if (this[CURRENT] && this[CURRENT].entry)
          this[CURRENT].entry.resume();
      }
      [PIPE](job) {
        job.piped = true;
        if (job.readdir)
          job.readdir.forEach((entry) => {
            const p = this.prefix ? job.path.slice(this.prefix.length + 1) || "./" : job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        const source = job.entry;
        const zip = this.zip;
        if (zip)
          source.on("data", (chunk) => {
            if (!zip.write(chunk))
              source.pause();
          });
        else
          source.on("data", (chunk) => {
            if (!super.write(chunk))
              source.pause();
          });
      }
      pause() {
        if (this.zip)
          this.zip.pause();
        return super.pause();
      }
    });
    var PackSync = class extends Pack {
      constructor(opt) {
        super(opt);
        this[WRITEENTRYCLASS] = WriteEntrySync;
      }
      pause() {
      }
      resume() {
      }
      [STAT](job) {
        const stat = this.follow ? "statSync" : "lstatSync";
        this[ONSTAT](job, fs26[stat](job.absolute));
      }
      [READDIR](job, stat) {
        this[ONREADDIR](job, fs26.readdirSync(job.absolute));
      }
      [PIPE](job) {
        const source = job.entry;
        const zip = this.zip;
        if (job.readdir)
          job.readdir.forEach((entry) => {
            const p = this.prefix ? job.path.slice(this.prefix.length + 1) || "./" : job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        if (zip)
          source.on("data", (chunk) => {
            zip.write(chunk);
          });
        else
          source.on("data", (chunk) => {
            super[WRITE](chunk);
          });
      }
    };
    Pack.Sync = PackSync;
    module2.exports = Pack;
  }
});

// node_modules/fs-minipass/index.js
var require_fs_minipass = __commonJS({
  "node_modules/fs-minipass/index.js"(exports2) {
    "use strict";
    var MiniPass = require_minipass();
    var EE = require("events").EventEmitter;
    var fs26 = require("fs");
    var writev = fs26.writev;
    if (!writev) {
      const binding = process.binding("fs");
      const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
      writev = (fd, iovec, pos, cb) => {
        const done = (er, bw) => cb(er, bw, iovec);
        const req = new FSReqWrap();
        req.oncomplete = done;
        binding.writeBuffers(fd, iovec, pos, req);
      };
    }
    var _autoClose = Symbol("_autoClose");
    var _close = Symbol("_close");
    var _ended = Symbol("_ended");
    var _fd = Symbol("_fd");
    var _finished = Symbol("_finished");
    var _flags = Symbol("_flags");
    var _flush = Symbol("_flush");
    var _handleChunk = Symbol("_handleChunk");
    var _makeBuf = Symbol("_makeBuf");
    var _mode = Symbol("_mode");
    var _needDrain = Symbol("_needDrain");
    var _onerror = Symbol("_onerror");
    var _onopen = Symbol("_onopen");
    var _onread = Symbol("_onread");
    var _onwrite = Symbol("_onwrite");
    var _open = Symbol("_open");
    var _path = Symbol("_path");
    var _pos = Symbol("_pos");
    var _queue = Symbol("_queue");
    var _read = Symbol("_read");
    var _readSize = Symbol("_readSize");
    var _reading = Symbol("_reading");
    var _remain = Symbol("_remain");
    var _size = Symbol("_size");
    var _write = Symbol("_write");
    var _writing = Symbol("_writing");
    var _defaultFlag = Symbol("_defaultFlag");
    var _errored = Symbol("_errored");
    var ReadStream = class extends MiniPass {
      constructor(path34, opt) {
        opt = opt || {};
        super(opt);
        this.readable = true;
        this.writable = false;
        if (typeof path34 !== "string")
          throw new TypeError("path must be a string");
        this[_errored] = false;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_path] = path34;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        if (typeof this[_fd] === "number")
          this[_read]();
        else
          this[_open]();
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      write() {
        throw new TypeError("this is a readable stream");
      }
      end() {
        throw new TypeError("this is a readable stream");
      }
      [_open]() {
        fs26.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_read]();
        }
      }
      [_makeBuf]() {
        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
      }
      [_read]() {
        if (!this[_reading]) {
          this[_reading] = true;
          const buf = this[_makeBuf]();
          if (buf.length === 0)
            return process.nextTick(() => this[_onread](null, 0, buf));
          fs26.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
        }
      }
      [_onread](er, br, buf) {
        this[_reading] = false;
        if (er)
          this[_onerror](er);
        else if (this[_handleChunk](br, buf))
          this[_read]();
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs26.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
      [_onerror](er) {
        this[_reading] = true;
        this[_close]();
        this.emit("error", er);
      }
      [_handleChunk](br, buf) {
        let ret = false;
        this[_remain] -= br;
        if (br > 0)
          ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
        if (br === 0 || this[_remain] <= 0) {
          ret = false;
          this[_close]();
          super.end();
        }
        return ret;
      }
      emit(ev, data) {
        switch (ev) {
          case "prefinish":
          case "finish":
            break;
          case "drain":
            if (typeof this[_fd] === "number")
              this[_read]();
            break;
          case "error":
            if (this[_errored])
              return;
            this[_errored] = true;
            return super.emit(ev, data);
          default:
            return super.emit(ev, data);
        }
      }
    };
    var ReadStreamSync = class extends ReadStream {
      [_open]() {
        let threw = true;
        try {
          this[_onopen](null, fs26.openSync(this[_path], "r"));
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_read]() {
        let threw = true;
        try {
          if (!this[_reading]) {
            this[_reading] = true;
            do {
              const buf = this[_makeBuf]();
              const br = buf.length === 0 ? 0 : fs26.readSync(this[_fd], buf, 0, buf.length, null);
              if (!this[_handleChunk](br, buf))
                break;
            } while (true);
            this[_reading] = false;
          }
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs26.closeSync(fd);
          this.emit("close");
        }
      }
    };
    var WriteStream = class extends EE {
      constructor(path34, opt) {
        opt = opt || {};
        super(opt);
        this.readable = false;
        this.writable = true;
        this[_errored] = false;
        this[_writing] = false;
        this[_ended] = false;
        this[_needDrain] = false;
        this[_queue] = [];
        this[_path] = path34;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
        this[_pos] = typeof opt.start === "number" ? opt.start : null;
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        const defaultFlag = this[_pos] !== null ? "r+" : "w";
        this[_defaultFlag] = opt.flags === void 0;
        this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
        if (this[_fd] === null)
          this[_open]();
      }
      emit(ev, data) {
        if (ev === "error") {
          if (this[_errored])
            return;
          this[_errored] = true;
        }
        return super.emit(ev, data);
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      [_onerror](er) {
        this[_close]();
        this[_writing] = true;
        this.emit("error", er);
      }
      [_open]() {
        fs26.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
          this[_flags] = "w";
          this[_open]();
        } else if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_flush]();
        }
      }
      end(buf, enc) {
        if (buf)
          this.write(buf, enc);
        this[_ended] = true;
        if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
          this[_onwrite](null, 0);
        return this;
      }
      write(buf, enc) {
        if (typeof buf === "string")
          buf = Buffer.from(buf, enc);
        if (this[_ended]) {
          this.emit("error", new Error("write() after end()"));
          return false;
        }
        if (this[_fd] === null || this[_writing] || this[_queue].length) {
          this[_queue].push(buf);
          this[_needDrain] = true;
          return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
      }
      [_write](buf) {
        fs26.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
      [_onwrite](er, bw) {
        if (er)
          this[_onerror](er);
        else {
          if (this[_pos] !== null)
            this[_pos] += bw;
          if (this[_queue].length)
            this[_flush]();
          else {
            this[_writing] = false;
            if (this[_ended] && !this[_finished]) {
              this[_finished] = true;
              this[_close]();
              this.emit("finish");
            } else if (this[_needDrain]) {
              this[_needDrain] = false;
              this.emit("drain");
            }
          }
        }
      }
      [_flush]() {
        if (this[_queue].length === 0) {
          if (this[_ended])
            this[_onwrite](null, 0);
        } else if (this[_queue].length === 1)
          this[_write](this[_queue].pop());
        else {
          const iovec = this[_queue];
          this[_queue] = [];
          writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs26.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
    };
    var WriteStreamSync = class extends WriteStream {
      [_open]() {
        let fd;
        if (this[_defaultFlag] && this[_flags] === "r+") {
          try {
            fd = fs26.openSync(this[_path], this[_flags], this[_mode]);
          } catch (er) {
            if (er.code === "ENOENT") {
              this[_flags] = "w";
              return this[_open]();
            } else
              throw er;
          }
        } else
          fd = fs26.openSync(this[_path], this[_flags], this[_mode]);
        this[_onopen](null, fd);
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs26.closeSync(fd);
          this.emit("close");
        }
      }
      [_write](buf) {
        let threw = true;
        try {
          this[_onwrite](null, fs26.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
          threw = false;
        } finally {
          if (threw)
            try {
              this[_close]();
            } catch (_) {
            }
        }
      }
    };
    exports2.ReadStream = ReadStream;
    exports2.ReadStreamSync = ReadStreamSync;
    exports2.WriteStream = WriteStream;
    exports2.WriteStreamSync = WriteStreamSync;
  }
});

// node_modules/tar/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/tar/lib/parse.js"(exports2, module2) {
    "use strict";
    var warner = require_warn_mixin();
    var path34 = require("path");
    var Header = require_header();
    var EE = require("events");
    var Yallist = require_yallist();
    var maxMetaEntrySize = 1024 * 1024;
    var Entry = require_read_entry();
    var Pax = require_pax();
    var zlib = require_minizlib();
    var gzipHeader = Buffer.from([31, 139]);
    var STATE = Symbol("state");
    var WRITEENTRY = Symbol("writeEntry");
    var READENTRY = Symbol("readEntry");
    var NEXTENTRY = Symbol("nextEntry");
    var PROCESSENTRY = Symbol("processEntry");
    var EX = Symbol("extendedHeader");
    var GEX = Symbol("globalExtendedHeader");
    var META = Symbol("meta");
    var EMITMETA = Symbol("emitMeta");
    var BUFFER = Symbol("buffer");
    var QUEUE = Symbol("queue");
    var ENDED = Symbol("ended");
    var EMITTEDEND = Symbol("emittedEnd");
    var EMIT = Symbol("emit");
    var UNZIP = Symbol("unzip");
    var CONSUMECHUNK = Symbol("consumeChunk");
    var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
    var CONSUMEBODY = Symbol("consumeBody");
    var CONSUMEMETA = Symbol("consumeMeta");
    var CONSUMEHEADER = Symbol("consumeHeader");
    var CONSUMING = Symbol("consuming");
    var BUFFERCONCAT = Symbol("bufferConcat");
    var MAYBEEND = Symbol("maybeEnd");
    var WRITING = Symbol("writing");
    var ABORTED = Symbol("aborted");
    var DONE = Symbol("onDone");
    var SAW_VALID_ENTRY = Symbol("sawValidEntry");
    var SAW_NULL_BLOCK = Symbol("sawNullBlock");
    var SAW_EOF = Symbol("sawEOF");
    var noop = (_) => true;
    module2.exports = warner(class Parser extends EE {
      constructor(opt) {
        opt = opt || {};
        super(opt);
        this.file = opt.file || "";
        this[SAW_VALID_ENTRY] = null;
        this.on(DONE, (_) => {
          if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
            this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
          }
        });
        if (opt.ondone)
          this.on(DONE, opt.ondone);
        else
          this.on(DONE, (_) => {
            this.emit("prefinish");
            this.emit("finish");
            this.emit("end");
            this.emit("close");
          });
        this.strict = !!opt.strict;
        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
        this.filter = typeof opt.filter === "function" ? opt.filter : noop;
        this.writable = true;
        this.readable = false;
        this[QUEUE] = new Yallist();
        this[BUFFER] = null;
        this[READENTRY] = null;
        this[WRITEENTRY] = null;
        this[STATE] = "begin";
        this[META] = "";
        this[EX] = null;
        this[GEX] = null;
        this[ENDED] = false;
        this[UNZIP] = null;
        this[ABORTED] = false;
        this[SAW_NULL_BLOCK] = false;
        this[SAW_EOF] = false;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        if (typeof opt.onentry === "function")
          this.on("entry", opt.onentry);
      }
      [CONSUMEHEADER](chunk, position) {
        if (this[SAW_VALID_ENTRY] === null)
          this[SAW_VALID_ENTRY] = false;
        let header;
        try {
          header = new Header(chunk, position, this[EX], this[GEX]);
        } catch (er) {
          return this.warn("TAR_ENTRY_INVALID", er);
        }
        if (header.nullBlock) {
          if (this[SAW_NULL_BLOCK]) {
            this[SAW_EOF] = true;
            if (this[STATE] === "begin")
              this[STATE] = "header";
            this[EMIT]("eof");
          } else {
            this[SAW_NULL_BLOCK] = true;
            this[EMIT]("nullBlock");
          }
        } else {
          this[SAW_NULL_BLOCK] = false;
          if (!header.cksumValid)
            this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
          else if (!header.path)
            this.warn("TAR_ENTRY_INVALID", "path is required", { header });
          else {
            const type = header.type;
            if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)
              this.warn("TAR_ENTRY_INVALID", "linkpath required", { header });
            else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)
              this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header });
            else {
              const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
              if (!this[SAW_VALID_ENTRY]) {
                if (entry.remain) {
                  const onend = () => {
                    if (!entry.invalid)
                      this[SAW_VALID_ENTRY] = true;
                  };
                  entry.on("end", onend);
                } else {
                  this[SAW_VALID_ENTRY] = true;
                }
              }
              if (entry.meta) {
                if (entry.size > this.maxMetaEntrySize) {
                  entry.ignore = true;
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = "ignore";
                  entry.resume();
                } else if (entry.size > 0) {
                  this[META] = "";
                  entry.on("data", (c) => this[META] += c);
                  this[STATE] = "meta";
                }
              } else {
                this[EX] = null;
                entry.ignore = entry.ignore || !this.filter(entry.path, entry);
                if (entry.ignore) {
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = entry.remain ? "ignore" : "header";
                  entry.resume();
                } else {
                  if (entry.remain)
                    this[STATE] = "body";
                  else {
                    this[STATE] = "header";
                    entry.end();
                  }
                  if (!this[READENTRY]) {
                    this[QUEUE].push(entry);
                    this[NEXTENTRY]();
                  } else
                    this[QUEUE].push(entry);
                }
              }
            }
          }
        }
      }
      [PROCESSENTRY](entry) {
        let go = true;
        if (!entry) {
          this[READENTRY] = null;
          go = false;
        } else if (Array.isArray(entry))
          this.emit.apply(this, entry);
        else {
          this[READENTRY] = entry;
          this.emit("entry", entry);
          if (!entry.emittedEnd) {
            entry.on("end", (_) => this[NEXTENTRY]());
            go = false;
          }
        }
        return go;
      }
      [NEXTENTRY]() {
        do {
        } while (this[PROCESSENTRY](this[QUEUE].shift()));
        if (!this[QUEUE].length) {
          const re = this[READENTRY];
          const drainNow = !re || re.flowing || re.size === re.remain;
          if (drainNow) {
            if (!this[WRITING])
              this.emit("drain");
          } else
            re.once("drain", (_) => this.emit("drain"));
        }
      }
      [CONSUMEBODY](chunk, position) {
        const entry = this[WRITEENTRY];
        const br = entry.blockRemain;
        const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
        entry.write(c);
        if (!entry.blockRemain) {
          this[STATE] = "header";
          this[WRITEENTRY] = null;
          entry.end();
        }
        return c.length;
      }
      [CONSUMEMETA](chunk, position) {
        const entry = this[WRITEENTRY];
        const ret = this[CONSUMEBODY](chunk, position);
        if (!this[WRITEENTRY])
          this[EMITMETA](entry);
        return ret;
      }
      [EMIT](ev, data, extra) {
        if (!this[QUEUE].length && !this[READENTRY])
          this.emit(ev, data, extra);
        else
          this[QUEUE].push([ev, data, extra]);
      }
      [EMITMETA](entry) {
        this[EMIT]("meta", this[META]);
        switch (entry.type) {
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this[EX] = Pax.parse(this[META], this[EX], false);
            break;
          case "GlobalExtendedHeader":
            this[GEX] = Pax.parse(this[META], this[GEX], true);
            break;
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
            this[EX] = this[EX] || Object.create(null);
            this[EX].path = this[META].replace(/\0.*/, "");
            break;
          case "NextFileHasLongLinkpath":
            this[EX] = this[EX] || Object.create(null);
            this[EX].linkpath = this[META].replace(/\0.*/, "");
            break;
          default:
            throw new Error("unknown meta: " + entry.type);
        }
      }
      abort(error) {
        this[ABORTED] = true;
        this.emit("abort", error);
        this.warn("TAR_ABORT", error, { recoverable: false });
      }
      write(chunk) {
        if (this[ABORTED])
          return;
        if (this[UNZIP] === null && chunk) {
          if (this[BUFFER]) {
            chunk = Buffer.concat([this[BUFFER], chunk]);
            this[BUFFER] = null;
          }
          if (chunk.length < gzipHeader.length) {
            this[BUFFER] = chunk;
            return true;
          }
          for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
            if (chunk[i] !== gzipHeader[i])
              this[UNZIP] = false;
          }
          if (this[UNZIP] === null) {
            const ended = this[ENDED];
            this[ENDED] = false;
            this[UNZIP] = new zlib.Unzip();
            this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
            this[UNZIP].on("error", (er) => this.abort(er));
            this[UNZIP].on("end", (_) => {
              this[ENDED] = true;
              this[CONSUMECHUNK]();
            });
            this[WRITING] = true;
            const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
            this[WRITING] = false;
            return ret2;
          }
        }
        this[WRITING] = true;
        if (this[UNZIP])
          this[UNZIP].write(chunk);
        else
          this[CONSUMECHUNK](chunk);
        this[WRITING] = false;
        const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
        if (!ret && !this[QUEUE].length)
          this[READENTRY].once("drain", (_) => this.emit("drain"));
        return ret;
      }
      [BUFFERCONCAT](c) {
        if (c && !this[ABORTED])
          this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
      }
      [MAYBEEND]() {
        if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
          this[EMITTEDEND] = true;
          const entry = this[WRITEENTRY];
          if (entry && entry.blockRemain) {
            const have = this[BUFFER] ? this[BUFFER].length : 0;
            this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
            if (this[BUFFER])
              entry.write(this[BUFFER]);
            entry.end();
          }
          this[EMIT](DONE);
        }
      }
      [CONSUMECHUNK](chunk) {
        if (this[CONSUMING])
          this[BUFFERCONCAT](chunk);
        else if (!chunk && !this[BUFFER])
          this[MAYBEEND]();
        else {
          this[CONSUMING] = true;
          if (this[BUFFER]) {
            this[BUFFERCONCAT](chunk);
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          } else {
            this[CONSUMECHUNKSUB](chunk);
          }
          while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          }
          this[CONSUMING] = false;
        }
        if (!this[BUFFER] || this[ENDED])
          this[MAYBEEND]();
      }
      [CONSUMECHUNKSUB](chunk) {
        let position = 0;
        let length = chunk.length;
        while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
          switch (this[STATE]) {
            case "begin":
            case "header":
              this[CONSUMEHEADER](chunk, position);
              position += 512;
              break;
            case "ignore":
            case "body":
              position += this[CONSUMEBODY](chunk, position);
              break;
            case "meta":
              position += this[CONSUMEMETA](chunk, position);
              break;
            default:
              throw new Error("invalid state: " + this[STATE]);
          }
        }
        if (position < length) {
          if (this[BUFFER])
            this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
          else
            this[BUFFER] = chunk.slice(position);
        }
      }
      end(chunk) {
        if (!this[ABORTED]) {
          if (this[UNZIP])
            this[UNZIP].end(chunk);
          else {
            this[ENDED] = true;
            this.write(chunk);
          }
        }
      }
    });
  }
});

// node_modules/tar/lib/list.js
var require_list = __commonJS({
  "node_modules/tar/lib/list.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Parser = require_parse2();
    var fs26 = require("fs");
    var fsm = require_fs_minipass();
    var path34 = require("path");
    var t = module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function")
        cb = opt_, files = null, opt_ = {};
      else if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (typeof files === "function")
        cb = files, files = null;
      if (!files)
        files = [];
      else
        files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      if (files.length)
        filesFilter(opt, files);
      if (!opt.noResume)
        onentryFunction(opt);
      return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list2(opt);
    };
    var onentryFunction = (opt) => {
      const onentry = opt.onentry;
      opt.onentry = onentry ? (e) => {
        onentry(e);
        e.resume();
      } : (e) => e.resume();
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [f.replace(/\/+$/, ""), true]));
      const filter = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path34.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path34.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\/+$/, "")) : (file) => mapHas(file.replace(/\/+$/, ""));
    };
    var listFileSync = (opt) => {
      const p = list2(opt);
      const file = opt.file;
      let threw = true;
      let fd;
      try {
        const stat = fs26.statSync(file);
        const readSize = opt.maxReadSize || 16 * 1024 * 1024;
        if (stat.size < readSize) {
          p.end(fs26.readFileSync(file));
        } else {
          let pos = 0;
          const buf = Buffer.allocUnsafe(readSize);
          fd = fs26.openSync(file, "r");
          while (pos < stat.size) {
            let bytesRead = fs26.readSync(fd, buf, 0, readSize, pos);
            pos += bytesRead;
            p.write(buf.slice(0, bytesRead));
          }
          p.end();
        }
        threw = false;
      } finally {
        if (threw && fd)
          try {
            fs26.closeSync(fd);
          } catch (er) {
          }
      }
    };
    var listFile = (opt, cb) => {
      const parse5 = new Parser(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve3, reject) => {
        parse5.on("error", reject);
        parse5.on("end", resolve3);
        fs26.stat(file, (er, stat) => {
          if (er)
            reject(er);
          else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(parse5);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var list2 = (opt) => new Parser(opt);
  }
});

// node_modules/tar/lib/create.js
var require_create = __commonJS({
  "node_modules/tar/lib/create.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fs26 = require("fs");
    var fsm = require_fs_minipass();
    var t = require_list();
    var path34 = require("path");
    var c = module2.exports = (opt_, files, cb) => {
      if (typeof files === "function")
        cb = files;
      if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
    };
    var createFileSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      const stream = new fsm.WriteStreamSync(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var createFile = (opt, files, cb) => {
      const p = new Pack(opt);
      const stream = new fsm.WriteStream(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      const promise = new Promise((res, rej) => {
        stream.on("error", rej);
        stream.on("close", res);
        p.on("error", rej);
      });
      addFilesAsync(p, files);
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@")
          t({
            file: path34.resolve(p.cwd, file.substr(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        else
          p.add(file);
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@")
          return t({
            file: path34.resolve(p.cwd, file.substr(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        else
          p.add(file);
      }
      p.end();
    };
    var createSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      addFilesSync(p, files);
      return p;
    };
    var create = (opt, files) => {
      const p = new Pack(opt);
      addFilesAsync(p, files);
      return p;
    };
  }
});

// node_modules/tar/lib/replace.js
var require_replace = __commonJS({
  "node_modules/tar/lib/replace.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var Parse = require_parse2();
    var fs26 = require("fs");
    var fsm = require_fs_minipass();
    var t = require_list();
    var path34 = require("path");
    var Header = require_header();
    var r = module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file)
        throw new TypeError("file is required");
      if (opt.gzip)
        throw new TypeError("cannot append to compressed archives");
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
    };
    var replaceSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      let threw = true;
      let fd;
      let position;
      try {
        try {
          fd = fs26.openSync(opt.file, "r+");
        } catch (er) {
          if (er.code === "ENOENT")
            fd = fs26.openSync(opt.file, "w+");
          else
            throw er;
        }
        const st = fs26.fstatSync(fd);
        const headBuf = Buffer.alloc(512);
        POSITION:
          for (position = 0; position < st.size; position += 512) {
            for (let bufPos = 0, bytes2 = 0; bufPos < 512; bufPos += bytes2) {
              bytes2 = fs26.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);
              if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
                throw new Error("cannot append to compressed archives");
              if (!bytes2)
                break POSITION;
            }
            let h = new Header(headBuf);
            if (!h.cksumValid)
              break;
            let entryBlockSize = 512 * Math.ceil(h.size / 512);
            if (position + entryBlockSize + 512 > st.size)
              break;
            position += entryBlockSize;
            if (opt.mtimeCache)
              opt.mtimeCache.set(h.path, h.mtime);
          }
        threw = false;
        streamSync(opt, p, position, fd, files);
      } finally {
        if (threw)
          try {
            fs26.closeSync(fd);
          } catch (er) {
          }
      }
    };
    var streamSync = (opt, p, position, fd, files) => {
      const stream = new fsm.WriteStreamSync(opt.file, {
        fd,
        start: position
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var replace = (opt, files, cb) => {
      files = Array.from(files);
      const p = new Pack(opt);
      const getPos = (fd, size, cb_) => {
        const cb2 = (er, pos) => {
          if (er)
            fs26.close(fd, (_) => cb_(er));
          else
            cb_(null, pos);
        };
        let position = 0;
        if (size === 0)
          return cb2(null, 0);
        let bufPos = 0;
        const headBuf = Buffer.alloc(512);
        const onread = (er, bytes2) => {
          if (er)
            return cb2(er);
          bufPos += bytes2;
          if (bufPos < 512 && bytes2)
            return fs26.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);
          if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
            return cb2(new Error("cannot append to compressed archives"));
          if (bufPos < 512)
            return cb2(null, position);
          const h = new Header(headBuf);
          if (!h.cksumValid)
            return cb2(null, position);
          const entryBlockSize = 512 * Math.ceil(h.size / 512);
          if (position + entryBlockSize + 512 > size)
            return cb2(null, position);
          position += entryBlockSize + 512;
          if (position >= size)
            return cb2(null, position);
          if (opt.mtimeCache)
            opt.mtimeCache.set(h.path, h.mtime);
          bufPos = 0;
          fs26.read(fd, headBuf, 0, 512, position, onread);
        };
        fs26.read(fd, headBuf, 0, 512, position, onread);
      };
      const promise = new Promise((resolve3, reject) => {
        p.on("error", reject);
        let flag = "r+";
        const onopen = (er, fd) => {
          if (er && er.code === "ENOENT" && flag === "r+") {
            flag = "w+";
            return fs26.open(opt.file, flag, onopen);
          }
          if (er)
            return reject(er);
          fs26.fstat(fd, (er2, st) => {
            if (er2)
              return reject(er2);
            getPos(fd, st.size, (er3, position) => {
              if (er3)
                return reject(er3);
              const stream = new fsm.WriteStream(opt.file, {
                fd,
                start: position
              });
              p.pipe(stream);
              stream.on("error", reject);
              stream.on("close", resolve3);
              addFilesAsync(p, files);
            });
          });
        };
        fs26.open(opt.file, flag, onopen);
      });
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@")
          t({
            file: path34.resolve(p.cwd, file.substr(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        else
          p.add(file);
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@")
          return t({
            file: path34.resolve(p.cwd, file.substr(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        else
          p.add(file);
      }
      p.end();
    };
  }
});

// node_modules/tar/lib/update.js
var require_update = __commonJS({
  "node_modules/tar/lib/update.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var r = require_replace();
    var u = module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file)
        throw new TypeError("file is required");
      if (opt.gzip)
        throw new TypeError("cannot append to compressed archives");
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      mtimeFilter(opt);
      return r(opt, files, cb);
    };
    var mtimeFilter = (opt) => {
      const filter = opt.filter;
      if (!opt.mtimeCache)
        opt.mtimeCache = new Map();
      opt.filter = filter ? (path34, stat) => filter(path34, stat) && !(opt.mtimeCache.get(path34) > stat.mtime) : (path34, stat) => !(opt.mtimeCache.get(path34) > stat.mtime);
    };
  }
});

// node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS({
  "node_modules/mkdirp/lib/opts-arg.js"(exports2, module2) {
    var { promisify } = require("util");
    var fs26 = require("fs");
    var optsArg = (opts) => {
      if (!opts)
        opts = { mode: 511, fs: fs26 };
      else if (typeof opts === "object")
        opts = __spreadValues({ mode: 511, fs: fs26 }, opts);
      else if (typeof opts === "number")
        opts = { mode: opts, fs: fs26 };
      else if (typeof opts === "string")
        opts = { mode: parseInt(opts, 8), fs: fs26 };
      else
        throw new TypeError("invalid options argument");
      opts.mkdir = opts.mkdir || opts.fs.mkdir || fs26.mkdir;
      opts.mkdirAsync = promisify(opts.mkdir);
      opts.stat = opts.stat || opts.fs.stat || fs26.stat;
      opts.statAsync = promisify(opts.stat);
      opts.statSync = opts.statSync || opts.fs.statSync || fs26.statSync;
      opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs26.mkdirSync;
      return opts;
    };
    module2.exports = optsArg;
  }
});

// node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS({
  "node_modules/mkdirp/lib/path-arg.js"(exports2, module2) {
    var platform3 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
    var { resolve: resolve3, parse: parse5 } = require("path");
    var pathArg = (path34) => {
      if (/\0/.test(path34)) {
        throw Object.assign(new TypeError("path must be a string without null bytes"), {
          path: path34,
          code: "ERR_INVALID_ARG_VALUE"
        });
      }
      path34 = resolve3(path34);
      if (platform3 === "win32") {
        const badWinChars = /[*|"<>?:]/;
        const { root } = parse5(path34);
        if (badWinChars.test(path34.substr(root.length))) {
          throw Object.assign(new Error("Illegal characters in path."), {
            path: path34,
            code: "EINVAL"
          });
        }
      }
      return path34;
    };
    module2.exports = pathArg;
  }
});

// node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS({
  "node_modules/mkdirp/lib/find-made.js"(exports2, module2) {
    var { dirname: dirname4 } = require("path");
    var findMade = (opts, parent, path34 = void 0) => {
      if (path34 === parent)
        return Promise.resolve();
      return opts.statAsync(parent).then((st) => st.isDirectory() ? path34 : void 0, (er) => er.code === "ENOENT" ? findMade(opts, dirname4(parent), parent) : void 0);
    };
    var findMadeSync = (opts, parent, path34 = void 0) => {
      if (path34 === parent)
        return void 0;
      try {
        return opts.statSync(parent).isDirectory() ? path34 : void 0;
      } catch (er) {
        return er.code === "ENOENT" ? findMadeSync(opts, dirname4(parent), parent) : void 0;
      }
    };
    module2.exports = { findMade, findMadeSync };
  }
});

// node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS({
  "node_modules/mkdirp/lib/mkdirp-manual.js"(exports2, module2) {
    var { dirname: dirname4 } = require("path");
    var mkdirpManual = (path34, opts, made) => {
      opts.recursive = false;
      const parent = dirname4(path34);
      if (parent === path34) {
        return opts.mkdirAsync(path34, opts).catch((er) => {
          if (er.code !== "EISDIR")
            throw er;
        });
      }
      return opts.mkdirAsync(path34, opts).then(() => made || path34, (er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path34, opts, made2));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        return opts.statAsync(path34).then((st) => {
          if (st.isDirectory())
            return made;
          else
            throw er;
        }, () => {
          throw er;
        });
      });
    };
    var mkdirpManualSync = (path34, opts, made) => {
      const parent = dirname4(path34);
      opts.recursive = false;
      if (parent === path34) {
        try {
          return opts.mkdirSync(path34, opts);
        } catch (er) {
          if (er.code !== "EISDIR")
            throw er;
          else
            return;
        }
      }
      try {
        opts.mkdirSync(path34, opts);
        return made || path34;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path34, opts, mkdirpManualSync(parent, opts, made));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        try {
          if (!opts.statSync(path34).isDirectory())
            throw er;
        } catch (_) {
          throw er;
        }
      }
    };
    module2.exports = { mkdirpManual, mkdirpManualSync };
  }
});

// node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS({
  "node_modules/mkdirp/lib/mkdirp-native.js"(exports2, module2) {
    var { dirname: dirname4 } = require("path");
    var { findMade, findMadeSync } = require_find_made();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var mkdirpNative = (path34, opts) => {
      opts.recursive = true;
      const parent = dirname4(path34);
      if (parent === path34)
        return opts.mkdirAsync(path34, opts);
      return findMade(opts, path34).then((made) => opts.mkdirAsync(path34, opts).then(() => made).catch((er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(path34, opts);
        else
          throw er;
      }));
    };
    var mkdirpNativeSync = (path34, opts) => {
      opts.recursive = true;
      const parent = dirname4(path34);
      if (parent === path34)
        return opts.mkdirSync(path34, opts);
      const made = findMadeSync(opts, path34);
      try {
        opts.mkdirSync(path34, opts);
        return made;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path34, opts);
        else
          throw er;
      }
    };
    module2.exports = { mkdirpNative, mkdirpNativeSync };
  }
});

// node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS({
  "node_modules/mkdirp/lib/use-native.js"(exports2, module2) {
    var fs26 = require("fs");
    var version2 = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
    var versArr = version2.replace(/^v/, "").split(".");
    var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
    var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs26.mkdir;
    var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs26.mkdirSync;
    module2.exports = { useNative, useNativeSync };
  }
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "node_modules/mkdirp/index.js"(exports2, module2) {
    var optsArg = require_opts_arg();
    var pathArg = require_path_arg();
    var { mkdirpNative, mkdirpNativeSync } = require_mkdirp_native();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var { useNative, useNativeSync } = require_use_native();
    var mkdirp = (path34, opts) => {
      path34 = pathArg(path34);
      opts = optsArg(opts);
      return useNative(opts) ? mkdirpNative(path34, opts) : mkdirpManual(path34, opts);
    };
    var mkdirpSync = (path34, opts) => {
      path34 = pathArg(path34);
      opts = optsArg(opts);
      return useNativeSync(opts) ? mkdirpNativeSync(path34, opts) : mkdirpManualSync(path34, opts);
    };
    mkdirp.sync = mkdirpSync;
    mkdirp.native = (path34, opts) => mkdirpNative(pathArg(path34), optsArg(opts));
    mkdirp.manual = (path34, opts) => mkdirpManual(pathArg(path34), optsArg(opts));
    mkdirp.nativeSync = (path34, opts) => mkdirpNativeSync(pathArg(path34), optsArg(opts));
    mkdirp.manualSync = (path34, opts) => mkdirpManualSync(pathArg(path34), optsArg(opts));
    module2.exports = mkdirp;
  }
});

// node_modules/chownr/chownr.js
var require_chownr = __commonJS({
  "node_modules/chownr/chownr.js"(exports2, module2) {
    "use strict";
    var fs26 = require("fs");
    var path34 = require("path");
    var LCHOWN = fs26.lchown ? "lchown" : "chown";
    var LCHOWNSYNC = fs26.lchownSync ? "lchownSync" : "chownSync";
    var needEISDIRHandled = fs26.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
    var lchownSync = (path35, uid, gid) => {
      try {
        return fs26[LCHOWNSYNC](path35, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var chownSync = (path35, uid, gid) => {
      try {
        return fs26.chownSync(path35, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var handleEISDIR = needEISDIRHandled ? (path35, uid, gid, cb) => (er) => {
      if (!er || er.code !== "EISDIR")
        cb(er);
      else
        fs26.chown(path35, uid, gid, cb);
    } : (_, __, ___, cb) => cb;
    var handleEISDirSync = needEISDIRHandled ? (path35, uid, gid) => {
      try {
        return lchownSync(path35, uid, gid);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        chownSync(path35, uid, gid);
      }
    } : (path35, uid, gid) => lchownSync(path35, uid, gid);
    var nodeVersion = process.version;
    var readdir = (path35, options, cb) => fs26.readdir(path35, options, cb);
    var readdirSync = (path35, options) => fs26.readdirSync(path35, options);
    if (/^v4\./.test(nodeVersion))
      readdir = (path35, options, cb) => fs26.readdir(path35, cb);
    var chown = (cpath, uid, gid, cb) => {
      fs26[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
        cb(er && er.code !== "ENOENT" ? er : null);
      }));
    };
    var chownrKid = (p, child, uid, gid, cb) => {
      if (typeof child === "string")
        return fs26.lstat(path34.resolve(p, child), (er, stats) => {
          if (er)
            return cb(er.code !== "ENOENT" ? er : null);
          stats.name = child;
          chownrKid(p, stats, uid, gid, cb);
        });
      if (child.isDirectory()) {
        chownr(path34.resolve(p, child.name), uid, gid, (er) => {
          if (er)
            return cb(er);
          const cpath = path34.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        });
      } else {
        const cpath = path34.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      }
    };
    var chownr = (p, uid, gid, cb) => {
      readdir(p, { withFileTypes: true }, (er, children) => {
        if (er) {
          if (er.code === "ENOENT")
            return cb();
          else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
            return cb(er);
        }
        if (er || !children.length)
          return chown(p, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--len === 0)
            return chown(p, uid, gid, cb);
        };
        children.forEach((child) => chownrKid(p, child, uid, gid, then));
      });
    };
    var chownrKidSync = (p, child, uid, gid) => {
      if (typeof child === "string") {
        try {
          const stats = fs26.lstatSync(path34.resolve(p, child));
          stats.name = child;
          child = stats;
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          else
            throw er;
        }
      }
      if (child.isDirectory())
        chownrSync(path34.resolve(p, child.name), uid, gid);
      handleEISDirSync(path34.resolve(p, child.name), uid, gid);
    };
    var chownrSync = (p, uid, gid) => {
      let children;
      try {
        children = readdirSync(p, { withFileTypes: true });
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
          return handleEISDirSync(p, uid, gid);
        else
          throw er;
      }
      if (children && children.length)
        children.forEach((child) => chownrKidSync(p, child, uid, gid));
      return handleEISDirSync(p, uid, gid);
    };
    module2.exports = chownr;
    chownr.sync = chownrSync;
  }
});

// node_modules/tar/lib/mkdir.js
var require_mkdir = __commonJS({
  "node_modules/tar/lib/mkdir.js"(exports2, module2) {
    "use strict";
    var mkdirp = require_mkdirp();
    var fs26 = require("fs");
    var path34 = require("path");
    var chownr = require_chownr();
    var SymlinkError = class extends Error {
      constructor(symlink, path35) {
        super("Cannot extract through symbolic link");
        this.path = path35;
        this.symlink = symlink;
      }
      get name() {
        return "SylinkError";
      }
    };
    var CwdError = class extends Error {
      constructor(path35, code) {
        super(code + ": Cannot cd into '" + path35 + "'");
        this.path = path35;
        this.code = code;
      }
      get name() {
        return "CwdError";
      }
    };
    var mkdir = module2.exports = (dir, opt, cb) => {
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd = opt.cwd;
      const done = (er, created) => {
        if (er)
          cb(er);
        else {
          cache.set(dir, true);
          if (created && doChown)
            chownr(created, uid, gid, (er2) => done(er2));
          else if (needChmod)
            fs26.chmod(dir, mode, cb);
          else
            cb();
        }
      };
      if (cache && cache.get(dir) === true)
        return done();
      if (dir === cwd)
        return fs26.stat(dir, (er, st) => {
          if (er || !st.isDirectory())
            er = new CwdError(dir, er && er.code || "ENOTDIR");
          done(er);
        });
      if (preserve)
        return mkdirp(dir, { mode }).then((made) => done(null, made), done);
      const sub = path34.relative(cwd, dir);
      const parts = sub.split(/\/|\\/);
      mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);
    };
    var mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
      if (!parts.length)
        return cb(null, created);
      const p = parts.shift();
      const part = base + "/" + p;
      if (cache.get(part))
        return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
      fs26.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
    };
    var onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => (er) => {
      if (er) {
        if (er.path && path34.dirname(er.path) === cwd && (er.code === "ENOTDIR" || er.code === "ENOENT"))
          return cb(new CwdError(cwd, er.code));
        fs26.lstat(part, (statEr, st) => {
          if (statEr)
            cb(statEr);
          else if (st.isDirectory())
            mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
          else if (unlink)
            fs26.unlink(part, (er2) => {
              if (er2)
                return cb(er2);
              fs26.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
            });
          else if (st.isSymbolicLink())
            return cb(new SymlinkError(part, part + "/" + parts.join("/")));
          else
            cb(er);
        });
      } else {
        created = created || part;
        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
      }
    };
    var mkdirSync = module2.exports.sync = (dir, opt) => {
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd = opt.cwd;
      const done = (created2) => {
        cache.set(dir, true);
        if (created2 && doChown)
          chownr.sync(created2, uid, gid);
        if (needChmod)
          fs26.chmodSync(dir, mode);
      };
      if (cache && cache.get(dir) === true)
        return done();
      if (dir === cwd) {
        let ok = false;
        let code = "ENOTDIR";
        try {
          ok = fs26.statSync(dir).isDirectory();
        } catch (er) {
          code = er.code;
        } finally {
          if (!ok)
            throw new CwdError(dir, code);
        }
        done();
        return;
      }
      if (preserve)
        return done(mkdirp.sync(dir, mode));
      const sub = path34.relative(cwd, dir);
      const parts = sub.split(/\/|\\/);
      let created = null;
      for (let p = parts.shift(), part = cwd; p && (part += "/" + p); p = parts.shift()) {
        if (cache.get(part))
          continue;
        try {
          fs26.mkdirSync(part, mode);
          created = created || part;
          cache.set(part, true);
        } catch (er) {
          if (er.path && path34.dirname(er.path) === cwd && (er.code === "ENOTDIR" || er.code === "ENOENT"))
            return new CwdError(cwd, er.code);
          const st = fs26.lstatSync(part);
          if (st.isDirectory()) {
            cache.set(part, true);
            continue;
          } else if (unlink) {
            fs26.unlinkSync(part);
            fs26.mkdirSync(part, mode);
            created = created || part;
            cache.set(part, true);
            continue;
          } else if (st.isSymbolicLink())
            return new SymlinkError(part, part + "/" + parts.join("/"));
        }
      }
      return done(created);
    };
  }
});

// node_modules/tar/lib/path-reservations.js
var require_path_reservations = __commonJS({
  "node_modules/tar/lib/path-reservations.js"(exports2, module2) {
    var assert = require("assert");
    module2.exports = () => {
      const queues = new Map();
      const reservations = new Map();
      const { join: join2 } = require("path");
      const getDirs = (path34) => join2(path34).split(/[\\\/]/).slice(0, -1).reduce((set, path35) => set.length ? set.concat(join2(set[set.length - 1], path35)) : [path35], []);
      const running = new Set();
      const getQueues = (fn) => {
        const res = reservations.get(fn);
        if (!res)
          throw new Error("function does not have any path reservations");
        return {
          paths: res.paths.map((path34) => queues.get(path34)),
          dirs: [...res.dirs].map((path34) => queues.get(path34))
        };
      };
      const check = (fn) => {
        const { paths, dirs } = getQueues(fn);
        return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
      };
      const run = (fn) => {
        if (running.has(fn) || !check(fn))
          return false;
        running.add(fn);
        fn(() => clear(fn));
        return true;
      };
      const clear = (fn) => {
        if (!running.has(fn))
          return false;
        const { paths, dirs } = reservations.get(fn);
        const next = new Set();
        paths.forEach((path34) => {
          const q = queues.get(path34);
          assert.equal(q[0], fn);
          if (q.length === 1)
            queues.delete(path34);
          else {
            q.shift();
            if (typeof q[0] === "function")
              next.add(q[0]);
            else
              q[0].forEach((fn2) => next.add(fn2));
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          assert(q[0] instanceof Set);
          if (q[0].size === 1 && q.length === 1) {
            queues.delete(dir);
          } else if (q[0].size === 1) {
            q.shift();
            next.add(q[0]);
          } else
            q[0].delete(fn);
        });
        running.delete(fn);
        next.forEach((fn2) => run(fn2));
        return true;
      };
      const reserve = (paths, fn) => {
        const dirs = new Set(paths.map((path34) => getDirs(path34)).reduce((a, b) => a.concat(b)));
        reservations.set(fn, { dirs, paths });
        paths.forEach((path34) => {
          const q = queues.get(path34);
          if (!q)
            queues.set(path34, [fn]);
          else
            q.push(fn);
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          if (!q)
            queues.set(dir, [new Set([fn])]);
          else if (q[q.length - 1] instanceof Set)
            q[q.length - 1].add(fn);
          else
            q.push(new Set([fn]));
        });
        return run(fn);
      };
      return { check, reserve };
    };
  }
});

// node_modules/tar/lib/get-write-flag.js
var require_get_write_flag = __commonJS({
  "node_modules/tar/lib/get-write-flag.js"(exports2, module2) {
    var platform3 = process.env.__FAKE_PLATFORM__ || process.platform;
    var isWindows4 = platform3 === "win32";
    var fs26 = global.__FAKE_TESTING_FS__ || require("fs");
    var { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs26.constants;
    var fMapEnabled = isWindows4 && !!UV_FS_O_FILEMAP;
    var fMapLimit = 512 * 1024;
    var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
    module2.exports = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
  }
});

// node_modules/tar/lib/unpack.js
var require_unpack = __commonJS({
  "node_modules/tar/lib/unpack.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var EE = require("events").EventEmitter;
    var Parser = require_parse2();
    var fs26 = require("fs");
    var fsm = require_fs_minipass();
    var path34 = require("path");
    var mkdir = require_mkdir();
    var mkdirSync = mkdir.sync;
    var wc = require_winchars();
    var pathReservations = require_path_reservations();
    var ONENTRY = Symbol("onEntry");
    var CHECKFS = Symbol("checkFs");
    var CHECKFS2 = Symbol("checkFs2");
    var ISREUSABLE = Symbol("isReusable");
    var MAKEFS = Symbol("makeFs");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var LINK = Symbol("link");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var UNSUPPORTED = Symbol("unsupported");
    var UNKNOWN = Symbol("unknown");
    var CHECKPATH = Symbol("checkPath");
    var MKDIR = Symbol("mkdir");
    var ONERROR = Symbol("onError");
    var PENDING = Symbol("pending");
    var PEND = Symbol("pend");
    var UNPEND = Symbol("unpend");
    var ENDED = Symbol("ended");
    var MAYBECLOSE = Symbol("maybeClose");
    var SKIP = Symbol("skip");
    var DOCHOWN = Symbol("doChown");
    var UID = Symbol("uid");
    var GID = Symbol("gid");
    var crypto2 = require("crypto");
    var getFlag = require_get_write_flag();
    var neverCalled = () => {
      throw new Error("sync function called cb somehow?!?");
    };
    var unlinkFile = (path35, cb) => {
      if (process.platform !== "win32")
        return fs26.unlink(path35, cb);
      const name2 = path35 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
      fs26.rename(path35, name2, (er) => {
        if (er)
          return cb(er);
        fs26.unlink(name2, cb);
      });
    };
    var unlinkFileSync = (path35) => {
      if (process.platform !== "win32")
        return fs26.unlinkSync(path35);
      const name2 = path35 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
      fs26.renameSync(path35, name2);
      fs26.unlinkSync(name2);
    };
    var uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
    var Unpack = class extends Parser {
      constructor(opt) {
        if (!opt)
          opt = {};
        opt.ondone = (_) => {
          this[ENDED] = true;
          this[MAYBECLOSE]();
        };
        super(opt);
        this.reservations = pathReservations();
        this.transform = typeof opt.transform === "function" ? opt.transform : null;
        this.writable = true;
        this.readable = false;
        this[PENDING] = 0;
        this[ENDED] = false;
        this.dirCache = opt.dirCache || new Map();
        if (typeof opt.uid === "number" || typeof opt.gid === "number") {
          if (typeof opt.uid !== "number" || typeof opt.gid !== "number")
            throw new TypeError("cannot set owner without number uid and gid");
          if (opt.preserveOwner)
            throw new TypeError("cannot preserve owner in archive and also set owner explicitly");
          this.uid = opt.uid;
          this.gid = opt.gid;
          this.setOwner = true;
        } else {
          this.uid = null;
          this.gid = null;
          this.setOwner = false;
        }
        if (opt.preserveOwner === void 0 && typeof opt.uid !== "number")
          this.preserveOwner = process.getuid && process.getuid() === 0;
        else
          this.preserveOwner = !!opt.preserveOwner;
        this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
        this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
        this.forceChown = opt.forceChown === true;
        this.win32 = !!opt.win32 || process.platform === "win32";
        this.newer = !!opt.newer;
        this.keep = !!opt.keep;
        this.noMtime = !!opt.noMtime;
        this.preservePaths = !!opt.preservePaths;
        this.unlink = !!opt.unlink;
        this.cwd = path34.resolve(opt.cwd || process.cwd());
        this.strip = +opt.strip || 0;
        this.processUmask = process.umask();
        this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
        this.dmode = opt.dmode || 511 & ~this.umask;
        this.fmode = opt.fmode || 438 & ~this.umask;
        this.on("entry", (entry) => this[ONENTRY](entry));
      }
      warn(code, msg, data = {}) {
        if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT")
          data.recoverable = false;
        return super.warn(code, msg, data);
      }
      [MAYBECLOSE]() {
        if (this[ENDED] && this[PENDING] === 0) {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
          this.emit("close");
        }
      }
      [CHECKPATH](entry) {
        if (this.strip) {
          const parts = entry.path.split(/\/|\\/);
          if (parts.length < this.strip)
            return false;
          entry.path = parts.slice(this.strip).join("/");
          if (entry.type === "Link") {
            const linkparts = entry.linkpath.split(/\/|\\/);
            if (linkparts.length >= this.strip)
              entry.linkpath = linkparts.slice(this.strip).join("/");
          }
        }
        if (!this.preservePaths) {
          const p = entry.path;
          if (p.match(/(^|\/|\\)\.\.(\\|\/|$)/)) {
            this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
              entry,
              path: p
            });
            return false;
          }
          if (path34.win32.isAbsolute(p)) {
            const parsed = path34.win32.parse(p);
            entry.path = p.substr(parsed.root.length);
            const r = parsed.root;
            this.warn("TAR_ENTRY_INFO", `stripping ${r} from absolute path`, {
              entry,
              path: p
            });
          }
        }
        if (this.win32) {
          const parsed = path34.win32.parse(entry.path);
          entry.path = parsed.root === "" ? wc.encode(entry.path) : parsed.root + wc.encode(entry.path.substr(parsed.root.length));
        }
        if (path34.isAbsolute(entry.path))
          entry.absolute = entry.path;
        else
          entry.absolute = path34.resolve(this.cwd, entry.path);
        return true;
      }
      [ONENTRY](entry) {
        if (!this[CHECKPATH](entry))
          return entry.resume();
        assert.equal(typeof entry.absolute, "string");
        switch (entry.type) {
          case "Directory":
          case "GNUDumpDir":
            if (entry.mode)
              entry.mode = entry.mode | 448;
          case "File":
          case "OldFile":
          case "ContiguousFile":
          case "Link":
          case "SymbolicLink":
            return this[CHECKFS](entry);
          case "CharacterDevice":
          case "BlockDevice":
          case "FIFO":
            return this[UNSUPPORTED](entry);
        }
      }
      [ONERROR](er, entry) {
        if (er.name === "CwdError")
          this.emit("error", er);
        else {
          this.warn("TAR_ENTRY_ERROR", er, { entry });
          this[UNPEND]();
          entry.resume();
        }
      }
      [MKDIR](dir, mode, cb) {
        mkdir(dir, {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode
        }, cb);
      }
      [DOCHOWN](entry) {
        return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
      }
      [UID](entry) {
        return uint32(this.uid, entry.uid, this.processUid);
      }
      [GID](entry) {
        return uint32(this.gid, entry.gid, this.processGid);
      }
      [FILE](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.fmode;
        const stream = new fsm.WriteStream(entry.absolute, {
          flags: getFlag(entry.size),
          mode,
          autoClose: false
        });
        stream.on("error", (er) => this[ONERROR](er, entry));
        let actions = 1;
        const done = (er) => {
          if (er)
            return this[ONERROR](er, entry);
          if (--actions === 0) {
            fs26.close(stream.fd, (er2) => {
              fullyDone();
              er2 ? this[ONERROR](er2, entry) : this[UNPEND]();
            });
          }
        };
        stream.on("finish", (_) => {
          const abs = entry.absolute;
          const fd = stream.fd;
          if (entry.mtime && !this.noMtime) {
            actions++;
            const atime = entry.atime || new Date();
            const mtime = entry.mtime;
            fs26.futimes(fd, atime, mtime, (er) => er ? fs26.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            fs26.fchown(fd, uid, gid, (er) => er ? fs26.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
          }
          done();
        });
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => this[ONERROR](er, entry));
          entry.pipe(tx);
        }
        tx.pipe(stream);
      }
      [DIRECTORY](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.dmode;
        this[MKDIR](entry.absolute, mode, (er) => {
          if (er) {
            fullyDone();
            return this[ONERROR](er, entry);
          }
          let actions = 1;
          const done = (_) => {
            if (--actions === 0) {
              fullyDone();
              this[UNPEND]();
              entry.resume();
            }
          };
          if (entry.mtime && !this.noMtime) {
            actions++;
            fs26.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            fs26.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
          }
          done();
        });
      }
      [UNSUPPORTED](entry) {
        entry.unsupported = true;
        this.warn("TAR_ENTRY_UNSUPPORTED", `unsupported entry type: ${entry.type}`, { entry });
        entry.resume();
      }
      [SYMLINK](entry, done) {
        this[LINK](entry, entry.linkpath, "symlink", done);
      }
      [HARDLINK](entry, done) {
        this[LINK](entry, path34.resolve(this.cwd, entry.linkpath), "link", done);
      }
      [PEND]() {
        this[PENDING]++;
      }
      [UNPEND]() {
        this[PENDING]--;
        this[MAYBECLOSE]();
      }
      [SKIP](entry) {
        this[UNPEND]();
        entry.resume();
      }
      [ISREUSABLE](entry, st) {
        return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && process.platform !== "win32";
      }
      [CHECKFS](entry) {
        this[PEND]();
        const paths = [entry.path];
        if (entry.linkpath)
          paths.push(entry.linkpath);
        this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
      }
      [CHECKFS2](entry, done) {
        this[MKDIR](path34.dirname(entry.absolute), this.dmode, (er) => {
          if (er) {
            done();
            return this[ONERROR](er, entry);
          }
          fs26.lstat(entry.absolute, (er2, st) => {
            if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
              this[SKIP](entry);
              done();
            } else if (er2 || this[ISREUSABLE](entry, st)) {
              this[MAKEFS](null, entry, done);
            } else if (st.isDirectory()) {
              if (entry.type === "Directory") {
                if (!entry.mode || (st.mode & 4095) === entry.mode)
                  this[MAKEFS](null, entry, done);
                else
                  fs26.chmod(entry.absolute, entry.mode, (er3) => this[MAKEFS](er3, entry, done));
              } else
                fs26.rmdir(entry.absolute, (er3) => this[MAKEFS](er3, entry, done));
            } else
              unlinkFile(entry.absolute, (er3) => this[MAKEFS](er3, entry, done));
          });
        });
      }
      [MAKEFS](er, entry, done) {
        if (er)
          return this[ONERROR](er, entry);
        switch (entry.type) {
          case "File":
          case "OldFile":
          case "ContiguousFile":
            return this[FILE](entry, done);
          case "Link":
            return this[HARDLINK](entry, done);
          case "SymbolicLink":
            return this[SYMLINK](entry, done);
          case "Directory":
          case "GNUDumpDir":
            return this[DIRECTORY](entry, done);
        }
      }
      [LINK](entry, linkpath, link, done) {
        fs26[link](linkpath, entry.absolute, (er) => {
          if (er)
            return this[ONERROR](er, entry);
          done();
          this[UNPEND]();
          entry.resume();
        });
      }
    };
    var UnpackSync = class extends Unpack {
      constructor(opt) {
        super(opt);
      }
      [CHECKFS](entry) {
        const er = this[MKDIR](path34.dirname(entry.absolute), this.dmode, neverCalled);
        if (er)
          return this[ONERROR](er, entry);
        try {
          const st = fs26.lstatSync(entry.absolute);
          if (this.keep || this.newer && st.mtime > entry.mtime)
            return this[SKIP](entry);
          else if (this[ISREUSABLE](entry, st))
            return this[MAKEFS](null, entry, neverCalled);
          else {
            try {
              if (st.isDirectory()) {
                if (entry.type === "Directory") {
                  if (entry.mode && (st.mode & 4095) !== entry.mode)
                    fs26.chmodSync(entry.absolute, entry.mode);
                } else
                  fs26.rmdirSync(entry.absolute);
              } else
                unlinkFileSync(entry.absolute);
              return this[MAKEFS](null, entry, neverCalled);
            } catch (er2) {
              return this[ONERROR](er2, entry);
            }
          }
        } catch (er2) {
          return this[MAKEFS](null, entry, neverCalled);
        }
      }
      [FILE](entry, _) {
        const mode = entry.mode & 4095 || this.fmode;
        const oner = (er) => {
          let closeError;
          try {
            fs26.closeSync(fd);
          } catch (e) {
            closeError = e;
          }
          if (er || closeError)
            this[ONERROR](er || closeError, entry);
        };
        let stream;
        let fd;
        try {
          fd = fs26.openSync(entry.absolute, getFlag(entry.size), mode);
        } catch (er) {
          return oner(er);
        }
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => this[ONERROR](er, entry));
          entry.pipe(tx);
        }
        tx.on("data", (chunk) => {
          try {
            fs26.writeSync(fd, chunk, 0, chunk.length);
          } catch (er) {
            oner(er);
          }
        });
        tx.on("end", (_2) => {
          let er = null;
          if (entry.mtime && !this.noMtime) {
            const atime = entry.atime || new Date();
            const mtime = entry.mtime;
            try {
              fs26.futimesSync(fd, atime, mtime);
            } catch (futimeser) {
              try {
                fs26.utimesSync(entry.absolute, atime, mtime);
              } catch (utimeser) {
                er = futimeser;
              }
            }
          }
          if (this[DOCHOWN](entry)) {
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            try {
              fs26.fchownSync(fd, uid, gid);
            } catch (fchowner) {
              try {
                fs26.chownSync(entry.absolute, uid, gid);
              } catch (chowner) {
                er = er || fchowner;
              }
            }
          }
          oner(er);
        });
      }
      [DIRECTORY](entry, _) {
        const mode = entry.mode & 4095 || this.dmode;
        const er = this[MKDIR](entry.absolute, mode);
        if (er)
          return this[ONERROR](er, entry);
        if (entry.mtime && !this.noMtime) {
          try {
            fs26.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);
          } catch (er2) {
          }
        }
        if (this[DOCHOWN](entry)) {
          try {
            fs26.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
          } catch (er2) {
          }
        }
        entry.resume();
      }
      [MKDIR](dir, mode) {
        try {
          return mkdir.sync(dir, {
            uid: this.uid,
            gid: this.gid,
            processUid: this.processUid,
            processGid: this.processGid,
            umask: this.processUmask,
            preserve: this.preservePaths,
            unlink: this.unlink,
            cache: this.dirCache,
            cwd: this.cwd,
            mode
          });
        } catch (er) {
          return er;
        }
      }
      [LINK](entry, linkpath, link, _) {
        try {
          fs26[link + "Sync"](linkpath, entry.absolute);
          entry.resume();
        } catch (er) {
          return this[ONERROR](er, entry);
        }
      }
    };
    Unpack.Sync = UnpackSync;
    module2.exports = Unpack;
  }
});

// node_modules/tar/lib/extract.js
var require_extract = __commonJS({
  "node_modules/tar/lib/extract.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Unpack = require_unpack();
    var fs26 = require("fs");
    var fsm = require_fs_minipass();
    var path34 = require("path");
    var x = module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function")
        cb = opt_, files = null, opt_ = {};
      else if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (typeof files === "function")
        cb = files, files = null;
      if (!files)
        files = [];
      else
        files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      if (files.length)
        filesFilter(opt, files);
      return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [f.replace(/\/+$/, ""), true]));
      const filter = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path34.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path34.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\/+$/, "")) : (file) => mapHas(file.replace(/\/+$/, ""));
    };
    var extractFileSync = (opt) => {
      const u = new Unpack.Sync(opt);
      const file = opt.file;
      let threw = true;
      let fd;
      const stat = fs26.statSync(file);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const stream = new fsm.ReadStreamSync(file, {
        readSize,
        size: stat.size
      });
      stream.pipe(u);
    };
    var extractFile = (opt, cb) => {
      const u = new Unpack(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve3, reject) => {
        u.on("error", reject);
        u.on("close", resolve3);
        fs26.stat(file, (er, stat) => {
          if (er)
            reject(er);
          else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(u);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var extractSync = (opt) => {
      return new Unpack.Sync(opt);
    };
    var extract = (opt) => {
      return new Unpack(opt);
    };
  }
});

// node_modules/tar/index.js
var require_tar = __commonJS({
  "node_modules/tar/index.js"(exports2) {
    "use strict";
    exports2.c = exports2.create = require_create();
    exports2.r = exports2.replace = require_replace();
    exports2.t = exports2.list = require_list();
    exports2.u = exports2.update = require_update();
    exports2.x = exports2.extract = require_extract();
    exports2.Pack = require_pack();
    exports2.Unpack = require_unpack();
    exports2.Parse = require_parse2();
    exports2.ReadEntry = require_read_entry();
    exports2.WriteEntry = require_write_entry();
    exports2.Header = require_header();
    exports2.Pax = require_pax();
    exports2.types = require_types2();
  }
});

// node_modules/traverse/index.js
var require_traverse = __commonJS({
  "node_modules/traverse/index.js"(exports2, module2) {
    module2.exports = Traverse;
    function Traverse(obj) {
      if (!(this instanceof Traverse))
        return new Traverse(obj);
      this.value = obj;
    }
    Traverse.prototype.get = function(ps) {
      var node = this.value;
      for (var i = 0; i < ps.length; i++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) {
          node = void 0;
          break;
        }
        node = node[key];
      }
      return node;
    };
    Traverse.prototype.set = function(ps, value) {
      var node = this.value;
      for (var i = 0; i < ps.length - 1; i++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key))
          node[key] = {};
        node = node[key];
      }
      node[ps[i]] = value;
      return value;
    };
    Traverse.prototype.map = function(cb) {
      return walk2(this.value, cb, true);
    };
    Traverse.prototype.forEach = function(cb) {
      this.value = walk2(this.value, cb, false);
      return this.value;
    };
    Traverse.prototype.reduce = function(cb, init) {
      var skip = arguments.length === 1;
      var acc = skip ? this.value : init;
      this.forEach(function(x) {
        if (!this.isRoot || !skip) {
          acc = cb.call(this, acc, x);
        }
      });
      return acc;
    };
    Traverse.prototype.deepEqual = function(obj) {
      if (arguments.length !== 1) {
        throw new Error("deepEqual requires exactly one object to compare against");
      }
      var equal = true;
      var node = obj;
      this.forEach(function(y) {
        var notEqual = function() {
          equal = false;
          return void 0;
        }.bind(this);
        if (!this.isRoot) {
          if (typeof node !== "object")
            return notEqual();
          node = node[this.key];
        }
        var x = node;
        this.post(function() {
          node = x;
        });
        var toS = function(o) {
          return Object.prototype.toString.call(o);
        };
        if (this.circular) {
          if (Traverse(obj).get(this.circular.path) !== x)
            notEqual();
        } else if (typeof x !== typeof y) {
          notEqual();
        } else if (x === null || y === null || x === void 0 || y === void 0) {
          if (x !== y)
            notEqual();
        } else if (x.__proto__ !== y.__proto__) {
          notEqual();
        } else if (x === y) {
        } else if (typeof x === "function") {
          if (x instanceof RegExp) {
            if (x.toString() != y.toString())
              notEqual();
          } else if (x !== y)
            notEqual();
        } else if (typeof x === "object") {
          if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
            if (toS(x) !== toS(y)) {
              notEqual();
            }
          } else if (x instanceof Date || y instanceof Date) {
            if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) {
              notEqual();
            }
          } else {
            var kx = Object.keys(x);
            var ky = Object.keys(y);
            if (kx.length !== ky.length)
              return notEqual();
            for (var i = 0; i < kx.length; i++) {
              var k = kx[i];
              if (!Object.hasOwnProperty.call(y, k)) {
                notEqual();
              }
            }
          }
        }
      });
      return equal;
    };
    Traverse.prototype.paths = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.path);
      });
      return acc;
    };
    Traverse.prototype.nodes = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.node);
      });
      return acc;
    };
    Traverse.prototype.clone = function() {
      var parents = [], nodes = [];
      return function clone(src) {
        for (var i = 0; i < parents.length; i++) {
          if (parents[i] === src) {
            return nodes[i];
          }
        }
        if (typeof src === "object" && src !== null) {
          var dst = copy(src);
          parents.push(src);
          nodes.push(dst);
          Object.keys(src).forEach(function(key) {
            dst[key] = clone(src[key]);
          });
          parents.pop();
          nodes.pop();
          return dst;
        } else {
          return src;
        }
      }(this.value);
    };
    function walk2(root, cb, immutable) {
      var path34 = [];
      var parents = [];
      var alive = true;
      return function walker(node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        var state = {
          node,
          node_,
          path: [].concat(path34),
          parent: parents.slice(-1)[0],
          key: path34.slice(-1)[0],
          isRoot: path34.length === 0,
          level: path34.length,
          circular: null,
          update: function(x) {
            if (!state.isRoot) {
              state.parent.node[state.key] = x;
            }
            state.node = x;
          },
          "delete": function() {
            delete state.parent.node[state.key];
          },
          remove: function() {
            if (Array.isArray(state.parent.node)) {
              state.parent.node.splice(state.key, 1);
            } else {
              delete state.parent.node[state.key];
            }
          },
          before: function(f) {
            modifiers.before = f;
          },
          after: function(f) {
            modifiers.after = f;
          },
          pre: function(f) {
            modifiers.pre = f;
          },
          post: function(f) {
            modifiers.post = f;
          },
          stop: function() {
            alive = false;
          }
        };
        if (!alive)
          return state;
        if (typeof node === "object" && node !== null) {
          state.isLeaf = Object.keys(node).length == 0;
          for (var i = 0; i < parents.length; i++) {
            if (parents[i].node_ === node_) {
              state.circular = parents[i];
              break;
            }
          }
        } else {
          state.isLeaf = true;
        }
        state.notLeaf = !state.isLeaf;
        state.notRoot = !state.isRoot;
        var ret = cb.call(state, state.node);
        if (ret !== void 0 && state.update)
          state.update(ret);
        if (modifiers.before)
          modifiers.before.call(state, state.node);
        if (typeof state.node == "object" && state.node !== null && !state.circular) {
          parents.push(state);
          var keys = Object.keys(state.node);
          keys.forEach(function(key, i2) {
            path34.push(key);
            if (modifiers.pre)
              modifiers.pre.call(state, state.node[key], key);
            var child = walker(state.node[key]);
            if (immutable && Object.hasOwnProperty.call(state.node, key)) {
              state.node[key] = child.node;
            }
            child.isLast = i2 == keys.length - 1;
            child.isFirst = i2 == 0;
            if (modifiers.post)
              modifiers.post.call(state, child);
            path34.pop();
          });
          parents.pop();
        }
        if (modifiers.after)
          modifiers.after.call(state, state.node);
        return state;
      }(root).node;
    }
    Object.keys(Traverse.prototype).forEach(function(key) {
      Traverse[key] = function(obj) {
        var args = [].slice.call(arguments, 1);
        var t = Traverse(obj);
        return t[key].apply(t, args);
      };
    });
    function copy(src) {
      if (typeof src === "object" && src !== null) {
        var dst;
        if (Array.isArray(src)) {
          dst = [];
        } else if (src instanceof Date) {
          dst = new Date(src);
        } else if (src instanceof Boolean) {
          dst = new Boolean(src);
        } else if (src instanceof Number) {
          dst = new Number(src);
        } else if (src instanceof String) {
          dst = new String(src);
        } else {
          dst = Object.create(Object.getPrototypeOf(src));
        }
        Object.keys(src).forEach(function(key) {
          dst[key] = src[key];
        });
        return dst;
      } else
        return src;
    }
  }
});

// node_modules/chainsaw/index.js
var require_chainsaw = __commonJS({
  "node_modules/chainsaw/index.js"(exports2, module2) {
    var Traverse = require_traverse();
    var EventEmitter8 = require("events").EventEmitter;
    module2.exports = Chainsaw;
    function Chainsaw(builder) {
      var saw = Chainsaw.saw(builder, {});
      var r = builder.call(saw.handlers, saw);
      if (r !== void 0)
        saw.handlers = r;
      saw.record();
      return saw.chain();
    }
    Chainsaw.light = function ChainsawLight(builder) {
      var saw = Chainsaw.saw(builder, {});
      var r = builder.call(saw.handlers, saw);
      if (r !== void 0)
        saw.handlers = r;
      return saw.chain();
    };
    Chainsaw.saw = function(builder, handlers) {
      var saw = new EventEmitter8();
      saw.handlers = handlers;
      saw.actions = [];
      saw.chain = function() {
        var ch = Traverse(saw.handlers).map(function(node) {
          if (this.isRoot)
            return node;
          var ps = this.path;
          if (typeof node === "function") {
            this.update(function() {
              saw.actions.push({
                path: ps,
                args: [].slice.call(arguments)
              });
              return ch;
            });
          }
        });
        process.nextTick(function() {
          saw.emit("begin");
          saw.next();
        });
        return ch;
      };
      saw.pop = function() {
        return saw.actions.shift();
      };
      saw.next = function() {
        var action = saw.pop();
        if (!action) {
          saw.emit("end");
        } else if (!action.trap) {
          var node = saw.handlers;
          action.path.forEach(function(key) {
            node = node[key];
          });
          node.apply(saw.handlers, action.args);
        }
      };
      saw.nest = function(cb) {
        var args = [].slice.call(arguments, 1);
        var autonext = true;
        if (typeof cb === "boolean") {
          var autonext = cb;
          cb = args.shift();
        }
        var s = Chainsaw.saw(builder, {});
        var r = builder.call(s.handlers, s);
        if (r !== void 0)
          s.handlers = r;
        if (typeof saw.step !== "undefined") {
          s.record();
        }
        cb.apply(s.chain(), args);
        if (autonext !== false)
          s.on("end", saw.next);
      };
      saw.record = function() {
        upgradeChainsaw(saw);
      };
      ["trap", "down", "jump"].forEach(function(method) {
        saw[method] = function() {
          throw new Error("To use the trap, down and jump features, please call record() first to start recording actions.");
        };
      });
      return saw;
    };
    function upgradeChainsaw(saw) {
      saw.step = 0;
      saw.pop = function() {
        return saw.actions[saw.step++];
      };
      saw.trap = function(name2, cb) {
        var ps = Array.isArray(name2) ? name2 : [name2];
        saw.actions.push({
          path: ps,
          step: saw.step,
          cb,
          trap: true
        });
      };
      saw.down = function(name2) {
        var ps = (Array.isArray(name2) ? name2 : [name2]).join("/");
        var i = saw.actions.slice(saw.step).map(function(x) {
          if (x.trap && x.step <= saw.step)
            return false;
          return x.path.join("/") == ps;
        }).indexOf(true);
        if (i >= 0)
          saw.step += i;
        else
          saw.step = saw.actions.length;
        var act = saw.actions[saw.step - 1];
        if (act && act.trap) {
          saw.step = act.step;
          act.cb();
        } else
          saw.next();
      };
      saw.jump = function(step) {
        saw.step = step;
        saw.next();
      };
    }
  }
});

// node_modules/buffers/index.js
var require_buffers = __commonJS({
  "node_modules/buffers/index.js"(exports2, module2) {
    module2.exports = Buffers;
    function Buffers(bufs) {
      if (!(this instanceof Buffers))
        return new Buffers(bufs);
      this.buffers = bufs || [];
      this.length = this.buffers.reduce(function(size, buf) {
        return size + buf.length;
      }, 0);
    }
    Buffers.prototype.push = function() {
      for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
          throw new TypeError("Tried to push a non-buffer");
        }
      }
      for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.push(buf);
        this.length += buf.length;
      }
      return this.length;
    };
    Buffers.prototype.unshift = function() {
      for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
          throw new TypeError("Tried to unshift a non-buffer");
        }
      }
      for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.unshift(buf);
        this.length += buf.length;
      }
      return this.length;
    };
    Buffers.prototype.copy = function(dst, dStart, start, end) {
      return this.slice(start, end).copy(dst, dStart, 0, end - start);
    };
    Buffers.prototype.splice = function(i, howMany) {
      var buffers = this.buffers;
      var index = i >= 0 ? i : this.length - i;
      var reps = [].slice.call(arguments, 2);
      if (howMany === void 0) {
        howMany = this.length - index;
      } else if (howMany > this.length - index) {
        howMany = this.length - index;
      }
      for (var i = 0; i < reps.length; i++) {
        this.length += reps[i].length;
      }
      var removed = new Buffers();
      var bytes2 = 0;
      var startBytes = 0;
      for (var ii = 0; ii < buffers.length && startBytes + buffers[ii].length < index; ii++) {
        startBytes += buffers[ii].length;
      }
      if (index - startBytes > 0) {
        var start = index - startBytes;
        if (start + howMany < buffers[ii].length) {
          removed.push(buffers[ii].slice(start, start + howMany));
          var orig = buffers[ii];
          var buf0 = new Buffer(start);
          for (var i = 0; i < start; i++) {
            buf0[i] = orig[i];
          }
          var buf1 = new Buffer(orig.length - start - howMany);
          for (var i = start + howMany; i < orig.length; i++) {
            buf1[i - howMany - start] = orig[i];
          }
          if (reps.length > 0) {
            var reps_ = reps.slice();
            reps_.unshift(buf0);
            reps_.push(buf1);
            buffers.splice.apply(buffers, [ii, 1].concat(reps_));
            ii += reps_.length;
            reps = [];
          } else {
            buffers.splice(ii, 1, buf0, buf1);
            ii += 2;
          }
        } else {
          removed.push(buffers[ii].slice(start));
          buffers[ii] = buffers[ii].slice(0, start);
          ii++;
        }
      }
      if (reps.length > 0) {
        buffers.splice.apply(buffers, [ii, 0].concat(reps));
        ii += reps.length;
      }
      while (removed.length < howMany) {
        var buf = buffers[ii];
        var len = buf.length;
        var take = Math.min(len, howMany - removed.length);
        if (take === len) {
          removed.push(buf);
          buffers.splice(ii, 1);
        } else {
          removed.push(buf.slice(0, take));
          buffers[ii] = buffers[ii].slice(take);
        }
      }
      this.length -= removed.length;
      return removed;
    };
    Buffers.prototype.slice = function(i, j) {
      var buffers = this.buffers;
      if (j === void 0)
        j = this.length;
      if (i === void 0)
        i = 0;
      if (j > this.length)
        j = this.length;
      var startBytes = 0;
      for (var si = 0; si < buffers.length && startBytes + buffers[si].length <= i; si++) {
        startBytes += buffers[si].length;
      }
      var target = new Buffer(j - i);
      var ti = 0;
      for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
        var len = buffers[ii].length;
        var start = ti === 0 ? i - startBytes : 0;
        var end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
        buffers[ii].copy(target, ti, start, end);
        ti += end - start;
      }
      return target;
    };
    Buffers.prototype.pos = function(i) {
      if (i < 0 || i >= this.length)
        throw new Error("oob");
      var l = i, bi = 0, bu = null;
      for (; ; ) {
        bu = this.buffers[bi];
        if (l < bu.length) {
          return { buf: bi, offset: l };
        } else {
          l -= bu.length;
        }
        bi++;
      }
    };
    Buffers.prototype.get = function get(i) {
      var pos = this.pos(i);
      return this.buffers[pos.buf].get(pos.offset);
    };
    Buffers.prototype.set = function set(i, b) {
      var pos = this.pos(i);
      return this.buffers[pos.buf].set(pos.offset, b);
    };
    Buffers.prototype.indexOf = function(needle, offset) {
      if (typeof needle === "string") {
        needle = new Buffer(needle);
      } else if (needle instanceof Buffer) {
      } else {
        throw new Error("Invalid type for a search string");
      }
      if (!needle.length) {
        return 0;
      }
      if (!this.length) {
        return -1;
      }
      var i = 0, j = 0, match = 0, mstart, pos = 0;
      if (offset) {
        var p = this.pos(offset);
        i = p.buf;
        j = p.offset;
        pos = offset;
      }
      for (; ; ) {
        while (j >= this.buffers[i].length) {
          j = 0;
          i++;
          if (i >= this.buffers.length) {
            return -1;
          }
        }
        var char = this.buffers[i][j];
        if (char == needle[match]) {
          if (match == 0) {
            mstart = {
              i,
              j,
              pos
            };
          }
          match++;
          if (match == needle.length) {
            return mstart.pos;
          }
        } else if (match != 0) {
          i = mstart.i;
          j = mstart.j;
          pos = mstart.pos;
          match = 0;
        }
        j++;
        pos++;
      }
    };
    Buffers.prototype.toBuffer = function() {
      return this.slice();
    };
    Buffers.prototype.toString = function(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
  }
});

// node_modules/binary/lib/vars.js
var require_vars = __commonJS({
  "node_modules/binary/lib/vars.js"(exports2, module2) {
    module2.exports = function(store) {
      function getset(name2, value) {
        var node = vars.store;
        var keys = name2.split(".");
        keys.slice(0, -1).forEach(function(k) {
          if (node[k] === void 0)
            node[k] = {};
          node = node[k];
        });
        var key = keys[keys.length - 1];
        if (arguments.length == 1) {
          return node[key];
        } else {
          return node[key] = value;
        }
      }
      var vars = {
        get: function(name2) {
          return getset(name2);
        },
        set: function(name2, value) {
          return getset(name2, value);
        },
        store: store || {}
      };
      return vars;
    };
  }
});

// node_modules/binary/index.js
var require_binary = __commonJS({
  "node_modules/binary/index.js"(exports2, module2) {
    var Chainsaw = require_chainsaw();
    var EventEmitter8 = require("events").EventEmitter;
    var Buffers = require_buffers();
    var Vars = require_vars();
    var Stream = require("stream").Stream;
    exports2 = module2.exports = function(bufOrEm, eventName) {
      if (Buffer.isBuffer(bufOrEm)) {
        return exports2.parse(bufOrEm);
      }
      var s = exports2.stream();
      if (bufOrEm && bufOrEm.pipe) {
        bufOrEm.pipe(s);
      } else if (bufOrEm) {
        bufOrEm.on(eventName || "data", function(buf) {
          s.write(buf);
        });
        bufOrEm.on("end", function() {
          s.end();
        });
      }
      return s;
    };
    exports2.stream = function(input) {
      if (input)
        return exports2.apply(null, arguments);
      var pending = null;
      function getBytes(bytes2, cb, skip) {
        pending = {
          bytes: bytes2,
          skip,
          cb: function(buf) {
            pending = null;
            cb(buf);
          }
        };
        dispatch();
      }
      var offset = null;
      function dispatch() {
        if (!pending) {
          if (caughtEnd)
            done = true;
          return;
        }
        if (typeof pending === "function") {
          pending();
        } else {
          var bytes2 = offset + pending.bytes;
          if (buffers.length >= bytes2) {
            var buf;
            if (offset == null) {
              buf = buffers.splice(0, bytes2);
              if (!pending.skip) {
                buf = buf.slice();
              }
            } else {
              if (!pending.skip) {
                buf = buffers.slice(offset, bytes2);
              }
              offset = bytes2;
            }
            if (pending.skip) {
              pending.cb();
            } else {
              pending.cb(buf);
            }
          }
        }
      }
      function builder(saw) {
        function next() {
          if (!done)
            saw.next();
        }
        var self2 = words(function(bytes2, cb) {
          return function(name2) {
            getBytes(bytes2, function(buf) {
              vars.set(name2, cb(buf));
              next();
            });
          };
        });
        self2.tap = function(cb) {
          saw.nest(cb, vars.store);
        };
        self2.into = function(key, cb) {
          if (!vars.get(key))
            vars.set(key, {});
          var parent = vars;
          vars = Vars(parent.get(key));
          saw.nest(function() {
            cb.apply(this, arguments);
            this.tap(function() {
              vars = parent;
            });
          }, vars.store);
        };
        self2.flush = function() {
          vars.store = {};
          next();
        };
        self2.loop = function(cb) {
          var end = false;
          saw.nest(false, function loop() {
            this.vars = vars.store;
            cb.call(this, function() {
              end = true;
              next();
            }, vars.store);
            this.tap(function() {
              if (end)
                saw.next();
              else
                loop.call(this);
            }.bind(this));
          }, vars.store);
        };
        self2.buffer = function(name2, bytes2) {
          if (typeof bytes2 === "string") {
            bytes2 = vars.get(bytes2);
          }
          getBytes(bytes2, function(buf) {
            vars.set(name2, buf);
            next();
          });
        };
        self2.skip = function(bytes2) {
          if (typeof bytes2 === "string") {
            bytes2 = vars.get(bytes2);
          }
          getBytes(bytes2, function() {
            next();
          });
        };
        self2.scan = function find(name2, search) {
          if (typeof search === "string") {
            search = new Buffer(search);
          } else if (!Buffer.isBuffer(search)) {
            throw new Error("search must be a Buffer or a string");
          }
          var taken = 0;
          pending = function() {
            var pos = buffers.indexOf(search, offset + taken);
            var i = pos - offset - taken;
            if (pos !== -1) {
              pending = null;
              if (offset != null) {
                vars.set(name2, buffers.slice(offset, offset + taken + i));
                offset += taken + i + search.length;
              } else {
                vars.set(name2, buffers.slice(0, taken + i));
                buffers.splice(0, taken + i + search.length);
              }
              next();
              dispatch();
            } else {
              i = Math.max(buffers.length - search.length - offset - taken, 0);
            }
            taken += i;
          };
          dispatch();
        };
        self2.peek = function(cb) {
          offset = 0;
          saw.nest(function() {
            cb.call(this, vars.store);
            this.tap(function() {
              offset = null;
            });
          });
        };
        return self2;
      }
      ;
      var stream = Chainsaw.light(builder);
      stream.writable = true;
      var buffers = Buffers();
      stream.write = function(buf) {
        buffers.push(buf);
        dispatch();
      };
      var vars = Vars();
      var done = false, caughtEnd = false;
      stream.end = function() {
        caughtEnd = true;
      };
      stream.pipe = Stream.prototype.pipe;
      Object.getOwnPropertyNames(EventEmitter8.prototype).forEach(function(name2) {
        stream[name2] = EventEmitter8.prototype[name2];
      });
      return stream;
    };
    exports2.parse = function parse5(buffer) {
      var self2 = words(function(bytes2, cb) {
        return function(name2) {
          if (offset + bytes2 <= buffer.length) {
            var buf = buffer.slice(offset, offset + bytes2);
            offset += bytes2;
            vars.set(name2, cb(buf));
          } else {
            vars.set(name2, null);
          }
          return self2;
        };
      });
      var offset = 0;
      var vars = Vars();
      self2.vars = vars.store;
      self2.tap = function(cb) {
        cb.call(self2, vars.store);
        return self2;
      };
      self2.into = function(key, cb) {
        if (!vars.get(key)) {
          vars.set(key, {});
        }
        var parent = vars;
        vars = Vars(parent.get(key));
        cb.call(self2, vars.store);
        vars = parent;
        return self2;
      };
      self2.loop = function(cb) {
        var end = false;
        var ender = function() {
          end = true;
        };
        while (end === false) {
          cb.call(self2, ender, vars.store);
        }
        return self2;
      };
      self2.buffer = function(name2, size) {
        if (typeof size === "string") {
          size = vars.get(size);
        }
        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
        offset += size;
        vars.set(name2, buf);
        return self2;
      };
      self2.skip = function(bytes2) {
        if (typeof bytes2 === "string") {
          bytes2 = vars.get(bytes2);
        }
        offset += bytes2;
        return self2;
      };
      self2.scan = function(name2, search) {
        if (typeof search === "string") {
          search = new Buffer(search);
        } else if (!Buffer.isBuffer(search)) {
          throw new Error("search must be a Buffer or a string");
        }
        vars.set(name2, null);
        for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {
          for (var j = 0; j < search.length && buffer[offset + i + j] === search[j]; j++)
            ;
          if (j === search.length)
            break;
        }
        vars.set(name2, buffer.slice(offset, offset + i));
        offset += i + search.length;
        return self2;
      };
      self2.peek = function(cb) {
        var was = offset;
        cb.call(self2, vars.store);
        offset = was;
        return self2;
      };
      self2.flush = function() {
        vars.store = {};
        return self2;
      };
      self2.eof = function() {
        return offset >= buffer.length;
      };
      return self2;
    };
    function decodeLEu(bytes2) {
      var acc = 0;
      for (var i = 0; i < bytes2.length; i++) {
        acc += Math.pow(256, i) * bytes2[i];
      }
      return acc;
    }
    function decodeBEu(bytes2) {
      var acc = 0;
      for (var i = 0; i < bytes2.length; i++) {
        acc += Math.pow(256, bytes2.length - i - 1) * bytes2[i];
      }
      return acc;
    }
    function decodeBEs(bytes2) {
      var val = decodeBEu(bytes2);
      if ((bytes2[0] & 128) == 128) {
        val -= Math.pow(256, bytes2.length);
      }
      return val;
    }
    function decodeLEs(bytes2) {
      var val = decodeLEu(bytes2);
      if ((bytes2[bytes2.length - 1] & 128) == 128) {
        val -= Math.pow(256, bytes2.length);
      }
      return val;
    }
    function words(decode) {
      var self2 = {};
      [1, 2, 4, 8].forEach(function(bytes2) {
        var bits = bytes2 * 8;
        self2["word" + bits + "le"] = self2["word" + bits + "lu"] = decode(bytes2, decodeLEu);
        self2["word" + bits + "ls"] = decode(bytes2, decodeLEs);
        self2["word" + bits + "be"] = self2["word" + bits + "bu"] = decode(bytes2, decodeBEu);
        self2["word" + bits + "bs"] = decode(bytes2, decodeBEs);
      });
      self2.word8 = self2.word8u = self2.word8be;
      self2.word8s = self2.word8bs;
      return self2;
    }
  }
});

// node_modules/unzip-stream/lib/matcher-stream.js
var require_matcher_stream = __commonJS({
  "node_modules/unzip-stream/lib/matcher-stream.js"(exports2, module2) {
    var Transform2 = require("stream").Transform;
    var util4 = require("util");
    function MatcherStream(patternDesc, matchFn) {
      if (!(this instanceof MatcherStream)) {
        return new MatcherStream();
      }
      Transform2.call(this);
      var p = typeof patternDesc === "object" ? patternDesc.pattern : patternDesc;
      this.pattern = Buffer.isBuffer(p) ? p : Buffer.from(p);
      this.requiredLength = this.pattern.length;
      if (patternDesc.requiredExtraSize)
        this.requiredLength += patternDesc.requiredExtraSize;
      this.data = new Buffer("");
      this.bytesSoFar = 0;
      this.matchFn = matchFn;
    }
    util4.inherits(MatcherStream, Transform2);
    MatcherStream.prototype.checkDataChunk = function(ignoreMatchZero) {
      var enoughData = this.data.length >= this.requiredLength;
      if (!enoughData) {
        return;
      }
      var matchIndex = this.data.indexOf(this.pattern, ignoreMatchZero ? 1 : 0);
      if (matchIndex >= 0 && matchIndex + this.requiredLength > this.data.length) {
        if (matchIndex > 0) {
          var packet = this.data.slice(0, matchIndex);
          this.push(packet);
          this.bytesSoFar += matchIndex;
          this.data = this.data.slice(matchIndex);
        }
        return;
      }
      if (matchIndex === -1) {
        var packetLen = this.data.length - this.requiredLength + 1;
        var packet = this.data.slice(0, packetLen);
        this.push(packet);
        this.bytesSoFar += packetLen;
        this.data = this.data.slice(packetLen);
        return;
      }
      if (matchIndex > 0) {
        var packet = this.data.slice(0, matchIndex);
        this.data = this.data.slice(matchIndex);
        this.push(packet);
        this.bytesSoFar += matchIndex;
      }
      var finished = this.matchFn ? this.matchFn(this.data, this.bytesSoFar) : true;
      if (finished) {
        this.data = new Buffer("");
        return;
      }
      return true;
    };
    MatcherStream.prototype._transform = function(chunk, encoding, cb) {
      this.data = Buffer.concat([this.data, chunk]);
      var firstIteration = true;
      while (this.checkDataChunk(!firstIteration)) {
        firstIteration = false;
      }
      cb();
    };
    MatcherStream.prototype._flush = function(cb) {
      if (this.data.length > 0) {
        var firstIteration = true;
        while (this.checkDataChunk(!firstIteration)) {
          firstIteration = false;
        }
      }
      if (this.data.length > 0) {
        this.push(this.data);
        this.data = null;
      }
      cb();
    };
    module2.exports = MatcherStream;
  }
});

// node_modules/unzip-stream/lib/entry.js
var require_entry = __commonJS({
  "node_modules/unzip-stream/lib/entry.js"(exports2, module2) {
    "use strict";
    var stream = require("stream");
    var inherits = require("util").inherits;
    function Entry() {
      if (!(this instanceof Entry)) {
        return new Entry();
      }
      stream.PassThrough.call(this);
      this.path = null;
      this.type = null;
      this.isDirectory = false;
    }
    inherits(Entry, stream.PassThrough);
    Entry.prototype.autodrain = function() {
      return this.pipe(new stream.Transform({ transform: function(d, e, cb) {
        cb();
      } }));
    };
    module2.exports = Entry;
  }
});

// node_modules/unzip-stream/lib/unzip-stream.js
var require_unzip_stream = __commonJS({
  "node_modules/unzip-stream/lib/unzip-stream.js"(exports2, module2) {
    "use strict";
    var binary = require_binary();
    var stream = require("stream");
    var util4 = require("util");
    var zlib = require("zlib");
    var MatcherStream = require_matcher_stream();
    var Entry = require_entry();
    var states = {
      STREAM_START: 0,
      START: 1,
      LOCAL_FILE_HEADER: 2,
      LOCAL_FILE_HEADER_SUFFIX: 3,
      FILE_DATA: 4,
      FILE_DATA_END: 5,
      DATA_DESCRIPTOR: 6,
      CENTRAL_DIRECTORY_FILE_HEADER: 7,
      CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX: 8,
      CDIR64_END: 9,
      CDIR64_END_DATA_SECTOR: 10,
      CDIR64_LOCATOR: 11,
      CENTRAL_DIRECTORY_END: 12,
      CENTRAL_DIRECTORY_END_COMMENT: 13,
      TRAILING_JUNK: 14,
      ERROR: 99
    };
    var FOUR_GIGS = 4294967296;
    var SIG_LOCAL_FILE_HEADER = 67324752;
    var SIG_DATA_DESCRIPTOR = 134695760;
    var SIG_CDIR_RECORD = 33639248;
    var SIG_CDIR64_RECORD_END = 101075792;
    var SIG_CDIR64_LOCATOR_END = 117853008;
    var SIG_CDIR_RECORD_END = 101010256;
    function UnzipStream(options) {
      if (!(this instanceof UnzipStream)) {
        return new UnzipStream(options);
      }
      stream.Transform.call(this);
      this.options = options || {};
      this.data = new Buffer("");
      this.state = states.STREAM_START;
      this.skippedBytes = 0;
      this.parsedEntity = null;
      this.outStreamInfo = {};
    }
    util4.inherits(UnzipStream, stream.Transform);
    UnzipStream.prototype.processDataChunk = function(chunk) {
      var requiredLength;
      switch (this.state) {
        case states.STREAM_START:
        case states.START:
          requiredLength = 4;
          break;
        case states.LOCAL_FILE_HEADER:
          requiredLength = 26;
          break;
        case states.LOCAL_FILE_HEADER_SUFFIX:
          requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength;
          break;
        case states.DATA_DESCRIPTOR:
          requiredLength = 12;
          break;
        case states.CENTRAL_DIRECTORY_FILE_HEADER:
          requiredLength = 42;
          break;
        case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
          requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength + this.parsedEntity.fileCommentLength;
          break;
        case states.CDIR64_END:
          requiredLength = 52;
          break;
        case states.CDIR64_END_DATA_SECTOR:
          requiredLength = this.parsedEntity.centralDirectoryRecordSize - 44;
          break;
        case states.CDIR64_LOCATOR:
          requiredLength = 16;
          break;
        case states.CENTRAL_DIRECTORY_END:
          requiredLength = 18;
          break;
        case states.CENTRAL_DIRECTORY_END_COMMENT:
          requiredLength = this.parsedEntity.commentLength;
          break;
        case states.FILE_DATA:
          return 0;
        case states.FILE_DATA_END:
          return 0;
        case states.TRAILING_JUNK:
          if (this.options.debug)
            console.log("found", chunk.length, "bytes of TRAILING_JUNK");
          return chunk.length;
        default:
          return chunk.length;
      }
      var chunkLength = chunk.length;
      if (chunkLength < requiredLength) {
        return 0;
      }
      switch (this.state) {
        case states.STREAM_START:
        case states.START:
          var signature = chunk.readUInt32LE(0);
          switch (signature) {
            case SIG_LOCAL_FILE_HEADER:
              this.state = states.LOCAL_FILE_HEADER;
              break;
            case SIG_CDIR_RECORD:
              this.state = states.CENTRAL_DIRECTORY_FILE_HEADER;
              break;
            case SIG_CDIR64_RECORD_END:
              this.state = states.CDIR64_END;
              break;
            case SIG_CDIR64_LOCATOR_END:
              this.state = states.CDIR64_LOCATOR;
              break;
            case SIG_CDIR_RECORD_END:
              this.state = states.CENTRAL_DIRECTORY_END;
              break;
            default:
              var isStreamStart = this.state === states.STREAM_START;
              if (!isStreamStart && (signature & 65535) !== 19280 && this.skippedBytes < 26) {
                var remaining = signature;
                var toSkip = 4;
                for (var i = 1; i < 4 && remaining !== 0; i++) {
                  remaining = remaining >>> 8;
                  if ((remaining & 255) === 80) {
                    toSkip = i;
                    break;
                  }
                }
                this.skippedBytes += toSkip;
                if (this.options.debug)
                  console.log("Skipped", this.skippedBytes, "bytes");
                return toSkip;
              }
              this.state = states.ERROR;
              var errMsg = isStreamStart ? "Not a valid zip file" : "Invalid signature in zip file";
              if (this.options.debug) {
                var sig = chunk.readUInt32LE(0);
                var asString;
                try {
                  asString = chunk.slice(0, 4).toString();
                } catch (e) {
                }
                console.log("Unexpected signature in zip file: 0x" + sig.toString(16), '"' + asString + '", skipped', this.skippedBytes, "bytes");
              }
              this.emit("error", new Error(errMsg));
              return chunk.length;
          }
          this.skippedBytes = 0;
          return requiredLength;
        case states.LOCAL_FILE_HEADER:
          this.parsedEntity = this._readFile(chunk);
          this.state = states.LOCAL_FILE_HEADER_SUFFIX;
          return requiredLength;
        case states.LOCAL_FILE_HEADER_SUFFIX:
          var entry = new Entry();
          var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
          entry.path = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
          var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
          var extra = this._readExtraFields(extraDataBuffer);
          if (extra && extra.parsed) {
            if (extra.parsed.path && !isUtf8) {
              entry.path = extra.parsed.path;
            }
            if (Number.isFinite(extra.parsed.uncompressedSize) && this.parsedEntity.uncompressedSize === FOUR_GIGS - 1) {
              this.parsedEntity.uncompressedSize = extra.parsed.uncompressedSize;
            }
            if (Number.isFinite(extra.parsed.compressedSize) && this.parsedEntity.compressedSize === FOUR_GIGS - 1) {
              this.parsedEntity.compressedSize = extra.parsed.compressedSize;
            }
          }
          this.parsedEntity.extra = extra.parsed || {};
          if (this.options.debug) {
            const debugObj = Object.assign({}, this.parsedEntity, {
              path: entry.path,
              flags: "0x" + this.parsedEntity.flags.toString(16),
              extraFields: extra && extra.debug
            });
            console.log("decoded LOCAL_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
          }
          this._prepareOutStream(this.parsedEntity, entry);
          this.emit("entry", entry);
          this.state = states.FILE_DATA;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_FILE_HEADER:
          this.parsedEntity = this._readCentralDirectoryEntry(chunk);
          this.state = states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
          var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
          var path34 = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
          var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
          var extra = this._readExtraFields(extraDataBuffer);
          if (extra && extra.parsed && extra.parsed.path && !isUtf8) {
            path34 = extra.parsed.path;
          }
          this.parsedEntity.extra = extra.parsed;
          var isUnix = (this.parsedEntity.versionMadeBy & 65280) >> 8 === 3;
          var unixAttrs, isSymlink;
          if (isUnix) {
            unixAttrs = this.parsedEntity.externalFileAttributes >>> 16;
            var fileType = unixAttrs >>> 12;
            isSymlink = (fileType & 10) === 10;
          }
          if (this.options.debug) {
            const debugObj = Object.assign({}, this.parsedEntity, {
              path: path34,
              flags: "0x" + this.parsedEntity.flags.toString(16),
              unixAttrs: unixAttrs && "0" + unixAttrs.toString(8),
              isSymlink,
              extraFields: extra.debug
            });
            console.log("decoded CENTRAL_DIRECTORY_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
          }
          this.state = states.START;
          return requiredLength;
        case states.CDIR64_END:
          this.parsedEntity = this._readEndOfCentralDirectory64(chunk);
          if (this.options.debug) {
            console.log("decoded CDIR64_END_RECORD:", this.parsedEntity);
          }
          this.state = states.CDIR64_END_DATA_SECTOR;
          return requiredLength;
        case states.CDIR64_END_DATA_SECTOR:
          this.state = states.START;
          return requiredLength;
        case states.CDIR64_LOCATOR:
          this.state = states.START;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_END:
          this.parsedEntity = this._readEndOfCentralDirectory(chunk);
          if (this.options.debug) {
            console.log("decoded CENTRAL_DIRECTORY_END:", this.parsedEntity);
          }
          this.state = states.CENTRAL_DIRECTORY_END_COMMENT;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_END_COMMENT:
          if (this.options.debug) {
            console.log("decoded CENTRAL_DIRECTORY_END_COMMENT:", chunk.slice(0, requiredLength).toString());
          }
          this.state = states.TRAILING_JUNK;
          return requiredLength;
        case states.ERROR:
          return chunk.length;
        default:
          console.log("didn't handle state #", this.state, "discarding");
          return chunk.length;
      }
    };
    UnzipStream.prototype._prepareOutStream = function(vars, entry) {
      var self2 = this;
      var isDirectory = vars.uncompressedSize === 0 && /[\/\\]$/.test(entry.path);
      entry.path = entry.path.replace(/^([/\\]*[.]+[/\\]+)*[/\\]*/, "");
      entry.type = isDirectory ? "Directory" : "File";
      entry.isDirectory = isDirectory;
      var fileSizeKnown = !(vars.flags & 8);
      if (fileSizeKnown) {
        entry.size = vars.uncompressedSize;
      }
      var isVersionSupported = vars.versionsNeededToExtract <= 45;
      this.outStreamInfo = {
        stream: null,
        limit: fileSizeKnown ? vars.compressedSize : -1,
        written: 0
      };
      if (!fileSizeKnown) {
        var pattern = new Buffer(4);
        pattern.writeUInt32LE(SIG_DATA_DESCRIPTOR, 0);
        var zip64Mode = vars.extra.zip64Mode;
        var extraSize = zip64Mode ? 20 : 12;
        var searchPattern = {
          pattern,
          requiredExtraSize: extraSize
        };
        var matcherStream = new MatcherStream(searchPattern, function(matchedChunk, sizeSoFar) {
          var vars2 = self2._readDataDescriptor(matchedChunk, zip64Mode);
          var compressedSizeMatches = vars2.compressedSize === sizeSoFar;
          if (!zip64Mode && !compressedSizeMatches && sizeSoFar >= FOUR_GIGS) {
            var overflown = sizeSoFar - FOUR_GIGS;
            while (overflown >= 0) {
              compressedSizeMatches = vars2.compressedSize === overflown;
              if (compressedSizeMatches)
                break;
              overflown -= FOUR_GIGS;
            }
          }
          if (!compressedSizeMatches) {
            return;
          }
          self2.state = states.FILE_DATA_END;
          var sliceOffset = zip64Mode ? 24 : 16;
          if (self2.data.length > 0) {
            self2.data = Buffer.concat([matchedChunk.slice(sliceOffset), self2.data]);
          } else {
            self2.data = matchedChunk.slice(sliceOffset);
          }
          return true;
        });
        this.outStreamInfo.stream = matcherStream;
      } else {
        this.outStreamInfo.stream = new stream.PassThrough();
      }
      var isEncrypted = vars.flags & 1 || vars.flags & 64;
      if (isEncrypted || !isVersionSupported) {
        var message = isEncrypted ? "Encrypted files are not supported!" : "Zip version " + Math.floor(vars.versionsNeededToExtract / 10) + "." + vars.versionsNeededToExtract % 10 + " is not supported";
        entry.skip = true;
        setImmediate(() => {
          entry.emit("error", new Error(message));
        });
        this.outStreamInfo.stream.pipe(new Entry().autodrain());
        return;
      }
      var isCompressed = vars.compressionMethod > 0;
      if (isCompressed) {
        var inflater = zlib.createInflateRaw();
        inflater.on("error", function(err) {
          self2.state = states.ERROR;
          self2.emit("error", err);
        });
        this.outStreamInfo.stream.pipe(inflater).pipe(entry);
      } else {
        this.outStreamInfo.stream.pipe(entry);
      }
      if (this._drainAllEntries) {
        entry.autodrain();
      }
    };
    UnzipStream.prototype._readFile = function(data) {
      var vars = binary.parse(data).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
      return vars;
    };
    UnzipStream.prototype._readExtraFields = function(data) {
      var extra = {};
      var result = { parsed: extra };
      if (this.options.debug) {
        result.debug = [];
      }
      var index = 0;
      while (index < data.length) {
        var vars = binary.parse(data).skip(index).word16lu("extraId").word16lu("extraSize").vars;
        index += 4;
        var fieldType = void 0;
        switch (vars.extraId) {
          case 1:
            fieldType = "Zip64 extended information extra field";
            var z64vars = binary.parse(data.slice(index, index + vars.extraSize)).word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offsetToLocalHeader").word32lu("diskStartNumber").vars;
            if (z64vars.uncompressedSize !== null) {
              extra.uncompressedSize = z64vars.uncompressedSize;
            }
            if (z64vars.compressedSize !== null) {
              extra.compressedSize = z64vars.compressedSize;
            }
            extra.zip64Mode = true;
            break;
          case 10:
            fieldType = "NTFS extra field";
            break;
          case 21589:
            fieldType = "extended timestamp";
            var timestampFields = data.readUInt8(index);
            var offset = 1;
            if (vars.extraSize >= offset + 4 && timestampFields & 1) {
              extra.mtime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
            }
            if (vars.extraSize >= offset + 4 && timestampFields & 2) {
              extra.atime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
            }
            if (vars.extraSize >= offset + 4 && timestampFields & 4) {
              extra.ctime = new Date(data.readUInt32LE(index + offset) * 1e3);
            }
            break;
          case 28789:
            fieldType = "Info-ZIP Unicode Path Extra Field";
            var fieldVer = data.readUInt8(index);
            if (fieldVer === 1) {
              var offset = 1;
              var nameCrc32 = data.readUInt32LE(index + offset);
              offset += 4;
              var pathBuffer = data.slice(index + offset);
              extra.path = pathBuffer.toString();
            }
            break;
          case 13:
          case 22613:
            fieldType = vars.extraId === 13 ? "PKWARE Unix" : "Info-ZIP UNIX (type 1)";
            var offset = 0;
            if (vars.extraSize >= 8) {
              var atime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
              var mtime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
              extra.atime = atime;
              extra.mtime = mtime;
              if (vars.extraSize >= 12) {
                var uid = data.readUInt16LE(index + offset);
                offset += 2;
                var gid = data.readUInt16LE(index + offset);
                offset += 2;
                extra.uid = uid;
                extra.gid = gid;
              }
            }
            break;
          case 30805:
            fieldType = "Info-ZIP UNIX (type 2)";
            var offset = 0;
            if (vars.extraSize >= 4) {
              var uid = data.readUInt16LE(index + offset);
              offset += 2;
              var gid = data.readUInt16LE(index + offset);
              offset += 2;
              extra.uid = uid;
              extra.gid = gid;
            }
            break;
          case 30837:
            fieldType = "Info-ZIP New Unix";
            var offset = 0;
            var extraVer = data.readUInt8(index);
            offset += 1;
            if (extraVer === 1) {
              var uidSize = data.readUInt8(index + offset);
              offset += 1;
              if (uidSize <= 6) {
                extra.uid = data.readUIntLE(index + offset, uidSize);
              }
              offset += uidSize;
              var gidSize = data.readUInt8(index + offset);
              offset += 1;
              if (gidSize <= 6) {
                extra.gid = data.readUIntLE(index + offset, gidSize);
              }
            }
            break;
          case 30062:
            fieldType = "ASi Unix";
            var offset = 0;
            if (vars.extraSize >= 14) {
              var crc = data.readUInt32LE(index + offset);
              offset += 4;
              var mode = data.readUInt16LE(index + offset);
              offset += 2;
              var sizdev = data.readUInt32LE(index + offset);
              offset += 4;
              var uid = data.readUInt16LE(index + offset);
              offset += 2;
              var gid = data.readUInt16LE(index + offset);
              offset += 2;
              extra.mode = mode;
              extra.uid = uid;
              extra.gid = gid;
              if (vars.extraSize > 14) {
                var start = index + offset;
                var end = index + vars.extraSize - 14;
                var symlinkName = this._decodeString(data.slice(start, end));
                extra.symlink = symlinkName;
              }
            }
            break;
        }
        if (this.options.debug) {
          result.debug.push({
            extraId: "0x" + vars.extraId.toString(16),
            description: fieldType,
            data: data.slice(index, index + vars.extraSize).inspect()
          });
        }
        index += vars.extraSize;
      }
      return result;
    };
    UnzipStream.prototype._readDataDescriptor = function(data, zip64Mode) {
      if (zip64Mode) {
        var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word64lu("compressedSize").word64lu("uncompressedSize").vars;
        return vars;
      }
      var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
      return vars;
    };
    UnzipStream.prototype._readCentralDirectoryEntry = function(data) {
      var vars = binary.parse(data).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
      return vars;
    };
    UnzipStream.prototype._readEndOfCentralDirectory64 = function(data) {
      var vars = binary.parse(data).word64lu("centralDirectoryRecordSize").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskNumberWithCentralDirectoryStart").word64lu("centralDirectoryEntries").word64lu("totalCentralDirectoryEntries").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
      return vars;
    };
    UnzipStream.prototype._readEndOfCentralDirectory = function(data) {
      var vars = binary.parse(data).word16lu("diskNumber").word16lu("diskStart").word16lu("centralDirectoryEntries").word16lu("totalCentralDirectoryEntries").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
      return vars;
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0 ";
    UnzipStream.prototype._decodeString = function(buffer, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8");
      }
      if (this.options.decodeString) {
        return this.options.decodeString(buffer);
      }
      let result = "";
      for (var i = 0; i < buffer.length; i++) {
        result += cp437[buffer[i]];
      }
      return result;
    };
    UnzipStream.prototype._parseOrOutput = function(encoding, cb) {
      var consume;
      while ((consume = this.processDataChunk(this.data)) > 0) {
        this.data = this.data.slice(consume);
        if (this.data.length === 0)
          break;
      }
      if (this.state === states.FILE_DATA) {
        if (this.outStreamInfo.limit >= 0) {
          var remaining = this.outStreamInfo.limit - this.outStreamInfo.written;
          var packet;
          if (remaining < this.data.length) {
            packet = this.data.slice(0, remaining);
            this.data = this.data.slice(remaining);
          } else {
            packet = this.data;
            this.data = new Buffer("");
          }
          this.outStreamInfo.written += packet.length;
          if (this.outStreamInfo.limit === this.outStreamInfo.written) {
            this.state = states.START;
            this.outStreamInfo.stream.end(packet, encoding, cb);
          } else {
            this.outStreamInfo.stream.write(packet, encoding, cb);
          }
        } else {
          var packet = this.data;
          this.data = new Buffer("");
          this.outStreamInfo.written += packet.length;
          var outputStream = this.outStreamInfo.stream;
          outputStream.write(packet, encoding, () => {
            if (this.state === states.FILE_DATA_END) {
              this.state = states.START;
              return outputStream.end(cb);
            }
            cb();
          });
        }
        return;
      }
      cb();
    };
    UnzipStream.prototype.drainAll = function() {
      this._drainAllEntries = true;
    };
    UnzipStream.prototype._transform = function(chunk, encoding, cb) {
      var self2 = this;
      if (self2.data.length > 0) {
        self2.data = Buffer.concat([self2.data, chunk]);
      } else {
        self2.data = chunk;
      }
      var startDataLength = self2.data.length;
      var done = function() {
        if (self2.data.length > 0 && self2.data.length < startDataLength) {
          startDataLength = self2.data.length;
          self2._parseOrOutput(encoding, done);
          return;
        }
        cb();
      };
      self2._parseOrOutput(encoding, done);
    };
    UnzipStream.prototype._flush = function(cb) {
      var self2 = this;
      if (self2.data.length > 0) {
        self2._parseOrOutput("buffer", function() {
          if (self2.data.length > 0)
            return setImmediate(function() {
              self2._flush(cb);
            });
          cb();
        });
        return;
      }
      if (self2.state === states.FILE_DATA) {
        return cb(new Error("Stream finished in an invalid state, uncompression failed"));
      }
      setImmediate(cb);
    };
    module2.exports = UnzipStream;
  }
});

// node_modules/unzip-stream/lib/parser-stream.js
var require_parser_stream = __commonJS({
  "node_modules/unzip-stream/lib/parser-stream.js"(exports2, module2) {
    var Transform2 = require("stream").Transform;
    var util4 = require("util");
    var UnzipStream = require_unzip_stream();
    function ParserStream(opts) {
      if (!(this instanceof ParserStream)) {
        return new ParserStream(opts);
      }
      var transformOpts = opts || {};
      Transform2.call(this, { readableObjectMode: true });
      this.opts = opts || {};
      this.unzipStream = new UnzipStream(this.opts);
      var self2 = this;
      this.unzipStream.on("entry", function(entry) {
        self2.push(entry);
      });
      this.unzipStream.on("error", function(error) {
        self2.emit("error", error);
      });
    }
    util4.inherits(ParserStream, Transform2);
    ParserStream.prototype._transform = function(chunk, encoding, cb) {
      this.unzipStream.write(chunk, encoding, cb);
    };
    ParserStream.prototype._flush = function(cb) {
      var self2 = this;
      this.unzipStream.end(function() {
        process.nextTick(function() {
          self2.emit("close");
        });
        cb();
      });
    };
    ParserStream.prototype.on = function(eventName, fn) {
      if (eventName === "entry") {
        return Transform2.prototype.on.call(this, "data", fn);
      }
      return Transform2.prototype.on.call(this, eventName, fn);
    };
    ParserStream.prototype.drainAll = function() {
      this.unzipStream.drainAll();
      return this.pipe(new Transform2({ objectMode: true, transform: function(d, e, cb) {
        cb();
      } }));
    };
    module2.exports = ParserStream;
  }
});

// node_modules/unzip-stream/node_modules/mkdirp/index.js
var require_mkdirp2 = __commonJS({
  "node_modules/unzip-stream/node_modules/mkdirp/index.js"(exports2, module2) {
    var path34 = require("path");
    var fs26 = require("fs");
    var _0777 = parseInt("0777", 8);
    module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    function mkdirP(p, opts, f, made) {
      if (typeof opts === "function") {
        f = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs26;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      var cb = f || function() {
      };
      p = path34.resolve(p);
      xfs.mkdir(p, mode, function(er) {
        if (!er) {
          made = made || p;
          return cb(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path34.dirname(p) === p)
              return cb(er);
            mkdirP(path34.dirname(p), opts, function(er2, made2) {
              if (er2)
                cb(er2, made2);
              else
                mkdirP(p, opts, cb, made2);
            });
            break;
          default:
            xfs.stat(p, function(er2, stat) {
              if (er2 || !stat.isDirectory())
                cb(er, made);
              else
                cb(null, made);
            });
            break;
        }
      });
    }
    mkdirP.sync = function sync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs26;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      p = path34.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        switch (err0.code) {
          case "ENOENT":
            made = sync(path34.dirname(p), opts, made);
            sync(p, opts, made);
            break;
          default:
            var stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0;
            }
            if (!stat.isDirectory())
              throw err0;
            break;
        }
      }
      return made;
    };
  }
});

// node_modules/unzip-stream/lib/extract.js
var require_extract2 = __commonJS({
  "node_modules/unzip-stream/lib/extract.js"(exports2, module2) {
    var fs26 = require("fs");
    var path34 = require("path");
    var util4 = require("util");
    var mkdirp = require_mkdirp2();
    var Transform2 = require("stream").Transform;
    var UnzipStream = require_unzip_stream();
    function Extract(opts) {
      if (!(this instanceof Extract))
        return new Extract(opts);
      Transform2.call(this);
      this.opts = opts || {};
      this.unzipStream = new UnzipStream(this.opts);
      this.unfinishedEntries = 0;
      this.afterFlushWait = false;
      this.createdDirectories = {};
      var self2 = this;
      this.unzipStream.on("entry", this._processEntry.bind(this));
      this.unzipStream.on("error", function(error) {
        self2.emit("error", error);
      });
    }
    util4.inherits(Extract, Transform2);
    Extract.prototype._transform = function(chunk, encoding, cb) {
      this.unzipStream.write(chunk, encoding, cb);
    };
    Extract.prototype._flush = function(cb) {
      var self2 = this;
      var allDone = function() {
        process.nextTick(function() {
          self2.emit("close");
        });
        cb();
      };
      this.unzipStream.end(function() {
        if (self2.unfinishedEntries > 0) {
          self2.afterFlushWait = true;
          return self2.on("await-finished", allDone);
        }
        allDone();
      });
    };
    Extract.prototype._processEntry = function(entry) {
      var self2 = this;
      var destPath = path34.join(this.opts.path, entry.path);
      var directory = entry.isDirectory ? destPath : path34.dirname(destPath);
      this.unfinishedEntries++;
      var writeFileFn = function() {
        var pipedStream = fs26.createWriteStream(destPath);
        pipedStream.on("close", function() {
          self2.unfinishedEntries--;
          self2._notifyAwaiter();
        });
        pipedStream.on("error", function(error) {
          self2.emit("error", error);
        });
        entry.pipe(pipedStream);
      };
      if (this.createdDirectories[directory] || directory === ".") {
        return writeFileFn();
      }
      mkdirp(directory, function(err) {
        if (err)
          return self2.emit("error", err);
        self2.createdDirectories[directory] = true;
        if (entry.isDirectory) {
          self2.unfinishedEntries--;
          self2._notifyAwaiter();
          return;
        }
        writeFileFn();
      });
    };
    Extract.prototype._notifyAwaiter = function() {
      if (this.afterFlushWait && this.unfinishedEntries === 0) {
        this.emit("await-finished");
        this.afterFlushWait = false;
      }
    };
    module2.exports = Extract;
  }
});

// node_modules/unzip-stream/unzip.js
var require_unzip = __commonJS({
  "node_modules/unzip-stream/unzip.js"(exports2) {
    "use strict";
    exports2.Parse = require_parser_stream();
    exports2.Extract = require_extract2();
  }
});

// node_modules/@tootallnate/once/dist/index.js
var require_dist = __commonJS({
  "node_modules/@tootallnate/once/dist/index.js"(exports2, module2) {
    "use strict";
    function noop() {
    }
    function once(emitter, name2) {
      const o = once.spread(emitter, name2);
      const r = o.then((args) => args[0]);
      r.cancel = o.cancel;
      return r;
    }
    (function(once2) {
      function spread(emitter, name2) {
        let c = null;
        const p = new Promise((resolve3, reject) => {
          function cancel() {
            emitter.removeListener(name2, onEvent);
            emitter.removeListener("error", onError);
            p.cancel = noop;
          }
          function onEvent(...args) {
            cancel();
            resolve3(args);
          }
          function onError(err) {
            cancel();
            reject(err);
          }
          c = cancel;
          emitter.on(name2, onEvent);
          emitter.on("error", onError);
        });
        if (!c) {
          throw new TypeError("Could not get `cancel()` function");
        }
        p.cancel = c;
        return p;
      }
      once2.spread = spread;
    })(once || (once = {}));
    module2.exports = once;
  }
});

// node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "node_modules/agent-base/dist/src/promisify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function promisify(fn) {
      return function(req, opts) {
        return new Promise((resolve3, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve3(rtn);
            }
          });
        });
      };
    }
    exports2.default = promisify;
  }
});

// node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/agent-base/dist/src/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = require("events");
    var debug_1 = __importDefault(require_src());
    var promisify_1 = __importDefault(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  }
});

// node_modules/http-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "node_modules/http-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve3) {
          resolve3(value);
        });
      }
      return new (P || (P = Promise))(function(resolve3, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var debug_1 = __importDefault(require_src());
    var once_1 = __importDefault(require_dist());
    var agent_base_1 = require_src2();
    var debug = debug_1.default("http-proxy-agent");
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    var HttpProxyAgent2 = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("Creating new HttpProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          const parsed = url_1.default.parse(req.path);
          if (!parsed.protocol) {
            parsed.protocol = "http:";
          }
          if (!parsed.hostname) {
            parsed.hostname = opts.hostname || opts.host || null;
          }
          if (parsed.port == null && typeof opts.port) {
            parsed.port = String(opts.port);
          }
          if (parsed.port === "80") {
            delete parsed.port;
          }
          req.path = url_1.default.format(parsed);
          if (proxy.auth) {
            req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
          }
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          if (req._header) {
            let first;
            let endOfHeaders;
            debug("Regenerating stored HTTP header string for request");
            req._header = null;
            req._implicitHeader();
            if (req.output && req.output.length > 0) {
              debug("Patching connection write() output buffer with updated header");
              first = req.output[0];
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.output[0] = req._header + first.substring(endOfHeaders);
              debug("Output buffer: %o", req.output);
            } else if (req.outputData && req.outputData.length > 0) {
              debug("Patching connection write() output buffer with updated header");
              first = req.outputData[0].data;
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.outputData[0].data = req._header + first.substring(endOfHeaders);
              debug("Output buffer: %o", req.outputData[0].data);
            }
          }
          yield once_1.default(socket, "connect");
          return socket;
        });
      }
    };
    exports2.default = HttpProxyAgent2;
  }
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/http-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpProxyAgent2(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpProxyAgent3) {
      createHttpProxyAgent3.HttpProxyAgent = agent_1.default;
      createHttpProxyAgent3.prototype = agent_1.default.prototype;
    })(createHttpProxyAgent2 || (createHttpProxyAgent2 = {}));
    module2.exports = createHttpProxyAgent2;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve3, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve3({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports2.default = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent2 = __commonJS({
  "node_modules/https-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve3) {
          resolve3(value);
        });
      }
      return new (P || (P = Promise))(function(resolve3, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent2 = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name2 of Object.keys(headers)) {
            payload += `${name2}: ${headers[name2]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              const servername = opts.servername || opts.host;
              if (!servername) {
                throw new Error('Could not determine "servername"');
              }
              debug("Upgrading socket connection to TLS");
              return tls_1.default.connect(Object.assign(Object.assign({}, omit2(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket();
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports2.default = HttpsProxyAgent2;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit2(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent2());
    function createHttpsProxyAgent2(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent3) {
      createHttpsProxyAgent3.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent3.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent2 || (createHttpsProxyAgent2 = {}));
    module2.exports = createHttpsProxyAgent2;
  }
});

// node_modules/mimic-response/index.js
var require_mimic_response = __commonJS({
  "node_modules/mimic-response/index.js"(exports2, module2) {
    "use strict";
    var knownProperties = [
      "aborted",
      "complete",
      "headers",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "method",
      "rawHeaders",
      "rawTrailers",
      "setTimeout",
      "socket",
      "statusCode",
      "statusMessage",
      "trailers",
      "url"
    ];
    module2.exports = (fromStream, toStream) => {
      if (toStream._readableState.autoDestroy) {
        throw new Error("The second stream must have the `autoDestroy` option set to `false`");
      }
      const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));
      const properties = {};
      for (const property of fromProperties) {
        if (property in toStream) {
          continue;
        }
        properties[property] = {
          get() {
            const value = fromStream[property];
            const isFunction = typeof value === "function";
            return isFunction ? value.bind(fromStream) : value;
          },
          set(value) {
            fromStream[property] = value;
          },
          enumerable: true,
          configurable: false
        };
      }
      Object.defineProperties(toStream, properties);
      fromStream.once("aborted", () => {
        toStream.destroy();
        toStream.emit("aborted");
      });
      fromStream.once("close", () => {
        if (fromStream.complete) {
          if (toStream.readable) {
            toStream.once("end", () => {
              toStream.emit("close");
            });
          } else {
            toStream.emit("close");
          }
        } else {
          toStream.emit("close");
        }
      });
      return toStream;
    };
  }
});

// node_modules/decompress-response/index.js
var require_decompress_response = __commonJS({
  "node_modules/decompress-response/index.js"(exports2, module2) {
    "use strict";
    var { Transform: Transform2, PassThrough } = require("stream");
    var zlib = require("zlib");
    var mimicResponse = require_mimic_response();
    module2.exports = (response) => {
      const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
      if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
        return response;
      }
      const isBrotli = contentEncoding === "br";
      if (isBrotli && typeof zlib.createBrotliDecompress !== "function") {
        response.destroy(new Error("Brotli is not supported on Node.js < 12"));
        return response;
      }
      let isEmpty = true;
      const checker = new Transform2({
        transform(data, _encoding, callback) {
          isEmpty = false;
          callback(null, data);
        },
        flush(callback) {
          callback();
        }
      });
      const finalStream = new PassThrough({
        autoDestroy: false,
        destroy(error, callback) {
          response.destroy();
          callback(error);
        }
      });
      const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
      decompressStream.once("error", (error) => {
        if (isEmpty && !response.readable) {
          finalStream.end();
          return;
        }
        finalStream.destroy(error);
      });
      mimicResponse(response, finalStream);
      response.pipe(checker).pipe(decompressStream).pipe(finalStream);
      return finalStream;
    };
  }
});

// src/model/fetch.ts
function getSystemProxyURI(endpoint) {
  let env;
  if (endpoint.protocol === "http:") {
    env = process.env.HTTP_PROXY || process.env.http_proxy || null;
  } else if (endpoint.protocol === "https:") {
    env = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
  }
  let noProxy = process.env.NO_PROXY || process.env.no_proxy;
  if (noProxy === "*") {
    env = null;
  } else if (noProxy) {
    const hostname = endpoint.hostname.replace(/^\.*/, ".").toLowerCase();
    const port = endpoint.port || endpoint.protocol.startsWith("https") ? "443" : "80";
    const noProxyList = noProxy.split(",");
    for (let i = 0, len = noProxyList.length; i < len; i++) {
      let noProxyItem = noProxyList[i].trim().toLowerCase();
      if (noProxyItem.includes(":")) {
        let noProxyItemParts = noProxyItem.split(":", 2);
        let noProxyHost = noProxyItemParts[0].replace(/^\.*/, ".");
        let noProxyPort = noProxyItemParts[1];
        if (port === noProxyPort && hostname.endsWith(noProxyHost)) {
          env = null;
          break;
        }
      } else {
        noProxyItem = noProxyItem.replace(/^\.*/, ".");
        if (hostname.endsWith(noProxyItem)) {
          env = null;
          break;
        }
      }
    }
  }
  return env;
}
function getAgent(endpoint, options) {
  let proxy = options.proxyUrl || getSystemProxyURI(endpoint);
  if (proxy) {
    const proxyEndpoint = (0, import_url.parse)(proxy);
    if (!/^https?:$/.test(proxyEndpoint.protocol)) {
      return null;
    }
    let opts = {
      host: proxyEndpoint.hostname,
      port: proxyEndpoint.port ? Number(proxyEndpoint.port) : proxyEndpoint.protocol === "https" ? "443" : "80",
      auth: proxyEndpoint.auth,
      rejectUnauthorized: typeof options.strictSSL === "boolean" ? options.strictSSL : true
    };
    logger31.info(`Using proxy ${proxy} from ${options.proxyUrl ? "configuration" : "system environment"} for ${endpoint.hostname}:`);
    return endpoint.protocol === "http:" ? (0, import_http_proxy_agent.default)(opts) : (0, import_https_proxy_agent.default)(opts);
  }
  return null;
}
function resolveRequestOptions(url, options = {}) {
  let config = workspace_default.getConfiguration("http");
  let { data } = options;
  let dataType = getDataType(data);
  let proxyOptions = {
    proxyUrl: config.get("proxy", ""),
    strictSSL: config.get("proxyStrictSSL", true),
    proxyAuthorization: config.get("proxyAuthorization", null),
    proxyCA: config.get("proxyCA", null)
  };
  if (options.query && !url.includes("?")) {
    url = `${url}?${(0, import_querystring.stringify)(options.query)}`;
  }
  let headers = Object.assign(options.headers || {}, { "Proxy-Authorization": proxyOptions.proxyAuthorization });
  let endpoint = (0, import_url.parse)(url);
  let agent = getAgent(endpoint, proxyOptions);
  let opts = {
    method: options.method || "GET",
    hostname: endpoint.hostname,
    port: endpoint.port ? parseInt(endpoint.port, 10) : endpoint.protocol === "https:" ? 443 : 80,
    path: endpoint.path,
    agent,
    rejectUnauthorized: proxyOptions.strictSSL,
    maxRedirects: 3,
    headers: Object.assign({
      "User-Agent": "Mozilla/5.0 (X11; Linux x86_64)",
      "Accept-Encoding": "gzip, deflate"
    }, headers)
  };
  if (proxyOptions.proxyCA) {
    opts.ca = import_fs11.default.readFileSync(proxyOptions.proxyCA);
  }
  if (dataType == "object") {
    opts.headers["Content-Type"] = "application/json";
  } else if (dataType == "string") {
    opts.headers["Content-Type"] = "text/plain";
  }
  if (options.user && options.password) {
    opts.auth = options.user + ":" + options.password;
  }
  if (options.timeout) {
    opts.timeout = options.timeout;
  }
  if (options.buffer)
    opts.buffer = true;
  return opts;
}
function request(url, data, opts, token) {
  let mod = url.startsWith("https:") ? import_follow_redirects.https : import_follow_redirects.http;
  return new Promise((resolve3, reject) => {
    if (token) {
      let disposable = token.onCancellationRequested(() => {
        disposable.dispose();
        req.destroy(new Error("request aborted"));
      });
    }
    const req = mod.request(opts, (res) => {
      let readable = res;
      if (res.statusCode >= 200 && res.statusCode < 300 || res.statusCode === 1223) {
        let headers = res.headers || {};
        let chunks = [];
        let contentType = headers["content-type"] || "";
        readable = (0, import_decompress_response.default)(res);
        readable.on("data", (chunk) => {
          chunks.push(chunk);
        });
        readable.on("end", () => {
          let buf = Buffer.concat(chunks);
          if (!opts.buffer && (contentType.startsWith("application/json") || contentType.startsWith("text/"))) {
            let ms = contentType.match(/charset=(\S+)/);
            let encoding = ms ? ms[1] : "utf8";
            let rawData = buf.toString(encoding);
            if (!contentType.includes("application/json")) {
              resolve3(rawData);
            } else {
              try {
                const parsedData = JSON.parse(rawData);
                resolve3(parsedData);
              } catch (e) {
                reject(new Error(`Parse response error: ${e}`));
              }
            }
          } else {
            resolve3(buf);
          }
        });
        readable.on("error", (err) => {
          reject(new Error(`Unable to connect ${url}: ${err.message}`));
        });
      } else {
        reject(new Error(`Bad response from ${url}: ${res.statusCode}`));
      }
    });
    req.on("error", reject);
    req.on("timeout", () => {
      req.destroy(new Error(`Request timeout after ${opts.timeout}ms`));
    });
    if (data) {
      if (typeof data === "string" || Buffer.isBuffer(data)) {
        req.write(data);
      } else {
        req.write(JSON.stringify(data));
      }
    }
    if (opts.timeout) {
      req.setTimeout(opts.timeout);
    }
    req.end();
  });
}
function getDataType(data) {
  if (data === null)
    return "null";
  if (data === void 0)
    return "undefined";
  if (typeof data == "string")
    return "string";
  if (Buffer.isBuffer(data))
    return "buffer";
  if (Array.isArray(data) || objectLiteral(data))
    return "object";
  return "unknown";
}
function fetch(url, options = {}, token) {
  let opts = resolveRequestOptions(url, options);
  return request(url, options.data, opts, token).catch((err) => {
    logger31.error(`Fetch error for ${url}:`, opts, err);
    if (opts.agent && opts.agent.proxy) {
      let { proxy } = opts.agent;
      throw new Error(`Request failed using proxy ${proxy.host}: ${err.message}`);
    } else {
      throw err;
    }
  });
}
var import_follow_redirects, import_url, import_fs11, import_querystring, import_http_proxy_agent, import_https_proxy_agent, import_decompress_response, logger31;
var init_fetch = __esm({
  "src/model/fetch.ts"() {
    import_follow_redirects = __toModule(require_follow_redirects());
    import_url = __toModule(require("url"));
    import_fs11 = __toModule(require("fs"));
    init_is();
    init_workspace();
    import_querystring = __toModule(require("querystring"));
    import_http_proxy_agent = __toModule(require_dist2());
    import_https_proxy_agent = __toModule(require_dist3());
    import_decompress_response = __toModule(require_decompress_response());
    logger31 = require_logger2()("model-fetch");
  }
});

// src/model/download.ts
function download(url, options, token) {
  let { dest, onProgress, extract } = options;
  if (!dest || !import_path13.default.isAbsolute(dest)) {
    throw new Error(`Expect absolute file path for dest option.`);
  }
  let stat;
  try {
    stat = import_fs_extra5.default.statSync(dest);
  } catch (_e) {
    import_fs_extra5.default.mkdirpSync(dest);
  }
  if (stat && !stat.isDirectory()) {
    throw new Error(`${dest} exists, but not directory!`);
  }
  let mod = url.startsWith("https") ? import_follow_redirects2.https : import_follow_redirects2.http;
  let opts = resolveRequestOptions(url, options);
  let extname = import_path13.default.extname(url);
  return new Promise((resolve3, reject) => {
    if (token) {
      let disposable = token.onCancellationRequested(() => {
        disposable.dispose();
        req.destroy(new Error("request aborted"));
      });
    }
    const req = mod.request(opts, (res) => {
      var _a2, _b;
      if (res.statusCode >= 200 && res.statusCode < 300 || res.statusCode === 1223) {
        let headers = res.headers || {};
        let dispositionHeader = headers["content-disposition"];
        if (!extname && dispositionHeader) {
          let disposition = import_content_disposition.default.parse(dispositionHeader);
          if ((_a2 = disposition.parameters) == null ? void 0 : _a2.filename) {
            extname = import_path13.default.extname(disposition.parameters.filename);
          }
        }
        if (extract === true) {
          if (extname === ".zip" || headers["content-type"] == "application/zip") {
            extract = "unzip";
          } else if (extname == ".tgz") {
            extract = "untar";
          } else {
            reject(new Error(`Unable to extract for ${url}`));
            return;
          }
        }
        let total = Number(headers["content-length"]);
        let cur = 0;
        if (!isNaN(total)) {
          res.on("data", (chunk) => {
            cur += chunk.length;
            let percent = (cur / total * 100).toFixed(1);
            if (onProgress) {
              onProgress(percent);
            } else {
              logger32.info(`Download ${url} progress ${percent}%`);
            }
          });
        }
        res.on("error", (err) => {
          reject(new Error(`Unable to connect ${url}: ${err.message}`));
        });
        res.on("end", () => {
          logger32.info("Download completed:", url);
        });
        let stream;
        if (extract === "untar") {
          stream = res.pipe(import_tar.default.x({ strip: (_b = options.strip) != null ? _b : 1, C: dest }));
        } else if (extract === "unzip") {
          stream = res.pipe(import_unzip_stream.default.Extract({ path: dest }));
        } else {
          dest = import_path13.default.join(dest, `${v1_default()}${extname}`);
          stream = res.pipe(import_fs_extra5.default.createWriteStream(dest));
        }
        stream.on("finish", () => {
          logger32.info(`Downloaded ${url} => ${dest}`);
          setTimeout(() => {
            resolve3(dest);
          }, 100);
        });
        stream.on("error", reject);
      } else {
        reject(new Error(`Invalid response from ${url}: ${res.statusCode}`));
      }
    });
    req.on("error", reject);
    req.on("timeout", () => {
      req.destroy(new Error(`request timeout after ${options.timeout}ms`));
    });
    if (options.timeout) {
      req.setTimeout(options.timeout);
    }
    req.end();
  });
}
var import_content_disposition, import_follow_redirects2, import_fs_extra5, import_path13, import_tar, import_unzip_stream, logger32;
var init_download = __esm({
  "src/model/download.ts"() {
    import_content_disposition = __toModule(require_content_disposition());
    import_follow_redirects2 = __toModule(require_follow_redirects());
    import_fs_extra5 = __toModule(require_lib5());
    import_path13 = __toModule(require("path"));
    import_tar = __toModule(require_tar());
    import_unzip_stream = __toModule(require_unzip());
    init_esm_node();
    init_fetch();
    logger32 = require_logger2()("model-download");
  }
});

// src/model/installer.ts
function registryUrl(scope = "coc.nvim") {
  const result = (0, import_rc.default)("npm", { registry: "https://registry.npmjs.org/" });
  const registry = result[`${scope}:registry`] || result.config_registry || result.registry;
  return registry.endsWith("/") ? registry : registry + "/";
}
function createInstallerFactory(npm, root) {
  return (def) => new Installer(root, npm, def);
}
var import_events13, import_child_process3, import_readline2, import_fs_extra6, import_os6, import_path14, import_rc, import_semver2, logger33, Installer;
var init_installer = __esm({
  "src/model/installer.ts"() {
    import_events13 = __toModule(require("events"));
    import_child_process3 = __toModule(require("child_process"));
    init_main3();
    import_readline2 = __toModule(require("readline"));
    import_fs_extra6 = __toModule(require_lib5());
    import_os6 = __toModule(require("os"));
    import_path14 = __toModule(require("path"));
    import_rc = __toModule(require_rc());
    import_semver2 = __toModule(require_semver2());
    init_workspace();
    init_download();
    init_fetch();
    init_fs();
    logger33 = require_logger2()("model-installer");
    Installer = class extends import_events13.EventEmitter {
      constructor(root, npm, def) {
        super();
        this.root = root;
        this.npm = npm;
        this.def = def;
        if (!import_fs_extra6.default.existsSync(root))
          import_fs_extra6.default.mkdirpSync(root);
        if (/^https?:/.test(def)) {
          this.url = def;
        } else {
          if (def.startsWith("@")) {
            const idx = def.indexOf("@", 1);
            if (idx > 1) {
              this.name = def.substring(0, idx);
              this.version = def.substring(idx + 1);
            } else {
              this.name = def;
            }
          } else {
            if (def.includes("@")) {
              let [name2, version2] = def.split("@", 2);
              this.name = name2;
              this.version = version2;
            } else {
              this.name = def;
            }
          }
        }
      }
      get info() {
        return { name: this.name, version: this.version };
      }
      async install() {
        this.log(`Using npm from: ${this.npm}`);
        let info = await this.getInfo();
        logger33.info(`Fetched info of ${this.def}`, info);
        let { name: name2 } = info;
        let required = info["engines.coc"] ? info["engines.coc"].replace(/^\^/, ">=") : "";
        if (required && !import_semver2.default.satisfies(workspace_default.version, required)) {
          throw new Error(`${name2} ${info.version} requires coc.nvim >= ${required}, please update coc.nvim.`);
        }
        await this.doInstall(info);
        return name2;
      }
      async update(url) {
        this.url = url;
        let folder = import_path14.default.join(this.root, this.name);
        let stat = await import_fs_extra6.default.lstat(folder);
        if (stat.isSymbolicLink()) {
          this.log(`Skipped update for symbol link`);
          return;
        }
        let version2;
        if (import_fs_extra6.default.existsSync(import_path14.default.join(folder, "package.json"))) {
          let content = await import_fs_extra6.default.readFile(import_path14.default.join(folder, "package.json"), "utf8");
          version2 = JSON.parse(content).version;
        }
        this.log(`Using npm from: ${this.npm}`);
        let info = await this.getInfo();
        if (version2 && info.version && import_semver2.default.gte(version2, info.version)) {
          this.log(`Current version ${version2} is up to date.`);
          return;
        }
        let required = info["engines.coc"] ? info["engines.coc"].replace(/^\^/, ">=") : "";
        if (required && !import_semver2.default.satisfies(workspace_default.version, required)) {
          throw new Error(`${info.version} requires coc.nvim ${required}, please update coc.nvim.`);
        }
        await this.doInstall(info);
        let jsonFile = import_path14.default.join(this.root, info.name, "package.json");
        if (import_fs_extra6.default.existsSync(jsonFile)) {
          this.log(`Updated to v${info.version}`);
          return import_path14.default.dirname(jsonFile);
        } else {
          throw new Error(`Package.json not found: ${jsonFile}`);
        }
      }
      async doInstall(info) {
        let folder = import_path14.default.join(this.root, info.name);
        if (import_fs_extra6.default.existsSync(folder)) {
          let stat2 = import_fs_extra6.default.statSync(folder);
          if (!stat2.isDirectory()) {
            this.log(`${folder} is not directory skipped install`);
            return;
          }
        }
        let tmpFolder = await import_fs_extra6.default.mkdtemp(import_path14.default.join(import_os6.default.tmpdir(), `${info.name.replace("/", "-")}-`));
        let url = info["dist.tarball"];
        this.log(`Downloading from ${url}`);
        await download(url, { dest: tmpFolder, onProgress: (p) => this.log(`Download progress ${p}%`, true), extract: "untar" });
        this.log(`Extension download at ${tmpFolder}`);
        let content = await import_fs_extra6.default.readFile(import_path14.default.join(tmpFolder, "package.json"), "utf8");
        let { dependencies } = JSON.parse(content);
        if (dependencies && Object.keys(dependencies).length) {
          let p = new Promise((resolve3, reject) => {
            let args = ["install", "--ignore-scripts", "--no-lockfile", "--production"];
            if (url.startsWith("https://github.com")) {
              args = ["install"];
            }
            if ((this.npm.endsWith("npm") || this.npm.endsWith("npm.CMD")) && !this.npm.endsWith("pnpm")) {
              args.push("--legacy-peer-deps");
            }
            if (this.npm.endsWith("yarn")) {
              args.push("--ignore-engines");
            }
            this.log(`Installing dependencies by: ${this.npm} ${args.join(" ")}.`);
            const child = (0, import_child_process3.spawn)(this.npm, args, {
              cwd: tmpFolder
            });
            const rl = import_readline2.default.createInterface({
              input: child.stdout
            });
            rl.on("line", (line) => {
              this.log(`[npm] ${line}`, true);
            });
            child.stderr.setEncoding("utf8");
            child.stdout.setEncoding("utf8");
            child.on("error", reject);
            let err = "";
            child.stderr.on("data", (data) => {
              err += data;
            });
            child.on("exit", (code) => {
              if (code) {
                if (err)
                  this.log(err);
                reject(new Error(`${this.npm} install exited with ${code}`));
                return;
              }
              resolve3();
            });
          });
          await p;
        }
        let jsonFile = import_path14.default.resolve(this.root, global.hasOwnProperty("__TEST__") ? "" : "..", "package.json");
        let errors = [];
        let obj = parse3(import_fs_extra6.default.readFileSync(jsonFile, "utf8"), errors, { allowTrailingComma: true });
        if (errors && errors.length > 0) {
          throw new Error(`Error on load ${jsonFile}`);
        }
        obj.dependencies = obj.dependencies || {};
        if (this.url) {
          obj.dependencies[info.name] = this.url;
        } else {
          obj.dependencies[info.name] = ">=" + info.version;
        }
        const sortedObj = { dependencies: {} };
        Object.keys(obj.dependencies).sort().forEach((k) => {
          sortedObj.dependencies[k] = obj.dependencies[k];
        });
        let stat = await statAsync(folder);
        if (stat) {
          if (stat.isDirectory()) {
            import_fs_extra6.default.removeSync(folder);
          } else {
            import_fs_extra6.default.unlinkSync(folder);
          }
        }
        await import_fs_extra6.default.move(tmpFolder, folder, { overwrite: true });
        await import_fs_extra6.default.writeFile(jsonFile, JSON.stringify(sortedObj, null, 2), { encoding: "utf8" });
        this.log(`Update package.json at ${jsonFile}`);
        this.log(`Installed extension ${this.name}@${info.version} at ${folder}`);
      }
      async getInfo() {
        if (this.url)
          return await this.getInfoFromUri();
        let registry = registryUrl();
        this.log(`Get info from ${registry}`);
        let buffer = await fetch(registry + this.name, { timeout: 1e4, buffer: true });
        let res = JSON.parse(buffer.toString());
        if (!this.version)
          this.version = res["dist-tags"]["latest"];
        let obj = res["versions"][this.version];
        if (!obj)
          throw new Error(`${this.def} doesn't exists in ${registry}.`);
        let requiredVersion = obj["engines"] && obj["engines"]["coc"];
        if (!requiredVersion) {
          throw new Error(`${this.def} is not valid coc extension, "engines" field with coc property required.`);
        }
        return {
          "dist.tarball": obj["dist"]["tarball"],
          "engines.coc": requiredVersion,
          version: obj["version"],
          name: res.name
        };
      }
      async getInfoFromUri() {
        let { url } = this;
        if (!url.includes("github.com")) {
          throw new Error(`"${url}" is not supported, coc.nvim support github.com only`);
        }
        url = url.replace(/\/$/, "");
        let branch = "master";
        if (url.includes("@")) {
          let idx = url.indexOf("@");
          branch = url.substr(idx + 1);
          url = url.substring(0, idx);
        }
        let fileUrl = url.replace("github.com", "raw.githubusercontent.com") + `/${branch}/package.json`;
        this.log(`Get info from ${fileUrl}`);
        let content = await fetch(fileUrl, { timeout: 1e4 });
        let obj = typeof content == "string" ? JSON.parse(content) : content;
        this.name = obj.name;
        return {
          "dist.tarball": `${url}/archive/${branch}.tar.gz`,
          "engines.coc": obj["engines"] ? obj["engines"]["coc"] : null,
          name: obj.name,
          version: obj.version
        };
      }
      log(msg, isProgress = false) {
        logger33.info(msg);
        this.emit("message", msg, isProgress);
      }
    };
  }
});

// src/model/memos.ts
var import_fs13, logger34, Memos;
var init_memos = __esm({
  "src/model/memos.ts"() {
    import_fs13 = __toModule(require("fs"));
    init_object();
    logger34 = require_logger2()("model-memos");
    Memos = class {
      constructor(filepath) {
        this.filepath = filepath;
        if (!import_fs13.default.existsSync(filepath)) {
          import_fs13.default.writeFileSync(filepath, "{}", "utf8");
        }
      }
      fetchContent(id, key) {
        try {
          let content = import_fs13.default.readFileSync(this.filepath, "utf8");
          let res = JSON.parse(content);
          let obj = res[id];
          if (!obj)
            return void 0;
          return obj[key];
        } catch (e) {
          return void 0;
        }
      }
      async update(id, key, value) {
        let { filepath } = this;
        try {
          let content = import_fs13.default.readFileSync(filepath, "utf8");
          let current = content ? JSON.parse(content) : {};
          current[id] = current[id] || {};
          if (value !== void 0) {
            current[id][key] = deepClone(value);
          } else {
            delete current[id][key];
          }
          content = JSON.stringify(current, null, 2);
          import_fs13.default.writeFileSync(filepath, content, "utf8");
        } catch (e) {
          logger34.error(`Error on update memos:`, e);
        }
      }
      createMemento(id) {
        return {
          get: (key, defaultValue) => {
            let res = this.fetchContent(id, key);
            return res === void 0 ? defaultValue : res;
          },
          update: async (key, value) => {
            await this.update(id, key, value);
          }
        };
      }
    };
  }
});

// src/util/lodash.ts
function defaults(obj, ...sources) {
  obj = Object(obj);
  sources.forEach((source) => {
    if (source != null) {
      source = Object(source);
      for (const key in source) {
        const value = obj[key];
        if (value === void 0 || value === objectProto[key] && !hasOwnProperty2.call(obj, key)) {
          obj[key] = source[key];
        }
      }
    }
  });
  return obj;
}
function omit(obj, properties) {
  let o = {};
  for (let key of Object.keys(obj)) {
    if (!properties.includes(key)) {
      o[key] = obj[key];
    }
  }
  return o;
}
var objectProto, hasOwnProperty2;
var init_lodash = __esm({
  "src/util/lodash.ts"() {
    objectProto = Object.prototype;
    hasOwnProperty2 = objectProto.hasOwnProperty;
  }
});

// src/provider/manager.ts
function addLocation(arr, location) {
  let { range, uri } = location;
  if (arr.find((o) => o.uri == uri && equals(o.range, range)) != null)
    return;
  arr.push(location);
}
var import_vscode_languageserver_protocol19, logger35, Manager;
var init_manager2 = __esm({
  "src/provider/manager.ts"() {
    import_vscode_languageserver_protocol19 = __toModule(require_main2());
    init_workspace();
    init_window();
    init_object();
    logger35 = require_logger2()("provider-manager");
    Manager = class {
      constructor() {
        this.providers = new Set();
      }
      hasProvider(document2) {
        return this.getProvider(document2) != null;
      }
      getProvider(document2) {
        let currScore = 0;
        let providerItem;
        for (let item of this.providers) {
          let { selector, priority } = item;
          let score5 = workspace_default.match(selector, document2);
          if (score5 == 0)
            continue;
          if (typeof priority == "number") {
            score5 = priority;
          }
          if (score5 < currScore)
            continue;
          currScore = score5;
          providerItem = item;
        }
        return providerItem;
      }
      poviderById(id) {
        let item = Array.from(this.providers).find((o) => o.id == id);
        return item ? item.provider : null;
      }
      getProviders(document2) {
        let items = Array.from(this.providers);
        items = items.filter((item) => workspace_default.match(item.selector, document2) > 0);
        return items.sort((a, b) => workspace_default.match(b.selector, document2) - workspace_default.match(a.selector, document2));
      }
      toLocations(arr) {
        let res = [];
        for (let def of arr) {
          if (!def)
            continue;
          if (import_vscode_languageserver_protocol19.Location.is(def)) {
            addLocation(res, def);
          } else if (Array.isArray(def)) {
            for (let d of def) {
              if (import_vscode_languageserver_protocol19.Location.is(d)) {
                addLocation(res, d);
              } else if (import_vscode_languageserver_protocol19.LocationLink.is(d)) {
                let { targetUri, targetSelectionRange } = d;
                addLocation(res, import_vscode_languageserver_protocol19.Location.create(targetUri, targetSelectionRange));
              }
            }
          } else {
            window_default.showMessage(`Bad definition ${JSON.stringify(def)}`, "error");
          }
        }
        return res;
      }
    };
  }
});

// src/provider/codeActionmanager.ts
var import_vscode_languageserver_protocol20, logger36, CodeActionManager;
var init_codeActionmanager = __esm({
  "src/provider/codeActionmanager.ts"() {
    import_vscode_languageserver_protocol20 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    logger36 = require_logger2()("codeActionManager");
    CodeActionManager = class extends Manager {
      register(selector, provider, clientId, codeActionKinds) {
        let item = {
          id: v4_default(),
          selector,
          provider,
          kinds: codeActionKinds,
          clientId
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol20.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideCodeActions(document2, range, context, token) {
        let providers = this.getProviders(document2);
        if (!providers.length)
          return null;
        if (context.only) {
          let { only } = context;
          providers = providers.filter((p) => {
            if (p.kinds && !p.kinds.some((kind) => only.includes(kind))) {
              return false;
            }
            return true;
          });
        }
        let res = [];
        await Promise.all(providers.map((item) => {
          let { provider, clientId } = item;
          return Promise.resolve(provider.provideCodeActions(document2, range, context, token)).then((actions) => {
            if (!actions || actions.length == 0)
              return;
            for (let action of actions) {
              if (import_vscode_languageserver_protocol20.Command.is(action)) {
                let codeAction = {
                  title: action.title,
                  command: action,
                  clientId
                };
                res.push(codeAction);
              } else {
                if (context.only) {
                  if (!action.kind)
                    continue;
                  let found = false;
                  for (let only of context.only) {
                    if (action.kind.startsWith(only)) {
                      found = true;
                      break;
                    }
                  }
                  if (!found)
                    continue;
                }
                let idx = res.findIndex((o) => o.title == action.title);
                if (idx == -1)
                  res.push(Object.assign({ clientId }, action));
              }
            }
          });
        }));
        return res;
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/codeLensManager.ts
var import_vscode_languageserver_protocol21, CodeLensManager;
var init_codeLensManager = __esm({
  "src/provider/codeLensManager.ts"() {
    import_vscode_languageserver_protocol21 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    init_lodash();
    CodeLensManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol21.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideCodeLenses(document2, token) {
        let providers = this.getProviders(document2);
        if (!providers.length)
          return null;
        let arr = await Promise.all(providers.map((item) => {
          let { provider, id } = item;
          return Promise.resolve(provider.provideCodeLenses(document2, token)).then((res) => {
            if (Array.isArray(res)) {
              for (let item2 of res) {
                item2.source = id;
              }
            }
            return res || [];
          });
        }));
        return [].concat(...arr);
      }
      async resolveCodeLens(codeLens, token) {
        if (codeLens.command)
          return codeLens;
        let { source } = codeLens;
        let provider = this.poviderById(source);
        if (!provider || typeof provider.resolveCodeLens != "function") {
          return codeLens;
        }
        let res = await Promise.resolve(provider.resolveCodeLens(omit(codeLens, ["source"]), token));
        Object.assign(codeLens, res);
        return codeLens;
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/declarationManager.ts
var import_vscode_languageserver_protocol22, logger37, DeclarationManager;
var init_declarationManager = __esm({
  "src/provider/declarationManager.ts"() {
    import_vscode_languageserver_protocol22 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    logger37 = require_logger2()("definitionManager");
    DeclarationManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol22.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideDeclaration(document2, position, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDeclaration(document2, position, token));
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/definitionManager.ts
var import_vscode_languageserver_protocol23, logger38, DefinitionManager;
var init_definitionManager = __esm({
  "src/provider/definitionManager.ts"() {
    import_vscode_languageserver_protocol23 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    logger38 = require_logger2()("definitionManager");
    DefinitionManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol23.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideDefinition(document2, position, token) {
        let providers = this.getProviders(document2);
        if (!providers.length)
          return null;
        let arr = await Promise.all(providers.map((item) => {
          let { provider } = item;
          return Promise.resolve(provider.provideDefinition(document2, position, token));
        }));
        return this.toLocations(arr);
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/documentColorManager.ts
var import_vscode_languageserver_protocol24, DocumentColorManager;
var init_documentColorManager = __esm({
  "src/provider/documentColorManager.ts"() {
    import_vscode_languageserver_protocol24 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    DocumentColorManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol24.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideDocumentColors(document2, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        let res = await Promise.resolve(provider.provideDocumentColors(document2, token));
        return res;
      }
      async provideColorPresentations(colorInformation, document2, token) {
        let { range, color } = colorInformation;
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        let res = await Promise.resolve(provider.provideColorPresentations(color, { document: document2, range }, token));
        return res;
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/documentHighlightManager.ts
var import_vscode_languageserver_protocol25, DocumentHighlightManager;
var init_documentHighlightManager = __esm({
  "src/provider/documentHighlightManager.ts"() {
    import_vscode_languageserver_protocol25 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    DocumentHighlightManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol25.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideDocumentHighlights(document2, position, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentHighlights(document2, position, token));
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/documentLinkManager.ts
var import_vscode_languageserver_protocol26, DocumentLinkManager;
var init_documentLinkManager = __esm({
  "src/provider/documentLinkManager.ts"() {
    import_vscode_languageserver_protocol26 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    DocumentLinkManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol26.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async _provideDocumentLinks(item, document2, token) {
        let { provider, id } = item;
        let items = await Promise.resolve(provider.provideDocumentLinks(document2, token));
        if (!items || !items.length)
          return [];
        items.forEach((item2) => {
          item2.data = item2.data || {};
          item2.data.source = id;
        });
        return items;
      }
      async provideDocumentLinks(document2, token) {
        let items = this.getProviders(document2);
        if (items.length == 0)
          return [];
        const arr = await Promise.all(items.map((item) => this._provideDocumentLinks(item, document2, token)));
        return [].concat(...arr);
      }
      async resolveDocumentLink(link, token) {
        let { data } = link;
        if (!data || !data.source)
          return null;
        for (let item of this.providers) {
          if (item.id == data.source) {
            let { provider } = item;
            link = await Promise.resolve(provider.resolveDocumentLink(link, token));
            return link;
          }
        }
        return null;
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/documentSymbolManager.ts
var import_vscode_languageserver_protocol27, DocumentSymbolManager;
var init_documentSymbolManager = __esm({
  "src/provider/documentSymbolManager.ts"() {
    import_vscode_languageserver_protocol27 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    DocumentSymbolManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol27.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideDocumentSymbols(document2, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentSymbols(document2, token)) || [];
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/foldingRangeManager.ts
var import_vscode_languageserver_protocol28, FoldingRangeManager;
var init_foldingRangeManager = __esm({
  "src/provider/foldingRangeManager.ts"() {
    import_vscode_languageserver_protocol28 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    FoldingRangeManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol28.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideFoldingRanges(document2, context, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideFoldingRanges(document2, context, token)) || [];
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/formatManager.ts
var import_vscode_languageserver_protocol29, FormatManager;
var init_formatManager = __esm({
  "src/provider/formatManager.ts"() {
    import_vscode_languageserver_protocol29 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    FormatManager = class extends Manager {
      register(selector, provider, priority = 0) {
        let item = {
          id: v4_default(),
          selector,
          priority,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol29.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      handles(doc) {
        return this.getProvider(doc) != null;
      }
      async provideDocumentFormattingEdits(document2, options, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentFormattingEdits(document2, options, token));
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/formatRangeManager.ts
var import_vscode_languageserver_protocol30, FormatRangeManager;
var init_formatRangeManager = __esm({
  "src/provider/formatRangeManager.ts"() {
    import_vscode_languageserver_protocol30 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    FormatRangeManager = class extends Manager {
      register(selector, provider, priority = 0) {
        let item = {
          id: v4_default(),
          selector,
          provider,
          priority
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol30.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideDocumentRangeFormattingEdits(document2, range, options, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentRangeFormattingEdits(document2, range, options, token));
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/hoverManager.ts
var import_vscode_languageserver_protocol31, HoverManager;
var init_hoverManager = __esm({
  "src/provider/hoverManager.ts"() {
    import_vscode_languageserver_protocol31 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    HoverManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol31.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideHover(document2, position, token) {
        let items = this.getProviders(document2);
        if (items.length === 0)
          return null;
        let res = [];
        for (let i = 0, len = items.length; i < len; i += 1) {
          const item = items[i];
          let hover = await Promise.resolve(item.provider.provideHover(document2, position, token));
          if (hover && hover.contents != "")
            res.push(hover);
        }
        return res;
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/implementationManager.ts
var import_vscode_languageserver_protocol32, ImplementationManager;
var init_implementationManager = __esm({
  "src/provider/implementationManager.ts"() {
    import_vscode_languageserver_protocol32 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    ImplementationManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol32.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideReferences(document2, position, token) {
        let providers = this.getProviders(document2);
        if (!providers.length)
          return null;
        let arr = await Promise.all(providers.map((item) => {
          let { provider } = item;
          return Promise.resolve(provider.provideImplementation(document2, position, token));
        }));
        return this.toLocations(arr);
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/onTypeFormatManager.ts
var import_vscode_languageserver_protocol33, logger39, OnTypeFormatManager;
var init_onTypeFormatManager = __esm({
  "src/provider/onTypeFormatManager.ts"() {
    import_vscode_languageserver_protocol33 = __toModule(require_main2());
    init_workspace();
    logger39 = require_logger2()("onTypeFormatManager");
    OnTypeFormatManager = class {
      constructor() {
        this.providers = new Set();
      }
      register(selector, provider, triggerCharacters) {
        let item = {
          triggerCharacters,
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol33.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      hasProvider(document2) {
        for (let o of this.providers) {
          let { selector } = o;
          if (workspace_default.match(selector, document2) > 0) {
            return true;
          }
        }
        return false;
      }
      getProvider(document2, triggerCharacter) {
        for (let o of this.providers) {
          let { triggerCharacters, selector } = o;
          if (workspace_default.match(selector, document2) > 0 && triggerCharacters.includes(triggerCharacter)) {
            return o.provider;
          }
        }
        return null;
      }
      async onCharacterType(character, document2, position, token) {
        let provider = this.getProvider(document2, character);
        if (!provider)
          return;
        let formatOpts = await workspace_default.getFormatOptions(document2.uri);
        return await Promise.resolve(provider.provideOnTypeFormattingEdits(document2, position, character, formatOpts, token));
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/selectionRangeManager.ts
var import_vscode_languageserver_protocol34, SelectionRangeManager;
var init_selectionRangeManager = __esm({
  "src/provider/selectionRangeManager.ts"() {
    import_vscode_languageserver_protocol34 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    SelectionRangeManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol34.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideSelectionRanges(document2, positions2, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideSelectionRanges(document2, positions2, token)) || [];
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/referenceManager.ts
var import_vscode_languageserver_protocol35, ReferenceManager;
var init_referenceManager = __esm({
  "src/provider/referenceManager.ts"() {
    import_vscode_languageserver_protocol35 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    ReferenceManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol35.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideReferences(document2, position, context, token) {
        let providers = this.getProviders(document2);
        if (!providers.length)
          return null;
        let arr = await Promise.all(providers.map((item) => {
          let { provider } = item;
          return Promise.resolve(provider.provideReferences(document2, position, context, token));
        }));
        return this.toLocations(arr);
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/renameManager.ts
var import_vscode_languageserver_protocol36, RenameManager;
var init_renameManager = __esm({
  "src/provider/renameManager.ts"() {
    import_vscode_languageserver_protocol36 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    RenameManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol36.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideRenameEdits(document2, position, newName, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideRenameEdits(document2, position, newName, token));
      }
      async prepareRename(document2, position, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        if (provider.prepareRename == null)
          return null;
        let res = await Promise.resolve(provider.prepareRename(document2, position, token));
        if (res == null)
          return false;
        return res;
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/signatureManager.ts
var import_vscode_languageserver_protocol37, SignatureManager;
var init_signatureManager = __esm({
  "src/provider/signatureManager.ts"() {
    import_vscode_languageserver_protocol37 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    SignatureManager = class extends Manager {
      register(selector, provider, triggerCharacters) {
        let characters = triggerCharacters.reduce((p, c) => p.concat(c.split(/\s*/g)), []);
        let item = {
          id: v4_default(),
          selector,
          provider,
          triggerCharacters: characters
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol37.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      shouldTrigger(document2, triggerCharacter) {
        let item = this.getProvider(document2);
        if (!item)
          return false;
        let { triggerCharacters } = item;
        return triggerCharacters && triggerCharacters.indexOf(triggerCharacter) != -1;
      }
      async provideSignatureHelp(document2, position, token, context) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let res = await Promise.resolve(item.provider.provideSignatureHelp(document2, position, token, context));
        if (res && res.signatures && res.signatures.length)
          return res;
        return null;
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/typeDefinitionManager.ts
var import_vscode_languageserver_protocol38, TypeDefinitionManager;
var init_typeDefinitionManager = __esm({
  "src/provider/typeDefinitionManager.ts"() {
    import_vscode_languageserver_protocol38 = __toModule(require_main2());
    init_manager2();
    init_esm_node();
    TypeDefinitionManager = class extends Manager {
      register(selector, provider) {
        let item = {
          id: v4_default(),
          selector,
          provider
        };
        this.providers.add(item);
        return import_vscode_languageserver_protocol38.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      async provideTypeDefinition(document2, position, token) {
        let providers = this.getProviders(document2);
        if (!providers.length)
          return null;
        let arr = await Promise.all(providers.map((item) => {
          let { provider } = item;
          return Promise.resolve(provider.provideTypeDefinition(document2, position, token));
        }));
        return this.toLocations(arr);
      }
      dispose() {
        this.providers = new Set();
      }
    };
  }
});

// src/provider/workspaceSymbolsManager.ts
var import_vscode_languageserver_protocol39, WorkspaceSymbolManager;
var init_workspaceSymbolsManager = __esm({
  "src/provider/workspaceSymbolsManager.ts"() {
    init_esm_node();
    import_vscode_languageserver_protocol39 = __toModule(require_main2());
    WorkspaceSymbolManager = class {
      constructor() {
        this.providers = new Map();
      }
      register(provider) {
        let id = v4_default();
        this.providers.set(id, provider);
        return import_vscode_languageserver_protocol39.Disposable.create(() => {
          this.providers.delete(id);
        });
      }
      async provideWorkspaceSymbols(query, token) {
        let entries = Array.from(this.providers.entries());
        if (!entries.length)
          return [];
        let res = [];
        await Promise.all(entries.map((o) => {
          let [id, p] = o;
          return Promise.resolve(p.provideWorkspaceSymbols(query, token)).then((item) => {
            if (item) {
              item.source = id;
              res.push(...item);
            }
          });
        }));
        return res;
      }
      async resolveWorkspaceSymbol(symbolInfo, token) {
        let provider = this.providers.get(symbolInfo.source);
        if (!provider)
          return;
        if (typeof provider.resolveWorkspaceSymbol != "function") {
          return Promise.resolve(symbolInfo);
        }
        return await Promise.resolve(provider.resolveWorkspaceSymbol(symbolInfo, token));
      }
      hasProvider() {
        return this.providers.size > 0;
      }
      dispose() {
        this.providers = new Map();
      }
    };
  }
});

// src/util/complete.ts
function getPosition(opt) {
  let { line, linenr, colnr } = opt;
  let part = byteSlice(line, 0, colnr - 1);
  return {
    line: linenr - 1,
    character: part.length
  };
}
function getWord(item, opt, invalidInsertCharacters) {
  let { label, data, insertTextFormat, insertText, textEdit } = item;
  let word;
  let newText;
  if (data && typeof data.word === "string")
    return data.word;
  if (textEdit) {
    let { range } = textEdit;
    newText = textEdit.newText;
    if (range && range.start.line == range.end.line) {
      let { line, col, colnr } = opt;
      let character = characterIndex(line, col);
      if (range.start.character > character) {
        let before = line.slice(character, range.start.character);
        newText = before + newText;
      } else {
        let start = line.slice(range.start.character, character);
        if (start.length && newText.startsWith(start)) {
          newText = newText.slice(start.length);
        }
      }
      character = characterIndex(line, colnr - 1);
      if (range.end.character > character) {
        let end = line.slice(character, range.end.character);
        if (newText.endsWith(end)) {
          newText = newText.slice(0, -end.length);
        }
      }
    }
  } else {
    newText = insertText;
  }
  if (insertTextFormat == import_vscode_languageserver_protocol40.InsertTextFormat.Snippet && newText && newText.includes("$")) {
    let parser2 = new SnippetParser();
    let text = parser2.text(newText);
    word = text ? getValidWord(text, invalidInsertCharacters) : label;
  } else {
    word = getValidWord(newText, invalidInsertCharacters) || label;
  }
  return word || "";
}
function completionKindString(kind, map, defaultValue = "") {
  return map.get(kind) || defaultValue;
}
function getValidWord(text, invalidChars) {
  if (!text)
    return "";
  for (let i = 0; i < text.length; i++) {
    let c = text[i];
    if (invalidChars.includes(c)) {
      return text.slice(0, i);
    }
  }
  return text;
}
var import_vscode_languageserver_protocol40, logger40;
var init_complete = __esm({
  "src/util/complete.ts"() {
    import_vscode_languageserver_protocol40 = __toModule(require_main2());
    init_parser2();
    init_string();
    logger40 = require_logger2()("util-complete");
  }
});

// src/languages.ts
var import_vscode_languageserver_protocol41, logger41, Languages, languages_default;
var init_languages = __esm({
  "src/languages.ts"() {
    import_vscode_languageserver_protocol41 = __toModule(require_main2());
    init_commands2();
    init_manager();
    init_codeActionmanager();
    init_codeLensManager();
    init_declarationManager();
    init_definitionManager();
    init_documentColorManager();
    init_documentHighlightManager();
    init_documentLinkManager();
    init_documentSymbolManager();
    init_foldingRangeManager();
    init_formatManager();
    init_formatRangeManager();
    init_hoverManager();
    init_implementationManager();
    init_onTypeFormatManager();
    init_selectionRangeManager();
    init_referenceManager();
    init_renameManager();
    init_signatureManager();
    init_typeDefinitionManager();
    init_workspaceSymbolsManager();
    init_manager4();
    init_sources2();
    init_types();
    init_complete();
    init_position();
    init_string();
    init_window();
    init_workspace();
    logger41 = require_logger2()("languages");
    Languages = class {
      constructor() {
        this.onTypeFormatManager = new OnTypeFormatManager();
        this.documentLinkManager = new DocumentLinkManager();
        this.documentColorManager = new DocumentColorManager();
        this.foldingRangeManager = new FoldingRangeManager();
        this.renameManager = new RenameManager();
        this.formatManager = new FormatManager();
        this.codeActionManager = new CodeActionManager();
        this.workspaceSymbolsManager = new WorkspaceSymbolManager();
        this.formatRangeManager = new FormatRangeManager();
        this.hoverManager = new HoverManager();
        this.signatureManager = new SignatureManager();
        this.documentSymbolManager = new DocumentSymbolManager();
        this.documentHighlightManager = new DocumentHighlightManager();
        this.definitionManager = new DefinitionManager();
        this.declarationManager = new DeclarationManager();
        this.typeDefinitionManager = new TypeDefinitionManager();
        this.referenceManager = new ReferenceManager();
        this.implementationManager = new ImplementationManager();
        this.codeLensManager = new CodeLensManager();
        this.selectionRangeManager = new SelectionRangeManager();
        this.cancelTokenSource = new import_vscode_languageserver_protocol41.CancellationTokenSource();
      }
      init() {
        this.loadCompleteConfig();
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("suggest")) {
            this.loadCompleteConfig();
          }
        }, this);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      get detailField() {
        let { detailField, floatEnable } = this.completeConfig;
        if (detailField == "preview" && (!floatEnable || !workspace_default.floatSupported)) {
          return "menu";
        }
        return "preview";
      }
      loadCompleteConfig() {
        let suggest = workspace_default.getConfiguration("suggest");
        let labels = suggest.get("completionItemKindLabels", {});
        this.completionItemKindMap = new Map([
          [import_vscode_languageserver_protocol41.CompletionItemKind.Text, labels["text"] || "v"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Method, labels["method"] || "f"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Function, labels["function"] || "f"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Constructor, typeof labels["constructor"] == "function" ? "f" : labels["constructor"]],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Field, labels["field"] || "m"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Variable, labels["variable"] || "v"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Class, labels["class"] || "C"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Interface, labels["interface"] || "I"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Module, labels["module"] || "M"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Property, labels["property"] || "m"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Unit, labels["unit"] || "U"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Value, labels["value"] || "v"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Enum, labels["enum"] || "E"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Keyword, labels["keyword"] || "k"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Snippet, labels["snippet"] || "S"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Color, labels["color"] || "v"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.File, labels["file"] || "F"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Reference, labels["reference"] || "r"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Folder, labels["folder"] || "F"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.EnumMember, labels["enumMember"] || "m"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Constant, labels["constant"] || "v"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Struct, labels["struct"] || "S"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Event, labels["event"] || "E"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.Operator, labels["operator"] || "O"],
          [import_vscode_languageserver_protocol41.CompletionItemKind.TypeParameter, labels["typeParameter"] || "T"]
        ]);
        this.completeConfig = {
          defaultKindText: labels["default"] || "",
          priority: suggest.get("languageSourcePriority", 99),
          echodocSupport: suggest.get("echodocSupport", false),
          snippetsSupport: suggest.get("snippetsSupport", true),
          detailField: suggest.get("detailField", "preview"),
          detailMaxLength: suggest.get("detailMaxLength", 100),
          floatEnable: suggest.get("floatEnable", true),
          invalidInsertCharacters: suggest.get("invalidInsertCharacters", ["(", "<", "{", "[", "\r", "\n"])
        };
      }
      hasFormatProvider(doc) {
        if (this.formatManager.hasProvider(doc)) {
          return true;
        }
        if (this.formatRangeManager.hasProvider(doc)) {
          return true;
        }
        return false;
      }
      registerOnTypeFormattingEditProvider(selector, provider, triggerCharacters) {
        return this.onTypeFormatManager.register(selector, provider, triggerCharacters);
      }
      registerCompletionItemProvider(name2, shortcut, selector, provider, triggerCharacters = [], priority, allCommitCharacters) {
        selector = typeof selector == "string" ? [selector] : selector;
        let source = this.createCompleteSource(name2, shortcut, provider, selector, triggerCharacters, allCommitCharacters || [], priority);
        sources_default.addSource(source);
        logger41.debug("created service source", name2);
        return {
          dispose: () => {
            sources_default.removeSource(name2);
          }
        };
      }
      registerCodeActionProvider(selector, provider, clientId, codeActionKinds) {
        return this.codeActionManager.register(selector, provider, clientId, codeActionKinds);
      }
      registerHoverProvider(selector, provider) {
        return this.hoverManager.register(selector, provider);
      }
      registerSelectionRangeProvider(selector, provider) {
        return this.selectionRangeManager.register(selector, provider);
      }
      registerSignatureHelpProvider(selector, provider, triggerCharacters) {
        return this.signatureManager.register(selector, provider, triggerCharacters);
      }
      registerDocumentSymbolProvider(selector, provider) {
        return this.documentSymbolManager.register(selector, provider);
      }
      registerFoldingRangeProvider(selector, provider) {
        return this.foldingRangeManager.register(selector, provider);
      }
      registerDocumentHighlightProvider(selector, provider) {
        return this.documentHighlightManager.register(selector, provider);
      }
      registerCodeLensProvider(selector, provider) {
        return this.codeLensManager.register(selector, provider);
      }
      registerDocumentLinkProvider(selector, provider) {
        return this.documentLinkManager.register(selector, provider);
      }
      registerDocumentColorProvider(selector, provider) {
        return this.documentColorManager.register(selector, provider);
      }
      registerDefinitionProvider(selector, provider) {
        return this.definitionManager.register(selector, provider);
      }
      registerDeclarationProvider(selector, provider) {
        return this.declarationManager.register(selector, provider);
      }
      registerTypeDefinitionProvider(selector, provider) {
        return this.typeDefinitionManager.register(selector, provider);
      }
      registerImplementationProvider(selector, provider) {
        return this.implementationManager.register(selector, provider);
      }
      registerReferencesProvider(selector, provider) {
        return this.referenceManager.register(selector, provider);
      }
      registerRenameProvider(selector, provider) {
        return this.renameManager.register(selector, provider);
      }
      registerWorkspaceSymbolProvider(provider) {
        if (arguments.length > 1 && typeof arguments[1].provideWorkspaceSymbols === "function") {
          provider = arguments[1];
        }
        return this.workspaceSymbolsManager.register(provider);
      }
      registerDocumentFormatProvider(selector, provider, priority = 0) {
        return this.formatManager.register(selector, provider, priority);
      }
      registerDocumentRangeFormatProvider(selector, provider, priority = 0) {
        return this.formatRangeManager.register(selector, provider, priority);
      }
      shouldTriggerSignatureHelp(document2, triggerCharacter) {
        return this.signatureManager.shouldTrigger(document2, triggerCharacter);
      }
      async getHover(document2, position, token) {
        return await this.hoverManager.provideHover(document2, position, token);
      }
      async getSignatureHelp(document2, position, token, context) {
        return await this.signatureManager.provideSignatureHelp(document2, position, token, context);
      }
      async getDefinition(document2, position, token) {
        if (!this.definitionManager.hasProvider(document2))
          return null;
        return await this.definitionManager.provideDefinition(document2, position, token);
      }
      async getDeclaration(document2, position, token) {
        if (!this.declarationManager.hasProvider(document2))
          return null;
        return await this.declarationManager.provideDeclaration(document2, position, token);
      }
      async getTypeDefinition(document2, position, token) {
        if (!this.typeDefinitionManager.hasProvider(document2))
          return null;
        return await this.typeDefinitionManager.provideTypeDefinition(document2, position, token);
      }
      async getImplementation(document2, position, token) {
        if (!this.implementationManager.hasProvider(document2))
          return null;
        return await this.implementationManager.provideReferences(document2, position, token);
      }
      async getReferences(document2, context, position, token) {
        if (!this.referenceManager.hasProvider(document2))
          return null;
        return await this.referenceManager.provideReferences(document2, position, context, token);
      }
      async getDocumentSymbol(document2, token) {
        return await this.documentSymbolManager.provideDocumentSymbols(document2, token);
      }
      async getSelectionRanges(document2, positions2, token) {
        return await this.selectionRangeManager.provideSelectionRanges(document2, positions2, token);
      }
      async getWorkspaceSymbols(query, token) {
        query = query || "";
        return await this.workspaceSymbolsManager.provideWorkspaceSymbols(query, token);
      }
      async resolveWorkspaceSymbol(symbol, token) {
        return await this.workspaceSymbolsManager.resolveWorkspaceSymbol(symbol, token);
      }
      async prepareRename(document2, position, token) {
        return await this.renameManager.prepareRename(document2, position, token);
      }
      async provideRenameEdits(document2, position, newName, token) {
        return await this.renameManager.provideRenameEdits(document2, position, newName, token);
      }
      async provideDocumentFormattingEdits(document2, options, token) {
        if (!this.formatManager.hasProvider(document2)) {
          let hasRangeFormater = this.formatRangeManager.hasProvider(document2);
          if (!hasRangeFormater)
            return null;
          let end = document2.positionAt(document2.getText().length);
          let range = import_vscode_languageserver_protocol41.Range.create(import_vscode_languageserver_protocol41.Position.create(0, 0), end);
          return await this.provideDocumentRangeFormattingEdits(document2, range, options, token);
        }
        return await this.formatManager.provideDocumentFormattingEdits(document2, options, token);
      }
      async provideDocumentRangeFormattingEdits(document2, range, options, token) {
        if (!this.formatRangeManager.hasProvider(document2))
          return null;
        return await this.formatRangeManager.provideDocumentRangeFormattingEdits(document2, range, options, token);
      }
      async getCodeActions(document2, range, context, token) {
        return await this.codeActionManager.provideCodeActions(document2, range, context, token);
      }
      async getDocumentHighLight(document2, position, token) {
        return await this.documentHighlightManager.provideDocumentHighlights(document2, position, token);
      }
      async getDocumentLinks(document2, token) {
        if (!this.documentLinkManager.hasProvider(document2)) {
          return null;
        }
        return await this.documentLinkManager.provideDocumentLinks(document2, token) || [];
      }
      async resolveDocumentLink(link) {
        return await this.documentLinkManager.resolveDocumentLink(link, this.token);
      }
      async provideDocumentColors(document2, token) {
        return await this.documentColorManager.provideDocumentColors(document2, token);
      }
      async provideFoldingRanges(document2, context, token) {
        if (!this.foldingRangeManager.hasProvider(document2)) {
          return null;
        }
        return await this.foldingRangeManager.provideFoldingRanges(document2, context, token);
      }
      async provideColorPresentations(color, document2, token) {
        return await this.documentColorManager.provideColorPresentations(color, document2, token);
      }
      async getCodeLens(document2, token) {
        return await this.codeLensManager.provideCodeLenses(document2, token);
      }
      async resolveCodeLens(codeLens, token) {
        return await this.codeLensManager.resolveCodeLens(codeLens, token);
      }
      async provideDocumentOnTypeEdits(character, document2, position, token) {
        return this.onTypeFormatManager.onCharacterType(character, document2, position, token);
      }
      hasOnTypeProvider(character, document2) {
        return this.onTypeFormatManager.getProvider(document2, character) != null;
      }
      hasProvider(id, document2) {
        switch (id) {
          case "rename":
            return this.renameManager.hasProvider(document2);
          case "onTypeEdit":
            return this.onTypeFormatManager.hasProvider(document2);
          case "documentLink":
            return this.documentLinkManager.hasProvider(document2);
          case "documentColor":
            return this.documentColorManager.hasProvider(document2);
          case "foldingRange":
            return this.foldingRangeManager.hasProvider(document2);
          case "format":
            return this.formatManager.hasProvider(document2) || this.formatRangeManager.hasProvider(document2);
          case "codeAction":
            return this.codeActionManager.hasProvider(document2);
          case "workspaceSymbols":
            return this.workspaceSymbolsManager.hasProvider();
          case "formatRange":
            return this.formatRangeManager.hasProvider(document2);
          case "hover":
            return this.hoverManager.hasProvider(document2);
          case "signature":
            return this.signatureManager.hasProvider(document2);
          case "documentSymbol":
            return this.documentSymbolManager.hasProvider(document2);
          case "documentHighlight":
            return this.documentHighlightManager.hasProvider(document2);
          case "definition":
            return this.definitionManager.hasProvider(document2);
          case "declaration":
            return this.declarationManager.hasProvider(document2);
          case "typeDefinition":
            return this.typeDefinitionManager.hasProvider(document2);
          case "reference":
            return this.referenceManager.hasProvider(document2);
          case "implementation":
            return this.implementationManager.hasProvider(document2);
          case "codeLens":
            return this.codeLensManager.hasProvider(document2);
          case "selectionRange":
            return this.selectionRangeManager.hasProvider(document2);
          default:
            throw new Error(`${id} not supported.`);
        }
      }
      dispose() {
      }
      createDiagnosticCollection(owner) {
        return manager_default.create(owner);
      }
      createCompleteSource(name2, shortcut, provider, selector, triggerCharacters, allCommitCharacters, priority) {
        let completeItems = [];
        let hasResolve = typeof provider.resolveCompletionItem === "function";
        priority = priority == null ? this.completeConfig.priority : priority;
        let resolvedIndexes = new Set();
        let source = {
          name: name2,
          priority,
          shortcut,
          enable: true,
          sourceType: SourceType.Service,
          documentSelector: selector,
          triggerCharacters: triggerCharacters || [],
          toggle: () => {
            source.enable = !source.enable;
          },
          doComplete: async (opt, token) => {
            let { triggerCharacter, bufnr } = opt;
            resolvedIndexes = new Set();
            let isTrigger = triggerCharacters && triggerCharacters.includes(triggerCharacter);
            let triggerKind = import_vscode_languageserver_protocol41.CompletionTriggerKind.Invoked;
            if (opt.triggerForInComplete) {
              triggerKind = import_vscode_languageserver_protocol41.CompletionTriggerKind.TriggerForIncompleteCompletions;
            } else if (isTrigger) {
              triggerKind = import_vscode_languageserver_protocol41.CompletionTriggerKind.TriggerCharacter;
            }
            if (token.isCancellationRequested)
              return null;
            let position = getPosition(opt);
            let context = { triggerKind, option: opt };
            if (isTrigger)
              context.triggerCharacter = triggerCharacter;
            let result;
            try {
              let doc = workspace_default.getDocument(bufnr);
              result = await Promise.resolve(provider.provideCompletionItems(doc.textDocument, position, token, context));
            } catch (e) {
              logger41.error(`Complete "${name2}" error:`, e);
              return null;
            }
            if (!result || token.isCancellationRequested)
              return null;
            completeItems = Array.isArray(result) ? result : result.items;
            if (!completeItems || completeItems.length == 0)
              return null;
            let startcol = this.getStartColumn(opt.line, completeItems);
            let option = Object.assign({}, opt);
            let prefix;
            if (startcol != null) {
              if (startcol < option.col) {
                prefix = byteSlice(opt.line, startcol, option.col);
              }
              option.col = startcol;
            }
            let items = completeItems.map((o, index) => {
              let item = this.convertVimCompleteItem(o, shortcut, option, prefix);
              item.index = index;
              return item;
            });
            return {
              startcol,
              isIncomplete: !!result.isIncomplete,
              items
            };
          },
          onCompleteResolve: async (item, token) => {
            let resolving = completeItems[item.index];
            if (!resolving)
              return;
            if (hasResolve && !resolvedIndexes.has(item.index)) {
              let resolved = await Promise.resolve(provider.resolveCompletionItem(resolving, token));
              if (token.isCancellationRequested)
                return;
              resolvedIndexes.add(item.index);
              if (resolved)
                Object.assign(resolving, resolved);
            }
            if (item.documentation == null) {
              let { documentation, detail } = resolving;
              if (!documentation && !detail)
                return;
              let docs = [];
              if (detail && !item.detailShown && detail != item.word) {
                detail = detail.replace(/\n\s*/g, " ");
                if (detail.length) {
                  let isText = /^[\w-\s.,\t]+$/.test(detail);
                  let filetype = isText ? "txt" : await workspace_default.nvim.eval("&filetype");
                  docs.push({ filetype: isText ? "txt" : filetype, content: detail });
                }
              }
              if (documentation) {
                if (typeof documentation == "string") {
                  docs.push({
                    filetype: "markdown",
                    content: documentation
                  });
                } else if (documentation.value) {
                  docs.push({
                    filetype: documentation.kind == "markdown" ? "markdown" : "txt",
                    content: documentation.value
                  });
                }
              }
              item.documentation = docs;
            }
          },
          onCompleteDone: async (vimItem, opt) => {
            let item = completeItems[vimItem.index];
            if (!item)
              return;
            let line = opt.linenr - 1;
            if (item.insertText != null && !item.textEdit) {
              item.textEdit = {
                range: import_vscode_languageserver_protocol41.Range.create(line, opt.col, line, opt.colnr - 1),
                newText: item.insertText
              };
            }
            if (vimItem.line)
              Object.assign(opt, { line: vimItem.line });
            try {
              let isSnippet = await this.applyTextEdit(item, vimItem.word, opt);
              let { additionalTextEdits } = item;
              if (additionalTextEdits && item.textEdit) {
                let r = item.textEdit.range;
                additionalTextEdits = additionalTextEdits.filter((edit2) => {
                  if (rangeOverlap(r, edit2.range)) {
                    logger41.error("Filtered overlap additionalTextEdit:", edit2);
                    return false;
                  }
                  return true;
                });
              }
              await this.applyAdditionalEdits(additionalTextEdits, opt.bufnr, isSnippet);
              if (isSnippet)
                await manager_default2.selectCurrentPlaceholder();
              if (item.command && commands_default.has(item.command.command)) {
                commands_default.execute(item.command);
              }
            } catch (e) {
              logger41.error("Error on CompleteDone:", e);
            }
          },
          shouldCommit: (item, character) => {
            let completeItem = completeItems[item.index];
            if (!completeItem)
              return false;
            let commitCharacters = completeItem.commitCharacters || allCommitCharacters;
            return commitCharacters.includes(character);
          }
        };
        return source;
      }
      get token() {
        this.cancelTokenSource = new import_vscode_languageserver_protocol41.CancellationTokenSource();
        return this.cancelTokenSource.token;
      }
      async applyTextEdit(item, word, option) {
        let { nvim } = this;
        let { textEdit } = item;
        if (!textEdit)
          return false;
        let { line, bufnr, linenr } = option;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return false;
        let { range, newText } = textEdit;
        let isSnippet = item.insertTextFormat === import_vscode_languageserver_protocol41.InsertTextFormat.Snippet;
        let start = line.substr(0, range.start.character);
        let end = line.substr(range.end.character);
        if (isSnippet && this.completeConfig.snippetsSupport === false) {
          isSnippet = false;
          newText = word;
        }
        if (isSnippet) {
          let currline = doc.getline(linenr - 1);
          let endCharacter = currline.length - end.length;
          let r = import_vscode_languageserver_protocol41.Range.create(linenr - 1, range.start.character, linenr - 1, endCharacter);
          return await manager_default2.insertSnippet(newText, false, r);
        }
        let newLines = `${start}${newText}${end}`.split(/\r?\n/);
        if (newLines.length == 1) {
          await nvim.call("coc#util#setline", [linenr, newLines[0]]);
          await window_default.moveTo(import_vscode_languageserver_protocol41.Position.create(linenr - 1, (start + newText).length));
        } else {
          let buffer = nvim.createBuffer(bufnr);
          await buffer.setLines(newLines, {
            start: linenr - 1,
            end: linenr,
            strictIndexing: false
          });
          let line2 = linenr - 1 + newLines.length - 1;
          let character = newLines[newLines.length - 1].length - end.length;
          await window_default.moveTo({ line: line2, character });
        }
        return false;
      }
      async applyAdditionalEdits(textEdits, bufnr, snippet) {
        if (!textEdits || textEdits.length == 0)
          return;
        let document2 = workspace_default.getDocument(bufnr);
        if (!document2)
          return;
        await document2.patchChange(true);
        let changed = null;
        let pos = await window_default.getCursorPosition();
        if (!snippet)
          changed = getChangedFromEdits(pos, textEdits);
        await document2.applyEdits(textEdits);
        if (changed)
          await window_default.moveTo(import_vscode_languageserver_protocol41.Position.create(pos.line + changed.line, pos.character + changed.character));
      }
      getStartColumn(line, items) {
        let first = items[0];
        if (!first.textEdit)
          return null;
        let { range, newText } = first.textEdit;
        let { character } = range.start;
        if (newText.length < range.end.character - character) {
          return null;
        }
        for (let i = 0; i < 10; i++) {
          let o = items[i];
          if (!o)
            break;
          if (!o.textEdit)
            return null;
          if (o.textEdit.range.start.character !== character)
            return null;
        }
        return byteIndex(line, character);
      }
      convertVimCompleteItem(item, shortcut, opt, prefix) {
        var _a2;
        let { echodocSupport, detailMaxLength, invalidInsertCharacters } = this.completeConfig;
        let { detailField } = this;
        let hasAdditionalEdit = item.additionalTextEdits && item.additionalTextEdits.length > 0;
        let isSnippet = item.insertTextFormat === import_vscode_languageserver_protocol41.InsertTextFormat.Snippet || hasAdditionalEdit;
        let label = item.label.trim();
        let obj = {
          word: getWord(item, opt, invalidInsertCharacters),
          abbr: label,
          menu: `[${shortcut}]`,
          kind: completionKindString(item.kind, this.completionItemKindMap, this.completeConfig.defaultKindText),
          sortText: item.sortText || null,
          sourceScore: item["score"] || null,
          filterText: item.filterText || label,
          isSnippet,
          dup: item.data && item.data.dup == 0 ? 0 : 1
        };
        if (prefix) {
          if (!obj.filterText.startsWith(prefix)) {
            if (item.textEdit && item.textEdit.newText.startsWith(prefix)) {
              obj.filterText = item.textEdit.newText.split(/\r?\n/)[0];
            }
          }
          if (!item.textEdit && !obj.word.startsWith(prefix)) {
            obj.word = `${prefix}${obj.word}`;
          }
        }
        if (item && item.detail && detailField != "preview") {
          let detail = item.detail.replace(/\n\s*/g, " ");
          if (byteLength(detail) < detailMaxLength) {
            if (detailField == "menu") {
              obj.menu = `${detail} ${obj.menu}`;
            } else if (detailField == "abbr") {
              obj.abbr = `${obj.abbr} - ${detail}`;
            }
            obj.detailShown = 1;
          }
        }
        if (item.documentation) {
          obj.info = typeof item.documentation == "string" ? item.documentation : item.documentation.value;
        } else {
          obj.info = "";
        }
        if (obj.word == "")
          obj.empty = 1;
        if (item.textEdit)
          obj.line = opt.line;
        if (item.kind == import_vscode_languageserver_protocol41.CompletionItemKind.Folder && !obj.abbr.endsWith("/")) {
          obj.abbr = obj.abbr + "/";
        }
        if (echodocSupport && item.kind >= 2 && item.kind <= 4) {
          let fields = [item.detail || "", obj.abbr, obj.word];
          for (let s of fields) {
            if (s.includes("(")) {
              obj.signature = s;
              break;
            }
          }
        }
        if (item.preselect)
          obj.preselect = true;
        if ((_a2 = item.data) == null ? void 0 : _a2.optional)
          obj.abbr = obj.abbr + "?";
        return obj;
      }
    };
    languages_default = new Languages();
  }
});

// src/model/highligher.ts
var Highlighter;
var init_highligher = __esm({
  "src/model/highligher.ts"() {
    init_ansiparse();
    init_string();
    Highlighter = class {
      constructor(srcId = -1) {
        this.srcId = srcId;
        this.lines = [];
        this.highlights = [];
      }
      addLine(line, hlGroup) {
        if (line.includes("\n")) {
          for (let content of line.split(/\r?\n/)) {
            this.addLine(content, hlGroup);
          }
          return;
        }
        if (hlGroup) {
          this.highlights.push({
            line: this.lines.length,
            colStart: line.match(/^\s*/)[0].length,
            colEnd: byteLength(line),
            hlGroup
          });
        }
        if (line.includes("")) {
          let res = parseAnsiHighlights(line);
          for (let hl of res.highlights) {
            let { span, hlGroup: hlGroup2 } = hl;
            if (span[0] != span[1]) {
              this.highlights.push({
                line: this.lines.length,
                colStart: span[0],
                colEnd: span[1],
                hlGroup: hlGroup2
              });
            }
          }
          this.lines.push(res.line);
        } else {
          this.lines.push(line);
        }
      }
      addLines(lines) {
        this.lines.push(...lines);
      }
      addText(text, hlGroup) {
        let { lines } = this;
        let pre = lines[lines.length - 1] || "";
        if (hlGroup) {
          let colStart = byteLength(pre);
          this.highlights.push({
            line: lines.length ? lines.length - 1 : 0,
            colStart,
            colEnd: colStart + byteLength(text),
            hlGroup
          });
        }
        if (lines.length) {
          lines[lines.length - 1] = `${pre}${text}`;
        } else {
          lines.push(text);
        }
      }
      get length() {
        return this.lines.length;
      }
      getline(line) {
        return this.lines[line] || "";
      }
      render(buffer, start = 0, end = -1) {
        buffer.setLines(this.lines, { start, end, strictIndexing: false }, true);
        for (let item of this.highlights) {
          buffer.addHighlight({
            hlGroup: item.hlGroup,
            colStart: item.colStart,
            colEnd: item.colEnd == null ? -1 : item.colEnd,
            line: start + item.line,
            srcId: this.srcId
          }).logError();
        }
      }
    };
  }
});

// src/util/processes.ts
function terminate(process2, cwd) {
  if (process2.killed)
    return;
  if (isWindows3) {
    try {
      let options = {
        stdio: ["pipe", "pipe", "ignore"]
      };
      if (cwd) {
        options.cwd = cwd;
      }
      cp.execFileSync("taskkill", ["/T", "/F", "/PID", process2.pid.toString()], options);
      return true;
    } catch (err) {
      return false;
    }
  } else if (isLinux2 || isMacintosh2) {
    try {
      let filepath = (0, import_path15.join)(pluginRoot2, "bin/terminateProcess.sh");
      if (!import_fs14.default.existsSync(filepath)) {
        console.error(`"${filepath}" not found`);
        return false;
      }
      let result = cp.spawnSync(filepath, [process2.pid.toString()]);
      return result.error ? false : true;
    } catch (err) {
      return false;
    }
  } else {
    process2.kill("SIGKILL");
    return true;
  }
}
var cp, import_path15, import_fs14, isWindows3, isMacintosh2, isLinux2, pluginRoot2;
var init_processes = __esm({
  "src/util/processes.ts"() {
    cp = __toModule(require("child_process"));
    import_path15 = __toModule(require("path"));
    import_fs14 = __toModule(require("fs"));
    isWindows3 = process.platform === "win32";
    isMacintosh2 = process.platform === "darwin";
    isLinux2 = process.platform === "linux";
    pluginRoot2 = false ? resolve2(__dirname, "../..") : (0, import_path15.dirname)(__dirname);
  }
});

// src/language-client/progressPart.ts
var import_vscode_languageserver_protocol42, logger42, ProgressPart;
var init_progressPart = __esm({
  "src/language-client/progressPart.ts"() {
    import_vscode_languageserver_protocol42 = __toModule(require_main2());
    init_util();
    init_window();
    "use strict";
    logger42 = require_logger2()("language-client-progressPart");
    ProgressPart = class {
      constructor(client, token, done) {
        this.client = client;
        this.token = token;
        this.disposables = [];
        this._cancelled = false;
        this.statusBarItem = window_default.createStatusBarItem(99, { progress: true });
        this.disposables.push(client.onProgress(import_vscode_languageserver_protocol42.WorkDoneProgress.type, this.token, (value) => {
          switch (value.kind) {
            case "begin":
              this.begin(value);
              break;
            case "report":
              this.report(value);
              break;
            case "end":
              this.done(value.message);
              done && done(this);
              break;
          }
        }));
      }
      begin(params) {
        if (typeof this.title === "string")
          return;
        this.title = params.title;
        this.report(params);
      }
      report(params) {
        let statusBarItem = this.statusBarItem;
        let parts = [];
        if (this.title)
          parts.push(this.title);
        if (typeof params.percentage == "number")
          parts.push(params.percentage.toFixed(0) + "%");
        if (params.message)
          parts.push(params.message);
        statusBarItem.text = parts.join(" ");
        statusBarItem.show();
      }
      cancel() {
        if (this._cancelled)
          return;
        this._cancelled = true;
        disposeAll(this.disposables);
      }
      done(message) {
        if (this._cancelled)
          return;
        const statusBarItem = this.statusBarItem;
        statusBarItem.text = `${this.title} ${message || "finished"}`;
        setTimeout(() => {
          statusBarItem.dispose();
        }, 300);
        this.cancel();
      }
    };
  }
});

// src/language-client/utils/async.ts
var Delayer;
var init_async = __esm({
  "src/language-client/utils/async.ts"() {
    Delayer = class {
      constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = null;
        this.completionPromise = null;
        this.doResolve = null;
        this.task = null;
      }
      trigger(task, delay = this.defaultDelay) {
        this.task = task;
        this.cancelTimeout();
        if (!this.completionPromise) {
          this.completionPromise = new Promise((c, e) => {
            this.doResolve = c;
            this.doReject = e;
          }).then(() => {
            this.completionPromise = null;
            this.doResolve = null;
            const task2 = this.task;
            this.task = null;
            return task2();
          });
        }
        this.timeout = setTimeout(() => {
          this.timeout = null;
          this.doResolve(null);
        }, delay);
        return this.completionPromise;
      }
      isTriggered() {
        return this.timeout !== null;
      }
      cancel() {
        this.cancelTimeout();
        if (this.completionPromise) {
          this.doReject(new Error("Canceled"));
          this.completionPromise = null;
        }
      }
      cancelTimeout() {
        if (this.timeout !== null) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
      }
      dispose() {
        this.cancelTimeout();
      }
    };
  }
});

// src/language-client/utils/converter.ts
function convertToTextDocumentItem(document2) {
  return {
    uri: document2.uri,
    languageId: document2.languageId,
    version: document2.version,
    text: document2.getText()
  };
}
function asCloseTextDocumentParams(document2) {
  return {
    textDocument: {
      uri: document2.uri
    }
  };
}
function asChangeTextDocumentParams(document2) {
  let result = {
    textDocument: {
      uri: document2.uri,
      version: document2.version
    },
    contentChanges: [{ text: document2.getText() }]
  };
  return result;
}
function asWillSaveTextDocumentParams(event) {
  return {
    textDocument: asVersionedTextDocumentIdentifier(event.document),
    reason: event.reason
  };
}
function asVersionedTextDocumentIdentifier(textDocument) {
  return {
    uri: textDocument.uri,
    version: textDocument.version
  };
}
function asSaveTextDocumentParams(document2, includeText) {
  let result = {
    textDocument: asVersionedTextDocumentIdentifier(document2)
  };
  if (includeText) {
    result.text = document2.getText();
  }
  return result;
}
function asUri(resource) {
  return resource.toString();
}
function asCompletionParams(textDocument, position, context) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position,
    context: omit(context, ["option"])
  };
}
function asTextDocumentPositionParams(textDocument, position) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position
  };
}
function asSignatureHelpParams(textDocument, position, context) {
  return {
    textDocument: asTextDocumentIdentifier(textDocument),
    position,
    context
  };
}
function asTextDocumentIdentifier(textDocument) {
  return {
    uri: textDocument.uri
  };
}
function asReferenceParams(textDocument, position, options) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position,
    context: { includeDeclaration: options.includeDeclaration }
  };
}
function asDocumentSymbolParams(textDocument) {
  return {
    textDocument: {
      uri: textDocument.uri
    }
  };
}
function asCodeLensParams(textDocument) {
  return {
    textDocument: {
      uri: textDocument.uri
    }
  };
}
var init_converter = __esm({
  "src/language-client/utils/converter.ts"() {
    init_lodash();
  }
});

// src/language-client/utils/uuid.ts
function generateUuid() {
  return v4_default();
}
var init_uuid = __esm({
  "src/language-client/utils/uuid.ts"() {
    init_esm_node();
  }
});

// src/language-client/client.ts
function createConnection(input, output, errorHandler, closeHandler) {
  let logger96 = new ConsoleLogger();
  let connection = (0, import_vscode_languageserver_protocol43.createProtocolConnection)(input, output, logger96);
  connection.onError((data) => {
    errorHandler(data[0], data[1], data[2]);
  });
  connection.onClose(closeHandler);
  let result = {
    listen: () => connection.listen(),
    sendRequest: (type, ...params) => connection.sendRequest(string(type) ? type : type.method, ...params),
    onRequest: (type, handler) => connection.onRequest(string(type) ? type : type.method, handler),
    sendNotification: (type, params) => connection.sendNotification(string(type) ? type : type.method, params),
    onNotification: (type, handler) => connection.onNotification(string(type) ? type : type.method, handler),
    onProgress: connection.onProgress,
    sendProgress: connection.sendProgress,
    trace: (value, tracer, sendNotificationOrTraceOptions) => {
      const defaultTraceOptions = {
        sendNotification: false,
        traceFormat: import_vscode_languageserver_protocol43.TraceFormat.Text
      };
      if (sendNotificationOrTraceOptions === void 0) {
        connection.trace(value, tracer, defaultTraceOptions);
      } else if (boolean(sendNotificationOrTraceOptions)) {
        connection.trace(value, tracer, sendNotificationOrTraceOptions);
      } else {
        connection.trace(value, tracer, sendNotificationOrTraceOptions);
      }
    },
    initialize: (params) => connection.sendRequest(import_vscode_languageserver_protocol43.InitializeRequest.type, params),
    shutdown: () => connection.sendRequest(import_vscode_languageserver_protocol43.ShutdownRequest.type, void 0),
    exit: () => connection.sendNotification(import_vscode_languageserver_protocol43.ExitNotification.type),
    onLogMessage: (handler) => connection.onNotification(import_vscode_languageserver_protocol43.LogMessageNotification.type, handler),
    onShowMessage: (handler) => connection.onNotification(import_vscode_languageserver_protocol43.ShowMessageNotification.type, handler),
    onTelemetry: (handler) => connection.onNotification(import_vscode_languageserver_protocol43.TelemetryEventNotification.type, handler),
    didChangeConfiguration: (params) => connection.sendNotification(import_vscode_languageserver_protocol43.DidChangeConfigurationNotification.type, params),
    didChangeWatchedFiles: (params) => connection.sendNotification(import_vscode_languageserver_protocol43.DidChangeWatchedFilesNotification.type, params),
    didOpenTextDocument: (params) => connection.sendNotification(import_vscode_languageserver_protocol43.DidOpenTextDocumentNotification.type, params),
    didChangeTextDocument: (params) => connection.sendNotification(import_vscode_languageserver_protocol43.DidChangeTextDocumentNotification.type, params),
    didCloseTextDocument: (params) => connection.sendNotification(import_vscode_languageserver_protocol43.DidCloseTextDocumentNotification.type, params),
    didSaveTextDocument: (params) => connection.sendNotification(import_vscode_languageserver_protocol43.DidSaveTextDocumentNotification.type, params),
    onDiagnostics: (handler) => connection.onNotification(import_vscode_languageserver_protocol43.PublishDiagnosticsNotification.type, handler),
    dispose: () => connection.dispose()
  };
  return result;
}
function ensure(target, key) {
  if (target[key] == null) {
    target[key] = {};
  }
  return target[key];
}
var import_path16, import_vscode_languageserver_protocol43, import_os7, logger43, ConsoleLogger, NullLogger, ErrorAction, CloseAction, DefaultErrorHandler, RevealOutputChannelOn, State2, ClientState, SupportedSymbolKinds, SupportedCompletionItemKinds, SupportedSymbolTags, DynamicFeature, DocumentNotifiactions, DidOpenTextDocumentFeature, DidCloseTextDocumentFeature, DidChangeTextDocumentFeature, WillSaveFeature, WillSaveWaitUntilFeature, DidSaveTextDocumentFeature, FileSystemWatcherFeature, TextDocumentFeature, WorkspaceFeature, CompletionItemFeature, HoverFeature, SignatureHelpFeature, DefinitionFeature, ReferencesFeature, DocumentHighlightFeature, DocumentSymbolFeature, WorkspaceSymbolFeature, CodeActionFeature, CodeLensFeature, DocumentFormattingFeature, DocumentRangeFormattingFeature, DocumentOnTypeFormattingFeature, RenameFeature, DocumentLinkFeature, ConfigurationFeature, ExecuteCommandFeature, MessageTransports, OnReady, BaseLanguageClient;
var init_client = __esm({
  "src/language-client/client.ts"() {
    import_path16 = __toModule(require("path"));
    import_vscode_languageserver_protocol43 = __toModule(require_main2());
    init_esm2();
    init_commands2();
    init_languages();
    init_fs();
    init_is();
    init_lodash();
    init_window();
    init_workspace();
    init_sources2();
    init_progressPart();
    init_async();
    import_os7 = __toModule(require("os"));
    init_converter();
    init_uuid();
    logger43 = require_logger2()("language-client-client");
    ConsoleLogger = class {
      error(message) {
        logger43.error(message);
      }
      warn(message) {
        logger43.warn(message);
      }
      info(message) {
        logger43.info(message);
      }
      log(message) {
        logger43.log(message);
      }
    };
    NullLogger = class {
      error(_message) {
      }
      warn(_message) {
      }
      info(_message) {
      }
      log(_message) {
      }
    };
    (function(ErrorAction2) {
      ErrorAction2[ErrorAction2["Continue"] = 1] = "Continue";
      ErrorAction2[ErrorAction2["Shutdown"] = 2] = "Shutdown";
    })(ErrorAction || (ErrorAction = {}));
    (function(CloseAction2) {
      CloseAction2[CloseAction2["DoNotRestart"] = 1] = "DoNotRestart";
      CloseAction2[CloseAction2["Restart"] = 2] = "Restart";
    })(CloseAction || (CloseAction = {}));
    DefaultErrorHandler = class {
      constructor(name2) {
        this.name = name2;
        this.restarts = [];
      }
      error(_error, _message, count) {
        if (count && count <= 3) {
          return 1;
        }
        return 2;
      }
      closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length < 5) {
          return 2;
        } else {
          let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
          if (diff <= 3 * 60 * 1e3) {
            window_default.showMessage(`The "${this.name}" server crashed 5 times in the last 3 minutes. The server will not be restarted.`, "error");
            return 1;
          } else {
            this.restarts.shift();
            return 2;
          }
        }
      }
    };
    (function(RevealOutputChannelOn2) {
      RevealOutputChannelOn2[RevealOutputChannelOn2["Info"] = 1] = "Info";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Warn"] = 2] = "Warn";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Error"] = 3] = "Error";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Never"] = 4] = "Never";
    })(RevealOutputChannelOn || (RevealOutputChannelOn = {}));
    (function(State3) {
      State3[State3["Stopped"] = 1] = "Stopped";
      State3[State3["Running"] = 2] = "Running";
      State3[State3["Starting"] = 3] = "Starting";
    })(State2 || (State2 = {}));
    (function(ClientState2) {
      ClientState2[ClientState2["Initial"] = 0] = "Initial";
      ClientState2[ClientState2["Starting"] = 1] = "Starting";
      ClientState2[ClientState2["StartFailed"] = 2] = "StartFailed";
      ClientState2[ClientState2["Running"] = 3] = "Running";
      ClientState2[ClientState2["Stopping"] = 4] = "Stopping";
      ClientState2[ClientState2["Stopped"] = 5] = "Stopped";
    })(ClientState || (ClientState = {}));
    SupportedSymbolKinds = [
      import_vscode_languageserver_protocol43.SymbolKind.File,
      import_vscode_languageserver_protocol43.SymbolKind.Module,
      import_vscode_languageserver_protocol43.SymbolKind.Namespace,
      import_vscode_languageserver_protocol43.SymbolKind.Package,
      import_vscode_languageserver_protocol43.SymbolKind.Class,
      import_vscode_languageserver_protocol43.SymbolKind.Method,
      import_vscode_languageserver_protocol43.SymbolKind.Property,
      import_vscode_languageserver_protocol43.SymbolKind.Field,
      import_vscode_languageserver_protocol43.SymbolKind.Constructor,
      import_vscode_languageserver_protocol43.SymbolKind.Enum,
      import_vscode_languageserver_protocol43.SymbolKind.Interface,
      import_vscode_languageserver_protocol43.SymbolKind.Function,
      import_vscode_languageserver_protocol43.SymbolKind.Variable,
      import_vscode_languageserver_protocol43.SymbolKind.Constant,
      import_vscode_languageserver_protocol43.SymbolKind.String,
      import_vscode_languageserver_protocol43.SymbolKind.Number,
      import_vscode_languageserver_protocol43.SymbolKind.Boolean,
      import_vscode_languageserver_protocol43.SymbolKind.Array,
      import_vscode_languageserver_protocol43.SymbolKind.Object,
      import_vscode_languageserver_protocol43.SymbolKind.Key,
      import_vscode_languageserver_protocol43.SymbolKind.Null,
      import_vscode_languageserver_protocol43.SymbolKind.EnumMember,
      import_vscode_languageserver_protocol43.SymbolKind.Struct,
      import_vscode_languageserver_protocol43.SymbolKind.Event,
      import_vscode_languageserver_protocol43.SymbolKind.Operator,
      import_vscode_languageserver_protocol43.SymbolKind.TypeParameter
    ];
    SupportedCompletionItemKinds = [
      import_vscode_languageserver_protocol43.CompletionItemKind.Text,
      import_vscode_languageserver_protocol43.CompletionItemKind.Method,
      import_vscode_languageserver_protocol43.CompletionItemKind.Function,
      import_vscode_languageserver_protocol43.CompletionItemKind.Constructor,
      import_vscode_languageserver_protocol43.CompletionItemKind.Field,
      import_vscode_languageserver_protocol43.CompletionItemKind.Variable,
      import_vscode_languageserver_protocol43.CompletionItemKind.Class,
      import_vscode_languageserver_protocol43.CompletionItemKind.Interface,
      import_vscode_languageserver_protocol43.CompletionItemKind.Module,
      import_vscode_languageserver_protocol43.CompletionItemKind.Property,
      import_vscode_languageserver_protocol43.CompletionItemKind.Unit,
      import_vscode_languageserver_protocol43.CompletionItemKind.Value,
      import_vscode_languageserver_protocol43.CompletionItemKind.Enum,
      import_vscode_languageserver_protocol43.CompletionItemKind.Keyword,
      import_vscode_languageserver_protocol43.CompletionItemKind.Snippet,
      import_vscode_languageserver_protocol43.CompletionItemKind.Color,
      import_vscode_languageserver_protocol43.CompletionItemKind.File,
      import_vscode_languageserver_protocol43.CompletionItemKind.Reference,
      import_vscode_languageserver_protocol43.CompletionItemKind.Folder,
      import_vscode_languageserver_protocol43.CompletionItemKind.EnumMember,
      import_vscode_languageserver_protocol43.CompletionItemKind.Constant,
      import_vscode_languageserver_protocol43.CompletionItemKind.Struct,
      import_vscode_languageserver_protocol43.CompletionItemKind.Event,
      import_vscode_languageserver_protocol43.CompletionItemKind.Operator,
      import_vscode_languageserver_protocol43.CompletionItemKind.TypeParameter
    ];
    SupportedSymbolTags = [
      import_vscode_languageserver_protocol43.SymbolTag.Deprecated
    ];
    (function(DynamicFeature3) {
      function is(value) {
        let candidate = value;
        return candidate && func(candidate.register) && func(candidate.unregister) && func(candidate.dispose) && candidate.messages !== void 0;
      }
      DynamicFeature3.is = is;
    })(DynamicFeature || (DynamicFeature = {}));
    DocumentNotifiactions = class {
      constructor(_client, _event, _type, _middleware, _createParams, _selectorFilter) {
        this._client = _client;
        this._event = _event;
        this._type = _type;
        this._middleware = _middleware;
        this._createParams = _createParams;
        this._selectorFilter = _selectorFilter;
        this._selectors = new Map();
      }
      static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
          if (workspace_default.match(selector, textDocument) > 0) {
            return true;
          }
        }
        return false;
      }
      register(_message, data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = this._event(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
      }
      callback(data) {
        if (!this._selectorFilter || this._selectorFilter(this._selectors.values(), data)) {
          if (this._middleware) {
            this._middleware(data, (data2) => this._client.sendNotification(this._type, this._createParams(data2)));
          } else {
            this._client.sendNotification(this._type, this._createParams(data));
          }
          this.notificationSent(data);
        }
      }
      notificationSent(_data) {
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._selectors.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document2) {
        for (const selector of this._selectors.values()) {
          if (workspace_default.match(selector, document2)) {
            return {
              send: (data) => {
                this.callback(data);
              }
            };
          }
        }
        throw new Error(`No provider available for the given text document`);
      }
    };
    DidOpenTextDocumentFeature = class extends DocumentNotifiactions {
      constructor(client, _syncedDocuments) {
        super(client, workspace_default.onDidOpenTextDocument, import_vscode_languageserver_protocol43.DidOpenTextDocumentNotification.type, client.clientOptions.middleware.didOpen, (textDocument) => {
          return { textDocument: convertToTextDocumentItem(textDocument) };
        }, DocumentNotifiactions.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
      }
      get messages() {
        return import_vscode_languageserver_protocol43.DidOpenTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register(this.messages, {
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      register(message, data) {
        super.register(message, data);
        if (!data.registerOptions.documentSelector) {
          return;
        }
        let documentSelector = data.registerOptions.documentSelector;
        workspace_default.textDocuments.forEach((textDocument) => {
          let uri = textDocument.uri.toString();
          if (this._syncedDocuments.has(uri)) {
            return;
          }
          if (workspace_default.match(documentSelector, textDocument) > 0) {
            let middleware = this._client.clientOptions.middleware;
            let didOpen = (textDocument2) => {
              this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            if (middleware.didOpen) {
              middleware.didOpen(textDocument, didOpen);
            } else {
              didOpen(textDocument);
            }
            this._syncedDocuments.set(uri, textDocument);
          }
        });
      }
      notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
      }
    };
    DidCloseTextDocumentFeature = class extends DocumentNotifiactions {
      constructor(client, _syncedDocuments) {
        super(client, workspace_default.onDidCloseTextDocument, import_vscode_languageserver_protocol43.DidCloseTextDocumentNotification.type, client.clientOptions.middleware.didClose, (textDocument) => asCloseTextDocumentParams(textDocument), DocumentNotifiactions.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
      }
      get messages() {
        return import_vscode_languageserver_protocol43.DidCloseTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register(this.messages, {
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      notificationSent(textDocument) {
        super.notificationSent(textDocument);
        this._syncedDocuments.delete(textDocument.uri.toString());
      }
      unregister(id) {
        let selector = this._selectors.get(id);
        super.unregister(id);
        let selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
          if (workspace_default.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument)) {
            let middleware = this._client.clientOptions.middleware;
            let didClose = (textDocument2) => {
              this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            this._syncedDocuments.delete(textDocument.uri.toString());
            if (middleware.didClose) {
              middleware.didClose(textDocument, didClose);
            } else {
              didClose(textDocument);
            }
          }
        });
      }
    };
    DidChangeTextDocumentFeature = class {
      constructor(_client) {
        this._client = _client;
        this._changeData = new Map();
      }
      get messages() {
        return import_vscode_languageserver_protocol43.DidChangeTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== import_vscode_languageserver_protocol43.TextDocumentSyncKind.None) {
          this.register(this.messages, {
            id: generateUuid(),
            registerOptions: Object.assign({}, { documentSelector }, { syncKind: textDocumentSyncOptions.change })
          });
        }
      }
      register(_message, data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = workspace_default.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
          documentSelector: data.registerOptions.documentSelector,
          syncKind: data.registerOptions.syncKind
        });
      }
      callback(event) {
        if (event.contentChanges.length === 0) {
          return;
        }
        let doc = workspace_default.getDocument(event.textDocument.uri);
        if (!doc)
          return;
        let { textDocument } = doc;
        for (const changeData of this._changeData.values()) {
          if (workspace_default.match(changeData.documentSelector, textDocument) > 0) {
            let middleware = this._client.clientOptions.middleware;
            if (changeData.syncKind === import_vscode_languageserver_protocol43.TextDocumentSyncKind.Incremental) {
              if (middleware.didChange) {
                middleware.didChange(event, () => this._client.sendNotification(import_vscode_languageserver_protocol43.DidChangeTextDocumentNotification.type, omit(event, ["bufnr", "original"])));
              } else {
                this._client.sendNotification(import_vscode_languageserver_protocol43.DidChangeTextDocumentNotification.type, omit(event, ["bufnr", "original"]));
              }
            } else if (changeData.syncKind === import_vscode_languageserver_protocol43.TextDocumentSyncKind.Full) {
              let didChange = (event2) => {
                let { textDocument: textDocument2 } = workspace_default.getDocument(event2.textDocument.uri);
                this._client.sendNotification(import_vscode_languageserver_protocol43.DidChangeTextDocumentNotification.type, asChangeTextDocumentParams(textDocument2));
              };
              if (middleware.didChange) {
                middleware.didChange(event, didChange);
              } else {
                didChange(event);
              }
            }
          }
        }
      }
      unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._changeData.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document2) {
        for (const changeData of this._changeData.values()) {
          if (workspace_default.match(changeData.documentSelector, document2)) {
            return {
              send: (event) => {
                this.callback(event);
              }
            };
          }
        }
        throw new Error(`No provider available for the given text document`);
      }
    };
    WillSaveFeature = class extends DocumentNotifiactions {
      constructor(client) {
        super(client, workspace_default.onWillSaveTextDocument, import_vscode_languageserver_protocol43.WillSaveTextDocumentNotification.type, client.clientOptions.middleware.willSave, (willSaveEvent) => asWillSaveTextDocumentParams(willSaveEvent), (selectors, willSaveEvent) => DocumentNotifiactions.textDocumentFilter(selectors, willSaveEvent.document));
      }
      get messages() {
        return import_vscode_languageserver_protocol43.WillSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
        value.willSave = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
          this.register(this.messages, {
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
    };
    WillSaveWaitUntilFeature = class {
      constructor(_client) {
        this._client = _client;
        this._selectors = new Map();
      }
      get messages() {
        return import_vscode_languageserver_protocol43.WillSaveTextDocumentWaitUntilRequest.type;
      }
      fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
        value.willSaveWaitUntil = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
          this.register(this.messages, {
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      register(_message, data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = workspace_default.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
      }
      callback(event) {
        if (DocumentNotifiactions.textDocumentFilter(this._selectors.values(), event.document)) {
          let middleware = this._client.clientOptions.middleware;
          let willSaveWaitUntil = (event2) => {
            return this._client.sendRequest(import_vscode_languageserver_protocol43.WillSaveTextDocumentWaitUntilRequest.type, asWillSaveTextDocumentParams(event2)).then((edits) => {
              return edits ? edits : [];
            }, (e) => {
              window_default.showMessage(`Error on willSaveWaitUntil: ${e}`, "error");
              logger43.error(e);
              return [];
            });
          };
          event.waitUntil(middleware.willSaveWaitUntil ? middleware.willSaveWaitUntil(event, willSaveWaitUntil) : willSaveWaitUntil(event));
        }
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._selectors.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
    };
    DidSaveTextDocumentFeature = class extends DocumentNotifiactions {
      constructor(client) {
        super(client, workspace_default.onDidSaveTextDocument, import_vscode_languageserver_protocol43.DidSaveTextDocumentNotification.type, client.clientOptions.middleware.didSave, (textDocument) => asSaveTextDocumentParams(textDocument, this._includeText), DocumentNotifiactions.textDocumentFilter);
      }
      get messages() {
        return import_vscode_languageserver_protocol43.DidSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").didSave = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
          this.register(this.messages, {
            id: generateUuid(),
            registerOptions: Object.assign({}, { documentSelector }, { includeText: !!textDocumentSyncOptions.save.includeText })
          });
        }
      }
      register(method, data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(method, data);
      }
    };
    FileSystemWatcherFeature = class {
      constructor(_client, _notifyFileEvent) {
        this._notifyFileEvent = _notifyFileEvent;
        this._watchers = new Map();
      }
      get messages() {
        return import_vscode_languageserver_protocol43.DidChangeWatchedFilesNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "didChangeWatchedFiles").dynamicRegistration = true;
      }
      initialize(_capabilities, _documentSelector) {
      }
      register(_method, data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
          return;
        }
        let disposables = [];
        for (let watcher of data.registerOptions.watchers) {
          if (!string(watcher.globPattern)) {
            continue;
          }
          let watchCreate = true, watchChange = true, watchDelete = true;
          if (watcher.kind != null) {
            watchCreate = (watcher.kind & import_vscode_languageserver_protocol43.WatchKind.Create) !== 0;
            watchChange = (watcher.kind & import_vscode_languageserver_protocol43.WatchKind.Change) != 0;
            watchDelete = (watcher.kind & import_vscode_languageserver_protocol43.WatchKind.Delete) != 0;
          }
          let fileSystemWatcher = workspace_default.createFileSystemWatcher(watcher.globPattern, !watchCreate, !watchChange, !watchDelete);
          this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, disposables);
          disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
      }
      registerRaw(id, fileSystemWatchers) {
        let disposables = [];
        for (let fileSystemWatcher of fileSystemWatchers) {
          disposables.push(fileSystemWatcher);
          this.hookListeners(fileSystemWatcher, true, true, true, disposables);
        }
        this._watchers.set(id, disposables);
      }
      hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
          fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
            uri: asUri(resource),
            type: import_vscode_languageserver_protocol43.FileChangeType.Created
          }), null, listeners);
        }
        if (watchChange) {
          fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
            uri: asUri(resource),
            type: import_vscode_languageserver_protocol43.FileChangeType.Changed
          }), null, listeners);
        }
        if (watchDelete) {
          fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
            uri: asUri(resource),
            type: import_vscode_languageserver_protocol43.FileChangeType.Deleted
          }), null, listeners);
        }
      }
      unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        }
      }
      dispose() {
        this._watchers.forEach((disposables) => {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        });
        this._watchers.clear();
      }
    };
    TextDocumentFeature = class {
      constructor(_client, _message) {
        this._client = _client;
        this._message = _message;
        this._registrations = new Map();
      }
      get messages() {
        return this._message;
      }
      register(message, data) {
        if (message.method !== this.messages.method) {
          throw new Error(`Register called on wrong feature. Requested ${message.method} but reached feature ${this.messages.method}`);
        }
        if (!data.registerOptions.documentSelector) {
          return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
      }
      unregister(id) {
        let registration = this._registrations.get(id);
        if (registration) {
          registration.disposable.dispose();
        }
      }
      dispose() {
        this._registrations.forEach((value) => {
          value.disposable.dispose();
        });
        this._registrations.clear();
      }
      getRegistration(documentSelector, capability) {
        if (!capability) {
          return [void 0, void 0];
        } else if (import_vscode_languageserver_protocol43.TextDocumentRegistrationOptions.is(capability)) {
          const id = import_vscode_languageserver_protocol43.StaticRegistrationOptions.hasId(capability) ? capability.id : generateUuid();
          const selector = capability.documentSelector || documentSelector;
          if (selector) {
            return [id, Object.assign({}, capability, { documentSelector: selector })];
          }
        } else if (boolean(capability) && capability === true || import_vscode_languageserver_protocol43.WorkDoneProgressOptions.is(capability)) {
          if (!documentSelector) {
            return [void 0, void 0];
          }
          let options = boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
          return [generateUuid(), options];
        }
        return [void 0, void 0];
      }
      getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
          return void 0;
        }
        return boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
      }
      getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
          let selector = registration.data.registerOptions.documentSelector;
          if (selector !== null && workspace_default.match(selector, textDocument) > 0) {
            return registration.provider;
          }
        }
        throw new Error(`The feature has no registration for the provided text document ${textDocument.uri.toString()}`);
      }
    };
    WorkspaceFeature = class {
      constructor(_client, _message) {
        this._client = _client;
        this._message = _message;
        this._registrations = new Map();
      }
      get messages() {
        return this._message;
      }
      register(message, data) {
        if (message.method !== this.messages.method) {
          throw new Error(`Register called on wrong feature. Requested ${message.method} but reached feature ${this.messages.method}`);
        }
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, registration);
      }
      unregister(id) {
        const registration = this._registrations.get(id);
        if (registration)
          registration.dispose();
      }
      dispose() {
        this._registrations.forEach((value) => {
          value.dispose();
        });
        this._registrations.clear();
      }
    };
    CompletionItemFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.CompletionRequest.type);
      }
      fillClientCapabilities(capabilites) {
        let snippetSupport = this._client.clientOptions.disableSnippetCompletion !== true;
        let completion = ensure(ensure(capabilites, "textDocument"), "completion");
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
          snippetSupport,
          commitCharactersSupport: true,
          documentationFormat: this._client.supporedMarkupKind,
          deprecatedSupport: true,
          preselectSupport: true,
          tagSupport: { valueSet: [import_vscode_languageserver_protocol43.CompletionItemTag.Deprecated] }
        };
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
      }
      initialize(capabilities, documentSelector) {
        this.index = 0;
        const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        let triggerCharacters = options.triggerCharacters || [];
        let allCommitCharacters = options.allCommitCharacters || [];
        let priority = options.priority;
        const provider = {
          provideCompletionItems: (document2, position, token, context) => {
            const client = this._client;
            const middleware = this._client.clientOptions.middleware;
            const provideCompletionItems = (document3, position2, context2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol43.CompletionRequest.type, asCompletionParams(document3, position2, context2), token2).then((result) => result, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.CompletionRequest.type, error);
                return Promise.resolve([]);
              });
            };
            return middleware.provideCompletionItem ? middleware.provideCompletionItem(document2, position, context, token, provideCompletionItems) : provideCompletionItems(document2, position, context, token);
          },
          resolveCompletionItem: options.resolveProvider ? (item, token) => {
            const client = this._client;
            const middleware = this._client.clientOptions.middleware;
            const resolveCompletionItem = (item2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol43.CompletionResolveRequest.type, item2, token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.CompletionResolveRequest.type, error);
                return Promise.resolve(item2);
              });
            };
            return middleware.resolveCompletionItem ? middleware.resolveCompletionItem(item, token, resolveCompletionItem) : resolveCompletionItem(item, token);
          } : void 0
        };
        let name2 = this._client.id + (this.index ? "-" + this.index : "");
        sources_default.removeSource(name2);
        const disposable = languages_default.registerCompletionItemProvider(name2, "LS", options.documentSelector || this._client.clientOptions.documentSelector, provider, triggerCharacters, priority, allCommitCharacters);
        this.index = this.index + 1;
        return [disposable, provider];
      }
    };
    HoverFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.HoverRequest.type);
      }
      fillClientCapabilities(capabilites) {
        const hoverCapability = ensure(ensure(capabilites, "textDocument"), "hover");
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = this._client.supporedMarkupKind;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideHover: (document2, position, token) => {
            const client = this._client;
            const provideHover = (document3, position2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol43.HoverRequest.type, asTextDocumentPositionParams(document3, position2), token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.HoverRequest.type, error);
                return Promise.resolve(null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideHover ? middleware.provideHover(document2, position, token, provideHover) : provideHover(document2, position, token);
          }
        };
        return [languages_default.registerHoverProvider(options.documentSelector, provider), provider];
      }
    };
    SignatureHelpFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.SignatureHelpRequest.type);
      }
      fillClientCapabilities(capabilites) {
        let config = ensure(ensure(capabilites, "textDocument"), "signatureHelp");
        config.dynamicRegistration = true;
        config.contextSupport = true;
        config.signatureInformation = {
          documentationFormat: this._client.supporedMarkupKind,
          activeParameterSupport: true,
          parameterInformation: {
            labelOffsetSupport: true
          }
        };
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideSignatureHelp: (document2, position, token, context) => {
            const client = this._client;
            const providerSignatureHelp = (document3, position2, context2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol43.SignatureHelpRequest.type, asSignatureHelpParams(document3, position2, context2), token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.SignatureHelpRequest.type, error);
                return Promise.resolve(null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideSignatureHelp ? middleware.provideSignatureHelp(document2, position, context, token, providerSignatureHelp) : providerSignatureHelp(document2, position, context, token);
          }
        };
        const triggerCharacters = options.triggerCharacters || [];
        const disposable = languages_default.registerSignatureHelpProvider(options.documentSelector, provider, triggerCharacters);
        return [disposable, provider];
      }
    };
    DefinitionFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.DefinitionRequest.type);
      }
      fillClientCapabilities(capabilites) {
        let definitionSupport = ensure(ensure(capabilites, "textDocument"), "definition");
        definitionSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDefinition: (document2, position, token) => {
            const client = this._client;
            const provideDefinition = (document3, position2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol43.DefinitionRequest.type, asTextDocumentPositionParams(document3, position2), token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.DefinitionRequest.type, error);
                return Promise.resolve(null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDefinition ? middleware.provideDefinition(document2, position, token, provideDefinition) : provideDefinition(document2, position, token);
          }
        };
        return [languages_default.registerDefinitionProvider(options.documentSelector, provider), provider];
      }
    };
    ReferencesFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.ReferencesRequest.type);
      }
      fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, "textDocument"), "references").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideReferences: (document2, position, options2, token) => {
            const client = this._client;
            const _providerReferences = (document3, position2, options3, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol43.ReferencesRequest.type, asReferenceParams(document3, position2, options3), token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.ReferencesRequest.type, error);
                return Promise.resolve([]);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideReferences ? middleware.provideReferences(document2, position, options2, token, _providerReferences) : _providerReferences(document2, position, options2, token);
          }
        };
        return [languages_default.registerReferencesProvider(options.documentSelector, provider), provider];
      }
    };
    DocumentHighlightFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.DocumentHighlightRequest.type);
      }
      fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, "textDocument"), "documentHighlight").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentHighlights: (document2, position, token) => {
            const client = this._client;
            const _provideDocumentHighlights = (document3, position2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol43.DocumentHighlightRequest.type, asTextDocumentPositionParams(document3, position2), token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.DocumentHighlightRequest.type, error);
                return Promise.resolve([]);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentHighlights ? middleware.provideDocumentHighlights(document2, position, token, _provideDocumentHighlights) : _provideDocumentHighlights(document2, position, token);
          }
        };
        return [languages_default.registerDocumentHighlightProvider(options.documentSelector, provider), provider];
      }
    };
    DocumentSymbolFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.DocumentSymbolRequest.type);
      }
      fillClientCapabilities(capabilites) {
        let symbolCapabilities = ensure(ensure(capabilites, "textDocument"), "documentSymbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
          valueSet: SupportedSymbolTags
        };
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentSymbols: (document2, token) => {
            const client = this._client;
            const _provideDocumentSymbols = (document3, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol43.DocumentSymbolRequest.type, asDocumentSymbolParams(document3), token2).then((data) => {
                if (data === null) {
                  return void 0;
                }
                if (data.length === 0) {
                  return [];
                } else {
                  let element = data[0];
                  if (import_vscode_languageserver_protocol43.DocumentSymbol.is(element)) {
                    return data;
                  } else {
                    return data;
                  }
                }
              }, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.DocumentSymbolRequest.type, error);
                return Promise.resolve([]);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentSymbols ? middleware.provideDocumentSymbols(document2, token, _provideDocumentSymbols) : _provideDocumentSymbols(document2, token);
          }
        };
        return [languages_default.registerDocumentSymbolProvider(options.documentSelector, provider), provider];
      }
    };
    WorkspaceSymbolFeature = class extends WorkspaceFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.WorkspaceSymbolRequest.type);
      }
      fillClientCapabilities(capabilites) {
        let symbolCapabilities = ensure(ensure(capabilites, "workspace"), "symbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
          valueSet: SupportedSymbolTags
        };
      }
      initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
      }
      registerLanguageProvider(_options) {
        const provider = {
          provideWorkspaceSymbols: (query, token) => {
            const client = this._client;
            const provideWorkspaceSymbols = (query2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol43.WorkspaceSymbolRequest.type, { query: query2 }, token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.WorkspaceSymbolRequest.type, error);
                return Promise.resolve([]);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideWorkspaceSymbols ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols) : provideWorkspaceSymbols(query, token);
          }
        };
        return languages_default.registerWorkspaceSymbolProvider(provider);
      }
    };
    CodeActionFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.CodeActionRequest.type);
      }
      fillClientCapabilities(capabilites) {
        const cap = ensure(ensure(capabilites, "textDocument"), "codeAction");
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.codeActionLiteralSupport = {
          codeActionKind: {
            valueSet: [
              import_vscode_languageserver_protocol43.CodeActionKind.Empty,
              import_vscode_languageserver_protocol43.CodeActionKind.QuickFix,
              import_vscode_languageserver_protocol43.CodeActionKind.Refactor,
              import_vscode_languageserver_protocol43.CodeActionKind.RefactorExtract,
              import_vscode_languageserver_protocol43.CodeActionKind.RefactorInline,
              import_vscode_languageserver_protocol43.CodeActionKind.RefactorRewrite,
              import_vscode_languageserver_protocol43.CodeActionKind.Source,
              import_vscode_languageserver_protocol43.CodeActionKind.SourceOrganizeImports
            ]
          }
        };
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideCodeActions: (document2, range, context, token) => {
            const client = this._client;
            const _provideCodeActions = (document3, range2, context2, token2) => {
              const params = {
                textDocument: {
                  uri: document3.uri
                },
                range: range2,
                context: context2
              };
              return client.sendRequest(import_vscode_languageserver_protocol43.CodeActionRequest.type, params, token2).then((values) => {
                if (values === null) {
                  return void 0;
                }
                return values;
              }, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.CodeActionRequest.type, error);
                return Promise.resolve([]);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideCodeActions ? middleware.provideCodeActions(document2, range, context, token, _provideCodeActions) : _provideCodeActions(document2, range, context, token);
          }
        };
        return [languages_default.registerCodeActionProvider(options.documentSelector, provider, this._client.id, options.codeActionKinds), provider];
      }
    };
    CodeLensFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.CodeLensRequest.type);
      }
      fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, "textDocument"), "codeLens").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideCodeLenses: (document2, token) => {
            const client = this._client;
            const provideCodeLenses = (document3, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol43.CodeLensRequest.type, asCodeLensParams(document3), token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.CodeLensRequest.type, error);
                return Promise.resolve([]);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideCodeLenses ? middleware.provideCodeLenses(document2, token, provideCodeLenses) : provideCodeLenses(document2, token);
          },
          resolveCodeLens: options.resolveProvider ? (codeLens, token) => {
            const client = this._client;
            const resolveCodeLens = (codeLens2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol43.CodeLensResolveRequest.type, codeLens2, token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.CodeLensResolveRequest.type, error);
                return codeLens2;
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.resolveCodeLens ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens) : resolveCodeLens(codeLens, token);
          } : void 0
        };
        return [languages_default.registerCodeLensProvider(options.documentSelector, provider), provider];
      }
    };
    DocumentFormattingFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.DocumentFormattingRequest.type);
      }
      fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, "textDocument"), "formatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentFormattingEdits: (document2, options2, token) => {
            const client = this._client;
            const provideDocumentFormattingEdits = (document3, options3, token2) => {
              const params = {
                textDocument: { uri: document3.uri },
                options: options3
              };
              return client.sendRequest(import_vscode_languageserver_protocol43.DocumentFormattingRequest.type, params, token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.DocumentFormattingRequest.type, error);
                return Promise.resolve([]);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentFormattingEdits ? middleware.provideDocumentFormattingEdits(document2, options2, token, provideDocumentFormattingEdits) : provideDocumentFormattingEdits(document2, options2, token);
          }
        };
        return [
          languages_default.registerDocumentFormatProvider(options.documentSelector, provider, this._client.clientOptions.formatterPriority),
          provider
        ];
      }
    };
    DocumentRangeFormattingFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.DocumentRangeFormattingRequest.type);
      }
      fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, "textDocument"), "rangeFormatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentRangeFormattingEdits: (document2, range, options2, token) => {
            const client = this._client;
            const provideDocumentRangeFormattingEdits = (document3, range2, options3, token2) => {
              const params = {
                textDocument: { uri: document3.uri },
                range: range2,
                options: options3
              };
              return client.sendRequest(import_vscode_languageserver_protocol43.DocumentRangeFormattingRequest.type, params, token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.DocumentRangeFormattingRequest.type, error);
                return Promise.resolve([]);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentRangeFormattingEdits ? middleware.provideDocumentRangeFormattingEdits(document2, range, options2, token, provideDocumentRangeFormattingEdits) : provideDocumentRangeFormattingEdits(document2, range, options2, token);
          }
        };
        return [languages_default.registerDocumentRangeFormatProvider(options.documentSelector, provider), provider];
      }
    };
    DocumentOnTypeFormattingFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.DocumentOnTypeFormattingRequest.type);
      }
      fillClientCapabilities(capabilites) {
        ensure(ensure(capabilites, "textDocument"), "onTypeFormatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideOnTypeFormattingEdits: (document2, position, ch, options2, token) => {
            const client = this._client;
            const provideOnTypeFormattingEdits = (document3, position2, ch2, options3, token2) => {
              const params = {
                textDocument: asVersionedTextDocumentIdentifier(document3),
                position: position2,
                ch: ch2,
                options: options3
              };
              return client.sendRequest(import_vscode_languageserver_protocol43.DocumentOnTypeFormattingRequest.type, params, token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.DocumentOnTypeFormattingRequest.type, error);
                return Promise.resolve([]);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideOnTypeFormattingEdits ? middleware.provideOnTypeFormattingEdits(document2, position, ch, options2, token, provideOnTypeFormattingEdits) : provideOnTypeFormattingEdits(document2, position, ch, options2, token);
          }
        };
        const moreTriggerCharacter = options.moreTriggerCharacter || [];
        const characters = [options.firstTriggerCharacter, ...moreTriggerCharacter];
        return [languages_default.registerOnTypeFormattingEditProvider(options.documentSelector, provider, characters), provider];
      }
    };
    RenameFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.RenameRequest.type);
      }
      fillClientCapabilities(capabilites) {
        let rename = ensure(ensure(capabilites, "textDocument"), "rename");
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options) {
          return;
        }
        if (boolean(capabilities.renameProvider)) {
          options.prepareProvider = false;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideRenameEdits: (document2, position, newName, token) => {
            const client = this._client;
            const provideRenameEdits = (document3, position2, newName2, token2) => {
              const params = {
                textDocument: { uri: document3.uri },
                position: position2,
                newName: newName2
              };
              return client.sendRequest(import_vscode_languageserver_protocol43.RenameRequest.type, params, token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.RenameRequest.type, error);
                return Promise.reject(new Error(error.message));
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideRenameEdits ? middleware.provideRenameEdits(document2, position, newName, token, provideRenameEdits) : provideRenameEdits(document2, position, newName, token);
          },
          prepareRename: options.prepareProvider ? (document2, position, token) => {
            const client = this._client;
            const prepareRename = (document3, position2, token2) => {
              const params = {
                textDocument: asTextDocumentIdentifier(document3),
                position: position2
              };
              return client.sendRequest(import_vscode_languageserver_protocol43.PrepareRenameRequest.type, params, token2).then((result) => {
                if (import_vscode_languageserver_protocol43.Range.is(result)) {
                  return result;
                } else if (result && import_vscode_languageserver_protocol43.Range.is(result.range)) {
                  return {
                    range: result.range,
                    placeholder: result.placeholder
                  };
                }
                return Promise.reject(new Error(`The element can't be renamed.`));
              }, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.PrepareRenameRequest.type, error);
                return Promise.reject(new Error(error.message));
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.prepareRename ? middleware.prepareRename(document2, position, token, prepareRename) : prepareRename(document2, position, token);
          } : void 0
        };
        return [languages_default.registerRenameProvider(options.documentSelector, provider), provider];
      }
    };
    DocumentLinkFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.DocumentLinkRequest.type);
      }
      fillClientCapabilities(capabilites) {
        const documentLinkCapabilities = ensure(ensure(capabilites, "textDocument"), "documentLink");
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: options
        });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDocumentLinks: (document2, token) => {
            const client = this._client;
            const provideDocumentLinks = (document3, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol43.DocumentLinkRequest.type, {
                textDocument: { uri: document3.uri }
              }, token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.DocumentLinkRequest.type, error);
                return Promise.resolve([]);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentLinks ? middleware.provideDocumentLinks(document2, token, provideDocumentLinks) : provideDocumentLinks(document2, token);
          },
          resolveDocumentLink: options.resolveProvider ? (link, token) => {
            const client = this._client;
            let resolveDocumentLink = (link2, token2) => {
              return client.sendRequest(import_vscode_languageserver_protocol43.DocumentLinkResolveRequest.type, link2, token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol43.DocumentLinkResolveRequest.type, error);
                return Promise.resolve(link2);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.resolveDocumentLink ? middleware.resolveDocumentLink(link, token, resolveDocumentLink) : resolveDocumentLink(link, token);
          } : void 0
        };
        return [languages_default.registerDocumentLinkProvider(options.documentSelector, provider), provider];
      }
    };
    ConfigurationFeature = class {
      constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
      }
      get messages() {
        return import_vscode_languageserver_protocol43.DidChangeConfigurationNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "didChangeConfiguration").dynamicRegistration = true;
      }
      initialize() {
        var _a2;
        let section2 = (_a2 = this._client.clientOptions.synchronize) == null ? void 0 : _a2.configurationSection;
        if (section2 !== void 0) {
          this.register(this.messages, {
            id: generateUuid(),
            registerOptions: {
              section: section2
            }
          });
        }
      }
      register(_message, data) {
        let { section: section2 } = data.registerOptions;
        let disposable = workspace_default.onDidChangeConfiguration((event) => {
          if (typeof section2 == "string" && !event.affectsConfiguration(section2)) {
            return;
          }
          if (Array.isArray(section2) && !section2.some((v) => event.affectsConfiguration(v))) {
            return;
          }
          if (section2 != null) {
            this.onDidChangeConfiguration(data.registerOptions.section);
          }
        });
        this._listeners.set(data.id, disposable);
        if (string(section2) && section2.endsWith(".settings")) {
          let settings = this.getConfiguredSettings(section2);
          if (!settings || emptyObject(settings))
            return;
        }
        if (section2 != null) {
          this.onDidChangeConfiguration(data.registerOptions.section);
        }
      }
      unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
          this._listeners.delete(id);
          disposable.dispose();
        }
      }
      dispose() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
      onDidChangeConfiguration(configurationSection) {
        let isConfigured = typeof configurationSection === "string" && configurationSection.startsWith("languageserver.");
        let sections;
        if (string(configurationSection)) {
          sections = [configurationSection];
        } else {
          sections = configurationSection;
        }
        let didChangeConfiguration = (sections2) => {
          if (sections2 === void 0) {
            this._client.sendNotification(import_vscode_languageserver_protocol43.DidChangeConfigurationNotification.type, { settings: null });
            return;
          }
          this._client.sendNotification(import_vscode_languageserver_protocol43.DidChangeConfigurationNotification.type, {
            settings: isConfigured ? this.getConfiguredSettings(sections2[0]) : this.extractSettingsInformation(sections2)
          });
        };
        let middleware = this.getMiddleware();
        middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections);
      }
      getConfiguredSettings(key) {
        let len = ".settings".length;
        let config = workspace_default.getConfiguration(key.slice(0, -len));
        return config.get("settings", {});
      }
      extractSettingsInformation(keys) {
        function ensurePath(config, path34) {
          let current = config;
          for (let i = 0; i < path34.length - 1; i++) {
            let obj = current[path34[i]];
            if (!obj) {
              obj = Object.create(null);
              current[path34[i]] = obj;
            }
            current = obj;
          }
          return current;
        }
        let result = Object.create(null);
        for (let i = 0; i < keys.length; i++) {
          let key = keys[i];
          let index = key.indexOf(".");
          let config = null;
          if (index >= 0) {
            config = workspace_default.getConfiguration(key.substr(0, index)).get(key.substr(index + 1));
          } else {
            config = workspace_default.getConfiguration(key);
          }
          if (config) {
            let path34 = keys[i].split(".");
            ensurePath(result, path34)[path34[path34.length - 1]] = config;
          }
        }
        return result;
      }
      getMiddleware() {
        let middleware = this._client.clientOptions.middleware;
        if (middleware.workspace && middleware.workspace.didChangeConfiguration) {
          return middleware.workspace.didChangeConfiguration;
        } else {
          return void 0;
        }
      }
    };
    ExecuteCommandFeature = class {
      constructor(_client) {
        this._client = _client;
        this._commands = new Map();
      }
      get messages() {
        return import_vscode_languageserver_protocol43.ExecuteCommandRequest.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "executeCommand").dynamicRegistration = true;
      }
      initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
          return;
        }
        this.register(this.messages, {
          id: generateUuid(),
          registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
      }
      register(_message, data) {
        const client = this._client;
        const middleware = client.clientOptions.middleware;
        const executeCommand = (command, args) => {
          const params = {
            command,
            arguments: args
          };
          return client.sendRequest(import_vscode_languageserver_protocol43.ExecuteCommandRequest.type, params).then(void 0, (error) => {
            client.logFailedRequest(import_vscode_languageserver_protocol43.ExecuteCommandRequest.type, error);
            throw error;
          });
        };
        if (data.registerOptions.commands) {
          let disposables = [];
          for (const command of data.registerOptions.commands) {
            disposables.push(commands_default.registerCommand(command, (...args) => {
              return middleware.executeCommand ? middleware.executeCommand(command, args, executeCommand) : executeCommand(command, args);
            }, null, true));
          }
          this._commands.set(data.id, disposables);
        }
      }
      unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
          disposables.forEach((disposable) => disposable.dispose());
        }
      }
      dispose() {
        this._commands.forEach((value) => {
          value.forEach((disposable) => disposable.dispose());
        });
        this._commands.clear();
      }
    };
    (function(MessageTransports2) {
      function is(value) {
        let candidate = value;
        return candidate && import_vscode_languageserver_protocol43.MessageReader.is(value.reader) && import_vscode_languageserver_protocol43.MessageWriter.is(value.writer);
      }
      MessageTransports2.is = is;
    })(MessageTransports || (MessageTransports = {}));
    OnReady = class {
      constructor(_resolve, _reject) {
        this._resolve = _resolve;
        this._reject = _reject;
        this._used = false;
      }
      get isUsed() {
        return this._used;
      }
      resolve() {
        this._used = true;
        this._resolve();
      }
      reject(error) {
        this._used = true;
        this._reject(error);
      }
    };
    BaseLanguageClient = class {
      constructor(id, name2, clientOptions) {
        this._features = [];
        this._method2Message = new Map();
        this._dynamicFeatures = new Map();
        this._id = id;
        this._name = name2;
        if (clientOptions.outputChannel) {
          this._outputChannel = clientOptions.outputChannel;
        } else {
          this._outputChannel = void 0;
        }
        let disableSnippetCompletion = false;
        let suggest = workspace_default.getConfiguration("suggest");
        if (suggest.get("snippetsSupport", true) === false || clientOptions.disableSnippetCompletion) {
          disableSnippetCompletion = true;
        }
        this._clientOptions = {
          disableWorkspaceFolders: clientOptions.disableWorkspaceFolders,
          disableSnippetCompletion,
          disableDynamicRegister: clientOptions.disableDynamicRegister,
          disableDiagnostics: clientOptions.disableDiagnostics,
          disableCompletion: clientOptions.disableCompletion,
          formatterPriority: clientOptions.formatterPriority,
          ignoredRootPaths: clientOptions.ignoredRootPaths,
          documentSelector: clientOptions.documentSelector || [],
          synchronize: clientOptions.synchronize || {},
          diagnosticCollectionName: clientOptions.diagnosticCollectionName,
          outputChannelName: clientOptions.outputChannelName || this._id,
          revealOutputChannelOn: clientOptions.revealOutputChannelOn || 4,
          stdioEncoding: clientOptions.stdioEncoding || "utf8",
          initializationOptions: clientOptions.initializationOptions,
          initializationFailedHandler: clientOptions.initializationFailedHandler,
          progressOnInitialization: !!clientOptions.progressOnInitialization,
          errorHandler: clientOptions.errorHandler || new DefaultErrorHandler(this._id),
          middleware: clientOptions.middleware || {},
          workspaceFolder: clientOptions.workspaceFolder
        };
        this.state = 0;
        this._connectionPromise = void 0;
        this._resolvedConnection = void 0;
        this._initializeResult = void 0;
        this._listeners = void 0;
        this._providers = void 0;
        this._diagnostics = void 0;
        this._fileEvents = [];
        this._fileEventDelayer = new Delayer(250);
        this._onReady = new Promise((resolve3, reject) => {
          this._onReadyCallbacks = new OnReady(resolve3, reject);
        });
        this._onStop = void 0;
        this._stateChangeEmitter = new import_vscode_languageserver_protocol43.Emitter();
        this._tracer = {
          log: (messageOrDataObject, data) => {
            if (string(messageOrDataObject)) {
              this.logTrace(messageOrDataObject, data);
            } else {
              this.logObjectTrace(messageOrDataObject);
            }
          }
        };
        this._syncedDocuments = new Map();
        let preferences = workspace_default.getConfiguration("coc.preferences");
        this._markdownSupport = preferences.get("enableMarkdown", true);
        this.registerBuiltinFeatures();
      }
      get supporedMarkupKind() {
        if (this._markdownSupport)
          return [import_vscode_languageserver_protocol43.MarkupKind.Markdown, import_vscode_languageserver_protocol43.MarkupKind.PlainText];
        return [import_vscode_languageserver_protocol43.MarkupKind.PlainText];
      }
      get state() {
        return this._state;
      }
      get id() {
        return this._id;
      }
      get name() {
        return this._name;
      }
      set state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
          this._stateChangeEmitter.fire({ oldState, newState });
        }
      }
      getPublicState() {
        if (this.state === 3) {
          return 2;
        } else if (this.state === 1) {
          return 3;
        } else {
          return 1;
        }
      }
      get initializeResult() {
        return this._initializeResult;
      }
      async sendRequest(type, ...params) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          return this._resolvedConnection.sendRequest(type, ...params);
        } catch (error) {
          this.error(`Sending request ${string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      onRequest(type, handler) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          this._resolvedConnection.onRequest(type, handler);
        } catch (error) {
          this.error(`Registering request handler ${string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      sendNotification(type, params) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          this._resolvedConnection.sendNotification(type, params);
        } catch (error) {
          this.error(`Sending notification ${string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      onNotification(type, handler) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          this._resolvedConnection.onNotification(type, handler);
        } catch (error) {
          this.error(`Registering notification handler ${string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      onProgress(type, token, handler) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          if (type == import_vscode_languageserver_protocol43.WorkDoneProgress.type) {
            const handleWorkDoneProgress = this._clientOptions.middleware.handleWorkDoneProgress;
            if (handleWorkDoneProgress !== void 0) {
              return this._resolvedConnection.onProgress(type, token, (params) => {
                handleWorkDoneProgress(token, params, () => handler(params));
              });
            }
          }
          return this._resolvedConnection.onProgress(type, token, handler);
        } catch (error) {
          this.error(`Registering progress handler for token ${token} failed.`, error);
          throw error;
        }
      }
      sendProgress(type, token, value) {
        if (!this.isConnectionActive()) {
          throw new Error("Language client is not ready yet");
        }
        try {
          this._resolvedConnection.sendProgress(type, token, value);
        } catch (error) {
          this.error(`Sending progress for token ${token} failed.`, error);
          throw error;
        }
      }
      get clientOptions() {
        return this._clientOptions;
      }
      get onDidChangeState() {
        return this._stateChangeEmitter.event;
      }
      get outputChannel() {
        if (!this._outputChannel) {
          let { outputChannelName } = this._clientOptions;
          this._outputChannel = window_default.createOutputChannel(outputChannelName ? outputChannelName : this._name);
        }
        return this._outputChannel;
      }
      get diagnostics() {
        return this._diagnostics;
      }
      createDefaultErrorHandler() {
        return new DefaultErrorHandler(this._id);
      }
      set trace(value) {
        this._trace = value;
        this.onReady().then(() => {
          this.resolveConnection().then((connection) => {
            connection.trace(this._trace, this._tracer, {
              sendNotification: false,
              traceFormat: this._traceFormat
            });
          });
        }, () => {
        });
      }
      logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
          this.outputChannel.append(`[LSP   - ${new Date().toLocaleTimeString()}] `);
        } else {
          this.outputChannel.append(`[Trace - ${new Date().toLocaleTimeString()}] `);
        }
        if (data) {
          this.outputChannel.appendLine(`${JSON.stringify(data)}`);
        }
      }
      data2String(data) {
        if (data instanceof import_vscode_languageserver_protocol43.ResponseError) {
          const responseError = data;
          return `  Message: ${responseError.message}
  Code: ${responseError.code} ${responseError.data ? "\n" + responseError.data.toString() : ""}`;
        }
        if (data instanceof Error) {
          if (string(data.stack)) {
            return data.stack;
          }
          return data.message;
        }
        if (string(data)) {
          return data;
        }
        return data.toString();
      }
      _appendOutput(type, message, data) {
        let level = 3;
        switch (type) {
          case "Info":
            level = 1;
            break;
          case "Warn":
            level = 2;
            break;
        }
        this.outputChannel.appendLine(`[${type}  - ${new Date().toLocaleTimeString()}] ${message}`);
        let dataString;
        if (data) {
          dataString = this.data2String(data);
          this.outputChannel.appendLine(dataString);
        }
        if (this._clientOptions.revealOutputChannelOn <= level) {
          this.outputChannel.show(true);
        }
      }
      info(message, data) {
        this._appendOutput("Info", message, data);
      }
      warn(message, data) {
        this._appendOutput("Warn", message, data);
      }
      error(message, data) {
        this._appendOutput("Error", message, data);
      }
      logTrace(message, data) {
        this.outputChannel.appendLine(`[Trace - ${new Date().toLocaleTimeString()}] ${message}`);
        if (data) {
          this.outputChannel.appendLine(this.data2String(data));
        }
      }
      needsStart() {
        return this.state === 0 || this.state === 4 || this.state === 5;
      }
      needsStop() {
        return this.state === 1 || this.state === 3;
      }
      onReady() {
        return this._onReady;
      }
      get started() {
        return this.state != 0;
      }
      isConnectionActive() {
        return this.state === 3 && !!this._resolvedConnection;
      }
      start() {
        if (this._onReadyCallbacks.isUsed) {
          this._onReady = new Promise((resolve3, reject) => {
            this._onReadyCallbacks = new OnReady(resolve3, reject);
          });
        }
        this._listeners = [];
        this._providers = [];
        if (!this._diagnostics) {
          let opts = this._clientOptions;
          let name2 = opts.diagnosticCollectionName ? opts.diagnosticCollectionName : this._id;
          this._diagnostics = languages_default.createDiagnosticCollection(name2);
        }
        this.state = 1;
        this.resolveConnection().then((connection) => {
          connection.onLogMessage((message) => {
            let kind;
            switch (message.type) {
              case import_vscode_languageserver_protocol43.MessageType.Error:
                kind = "error";
                this.error(message.message);
                break;
              case import_vscode_languageserver_protocol43.MessageType.Warning:
                kind = "warning";
                this.warn(message.message);
                break;
              case import_vscode_languageserver_protocol43.MessageType.Info:
                kind = "info";
                this.info(message.message);
                break;
              default:
                kind = "log";
                this.outputChannel.appendLine(message.message);
            }
            if (global.hasOwnProperty("__TEST__")) {
              console.log(`[${kind}] ${message.message}`);
              return;
            }
          });
          connection.onShowMessage((message) => {
            switch (message.type) {
              case import_vscode_languageserver_protocol43.MessageType.Error:
                window_default.showErrorMessage(message.message);
                break;
              case import_vscode_languageserver_protocol43.MessageType.Warning:
                window_default.showWarningMessage(message.message);
                break;
              case import_vscode_languageserver_protocol43.MessageType.Info:
                window_default.showInformationMessage(message.message);
                break;
              default:
                window_default.showInformationMessage(message.message);
            }
          });
          connection.onRequest(import_vscode_languageserver_protocol43.ShowMessageRequest.type, (params) => {
            let messageFunc;
            switch (params.type) {
              case import_vscode_languageserver_protocol43.MessageType.Error:
                messageFunc = window_default.showErrorMessage.bind(window_default);
                break;
              case import_vscode_languageserver_protocol43.MessageType.Warning:
                messageFunc = window_default.showWarningMessage.bind(window_default);
                break;
              case import_vscode_languageserver_protocol43.MessageType.Info:
                messageFunc = window_default.showInformationMessage.bind(window_default);
                break;
              default:
                messageFunc = window_default.showInformationMessage.bind(window_default);
            }
            let actions = params.actions || [];
            return messageFunc(params.message, ...actions);
          });
          connection.onTelemetry((_data) => {
          });
          connection.listen();
          return this.initialize(connection);
        }).then(void 0, (error) => {
          this.state = 2;
          this._onReadyCallbacks.reject(error);
          this.error("Starting client failed ", error);
        });
        return import_vscode_languageserver_protocol43.Disposable.create(() => {
          if (this.needsStop()) {
            this.stop();
          }
        });
      }
      resolveConnection() {
        if (!this._connectionPromise) {
          this._connectionPromise = this.createConnection();
        }
        return this._connectionPromise;
      }
      resolveRootPath() {
        if (this._clientOptions.workspaceFolder) {
          return URI.parse(this._clientOptions.workspaceFolder.uri).fsPath;
        }
        let { ignoredRootPaths } = this._clientOptions;
        let config = workspace_default.getConfiguration(this.id);
        let rootPatterns = config.get("rootPatterns", []);
        let required = config.get("requireRootPattern", false);
        let resolved;
        if (rootPatterns && rootPatterns.length) {
          let doc = workspace_default.getDocument(workspace_default.bufnr);
          if (doc && doc.schema == "file") {
            let dir = import_path16.default.dirname(URI.parse(doc.uri).fsPath);
            resolved = resolveRoot(dir, rootPatterns, workspace_default.cwd);
          }
        }
        if (required && !resolved)
          return false;
        let rootPath = resolved || workspace_default.rootPath || workspace_default.cwd;
        if (rootPath === import_os7.default.homedir() || ignoredRootPaths && ignoredRootPaths.includes(rootPath)) {
          this.warn(`Ignored rootPath ${rootPath} of client "${this._id}"`);
          return null;
        }
        return rootPath;
      }
      initialize(connection) {
        this.refreshTrace(connection, false);
        let { initializationOptions, progressOnInitialization } = this._clientOptions;
        let rootPath = this.resolveRootPath();
        if (rootPath === false) {
          console.warn(`required root pattern not found, server not started.`);
          return;
        }
        let initParams = {
          processId: process.pid,
          rootPath: rootPath ? rootPath : null,
          rootUri: rootPath ? asUri(URI.file(rootPath)) : null,
          capabilities: this.computeClientCapabilities(),
          initializationOptions: func(initializationOptions) ? initializationOptions() : initializationOptions,
          trace: import_vscode_languageserver_protocol43.Trace.toString(this._trace),
          workspaceFolders: null,
          clientInfo: {
            name: "coc.nvim",
            version: workspace_default.version
          }
        };
        this.fillInitializeParams(initParams);
        if (progressOnInitialization) {
          const token = generateUuid();
          initParams.workDoneToken = token;
          const part = new ProgressPart(connection, token);
          part.begin({ title: `initializing ${this.id}`, kind: "begin" });
          return this.doInitialize(connection, initParams).then((result) => {
            part.done();
            return result;
          }, (error) => {
            part.cancel();
            throw error;
          });
        } else {
          return this.doInitialize(connection, initParams);
        }
      }
      doInitialize(connection, initParams) {
        return connection.initialize(initParams).then((result) => {
          this._resolvedConnection = connection;
          this._initializeResult = result;
          this.state = 3;
          let textDocumentSyncOptions = void 0;
          if (number(result.capabilities.textDocumentSync)) {
            if (result.capabilities.textDocumentSync === import_vscode_languageserver_protocol43.TextDocumentSyncKind.None) {
              textDocumentSyncOptions = {
                openClose: false,
                change: import_vscode_languageserver_protocol43.TextDocumentSyncKind.None,
                save: void 0
              };
            } else {
              textDocumentSyncOptions = {
                openClose: true,
                change: result.capabilities.textDocumentSync,
                save: {
                  includeText: false
                }
              };
            }
          } else if (result.capabilities.textDocumentSync != null) {
            textDocumentSyncOptions = result.capabilities.textDocumentSync;
          }
          this._capabilities = Object.assign({}, result.capabilities, {
            resolvedTextDocumentSync: textDocumentSyncOptions
          });
          if (!this._clientOptions.disableDiagnostics) {
            connection.onDiagnostics((params) => this.handleDiagnostics(params));
          }
          connection.onRequest(import_vscode_languageserver_protocol43.RegistrationRequest.type, (params) => this.handleRegistrationRequest(params));
          connection.onRequest("client/registerFeature", (params) => this.handleRegistrationRequest(params));
          connection.onRequest(import_vscode_languageserver_protocol43.UnregistrationRequest.type, (params) => this.handleUnregistrationRequest(params));
          connection.onRequest("client/unregisterFeature", (params) => this.handleUnregistrationRequest(params));
          connection.onRequest(import_vscode_languageserver_protocol43.ApplyWorkspaceEditRequest.type, (params) => this.handleApplyWorkspaceEdit(params));
          connection.sendNotification(import_vscode_languageserver_protocol43.InitializedNotification.type, {});
          this.hookFileEvents(connection);
          this.hookConfigurationChanged(connection);
          this.initializeFeatures(connection);
          this._onReadyCallbacks.resolve();
          return result;
        }).then(void 0, (error) => {
          if (this._clientOptions.initializationFailedHandler) {
            if (this._clientOptions.initializationFailedHandler(error)) {
              this.initialize(connection);
            } else {
              this.stop();
              this._onReadyCallbacks.reject(error);
            }
          } else if (error instanceof import_vscode_languageserver_protocol43.ResponseError && error.data && error.data.retry) {
            window_default.showPrompt(error.message + " Retry?").then((confirmed) => {
              if (confirmed) {
                this.initialize(connection);
              } else {
                this.stop();
                this._onReadyCallbacks.reject(error);
              }
            });
          } else {
            if (error && error.message) {
              window_default.showMessage(error.message, "error");
            }
            this.error("Server initialization failed.", error);
            this.stop();
            this._onReadyCallbacks.reject(error);
          }
          throw error;
        });
      }
      stop() {
        this._initializeResult = void 0;
        if (!this._connectionPromise) {
          this.state = 5;
          return Promise.resolve();
        }
        if (this.state === 4 && this._onStop) {
          return this._onStop;
        }
        this.state = 4;
        this.cleanUp();
        return this._onStop = this.resolveConnection().then((connection) => {
          return connection.shutdown().then(() => {
            connection.exit();
            connection.dispose();
            this.state = 5;
            this.cleanUpChannel();
            this._onStop = void 0;
            this._connectionPromise = void 0;
            this._resolvedConnection = void 0;
          });
        }).catch((e) => {
          logger43.error("Error on stop languageserver:", e);
          this.state = 5;
          this.cleanUpChannel();
          this._onStop = void 0;
          this._connectionPromise = void 0;
          this._resolvedConnection = void 0;
        });
      }
      cleanUp(channel = true, diagnostics = true) {
        if (this._listeners) {
          this._listeners.forEach((listener) => listener.dispose());
          this._listeners = void 0;
        }
        if (this._providers) {
          this._providers.forEach((provider) => provider.dispose());
          this._providers = void 0;
        }
        for (let feature of this._features.values()) {
          if (typeof feature.dispose === "function") {
            feature.dispose();
          } else {
            logger43.error(`Feature can't be disposed`, feature);
          }
        }
        if (this._syncedDocuments) {
          this._syncedDocuments.clear();
        }
        if (channel) {
          this.cleanUpChannel();
        }
        if (this._diagnostics) {
          if (diagnostics) {
            this._diagnostics.dispose();
            this._diagnostics = void 0;
          } else {
            this._diagnostics.clear();
          }
        }
      }
      cleanUpChannel() {
        if (this._outputChannel) {
          this._outputChannel.dispose();
          this._outputChannel = void 0;
        }
      }
      notifyFileEvent(event) {
        var _a2;
        const client = this;
        function didChangeWatchedFile(event2) {
          client._fileEvents.push(event2);
          client._fileEventDelayer.trigger(() => {
            client.onReady().then(() => {
              client.resolveConnection().then((connection) => {
                if (client.isConnectionActive()) {
                  connection.didChangeWatchedFiles({ changes: client._fileEvents });
                }
                client._fileEvents = [];
              });
            }, (error) => {
              client.error(`Notify file events failed.`, error);
            });
          });
        }
        const workSpaceMiddleware = (_a2 = this.clientOptions.middleware) == null ? void 0 : _a2.workspace;
        (workSpaceMiddleware == null ? void 0 : workSpaceMiddleware.didChangeWatchedFile) ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event);
      }
      handleDiagnostics(params) {
        if (!this._diagnostics) {
          return;
        }
        let { uri, diagnostics } = params;
        let middleware = this.clientOptions.middleware.handleDiagnostics;
        if (middleware) {
          middleware(uri, diagnostics, (uri2, diagnostics2) => this.setDiagnostics(uri2, diagnostics2));
        } else {
          this.setDiagnostics(uri, diagnostics);
        }
      }
      setDiagnostics(uri, diagnostics) {
        var _a2;
        if (!this._diagnostics) {
          return;
        }
        const separate = workspace_default.getConfiguration("diagnostic").get("separateRelatedInformationAsDiagnostics");
        if (separate && diagnostics.length > 0) {
          const entries = new Map();
          entries.set(uri, diagnostics);
          for (const diagnostic of diagnostics) {
            if ((_a2 = diagnostic.relatedInformation) == null ? void 0 : _a2.length) {
              let message = `${diagnostic.message}

Related diagnostics:
`;
              for (const info of diagnostic.relatedInformation) {
                const basename = import_path16.default.basename(URI.parse(info.location.uri).fsPath);
                const ln = info.location.range.start.line;
                message = `${message}
${basename}(line ${ln + 1}): ${info.message}`;
                const diags = entries.get(info.location.uri) || [];
                diags.push(import_vscode_languageserver_protocol43.Diagnostic.create(info.location.range, info.message, import_vscode_languageserver_protocol43.DiagnosticSeverity.Hint, diagnostic.code, diagnostic.source));
                entries.set(info.location.uri, diags);
              }
              diagnostic.message = message;
            }
            this._diagnostics.set(Array.from(entries));
          }
        } else {
          this._diagnostics.set(uri, diagnostics);
        }
      }
      createConnection() {
        let errorHandler = (error, message, count) => {
          logger43.error("connection error:", error, message);
          this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
          this.handleConnectionClosed();
        };
        return this.createMessageTransports(this._clientOptions.stdioEncoding || "utf8").then((transports) => {
          return createConnection(transports.reader, transports.writer, errorHandler, closeHandler);
        });
      }
      handleConnectionClosed() {
        if (this.state === 4 || this.state === 5) {
          return;
        }
        try {
          if (this._resolvedConnection) {
            this._resolvedConnection.dispose();
          }
        } catch (error) {
        }
        let action = 1;
        try {
          action = this._clientOptions.errorHandler.closed();
        } catch (error) {
        }
        this._connectionPromise = void 0;
        this._resolvedConnection = void 0;
        if (action === 1) {
          this.error("Connection to server got closed. Server will not be restarted.");
          this.state = 5;
          this.cleanUp(false, true);
        } else if (action === 2) {
          this.info("Connection to server got closed. Server will restart.");
          this.cleanUp(false, true);
          this.state = 0;
          this.start();
        }
      }
      restart() {
        this.cleanUp(true, false);
        this.start();
      }
      handleConnectionError(error, message, count) {
        let action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === 2) {
          this.error("Connection to server is erroring. Shutting down server.");
          this.stop();
        }
      }
      hookConfigurationChanged(connection) {
        workspace_default.onDidChangeConfiguration(() => {
          this.refreshTrace(connection, true);
        });
      }
      refreshTrace(connection, sendNotification = false) {
        let config = workspace_default.getConfiguration(this._id);
        let trace = import_vscode_languageserver_protocol43.Trace.Off;
        let traceFormat = import_vscode_languageserver_protocol43.TraceFormat.Text;
        if (config) {
          const traceConfig = config.get("trace.server", "off");
          if (typeof traceConfig === "string") {
            trace = import_vscode_languageserver_protocol43.Trace.fromString(traceConfig);
          } else {
            trace = import_vscode_languageserver_protocol43.Trace.fromString(config.get("trace.server.verbosity", "off"));
            traceFormat = import_vscode_languageserver_protocol43.TraceFormat.fromString(config.get("trace.server.format", "text"));
          }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
          sendNotification,
          traceFormat: this._traceFormat
        });
      }
      hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents)
          return;
        let watchers;
        if (Array.isArray(fileEvents)) {
          watchers = fileEvents;
        } else {
          watchers = [fileEvents];
        }
        if (!watchers) {
          return;
        }
        this._dynamicFeatures.get(import_vscode_languageserver_protocol43.DidChangeWatchedFilesNotification.type.method).registerRaw(generateUuid(), watchers);
      }
      registerFeatures(features) {
        for (let feature of features) {
          this.registerFeature(feature);
        }
      }
      registerFeature(feature) {
        this._features.push(feature);
        if (DynamicFeature.is(feature)) {
          let messages = feature.messages;
          if (Array.isArray(messages)) {
            for (let message of messages) {
              this._method2Message.set(message.method, message);
              this._dynamicFeatures.set(message.method, feature);
            }
          } else {
            this._method2Message.set(messages.method, messages);
            this._dynamicFeatures.set(messages.method, feature);
          }
        }
      }
      getFeature(request2) {
        return this._dynamicFeatures.get(request2);
      }
      registerBuiltinFeatures() {
        this.registerFeature(new ConfigurationFeature(this));
        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new DidChangeTextDocumentFeature(this));
        this.registerFeature(new WillSaveFeature(this));
        this.registerFeature(new WillSaveWaitUntilFeature(this));
        this.registerFeature(new DidSaveTextDocumentFeature(this));
        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
        if (!this._clientOptions.disableCompletion) {
          this.registerFeature(new CompletionItemFeature(this));
        }
        this.registerFeature(new HoverFeature(this));
        this.registerFeature(new SignatureHelpFeature(this));
        this.registerFeature(new DefinitionFeature(this));
        this.registerFeature(new ReferencesFeature(this));
        this.registerFeature(new DocumentHighlightFeature(this));
        this.registerFeature(new DocumentSymbolFeature(this));
        this.registerFeature(new WorkspaceSymbolFeature(this));
        this.registerFeature(new CodeActionFeature(this));
        this.registerFeature(new CodeLensFeature(this));
        this.registerFeature(new DocumentFormattingFeature(this));
        this.registerFeature(new DocumentRangeFormattingFeature(this));
        this.registerFeature(new DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new RenameFeature(this));
        this.registerFeature(new DocumentLinkFeature(this));
        this.registerFeature(new ExecuteCommandFeature(this));
      }
      fillInitializeParams(params) {
        for (let feature of this._features) {
          if (func(feature.fillInitializeParams)) {
            feature.fillInitializeParams(params);
          }
        }
      }
      computeClientCapabilities() {
        let result = {};
        ensure(result, "workspace").applyEdit = true;
        let workspaceEdit = ensure(ensure(result, "workspace"), "workspaceEdit");
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [import_vscode_languageserver_protocol43.ResourceOperationKind.Create, import_vscode_languageserver_protocol43.ResourceOperationKind.Rename, import_vscode_languageserver_protocol43.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = import_vscode_languageserver_protocol43.FailureHandlingKind.TextOnlyTransactional;
        const diagnostics = ensure(ensure(result, "textDocument"), "publishDiagnostics");
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = false;
        diagnostics.tagSupport = { valueSet: [import_vscode_languageserver_protocol43.DiagnosticTag.Unnecessary, import_vscode_languageserver_protocol43.DiagnosticTag.Deprecated] };
        for (let feature of this._features) {
          feature.fillClientCapabilities(result);
        }
        return result;
      }
      initializeFeatures(_connection) {
        let documentSelector = this._clientOptions.documentSelector;
        for (let feature of this._features) {
          feature.initialize(this._capabilities, documentSelector);
        }
      }
      handleRegistrationRequest(params) {
        if (this.clientOptions.disableDynamicRegister)
          return Promise.resolve();
        return new Promise((resolve3, reject) => {
          for (let registration of params.registrations) {
            const feature = this._dynamicFeatures.get(registration.method);
            if (!feature) {
              reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
              return;
            }
            const options = registration.registerOptions || {};
            options.documentSelector = options.documentSelector || this._clientOptions.documentSelector;
            const data = {
              id: registration.id,
              registerOptions: options
            };
            feature.register(this._method2Message.get(registration.method), data);
          }
          resolve3();
        });
      }
      handleUnregistrationRequest(params) {
        return new Promise((resolve3, reject) => {
          for (let unregistration of params.unregisterations) {
            const feature = this._dynamicFeatures.get(unregistration.method);
            if (!feature) {
              reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
              return;
            }
            feature.unregister(unregistration.id);
          }
          resolve3();
        });
      }
      handleApplyWorkspaceEdit(params) {
        let workspaceEdit = params.edit;
        let openTextDocuments = new Map();
        workspace_default.textDocuments.forEach((document2) => openTextDocuments.set(document2.uri.toString(), document2));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
          for (const change of workspaceEdit.documentChanges) {
            if (import_vscode_languageserver_protocol43.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
              let textDocument = openTextDocuments.get(change.textDocument.uri);
              if (textDocument && textDocument.version !== change.textDocument.version) {
                versionMismatch = true;
                break;
              }
            }
          }
        }
        if (versionMismatch) {
          return Promise.resolve({ applied: false });
        }
        return workspace_default.applyEdit(params.edit).then((value) => {
          return { applied: value };
        });
      }
      logFailedRequest(type, error) {
        if (error instanceof import_vscode_languageserver_protocol43.ResponseError && error.code === import_vscode_languageserver_protocol43.ErrorCodes.RequestCancelled) {
          return;
        }
        this.error(`Request ${type.method} failed.`, error);
      }
    };
  }
});

// src/language-client/colorProvider.ts
function ensure2(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol44, ColorProviderFeature;
var init_colorProvider = __esm({
  "src/language-client/colorProvider.ts"() {
    import_vscode_languageserver_protocol44 = __toModule(require_main2());
    init_languages();
    init_client();
    "use strict";
    ColorProviderFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol44.DocumentColorRequest.type);
      }
      fillClientCapabilities(capabilites) {
        ensure2(ensure2(capabilites, "textDocument"), "colorProvider").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id || !options) {
          return;
        }
        this.register(this.messages, { id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideColorPresentations: (color, context, token) => {
            const client = this._client;
            const provideColorPresentations = (color2, context2, token2) => {
              const requestParams = {
                color: color2,
                textDocument: { uri: context2.document.uri },
                range: context2.range
              };
              return client.sendRequest(import_vscode_languageserver_protocol44.ColorPresentationRequest.type, requestParams, token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol44.ColorPresentationRequest.type, error);
                return Promise.resolve(null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideColorPresentations ? middleware.provideColorPresentations(color, context, token, provideColorPresentations) : provideColorPresentations(color, context, token);
          },
          provideDocumentColors: (document2, token) => {
            const client = this._client;
            const provideDocumentColors = (document3, token2) => {
              const requestParams = {
                textDocument: { uri: document3.uri }
              };
              return client.sendRequest(import_vscode_languageserver_protocol44.DocumentColorRequest.type, requestParams, token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol44.ColorPresentationRequest.type, error);
                return Promise.resolve(null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideDocumentColors ? middleware.provideDocumentColors(document2, token, provideDocumentColors) : provideDocumentColors(document2, token);
          }
        };
        return [languages_default.registerDocumentColorProvider(options.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/configuration.ts
function toJSONObject(obj) {
  if (obj) {
    if (Array.isArray(obj)) {
      return obj.map(toJSONObject);
    } else if (typeof obj === "object") {
      const res = Object.create(null);
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          res[key] = toJSONObject(obj[key]);
        }
      }
      return res;
    }
  }
  return obj;
}
var import_vscode_languageserver_protocol45, logger44, ConfigurationFeature2;
var init_configuration3 = __esm({
  "src/language-client/configuration.ts"() {
    import_vscode_languageserver_protocol45 = __toModule(require_main2());
    init_workspace();
    logger44 = require_logger2()("languageclient-configuration");
    ConfigurationFeature2 = class {
      constructor(_client) {
        this._client = _client;
        var _a2;
        let section2 = (_a2 = this._client.clientOptions.synchronize) == null ? void 0 : _a2.configurationSection;
        if (typeof section2 === "string" && section2.startsWith("languageserver.")) {
          this.languageserverSection = section2;
        }
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
      }
      initialize() {
        let client = this._client;
        client.onRequest(import_vscode_languageserver_protocol45.ConfigurationRequest.type, (params, token) => {
          let configuration = (params2) => {
            let result = [];
            for (let item of params2.items) {
              result.push(this.getConfiguration(item.scopeUri, item.section));
            }
            return result;
          };
          let middleware = client.clientOptions.middleware.workspace;
          return middleware && middleware.configuration ? middleware.configuration(params, token, configuration) : configuration(params, token);
        });
      }
      getConfiguration(resource, section2) {
        let result = null;
        if (section2) {
          if (this.languageserverSection) {
            section2 = `${this.languageserverSection}.${section2}`;
          }
          let index = section2.lastIndexOf(".");
          if (index === -1) {
            result = workspace_default.getConfiguration(void 0, resource).get(section2, {});
          } else {
            let config = workspace_default.getConfiguration(section2.substr(0, index), resource);
            if (config) {
              result = config.get(section2.substr(index + 1));
            }
          }
        } else {
          let config = workspace_default.getConfiguration(this.languageserverSection, resource);
          result = {};
          for (let key of Object.keys(config)) {
            if (config.has(key)) {
              result[key] = toJSONObject(config.get(key));
            }
          }
        }
        return result;
      }
      dispose() {
      }
    };
  }
});

// src/language-client/declaration.ts
function ensure3(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol46, DeclarationFeature;
var init_declaration = __esm({
  "src/language-client/declaration.ts"() {
    import_vscode_languageserver_protocol46 = __toModule(require_main2());
    init_languages();
    init_client();
    init_converter();
    "use strict";
    DeclarationFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol46.DeclarationRequest.type);
      }
      fillClientCapabilities(capabilites) {
        let declarationSupport = ensure3(ensure3(capabilites, "textDocument"), "declaration");
        declarationSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id || !options) {
          return;
        }
        this.register(this.messages, { id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideDeclaration: (document2, position, token) => {
            const client = this._client;
            const provideDeclaration = (document3, position2, token2) => client.sendRequest(import_vscode_languageserver_protocol46.DeclarationRequest.type, asTextDocumentPositionParams(document3, position2), token2).then((res) => res, (error) => {
              client.logFailedRequest(import_vscode_languageserver_protocol46.DeclarationRequest.type, error);
              return Promise.resolve(null);
            });
            const middleware = client.clientOptions.middleware;
            return middleware.provideDeclaration ? middleware.provideDeclaration(document2, position, token, provideDeclaration) : provideDeclaration(document2, position, token);
          }
        };
        return [languages_default.registerDeclarationProvider(options.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/foldingRange.ts
function ensure4(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol47, FoldingRangeFeature;
var init_foldingRange = __esm({
  "src/language-client/foldingRange.ts"() {
    import_vscode_languageserver_protocol47 = __toModule(require_main2());
    init_languages();
    init_client();
    "use strict";
    FoldingRangeFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol47.FoldingRangeRequest.type);
      }
      fillClientCapabilities(capabilites) {
        let capability = ensure4(ensure4(capabilites, "textDocument"), "foldingRange");
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5e3;
        capability.lineFoldingOnly = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register(this.messages, { id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideFoldingRanges: (document2, context, token) => {
            const client = this._client;
            const provideFoldingRanges = (document3, _, token2) => {
              const requestParams = {
                textDocument: { uri: document3.uri }
              };
              return client.sendRequest(import_vscode_languageserver_protocol47.FoldingRangeRequest.type, requestParams, token2).then((res) => res, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol47.FoldingRangeRequest.type, error);
                return Promise.resolve(null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideFoldingRanges ? middleware.provideFoldingRanges(document2, context, token, provideFoldingRanges) : provideFoldingRanges(document2, context, token);
          }
        };
        return [languages_default.registerFoldingRangeProvider(options.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/implementation.ts
function ensure5(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol48, ImplementationFeature;
var init_implementation = __esm({
  "src/language-client/implementation.ts"() {
    import_vscode_languageserver_protocol48 = __toModule(require_main2());
    init_languages();
    init_client();
    init_converter();
    ImplementationFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol48.ImplementationRequest.type);
      }
      fillClientCapabilities(capabilites) {
        const implementationSupport = ensure5(ensure5(capabilites, "textDocument"), "implementation");
        implementationSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id || !options) {
          return;
        }
        this.register(this.messages, { id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideImplementation: (document2, position, token) => {
            const client = this._client;
            const provideImplementation = (document3, position2, token2) => client.sendRequest(import_vscode_languageserver_protocol48.ImplementationRequest.type, asTextDocumentPositionParams(document3, position2), token2).then((res) => res, (error) => {
              client.logFailedRequest(import_vscode_languageserver_protocol48.ImplementationRequest.type, error);
              return Promise.resolve(null);
            });
            const middleware = client.clientOptions.middleware;
            return middleware.provideImplementation ? middleware.provideImplementation(document2, position, token, provideImplementation) : provideImplementation(document2, position, token);
          }
        };
        return [languages_default.registerImplementationProvider(options.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/progress.ts
function ensure6(target, key) {
  if (target[key] === void 0) {
    target[key] = Object.create(null);
  }
  return target[key];
}
var import_vscode_languageserver_protocol49, ProgressFeature;
var init_progress2 = __esm({
  "src/language-client/progress.ts"() {
    import_vscode_languageserver_protocol49 = __toModule(require_main2());
    init_progressPart();
    "use strict";
    ProgressFeature = class {
      constructor(_client) {
        this._client = _client;
        this.activeParts = new Set();
      }
      fillClientCapabilities(capabilities) {
        ensure6(capabilities, "window").workDoneProgress = true;
      }
      initialize() {
        let client = this._client;
        const deleteHandler = (part) => {
          this.activeParts.delete(part);
        };
        const createHandler = (params) => {
          this.activeParts.add(new ProgressPart(this._client, params.token, deleteHandler));
        };
        client.onRequest(import_vscode_languageserver_protocol49.WorkDoneProgressCreateRequest.type, createHandler);
      }
      dispose() {
        for (const part of this.activeParts) {
          part.done();
        }
        this.activeParts.clear();
      }
    };
  }
});

// src/language-client/typeDefinition.ts
function ensure7(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol50, TypeDefinitionFeature;
var init_typeDefinition = __esm({
  "src/language-client/typeDefinition.ts"() {
    import_vscode_languageserver_protocol50 = __toModule(require_main2());
    init_languages();
    init_client();
    init_converter();
    TypeDefinitionFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol50.TypeDefinitionRequest.type);
      }
      fillClientCapabilities(capabilites) {
        const typeDefinitionSupport = ensure7(ensure7(capabilites, "textDocument"), "typeDefinition");
        typeDefinitionSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id || !options) {
          return;
        }
        this.register(this.messages, { id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideTypeDefinition: (document2, position, token) => {
            const client = this._client;
            const provideTypeDefinition = (document3, position2, token2) => client.sendRequest(import_vscode_languageserver_protocol50.TypeDefinitionRequest.type, asTextDocumentPositionParams(document3, position2), token2).then((res) => res, (error) => {
              client.logFailedRequest(import_vscode_languageserver_protocol50.TypeDefinitionRequest.type, error);
              return Promise.resolve(null);
            });
            const middleware = client.clientOptions.middleware;
            return middleware.provideTypeDefinition ? middleware.provideTypeDefinition(document2, position, token, provideTypeDefinition) : provideTypeDefinition(document2, position, token);
          }
        };
        return [languages_default.registerTypeDefinitionProvider(options.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/workspaceFolders.ts
function access(target, key) {
  if (target === void 0) {
    return void 0;
  }
  return target[key];
}
function arrayDiff(left, right) {
  return left.filter((element) => !right.includes(element));
}
var import_vscode_languageserver_protocol51, import_os8, logger45, WorkspaceFoldersFeature;
var init_workspaceFolders = __esm({
  "src/language-client/workspaceFolders.ts"() {
    import_vscode_languageserver_protocol51 = __toModule(require_main2());
    init_workspace();
    import_os8 = __toModule(require("os"));
    init_uuid();
    init_esm2();
    "use strict";
    logger45 = require_logger2()("language-client-workspaceFolder");
    WorkspaceFoldersFeature = class {
      constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
      }
      get messages() {
        return import_vscode_languageserver_protocol51.DidChangeWorkspaceFoldersNotification.type;
      }
      getValidWorkspaceFolders() {
        let { workspaceFolders } = workspace_default;
        if (!workspaceFolders || workspaceFolders.length == 0)
          return void 0;
        let home = import_os8.default.homedir();
        let { ignoredRootPaths } = this._client.clientOptions;
        if (!Array.isArray(ignoredRootPaths)) {
          ignoredRootPaths = [];
        }
        let arr = workspaceFolders.filter((o) => {
          let fsPath = URI.parse(o.uri).fsPath;
          return fsPath != home && !ignoredRootPaths.includes(fsPath);
        });
        return arr.length ? arr : void 0;
      }
      asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
          return null;
        }
        return { uri: workspaceFolder.uri, name: workspaceFolder.name };
      }
      fillInitializeParams(params) {
        const folders = this.getValidWorkspaceFolders();
        this._initialFolders = folders;
        if (folders == null) {
          params.workspaceFolders = null;
        } else {
          params.workspaceFolders = folders.map((folder) => this.asProtocol(folder));
        }
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
      }
      initialize(capabilities) {
        let client = this._client;
        client.onRequest(import_vscode_languageserver_protocol51.WorkspaceFoldersRequest.type, (token) => {
          let workspaceFolders = () => {
            let folders = this.getValidWorkspaceFolders();
            if (folders === void 0) {
              return null;
            }
            let result = folders.map((folder) => this.asProtocol(folder));
            return result;
          };
          let middleware = client.clientOptions.middleware.workspace;
          return middleware && middleware.workspaceFolders ? middleware.workspaceFolders(token, workspaceFolders) : workspaceFolders(token);
        });
        let value = access(access(access(capabilities, "workspace"), "workspaceFolders"), "changeNotifications");
        let id;
        if (typeof value === "string") {
          id = value;
        } else if (value === true) {
          id = generateUuid();
        }
        if (id) {
          this.register(this.messages, {
            id,
            registerOptions: void 0
          });
        }
      }
      doSendEvent(addedFolders, removedFolders) {
        let params = {
          event: {
            added: addedFolders.map((folder) => this.asProtocol(folder)),
            removed: removedFolders.map((folder) => this.asProtocol(folder))
          }
        };
        this._client.sendNotification(import_vscode_languageserver_protocol51.DidChangeWorkspaceFoldersNotification.type, params);
      }
      sendInitialEvent(currentWorkspaceFolders) {
        if (this._initialFolders && currentWorkspaceFolders) {
          const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
          const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
          if (added.length > 0 || removed.length > 0) {
            this.doSendEvent(added, removed);
          }
        } else if (this._initialFolders) {
          this.doSendEvent([], this._initialFolders);
        } else if (currentWorkspaceFolders) {
          this.doSendEvent(currentWorkspaceFolders, []);
        }
      }
      register(_message, data) {
        let id = data.id;
        let client = this._client;
        let disposable = workspace_default.onDidChangeWorkspaceFolders((event) => {
          let didChangeWorkspaceFolders = (event2) => {
            this.doSendEvent(event2.added, event2.removed);
          };
          let middleware = client.clientOptions.middleware.workspace;
          middleware && middleware.didChangeWorkspaceFolders ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders) : didChangeWorkspaceFolders(event);
        });
        this._listeners.set(id, disposable);
        let workspaceFolders = this.getValidWorkspaceFolders();
        this.sendInitialEvent(workspaceFolders);
      }
      unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
          return;
        }
        this._listeners.delete(id);
        disposable.dispose();
      }
      dispose() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
    };
  }
});

// src/language-client/selectionRange.ts
function ensure8(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol52, SelectionRangeFeature;
var init_selectionRange = __esm({
  "src/language-client/selectionRange.ts"() {
    import_vscode_languageserver_protocol52 = __toModule(require_main2());
    init_languages();
    init_client();
    "use strict";
    SelectionRangeFeature = class extends TextDocumentFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol52.SelectionRangeRequest.type);
      }
      fillClientCapabilities(capabilites) {
        let capability = ensure8(ensure8(capabilites, "textDocument"), "selectionRange");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
        if (!id || !options) {
          return;
        }
        this.register(this.messages, { id, registerOptions: options });
      }
      registerLanguageProvider(options) {
        const provider = {
          provideSelectionRanges: (document2, positions2, token) => {
            const client = this._client;
            const provideSelectionRanges = (document3, positions3, token2) => {
              const requestParams = {
                textDocument: { uri: document3.uri },
                positions: positions3
              };
              return client.sendRequest(import_vscode_languageserver_protocol52.SelectionRangeRequest.type, requestParams, token2).then((ranges) => ranges, (error) => {
                client.logFailedRequest(import_vscode_languageserver_protocol52.SelectionRangeRequest.type, error);
                return Promise.resolve(null);
              });
            };
            const middleware = client.clientOptions.middleware;
            return middleware.provideSelectionRanges ? middleware.provideSelectionRanges(document2, positions2, token, provideSelectionRanges) : provideSelectionRanges(document2, positions2, token);
          }
        };
        return [languages_default.registerSelectionRangeProvider(options.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/index.ts
var import_child_process4, import_fs16, import_path17, import_vscode_languageserver_protocol53, ChildProcess2, logger46, Executable, TransportKind, Transport, NodeModule, StreamInfo, ChildProcessInfo, LanguageClient, SettingMonitor, ProposedFeatures;
var init_language_client = __esm({
  "src/language-client/index.ts"() {
    import_child_process4 = __toModule(require("child_process"));
    import_fs16 = __toModule(require("fs"));
    import_path17 = __toModule(require("path"));
    import_vscode_languageserver_protocol53 = __toModule(require_main2());
    init_types();
    init_util();
    init_is();
    init_processes();
    init_workspace();
    init_client();
    init_colorProvider();
    init_configuration3();
    init_declaration();
    init_foldingRange();
    init_implementation();
    init_progress2();
    init_typeDefinition();
    init_workspaceFolders();
    init_selectionRange();
    init_client();
    ChildProcess2 = import_child_process4.default.ChildProcess;
    logger46 = require_logger2()("language-client-index");
    (function(Executable3) {
      function is(value) {
        return string(value.command);
      }
      Executable3.is = is;
    })(Executable || (Executable = {}));
    (function(TransportKind2) {
      TransportKind2[TransportKind2["stdio"] = 0] = "stdio";
      TransportKind2[TransportKind2["ipc"] = 1] = "ipc";
      TransportKind2[TransportKind2["pipe"] = 2] = "pipe";
      TransportKind2[TransportKind2["socket"] = 3] = "socket";
    })(TransportKind || (TransportKind = {}));
    (function(Transport3) {
      function isSocket(value) {
        let candidate = value;
        return candidate && candidate.kind === 3 && number(candidate.port);
      }
      Transport3.isSocket = isSocket;
    })(Transport || (Transport = {}));
    (function(NodeModule2) {
      function is(value) {
        return string(value.module);
      }
      NodeModule2.is = is;
    })(NodeModule || (NodeModule = {}));
    (function(StreamInfo2) {
      function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;
      }
      StreamInfo2.is = is;
    })(StreamInfo || (StreamInfo = {}));
    (function(ChildProcessInfo2) {
      function is(value) {
        let candidate = value;
        return candidate && candidate.process !== void 0 && typeof candidate.detached === "boolean";
      }
      ChildProcessInfo2.is = is;
    })(ChildProcessInfo || (ChildProcessInfo = {}));
    LanguageClient = class extends BaseLanguageClient {
      constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name2;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (string(arg2)) {
          id = arg1;
          name2 = arg2;
          serverOptions = arg3;
          clientOptions = arg4;
          forceDebug = !!arg5;
        } else {
          id = arg1.toLowerCase();
          name2 = arg1;
          serverOptions = arg2;
          clientOptions = arg3;
          forceDebug = arg4;
        }
        if (forceDebug === void 0) {
          forceDebug = false;
        }
        super(id, name2, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = forceDebug;
        this.registerProposedFeatures();
      }
      stop() {
        return super.stop().then(() => {
          if (this._serverProcess) {
            let toCheck = this._serverProcess;
            this._serverProcess = void 0;
            if (this._isDetached === void 0 || !this._isDetached) {
              this.checkProcessDied(toCheck);
            }
            this._isDetached = void 0;
          }
        });
      }
      get serviceState() {
        let state = this._state;
        switch (state) {
          case ClientState.Initial:
            return ServiceStat.Initial;
          case ClientState.Running:
            return ServiceStat.Running;
          case ClientState.StartFailed:
            return ServiceStat.StartFailed;
          case ClientState.Starting:
            return ServiceStat.Starting;
          case ClientState.Stopped:
            return ServiceStat.Stopped;
          case ClientState.Stopping:
            return ServiceStat.Stopping;
          default:
            logger46.error(`Unknown state: ${state}`);
            return ServiceStat.Stopped;
        }
      }
      static stateName(state) {
        switch (state) {
          case ClientState.Initial:
            return "Initial";
          case ClientState.Running:
            return "Running";
          case ClientState.StartFailed:
            return "StartFailed";
          case ClientState.Starting:
            return "Starting";
          case ClientState.Stopped:
            return "Stopped";
          case ClientState.Stopping:
            return "Stopping";
          default:
            return "Unknonw";
        }
      }
      checkProcessDied(childProcess) {
        if (!childProcess || global.hasOwnProperty("__TEST__"))
          return;
        if (global.hasOwnProperty("__TEST__")) {
          process.kill(childProcess.pid, 0);
          return;
        }
        setTimeout(() => {
          try {
            process.kill(childProcess.pid, 0);
            terminate(childProcess);
          } catch (error) {
          }
        }, 2e3);
      }
      handleConnectionClosed() {
        this._serverProcess = void 0;
        super.handleConnectionClosed();
      }
      createMessageTransports(encoding) {
        function getEnvironment(env) {
          if (!env)
            return process.env;
          return Object.assign({}, process.env, env);
        }
        function startedInDebugMode() {
          let args = process.execArgv;
          if (args) {
            return args.some((arg) => /^--debug=?/.test(arg) || /^--debug-brk=?/.test(arg) || /^--inspect=?/.test(arg) || /^--inspect-brk=?/.test(arg));
          }
          return false;
        }
        let server = this._serverOptions;
        if (func(server)) {
          return server().then((result) => {
            if (MessageTransports.is(result)) {
              this._isDetached = !!result.detached;
              return result;
            } else if (StreamInfo.is(result)) {
              this._isDetached = !!result.detached;
              return {
                reader: new import_vscode_languageserver_protocol53.StreamMessageReader(result.reader),
                writer: new import_vscode_languageserver_protocol53.StreamMessageWriter(result.writer)
              };
            } else {
              let cp3;
              if (ChildProcessInfo.is(result)) {
                cp3 = result.process;
                this._isDetached = result.detached;
              } else {
                cp3 = result;
                this._isDetached = false;
              }
              cp3.stderr.on("data", (data) => this.appendOutput(data, encoding));
              return {
                reader: new import_vscode_languageserver_protocol53.StreamMessageReader(cp3.stdout),
                writer: new import_vscode_languageserver_protocol53.StreamMessageWriter(cp3.stdin)
              };
            }
          });
        }
        let json = server;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
          if (typeof v8debug === "object" || this._forceDebug || startedInDebugMode()) {
            json = runDebug.debug;
          } else {
            json = runDebug.run;
          }
        } else {
          json = server;
        }
        return this._getServerWorkingDir(json.options).then((serverWorkingDir) => {
          if (NodeModule.is(json) && json.module) {
            let node = json;
            let transport = node.transport || 0;
            let args = [];
            let options = node.options || Object.create(null);
            let runtime = node.runtime || process.execPath;
            if (options.execArgv)
              options.execArgv.forEach((element) => args.push(element));
            if (transport != 1)
              args.push(node.module);
            if (node.args)
              node.args.forEach((element) => args.push(element));
            let execOptions = Object.create(null);
            execOptions.cwd = serverWorkingDir;
            execOptions.env = getEnvironment(options.env);
            let pipeName;
            if (transport === 1) {
              execOptions.stdio = [null, null, null];
              args.push("--node-ipc");
            } else if (transport === 0) {
              args.push("--stdio");
            } else if (transport === 2) {
              pipeName = (0, import_vscode_languageserver_protocol53.generateRandomPipeName)();
              args.push(`--pipe=${pipeName}`);
            } else if (Transport.isSocket(transport)) {
              args.push(`--socket=${transport.port}`);
            }
            args.push(`--clientProcessId=${process.pid.toString()}`);
            if (transport === 1) {
              let forkOptions = {
                cwd: serverWorkingDir,
                env: getEnvironment(options.env),
                stdio: [null, null, null, "ipc"],
                execPath: runtime,
                execArgv: options.execArgv || []
              };
              let serverProcess = import_child_process4.default.fork(node.module, args, forkOptions);
              if (!serverProcess || !serverProcess.pid) {
                return Promise.reject(`Launching server module "${node.module}" failed.`);
              }
              serverProcess.on("error", (e) => {
                logger46.error(e);
              });
              logger46.info(`${this.id} started with ${serverProcess.pid}`);
              this._serverProcess = serverProcess;
              serverProcess.stdout.on("data", (data) => this.appendOutput(data, encoding));
              serverProcess.stderr.on("data", (data) => this.appendOutput(data, encoding));
              return {
                reader: new import_vscode_languageserver_protocol53.IPCMessageReader(serverProcess),
                writer: new import_vscode_languageserver_protocol53.IPCMessageWriter(serverProcess)
              };
            } else if (transport === 0) {
              let serverProcess = import_child_process4.default.spawn(runtime, args, execOptions);
              if (!serverProcess || !serverProcess.pid) {
                return Promise.reject(`Launching server module "${node.module}" failed.`);
              }
              logger46.info(`${this.id} started with ${serverProcess.pid}`);
              serverProcess.on("error", (e) => {
                logger46.error(`Process ${runtime} error: `, e);
              });
              this._serverProcess = serverProcess;
              serverProcess.stderr.on("data", (data) => this.appendOutput(data, encoding));
              return {
                reader: new import_vscode_languageserver_protocol53.StreamMessageReader(serverProcess.stdout),
                writer: new import_vscode_languageserver_protocol53.StreamMessageWriter(serverProcess.stdin)
              };
            } else if (transport == 2) {
              return Promise.resolve((0, import_vscode_languageserver_protocol53.createClientPipeTransport)(pipeName)).then((transport2) => {
                let process2 = import_child_process4.default.spawn(runtime, args, execOptions);
                if (!process2 || !process2.pid) {
                  return Promise.reject(`Launching server module "${node.module}" failed.`);
                }
                logger46.info(`Language server ${this.id} started with ${process2.pid}`);
                this._serverProcess = process2;
                process2.stderr.on("data", (data) => this.appendOutput(data, encoding));
                process2.stdout.on("data", (data) => this.appendOutput(data, encoding));
                return Promise.resolve(transport2.onConnected()).then((protocol) => ({ reader: protocol[0], writer: protocol[1] }));
              });
            } else if (Transport.isSocket(node.transport)) {
              return Promise.resolve((0, import_vscode_languageserver_protocol53.createClientSocketTransport)(node.transport.port)).then((transport2) => {
                let process2 = import_child_process4.default.spawn(runtime, args, execOptions);
                if (!process2 || !process2.pid) {
                  return Promise.reject(`Launching server ${node.module} failed.`);
                }
                process2.on("exit", (code) => {
                  if (code != 0)
                    this.error(`command "${runtime} ${args.join(" ")}" exited with code: ${code}`);
                });
                logger46.info(`Language server ${this.id} started with ${process2.pid}`);
                this._serverProcess = process2;
                process2.stderr.on("data", (data) => this.appendOutput(data, encoding));
                process2.stdout.on("data", (data) => this.appendOutput(data, encoding));
                return Promise.resolve(transport2.onConnected()).then((protocol) => ({ reader: protocol[0], writer: protocol[1] }));
              });
            }
          } else if (Executable.is(json) && json.command) {
            let command = json;
            let args = command.args || [];
            let options = Object.assign({}, command.options);
            options.env = options.env ? Object.assign({}, process.env, options.env) : process.env;
            options.cwd = serverWorkingDir;
            let cmd = workspace_default.expand(json.command);
            let serverProcess = import_child_process4.default.spawn(cmd, args, options);
            serverProcess.on("error", (e) => {
              this.error(e.message);
              logger46.error(e);
            });
            if (!serverProcess || !serverProcess.pid) {
              return Promise.reject(`Launching server "${this.id}" using command ${command.command} failed.`);
            }
            logger46.info(`Language server "${this.id}" started with ${serverProcess.pid}`);
            serverProcess.on("exit", (code) => {
              if (code != 0)
                this.error(`${command.command} exited with code: ${code}`);
            });
            serverProcess.stderr.on("data", (data) => this.appendOutput(data, encoding));
            this._serverProcess = serverProcess;
            this._isDetached = !!options.detached;
            return {
              reader: new import_vscode_languageserver_protocol53.StreamMessageReader(serverProcess.stdout),
              writer: new import_vscode_languageserver_protocol53.StreamMessageWriter(serverProcess.stdin)
            };
          }
          return Promise.reject(`Unsupported server configuration ${JSON.stringify(server, null, 2)}`);
        });
      }
      registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
      }
      registerBuiltinFeatures() {
        super.registerBuiltinFeatures();
        this.registerFeature(new ConfigurationFeature2(this));
        this.registerFeature(new TypeDefinitionFeature(this));
        this.registerFeature(new ImplementationFeature(this));
        this.registerFeature(new DeclarationFeature(this));
        this.registerFeature(new ColorProviderFeature(this));
        this.registerFeature(new FoldingRangeFeature(this));
        this.registerFeature(new SelectionRangeFeature(this));
        this.registerFeature(new ProgressFeature(this));
        if (!this.clientOptions.disableWorkspaceFolders) {
          this.registerFeature(new WorkspaceFoldersFeature(this));
        }
      }
      _getServerWorkingDir(options) {
        let cwd = options && options.cwd;
        if (cwd && !import_path17.default.isAbsolute(cwd))
          cwd = import_path17.default.join(workspace_default.cwd, cwd);
        if (!cwd)
          cwd = workspace_default.cwd;
        if (cwd) {
          return new Promise((s) => {
            import_fs16.default.lstat(cwd, (err, stats) => {
              s(!err && stats.isDirectory() ? cwd : void 0);
            });
          });
        }
        return Promise.resolve(void 0);
      }
      appendOutput(data, encoding) {
        let msg = string(data) ? data : data.toString(encoding);
        this.outputChannel.append(msg.endsWith("\n") ? msg : msg + "\n");
      }
    };
    SettingMonitor = class {
      constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
      }
      start() {
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration(this._setting)) {
            this.onDidChangeConfiguration();
          }
        }, null, this._listeners);
        this.onDidChangeConfiguration();
        return {
          dispose: () => {
            disposeAll(this._listeners);
            if (this._client.needsStop()) {
              this._client.stop();
            }
          }
        };
      }
      onDidChangeConfiguration() {
        let index = this._setting.indexOf(".");
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : void 0;
        let enabled = rest ? workspace_default.getConfiguration(primary).get(rest, true) : workspace_default.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
          this._client.start();
        } else if (!enabled && this._client.needsStop()) {
          this._client.stop();
        }
      }
    };
    (function(ProposedFeatures2) {
      function createAll(_client) {
        let result = [];
        return result;
      }
      ProposedFeatures2.createAll = createAll;
    })(ProposedFeatures || (ProposedFeatures = {}));
  }
});

// src/services.ts
function getStateName(state) {
  switch (state) {
    case ServiceStat.Initial:
      return "init";
    case ServiceStat.Running:
      return "running";
    case ServiceStat.Starting:
      return "starting";
    case ServiceStat.StartFailed:
      return "startFailed";
    case ServiceStat.Stopping:
      return "stopping";
    case ServiceStat.Stopped:
      return "stopped";
    default:
      return "unknown";
  }
}
function documentSelectorToLanguageIds(documentSelector) {
  let res = documentSelector.map((filter) => {
    if (typeof filter == "string") {
      return filter;
    }
    return filter.language;
  });
  res = res.filter((s) => typeof s == "string");
  return Array.from(new Set(res));
}
function getLanguageServerOptions(id, name2, config) {
  let { command, module: module2, port, args, filetypes } = config;
  args = args || [];
  if (!filetypes) {
    window_default.showMessage(`Wrong configuration of LS "${name2}", filetypes not found`, "error");
    return null;
  }
  if (!command && !module2 && !port) {
    window_default.showMessage(`Wrong configuration of LS "${name2}", no command or module specified.`, "error");
    return null;
  }
  let serverOptions;
  if (module2) {
    module2 = workspace_default.expand(module2);
    if (!import_fs17.default.existsSync(module2)) {
      window_default.showMessage(`Module file "${module2}" not found for LS "${name2}"`, "error");
      return null;
    }
    serverOptions = {
      module: module2,
      runtime: config.runtime || process.execPath,
      args,
      transport: getTransportKind(config),
      options: getForkOptions(config)
    };
  } else if (command) {
    serverOptions = {
      command,
      args,
      options: getSpawnOptions(config)
    };
  } else if (port) {
    serverOptions = () => new Promise((resolve3, reject) => {
      let client = new import_net2.default.Socket();
      let host = config.host || "127.0.0.1";
      logger47.info(`languageserver "${id}" connecting to ${host}:${port}`);
      client.connect(port, host, () => {
        resolve3({
          reader: client,
          writer: client
        });
      });
      client.on("error", (e) => {
        reject(new Error(`Connection error for ${id}: ${e.message}`));
      });
    });
  }
  let disableWorkspaceFolders = !!config.disableWorkspaceFolders;
  let disableSnippetCompletion = !!config.disableSnippetCompletion;
  let ignoredRootPaths = config.ignoredRootPaths || [];
  let clientOptions = {
    ignoredRootPaths: ignoredRootPaths.map((s) => workspace_default.expand(s)),
    disableWorkspaceFolders,
    disableSnippetCompletion,
    disableDynamicRegister: !!config.disableDynamicRegister,
    disableCompletion: !!config.disableCompletion,
    disableDiagnostics: !!config.disableDiagnostics,
    formatterPriority: config.formatterPriority || 0,
    documentSelector: getDocumentSelector(config.filetypes, config.additionalSchemes),
    revealOutputChannelOn: getRevealOutputChannelOn(config.revealOutputChannelOn),
    synchronize: {
      configurationSection: `${id}.settings`
    },
    diagnosticCollectionName: name2,
    outputChannelName: id,
    stdioEncoding: config.stdioEncoding || "utf8",
    progressOnInitialization: config.progressOnInitialization !== false,
    initializationOptions: config.initializationOptions || {}
  };
  return [clientOptions, serverOptions];
}
function getRevealOutputChannelOn(revealOn) {
  switch (revealOn) {
    case "info":
      return RevealOutputChannelOn.Info;
    case "warn":
      return RevealOutputChannelOn.Warn;
    case "error":
      return RevealOutputChannelOn.Error;
    case "never":
      return RevealOutputChannelOn.Never;
    default:
      return RevealOutputChannelOn.Never;
  }
}
function getDocumentSelector(filetypes, additionalSchemes) {
  let documentSelector = [];
  let schemes = ["file", "untitled"].concat(additionalSchemes || []);
  if (!filetypes)
    return schemes.map((s) => ({ scheme: s }));
  filetypes.forEach((filetype) => {
    documentSelector.push(...schemes.map((scheme) => ({ language: filetype, scheme })));
  });
  return documentSelector;
}
function getTransportKind(config) {
  let { transport, transportPort } = config;
  if (!transport || transport == "ipc")
    return TransportKind.ipc;
  if (transport == "stdio")
    return TransportKind.stdio;
  if (transport == "pipe")
    return TransportKind.pipe;
  return { kind: TransportKind.socket, port: transportPort };
}
function getForkOptions(config) {
  return {
    cwd: config.cwd,
    execArgv: config.execArgv || [],
    env: config.env || void 0
  };
}
function getSpawnOptions(config) {
  return {
    cwd: config.cwd,
    detached: !!config.detached,
    shell: !!config.shell,
    env: config.env || void 0
  };
}
function stateString(state) {
  switch (state) {
    case State2.Running:
      return "running";
    case State2.Starting:
      return "starting";
    case State2.Stopped:
      return "stopped";
    default:
      return "unknown";
  }
}
var import_events14, import_fs17, import_net2, import_vscode_languageserver_protocol54, logger47, ServiceManager, services_default;
var init_services = __esm({
  "src/services.ts"() {
    import_events14 = __toModule(require("events"));
    import_fs17 = __toModule(require("fs"));
    import_net2 = __toModule(require("net"));
    import_vscode_languageserver_protocol54 = __toModule(require_main2());
    init_language_client();
    init_types();
    init_util();
    init_workspace();
    init_window();
    logger47 = require_logger2()("services");
    ServiceManager = class extends import_events14.EventEmitter {
      constructor() {
        super(...arguments);
        this.registered = new Map();
        this.disposables = [];
      }
      init() {
        workspace_default.onDidOpenTextDocument((document2) => {
          this.start(document2);
        }, null, this.disposables);
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("languageserver")) {
            this.createCustomServices();
          }
        }, null, this.disposables);
        this.createCustomServices();
      }
      dispose() {
        this.removeAllListeners();
        disposeAll(this.disposables);
        for (let service of this.registered.values()) {
          service.dispose();
        }
      }
      regist(service) {
        let { id } = service;
        if (!id)
          logger47.error("invalid service configuration. ", service.name);
        if (this.registered.get(id))
          return;
        this.registered.set(id, service);
        logger47.info(`registered service "${id}"`);
        if (this.shouldStart(service)) {
          service.start();
        }
        if (service.state == ServiceStat.Running) {
          this.emit("ready", id);
        }
        service.onServiceReady(() => {
          logger47.info(`service ${id} started`);
          this.emit("ready", id);
        }, null, this.disposables);
        return import_vscode_languageserver_protocol54.Disposable.create(() => {
          service.stop();
          service.dispose();
          this.registered.delete(id);
        });
      }
      getService(id) {
        let service = this.registered.get(id);
        if (!service)
          service = this.registered.get(`languageserver.${id}`);
        return service;
      }
      shouldStart(service) {
        if (service.state != ServiceStat.Initial) {
          return false;
        }
        let selector = service.selector;
        for (let doc of workspace_default.documents) {
          if (workspace_default.match(selector, doc.textDocument)) {
            return true;
          }
        }
        return false;
      }
      start(document2) {
        let services = this.getServices(document2);
        for (let service of services) {
          if (service.state == ServiceStat.Initial) {
            service.start();
          }
        }
      }
      getServices(document2) {
        let res = [];
        for (let service of this.registered.values()) {
          if (workspace_default.match(service.selector, document2) > 0) {
            res.push(service);
          }
        }
        return res;
      }
      stop(id) {
        let service = this.registered.get(id);
        if (!service) {
          window_default.showMessage(`Service ${id} not found`, "error");
          return;
        }
        return Promise.resolve(service.stop());
      }
      stopAll() {
        for (let service of this.registered.values()) {
          service.stop();
        }
      }
      async toggle(id) {
        let service = this.registered.get(id);
        if (!service) {
          window_default.showMessage(`Service ${id} not found`, "error");
          return;
        }
        let { state } = service;
        try {
          if (state == ServiceStat.Running) {
            await Promise.resolve(service.stop());
          } else if (state == ServiceStat.Initial) {
            await service.start();
          } else if (state == ServiceStat.Stopped) {
            await service.restart();
          }
        } catch (e) {
          window_default.showMessage(`Service error: ${e.message}`, "error");
        }
      }
      getServiceStats() {
        let res = [];
        for (let [id, service] of this.registered) {
          res.push({
            id,
            languageIds: documentSelectorToLanguageIds(service.selector),
            state: getStateName(service.state)
          });
        }
        return res;
      }
      createCustomServices() {
        let lspConfig = workspace_default.getConfiguration().get("languageserver", {});
        for (let key of Object.keys(lspConfig)) {
          let config = lspConfig[key];
          this.registLanguageClient(key, config);
        }
      }
      waitClient(id) {
        let service = this.getService(id);
        if (service && service.state == ServiceStat.Running)
          return Promise.resolve();
        if (service)
          return new Promise((resolve3) => {
            service.onServiceReady(() => {
              resolve3();
            });
          });
        return new Promise((resolve3) => {
          let listener = (clientId) => {
            if (clientId == id || clientId == `languageserver.${id}`) {
              this.off("ready", listener);
              resolve3();
            }
          };
          this.on("ready", listener);
        });
      }
      async registNotification(id, method) {
        await this.waitClient(id);
        let service = this.getService(id);
        if (!service.client) {
          window_default.showMessage(`Not a language client: ${id}`, "error");
          return;
        }
        let client = service.client;
        client.onNotification(method, async (result) => {
          await workspace_default.nvim.call("coc#do_notify", [id, method, result]);
        });
      }
      async sendNotification(id, method, params) {
        if (!method)
          throw new Error(`method required for ontification`);
        let service = this.getService(id);
        if (!service || !service.client)
          throw new Error(`Language server ${id} not found`);
        if (service.state == ServiceStat.Starting) {
          await service.client.onReady();
        }
        if (service.state != ServiceStat.Running) {
          throw new Error(`Language server ${id} not running`);
        }
        await Promise.resolve(service.client.sendNotification(method, params));
      }
      async sendRequest(id, method, params, token) {
        if (!method)
          throw new Error(`method required for sendRequest`);
        let service = this.getService(id);
        if (!service)
          await wait(100);
        service = this.getService(id);
        if (!service || !service.client) {
          throw new Error(`Language server ${id} not found`);
        }
        if (service.state == ServiceStat.Starting) {
          await service.client.onReady();
        }
        if (service.state != ServiceStat.Running) {
          throw new Error(`Language server ${id} not running`);
        }
        if (!token) {
          let tokenSource = new import_vscode_languageserver_protocol54.CancellationTokenSource();
          token = tokenSource.token;
        }
        return await Promise.resolve(service.client.sendRequest(method, params, token));
      }
      registLanguageClient(name2, config) {
        let id = typeof name2 === "string" ? `languageserver.${name2}` : name2.id;
        let disposables = [];
        let onDidServiceReady = new import_vscode_languageserver_protocol54.Emitter();
        let client = typeof name2 === "string" ? null : name2;
        if (this.registered.has(id))
          return;
        let created = false;
        let service = {
          id,
          client,
          name: typeof name2 === "string" ? name2 : name2.name,
          selector: typeof name2 === "string" ? getDocumentSelector(config.filetypes, config.additionalSchemes) : name2.clientOptions.documentSelector,
          state: ServiceStat.Initial,
          onServiceReady: onDidServiceReady.event,
          start: () => {
            if (service.state == ServiceStat.Starting || service.state == ServiceStat.Running) {
              return;
            }
            if (client && !client.needsStart()) {
              return;
            }
            if (created && client) {
              client.restart();
              return Promise.resolve();
            }
            if (!created) {
              if (typeof name2 == "string" && !client) {
                let config2 = workspace_default.getConfiguration().get("languageserver", {})[name2];
                if (!config2 || config2.enable === false)
                  return;
                let opts = getLanguageServerOptions(id, name2, config2);
                if (!opts)
                  return;
                client = new LanguageClient(id, name2, opts[1], opts[0]);
                service.selector = opts[0].documentSelector;
                service.client = client;
              }
              client.onDidChangeState((changeEvent) => {
                let { oldState, newState } = changeEvent;
                if (newState == State2.Starting) {
                  service.state = ServiceStat.Starting;
                } else if (newState == State2.Running) {
                  service.state = ServiceStat.Running;
                } else if (newState == State2.Stopped) {
                  service.state = ServiceStat.Stopped;
                }
                let oldStr = stateString(oldState);
                let newStr = stateString(newState);
                logger47.info(`${client.name} state change: ${oldStr} => ${newStr}`);
              }, null, disposables);
              created = true;
            }
            service.state = ServiceStat.Starting;
            logger47.debug(`starting service: ${id}`);
            let disposable = client.start();
            disposables.push(disposable);
            return new Promise((resolve3) => {
              client.onReady().then(() => {
                onDidServiceReady.fire(void 0);
                resolve3();
              }, (e) => {
                window_default.showMessage(`Server ${id} failed to start: ${e}`, "error");
                logger47.error(`Server ${id} failed to start:`, e);
                service.state = ServiceStat.StartFailed;
                resolve3();
              });
            });
          },
          dispose: async () => {
            onDidServiceReady.dispose();
            disposeAll(disposables);
          },
          stop: async () => {
            if (!client || !client.needsStop())
              return;
            await Promise.resolve(client.stop());
          },
          restart: async () => {
            if (client) {
              service.state = ServiceStat.Starting;
              client.restart();
            } else {
              await service.start();
            }
          }
        };
        return this.regist(service);
      }
    };
    services_default = new ServiceManager();
  }
});

// src/list/configuration.ts
var import_events15, validKeys, ListConfiguration;
var init_configuration4 = __esm({
  "src/list/configuration.ts"() {
    init_workspace();
    init_window();
    import_events15 = __toModule(require("events"));
    validKeys = [
      "<esc>",
      "<space>",
      "<tab>",
      "<s-tab>",
      "<bs>",
      "<right>",
      "<left>",
      "<up>",
      "<down>",
      "<home>",
      "<end>",
      "<cr>",
      "<FocusGained>",
      "<FocusLost>",
      "<ScrollWheelUp>",
      "<ScrollWheelDown>",
      "<LeftMouse>",
      "<LeftDrag>",
      "<LeftRelease>",
      "<2-LeftMouse>",
      "<C-a>",
      "<C-b>",
      "<C-c>",
      "<C-d>",
      "<C-e>",
      "<C-f>",
      "<C-g>",
      "<C-h>",
      "<C-i>",
      "<C-j>",
      "<C-k>",
      "<C-l>",
      "<C-m>",
      "<C-n>",
      "<C-o>",
      "<C-p>",
      "<C-q>",
      "<C-r>",
      "<C-s>",
      "<C-t>",
      "<C-u>",
      "<C-v>",
      "<C-w>",
      "<C-x>",
      "<C-y>",
      "<C-z>",
      "<A-a>",
      "<A-b>",
      "<A-c>",
      "<A-d>",
      "<A-e>",
      "<A-f>",
      "<A-g>",
      "<A-h>",
      "<A-i>",
      "<A-j>",
      "<A-k>",
      "<A-l>",
      "<A-m>",
      "<A-n>",
      "<A-o>",
      "<A-p>",
      "<A-q>",
      "<A-r>",
      "<A-s>",
      "<A-t>",
      "<A-u>",
      "<A-v>",
      "<A-w>",
      "<A-x>",
      "<A-y>",
      "<A-z>"
    ];
    ListConfiguration = class extends import_events15.EventEmitter {
      constructor() {
        super();
        this.configuration = workspace_default.getConfiguration("list");
        this.disposable = workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("list")) {
            this.configuration = workspace_default.getConfiguration("list");
            this.emit("change");
          }
        });
      }
      get(key, defaultValue) {
        return this.configuration.get(key, defaultValue);
      }
      get previousKey() {
        return this.fixKey(this.configuration.get("previousKeymap", "<C-j>"));
      }
      get nextKey() {
        return this.fixKey(this.configuration.get("nextKeymap", "<C-k>"));
      }
      dispose() {
        this.disposable.dispose();
        this.removeAllListeners();
      }
      fixKey(key) {
        if (validKeys.includes(key))
          return key;
        let find = validKeys.find((s) => s.toLowerCase() == key.toLowerCase());
        if (find)
          return find;
        window_default.showMessage(`Configured key "${key}" not supported.`, "error");
        return null;
      }
    };
  }
});

// src/list/mappings.ts
var import_extensions, logger48, Mappings;
var init_mappings = __esm({
  "src/list/mappings.ts"() {
    import_extensions = __toModule(require_extensions());
    init_window();
    init_configuration4();
    logger48 = require_logger2()("list-mappings");
    Mappings = class {
      constructor(manager, nvim, config) {
        this.manager = manager;
        this.nvim = nvim;
        this.config = config;
        this.insertMappings = new Map();
        this.normalMappings = new Map();
        this.userInsertMappings = new Map();
        this.userNormalMappings = new Map();
        let { prompt } = manager;
        this.add("insert", "<C-k>", () => {
          prompt.removeTail();
        });
        this.add("insert", "<C-n>", () => {
          var _a2;
          (_a2 = manager.session) == null ? void 0 : _a2.history.next();
        });
        this.add("insert", "<C-p>", () => {
          var _a2;
          (_a2 = manager.session) == null ? void 0 : _a2.history.previous();
        });
        this.add("insert", "<C-v>", async () => {
          await prompt.paste();
        });
        this.add("insert", "<C-s>", () => manager.switchMatcher());
        this.add("insert", ["<C-m>", "<cr>"], async () => {
          await manager.doAction();
        });
        this.add("insert", ["<tab>", "<C-i>", "	"], () => manager.chooseAction());
        this.add("insert", "<C-o>", () => {
          manager.toggleMode();
        });
        this.add("insert", "<C-c>", () => {
          manager.stop();
          return;
        });
        this.add("insert", "<esc>", () => manager.cancel());
        this.add("insert", "<C-l>", async () => {
          var _a2;
          await ((_a2 = manager.session) == null ? void 0 : _a2.reloadItems());
        });
        this.add("insert", "<left>", () => {
          prompt.moveLeft();
        });
        this.add("insert", "<right>", () => {
          prompt.moveRight();
        });
        this.add("insert", ["<end>", "<C-e>"], () => {
          prompt.moveToEnd();
        });
        this.add("insert", ["<home>", "<C-a>"], () => {
          prompt.moveToStart();
        });
        this.add("insert", ["<C-h>", "<bs>", "<backspace>"], () => {
          prompt.onBackspace();
        });
        this.add("insert", "<C-w>", () => {
          prompt.removeWord();
        });
        this.add("insert", "<C-u>", () => {
          prompt.removeAhead();
        });
        this.add("insert", "<C-r>", () => prompt.insertRegister());
        this.add("insert", "<C-d>", () => manager.feedkeys("<C-d>", false));
        this.add("insert", "<PageUp>", () => manager.feedkeys("<PageUp>", false));
        this.add("insert", "<PageDown>", () => manager.feedkeys("<PageDown>", false));
        this.add("insert", "<down>", () => manager.normal("j"));
        this.add("insert", "<up>", () => manager.normal("k"));
        this.add("insert", ["<ScrollWheelUp>"], this.doScroll.bind(this, "<ScrollWheelUp>"));
        this.add("insert", ["<ScrollWheelDown>"], this.doScroll.bind(this, "<ScrollWheelDown>"));
        this.add("insert", ["<C-f>"], this.doScroll.bind(this, "<C-f>"));
        this.add("insert", ["<C-b>"], this.doScroll.bind(this, "<C-b>"));
        this.add("normal", "<C-o>", () => {
        });
        this.add("normal", "t", () => manager.doAction("tabe"));
        this.add("normal", "s", () => manager.doAction("split"));
        this.add("normal", "d", () => manager.doAction("drop"));
        this.add("normal", ["<cr>", "<C-m>", "\r"], () => manager.doAction());
        this.add("normal", "<C-a>", () => {
          var _a2;
          return (_a2 = manager.session) == null ? void 0 : _a2.ui.selectAll();
        });
        this.add("normal", " ", () => {
          var _a2;
          return (_a2 = manager.session) == null ? void 0 : _a2.ui.toggleSelection();
        });
        this.add("normal", "p", () => manager.togglePreview());
        this.add("normal", ["<tab>", "	", "<C-i>"], () => manager.chooseAction());
        this.add("normal", "<C-c>", () => {
          manager.stop();
        });
        this.add("normal", "<esc>", () => manager.cancel());
        this.add("normal", "<C-l>", () => {
          var _a2;
          return (_a2 = manager.session) == null ? void 0 : _a2.reloadItems();
        });
        this.add("normal", "<C-o>", () => {
          var _a2;
          return (_a2 = manager.session) == null ? void 0 : _a2.jumpBack();
        });
        this.add("normal", "<C-e>", () => this.scrollPreview("down"));
        this.add("normal", "<C-y>", () => this.scrollPreview("up"));
        this.add("normal", ["i", "I", "o", "O", "a", "A"], () => manager.toggleMode());
        this.add("normal", "?", () => {
          var _a2;
          return (_a2 = manager.session) == null ? void 0 : _a2.showHelp();
        });
        this.add("normal", ":", async () => {
          await manager.cancel(false);
          await nvim.eval('feedkeys(":")');
        });
        this.add("normal", ["<ScrollWheelUp>"], this.doScroll.bind(this, "<ScrollWheelUp>"));
        this.add("normal", ["<ScrollWheelDown>"], this.doScroll.bind(this, "<ScrollWheelDown>"));
        this.createMappings();
        config.on("change", () => {
          this.createMappings();
        });
      }
      createMappings() {
        let insertMappings = this.config.get("insertMappings", {});
        this.userInsertMappings = this.fixUserMappings(insertMappings);
        let normalMappings = this.config.get("normalMappings", {});
        this.userNormalMappings = this.fixUserMappings(normalMappings);
      }
      fixUserMappings(mappings) {
        let res = new Map();
        for (let [key, value] of Object.entries(mappings)) {
          if (key.length == 1) {
            res.set(key, value);
          } else if (key.startsWith("<") && key.endsWith(">")) {
            if (key.toLowerCase() == "<space>") {
              res.set(" ", value);
            } else if (key.toLowerCase() == "<backspace>") {
              res.set("<bs>", value);
            } else if (validKeys.includes(key)) {
              res.set(key, value);
            } else {
              let find = false;
              for (let i = 0; i < validKeys.length; i++) {
                if (validKeys[i].toLowerCase() == key.toLowerCase()) {
                  find = true;
                  res.set(validKeys[i], value);
                  break;
                }
              }
              if (!find)
                window_default.showMessage(`Invalid list mappings key configuration: "${key}"`, "warning");
            }
          } else {
            window_default.showMessage(`Invalid list mappings key configuration: "${key}"`, "warning");
          }
        }
        return res;
      }
      async doInsertKeymap(key) {
        let nextKey = this.config.nextKey;
        let previousKey = this.config.previousKey;
        let { session } = this.manager;
        if (!session)
          return;
        if (key == nextKey) {
          session.ui.index = session.ui.index + 1;
          return true;
        }
        if (key == previousKey) {
          session.ui.index = session.ui.index - 1;
          return true;
        }
        let expr = this.userInsertMappings.get(key);
        if (expr) {
          await this.evalExpression(expr, "insert");
          return true;
        }
        if (this.insertMappings.has(key)) {
          let fn = this.insertMappings.get(key);
          await Promise.resolve(fn());
          return true;
        }
        return false;
      }
      async doNormalKeymap(key) {
        let expr = this.userNormalMappings.get(key);
        if (expr) {
          await this.evalExpression(expr, "normal");
          return true;
        }
        if (this.normalMappings.has(key)) {
          let fn = this.normalMappings.get(key);
          await Promise.resolve(fn());
          return true;
        }
        return false;
      }
      add(mode, key, fn) {
        let mappings = mode == "insert" ? this.insertMappings : this.normalMappings;
        if (Array.isArray(key)) {
          for (let k of key) {
            mappings.set(k, fn);
          }
        } else {
          mappings.set(key, fn);
        }
      }
      async onError(msg) {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        window_default.showMessage(msg, "error");
        this.manager.prompt.start();
      }
      async evalExpression(expr, _mode) {
        var _a2, _b, _c, _d, _e, _f, _g;
        if (typeof expr != "string" || !expr.includes(":")) {
          await this.onError(`Invalid list mapping expression: ${expr}`);
          return;
        }
        let { manager } = this;
        let { prompt } = manager;
        let [key, action] = expr.split(":", 2);
        if (key == "do") {
          switch (action.toLowerCase()) {
            case "switch":
              manager.switchMatcher();
              return;
            case "selectall":
              await ((_a2 = manager.session) == null ? void 0 : _a2.ui.selectAll());
              return;
            case "help":
              await ((_b = manager.session) == null ? void 0 : _b.showHelp());
              return;
            case "refresh":
              await ((_c = manager.session) == null ? void 0 : _c.reloadItems());
              return;
            case "exit":
              await manager.cancel();
              return;
            case "stop":
              manager.stop();
              return;
            case "cancel":
              await manager.cancel(false);
              return;
            case "toggle":
              await ((_d = manager.session) == null ? void 0 : _d.ui.toggleSelection());
              return;
            case "jumpback":
              (_e = manager.session) == null ? void 0 : _e.jumpBack();
              return;
            case "previous":
              await manager.normal("k");
              return;
            case "next":
              await manager.normal("j");
              return;
            case "defaultaction":
              await manager.doAction();
              return;
            case "togglemode":
              return manager.toggleMode();
            case "previewtoggle":
              return manager.togglePreview();
            case "previewup":
              return this.scrollPreview("up");
            case "previewdown":
              return this.scrollPreview("down");
            default:
              await this.onError(`'${action}' not supported`);
          }
        } else if (key == "prompt") {
          switch (action) {
            case "previous":
              (_f = manager.session) == null ? void 0 : _f.history.previous();
              return;
            case "next":
              (_g = manager.session) == null ? void 0 : _g.history.next();
              return;
            case "start":
              return prompt.moveToStart();
            case "end":
              return prompt.moveToEnd();
            case "left":
              return prompt.moveLeft();
            case "right":
              return prompt.moveRight();
            case "deleteforward":
              return prompt.onBackspace();
            case "deletebackward":
              return prompt.removeNext();
            case "removetail":
              return prompt.removeTail();
            case "removeahead":
              return prompt.removeAhead();
            case "insertregister":
              prompt.insertRegister();
              return;
            case "paste":
              await prompt.paste();
              return;
            default:
              await this.onError(`prompt '${action}' not supported`);
          }
        } else if (key == "eval") {
          await prompt.eval(action);
        } else if (key == "command") {
          await manager.command(action);
        } else if (key == "action") {
          await manager.doAction(action);
        } else if (key == "feedkeys") {
          await manager.feedkeys(action);
        } else if (key == "normal") {
          await manager.normal(action, false);
        } else if (key == "normal!") {
          await manager.normal(action, true);
        } else if (key == "call") {
          await manager.call(action);
        } else if (key == "expr") {
          let name2 = await manager.call(action);
          if (name2)
            await manager.doAction(name2);
        } else {
          await this.onError(`Invalid expression ${expr}`);
        }
      }
      async doScroll(key) {
        await this.manager.feedkeys(key);
      }
      scrollPreview(dir) {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.call("coc#list#scroll_preview", [dir], true);
        nvim.command("redraw", true);
        void nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/prompt.ts
var import_vscode_languageserver_protocol55, logger49, Prompt;
var init_prompt = __esm({
  "src/list/prompt.ts"() {
    import_vscode_languageserver_protocol55 = __toModule(require_main2());
    logger49 = require_logger2()("list-prompt");
    Prompt = class {
      constructor(nvim, config) {
        this.nvim = nvim;
        this.config = config;
        this.cusorIndex = 0;
        this._input = "";
        this._mode = "insert";
        this.interactive = false;
        this.requestInput = false;
        this._onDidChangeInput = new import_vscode_languageserver_protocol55.Emitter();
        this.onDidChangeInput = this._onDidChangeInput.event;
      }
      get input() {
        return this._input;
      }
      set input(str) {
        if (this._input == str)
          return;
        this.cusorIndex = str.length;
        this._input = str;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      get mode() {
        return this._mode;
      }
      set mode(val) {
        if (val == this._mode)
          return;
        this._mode = val;
        this.drawPrompt();
      }
      set matcher(val) {
        this._matcher = val;
        this.drawPrompt();
      }
      start(opts) {
        if (opts) {
          this.interactive = opts.interactive;
          this.cusorIndex = opts.input.length;
          this._input = opts.input;
          this._mode = opts.mode;
          this._matcher = opts.interactive ? "" : opts.matcher;
        }
        this.nvim.call("coc#prompt#start_prompt", ["list"], true);
        this.drawPrompt();
      }
      cancel() {
        let { nvim } = this;
        nvim.call("coc#prompt#stop_prompt", ["list"], true);
      }
      reset() {
        this._input = "";
        this.cusorIndex = 0;
      }
      drawPrompt() {
        let indicator = this.config.get("indicator", ">");
        let { cusorIndex, interactive, input, _matcher } = this;
        let cmds = ['echo ""'];
        if (this.mode == "insert") {
          if (interactive) {
            cmds.push(`echohl MoreMsg | echon 'INTERACTIVE ' | echohl None`);
          } else if (_matcher) {
            cmds.push(`echohl MoreMsg | echon '${_matcher.toUpperCase()} ' | echohl None`);
          }
          cmds.push(`echohl Special | echon '${indicator} ' | echohl None`);
          if (cusorIndex == input.length) {
            cmds.push(`echon '${input.replace(/'/g, "''")}'`);
            cmds.push(`echohl Cursor | echon ' ' | echohl None`);
          } else {
            let pre = input.slice(0, cusorIndex);
            if (pre)
              cmds.push(`echon '${pre.replace(/'/g, "''")}'`);
            cmds.push(`echohl Cursor | echon '${input[cusorIndex].replace(/'/, "''")}' | echohl None`);
            let post = input.slice(cusorIndex + 1);
            cmds.push(`echon '${post.replace(/'/g, "''")}'`);
          }
        } else {
          cmds.push(`echohl MoreMsg | echo "" | echohl None`);
        }
        cmds.push("redraw");
        let cmd = cmds.join("|");
        this.nvim.command(cmd, true);
      }
      moveLeft() {
        if (this.cusorIndex == 0)
          return;
        this.cusorIndex = this.cusorIndex - 1;
        this.drawPrompt();
      }
      moveRight() {
        if (this.cusorIndex == this._input.length)
          return;
        this.cusorIndex = this.cusorIndex + 1;
        this.drawPrompt();
      }
      moveToEnd() {
        if (this.cusorIndex == this._input.length)
          return;
        this.cusorIndex = this._input.length;
        this.drawPrompt();
      }
      moveToStart() {
        if (this.cusorIndex == 0)
          return;
        this.cusorIndex = 0;
        this.drawPrompt();
      }
      onBackspace() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
          return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        this.cusorIndex = cusorIndex - 1;
        this._input = `${pre.slice(0, pre.length - 1)}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeNext() {
        let { cusorIndex, input } = this;
        if (cusorIndex == input.length - 1)
          return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex + 1);
        this._input = `${pre}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeWord() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
          return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        let remain = pre.replace(/[\w$]+([^\w$]+)?$/, "");
        this.cusorIndex = cusorIndex - (pre.length - remain.length);
        this._input = `${remain}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeTail() {
        let { cusorIndex, input } = this;
        if (cusorIndex == input.length)
          return;
        let pre = input.slice(0, cusorIndex);
        this._input = pre;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeAhead() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
          return;
        let post = input.slice(cusorIndex);
        this.cusorIndex = 0;
        this._input = post;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      async acceptCharacter(ch) {
        if (this.requestInput) {
          this.requestInput = false;
          if (/^[0-9a-z"%#*+/:\-.]$/.test(ch)) {
            let text = await this.nvim.call("getreg", ch);
            text = text.replace(/\n/g, " ");
            this.addText(text);
          }
        } else {
          this.addText(ch);
        }
      }
      insertRegister() {
        this.requestInput = true;
      }
      async paste() {
        let text = await this.nvim.eval("@*");
        text = text.replace(/\n/g, "");
        if (!text)
          return;
        this.addText(text);
      }
      async eval(expression) {
        let text = await this.nvim.call("eval", [expression]);
        text = text.replace(/\n/g, "");
        this.addText(text);
      }
      addText(text) {
        let { cusorIndex, input } = this;
        this.cusorIndex = cusorIndex + text.length;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        this._input = `${pre}${text}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
    };
  }
});

// src/util/fuzzy.ts
function getCharCodes(str) {
  let res = [];
  for (let i = 0, l = str.length; i < l; i++) {
    res.push(str.charCodeAt(i));
  }
  return res;
}
function wordChar(ch) {
  return ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90;
}
function caseMatch(input, code) {
  if (input == code)
    return true;
  if (input >= 97 && input <= 122 && code + 32 === input)
    return true;
  return false;
}
function fuzzyChar(a, b) {
  let ca = a.charCodeAt(0);
  let cb = b.charCodeAt(0);
  if (ca === cb)
    return true;
  if (ca >= 97 && ca <= 122 && cb + 32 === ca)
    return true;
  return false;
}
function fuzzyMatch(needle, text) {
  let totalCount = needle.length;
  if (needle.length > text.length)
    return false;
  let i = 0;
  for (let j = 0; j < text.length; j++) {
    if (i === totalCount)
      break;
    let code = text.charCodeAt(j);
    let m = needle[i];
    if (code === m) {
      i = i + 1;
      continue;
    }
    if (m >= 97 && m <= 122 && code + 32 === m) {
      i = i + 1;
      continue;
    }
  }
  return i === totalCount;
}
var init_fuzzy = __esm({
  "src/util/fuzzy.ts"() {
  }
});

// src/list/history.ts
var logger50, InputHistory;
var init_history = __esm({
  "src/list/history.ts"() {
    init_fuzzy();
    init_workspace();
    logger50 = require_logger2()("list-history");
    InputHistory = class {
      constructor(prompt, name2) {
        this.prompt = prompt;
        this.name = name2;
        this.index = -1;
        this.loaded = [];
        this.current = [];
        this.db = workspace_default.createDatabase(`list-${name2}-history`);
        this.key = Buffer.from(workspace_default.cwd).toString("base64");
      }
      filter() {
        let { input } = this.prompt;
        if (input == this.curr)
          return;
        this.historyInput = "";
        let codes = getCharCodes(input);
        this.current = this.loaded.filter((s) => fuzzyMatch(codes, s));
        this.index = -1;
      }
      get curr() {
        return this.index == -1 ? null : this.current[this.index];
      }
      load(input) {
        let { db } = this;
        input = input || "";
        let arr = db.fetch(this.key);
        if (!arr || !Array.isArray(arr)) {
          this.loaded = [];
        } else {
          this.loaded = arr;
        }
        this.index = -1;
        this.current = this.loaded.filter((s) => s.startsWith(input));
      }
      add() {
        let { loaded, db, prompt } = this;
        let { input } = prompt;
        if (!input || input.length < 2 || input == this.historyInput)
          return;
        let idx = loaded.indexOf(input);
        if (idx != -1)
          loaded.splice(idx, 1);
        loaded.push(input);
        if (loaded.length > 200) {
          loaded = loaded.slice(-200);
        }
        db.push(this.key, loaded);
      }
      previous() {
        let { current, index } = this;
        if (!current || !current.length)
          return;
        if (index <= 0) {
          this.index = current.length - 1;
        } else {
          this.index = index - 1;
        }
        this.historyInput = this.prompt.input = current[this.index] || "";
      }
      next() {
        let { current, index } = this;
        if (!current || !current.length)
          return;
        if (index == current.length - 1) {
          this.index = 0;
        } else {
          this.index = index + 1;
        }
        this.historyInput = this.prompt.input = current[this.index] || "";
      }
    };
  }
});

// src/list/ui.ts
var import_debounce6, import_vscode_languageserver_protocol56, logger51, ListUI;
var init_ui = __esm({
  "src/list/ui.ts"() {
    import_debounce6 = __toModule(require_debounce());
    import_vscode_languageserver_protocol56 = __toModule(require_main2());
    init_events();
    init_util();
    init_mutex();
    init_window();
    init_workspace();
    logger51 = require_logger2()("list-ui");
    ListUI = class {
      constructor(nvim, name2, listOptions, config) {
        this.nvim = nvim;
        this.name = name2;
        this.listOptions = listOptions;
        this.config = config;
        this.newTab = false;
        this.currIndex = 0;
        this.drawCount = 0;
        this.items = [];
        this.disposables = [];
        this.selected = new Set();
        this.mutex = new Mutex();
        this._onDidChangeLine = new import_vscode_languageserver_protocol56.Emitter();
        this._onDidOpen = new import_vscode_languageserver_protocol56.Emitter();
        this._onDidClose = new import_vscode_languageserver_protocol56.Emitter();
        this._onDidLineChange = new import_vscode_languageserver_protocol56.Emitter();
        this._onDoubleClick = new import_vscode_languageserver_protocol56.Emitter();
        this.onDidChangeLine = this._onDidChangeLine.event;
        this.onDidLineChange = this._onDidLineChange.event;
        this.onDidOpen = this._onDidOpen.event;
        this.onDidClose = this._onDidClose.event;
        this.onDidDoubleClick = this._onDoubleClick.event;
        this.signOffset = config.get("signOffset");
        this.matchHighlightGroup = config.get("matchHighlightGroup", "Search");
        this.newTab = listOptions.position == "tab";
        events_default.on("BufWinLeave", async (bufnr) => {
          if (bufnr != this.bufnr || this.window == null)
            return;
          this.window = null;
          this._onDidClose.fire(bufnr);
        }, null, this.disposables);
        events_default.on("CursorMoved", async (bufnr, cursor) => {
          if (bufnr != this.bufnr)
            return;
          this.onLineChange(cursor[0] - 1);
        }, null, this.disposables);
        let debounced = (0, import_debounce6.default)(async (bufnr) => {
          if (bufnr != this.bufnr)
            return;
          let [winid, start, end] = await nvim.eval('[win_getid(),line("w0"),line("w$")]');
          if (end < 300)
            return;
          if (!this.window || winid != this.window.id)
            return;
          nvim.pauseNotification();
          this.doHighlight(start - 1, end);
          nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        }, 100);
        this.disposables.push({
          dispose: () => {
            debounced.clear();
          }
        });
        events_default.on("CursorMoved", debounced, null, this.disposables);
      }
      get limitLines() {
        return this.config.get("limitLines", 3e4);
      }
      onLineChange(index) {
        if (this.currIndex == index)
          return;
        this.currIndex = index;
        this._onDidChangeLine.fire(index);
      }
      set index(n) {
        if (n < 0 || n >= this.items.length)
          return;
        let { nvim } = this;
        nvim.pauseNotification();
        this.setCursor(n + 1, 0);
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true).logError();
      }
      get index() {
        return this.currIndex;
      }
      get firstItem() {
        return this.items[0];
      }
      get lastItem() {
        return this.items[this.items.length - 1];
      }
      getItem(index) {
        return this.items[index];
      }
      get item() {
        let { window: window2 } = this;
        if (!window2)
          return Promise.resolve(null);
        return window2.cursor.then((cursor) => {
          this.currIndex = cursor[0] - 1;
          return this.items[this.currIndex];
        }, (_e) => null);
      }
      async echoMessage(item) {
        if (this.bufnr)
          return;
        let { items } = this;
        let idx = items.indexOf(item);
        let msg = `[${idx + 1}/${items.length}] ${item.label || ""}`;
        this.nvim.callTimer("coc#util#echo_lines", [[msg]], true);
      }
      async updateItem(item, index) {
        if (!this.bufnr || workspace_default.bufnr != this.bufnr)
          return;
        let obj = Object.assign({ resolved: true }, item);
        if (index < this.length) {
          this.items[index] = obj;
          let { nvim } = this;
          nvim.pauseNotification();
          nvim.command("setl modifiable", true);
          nvim.call("setline", [index + 1, obj.label], true);
          nvim.command("setl nomodifiable", true);
          await nvim.resumeNotification();
        }
      }
      async getItems() {
        if (this.length == 0 || !this.window)
          return [];
        let mode = await this.nvim.call("mode");
        if (mode == "v" || mode == "V") {
          let [start, end] = await this.getSelectedRange();
          let res = [];
          for (let i = start; i <= end; i++) {
            let item2 = this.items[i - 1];
            if (item2)
              res.push(item2);
          }
          return res;
        }
        let { selectedItems } = this;
        if (selectedItems.length)
          return selectedItems;
        let item = await this.item;
        return item == null ? [] : [item];
      }
      async onMouse(event) {
        let { nvim, window: window2 } = this;
        if (!window2)
          return;
        let winid = await nvim.getVvar("mouse_winid");
        let lnum = await nvim.getVvar("mouse_lnum");
        let col = await nvim.getVvar("mouse_col");
        if (event == "mouseDown") {
          this.mouseDown = { winid, lnum, col, current: winid == window2.id };
          return;
        }
        let current = winid == window2.id;
        if (current && event == "doubleClick") {
          this.setCursor(lnum, 0);
          this._onDoubleClick.fire();
        }
        if (!this.mouseDown || this.mouseDown.winid != this.mouseDown.winid)
          return;
        if (current && event == "mouseDrag") {
          await this.selectLines(this.mouseDown.lnum, lnum);
        } else if (current && event == "mouseUp") {
          if (this.mouseDown.lnum == lnum) {
            nvim.pauseNotification();
            this.clearSelection();
            this.setCursor(lnum, 0);
            nvim.command("redraw", true);
            await nvim.resumeNotification();
          } else {
            await this.selectLines(this.mouseDown.lnum, lnum);
          }
        } else if (!current && event == "mouseUp") {
          nvim.pauseNotification();
          nvim.call("win_gotoid", winid, true);
          nvim.call("cursor", [lnum, col], true);
          await nvim.resumeNotification();
        }
      }
      async resume() {
        let { items, selected, nvim, signOffset } = this;
        await this.drawItems(items, this.height, true);
        if (selected.size > 0 && this.bufnr) {
          nvim.pauseNotification();
          for (let lnum of selected) {
            nvim.command(`sign place ${signOffset + lnum} line=${lnum} name=CocSelected buffer=${this.bufnr}`, true);
          }
          await nvim.resumeNotification();
        }
      }
      async toggleSelection() {
        let { nvim, selected, signOffset, bufnr } = this;
        if (workspace_default.bufnr != bufnr)
          return;
        let lnum = await nvim.call("line", ".");
        let mode = await nvim.call("mode");
        if (mode == "v" || mode == "V") {
          let [start, end] = await this.getSelectedRange();
          let exists2 = selected.has(start);
          let reverse = start > end;
          if (reverse)
            [start, end] = [end, start];
          for (let i = start; i <= end; i++) {
            if (!exists2) {
              selected.add(i);
              nvim.command(`sign place ${signOffset + i} line=${i} name=CocSelected buffer=${bufnr}`, true);
            } else {
              selected.delete(i);
              nvim.command(`sign unplace ${signOffset + i} buffer=${bufnr}`, true);
            }
          }
          this.setCursor(end, 0);
          nvim.command("redraw", true);
          await nvim.resumeNotification();
          return;
        }
        let exists = selected.has(lnum);
        nvim.pauseNotification();
        if (exists) {
          selected.delete(lnum);
          nvim.command(`sign unplace ${signOffset + lnum} buffer=${bufnr}`, true);
        } else {
          selected.add(lnum);
          nvim.command(`sign place ${signOffset + lnum} line=${lnum} name=CocSelected buffer=${bufnr}`, true);
        }
        this.setCursor(lnum + 1, 0);
        nvim.command("redraw", true);
        await nvim.resumeNotification();
      }
      async selectLines(start, end) {
        let { nvim, signOffset, bufnr, length } = this;
        this.clearSelection();
        let { selected } = this;
        nvim.pauseNotification();
        let reverse = start > end;
        if (reverse)
          [start, end] = [end, start];
        for (let i = start; i <= end; i++) {
          if (i > length)
            break;
          selected.add(i);
          nvim.command(`sign place ${signOffset + i} line=${i} name=CocSelected buffer=${bufnr}`, true);
        }
        this.setCursor(end, 0);
        nvim.command("redraw", true);
        await nvim.resumeNotification();
      }
      async selectAll() {
        let { length } = this;
        if (length == 0)
          return;
        await this.selectLines(1, length);
      }
      clearSelection() {
        let { selected, nvim, signOffset, bufnr } = this;
        if (!bufnr)
          return;
        if (selected.size > 0) {
          let signIds = [];
          for (let lnum of selected) {
            signIds.push(signOffset + lnum);
          }
          nvim.call("coc#util#unplace_signs", [bufnr, signIds], true);
          this.selected = new Set();
        }
      }
      get shown() {
        return this.window != null;
      }
      get bufnr() {
        var _a2;
        return (_a2 = this.buffer) == null ? void 0 : _a2.id;
      }
      get winid() {
        var _a2;
        return (_a2 = this.window) == null ? void 0 : _a2.id;
      }
      get ready() {
        if (this.window)
          return Promise.resolve();
        return new Promise((resolve3, reject) => {
          let timeout = setTimeout(() => {
            reject(new Error("window create timeout"));
          }, 3e3);
          let disposable = this.onDidLineChange(() => {
            disposable.dispose();
            clearTimeout(timeout);
            resolve3();
          });
        });
      }
      async drawItems(items, height, reload = false, token) {
        let count = this.drawCount = this.drawCount + 1;
        const { nvim, name: name2, listOptions } = this;
        const release = await this.mutex.acquire();
        this.items = items.length > this.limitLines ? items.slice(0, this.limitLines) : items;
        const create = this.window == null;
        if (create && !(token && token.isCancellationRequested)) {
          try {
            let { position, numberSelect } = listOptions;
            let [bufnr, winid] = await nvim.call("coc#list#create", [position, height, name2, numberSelect]);
            if (token && token.isCancellationRequested) {
              nvim.call("coc#list#clean_up", [], true);
            } else {
              this.height = height;
              this.buffer = nvim.createBuffer(bufnr);
              this.window = nvim.createWindow(winid);
              this._onDidOpen.fire(this.bufnr);
            }
          } catch (e) {
            nvim.call("coc#prompt#stop_prompt", ["list"], true);
            nvim.call("coc#list#clean_up", [], true);
            release();
            window_default.showMessage(`Error on list create: ${e.message}`, "error");
            return;
          }
        }
        release();
        if (token && token.isCancellationRequested)
          return;
        if (count !== this.drawCount)
          return;
        const lines = this.items.map((item) => item.label);
        this.clearSelection();
        let newIndex = reload ? this.currIndex : 0;
        await this.setLines(lines, false, newIndex);
        this._onDidLineChange.fire(this.currIndex + 1);
      }
      async appendItems(items) {
        if (!this.window)
          return;
        let curr = this.items.length;
        if (curr >= this.limitLines)
          return;
        let max = this.limitLines - curr;
        let append = items.slice(0, max);
        this.items = this.items.concat(append);
        await this.setLines(append.map((item) => item.label), curr > 0, this.currIndex);
      }
      async setLines(lines, append = false, index) {
        let { nvim, buffer, window: window2 } = this;
        if (!buffer || !window2)
          return;
        nvim.pauseNotification();
        if (!append) {
          let statusSegments = this.config.get("statusLineSegments");
          if (statusSegments) {
            window2.notify("nvim_win_set_option", ["statusline", statusSegments.join(" ")]);
          }
          nvim.call("coc#compat#clear_matches", [window2.id], true);
          if (!lines.length) {
            lines = ["No results, press ? on normal mode to get help."];
            nvim.call("coc#compat#matchaddpos", ["Comment", [[1]], 99, this.window.id], true);
          }
        }
        buffer.setOption("modifiable", true, true);
        if (workspace_default.isVim) {
          nvim.call("coc#list#setlines", [buffer.id, lines, append], true);
        } else {
          buffer.setLines(lines, { start: append ? -1 : 0, end: -1, strictIndexing: false }, true);
        }
        buffer.setOption("modifiable", false, true);
        if (!append && index == 0) {
          this.doHighlight(0, 300);
        } else {
          let height = this.newTab ? workspace_default.env.lines : this.height;
          this.doHighlight(Math.max(0, index - height), Math.min(index + height + 1, this.length - 1));
        }
        if (!append) {
          this.currIndex = index;
          window2.notify("nvim_win_set_cursor", [[index + 1, 0]]);
        }
        nvim.command("redraws", true);
        let res = await nvim.resumeNotification();
        if (Array.isArray(res[1]) && res[1][0] == 0) {
          this.window = null;
        }
      }
      restoreWindow() {
        if (this.newTab)
          return;
        let { winid, height } = this;
        if (winid && height) {
          this.nvim.call("coc#list#restore", [winid, height], true);
        }
      }
      reset() {
        if (this.window) {
          this.window = null;
          this.buffer = null;
        }
      }
      dispose() {
        disposeAll(this.disposables);
        this.window = null;
        this._onDidChangeLine.dispose();
        this._onDidOpen.dispose();
        this._onDidClose.dispose();
        this._onDidLineChange.dispose();
        this._onDoubleClick.dispose();
      }
      get length() {
        return this.items.length;
      }
      get selectedItems() {
        let { selected, items } = this;
        let res = [];
        for (let i of selected) {
          if (items[i - 1])
            res.push(items[i - 1]);
        }
        return res;
      }
      doHighlight(start, end) {
        let { nvim } = workspace_default;
        let { items } = this;
        let groups = [];
        for (let i = start; i <= Math.min(end, items.length - 1); i++) {
          let { ansiHighlights, highlights } = items[i];
          if (ansiHighlights) {
            for (let hi of ansiHighlights) {
              let { span, hlGroup } = hi;
              groups.push({ hlGroup, priority: 9, pos: [i + 1, span[0] + 1, span[1] - span[0]] });
            }
          }
          if (highlights && Array.isArray(highlights.spans)) {
            let { spans, hlGroup } = highlights;
            for (let span of spans) {
              groups.push({ hlGroup: hlGroup || this.matchHighlightGroup, priority: 11, pos: [i + 1, span[0] + 1, span[1] - span[0]] });
            }
          }
        }
        nvim.call("coc#compat#matchaddgroups", [this.window.id, groups], true);
      }
      setCursor(lnum, col) {
        let { window: window2, items } = this;
        let max = items.length == 0 ? 1 : items.length;
        if (lnum > max)
          return;
        this.onLineChange(lnum - 1);
        if (window2)
          window2.notify("nvim_win_set_cursor", [[lnum, col]]);
      }
      async getSelectedRange() {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.eval('feedkeys("\\<esc>", "in")');
        let [, start] = await nvim.call("getpos", "'<");
        let [, end] = await nvim.call("getpos", "'>");
        if (start > end) {
          [start, end] = [end, start];
        }
        this.nvim.call("coc#prompt#start_prompt", ["list"], true);
        return [start, end];
      }
    };
  }
});

// src/util/fzy.ts
function islower(s) {
  return s.toLowerCase() === s;
}
function isupper(s) {
  return s.toUpperCase() === s;
}
function precompute_bonus(haystack) {
  let m = haystack.length;
  let match_bonus = new Array(m);
  let last_ch = "/";
  for (let i = 0; i < m; i++) {
    let ch = haystack[i];
    if (last_ch === "/") {
      match_bonus[i] = SCORE_MATCH_SLASH;
    } else if (last_ch === "-" || last_ch === "_" || last_ch === " ") {
      match_bonus[i] = SCORE_MATCH_WORD;
    } else if (last_ch === ".") {
      match_bonus[i] = SCORE_MATCH_DOT;
    } else if (islower(last_ch) && isupper(ch)) {
      match_bonus[i] = SCORE_MATCH_CAPITAL;
    } else {
      match_bonus[i] = 0;
    }
    last_ch = ch;
  }
  return match_bonus;
}
function compute(needle, haystack, D, M) {
  let n = needle.length;
  let m = haystack.length;
  let lower_needle = needle.toLowerCase();
  let lower_haystack = haystack.toLowerCase();
  let match_bonus = precompute_bonus(haystack);
  for (let i = 0; i < n; i++) {
    D[i] = new Array(m);
    M[i] = new Array(m);
    let prev_score = SCORE_MIN;
    let gap_score = i === n - 1 ? SCORE_GAP_TRAILING : SCORE_GAP_INNER;
    for (let j = 0; j < m; j++) {
      if (lower_needle[i] === lower_haystack[j]) {
        let score5 = SCORE_MIN;
        if (!i) {
          score5 = j * SCORE_GAP_LEADING + match_bonus[j];
        } else if (j) {
          score5 = Math.max(M[i - 1][j - 1] + match_bonus[j], D[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE);
        }
        D[i][j] = score5;
        M[i][j] = prev_score = Math.max(score5, prev_score + gap_score);
      } else {
        D[i][j] = SCORE_MIN;
        M[i][j] = prev_score = prev_score + gap_score;
      }
    }
  }
}
function score2(needle, haystack) {
  let n = needle.length;
  let m = haystack.length;
  if (!n || !m)
    return SCORE_MIN;
  if (n === m) {
    return SCORE_MAX;
  }
  if (m > 1024) {
    return SCORE_MIN;
  }
  let D = new Array(n);
  let M = new Array(n);
  compute(needle, haystack, D, M);
  return M[n - 1][m - 1];
}
function positions(needle, haystack) {
  let n = needle.length;
  let m = haystack.length;
  let positions2 = new Array(n);
  if (!n || !m)
    return positions2;
  if (n === m) {
    for (let i = 0; i < n; i++)
      positions2[i] = i;
    return positions2;
  }
  if (m > 1024) {
    return positions2;
  }
  let D = new Array(n);
  let M = new Array(n);
  compute(needle, haystack, D, M);
  let match_required = false;
  for (let i = n - 1, j = m - 1; i >= 0; i--) {
    for (; j >= 0; j--) {
      if (D[i][j] !== SCORE_MIN && (match_required || D[i][j] === M[i][j])) {
        match_required = i && j && M[i][j] === D[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE;
        positions2[i] = j--;
        break;
      }
    }
  }
  return positions2;
}
function hasMatch(needle, haystack) {
  needle = needle.toLowerCase();
  haystack = haystack.toLowerCase();
  let l = needle.length;
  for (let i = 0, j = 0; i < l; i += 1) {
    j = haystack.indexOf(needle[i], j) + 1;
    if (j === 0)
      return false;
  }
  return true;
}
var SCORE_MIN, SCORE_MAX, SCORE_GAP_LEADING, SCORE_GAP_TRAILING, SCORE_GAP_INNER, SCORE_MATCH_CONSECUTIVE, SCORE_MATCH_SLASH, SCORE_MATCH_WORD, SCORE_MATCH_CAPITAL, SCORE_MATCH_DOT;
var init_fzy = __esm({
  "src/util/fzy.ts"() {
    SCORE_MIN = -Infinity;
    SCORE_MAX = Infinity;
    SCORE_GAP_LEADING = -5e-3;
    SCORE_GAP_TRAILING = -5e-3;
    SCORE_GAP_INNER = -0.01;
    SCORE_MATCH_CONSECUTIVE = 1;
    SCORE_MATCH_SLASH = 0.9;
    SCORE_MATCH_WORD = 0.8;
    SCORE_MATCH_CAPITAL = 0.7;
    SCORE_MATCH_DOT = 0.6;
  }
});

// src/util/score.ts
function getMatchResult(text, query, filename = "") {
  if (!query)
    return { score: 1 };
  let matches = [];
  let codes = getCharCodes(query);
  let filenameIdx = filename ? text.indexOf(filename) : -1;
  let matchBase = filenameIdx != -1 && fuzzyMatch(codes, filename);
  let score5 = 0;
  let c = query[0];
  let idx = 0;
  if (matchBase) {
    if (filename.startsWith(c)) {
      score5 = score5 + 2;
      idx = filenameIdx + 1;
      matches.push(filenameIdx);
    } else if (filename[0].toLowerCase() == c) {
      score5 = score5 + 1.5;
      idx = filenameIdx + 1;
      matches.push(filenameIdx);
    } else {
      for (let i = 1; i < filename.length; i++) {
        if (fuzzyChar(c, filename[i])) {
          score5 = score5 + 1;
          idx = filenameIdx + i + 1;
          matches.push(filenameIdx + i);
          break;
        }
      }
    }
  } else if (text.startsWith(c)) {
    score5 = score5 + 1;
    matches.push(0);
    idx = 1;
  } else {
    for (let i = 1; i < text.length; i++) {
      let pre = text[i - 1];
      if (pre == import_path18.sep && text[i] == c) {
        score5 = score5 + 1;
        matches.push(i);
        idx = i + 1;
        break;
      }
    }
    if (idx == 0) {
      for (let i = 0; i < text.length; i++) {
        if (fuzzyChar(c, text[i])) {
          score5 = score5 + 0.5;
          matches.push(i);
          idx = i + 1;
          break;
        }
      }
    }
  }
  if (idx == 0)
    return { score: 0 };
  if (codes.length == 1)
    return { score: score5, matches };
  return nextResult(codes.slice(1), text, idx, { score: score5, matches });
}
function nextResult(codes, text, idx, curr) {
  let { score: score5, matches } = curr;
  let results = [];
  let c = codes[0];
  let remain = codes.slice(1);
  let result;
  function getRemianResult(index) {
    if (!result)
      return;
    if (remain.length == 0) {
      results.push(result);
    } else if (result) {
      let res = nextResult(remain, text, index, result);
      if (res)
        results.push(res);
    }
  }
  let followed = idx < text.length ? text[idx].charCodeAt(0) : null;
  if (!followed)
    return null;
  if (followed == c) {
    result = { score: score5 + 1, matches: matches.concat([idx]) };
    getRemianResult(idx + 1);
  } else if (caseMatch(c, followed)) {
    result = { score: score5 + 0.5, matches: matches.concat([idx]) };
    getRemianResult(idx + 1);
  }
  if (idx + 1 < text.length) {
    for (let i = idx + 1; i < text.length; i++) {
      let ch = text[i].charCodeAt(0);
      if (text[i - 1] == import_path18.sep && caseMatch(c, ch)) {
        let add = c == ch ? 1 : 0.5;
        result = { score: score5 + add, matches: matches.concat([i]) };
        getRemianResult(i + 1);
        break;
      }
    }
    for (let i = idx + 1; i < text.length; i++) {
      let ch = text[i].charCodeAt(0);
      if (caseMatch(c, ch)) {
        let add = c == ch ? 0.5 : 0.2;
        result = { score: score5 + add, matches: matches.concat([i]) };
        getRemianResult(i + 1);
        break;
      }
    }
  }
  return results.length ? bestResult(results) : null;
}
function bestResult(results) {
  let res = results[0];
  for (let i = 1; i < results.length; i++) {
    if (results[i].score > res.score) {
      res = results[i];
    }
  }
  return res;
}
var import_path18;
var init_score = __esm({
  "src/util/score.ts"() {
    import_path18 = __toModule(require("path"));
    init_fuzzy();
  }
});

// src/list/worker.ts
function getFilterLabel(item) {
  return item.filterText != null ? patchLine(item.filterText, item.label) : item.label;
}
function parseInput(input) {
  let res = [];
  let startIdx = 0;
  let currIdx = 0;
  let prev = "";
  for (; currIdx < input.length; currIdx++) {
    let ch = input[currIdx];
    if (ch.charCodeAt(0) === 32) {
      if (prev && prev != "\\" && startIdx != currIdx) {
        res.push(input.slice(startIdx, currIdx));
        startIdx = currIdx + 1;
      }
    } else {
    }
    prev = ch;
  }
  if (startIdx != input.length) {
    res.push(input.slice(startIdx, input.length));
  }
  return res.map((s) => s.replace(/\\\s/g, " ").trim()).filter((s) => s.length > 0);
}
var import_vscode_languageserver_protocol57, logger52, controlCode, Worker;
var init_worker = __esm({
  "src/list/worker.ts"() {
    import_vscode_languageserver_protocol57 = __toModule(require_main2());
    init_ansiparse();
    init_diff();
    init_fzy();
    init_score();
    init_string();
    init_window();
    init_workspace();
    logger52 = require_logger2()("list-worker");
    controlCode = "";
    Worker = class {
      constructor(nvim, list2, prompt, listOptions, config) {
        this.nvim = nvim;
        this.list = list2;
        this.prompt = prompt;
        this.listOptions = listOptions;
        this.config = config;
        this._loading = false;
        this.totalItems = [];
        this._onDidChangeItems = new import_vscode_languageserver_protocol57.Emitter();
        this._onDidChangeLoading = new import_vscode_languageserver_protocol57.Emitter();
        this.onDidChangeItems = this._onDidChangeItems.event;
        this.onDidChangeLoading = this._onDidChangeLoading.event;
      }
      set loading(loading) {
        if (this._loading == loading)
          return;
        this._loading = loading;
        this._onDidChangeLoading.fire(loading);
      }
      get isLoading() {
        return this._loading;
      }
      async loadItems(context, reload = false) {
        let { list: list2, listOptions } = this;
        this.loading = true;
        let { interactive } = listOptions;
        this.tokenSource = new import_vscode_languageserver_protocol57.CancellationTokenSource();
        let token = this.tokenSource.token;
        let items = await list2.loadItems(context, token);
        if (token.isCancellationRequested)
          return;
        if (!items || Array.isArray(items)) {
          this.tokenSource = null;
          items = items || [];
          this.totalItems = items.map((item) => {
            item.label = this.fixLabel(item.label);
            this.parseListItemAnsi(item);
            return item;
          });
          this.loading = false;
          let filtered;
          if (!interactive) {
            filtered = this.filterItems(items);
          } else {
            filtered = this.convertToHighlightItems(items);
          }
          this._onDidChangeItems.fire({
            items: filtered,
            reload,
            finished: true
          });
        } else {
          let task = items;
          let totalItems = this.totalItems = [];
          let count = 0;
          let currInput = context.input;
          let timer;
          let lastTs;
          let _onData = (finished) => {
            lastTs = Date.now();
            if (count >= totalItems.length)
              return;
            let inputChanged = this.input != currInput;
            if (interactive && inputChanged)
              return;
            if (count == 0 || inputChanged) {
              currInput = this.input;
              count = totalItems.length;
              let items2;
              if (interactive) {
                items2 = this.convertToHighlightItems(totalItems);
              } else {
                items2 = this.filterItems(totalItems);
              }
              this._onDidChangeItems.fire({ items: items2, reload, append: false, finished });
            } else {
              let remain = totalItems.slice(count);
              count = totalItems.length;
              let items2;
              if (!interactive) {
                items2 = this.filterItems(remain);
              } else {
                items2 = this.convertToHighlightItems(remain);
              }
              this._onDidChangeItems.fire({ items: items2, append: true, finished });
            }
          };
          task.on("data", (item) => {
            if (timer)
              clearTimeout(timer);
            if (token.isCancellationRequested)
              return;
            if (interactive && this.input != currInput)
              return;
            item.label = this.fixLabel(item.label);
            this.parseListItemAnsi(item);
            totalItems.push(item);
            if (!lastTs && totalItems.length == 500 || Date.now() - lastTs > 200) {
              _onData();
            } else {
              timer = setTimeout(() => _onData(), 50);
            }
          });
          let onEnd = () => {
            if (task == null)
              return;
            this.tokenSource = null;
            task = null;
            this.loading = false;
            disposable.dispose();
            if (timer)
              clearTimeout(timer);
            if (totalItems.length == 0) {
              this._onDidChangeItems.fire({ items: [], finished: true });
            } else {
              _onData(true);
            }
          };
          let disposable = token.onCancellationRequested(() => {
            if (task) {
              task.dispose();
              onEnd();
            }
          });
          task.on("error", async (error) => {
            if (task == null)
              return;
            task = null;
            this.tokenSource = null;
            this.loading = false;
            disposable.dispose();
            if (timer)
              clearTimeout(timer);
            this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
            window_default.showMessage(`Task error: ${error.toString()}`, "error");
            logger52.error(error);
          });
          task.on("end", onEnd);
        }
      }
      drawItems() {
        let { totalItems, listOptions } = this;
        let items;
        if (listOptions.interactive) {
          items = this.convertToHighlightItems(totalItems);
        } else {
          items = this.filterItems(totalItems);
        }
        this._onDidChangeItems.fire({ items, finished: true });
      }
      stop() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
        this.loading = false;
      }
      get length() {
        return this.totalItems.length;
      }
      get input() {
        return this.prompt.input;
      }
      convertToHighlightItems(items) {
        let { input } = this;
        if (!input)
          return [];
        return items.map((item) => {
          let filterLabel = getFilterLabel(item);
          if (filterLabel == "")
            return item;
          let res = getMatchResult(filterLabel, input);
          if (!res || !res.score)
            return item;
          let highlights = this.getHighlights(filterLabel, res.matches);
          return Object.assign({}, item, { highlights });
        });
      }
      filterItems(items) {
        let { input } = this;
        let { sort, matcher, ignorecase } = this.listOptions;
        let inputs = this.config.extendedSearchMode ? parseInput(input) : [input];
        if (input.length == 0 || inputs.length == 0)
          return items;
        if (matcher == "strict") {
          let filtered2 = [];
          for (let item of items) {
            let spans = [];
            let filterLabel = getFilterLabel(item);
            let match = true;
            for (let input2 of inputs) {
              let idx2 = ignorecase ? filterLabel.toLowerCase().indexOf(input2.toLowerCase()) : filterLabel.indexOf(input2);
              if (idx2 == -1) {
                match = false;
                break;
              }
              spans.push([byteIndex(filterLabel, idx2), byteIndex(filterLabel, idx2 + byteLength(input2))]);
            }
            if (match) {
              filtered2.push(Object.assign({}, item, {
                highlights: { spans }
              }));
            }
          }
          return filtered2;
        }
        if (matcher == "regex") {
          let filtered2 = [];
          let flags = ignorecase ? "iu" : "u";
          let regexes = inputs.reduce((p, c) => {
            try {
              let regex = new RegExp(c, flags);
              p.push(regex);
            } catch (e) {
            }
            return p;
          }, []);
          for (let item of items) {
            let spans = [];
            let filterLabel = getFilterLabel(item);
            let match = true;
            for (let regex of regexes) {
              let ms = filterLabel.match(regex);
              if (ms == null) {
                match = false;
                break;
              }
              spans.push([byteIndex(filterLabel, ms.index), byteIndex(filterLabel, ms.index + byteLength(ms[0]))]);
            }
            if (match) {
              filtered2.push(Object.assign({}, item, {
                highlights: { spans }
              }));
            }
          }
          return filtered2;
        }
        let filtered = [];
        let idx = 0;
        for (let item of items) {
          let filterText = item.filterText || item.label;
          let matchScore2 = 0;
          let matches = [];
          let filterLabel = getFilterLabel(item);
          let match = true;
          for (let input2 of inputs) {
            if (!hasMatch(input2, filterText)) {
              match = false;
              break;
            }
            matches.push(...positions(input2, filterLabel));
            if (sort)
              matchScore2 += score2(input2, filterText);
          }
          if (!match)
            continue;
          let obj = Object.assign({}, item, {
            sortText: typeof item.sortText === "string" ? item.sortText : String.fromCharCode(idx),
            score: matchScore2,
            highlights: this.getHighlights(filterLabel, matches)
          });
          filtered.push(obj);
          idx = idx + 1;
        }
        if (sort && filtered.length) {
          filtered.sort((a, b) => {
            if (a.score != b.score)
              return b.score - a.score;
            if (a.sortText > b.sortText)
              return 1;
            return -1;
          });
        }
        return filtered;
      }
      getHighlights(text, matches) {
        let spans = [];
        if (matches && matches.length) {
          let start = matches.shift();
          let next = matches.shift();
          let curr = start;
          while (next) {
            if (next == curr + 1) {
              curr = next;
              next = matches.shift();
              continue;
            }
            spans.push([byteIndex(text, start), byteIndex(text, curr) + 1]);
            start = next;
            curr = start;
            next = matches.shift();
          }
          spans.push([byteIndex(text, start), byteIndex(text, curr) + 1]);
        }
        return { spans };
      }
      parseListItemAnsi(item) {
        let { label } = item;
        if (item.ansiHighlights || !label.includes(controlCode))
          return;
        let { line, highlights } = parseAnsiHighlights(label);
        item.label = line;
        item.ansiHighlights = highlights;
      }
      fixLabel(label) {
        let { columns } = workspace_default.env;
        label = label.split("\n").join(" ");
        return label.slice(0, columns * 2);
      }
      dispose() {
        this.stop();
      }
    };
  }
});

// src/list/session.ts
var import_debounce7, import_vscode_languageserver_protocol58, frames2, logger53, ListSession;
var init_session = __esm({
  "src/list/session.ts"() {
    import_debounce7 = __toModule(require_debounce());
    import_vscode_languageserver_protocol58 = __toModule(require_main2());
    init_extensions2();
    init_highligher();
    init_util();
    init_workspace();
    init_window();
    init_history();
    init_ui();
    init_worker();
    frames2 = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
    logger53 = require_logger2()("list-session");
    ListSession = class {
      constructor(nvim, prompt, list2, listOptions, listArgs = [], config) {
        this.nvim = nvim;
        this.prompt = prompt;
        this.list = list2;
        this.listOptions = listOptions;
        this.listArgs = listArgs;
        this.config = config;
        this.loadingFrame = "";
        this.hidden = false;
        this.disposables = [];
        this.args = [];
        this.ui = new ListUI(nvim, list2.name, listOptions, config);
        this.history = new InputHistory(prompt, list2.name);
        this.worker = new Worker(nvim, list2, prompt, listOptions, {
          interactiveDebounceTime: config.get("interactiveDebounceTime", 100),
          extendedSearchMode: config.get("extendedSearchMode", true)
        });
        this.interactiveDebounceTime = config.get("interactiveDebounceTime", 100);
        let debouncedChangeLine = (0, import_debounce7.default)(async () => {
          let [previewing, currwin, lnum] = await nvim.eval('[coc#list#has_preview(),win_getid(),line(".")]');
          if (previewing && currwin == this.winid) {
            await this.doPreview(lnum - 1);
          }
        }, 50);
        this.disposables.push({
          dispose: () => {
            debouncedChangeLine.clear();
          }
        });
        this.ui.onDidChangeLine(debouncedChangeLine, null, this.disposables);
        this.ui.onDidChangeLine(this.resolveItem, this, this.disposables);
        this.ui.onDidLineChange(this.resolveItem, this, this.disposables);
        let debounced = (0, import_debounce7.default)(async () => {
          let { autoPreview } = this.listOptions;
          if (!autoPreview) {
            let [previewing, mode] = await nvim.eval("[coc#list#has_preview(),mode()]");
            if (!previewing || mode != "n")
              return;
          }
          await this.doAction("preview");
        }, 50);
        this.disposables.push({
          dispose: () => {
            debounced.clear();
          }
        });
        this.ui.onDidLineChange(debounced, null, this.disposables);
        this.ui.onDidLineChange(() => {
          this.updateStatus();
        }, null, this.disposables);
        this.ui.onDidOpen(async () => {
          if (typeof this.list.doHighlight == "function") {
            this.list.doHighlight();
          }
          if (this.listOptions.first) {
            await this.doAction();
          }
        }, null, this.disposables);
        this.ui.onDidClose(async () => {
          await this.hide();
        }, null, this.disposables);
        this.ui.onDidDoubleClick(async () => {
          await this.doAction();
        }, null, this.disposables);
        this.worker.onDidChangeItems(async ({ items, reload, append, finished }) => {
          if (this.hidden)
            return;
          if (append) {
            await this.ui.appendItems(items);
          } else {
            let height = this.config.get("height", 10);
            if (finished && !listOptions.interactive && listOptions.input.length == 0) {
              height = Math.min(items.length, height);
            }
            let tokenSource = this.uiTokenSource = new import_vscode_languageserver_protocol58.CancellationTokenSource();
            await this.ui.drawItems(items, Math.max(1, height), reload, tokenSource.token);
          }
        }, null, this.disposables);
        this.worker.onDidChangeLoading((loading) => {
          if (this.hidden)
            return;
          if (loading) {
            this.interval = setInterval(() => {
              let idx = Math.floor(new Date().getMilliseconds() / 100);
              this.loadingFrame = frames2[idx];
              this.updateStatus();
            }, 100);
          } else {
            if (this.interval) {
              this.loadingFrame = "";
              clearInterval(this.interval);
              this.interval = null;
            }
            this.updateStatus();
          }
        }, null, this.disposables);
      }
      async start(args) {
        this.args = args;
        this.cwd = workspace_default.cwd;
        this.hidden = false;
        let { listOptions, listArgs } = this;
        let res = await this.nvim.eval('[win_getid(),bufnr("%"),winheight("%")]');
        this.listArgs = listArgs;
        this.history.load(listOptions.input || "");
        this.window = this.nvim.createWindow(res[0]);
        this.buffer = this.nvim.createBuffer(res[1]);
        this.savedHeight = res[2];
        await this.worker.loadItems(this.context);
      }
      async reloadItems() {
        if (!this.window)
          return;
        let bufnr = await this.nvim.call("winbufnr", [this.window.id]);
        if (bufnr == -1)
          return;
        this.buffer = this.nvim.createBuffer(bufnr);
        await this.worker.loadItems(this.context, true);
      }
      async call(fname) {
        var _a2, _b;
        await this.nvim.call("coc#prompt#stop_prompt", ["list"]);
        let targets = await this.ui.getItems();
        let context = {
          name: this.name,
          args: this.listArgs,
          input: this.prompt.input,
          winid: (_a2 = this.window) == null ? void 0 : _a2.id,
          bufnr: (_b = this.buffer) == null ? void 0 : _b.id,
          targets
        };
        let res = await this.nvim.call(fname, [context]);
        this.prompt.start();
        return res;
      }
      async chooseAction() {
        let { nvim } = this;
        let { actions, defaultAction } = this.list;
        let names = actions.map((o) => o.name);
        let idx = names.indexOf(defaultAction);
        if (idx != -1) {
          names.splice(idx, 1);
          names.unshift(defaultAction);
        }
        let shortcuts = new Set();
        let choices = [];
        let invalids = [];
        for (let name2 of names) {
          let i = 0;
          for (let ch of name2) {
            if (!shortcuts.has(ch)) {
              shortcuts.add(ch);
              choices.push(`${name2.slice(0, i)}&${name2.slice(i)}`);
              break;
            }
            i++;
          }
          if (i == name2.length) {
            invalids.push(name2);
          }
        }
        if (invalids.length) {
          logger53.error(`Can't create shortcut for actions: ${invalids.join(",")} of "${this.name}" list`);
          names = names.filter((s) => !invalids.includes(s));
        }
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        let n = await nvim.call("confirm", ["Choose action:", choices.join("\n")]);
        await wait(10);
        this.prompt.start();
        if (n)
          await this.doAction(names[n - 1]);
      }
      async doAction(name2) {
        let { list: list2 } = this;
        name2 = name2 || list2.defaultAction;
        let action = list2.actions.find((o) => o.name == name2);
        if (!action) {
          window_default.showMessage(`Action ${name2} not found`, "error");
          return;
        }
        let items;
        if (name2 == "preview") {
          let item = await this.ui.item;
          items = item ? [item] : [];
        } else {
          items = await this.ui.getItems();
        }
        if (items.length)
          await this.doItemAction(items, action);
      }
      async doPreview(index) {
        let item = this.ui.getItem(index);
        let action = this.list.actions.find((o) => o.name == "preview");
        if (!item || !action)
          return;
        await this.doItemAction([item], action);
      }
      async first() {
        await this.doDefaultAction(0);
      }
      async last() {
        await this.doDefaultAction(this.ui.length - 1);
      }
      async previous() {
        await this.doDefaultAction(this.ui.index - 1);
      }
      async next() {
        await this.doDefaultAction(this.ui.index + 1);
      }
      async doDefaultAction(index) {
        let { ui } = this;
        let item = ui.getItem(index);
        if (!item)
          return;
        ui.index = index;
        await this.doItemAction([item], this.defaultAction);
        await ui.echoMessage(item);
      }
      get name() {
        return this.list.name;
      }
      get winid() {
        return this.ui.winid;
      }
      get length() {
        return this.ui.length;
      }
      get defaultAction() {
        let { defaultAction, actions } = this.list;
        let action = actions.find((o) => o.name == defaultAction);
        if (!action)
          throw new Error(`default action "${defaultAction}" not found`);
        return action;
      }
      async hide() {
        if (this.hidden)
          return;
        if (this.uiTokenSource) {
          this.uiTokenSource.cancel();
          this.uiTokenSource.dispose();
          this.uiTokenSource = null;
        }
        let { nvim, interval } = this;
        if (interval)
          clearInterval(interval);
        this.hidden = true;
        this.worker.stop();
        this.history.add();
        let { winid } = this.ui;
        this.ui.reset();
        if (this.window && winid) {
          await nvim.call("coc#list#hide", [this.window.id, this.savedHeight, winid]);
          if (workspace_default.isVim) {
            nvim.command("redraw", true);
            await wait(10);
          }
        }
        nvim.call("coc#prompt#stop_prompt", ["list"], true);
      }
      toggleMode() {
        let mode = this.prompt.mode == "normal" ? "insert" : "normal";
        this.prompt.mode = mode;
        this.listOptions.mode = mode;
        this.updateStatus();
      }
      stop() {
        this.worker.stop();
      }
      async resolveItem() {
        let index = this.ui.index;
        let item = this.ui.getItem(index);
        if (!item || item.resolved)
          return;
        let { list: list2 } = this;
        if (typeof list2.resolveItem == "function") {
          let resolved = await Promise.resolve(list2.resolveItem(item));
          if (resolved && index == this.ui.index) {
            await this.ui.updateItem(resolved, index);
          }
        }
      }
      async showHelp() {
        await this.hide();
        let { list: list2, nvim } = this;
        if (!list2)
          return;
        nvim.pauseNotification();
        nvim.command(`tabe +setl\\ previewwindow [LIST HELP]`, true);
        nvim.command("setl nobuflisted noswapfile buftype=nofile bufhidden=wipe", true);
        await nvim.resumeNotification();
        let hasOptions = list2.options && list2.options.length;
        let buf = await nvim.buffer;
        let highligher = new Highlighter();
        highligher.addLine("NAME", "Label");
        highligher.addLine(`  ${list2.name} - ${list2.description || ""}
`);
        highligher.addLine("SYNOPSIS", "Label");
        highligher.addLine(`  :CocList [LIST OPTIONS] ${list2.name}${hasOptions ? " [ARGUMENTS]" : ""}
`);
        if (list2.detail) {
          highligher.addLine("DESCRIPTION", "Label");
          let lines = list2.detail.split("\n").map((s) => "  " + s);
          highligher.addLine(lines.join("\n") + "\n");
        }
        if (hasOptions) {
          highligher.addLine("ARGUMENTS", "Label");
          highligher.addLine("");
          for (let opt of list2.options) {
            highligher.addLine(opt.name, "Special");
            highligher.addLine(`  ${opt.description}`);
            highligher.addLine("");
          }
          highligher.addLine("");
        }
        let config = workspace_default.getConfiguration(`list.source.${list2.name}`);
        if (Object.keys(config).length) {
          highligher.addLine("CONFIGURATIONS", "Label");
          highligher.addLine("");
          let props = {};
          extensions_default.all.forEach((extension) => {
            let { packageJSON } = extension;
            let { contributes } = packageJSON;
            if (!contributes)
              return;
            let { configuration } = contributes;
            if (configuration) {
              let { properties } = configuration;
              if (properties) {
                for (let key of Object.keys(properties)) {
                  props[key] = properties[key];
                }
              }
            }
          });
          for (let key of Object.keys(config)) {
            let val = config[key];
            let name2 = `list.source.${list2.name}.${key}`;
            let description = props[name2] && props[name2].description ? props[name2].description : key;
            highligher.addLine(`  "${name2}"`, "MoreMsg");
            highligher.addText(` - ${description}, current value: `);
            highligher.addText(JSON.stringify(val), "Special");
          }
          highligher.addLine("");
        }
        highligher.addLine("ACTIONS", "Label");
        highligher.addLine(`  ${list2.actions.map((o) => o.name).join(", ")}`);
        highligher.addLine("");
        highligher.addLine(`see ':h coc-list-options' for available list options.`, "Comment");
        nvim.pauseNotification();
        highligher.render(buf, 0, -1);
        nvim.command("setl nomod", true);
        nvim.command("setl nomodifiable", true);
        nvim.command("normal! gg", true);
        nvim.command("nnoremap <buffer> q :bd!<CR>", true);
        await nvim.resumeNotification();
      }
      switchMatcher() {
        let { matcher, interactive } = this.listOptions;
        if (interactive)
          return;
        const list2 = ["fuzzy", "strict", "regex"];
        let idx = list2.indexOf(matcher) + 1;
        if (idx >= list2.length)
          idx = 0;
        this.listOptions.matcher = list2[idx];
        this.prompt.matcher = list2[idx];
        this.worker.drawItems();
      }
      updateStatus() {
        let { ui, list: list2, nvim } = this;
        if (!ui.winid)
          return;
        let buf = nvim.createBuffer(ui.bufnr);
        let status = {
          mode: this.prompt.mode.toUpperCase(),
          args: this.args.join(" "),
          name: list2.name,
          cwd: this.cwd,
          loading: this.loadingFrame,
          total: this.worker.length
        };
        nvim.pauseNotification();
        buf.setVar("list_status", status, true);
        nvim.command("redraws", true);
        nvim.resumeNotification(false, true).logError();
      }
      get context() {
        let { winid } = this.ui;
        return {
          options: this.listOptions,
          args: this.listArgs,
          input: this.prompt.input,
          cwd: workspace_default.cwd,
          window: this.window,
          buffer: this.buffer,
          listWindow: winid ? this.nvim.createWindow(winid) : void 0
        };
      }
      redrawItems() {
        this.worker.drawItems();
      }
      onMouseEvent(key) {
        switch (key) {
          case "<LeftMouse>":
            return this.ui.onMouse("mouseDown");
          case "<LeftDrag>":
            return this.ui.onMouse("mouseDrag");
          case "<LeftRelease>":
            return this.ui.onMouse("mouseUp");
          case "<2-LeftMouse>":
            return this.ui.onMouse("doubleClick");
        }
      }
      async doNumberSelect(ch) {
        if (!this.listOptions.numberSelect)
          return false;
        let code = ch.charCodeAt(0);
        if (code >= 48 && code <= 57) {
          let n = Number(ch);
          if (n == 0)
            n = 10;
          if (this.ui.length >= n) {
            this.nvim.pauseNotification();
            this.ui.setCursor(Number(ch), 0);
            await this.nvim.resumeNotification();
            await this.doAction();
          }
          return true;
        }
        return false;
      }
      jumpBack() {
        let { window: window2, nvim } = this;
        if (window2) {
          nvim.pauseNotification();
          nvim.call("coc#prompt#stop_prompt", ["list"], true);
          this.nvim.call("win_gotoid", [window2.id], true);
          nvim.resumeNotification(false, true).logError();
        }
      }
      async resume() {
        if (this.winid)
          await this.hide();
        let res = await this.nvim.eval('[win_getid(),bufnr("%"),winheight("%")]');
        this.hidden = false;
        this.window = this.nvim.createWindow(res[0]);
        this.buffer = this.nvim.createBuffer(res[1]);
        this.savedHeight = res[2];
        this.prompt.start();
        await this.ui.resume();
        if (this.listOptions.autoPreview) {
          await this.doAction("preview");
        }
      }
      async doItemAction(items, action) {
        let { noQuit } = this.listOptions;
        let { nvim } = this;
        let persistAction = action.persist === true || action.name == "preview";
        let persist = this.winid && (persistAction || noQuit);
        try {
          if (persist) {
            if (!persistAction) {
              nvim.pauseNotification();
              nvim.call("coc#prompt#stop_prompt", ["list"], true);
              nvim.call("win_gotoid", [this.context.window.id], true);
              await nvim.resumeNotification();
            }
          } else {
            await this.hide();
          }
          if (action.multiple) {
            await Promise.resolve(action.execute(items, this.context));
          } else if (action.parallel) {
            await Promise.all(items.map((item) => Promise.resolve(action.execute(item, this.context))));
          } else {
            for (let item of items) {
              await Promise.resolve(action.execute(item, this.context));
            }
          }
          if (persist) {
            this.ui.restoreWindow();
          }
          if (action.reload && persist)
            await this.worker.loadItems(this.context, true);
        } catch (e) {
          window_default.showMessage(e.message, "error");
          logger53.error(`Error on action "${action.name}"`, e);
        }
      }
      onInputChange() {
        if (this.timer)
          clearTimeout(this.timer);
        let len = this.worker.length;
        this.listOptions.input = this.prompt.input;
        if (this.listOptions.interactive) {
          this.worker.stop();
          this.timer = setTimeout(async () => {
            await this.worker.loadItems(this.context);
          }, this.interactiveDebounceTime);
        } else if (len) {
          let wait2 = Math.max(Math.min(Math.floor(len / 200), 300), 50);
          this.timer = setTimeout(() => {
            this.worker.drawItems();
          }, wait2);
        }
      }
      dispose() {
        if (!this.hidden) {
          this.hidden = true;
          if (this.uiTokenSource) {
            this.uiTokenSource.cancel();
            this.uiTokenSource.dispose();
            this.uiTokenSource = null;
          }
          let { winid } = this.ui;
          this.ui.reset();
          if (this.window && winid) {
            this.nvim.call("coc#list#hide", [this.window.id, this.savedHeight, winid], true);
          }
        }
        if (this.interval) {
          clearInterval(this.interval);
        }
        if (this.timer) {
          clearTimeout(this.timer);
        }
        disposeAll(this.disposables);
        this.worker.dispose();
        this.ui.dispose();
      }
    };
  }
});

// src/list/commandTask.ts
var import_child_process5, import_events17, import_readline3, logger54, CommandTask;
var init_commandTask = __esm({
  "src/list/commandTask.ts"() {
    import_child_process5 = __toModule(require("child_process"));
    import_events17 = __toModule(require("events"));
    import_readline3 = __toModule(require("readline"));
    init_util();
    logger54 = require_logger2()("list-commandTask");
    CommandTask = class extends import_events17.EventEmitter {
      constructor(opt) {
        super();
        this.opt = opt;
        this.disposables = [];
        this.start();
      }
      start() {
        let { cmd, args, cwd, onLine } = this.opt;
        let proc = (0, import_child_process5.spawn)(cmd, args, { cwd, windowsHide: true });
        this.disposables.push({
          dispose: () => {
            proc.kill();
          }
        });
        proc.on("error", (e) => {
          this.emit("error", e.message);
        });
        proc.stderr.on("data", (chunk) => {
          logger54.error(`[${cmd} Error]`, chunk.toString("utf8"));
        });
        const rl = import_readline3.default.createInterface(proc.stdout);
        rl.on("line", (line) => {
          let res = onLine(line);
          if (res)
            this.emit("data", res);
        });
        rl.on("close", () => {
          this.emit("end");
        });
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/list/basic.ts
var import_fs18, import_path19, import_readline4, import_vscode_languageserver_protocol59, logger55, BasicList;
var init_basic = __esm({
  "src/list/basic.ts"() {
    import_fs18 = __toModule(require("fs"));
    import_path19 = __toModule(require("path"));
    import_readline4 = __toModule(require("readline"));
    import_vscode_languageserver_protocol59 = __toModule(require_main2());
    init_esm2();
    init_util();
    init_fs();
    init_position();
    init_workspace();
    init_commandTask();
    init_configuration4();
    logger55 = require_logger2()("list-basic");
    BasicList = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.defaultAction = "open";
        this.actions = [];
        this.options = [];
        this.disposables = [];
        this.config = new ListConfiguration();
      }
      get alignColumns() {
        return this.config.get("alignColumns", false);
      }
      get hlGroup() {
        return this.config.get("previewHighlightGroup", "Search");
      }
      get previewHeight() {
        return this.config.get("maxPreviewHeight", 12);
      }
      get splitRight() {
        return this.config.get("previewSplitRight", false);
      }
      parseArguments(args) {
        if (!this.optionMap) {
          this.optionMap = new Map();
          for (let opt of this.options) {
            let parts = opt.name.split(/,\s*/g).map((s) => s.replace(/\s+.*/g, ""));
            let name2 = opt.key ? opt.key : parts[parts.length - 1].replace(/^-/, "");
            for (let p of parts) {
              this.optionMap.set(p, { name: name2, hasValue: opt.hasValue });
            }
          }
        }
        let res = {};
        for (let i = 0; i < args.length; i++) {
          let arg = args[i];
          let def = this.optionMap.get(arg);
          if (!def) {
            logger55.error(`Option "${arg}" of "${this.name}" not found`);
            continue;
          }
          let value = true;
          if (def.hasValue) {
            value = args[i + 1] || "";
            i = i + 1;
          }
          res[def.name] = value;
        }
        return res;
      }
      getConfig() {
        return workspace_default.getConfiguration(`list.source.${this.name}`);
      }
      addAction(name2, fn, options) {
        this.createAction(Object.assign({
          name: name2,
          execute: fn
        }, options || {}));
      }
      addMultipleAction(name2, fn, options) {
        this.createAction(Object.assign({
          name: name2,
          multiple: true,
          execute: fn
        }, options || {}));
      }
      createCommandTask(opt) {
        return new CommandTask(opt);
      }
      addLocationActions() {
        this.createAction({
          name: "preview",
          execute: async (item, context) => {
            let loc = await this.convertLocation(item.location);
            await this.previewLocation(loc, context);
          }
        });
        let { nvim } = this;
        this.createAction({
          name: "quickfix",
          multiple: true,
          execute: async (items) => {
            let quickfixItems = await Promise.all(items.map((item) => this.convertLocation(item.location).then((loc) => workspace_default.getQuickfixItem(loc))));
            await nvim.call("setqflist", [quickfixItems]);
            let openCommand = await nvim.getVar("coc_quickfix_open_command");
            nvim.command(typeof openCommand === "string" ? openCommand : "copen", true);
          }
        });
        for (let name2 of ["open", "tabe", "drop", "vsplit", "split"]) {
          this.createAction({
            name: name2,
            execute: async (item) => {
              await this.jumpTo(item.location, name2 == "open" ? null : name2);
            }
          });
        }
      }
      async convertLocation(location) {
        if (typeof location == "string")
          return import_vscode_languageserver_protocol59.Location.create(location, import_vscode_languageserver_protocol59.Range.create(0, 0, 0, 0));
        if (import_vscode_languageserver_protocol59.Location.is(location))
          return location;
        let u = URI.parse(location.uri);
        if (u.scheme != "file")
          return import_vscode_languageserver_protocol59.Location.create(location.uri, import_vscode_languageserver_protocol59.Range.create(0, 0, 0, 0));
        const rl = import_readline4.default.createInterface({
          input: import_fs18.default.createReadStream(u.fsPath, { encoding: "utf8" })
        });
        let match = location.line;
        let n = 0;
        let resolved = false;
        let line = await new Promise((resolve3) => {
          rl.on("line", (line2) => {
            if (resolved)
              return;
            if (line2.includes(match)) {
              rl.removeAllListeners();
              rl.close();
              resolved = true;
              resolve3(line2);
              return;
            }
            n = n + 1;
          });
          rl.on("error", (e) => {
            this.nvim.errWriteLine(`Read ${u.fsPath} error: ${e.message}`);
            resolve3(null);
          });
        });
        if (line != null) {
          let character = location.text ? line.indexOf(location.text) : 0;
          if (character == 0)
            character = line.match(/^\s*/)[0].length;
          let end = import_vscode_languageserver_protocol59.Position.create(n, character + (location.text ? location.text.length : 0));
          return import_vscode_languageserver_protocol59.Location.create(location.uri, import_vscode_languageserver_protocol59.Range.create(import_vscode_languageserver_protocol59.Position.create(n, character), end));
        }
        return import_vscode_languageserver_protocol59.Location.create(location.uri, import_vscode_languageserver_protocol59.Range.create(0, 0, 0, 0));
      }
      async jumpTo(location, command) {
        if (typeof location == "string") {
          await workspace_default.jumpTo(location, null, command);
          return;
        }
        let { range, uri } = await this.convertLocation(location);
        let position = range.start;
        if (position.line == 0 && position.character == 0 && comparePosition(position, range.end) == 0) {
          position = null;
        }
        await workspace_default.jumpTo(uri, position, command);
      }
      createAction(action) {
        let { name: name2 } = action;
        let idx = this.actions.findIndex((o) => o.name == name2);
        if (idx !== -1)
          this.actions.splice(idx, 1);
        this.actions.push(action);
      }
      async previewLocation(location, context) {
        if (!context.listWindow)
          return;
        let { nvim } = this;
        let { uri, range } = location;
        let doc = workspace_default.getDocument(location.uri);
        let u = URI.parse(uri);
        let lines = [];
        if (doc) {
          lines = doc.getLines();
        } else if (u.scheme == "file") {
          try {
            let content = await readFile(u.fsPath, "utf8");
            lines = content.split(/\r?\n/);
          } catch (e) {
            [`Error on read file ${u.fsPath}`, e.message];
          }
        }
        let config = {
          winid: context.window.id,
          range: emptyRange(range) ? null : range,
          lnum: range.start.line + 1,
          name: u.scheme == "file" ? u.fsPath : uri,
          filetype: doc ? doc.filetype : this.getFiletype(u.fsPath),
          position: context.options.position,
          maxHeight: this.previewHeight,
          splitRight: this.splitRight,
          hlGroup: this.hlGroup,
          scheme: u.scheme
        };
        await nvim.call("coc#list#preview", [lines, config]);
        if (workspace_default.isVim)
          nvim.command("redraw", true);
      }
      async preview(options, context) {
        let { nvim } = this;
        let { bufname, filetype, range, lines, lnum } = options;
        let config = {
          winid: context.window.id,
          lnum: range ? range.start.line + 1 : lnum || 1,
          filetype: filetype || "txt",
          position: context.options.position,
          maxHeight: this.previewHeight,
          splitRight: this.splitRight,
          hlGroup: this.hlGroup
        };
        if (bufname)
          config.name = bufname;
        if (range)
          config.range = range;
        await nvim.call("coc#list#preview", [lines, config]);
        if (workspace_default.isVim)
          nvim.command("redraw", true);
      }
      doHighlight() {
      }
      dispose() {
        disposeAll(this.disposables);
      }
      getFiletype(filepath) {
        let extname = import_path19.default.extname(filepath);
        if (!extname)
          return "";
        for (let doc of workspace_default.documents) {
          let fsPath = URI.parse(doc.uri).fsPath;
          if (import_path19.default.extname(fsPath) == extname) {
            let { filetype } = doc;
            if (filetype == "javascriptreact")
              return "javascript";
            if (filetype == "typescriptreact")
              return "typescript";
            if (filetype.indexOf(".") !== -1)
              return filetype.split(".")[0];
            return filetype;
          }
        }
        return "";
      }
    };
  }
});

// src/list/formatting.ts
function formatListItems(align, list2) {
  if (list2.length === 0) {
    return [];
  }
  let processedList = [];
  if (align) {
    const maxWidths = Array(Math.min(...list2.map((item) => item.label.length))).fill(0);
    for (let item of list2) {
      for (let i = 0; i < maxWidths.length; i++) {
        maxWidths[i] = Math.max(maxWidths[i], item.label[i].length);
      }
    }
    processedList = list2.map((item) => __spreadProps(__spreadValues({}, item), {
      label: item.label.map((element, idx) => element.padEnd(maxWidths[idx])).join("	")
    }));
  } else {
    processedList = list2.map((item) => __spreadProps(__spreadValues({}, item), { label: item.label.join("	") }));
  }
  return processedList;
}
function formatPath(format2, pathToFormat) {
  var _a2;
  if (format2 === "hidden") {
    return "";
  } else if (format2 === "full") {
    return pathToFormat;
  } else if (format2 === "short") {
    const segments = pathToFormat.split(import_path20.default.sep);
    if (segments.length < 2) {
      return pathToFormat;
    }
    const shortenedInit = segments.slice(0, segments.length - 2).filter((seg) => seg.length > 0).map((seg) => seg[0]);
    return [...shortenedInit, segments[segments.length - 1]].join(import_path20.default.sep);
  } else {
    const segments = pathToFormat.split(import_path20.default.sep);
    return (_a2 = segments[segments.length - 1]) != null ? _a2 : "";
  }
}
var import_path20;
var init_formatting = __esm({
  "src/list/formatting.ts"() {
    import_path20 = __toModule(require("path"));
  }
});

// src/list/source/commands.ts
function score3(list2, key) {
  let idx = list2.indexOf(key);
  return idx == -1 ? -1 : list2.length - idx;
}
var CommandsList;
var init_commands = __esm({
  "src/list/source/commands.ts"() {
    init_commands2();
    init_events();
    init_workspace();
    init_basic();
    init_formatting();
    CommandsList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "run";
        this.description = "registered commands of coc.nvim";
        this.name = "commands";
        this.mru = workspace_default.createMru("commands");
        this.addAction("run", async (item) => {
          let { cmd } = item.data;
          await events_default.fire("Command", [cmd]);
          commands_default.executeCommand(cmd).logError();
          await commands_default.addRecent(cmd);
        });
        this.addAction("append", async (item) => {
          let { cmd } = item.data;
          await nvim.feedKeys(`:CocCommand ${cmd} `, "n", false);
        });
      }
      async loadItems(_context) {
        let items = [];
        let mruList = await this.mru.load();
        let { commandList, onCommandList, titles } = commands_default;
        let ids = commandList.map((c) => c.id).concat(onCommandList);
        for (const id of [...new Set(ids)]) {
          items.push({
            label: [id, ...titles.get(id) ? [titles.get(id)] : []],
            filterText: id,
            data: { cmd: id, score: score3(mruList, id) }
          });
        }
        items.sort((a, b) => b.data.score - a.data.score);
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocCommandsTitle /\\t.*$/ contained containedin=CocCommandsLine", true);
        nvim.command("highlight default link CocCommandsTitle Comment", true);
        nvim.resumeNotification().catch((_e) => {
        });
      }
    };
  }
});

// src/list/source/location.ts
var import_path21, logger56, LocationList;
var init_location = __esm({
  "src/list/source/location.ts"() {
    init_main();
    import_path21 = __toModule(require("path"));
    init_basic();
    init_workspace();
    init_esm2();
    init_fs();
    init_string();
    logger56 = require_logger2()("list-location");
    LocationList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "open";
        this.description = "show locations saved by g:coc_jump_locations variable";
        this.name = "location";
        this.addLocationActions();
      }
      async loadItems(context, token) {
        let locs = await this.nvim.getVar("coc_jump_locations");
        if (token.isCancellationRequested)
          return [];
        locs = locs || [];
        locs.forEach((loc) => {
          if (!loc.uri) {
            let fullpath = import_path21.default.isAbsolute(loc.filename) ? loc.filename : import_path21.default.join(context.cwd, loc.filename);
            loc.uri = URI.file(fullpath).toString();
          }
          if (!loc.bufnr && workspace_default.getDocument(loc.uri) != null) {
            loc.bufnr = workspace_default.getDocument(loc.uri).bufnr;
          }
          if (!loc.range) {
            let { lnum, col } = loc;
            loc.range = Range.create(lnum - 1, col - 1, lnum - 1, col - 1);
          } else {
            loc.lnum = loc.lnum || loc.range.start.line + 1;
            loc.col = loc.col || loc.range.start.character + 1;
          }
        });
        let bufnr = await this.nvim.call("bufnr", "%");
        let ignoreFilepath = locs.every((o) => o.bufnr && bufnr && o.bufnr == bufnr);
        let items = locs.map((loc) => {
          let filename = ignoreFilepath ? "" : loc.filename;
          let filterText = `${filename}${loc.text.trim()}`;
          if (import_path21.default.isAbsolute(filename)) {
            filename = isParentFolder(context.cwd, filename) ? import_path21.default.relative(context.cwd, filename) : filename;
          }
          let pre = `${filename} |${loc.type ? loc.type + " " : ""}${loc.lnum} col ${loc.col}| `;
          let highlight;
          if (loc.range && loc.range.start.line == loc.range.end.line) {
            let start = byteLength(pre) + byteLength(loc.text.slice(0, loc.range.start.character));
            let end = byteLength(pre) + byteLength(loc.text.slice(0, loc.range.end.character));
            highlight = { hlGroup: "Search", span: [start, end] };
          }
          let label = pre + loc.text;
          return {
            label,
            location: Location.create(loc.uri, loc.range),
            filterText,
            ansiHighlights: highlight ? [highlight] : void 0
          };
        });
        return items;
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocLocationName /\\v^[^|]+/ contained containedin=CocLocationLine", true);
        nvim.command("syntax match CocLocationPosition /\\v\\|\\w*\\s?\\d+\\scol\\s\\d+\\|/ contained containedin=CocLocationLine", true);
        nvim.command("syntax match CocLocationError /Error/ contained containedin=CocLocationPosition", true);
        nvim.command("syntax match CocLocationWarning /Warning/ contained containedin=CocLocationPosition", true);
        nvim.command("highlight default link CocLocationName Directory", true);
        nvim.command("highlight default link CocLocationPosition LineNr", true);
        nvim.command("highlight default link CocLocationError Error", true);
        nvim.command("highlight default link CocLocationWarning WarningMsg", true);
        nvim.resumeNotification().catch((_e) => {
        });
      }
    };
  }
});

// src/list/source/diagnostics.ts
var import_path22, logger57, DiagnosticsList;
var init_diagnostics = __esm({
  "src/list/source/diagnostics.ts"() {
    import_path22 = __toModule(require("path"));
    init_manager();
    init_location();
    init_fs();
    init_formatting();
    logger57 = require_logger2()("list-symbols");
    DiagnosticsList = class extends LocationList {
      constructor() {
        super(...arguments);
        this.defaultAction = "open";
        this.description = "diagnostics of current workspace";
        this.name = "diagnostics";
      }
      async loadItems(context) {
        let list2 = manager_default.getDiagnosticList();
        let { cwd } = context;
        const shouldIncludeCode = this.getConfig().get("includeCode", true);
        const pathFormat = this.getConfig().get("pathFormat", "full");
        const unformatted = list2.map((item) => {
          const file = isParentFolder(cwd, item.file) ? import_path22.default.relative(cwd, item.file) : item.file;
          const formattedPath = formatPath(pathFormat, file);
          const formattedPosition = pathFormat !== "hidden" ? [`${formattedPath}:${item.lnum}`] : [];
          const code = shouldIncludeCode ? [`[${item.source}${item.code ? "" : "]"}`, item.code ? `${item.code}]` : ""] : [];
          return {
            label: [...formattedPosition, ...code, item.severity, item.message],
            location: item.location
          };
        });
        return formatListItems(this.alignColumns, unformatted);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocDiagnosticsFile /\\v^\\s*\\S+/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsError /\\tError\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsWarning /\\tWarning\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsInfo /\\tInformation\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsHint /\\tHint\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("highlight default link CocDiagnosticsFile Comment", true);
        nvim.command("highlight default link CocDiagnosticsError CocErrorSign", true);
        nvim.command("highlight default link CocDiagnosticsWarning CocWarningSign", true);
        nvim.command("highlight default link CocDiagnosticsInfo CocInfoSign", true);
        nvim.command("highlight default link CocDiagnosticsHint CocHintSign", true);
        nvim.resumeNotification().catch((_e) => {
        });
      }
    };
  }
});

// src/list/source/extensions.ts
function getPriority(stat) {
  switch (stat) {
    case "unknown":
      return 2;
    case "activated":
      return 1;
    case "disabled":
      return -1;
    default:
      return 0;
  }
}
var import_fs_extra7, import_os9, import_path23, logger58, ExtensionList;
var init_extensions = __esm({
  "src/list/source/extensions.ts"() {
    import_fs_extra7 = __toModule(require_lib5());
    import_os9 = __toModule(require("os"));
    import_path23 = __toModule(require("path"));
    init_esm2();
    init_extensions2();
    init_util();
    init_workspace();
    init_window();
    init_basic();
    init_formatting();
    logger58 = require_logger2()("list-extensions");
    ExtensionList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "toggle";
        this.description = "manage coc extensions";
        this.name = "extensions";
        this.addAction("toggle", async (item) => {
          let { id, state } = item.data;
          if (state == "disabled")
            return;
          if (state == "activated") {
            await extensions_default.deactivate(id);
          } else {
            await extensions_default.activate(id);
          }
          await wait(100);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("configuration", async (item) => {
          let { root } = item.data;
          let jsonFile = import_path23.default.join(root, "package.json");
          if (import_fs_extra7.default.existsSync(jsonFile)) {
            let lines = import_fs_extra7.default.readFileSync(jsonFile, "utf8").split(/\r?\n/);
            let idx = lines.findIndex((s) => s.includes('"contributes"'));
            await workspace_default.jumpTo(URI.file(jsonFile).toString(), { line: idx == -1 ? 0 : idx, character: 0 });
          }
        });
        this.addAction("open", async (item) => {
          let { root } = item.data;
          if (workspace_default.env.isiTerm) {
            nvim.call("coc#util#iterm_open", [root], true);
          } else {
            nvim.call("coc#util#open_url", [root], true);
          }
        });
        this.addAction("disable", async (item) => {
          let { id, state } = item.data;
          if (state !== "disabled")
            await extensions_default.toggleExtension(id);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("enable", async (item) => {
          let { id, state } = item.data;
          if (state == "disabled")
            await extensions_default.toggleExtension(id);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("lock", async (item) => {
          let { id } = item.data;
          await extensions_default.toggleLock(id);
        }, { persist: true, reload: true });
        this.addAction("help", async (item) => {
          let { root } = item.data;
          let files = await import_fs_extra7.default.readdir(root);
          let file = files.find((f) => /^readme/i.test(f));
          if (file) {
            let escaped = await nvim.call("fnameescape", [import_path23.default.join(root, file)]);
            await workspace_default.callAsync("coc#util#execute", [`edit ${escaped}`]);
          }
        });
        this.addAction("reload", async (item) => {
          let { id } = item.data;
          await extensions_default.reloadExtension(id);
        }, { persist: true, reload: true });
        this.addAction("fix", async (item) => {
          let { root, isLocal } = item.data;
          let { npm } = extensions_default;
          if (isLocal) {
            window_default.showMessage(`Can't fix for local extension.`, "warning");
            return;
          }
          if (!npm)
            return;
          let folder = import_path23.default.join(root, "node_modules");
          if (import_fs_extra7.default.existsSync(folder)) {
            import_fs_extra7.default.removeSync(folder);
          }
          let terminal = await workspace_default.createTerminal({
            cwd: root
          });
          let shown = await terminal.show(false);
          if (!shown)
            return;
          workspace_default.nvim.command(`startinsert`, true);
          terminal.sendText(`${npm} install --production --ignore-scripts --no-lockfile`, true);
        });
        this.addMultipleAction("uninstall", async (items) => {
          let ids = [];
          for (let item of items) {
            if (item.data.isLocal)
              continue;
            ids.push(item.data.id);
          }
          extensions_default.uninstallExtension(ids).catch((e) => {
            logger58.error(e);
          });
        });
      }
      async loadItems(_context) {
        let items = [];
        let list2 = await extensions_default.getExtensionStates();
        let lockedList = await extensions_default.getLockedList();
        for (let stat of list2) {
          let prefix = "+";
          if (stat.state == "disabled") {
            prefix = "-";
          } else if (stat.state == "activated") {
            prefix = "*";
          } else if (stat.state == "unknown") {
            prefix = "?";
          }
          let root = await this.nvim.call("resolve", stat.root);
          let locked = lockedList.includes(stat.id);
          items.push({
            label: [`${prefix} ${stat.id}${locked ? " \uE0A2" : ""}`, ...stat.isLocal ? ["[RTP]"] : [], stat.version, root.replace(import_os9.default.homedir(), "~")],
            filterText: stat.id,
            data: {
              id: stat.id,
              root,
              state: stat.state,
              isLocal: stat.isLocal,
              priority: getPriority(stat.state)
            }
          });
        }
        items.sort((a, b) => {
          if (a.data.priority != b.data.priority) {
            return b.data.priority - a.data.priority;
          }
          return b.data.id - a.data.id ? 1 : -1;
        });
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocExtensionsActivited /\\v^\\*/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsLoaded /\\v^\\+/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsDisabled /\\v^-/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsName /\\v%3c\\S+/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsRoot /\\v\\t[^\\t]*$/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsLocal /\\v\\[RTP\\]/ contained containedin=CocExtensionsLine", true);
        nvim.command("highlight default link CocExtensionsActivited Special", true);
        nvim.command("highlight default link CocExtensionsLoaded Normal", true);
        nvim.command("highlight default link CocExtensionsDisabled Comment", true);
        nvim.command("highlight default link CocExtensionsName String", true);
        nvim.command("highlight default link CocExtensionsLocal MoreMsg", true);
        nvim.command("highlight default link CocExtensionsRoot Comment", true);
        nvim.resumeNotification().catch((_e) => {
        });
      }
    };
  }
});

// src/list/source/folders.ts
var import_path24, import_fs_extra8, FoldList;
var init_folders = __esm({
  "src/list/source/folders.ts"() {
    import_path24 = __toModule(require("path"));
    init_esm2();
    import_fs_extra8 = __toModule(require_lib5());
    init_fs();
    init_workspace();
    init_window();
    init_basic();
    FoldList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "edit";
        this.description = "list of current workspace folders";
        this.name = "folders";
        this.addAction("edit", async (item) => {
          let newPath = await nvim.call("input", ["Folder: ", item.label, "dir"]);
          let stat = await statAsync(newPath);
          if (!stat || !stat.isDirectory()) {
            window_default.showMessage(`invalid path: ${newPath}`, "error");
            return;
          }
          workspace_default.renameWorkspaceFolder(item.label, newPath);
        });
        this.addAction("delete", async (item) => {
          workspace_default.removeWorkspaceFolder(item.label);
        }, { reload: true, persist: true });
        this.addAction("newfile", async (item) => {
          let file = await window_default.requestInput("File name", item.label + "/");
          let dir = import_path24.default.dirname(file);
          let stat = await statAsync(dir);
          if (!stat || !stat.isDirectory()) {
            import_fs_extra8.default.mkdirpSync(dir);
          }
          await workspace_default.createFile(file, { overwrite: false, ignoreIfExists: true });
          await this.jumpTo(URI.file(file).toString());
        });
      }
      async loadItems(_context) {
        return workspace_default.folderPaths.map((p) => ({ label: p }));
      }
    };
  }
});

// src/list/source/links.ts
function formatUri(uri) {
  if (!uri.startsWith("file:"))
    return uri;
  let filepath = URI.parse(uri).fsPath;
  return isParentFolder(workspace_default.cwd, filepath) ? import_path25.default.relative(workspace_default.cwd, filepath) : filepath;
}
var import_path25, LinksList;
var init_links = __esm({
  "src/list/source/links.ts"() {
    init_languages();
    init_workspace();
    import_path25 = __toModule(require("path"));
    init_basic();
    init_main();
    init_esm2();
    init_fs();
    LinksList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "open";
        this.description = "links of current buffer";
        this.name = "links";
        this.addAction("open", async (item) => {
          let { target } = item.data;
          let uri = URI.parse(target);
          if (uri.scheme.startsWith("http")) {
            await nvim.call("coc#util#open_url", target);
          } else {
            await workspace_default.jumpTo(target);
          }
        });
        this.addAction("jump", async (item) => {
          let { location } = item.data;
          await workspace_default.jumpTo(location.uri, location.range.start);
        });
      }
      async loadItems(context, token) {
        let buf = await context.window.buffer;
        let doc = workspace_default.getDocument(buf.id);
        if (!doc)
          return null;
        let items = [];
        let links2 = await languages_default.getDocumentLinks(doc.textDocument, token);
        if (links2 == null) {
          throw new Error("Links provider not found.");
        }
        let res = [];
        for (let link of links2) {
          if (link.target) {
            items.push({
              label: formatUri(link.target),
              data: {
                target: link.target,
                location: Location.create(doc.uri, link.range)
              }
            });
          } else {
            link = await languages_default.resolveDocumentLink(link);
            if (link.target) {
              items.push({
                label: formatUri(link.target),
                data: {
                  target: link.target,
                  location: Location.create(doc.uri, link.range)
                }
              });
            }
            res.push(link);
          }
        }
        return items;
      }
    };
  }
});

// src/list/source/lists.ts
function score4(list2, key) {
  let idx = list2.indexOf(key);
  return idx == -1 ? -1 : list2.length - idx;
}
var LinksList2;
var init_lists = __esm({
  "src/list/source/lists.ts"() {
    init_basic();
    init_mru();
    init_formatting();
    LinksList2 = class extends BasicList {
      constructor(nvim, listMap) {
        super(nvim);
        this.listMap = listMap;
        this.name = "lists";
        this.defaultAction = "open";
        this.description = "registered lists of coc.nvim";
        this.mru = new Mru("lists");
        this.addAction("open", async (item) => {
          let { name: name2 } = item.data;
          await this.mru.add(name2);
          await nvim.command(`CocList ${name2}`);
        });
      }
      async loadItems(_context) {
        let items = [];
        let mruList = await this.mru.load();
        for (let list2 of this.listMap.values()) {
          if (list2.name == "lists")
            continue;
          items.push({
            label: [list2.name, ...list2.description ? [list2.description] : []],
            data: {
              name: list2.name,
              interactive: list2.interactive,
              score: score4(mruList, list2.name)
            }
          });
        }
        items.sort((a, b) => b.data.score - a.data.score);
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocListsDesc /\\t.*$/ contained containedin=CocListsLine", true);
        nvim.command("highlight default link CocListsDesc Comment", true);
        nvim.resumeNotification().catch((_e) => {
        });
      }
    };
  }
});

// src/util/convert.ts
function getSymbolKind(kind) {
  switch (kind) {
    case import_vscode_languageserver_protocol60.SymbolKind.File:
      return "File";
    case import_vscode_languageserver_protocol60.SymbolKind.Module:
      return "Module";
    case import_vscode_languageserver_protocol60.SymbolKind.Namespace:
      return "Namespace";
    case import_vscode_languageserver_protocol60.SymbolKind.Package:
      return "Package";
    case import_vscode_languageserver_protocol60.SymbolKind.Class:
      return "Class";
    case import_vscode_languageserver_protocol60.SymbolKind.Method:
      return "Method";
    case import_vscode_languageserver_protocol60.SymbolKind.Property:
      return "Property";
    case import_vscode_languageserver_protocol60.SymbolKind.Field:
      return "Field";
    case import_vscode_languageserver_protocol60.SymbolKind.Constructor:
      return "Constructor";
    case import_vscode_languageserver_protocol60.SymbolKind.Enum:
      return "Enum";
    case import_vscode_languageserver_protocol60.SymbolKind.Interface:
      return "Interface";
    case import_vscode_languageserver_protocol60.SymbolKind.Function:
      return "Function";
    case import_vscode_languageserver_protocol60.SymbolKind.Variable:
      return "Variable";
    case import_vscode_languageserver_protocol60.SymbolKind.Constant:
      return "Constant";
    case import_vscode_languageserver_protocol60.SymbolKind.String:
      return "String";
    case import_vscode_languageserver_protocol60.SymbolKind.Number:
      return "Number";
    case import_vscode_languageserver_protocol60.SymbolKind.Boolean:
      return "Boolean";
    case import_vscode_languageserver_protocol60.SymbolKind.Array:
      return "Array";
    case import_vscode_languageserver_protocol60.SymbolKind.Object:
      return "Object";
    case import_vscode_languageserver_protocol60.SymbolKind.Key:
      return "Key";
    case import_vscode_languageserver_protocol60.SymbolKind.Null:
      return "Null";
    case import_vscode_languageserver_protocol60.SymbolKind.EnumMember:
      return "EnumMember";
    case import_vscode_languageserver_protocol60.SymbolKind.Struct:
      return "Struct";
    case import_vscode_languageserver_protocol60.SymbolKind.Event:
      return "Event";
    case import_vscode_languageserver_protocol60.SymbolKind.Operator:
      return "Operator";
    case import_vscode_languageserver_protocol60.SymbolKind.TypeParameter:
      return "TypeParameter";
    default:
      return "Unknown";
  }
}
var import_vscode_languageserver_protocol60;
var init_convert = __esm({
  "src/util/convert.ts"() {
    import_vscode_languageserver_protocol60 = __toModule(require_main2());
  }
});

// src/list/source/outline.ts
function getFilterText(s, kind) {
  return `${s.name}${kind ? ` ${kind}` : ""}`;
}
function sortSymbols(a, b) {
  let ra = a.selectionRange;
  let rb = b.selectionRange;
  if (ra.start.line != rb.start.line) {
    return ra.start.line - rb.start.line;
  }
  return ra.start.character - rb.start.character;
}
var import_path26, import_which3, logger59, Outline;
var init_outline = __esm({
  "src/list/source/outline.ts"() {
    import_path26 = __toModule(require("path"));
    init_main();
    init_esm2();
    import_which3 = __toModule(require_which());
    init_languages();
    init_util();
    init_fs();
    init_workspace();
    init_location();
    init_convert();
    init_formatting();
    logger59 = require_logger2()("list-symbols");
    Outline = class extends LocationList {
      constructor() {
        super(...arguments);
        this.description = "symbols of current document";
        this.name = "outline";
        this.options = [{
          name: "-k, -kind KIND",
          hasValue: true,
          description: "filters also by kind"
        }];
      }
      async loadItems(context, token) {
        let buf = await context.window.buffer;
        let document2 = workspace_default.getDocument(buf.id);
        if (!document2)
          return null;
        let config = this.getConfig();
        let ctagsFilestypes = config.get("ctagsFilestypes", []);
        let symbols;
        let args = this.parseArguments(context.args);
        if (!ctagsFilestypes.includes(document2.filetype)) {
          symbols = await languages_default.getDocumentSymbol(document2.textDocument, token);
        }
        if (token.isCancellationRequested)
          return [];
        if (!symbols)
          return await this.loadCtagsSymbols(document2);
        if (symbols.length == 0)
          return [];
        let filterKind = args.kind ? args.kind.toLowerCase() : null;
        let items = [];
        let isSymbols = !symbols[0].hasOwnProperty("location");
        if (isSymbols) {
          let addSymbols = function(symbols2, level = 0) {
            symbols2.sort(sortSymbols);
            for (let s of symbols2) {
              let kind = getSymbolKind(s.kind);
              let location = Location.create(document2.uri, s.selectionRange);
              items.push({
                label: [`${"| ".repeat(level)}${s.name}`, `[${kind}]`, `${s.range.start.line + 1}`],
                filterText: getFilterText(s, args.kind == "" ? kind : null),
                location,
                data: { kind }
              });
              if (s.children && s.children.length) {
                addSymbols(s.children, level + 1);
              }
            }
          };
          addSymbols(symbols);
          if (filterKind) {
            items = items.filter((o) => o.data.kind.toLowerCase().indexOf(filterKind) == 0);
          }
        } else {
          symbols.sort((a, b) => {
            let sa = a.location.range.start;
            let sb = b.location.range.start;
            let d = sa.line - sb.line;
            return d == 0 ? sa.character - sb.character : d;
          });
          for (let s of symbols) {
            let kind = getSymbolKind(s.kind);
            if (s.name.endsWith(") callback"))
              continue;
            if (filterKind && !kind.toLowerCase().startsWith(filterKind)) {
              continue;
            }
            if (s.location.uri === void 0) {
              s.location.uri = document2.uri;
            }
            items.push({
              label: [s.name, `[${kind}]`, `${s.location.range.start.line + 1}`],
              filterText: getFilterText(s, args.kind == "" ? kind : null),
              location: s.location
            });
          }
        }
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocOutlineName /\\v\\s?[^\\t]+\\s/ contained containedin=CocOutlineLine", true);
        nvim.command("syntax match CocOutlineIndentLine /\\v\\|/ contained containedin=CocOutlineLine,CocOutlineName", true);
        nvim.command("syntax match CocOutlineKind /\\[\\w\\+\\]/ contained containedin=CocOutlineLine", true);
        nvim.command("syntax match CocOutlineLine /\\d\\+$/ contained containedin=CocOutlineLine", true);
        nvim.command("highlight default link CocOutlineName Normal", true);
        nvim.command("highlight default link CocOutlineIndentLine Comment", true);
        nvim.command("highlight default link CocOutlineKind Typedef", true);
        nvim.command("highlight default link CocOutlineLine Comment", true);
        nvim.resumeNotification(false, true).logError();
      }
      async loadCtagsSymbols(document2) {
        if (!import_which3.default.sync("ctags", { nothrow: true })) {
          return [];
        }
        let uri = URI.parse(document2.uri);
        let extname = import_path26.default.extname(uri.fsPath);
        let content = "";
        let tempname = await this.nvim.call("tempname");
        let filepath = `${tempname}.${extname}`;
        let escaped = await this.nvim.call("fnameescape", filepath);
        await writeFile(escaped, document2.getDocumentContent());
        try {
          content = await runCommand(`ctags -f - --excmd=number --language-force=${document2.filetype} ${escaped}`);
        } catch (e) {
        }
        if (!content.trim().length) {
          content = await runCommand(`ctags -f - --excmd=number ${escaped}`);
        }
        content = content.trim();
        if (!content)
          return [];
        let lines = content.split(/\r?\n/);
        let items = [];
        for (let line of lines) {
          let parts = line.split("	");
          if (parts.length < 4)
            continue;
          let lnum = Number(parts[2].replace(/;"$/, ""));
          let text = document2.getline(lnum - 1);
          if (!text)
            continue;
          let idx = text.indexOf(parts[0]);
          let start = idx == -1 ? 0 : idx;
          let range = Range.create(lnum - 1, start, lnum - 1, start + parts[0].length);
          items.push({
            label: `${parts[0]} [${parts[3]}] ${lnum}`,
            filterText: parts[0],
            location: Location.create(document2.uri, range),
            data: { line: lnum }
          });
        }
        items.sort((a, b) => a.data.line - b.data.line);
        return items;
      }
    };
  }
});

// src/list/source/services.ts
var ServicesList;
var init_services2 = __esm({
  "src/list/source/services.ts"() {
    init_services();
    init_basic();
    init_util();
    init_formatting();
    ServicesList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "toggle";
        this.description = "registered services of coc.nvim";
        this.name = "services";
        this.addAction("toggle", async (item) => {
          let { id } = item.data;
          await services_default.toggle(id);
          await wait(100);
        }, { persist: true, reload: true });
      }
      async loadItems(_context) {
        let stats = services_default.getServiceStats();
        stats.sort((a, b) => a.id > b.id ? -1 : 1);
        return formatListItems(this.alignColumns, stats.map((stat) => {
          let prefix = stat.state == "running" ? "*" : " ";
          return {
            label: [prefix, stat.id, `[${stat.state}]`, stat.languageIds.join(", ")],
            data: { id: stat.id }
          };
        }));
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocServicesPrefix /\\v^./ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesName /\\v%3c\\S+/ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesStat /\\v\\t\\[\\w+\\]/ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesLanguages /\\v(\\])@<=.*$/ contained containedin=CocServicesLine", true);
        nvim.command("highlight default link CocServicesPrefix Special", true);
        nvim.command("highlight default link CocServicesName Type", true);
        nvim.command("highlight default link CocServicesStat Statement", true);
        nvim.command("highlight default link CocServicesLanguages Comment", true);
        nvim.resumeNotification().catch((_e) => {
        });
      }
    };
  }
});

// src/list/source/sources.ts
function fixWidth(str, width) {
  if (str.length > width) {
    return str.slice(0, width - 1) + ".";
  }
  return str + " ".repeat(width - str.length);
}
var logger60, SourcesList;
var init_sources = __esm({
  "src/list/source/sources.ts"() {
    init_main();
    init_esm2();
    init_sources2();
    init_workspace();
    init_basic();
    logger60 = require_logger2()("list-sources");
    SourcesList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "toggle";
        this.description = "registered completion sources";
        this.name = "sources";
        this.addAction("toggle", async (item) => {
          let { name: name2 } = item.data;
          sources_default.toggleSource(name2);
        }, { persist: true, reload: true });
        this.addAction("refresh", async (item) => {
          let { name: name2 } = item.data;
          await sources_default.refresh(name2);
        }, { persist: true, reload: true });
        this.addAction("open", async (item) => {
          let { location } = item;
          if (location)
            await this.jumpTo(location);
        });
      }
      async loadItems(context) {
        let stats = sources_default.sourceStats();
        let filetype = await context.buffer.getOption("filetype");
        let map = workspace_default.env.disabledSources;
        let disables = map ? map[filetype] || [] : [];
        stats.sort((a, b) => {
          if (a.type != b.type)
            return a.type < b.type ? 1 : -1;
          return a.name > b.name ? -1 : 1;
        });
        return stats.map((stat) => {
          let prefix = stat.disabled ? " " : "*";
          if (disables && disables.includes(stat.name)) {
            prefix = "-";
          }
          let location;
          if (stat.filepath) {
            location = Location.create(URI.file(stat.filepath).toString(), Range.create(0, 0, 0, 0));
          }
          return {
            label: `${prefix} ${fixWidth(stat.name, 22)} ${fixWidth("[" + stat.shortcut + "]", 10)} ${fixWidth(stat.triggerCharacters.join(""), 10)} ${fixWidth(stat.priority.toString(), 3)} ${stat.filetypes.join(",")}`,
            location,
            data: { name: stat.name }
          };
        });
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocSourcesPrefix /\\v^./ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesName /\\v%3c\\S+/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesType /\\v%25v.*%36v/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesPriority /\\v%46v.*%50v/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesFileTypes /\\v\\S+$/ contained containedin=CocSourcesLine", true);
        nvim.command("highlight default link CocSourcesPrefix Special", true);
        nvim.command("highlight default link CocSourcesName Type", true);
        nvim.command("highlight default link CocSourcesPriority Number", true);
        nvim.command("highlight default link CocSourcesFileTypes Comment", true);
        nvim.command("highlight default link CocSourcesType Statement", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/symbols.ts
var import_path27, import_minimatch5, import_vscode_languageserver_protocol61, logger61, Symbols;
var init_symbols = __esm({
  "src/list/source/symbols.ts"() {
    import_path27 = __toModule(require("path"));
    import_minimatch5 = __toModule(require_minimatch());
    init_esm2();
    init_languages();
    init_workspace();
    init_location();
    init_convert();
    init_fs();
    init_fzy();
    import_vscode_languageserver_protocol61 = __toModule(require_main2());
    init_formatting();
    logger61 = require_logger2()("list-symbols");
    Symbols = class extends LocationList {
      constructor() {
        super(...arguments);
        this.interactive = true;
        this.description = "search workspace symbols";
        this.detail = "Symbols list is provided by server, it works on interactive mode only.";
        this.name = "symbols";
        this.options = [{
          name: "-k, -kind KIND",
          description: "Filter symbols by kind.",
          hasValue: true
        }];
      }
      async loadItems(context, token) {
        let { input } = context;
        let args = this.parseArguments(context.args);
        let filterKind = args.kind ? args.kind.toLowerCase() : "";
        if (!context.options.interactive) {
          throw new Error("Symbols only works on interactive mode");
        }
        let symbols = await languages_default.getWorkspaceSymbols(input, token);
        if (!symbols) {
          throw new Error("No workspace symbols provider registed");
        }
        let config = this.getConfig();
        let excludes = config.get("excludes", []);
        let items = [];
        for (let s of symbols) {
          let kind = getSymbolKind(s.kind);
          if (filterKind && kind.toLowerCase() != filterKind) {
            continue;
          }
          let file = URI.parse(s.location.uri).fsPath;
          if (isParentFolder(workspace_default.cwd, file)) {
            file = import_path27.default.relative(workspace_default.cwd, file);
          }
          if (excludes.some((p) => (0, import_minimatch5.default)(file, p))) {
            continue;
          }
          items.push({
            label: [s.name, `[${kind}]`, file],
            filterText: `${s.name}`,
            location: s.location,
            data: { original: s, kind: s.kind, file, score: score2(input, s.name) }
          });
        }
        items.sort((a, b) => {
          if (a.data.score != b.data.score) {
            return b.data.score - a.data.score;
          }
          if (a.data.kind != b.data.kind) {
            return a.data.kind - b.data.kind;
          }
          return a.data.file.length - b.data.file.length;
        });
        return formatListItems(this.alignColumns, items);
      }
      async resolveItem(item) {
        let s = item.data.original;
        if (!s)
          return null;
        let tokenSource = new import_vscode_languageserver_protocol61.CancellationTokenSource();
        let resolved = await languages_default.resolveWorkspaceSymbol(s, tokenSource.token);
        if (!resolved)
          return null;
        let kind = getSymbolKind(resolved.kind);
        let file = URI.parse(resolved.location.uri).fsPath;
        if (isParentFolder(workspace_default.cwd, file)) {
          file = import_path27.default.relative(workspace_default.cwd, file);
        }
        return {
          label: `${s.name} [${kind}]	${file}`,
          filterText: `${s.name}`,
          location: s.location
        };
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocSymbolsName /\\v^\\s*\\S+/ contained containedin=CocSymbolsLine", true);
        nvim.command("syntax match CocSymbolsKind /\\[\\w\\+\\]\\s*\\t/ contained containedin=CocSymbolsLine", true);
        nvim.command("syntax match CocSymbolsFile /\\S\\+$/ contained containedin=CocSymbolsLine", true);
        nvim.command("highlight default link CocSymbolsName Normal", true);
        nvim.command("highlight default link CocSymbolsKind Typedef", true);
        nvim.command("highlight default link CocSymbolsFile Comment", true);
        nvim.resumeNotification().catch((_e) => {
        });
      }
    };
  }
});

// src/list/manager.ts
var import_debounce8, import_vscode_languageserver_protocol62, logger62, mouseKeys, ListManager, manager_default3;
var init_manager3 = __esm({
  "src/list/manager.ts"() {
    import_debounce8 = __toModule(require_debounce());
    import_vscode_languageserver_protocol62 = __toModule(require_main2());
    init_events();
    init_extensions2();
    init_util();
    init_workspace();
    init_window();
    init_configuration4();
    init_mappings();
    init_prompt();
    init_session();
    init_commands();
    init_diagnostics();
    init_extensions();
    init_folders();
    init_links();
    init_lists();
    init_location();
    init_outline();
    init_services2();
    init_sources();
    init_symbols();
    logger62 = require_logger2()("list-manager");
    mouseKeys = ["<LeftMouse>", "<LeftDrag>", "<LeftRelease>", "<2-LeftMouse>"];
    ListManager = class {
      constructor() {
        this.plugTs = 0;
        this.sessionsMap = new Map();
        this.disposables = [];
        this.listMap = new Map();
      }
      init(nvim) {
        this.nvim = nvim;
        this.config = new ListConfiguration();
        this.prompt = new Prompt(nvim, this.config);
        this.mappings = new Mappings(this, nvim, this.config);
        let signText = this.config.get("selectedSignText", "*");
        nvim.command(`sign define CocSelected text=${signText} texthl=CocSelectedText linehl=CocSelectedLine`, true);
        events_default.on("InputChar", this.onInputChar, this, this.disposables);
        events_default.on("FocusGained", (0, import_debounce8.default)(async () => {
          let session = await this.getCurrentSession();
          if (session)
            this.prompt.drawPrompt();
        }, 100), null, this.disposables);
        let timer;
        events_default.on("WinEnter", (winid) => {
          let session = this.getSessionByWinid(winid);
          if (session)
            this.prompt.start(session.listOptions);
        }, null, this.disposables);
        events_default.on("WinLeave", (winid) => {
          let session = this.getSessionByWinid(winid);
          if (session)
            this.prompt.cancel();
        });
        this.disposables.push(import_vscode_languageserver_protocol62.Disposable.create(() => {
          if (timer)
            clearTimeout(timer);
        }));
        this.prompt.onDidChangeInput(() => {
          let { session } = this;
          if (!session)
            return;
          session.onInputChange();
          session.history.filter();
        });
        this.registerList(new LinksList(nvim));
        this.registerList(new LocationList(nvim));
        this.registerList(new Symbols(nvim));
        this.registerList(new Outline(nvim));
        this.registerList(new CommandsList(nvim));
        this.registerList(new ExtensionList(nvim));
        this.registerList(new DiagnosticsList(nvim));
        this.registerList(new SourcesList(nvim));
        this.registerList(new ServicesList(nvim));
        this.registerList(new LinksList2(nvim, this.listMap));
        this.registerList(new FoldList(nvim));
      }
      async start(args) {
        let res = this.parseArgs(args);
        if (!res)
          return;
        let { name: name2 } = res.list;
        let curr = this.sessionsMap.get(name2);
        if (curr)
          curr.dispose();
        this.prompt.start(res.options);
        let session = new ListSession(this.nvim, this.prompt, res.list, res.options, res.listArgs, this.config);
        this.sessionsMap.set(name2, session);
        this.lastSession = session;
        try {
          await session.start(args);
        } catch (e) {
          this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
          let msg = e instanceof Error ? e.message : e.toString();
          window_default.showMessage(`Error on "CocList ${name2}": ${msg}`, "error");
          logger62.error(e);
        }
      }
      getSessionByWinid(winid) {
        for (let session of this.sessionsMap.values()) {
          if (session && session.winid == winid) {
            this.lastSession = session;
            return session;
          }
        }
        return null;
      }
      async getCurrentSession() {
        let { id } = await this.nvim.window;
        for (let session of this.sessionsMap.values()) {
          if (session && session.winid == id) {
            this.lastSession = session;
            return session;
          }
        }
        return null;
      }
      async resume(name2) {
        var _a2;
        if (!name2) {
          await ((_a2 = this.session) == null ? void 0 : _a2.resume());
        } else {
          let session = this.sessionsMap.get(name2);
          if (!session) {
            window_default.showMessage(`Can't find exists ${name2} list`);
            return;
          }
          await session.resume();
        }
      }
      async doAction(name2) {
        let lastSession = this.lastSession;
        if (!lastSession)
          return;
        await lastSession.doAction(name2);
      }
      async first(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.first();
      }
      async last(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.last();
      }
      async previous(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.previous();
      }
      async next(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.next();
      }
      getSession(name2) {
        if (!name2)
          return this.session;
        return this.sessionsMap.get(name2);
      }
      async cancel(close = true) {
        this.prompt.cancel();
        if (!close)
          return;
        if (this.session)
          await this.session.hide();
      }
      reset() {
        this.prompt.cancel();
        this.lastSession = void 0;
        for (let session of this.sessionsMap.values()) {
          session.dispose();
        }
        this.sessionsMap.clear();
        this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
      }
      switchMatcher() {
        var _a2;
        (_a2 = this.session) == null ? void 0 : _a2.switchMatcher();
      }
      async togglePreview() {
        let { nvim } = this;
        let winid = await nvim.call("coc#list#get_preview", [0]);
        if (winid != -1) {
          let win = nvim.createWindow(winid);
          await win.close(true);
          await nvim.command("redraw");
        } else {
          await this.doAction("preview");
        }
      }
      async chooseAction() {
        let { lastSession } = this;
        if (lastSession)
          await lastSession.chooseAction();
      }
      parseArgs(args) {
        let options = [];
        let interactive = false;
        let autoPreview = false;
        let numberSelect = false;
        let noQuit = false;
        let first = false;
        let name2;
        let input = "";
        let matcher = "fuzzy";
        let position = "bottom";
        let listArgs = [];
        let listOptions = [];
        for (let arg of args) {
          if (!name2 && arg.startsWith("-")) {
            listOptions.push(arg);
          } else if (!name2) {
            if (!/^\w+$/.test(arg)) {
              window_default.showMessage(`Invalid list option: "${arg}"`, "error");
              return null;
            }
            name2 = arg;
          } else {
            listArgs.push(arg);
          }
        }
        name2 = name2 || "lists";
        let config = workspace_default.getConfiguration(`list.source.${name2}`);
        if (!listOptions.length && !listArgs.length)
          listOptions = config.get("defaultOptions", []);
        if (!listArgs.length)
          listArgs = config.get("defaultArgs", []);
        for (let opt of listOptions) {
          if (opt.startsWith("--input")) {
            input = opt.slice(8);
          } else if (opt == "--number-select" || opt == "-N") {
            numberSelect = true;
          } else if (opt == "--auto-preview" || opt == "-A") {
            autoPreview = true;
          } else if (opt == "--regex" || opt == "-R") {
            matcher = "regex";
          } else if (opt == "--strict" || opt == "-S") {
            matcher = "strict";
          } else if (opt == "--interactive" || opt == "-I") {
            interactive = true;
          } else if (opt == "--top") {
            position = "top";
          } else if (opt == "--tab") {
            position = "tab";
          } else if (opt == "--ignore-case" || opt == "--normal" || opt == "--no-sort") {
            options.push(opt.slice(2));
          } else if (opt == "--first") {
            first = true;
          } else if (opt == "--no-quit") {
            noQuit = true;
          } else {
            window_default.showMessage(`Invalid option "${opt}" of list`, "error");
            return null;
          }
        }
        let list2 = this.listMap.get(name2);
        if (!list2) {
          window_default.showMessage(`List ${name2} not found`, "error");
          return null;
        }
        if (interactive && !list2.interactive) {
          window_default.showMessage(`Interactive mode of "${name2}" list not supported`, "error");
          return null;
        }
        return {
          list: list2,
          listArgs,
          options: {
            numberSelect,
            autoPreview,
            noQuit,
            first,
            input,
            interactive,
            matcher,
            position,
            ignorecase: options.includes("ignore-case") ? true : false,
            mode: !options.includes("normal") ? "insert" : "normal",
            sort: !options.includes("no-sort") ? true : false
          }
        };
      }
      async onInputChar(session, ch, charmod) {
        if (session != "list")
          return;
        let { mode } = this.prompt;
        let now = Date.now();
        if (ch == "<plug>" || this.plugTs && now - this.plugTs < 20) {
          this.plugTs = now;
          return;
        }
        if (!ch)
          return;
        if (ch == "<esc>") {
          await this.cancel();
          return;
        }
        try {
          if (mode == "insert") {
            await this.onInsertInput(ch, charmod);
          } else {
            await this.onNormalInput(ch, charmod);
          }
        } catch (e) {
          window_default.showMessage(`Error on input ${ch}: ${e}`);
          logger62.error(e);
        }
      }
      async onInsertInput(ch, charmod) {
        let { session } = this;
        if (!session)
          return;
        if (mouseKeys.includes(ch)) {
          await this.onMouseEvent(ch);
          return;
        }
        let n = await session.doNumberSelect(ch);
        if (n)
          return;
        let done = await this.mappings.doInsertKeymap(ch);
        if (done || charmod)
          return;
        if (ch.startsWith("<") && ch.endsWith(">"))
          return;
        for (let s of ch) {
          let code = s.codePointAt(0);
          if (code == 65533)
            return;
          if (code < 32 || code >= 127 && code <= 159)
            return;
          await this.prompt.acceptCharacter(s);
        }
      }
      async onNormalInput(ch, _charmod) {
        if (mouseKeys.includes(ch)) {
          await this.onMouseEvent(ch);
          return;
        }
        let used = await this.mappings.doNormalKeymap(ch);
        if (!used)
          await this.feedkeys(ch);
      }
      onMouseEvent(key) {
        if (this.session)
          return this.session.onMouseEvent(key);
      }
      async feedkeys(key, remap = true) {
        let { nvim } = this;
        key = key.startsWith("<") && key.endsWith(">") ? `\\${key}` : key;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.call("eval", [`feedkeys("${key}", "${remap ? "i" : "in"}")`]);
        this.prompt.start();
      }
      async command(command) {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.command(command);
        this.prompt.start();
      }
      async normal(command, bang = true) {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.command(`normal${bang ? "!" : ""} ${command}`);
        this.prompt.start();
      }
      async call(fname) {
        if (this.session)
          return await this.session.call(fname);
      }
      get session() {
        return this.lastSession;
      }
      registerList(list2) {
        const { name: name2 } = list2;
        let exists = this.listMap.get(name2);
        if (this.listMap.has(name2)) {
          if (exists) {
            if (typeof exists.dispose == "function") {
              exists.dispose();
            }
            this.listMap.delete(name2);
          }
          window_default.showMessage(`list "${name2}" recreated.`);
        }
        this.listMap.set(name2, list2);
        let config = workspace_default.getConfiguration(`list.source.${name2}`);
        let defaultAction = config.get("defaultAction");
        if (defaultAction && list2.actions.find((o) => o.name == defaultAction)) {
          list2.defaultAction = defaultAction;
        }
        extensions_default.addSchemeProperty(`list.source.${name2}.defaultAction`, {
          type: "string",
          default: null,
          description: `Default default action of "${name2}" list.`
        });
        extensions_default.addSchemeProperty(`list.source.${name2}.defaultOptions`, {
          type: "array",
          default: list2.interactive ? ["--interactive"] : [],
          description: `Default list options of "${name2}" list, only used when both list option and argument are empty.`,
          uniqueItems: true,
          items: {
            type: "string",
            enum: [
              "--top",
              "--normal",
              "--no-sort",
              "--input",
              "--tab",
              "--strict",
              "--regex",
              "--ignore-case",
              "--number-select",
              "--interactive",
              "--auto-preview",
              "--first",
              "--no-quit"
            ]
          }
        });
        extensions_default.addSchemeProperty(`list.source.${name2}.defaultArgs`, {
          type: "array",
          default: [],
          description: `Default argument list of "${name2}" list, only used when list argument is empty.`,
          uniqueItems: true,
          items: { type: "string" }
        });
        return import_vscode_languageserver_protocol62.Disposable.create(() => {
          if (typeof list2.dispose == "function") {
            list2.dispose();
          }
          this.listMap.delete(name2);
        });
      }
      get names() {
        return Array.from(this.listMap.keys());
      }
      get descriptions() {
        let d = {};
        for (let name2 of this.listMap.keys()) {
          let list2 = this.listMap.get(name2);
          d[name2] = list2.description;
        }
        return d;
      }
      async loadItems(name2) {
        let args = [name2];
        let res = this.parseArgs(args);
        if (!res)
          return;
        let { list: list2, options, listArgs } = res;
        let source = new import_vscode_languageserver_protocol62.CancellationTokenSource();
        let token = source.token;
        let arr = await this.nvim.eval('[win_getid(),bufnr("%")]');
        let items = await list2.loadItems({
          options,
          args: listArgs,
          input: "",
          cwd: workspace_default.cwd,
          window: this.nvim.createWindow(arr[0]),
          buffer: this.nvim.createBuffer(arr[1]),
          listWindow: null
        }, token);
        return items;
      }
      toggleMode() {
        let lastSession = this.lastSession;
        if (lastSession)
          lastSession.toggleMode();
      }
      get isActivated() {
        var _a2;
        return ((_a2 = this.session) == null ? void 0 : _a2.winid) != null;
      }
      stop() {
        let lastSession = this.lastSession;
        if (lastSession)
          lastSession.stop();
      }
      dispose() {
        for (let session of this.sessionsMap.values()) {
          session.dispose();
        }
        this.sessionsMap.clear();
        if (this.config) {
          this.config.dispose();
        }
        this.lastSession = void 0;
        disposeAll(this.disposables);
      }
    };
    manager_default3 = new ListManager();
  }
});

// src/provider/index.ts
var init_provider = __esm({
  "src/provider/index.ts"() {
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BaseLanguageClient: () => BaseLanguageClient,
  BasicList: () => BasicList,
  Buffer: () => import_neovim.Buffer,
  CancellationToken: () => import_vscode_languageserver_protocol63.CancellationToken,
  CancellationTokenSource: () => import_vscode_languageserver_protocol63.CancellationTokenSource,
  ClientState: () => ClientState,
  CloseAction: () => CloseAction,
  CodeActionKind: () => import_vscode_languageserver_protocol63.CodeActionKind,
  CompletionItemKind: () => import_vscode_languageserver_protocol63.CompletionItemKind,
  CompletionTriggerKind: () => import_vscode_languageserver_protocol63.CompletionTriggerKind,
  ConfigurationTarget: () => ConfigurationTarget,
  Diagnostic: () => import_vscode_languageserver_protocol63.Diagnostic,
  DiagnosticSeverity: () => import_vscode_languageserver_protocol63.DiagnosticSeverity,
  DiagnosticTag: () => import_vscode_languageserver_protocol63.DiagnosticTag,
  Disposable: () => import_vscode_languageserver_protocol63.Disposable,
  Document: () => Document,
  DocumentHighlightKind: () => import_vscode_languageserver_protocol63.DocumentHighlightKind,
  Emitter: () => import_vscode_languageserver_protocol63.Emitter,
  ErrorAction: () => ErrorAction,
  Event: () => import_vscode_languageserver_protocol63.Event,
  ExtensionType: () => ExtensionType,
  FileChangeType: () => import_vscode_languageserver_protocol63.FileChangeType,
  FileSystemWatcher: () => FileSystemWatcher,
  FloatFactory: () => FloatFactory,
  Highligher: () => Highlighter,
  InsertTextFormat: () => import_vscode_languageserver_protocol63.InsertTextFormat,
  LanguageClient: () => LanguageClient,
  Location: () => import_vscode_languageserver_protocol63.Location,
  LocationLink: () => import_vscode_languageserver_protocol63.LocationLink,
  MarkupKind: () => import_vscode_languageserver_protocol63.MarkupKind,
  MessageLevel: () => MessageLevel,
  MessageTransports: () => MessageTransports,
  Mru: () => Mru,
  Mutex: () => Mutex,
  Neovim: () => import_neovim.Neovim,
  NotificationType: () => import_vscode_languageserver_protocol63.NotificationType,
  NotificationType0: () => import_vscode_languageserver_protocol63.NotificationType0,
  NullLogger: () => NullLogger,
  PatternType: () => PatternType,
  Position: () => import_vscode_languageserver_protocol63.Position,
  ProgressType: () => import_vscode_jsonrpc.ProgressType,
  ProposedFeatures: () => ProposedFeatures,
  Range: () => import_vscode_languageserver_protocol63.Range,
  RequestType: () => import_vscode_languageserver_protocol63.RequestType,
  RequestType0: () => import_vscode_languageserver_protocol63.RequestType0,
  RevealOutputChannelOn: () => RevealOutputChannelOn,
  ServiceStat: () => ServiceStat,
  SettingMonitor: () => SettingMonitor,
  SignatureHelpTriggerKind: () => import_vscode_languageserver_protocol63.SignatureHelpTriggerKind,
  SourceType: () => SourceType,
  State: () => State2,
  SymbolKind: () => import_vscode_languageserver_protocol63.SymbolKind,
  TextDocumentFeature: () => TextDocumentFeature,
  TextEdit: () => import_vscode_languageserver_protocol63.TextEdit,
  TransportKind: () => TransportKind,
  Uri: () => URI,
  Watchman: () => Watchman,
  Window: () => import_neovim.Window,
  ansiparse: () => ansiparse,
  commands: () => commands_default,
  concurrent: () => concurrent,
  diagnosticManager: () => manager_default,
  disposeAll: () => disposeAll,
  download: () => download,
  events: () => events_default,
  executable: () => executable,
  extensions: () => extensions_default,
  fetch: () => fetch,
  isRunning: () => isRunning,
  languages: () => languages_default,
  listManager: () => manager_default3,
  runCommand: () => runCommand,
  services: () => services_default,
  snippetManager: () => manager_default2,
  sources: () => sources_default,
  wait: () => wait,
  watchFile: () => watchFile,
  window: () => window_default,
  workspace: () => workspace_default
});
var import_neovim, import_vscode_languageserver_protocol63, import_vscode_jsonrpc;
var init_src = __esm({
  "src/index.ts"() {
    init_commands2();
    init_events();
    init_languages();
    init_document();
    init_mru();
    init_floatFactory();
    init_fetch();
    init_download();
    init_highligher();
    init_fileSystemWatcher();
    init_services();
    init_sources2();
    init_workspace();
    init_window();
    init_extensions2();
    init_manager3();
    init_manager4();
    init_basic();
    init_manager();
    init_ansiparse();
    init_watchman();
    init_mutex();
    init_esm2();
    import_neovim = __toModule(require_lib6());
    import_vscode_languageserver_protocol63 = __toModule(require_main2());
    import_vscode_jsonrpc = __toModule(require_main());
    init_types();
    init_language_client();
    init_provider();
    init_util();
  }
});

// src/util/factory.ts
function removedGlobalStub(name2) {
  return () => {
    throw new Error(`process.${name2}() is not allowed in extension sandbox`);
  };
}
function makeRequireFunction() {
  const req = (p) => {
    if (p === "coc.nvim") {
      return init_src(), src_exports;
    }
    return this.require(p);
  };
  req.resolve = (request2) => Module._resolveFilename(request2, this);
  req.main = process.mainModule;
  req.extensions = Module._extensions;
  req.cache = Module._cache;
  return req;
}
function compileInSandbox(sandbox) {
  return function(content, filename) {
    const require2 = makeRequireFunction.call(this);
    const dirname4 = path26.dirname(filename);
    const newContent = content.replace(/^\#\!.*/, "");
    const wrapper = Module.wrap(newContent);
    const compiledWrapper = vm.runInContext(wrapper, sandbox, { filename });
    const args = [this.exports, require2, this, filename, dirname4];
    return compiledWrapper.apply(this.exports, args);
  };
}
function createSandbox(filename, logger96) {
  const module2 = new Module(filename);
  module2.paths = Module._nodeModulePaths(filename);
  const sandbox = vm.createContext({
    module: module2,
    Buffer,
    console: {
      debug: (...args) => {
        logger96.debug.apply(logger96, args);
      },
      log: (...args) => {
        logger96.debug.apply(logger96, args);
      },
      error: (...args) => {
        logger96.error.apply(logger96, args);
      },
      info: (...args) => {
        logger96.info.apply(logger96, args);
      },
      warn: (...args) => {
        logger96.warn.apply(logger96, args);
      }
    }
  });
  defaults(sandbox, global);
  sandbox.Reflect = Reflect;
  sandbox.require = function sandboxRequire(p) {
    const oldCompile = Module.prototype._compile;
    Module.prototype._compile = compileInSandbox(sandbox);
    const moduleExports = sandbox.module.require(p);
    Module.prototype._compile = oldCompile;
    return moduleExports;
  };
  sandbox.process = new process.constructor();
  for (let key of Object.keys(process)) {
    sandbox.process[key] = process[key];
  }
  REMOVED_GLOBALS.forEach((name2) => {
    sandbox.process[name2] = removedGlobalStub(name2);
  });
  sandbox.process["chdir"] = () => {
  };
  sandbox.process.umask = (mask) => {
    if (typeof mask !== "undefined") {
      throw new Error("Cannot use process.umask() to change mask (read-only)");
    }
    return process.umask();
  };
  return sandbox;
}
function createExtension(id, filename, isEmpty = false) {
  if (isEmpty || !import_fs26.default.existsSync(filename))
    return {
      activate: () => {
      },
      deactivate: null
    };
  const sandbox = createSandbox(filename, createLogger(`extension:${id}`));
  delete Module._cache[require.resolve(filename)];
  const defaultImport = sandbox.require(filename);
  const activate = defaultImport && defaultImport.activate || defaultImport;
  if (typeof activate !== "function") {
    return { activate: () => {
    }, deactivate: null };
  }
  return {
    activate,
    deactivate: typeof defaultImport.deactivate === "function" ? defaultImport.deactivate : null
  };
}
var import_fs26, path26, vm, createLogger, logger63, Module, REMOVED_GLOBALS;
var init_factory = __esm({
  "src/util/factory.ts"() {
    import_fs26 = __toModule(require("fs"));
    path26 = __toModule(require("path"));
    vm = __toModule(require("vm"));
    init_lodash();
    createLogger = require_logger2();
    logger63 = createLogger("util-factoroy");
    Module = require("module");
    REMOVED_GLOBALS = [
      "reallyExit",
      "abort",
      "umask",
      "setuid",
      "setgid",
      "setgroups",
      "_fatalException",
      "exit",
      "kill"
    ];
  }
});

// src/extensions.ts
var import_debounce9, import_fs_extra9, import_isuri2, import_path28, import_semver3, import_vscode_languageserver_protocol64, import_which4, import_extensions7, createLogger2, logger64, Extensions, extensions_default;
var init_extensions2 = __esm({
  "src/extensions.ts"() {
    import_debounce9 = __toModule(require_debounce());
    init_main3();
    import_fs_extra9 = __toModule(require_lib5());
    import_isuri2 = __toModule(require_isuri());
    import_path28 = __toModule(require("path"));
    import_semver3 = __toModule(require_semver2());
    import_vscode_languageserver_protocol64 = __toModule(require_main2());
    init_esm2();
    import_which4 = __toModule(require_which());
    init_commands2();
    init_events();
    init_db();
    init_floatFactory();
    init_installBuffer();
    init_installer();
    init_memos();
    init_types();
    init_util();
    init_array();
    import_extensions7 = __toModule(require_extensions());
    init_factory();
    init_fs();
    init_is();
    init_watchman();
    init_workspace();
    init_window();
    createLogger2 = require_logger2();
    logger64 = createLogger2("extensions");
    Extensions = class {
      constructor() {
        this.extensions = new Map();
        this.disabled = new Set();
        this._onDidLoadExtension = new import_vscode_languageserver_protocol64.Emitter();
        this._onDidActiveExtension = new import_vscode_languageserver_protocol64.Emitter();
        this._onDidUnloadExtension = new import_vscode_languageserver_protocol64.Emitter();
        this._additionalSchemes = {};
        this.activated = false;
        this.disposables = [];
        this.ready = true;
        this.onDidLoadExtension = this._onDidLoadExtension.event;
        this.onDidActiveExtension = this._onDidActiveExtension.event;
        this.onDidUnloadExtension = this._onDidUnloadExtension.event;
        let folder = global.hasOwnProperty("__TEST__") ? import_path28.default.join(__dirname, "__tests__") : process.env.COC_DATA_HOME;
        let root = this.root = import_path28.default.join(folder, "extensions");
        if (!import_fs_extra9.default.existsSync(root)) {
          import_fs_extra9.default.mkdirpSync(root);
        }
        let jsonFile = import_path28.default.join(root, "package.json");
        if (!import_fs_extra9.default.existsSync(jsonFile)) {
          import_fs_extra9.default.writeFileSync(jsonFile, '{"dependencies":{}}', "utf8");
        }
        let filepath = import_path28.default.join(root, "db.json");
        this.db = new DB(filepath);
      }
      get outputChannel() {
        if (this._outputChannel)
          return this._outputChannel;
        this._outputChannel = window_default.createOutputChannel("extensions");
        return this._outputChannel;
      }
      async init() {
        let extensionObj = this.db.fetch("extension") || {};
        let keys = Object.keys(extensionObj);
        for (let key of keys) {
          if (extensionObj[key].disabled == true) {
            this.disabled.add(key);
          }
        }
        if (process.env.COC_NO_PLUGINS)
          return;
        let stats = await this.globalExtensionStats();
        let localStats = await this.localExtensionStats(stats.map((o) => o.id));
        stats = stats.concat(localStats);
        this.memos = new Memos(import_path28.default.resolve(this.root, "../memos.json"));
        stats.map((stat) => {
          let extensionType = stat.isLocal ? ExtensionType.Local : ExtensionType.Global;
          try {
            this.createExtension(stat.root, stat.packageJSON, extensionType);
          } catch (e) {
            logger64.error(`Error on create ${stat.root}:`, e);
          }
        });
        await this.loadFileExtensions();
        commands_default.register({
          id: "extensions.forceUpdateAll",
          execute: async () => {
            let arr = await this.cleanExtensions();
            logger64.info(`Force update extensions: ${arr}`);
            await this.installExtensions(arr);
          }
        }, false, "remove all global extensions and install them");
        workspace_default.onDidRuntimePathChange(async (paths) => {
          for (let p of paths) {
            if (p && this.checkDirectory(p) === true) {
              await this.loadExtension(p);
            }
          }
        }, null, this.disposables);
      }
      async activateExtensions() {
        this.activated = true;
        for (let item of this.extensions.values()) {
          let { id, packageJSON } = item.extension;
          await this.setupActiveEvents(id, packageJSON);
        }
        let floatFactory = new FloatFactory(workspace_default.nvim);
        events_default.on("CursorMoved", (0, import_debounce9.debounce)(async (bufnr) => {
          if (this.installBuffer && bufnr == this.installBuffer.bufnr) {
            let lnum = await workspace_default.nvim.call("line", ["."]);
            let msgs = this.installBuffer.getMessages(lnum - 1);
            let docs = msgs && msgs.length ? [{ content: msgs.join("\n"), filetype: "txt" }] : [];
            await floatFactory.show(docs, { modes: ["n"] });
          }
        }, 500));
        if (global.hasOwnProperty("__TEST__"))
          return;
        this.checkExtensions().logError();
        let config = workspace_default.getConfiguration("coc.preferences");
        let interval = config.get("extensionUpdateCheck", "never");
        let silent = config.get("silentAutoupdate", true);
        if (interval != "never") {
          let now = new Date();
          let day = new Date(now.getFullYear(), now.getMonth(), now.getDate() - (interval == "daily" ? 0 : 7));
          let ts = this.db.fetch("lastUpdate");
          if (ts && Number(ts) > day.getTime())
            return;
          this.outputChannel.appendLine("Start auto update...");
          this.updateExtensions(false, silent).logError();
        }
      }
      async updateExtensions(sync, silent = false) {
        if (!this.npm)
          return;
        let lockedList = await this.getLockedList();
        let stats = await this.globalExtensionStats();
        stats = stats.filter((o) => ![...lockedList, ...this.disabled].includes(o.id));
        this.db.push("lastUpdate", Date.now());
        if (silent) {
          window_default.showMessage("Updating extensions, checkout output:///extensions for details.", "more");
        }
        let installBuffer = this.installBuffer = new InstallBuffer(true, sync, silent ? this.outputChannel : void 0);
        installBuffer.setExtensions(stats.map((o) => o.id));
        await installBuffer.show(workspace_default.nvim);
        let createInstaller = createInstallerFactory(this.npm, this.modulesFolder);
        let fn = (stat) => {
          let { id } = stat;
          installBuffer.startProgress([id]);
          let url = stat.exotic ? stat.uri : null;
          let installer = createInstaller(id);
          installer.on("message", (msg, isProgress) => {
            installBuffer.addMessage(id, msg, isProgress);
          });
          return installer.update(url).then((directory) => {
            installBuffer.finishProgress(id, true);
            if (directory) {
              this.loadExtension(directory).logError();
            }
          }, (err) => {
            installBuffer.addMessage(id, err.message);
            installBuffer.finishProgress(id, false);
          });
        };
        await concurrent(stats, fn, silent ? 1 : 3);
      }
      async checkExtensions() {
        let { globalExtensions } = workspace_default.env;
        if (globalExtensions && globalExtensions.length) {
          let names = this.filterGlobalExtensions(globalExtensions);
          this.installExtensions(names).logError();
        }
      }
      get installer() {
        return createInstallerFactory(this.npm, this.modulesFolder);
      }
      async installExtensions(list2 = []) {
        let { npm } = this;
        if (!npm || !list2.length)
          return;
        list2 = distinct(list2);
        let installBuffer = this.installBuffer = new InstallBuffer();
        installBuffer.setExtensions(list2);
        await installBuffer.show(workspace_default.nvim);
        let createInstaller = createInstallerFactory(this.npm, this.modulesFolder);
        let fn = (key) => {
          installBuffer.startProgress([key]);
          let installer = createInstaller(key);
          installer.on("message", (msg, isProgress) => {
            installBuffer.addMessage(key, msg, isProgress);
          });
          return installer.install().then((name2) => {
            installBuffer.finishProgress(key, true);
            let directory = import_path28.default.join(this.modulesFolder, name2);
            this.loadExtension(directory).logError();
          }, (err) => {
            installBuffer.addMessage(key, err.message);
            installBuffer.finishProgress(key, false);
            logger64.error(`Error on install ${key}`, err);
          });
        };
        await concurrent(list2, fn);
      }
      getMissingExtensions() {
        let json = this.loadJson() || { dependencies: {} };
        let ids = [];
        for (let key of Object.keys(json.dependencies)) {
          let folder = import_path28.default.join(this.modulesFolder, key);
          if (!import_fs_extra9.default.existsSync(folder)) {
            let val = json.dependencies[key];
            if (val.startsWith("http")) {
              ids.push(val);
            } else {
              ids.push(key);
            }
          }
        }
        return ids;
      }
      get npm() {
        let npm = workspace_default.getConfiguration("npm").get("binPath", "npm");
        npm = workspace_default.expand(npm);
        for (let exe of [npm, "yarnpkg", "yarn", "npm"]) {
          try {
            let res = import_which4.default.sync(exe);
            return res;
          } catch (e) {
            continue;
          }
        }
        window_default.showMessage(`Can't find npm or yarn in your $PATH`, "error");
        return null;
      }
      get all() {
        return Array.from(this.extensions.values()).map((o) => o.extension).filter((o) => !this.isDisabled(o.id));
      }
      getExtension(id) {
        return this.extensions.get(id);
      }
      getExtensionState(id) {
        let disabled = this.isDisabled(id);
        if (disabled)
          return "disabled";
        let item = this.extensions.get(id);
        if (!item)
          return "unknown";
        let { extension } = item;
        return extension.isActive ? "activated" : "loaded";
      }
      async getExtensionStates() {
        let localStats = await this.localExtensionStats([]);
        let globalStats = await this.globalExtensionStats();
        return localStats.concat(globalStats.filter((o) => localStats.find((s) => s.id == o.id) == null));
      }
      async getLockedList() {
        let obj = await this.db.fetch("extension");
        obj = obj || {};
        return Object.keys(obj).filter((id) => obj[id].locked === true);
      }
      async toggleLock(id) {
        let key = `extension.${id}.locked`;
        let locked = await this.db.fetch(key);
        if (locked) {
          this.db.delete(key);
        } else {
          this.db.push(key, true);
        }
      }
      async toggleExtension(id) {
        let state = this.getExtensionState(id);
        if (state == null)
          return;
        if (state == "activated") {
          await this.deactivate(id);
        }
        let key = `extension.${id}.disabled`;
        this.db.push(key, state == "disabled" ? false : true);
        if (state != "disabled") {
          this.disabled.add(id);
          await this.unloadExtension(id);
        } else {
          this.disabled.delete(id);
          let folder = import_path28.default.join(this.modulesFolder, id);
          if (import_fs_extra9.default.existsSync(folder)) {
            await this.loadExtension(folder);
          }
        }
        await wait(200);
      }
      async reloadExtension(id) {
        let item = this.extensions.get(id);
        if (!item) {
          window_default.showMessage(`Extension ${id} not registered`, "error");
          return;
        }
        if (item.type == ExtensionType.Internal) {
          window_default.showMessage(`Can't reload internal extension "${item.id}"`, "warning");
          return;
        }
        if (item.type == ExtensionType.SingleFile) {
          await this.loadExtensionFile(item.filepath);
        } else if (item.directory) {
          await this.loadExtension(item.directory);
        } else {
          window_default.showMessage(`Can't reload extension ${item.id}`, "warning");
        }
      }
      async cleanExtensions() {
        let dir = this.modulesFolder;
        if (!import_fs_extra9.default.existsSync(dir))
          return [];
        let ids = this.globalExtensions;
        let res = [];
        for (let id of ids) {
          let directory = import_path28.default.join(dir, id);
          let stat = await import_fs_extra9.default.lstat(directory);
          if (!stat || stat && stat.isSymbolicLink())
            continue;
          await this.unloadExtension(id);
          await import_fs_extra9.default.remove(directory);
          res.push(id);
        }
        return res;
      }
      async uninstallExtension(ids) {
        try {
          if (!ids.length)
            return;
          let [globals2, filtered] = splitArray(ids, (id) => this.globalExtensions.includes(id));
          if (filtered.length) {
            window_default.showMessage(`Extensions ${filtered} not global extensions, can't uninstall!`, "warning");
          }
          let json = this.loadJson() || { dependencies: {} };
          for (let id of globals2) {
            await this.unloadExtension(id);
            delete json.dependencies[id];
            let folder = import_path28.default.join(this.modulesFolder, id);
            if (import_fs_extra9.default.existsSync(folder)) {
              await import_fs_extra9.default.remove(folder);
            }
          }
          const sortedObj = { dependencies: {} };
          Object.keys(json.dependencies).sort().forEach((k) => {
            sortedObj.dependencies[k] = json.dependencies[k];
          });
          let jsonFile = import_path28.default.join(this.root, "package.json");
          import_fs_extra9.default.writeFileSync(jsonFile, JSON.stringify(sortedObj, null, 2), { encoding: "utf8" });
          window_default.showMessage(`Removed: ${globals2.join(" ")}`);
        } catch (e) {
          window_default.showMessage(`Uninstall failed: ${e.message}`, "error");
        }
      }
      isDisabled(id) {
        return this.disabled.has(id);
      }
      has(id) {
        return this.extensions.has(id);
      }
      isActivated(id) {
        let item = this.extensions.get(id);
        if (item && item.extension.isActive) {
          return true;
        }
        return false;
      }
      async loadExtension(folder) {
        try {
          let parentFolder = import_path28.default.dirname(folder);
          let isLocal = import_path28.default.normalize(parentFolder) != import_path28.default.normalize(this.modulesFolder);
          let jsonFile = import_path28.default.join(folder, "package.json");
          let packageJSON = JSON.parse(import_fs_extra9.default.readFileSync(jsonFile, "utf8"));
          let { name: name2 } = packageJSON;
          if (this.isDisabled(name2))
            return false;
          await this.unloadExtension(name2);
          this.createExtension(folder, Object.freeze(packageJSON), isLocal ? ExtensionType.Local : ExtensionType.Global);
          return true;
        } catch (e) {
          window_default.showMessage(`Error on load extension from "${folder}": ${e.message}`, "error");
          logger64.error(`Error on load extension from ${folder}`, e);
          return false;
        }
      }
      async loadFileExtensions() {
        if (!process.env.COC_VIMCONFIG)
          return;
        let folder = import_path28.default.join(process.env.COC_VIMCONFIG, "coc-extensions");
        if (!import_fs_extra9.default.existsSync(folder))
          return;
        let files = await import_fs_extra9.default.readdir(folder);
        files = files.filter((f) => f.endsWith(".js"));
        for (let file of files) {
          await this.loadExtensionFile(import_path28.default.join(folder, file));
        }
      }
      loadedExtensions() {
        return Array.from(this.extensions.keys());
      }
      async watchExtension(id) {
        let item = this.extensions.get(id);
        if (!item) {
          window_default.showMessage(`extension ${id} not found`, "error");
          return;
        }
        if (id.startsWith("single-")) {
          window_default.showMessage(`watching ${item.filepath}`);
          this.disposables.push(watchFile(item.filepath, async () => {
            await this.loadExtensionFile(item.filepath);
            window_default.showMessage(`reloaded ${id}`);
          }));
        } else {
          let watchmanPath = workspace_default.getWatchmanPath();
          if (!watchmanPath) {
            window_default.showMessage("watchman not found", "error");
            return;
          }
          let client = await Watchman.createClient(watchmanPath, item.directory);
          if (!client) {
            window_default.showMessage(`Can't create watchman client, check output:///watchman`);
            return;
          }
          window_default.showMessage(`watching ${item.directory}`);
          this.disposables.push(client);
          client.subscribe("**/*.js", async () => {
            await this.reloadExtension(id);
            window_default.showMessage(`reloaded ${id}`);
          }).then((disposable) => {
            this.disposables.push(disposable);
          }, (e) => {
            logger64.error(e);
          });
        }
      }
      async loadExtensionFile(filepath) {
        let filename = import_path28.default.basename(filepath);
        let basename = import_path28.default.basename(filepath, ".js");
        let name2 = "single-" + basename;
        if (this.isDisabled(name2))
          return;
        let root = import_path28.default.dirname(filepath);
        let packageJSON = {
          name: name2,
          main: filename,
          engines: { coc: "^0.0.79" }
        };
        let confpath = import_path28.default.join(root, basename + ".json");
        let stat = await statAsync(confpath);
        if (stat && stat.isFile()) {
          let content = await readFile(confpath, "utf8");
          let obj = JSON.parse(content);
          if (obj) {
            let attrs = ["activationEvents", "contributes"];
            for (const attr of attrs) {
              if (obj[attr]) {
                packageJSON[attr] = obj[attr];
              }
            }
          }
        }
        await this.unloadExtension(name2);
        this.createExtension(root, packageJSON, ExtensionType.SingleFile);
      }
      async activate(id) {
        if (this.isDisabled(id)) {
          throw new Error(`Extension ${id} is disabled!`);
        }
        let item = this.extensions.get(id);
        if (!item) {
          throw new Error(`Extension ${id} not registered!`);
        }
        let { extension } = item;
        if (extension.isActive)
          return true;
        await Promise.resolve(extension.activate());
        if (extension.isActive) {
          this._onDidActiveExtension.fire(extension);
          return true;
        }
        return false;
      }
      async deactivate(id) {
        let item = this.extensions.get(id);
        if (!item)
          return false;
        await Promise.resolve(item.deactivate());
        return true;
      }
      async call(id, method, args) {
        let item = this.extensions.get(id);
        if (!item)
          throw new Error(`extension ${id} not registered`);
        let { extension } = item;
        if (!extension.isActive) {
          await this.activate(id);
        }
        let { exports: exports2 } = extension;
        if (!exports2 || !exports2.hasOwnProperty(method)) {
          throw new Error(`method ${method} not found on extension ${id}`);
        }
        return await Promise.resolve(exports2[method].apply(null, args));
      }
      getExtensionApi(id) {
        let item = this.extensions.get(id);
        if (!item)
          return null;
        let { extension } = item;
        return extension.isActive ? extension.exports : null;
      }
      registerExtension(extension, deactivate) {
        let { id, packageJSON } = extension;
        this.extensions.set(id, { id, type: ExtensionType.Internal, extension, deactivate, isLocal: true });
        let { contributes } = packageJSON;
        if (contributes) {
          let { configuration } = contributes;
          if (configuration && configuration.properties) {
            let { properties } = configuration;
            let props = {};
            for (let key of Object.keys(properties)) {
              let val = properties[key].default;
              if (val != null)
                props[key] = val;
            }
            workspace_default.configurations.extendsDefaults(props);
          }
        }
        this._onDidLoadExtension.fire(extension);
        this.setupActiveEvents(id, packageJSON).logError();
      }
      get globalExtensions() {
        let json = this.loadJson();
        if (!json || !json.dependencies)
          return [];
        return Object.keys(json.dependencies);
      }
      async globalExtensionStats() {
        let json = this.loadJson();
        if (!json || !json.dependencies)
          return [];
        let { modulesFolder } = this;
        let res = await Promise.all(Object.keys(json.dependencies).map((key) => new Promise(async (resolve3) => {
          try {
            let val = json.dependencies[key];
            let root = import_path28.default.join(modulesFolder, key);
            let res2 = this.checkDirectory(root);
            if (res2 instanceof Error) {
              window_default.showMessage(`Unable to load global extension at ${root}: ${res2.message}`, "error");
              logger64.error(`Error on load ${root}`, res2);
              return resolve3(null);
            }
            let content = await readFile(import_path28.default.join(root, "package.json"), "utf8");
            root = await import_fs_extra9.default.realpath(root);
            let obj = JSON.parse(content);
            let version2 = obj ? obj.version || "" : "";
            let description = obj ? obj.description || "" : "";
            let uri = import_isuri2.default.isValid(val) ? val : "";
            resolve3({
              id: key,
              isLocal: false,
              version: version2,
              description,
              exotic: /^https?:/.test(val),
              uri: uri.replace(/\.git(#master)?$/, ""),
              root,
              state: this.getExtensionState(key),
              packageJSON: Object.freeze(obj)
            });
          } catch (e) {
            logger64.error(e);
            resolve3(null);
          }
        })));
        return res.filter((info) => info != null);
      }
      async localExtensionStats(excludes) {
        let runtimepath = await workspace_default.nvim.eval("&runtimepath");
        let paths = runtimepath.split(",");
        let res = await Promise.all(paths.map((root) => new Promise(async (resolve3) => {
          try {
            let res2 = this.checkDirectory(root);
            if (res2 !== true)
              return resolve3(null);
            let jsonFile = import_path28.default.join(root, "package.json");
            let content = await readFile(jsonFile, "utf8");
            let obj = JSON.parse(content);
            let exist = this.extensions.get(obj.name);
            if (exist && !exist.isLocal) {
              logger64.info(`Extension "${obj.name}" in runtimepath already loaded.`);
              return resolve3(null);
            }
            if (excludes.includes(obj.name)) {
              logger64.info(`Skipped load vim plugin from "${root}", "${obj.name}" already global extension.`);
              return resolve3(null);
            }
            let version2 = obj ? obj.version || "" : "";
            let description = obj ? obj.description || "" : "";
            resolve3({
              id: obj.name,
              isLocal: true,
              version: version2,
              description,
              exotic: false,
              root,
              state: this.getExtensionState(obj.name),
              packageJSON: Object.freeze(obj)
            });
          } catch (e) {
            logger64.error(e);
            resolve3(null);
          }
        })));
        return res.filter((info) => info != null);
      }
      loadJson() {
        let { root } = this;
        let jsonFile = import_path28.default.join(root, "package.json");
        if (!import_fs_extra9.default.existsSync(jsonFile))
          return null;
        let errors = [];
        let content = import_fs_extra9.default.readFileSync(jsonFile, "utf8");
        let data = parse3(content, errors, { allowTrailingComma: true });
        if (errors && errors.length > 0) {
          window_default.showMessage(`Error on parse ${jsonFile}`, "error");
          workspace_default.nvim.call("coc#util#open_file", ["edit", jsonFile], true);
        }
        return data;
      }
      get schemes() {
        return this._additionalSchemes;
      }
      addSchemeProperty(key, def) {
        this._additionalSchemes[key] = def;
        workspace_default.configurations.extendsDefaults({ [key]: def.default });
      }
      async setupActiveEvents(id, packageJSON) {
        let { activationEvents } = packageJSON;
        if (!this.canActivate(id))
          return;
        if (!activationEvents || Array.isArray(activationEvents) && activationEvents.includes("*")) {
          await this.activate(id).catch((e) => {
            window_default.showMessage(`Error on activate extension ${id}: ${e.message}`);
            this.outputChannel.appendLine(`Error on activate extension ${id}.
${e.message}
 ${e.stack}`);
          });
          return;
        }
        let disposables = [];
        let active = () => {
          disposeAll(disposables);
          return new Promise((resolve3) => {
            if (!this.canActivate(id)) {
              this.outputChannel.appendLine(`Extension ${id} is disabled or not loaded.`);
              return resolve3();
            }
            let timer = setTimeout(() => {
              this.outputChannel.appendLine(`Extension ${id} activate cost more than 1s`);
              resolve3();
            }, 1e3);
            this.activate(id).then(() => {
              clearTimeout(timer);
              resolve3();
            }, (e) => {
              clearTimeout(timer);
              window_default.showMessage(`Error on activate extension ${id}: ${e.message}`);
              this.outputChannel.appendLine(`Error on activate extension ${id}:${e.message}
 ${e.stack}`);
              resolve3();
            });
          });
        };
        for (let eventName of activationEvents) {
          let parts = eventName.split(":");
          let ev = parts[0];
          if (ev == "onLanguage") {
            if (workspace_default.filetypes.has(parts[1])) {
              await active();
              return;
            }
            workspace_default.onDidOpenTextDocument((document2) => {
              if (document2.languageId == parts[1]) {
                void active();
              }
            }, null, disposables);
          } else if (ev == "onCommand") {
            commands_default.onCommandList.push(parts[1]);
            events_default.on("Command", async (command) => {
              if (command == parts[1]) {
                await active();
                await wait(500);
              }
            }, null, disposables);
          } else if (ev == "workspaceContains") {
            let check = async () => {
              let folders = workspace_default.workspaceFolders.map((o) => URI.parse(o.uri).fsPath);
              for (let folder of folders) {
                if (inDirectory(folder, parts[1].split(/\s+/))) {
                  await active();
                  return true;
                }
              }
            };
            let res = await check();
            if (res)
              return;
            workspace_default.onDidChangeWorkspaceFolders(check, null, disposables);
          } else if (ev == "onFileSystem") {
            for (let doc of workspace_default.documents) {
              let u = URI.parse(doc.uri);
              if (u.scheme == parts[1]) {
                await active();
                return;
              }
            }
            workspace_default.onDidOpenTextDocument((document2) => {
              let u = URI.parse(document2.uri);
              if (u.scheme == parts[1]) {
                void active();
              }
            }, null, disposables);
          } else {
            window_default.showMessage(`Unsupported event ${eventName} of ${id}`, "error");
          }
        }
      }
      createExtension(root, packageJSON, type) {
        let id = packageJSON.name;
        let isActive = false;
        let exports2 = null;
        let filename = import_path28.default.join(root, packageJSON.main || "index.js");
        let ext;
        let subscriptions = [];
        let extension = {
          activate: async () => {
            if (isActive)
              return exports2;
            let context = {
              subscriptions,
              extensionPath: root,
              globalState: this.memos.createMemento(`${id}|global`),
              workspaceState: this.memos.createMemento(`${id}|${workspace_default.rootPath}`),
              asAbsolutePath: (relativePath) => import_path28.default.join(root, relativePath),
              storagePath: import_path28.default.join(this.root, `${id}-data`),
              logger: createLogger2(id)
            };
            isActive = true;
            if (!ext) {
              try {
                let isEmpty = !(packageJSON.engines || {}).hasOwnProperty("coc");
                ext = createExtension(id, filename, isEmpty);
              } catch (e) {
                logger64.error(`Error on createExtension ${id} from ${filename}`, e);
                return;
              }
            }
            try {
              exports2 = await Promise.resolve(ext.activate(context));
              logger64.debug("activate:", id);
            } catch (e) {
              isActive = false;
              logger64.error(`Error on active extension ${id}: ${e.stack}`, e);
            }
            return exports2;
          }
        };
        Object.defineProperties(extension, {
          id: {
            get: () => id,
            enumerable: true
          },
          packageJSON: {
            get: () => packageJSON,
            enumerable: true
          },
          extensionPath: {
            get: () => root,
            enumerable: true
          },
          isActive: {
            get: () => isActive,
            enumerable: true
          },
          exports: {
            get: () => exports2,
            enumerable: true
          }
        });
        this.extensions.set(id, {
          id,
          type,
          isLocal: type == ExtensionType.Local,
          extension,
          directory: root,
          filepath: filename,
          deactivate: () => {
            if (!isActive)
              return;
            isActive = false;
            disposeAll(subscriptions);
            subscriptions.splice(0, subscriptions.length);
            subscriptions = [];
            if (ext && ext.deactivate) {
              try {
                return Promise.resolve(ext.deactivate()).catch((e) => {
                  logger64.error(`Error on ${id} deactivate: `, e);
                });
              } catch (e) {
                logger64.error(`Error on ${id} deactivate: `, e);
              }
            }
          }
        });
        let { contributes } = packageJSON;
        if (contributes) {
          let { configuration, rootPatterns, commands } = contributes;
          if (configuration && configuration.properties) {
            let { properties } = configuration;
            let props = {};
            for (let key of Object.keys(properties)) {
              let val = properties[key].default;
              if (val != null)
                props[key] = val;
            }
            workspace_default.configurations.extendsDefaults(props);
          }
          if (rootPatterns && rootPatterns.length) {
            for (let item of rootPatterns) {
              workspace_default.addRootPattern(item.filetype, item.patterns);
            }
          }
          if (commands && commands.length) {
            for (let cmd of commands) {
              commands_default.titles.set(cmd.command, cmd.title);
            }
          }
        }
        this._onDidLoadExtension.fire(extension);
        if (this.activated) {
          this.setupActiveEvents(id, packageJSON).logError();
        }
      }
      filterGlobalExtensions(names) {
        let map = new Map();
        names.forEach((def) => {
          let name2 = this.getExtensionName(def);
          if (name2)
            map.set(name2, def);
        });
        let json = this.loadJson();
        let urls = [];
        let exists = [];
        if (json && json.dependencies) {
          for (let key of Object.keys(json.dependencies)) {
            let val = json.dependencies[key];
            if (typeof val !== "string")
              continue;
            if (import_fs_extra9.default.existsSync(import_path28.default.join(this.modulesFolder, key, "package.json"))) {
              exists.push(key);
              if (/^https?:/.test(val)) {
                urls.push(val);
              }
            }
          }
        }
        for (let name2 of map.keys()) {
          if (this.disabled.has(name2) || this.extensions.has(name2)) {
            map.delete(name2);
            continue;
          }
          if (/^https?:/.test(name2) && urls.some((url) => url.startsWith(name2)) || exists.includes(name2)) {
            map.delete(name2);
          }
        }
        return Array.from(map.values());
      }
      getExtensionName(def) {
        if (/^https?:/.test(def))
          return def;
        if (!def.includes("@"))
          return def;
        return def.replace(/@[\d.]+$/, "");
      }
      get modulesFolder() {
        return import_path28.default.join(this.root, global.hasOwnProperty("__TEST__") ? "" : "node_modules");
      }
      canActivate(id) {
        return !this.disabled.has(id) && this.extensions.has(id);
      }
      async unloadExtension(id) {
        let item = this.extensions.get(id);
        if (item) {
          await this.deactivate(id);
          this.extensions.delete(id);
          this._onDidUnloadExtension.fire(id);
        }
      }
      checkDirectory(folder) {
        try {
          let jsonFile = import_path28.default.join(folder, "package.json");
          if (!import_fs_extra9.default.existsSync(jsonFile))
            throw new Error("package.json not found");
          let packageJSON = JSON.parse(import_fs_extra9.default.readFileSync(jsonFile, "utf8"));
          let { name: name2, engines, main } = packageJSON;
          if (!name2 || !engines)
            throw new Error(`can't find name & engines in package.json`);
          if (!engines || !objectLiteral(engines)) {
            throw new Error(`invalid engines in ${jsonFile}`);
          }
          if (main && !import_fs_extra9.default.existsSync(import_path28.default.join(folder, main))) {
            throw new Error(`main file ${main} not found, you may need to build the project.`);
          }
          let keys = Object.keys(engines);
          if (!keys.includes("coc") && !keys.includes("vscode")) {
            throw new Error(`Engines in package.json doesn't have coc or vscode`);
          }
          if (keys.includes("coc")) {
            let required = engines["coc"].replace(/^\^/, ">=");
            if (!import_semver3.default.satisfies(workspace_default.version, required)) {
              throw new Error(`Please update coc.nvim, ${packageJSON.name} requires coc.nvim ${engines["coc"]}`);
            }
          }
          return true;
        } catch (e) {
          return e;
        }
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
    extensions_default = new Extensions();
  }
});

// src/model/source.ts
var logger65, Source;
var init_source = __esm({
  "src/model/source.ts"() {
    init_types();
    init_string();
    init_workspace();
    logger65 = require_logger2()("model-source");
    Source = class {
      constructor(option) {
        this._disabled = false;
        this.nvim = workspace_default.nvim;
        this.name = option.name;
        this.filepath = option.filepath || "";
        this.sourceType = option.sourceType || SourceType.Native;
        this.isSnippet = !!option.isSnippet;
        this.defaults = option;
      }
      get priority() {
        return this.getConfig("priority", 1);
      }
      get triggerOnly() {
        let triggerOnly = this.defaults["triggerOnly"];
        if (typeof triggerOnly == "boolean")
          return triggerOnly;
        if (!this.triggerCharacters && !this.triggerPatterns)
          return false;
        return Array.isArray(this.triggerPatterns) && this.triggerPatterns.length != 0;
      }
      get triggerCharacters() {
        return this.getConfig("triggerCharacters", null);
      }
      get optionalFns() {
        return this.defaults["optionalFns"] || [];
      }
      get triggerPatterns() {
        let patterns = this.getConfig("triggerPatterns", null);
        if (!patterns || patterns.length == 0)
          return null;
        return patterns.map((s) => typeof s === "string" ? new RegExp(s + "$") : s);
      }
      get shortcut() {
        let shortcut = this.getConfig("shortcut", "");
        return shortcut ? shortcut : this.name.slice(0, 3);
      }
      get enable() {
        if (this._disabled)
          return false;
        return this.getConfig("enable", true);
      }
      get filetypes() {
        return this.getConfig("filetypes", null);
      }
      get disableSyntaxes() {
        return this.getConfig("disableSyntaxes", []);
      }
      getConfig(key, defaultValue) {
        let config = workspace_default.getConfiguration(`coc.source.${this.name}`);
        defaultValue = this.defaults.hasOwnProperty(key) ? this.defaults[key] : defaultValue;
        return config.get(key, defaultValue);
      }
      toggle() {
        this._disabled = !this._disabled;
      }
      get firstMatch() {
        return this.getConfig("firstMatch", true);
      }
      get menu() {
        let { shortcut } = this;
        return shortcut ? `[${shortcut}]` : "";
      }
      filterWords(words, opt) {
        let { firstMatch } = this;
        let res = [];
        let { input } = opt;
        let cword = opt.word;
        if (!input.length)
          return [];
        let cFirst = input[0];
        for (let word of words) {
          if (!word || word.length < 3)
            continue;
          if (firstMatch && cFirst != word[0])
            continue;
          if (!firstMatch && cFirst.toLowerCase() != word[0].toLowerCase())
            continue;
          if (word == cword || word == input)
            continue;
          res.push(word);
        }
        return res;
      }
      fixStartcol(opt, valids) {
        let { col, input, line, bufnr } = opt;
        let start = byteSlice(line, 0, col);
        let document2 = workspace_default.getDocument(bufnr);
        if (!document2)
          return col;
        let { chars } = document2;
        for (let i = start.length - 1; i >= 0; i--) {
          let c = start[i];
          if (!chars.isKeywordChar(c) && !valids.includes(c)) {
            break;
          }
          input = `${c}${input}`;
          col = col - 1;
        }
        opt.col = col;
        opt.input = input;
        return col;
      }
      async shouldComplete(opt) {
        let { disableSyntaxes } = this;
        if (opt.synname && disableSyntaxes && disableSyntaxes.length) {
          let synname = (opt.synname || "").toLowerCase();
          if (disableSyntaxes.findIndex((s) => synname.includes(s.toLowerCase())) !== -1) {
            return false;
          }
        }
        let fn = this.defaults["shouldComplete"];
        if (fn)
          return await Promise.resolve(fn.call(this, opt));
        return true;
      }
      async refresh() {
        let fn = this.defaults["refresh"];
        if (fn)
          await Promise.resolve(fn.call(this));
      }
      async onCompleteDone(item, opt) {
        let fn = this.defaults["onCompleteDone"];
        if (fn)
          await Promise.resolve(fn.call(this, item, opt));
      }
      async doComplete(opt, token) {
        let fn = this.defaults["doComplete"];
        if (fn)
          return await Promise.resolve(fn.call(this, opt, token));
        return null;
      }
    };
  }
});

// src/model/source-vim.ts
var logger66, VimSource;
var init_source_vim = __esm({
  "src/model/source-vim.ts"() {
    init_fuzzy();
    init_string();
    init_workspace();
    init_window();
    init_source();
    logger66 = require_logger2()("model-source-vim");
    VimSource = class extends Source {
      async callOptinalFunc(fname, args) {
        let exists = this.optionalFns.includes(fname);
        if (!exists)
          return null;
        let name2 = `coc#source#${this.name}#${fname}`;
        let res;
        try {
          res = await this.nvim.call(name2, args);
        } catch (e) {
          window_default.showMessage(`Vim error from source ${this.name}: ${e.message}`, "error");
          return null;
        }
        return res;
      }
      async shouldComplete(opt) {
        let shouldRun = await super.shouldComplete(opt);
        if (!shouldRun)
          return false;
        if (!this.optionalFns.includes("should_complete"))
          return true;
        let res = await this.callOptinalFunc("should_complete", [opt]);
        return !!res;
      }
      async refresh() {
        await this.callOptinalFunc("refresh", []);
      }
      async onCompleteDone(item, opt) {
        await super.onCompleteDone(item, opt);
        if (!this.optionalFns.includes("on_complete"))
          return;
        await this.callOptinalFunc("on_complete", [item]);
      }
      onEnter(bufnr) {
        if (!this.optionalFns.includes("on_enter"))
          return;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return;
        let { filetypes } = this;
        if (filetypes && !filetypes.includes(doc.filetype))
          return;
        this.callOptinalFunc("on_enter", [{
          bufnr,
          uri: doc.uri,
          languageId: doc.filetype
        }]).logError();
      }
      async doComplete(opt, token) {
        let { col, input, line, colnr } = opt;
        let startcol = await this.callOptinalFunc("get_startcol", [opt]);
        if (token.isCancellationRequested)
          return;
        if (startcol) {
          if (startcol < 0)
            return null;
          startcol = Number(startcol);
          if (isNaN(startcol) || startcol < 0)
            startcol = col;
          if (startcol !== col) {
            input = byteSlice(line, startcol, colnr - 1);
            opt = Object.assign({}, opt, {
              col: startcol,
              changed: col - startcol,
              input
            });
          }
        }
        let items = await this.nvim.callAsync("coc#util#do_complete", [this.name, opt]);
        if (!items || items.length == 0 || token.isCancellationRequested)
          return null;
        if (this.firstMatch && input.length) {
          let ch = input[0];
          items = items.filter((item) => {
            let cfirst = item.filterText ? item.filterText[0] : item.word[0];
            return fuzzyChar(ch, cfirst);
          });
        }
        items = items.map((item) => {
          if (typeof item == "string") {
            return { word: item, menu: this.menu, isSnippet: this.isSnippet };
          }
          let menu = item.menu ? item.menu + " " : "";
          item.menu = `${menu}${this.menu}`;
          item.isSnippet = this.isSnippet;
          delete item.user_data;
          return item;
        });
        let res = { items };
        if (startcol)
          res.startcol = startcol;
        return res;
      }
    };
  }
});

// src/source/around.ts
var around_exports = {};
__export(around_exports, {
  default: () => Around,
  regist: () => regist
});
function regist(sourceMap) {
  sourceMap.set("around", new Around());
  return import_vscode_languageserver_protocol65.Disposable.create(() => {
    sourceMap.delete("around");
  });
}
var import_vscode_languageserver_protocol65, logger67, Around;
var init_around = __esm({
  "src/source/around.ts"() {
    import_vscode_languageserver_protocol65 = __toModule(require_main2());
    init_source();
    init_workspace();
    logger67 = require_logger2()("source-around");
    Around = class extends Source {
      constructor() {
        super({
          name: "around",
          filepath: __filename
        });
      }
      doComplete(opt) {
        let { bufnr, input } = opt;
        if (input.length === 0)
          return null;
        let document2 = workspace_default.getDocument(bufnr);
        if (!document2)
          return null;
        let words = document2.words;
        let moreWords = document2.getMoreWords();
        words.push(...moreWords);
        words = this.filterWords(words, opt);
        return Promise.resolve({
          items: words.map((word) => ({
            word,
            menu: this.menu
          }))
        });
      }
    };
  }
});

// src/source/buffer.ts
var buffer_exports = {};
__export(buffer_exports, {
  default: () => Buffer3,
  regist: () => regist2
});
function regist2(sourceMap) {
  sourceMap.set("buffer", new Buffer3());
  return import_vscode_languageserver_protocol66.Disposable.create(() => {
    sourceMap.delete("buffer");
  });
}
var import_vscode_languageserver_protocol66, logger68, Buffer3;
var init_buffer2 = __esm({
  "src/source/buffer.ts"() {
    import_vscode_languageserver_protocol66 = __toModule(require_main2());
    init_source();
    init_workspace();
    logger68 = require_logger2()("source-buffer");
    Buffer3 = class extends Source {
      constructor() {
        super({
          name: "buffer",
          filepath: __filename
        });
      }
      get ignoreGitignore() {
        return this.getConfig("ignoreGitignore", true);
      }
      getWords(bufnr) {
        let { ignoreGitignore } = this;
        let words = [];
        workspace_default.documents.forEach((document2) => {
          if (document2.bufnr == bufnr)
            return;
          if (ignoreGitignore && document2.isIgnored)
            return;
          for (let word of document2.words) {
            if (!words.includes(word)) {
              words.push(word);
            }
          }
        });
        return words;
      }
      doComplete(opt) {
        let { bufnr, input } = opt;
        if (input.length == 0)
          return null;
        let words = this.getWords(bufnr);
        words = this.filterWords(words, opt);
        return Promise.resolve({
          items: words.map((word) => ({
            word,
            menu: this.menu
          }))
        });
      }
    };
  }
});

// src/source/file.ts
var file_exports = {};
__export(file_exports, {
  default: () => File,
  regist: () => regist3
});
function regist3(sourceMap) {
  sourceMap.set("file", new File());
  return import_vscode_languageserver_protocol67.Disposable.create(() => {
    sourceMap.delete("file");
  });
}
var import_fs28, import_minimatch6, import_path29, import_util36, import_vscode_languageserver_protocol67, logger69, pathRe, File;
var init_file = __esm({
  "src/source/file.ts"() {
    import_fs28 = __toModule(require("fs"));
    import_minimatch6 = __toModule(require_minimatch());
    import_path29 = __toModule(require("path"));
    import_util36 = __toModule(require("util"));
    import_vscode_languageserver_protocol67 = __toModule(require_main2());
    init_source();
    init_fs();
    init_string();
    init_workspace();
    logger69 = require_logger2()("source-file");
    pathRe = /(?:\.{0,2}|~|\$HOME|([\w]+)|)\/(?:[\w.@()-]+\/)*(?:[\w.@()-])*$/;
    File = class extends Source {
      constructor() {
        super({
          name: "file",
          filepath: __filename
        });
      }
      resolveEnvVariables(str) {
        let replaced = str;
        replaced = replaced.replace(/%([^%]+)%/g, (_, n) => process.env[n]);
        replaced = replaced.replace(/\$([A-Z_]+[A-Z0-9_]*)|\${([A-Z0-9_]*)}/gi, (_, a, b) => process.env[a || b]);
        return replaced;
      }
      getPathOption(opt) {
        let { line, colnr } = opt;
        let part = byteSlice(line, 0, colnr - 1);
        part = this.resolveEnvVariables(part);
        if (!part || part.endsWith("//"))
          return null;
        let ms = part.match(pathRe);
        if (ms && ms.length) {
          const pathstr = workspace_default.expand(ms[0]);
          let input = ms[0].match(/[^/]*$/)[0];
          return { pathstr, part: ms[1], startcol: colnr - input.length - 1, input };
        }
        return null;
      }
      async getFileItem(root, filename) {
        let f = import_path29.default.join(root, filename);
        let stat = await statAsync(f);
        if (stat) {
          let abbr = stat.isDirectory() ? filename + "/" : filename;
          let word = filename;
          return { word, abbr };
        }
        return null;
      }
      filterFiles(files) {
        let ignoreHidden = this.getConfig("ignoreHidden", true);
        let ignorePatterns = this.getConfig("ignorePatterns", []);
        return files.filter((f) => {
          if (f == null)
            return false;
          if (ignoreHidden && f.startsWith("."))
            return false;
          for (let p of ignorePatterns) {
            if ((0, import_minimatch6.default)(f, p, { dot: true }))
              return false;
          }
          return true;
        });
      }
      async getItemsFromRoot(pathstr, root) {
        let res = [];
        let part = pathstr.endsWith("/") ? pathstr : import_path29.default.dirname(pathstr);
        let dir = import_path29.default.isAbsolute(pathstr) ? part : import_path29.default.join(root, part);
        try {
          let stat = await statAsync(dir);
          if (stat && stat.isDirectory()) {
            let files = await import_util36.default.promisify(import_fs28.default.readdir)(dir);
            files = this.filterFiles(files);
            let items = await Promise.all(files.map((filename) => this.getFileItem(dir, filename)));
            res = res.concat(items);
          }
          res = res.filter((item) => item != null);
          return res;
        } catch (e) {
          logger69.error(`Error on list files:`, e);
          return res;
        }
      }
      get trimSameExts() {
        return this.getConfig("trimSameExts", []);
      }
      async doComplete(opt) {
        let { col, filepath } = opt;
        let option = this.getPathOption(opt);
        if (!option)
          return null;
        let { pathstr, part, startcol, input } = option;
        if (startcol < opt.col)
          return null;
        let startPart = opt.col == startcol ? "" : byteSlice(opt.line, opt.col, startcol);
        let dirname4 = import_path29.default.dirname(filepath);
        let ext = import_path29.default.extname(import_path29.default.basename(filepath));
        let cwd = await this.nvim.call("getcwd", []);
        let root;
        if (pathstr.startsWith(".")) {
          root = filepath ? import_path29.default.dirname(filepath) : cwd;
        } else if (pathstr.startsWith("/")) {
          root = pathstr.endsWith("/") ? pathstr : import_path29.default.dirname(pathstr);
        } else if (part) {
          if (import_fs28.default.existsSync(import_path29.default.join(dirname4, part))) {
            root = dirname4;
          } else if (import_fs28.default.existsSync(import_path29.default.join(cwd, part))) {
            root = cwd;
          }
        } else {
          root = cwd;
        }
        if (!root)
          return null;
        let items = await this.getItemsFromRoot(pathstr, root);
        let trimExt = this.trimSameExts.includes(ext);
        let first = input[0];
        if (first && col == startcol)
          items = items.filter((o) => o.word[0] === first);
        return {
          items: items.map((item) => {
            let ex = import_path29.default.extname(item.word);
            item.word = trimExt && ex === ext ? item.word.replace(ext, "") : item.word;
            return {
              word: `${startPart}${item.word}`,
              abbr: `${startPart}${item.abbr}`,
              menu: this.menu
            };
          })
        };
      }
    };
  }
});

// src/sources.ts
var import_fast_diff3, import_fs30, import_path30, import_util37, import_vscode_languageserver_protocol68, logger70, Sources, sources_default;
var init_sources2 = __esm({
  "src/sources.ts"() {
    import_fast_diff3 = __toModule(require_diff2());
    import_fs30 = __toModule(require("fs"));
    import_path30 = __toModule(require("path"));
    import_util37 = __toModule(require("util"));
    import_vscode_languageserver_protocol68 = __toModule(require_main2());
    init_events();
    init_extensions2();
    init_source();
    init_source_vim();
    init_types();
    init_util();
    init_fs();
    init_match();
    init_workspace();
    init_window();
    init_string();
    logger70 = require_logger2()("sources");
    Sources = class {
      constructor() {
        this.sourceMap = new Map();
        this.disposables = [];
        this.remoteSourcePaths = [];
      }
      get nvim() {
        return workspace_default.nvim;
      }
      createNativeSources() {
        try {
          this.disposables.push((init_around(), around_exports).regist(this.sourceMap));
          this.disposables.push((init_buffer2(), buffer_exports).regist(this.sourceMap));
          this.disposables.push((init_file(), file_exports).regist(this.sourceMap));
        } catch (e) {
          console.error("Create source error:" + e.message);
        }
      }
      async createVimSourceExtension(nvim, filepath) {
        let name2 = import_path30.default.basename(filepath, ".vim");
        try {
          await nvim.command(`source ${filepath}`);
          let fns = await nvim.call("coc#util#remote_fns", name2);
          for (let fn of ["init", "complete"]) {
            if (!fns.includes(fn)) {
              window_default.showMessage(`${fn} not found for source ${name2}`, "error");
              return null;
            }
          }
          let props = await nvim.call(`coc#source#${name2}#init`, []);
          let packageJSON = {
            name: `coc-source-${name2}`,
            engines: {
              coc: ">= 0.0.1"
            },
            activationEvents: props.filetypes ? props.filetypes.map((f) => `onLanguage:${f}`) : ["*"],
            contributes: {
              configuration: {
                properties: {
                  [`coc.source.${name2}.enable`]: {
                    type: "boolean",
                    default: true
                  },
                  [`coc.source.${name2}.firstMatch`]: {
                    type: "boolean",
                    default: !!props.firstMatch
                  },
                  [`coc.source.${name2}.triggerCharacters`]: {
                    type: "number",
                    default: props.triggerCharacters || []
                  },
                  [`coc.source.${name2}.priority`]: {
                    type: "number",
                    default: props.priority || 9
                  },
                  [`coc.source.${name2}.shortcut`]: {
                    type: "string",
                    default: props.shortcut || name2.slice(0, 3).toUpperCase(),
                    description: "Shortcut text shown in complete menu."
                  },
                  [`coc.source.${name2}.disableSyntaxes`]: {
                    type: "array",
                    default: [],
                    items: {
                      type: "string"
                    }
                  },
                  [`coc.source.${name2}.filetypes`]: {
                    type: "array",
                    default: props.filetypes || null,
                    description: "Enabled filetypes.",
                    items: {
                      type: "string"
                    }
                  }
                }
              }
            }
          };
          let source = new VimSource({
            name: name2,
            filepath,
            sourceType: SourceType.Remote,
            optionalFns: fns.filter((n) => !["init", "complete"].includes(n))
          });
          let isActive = false;
          let extension = {
            id: packageJSON.name,
            packageJSON,
            exports: void 0,
            extensionPath: filepath,
            activate: () => {
              isActive = true;
              this.addSource(source);
              return Promise.resolve();
            }
          };
          Object.defineProperty(extension, "isActive", {
            get: () => isActive
          });
          extensions_default.registerExtension(extension, () => {
            isActive = false;
            this.removeSource(source);
          });
        } catch (e) {
          window_default.showMessage(`Error on create vim source ${name2}: ${e.message}`, "error");
        }
      }
      createRemoteSources() {
        let { runtimepath } = workspace_default.env;
        let paths = runtimepath.split(",");
        for (let path34 of paths) {
          this.createVimSources(path34).logError();
        }
      }
      async createVimSources(pluginPath) {
        if (this.remoteSourcePaths.includes(pluginPath))
          return;
        this.remoteSourcePaths.push(pluginPath);
        let folder = import_path30.default.join(pluginPath, "autoload/coc/source");
        let stat = await statAsync(folder);
        if (stat && stat.isDirectory()) {
          let arr = await import_util37.default.promisify(import_fs30.default.readdir)(folder);
          arr = arr.filter((s) => s.endsWith(".vim"));
          let files = arr.map((s) => import_path30.default.join(folder, s));
          if (files.length == 0)
            return;
          await Promise.all(files.map((p) => this.createVimSourceExtension(this.nvim, p)));
        }
      }
      init() {
        this.createNativeSources();
        this.createRemoteSources();
        events_default.on("BufEnter", this.onDocumentEnter, this, this.disposables);
        workspace_default.watchOption("runtimepath", async (oldValue, newValue) => {
          let result = (0, import_fast_diff3.default)(oldValue, newValue);
          for (let [changeType, value] of result) {
            if (changeType == 1) {
              let paths = value.replace(/,$/, "").split(",");
              for (let p of paths) {
                if (p)
                  await this.createVimSources(p);
              }
            }
          }
        }, this.disposables);
      }
      get names() {
        return Array.from(this.sourceMap.keys());
      }
      get sources() {
        return Array.from(this.sourceMap.values());
      }
      has(name2) {
        return this.names.findIndex((o) => o == name2) != -1;
      }
      getSource(name2) {
        if (!name2)
          return null;
        return this.sourceMap.get(name2) || null;
      }
      async doCompleteResolve(item, token) {
        let source = this.getSource(item.source);
        if (source && typeof source.onCompleteResolve == "function") {
          try {
            await Promise.resolve(source.onCompleteResolve(item, token));
          } catch (e) {
            logger70.error("Error on complete resolve:", e.stack);
          }
        }
      }
      async doCompleteDone(item, opt) {
        let data = JSON.parse(item.user_data);
        let source = this.getSource(data.source);
        if (source && typeof source.onCompleteDone === "function") {
          await Promise.resolve(source.onCompleteDone(item, opt));
        }
      }
      shouldCommit(item, commitCharacter) {
        if (!item || !item.source)
          return false;
        let source = this.getSource(item.source);
        if (source && source.sourceType == SourceType.Service && typeof source.shouldCommit === "function") {
          return source.shouldCommit(item, commitCharacter);
        }
        return false;
      }
      getCompleteSources(opt) {
        let { filetype } = opt;
        let pre = byteSlice(opt.line, 0, opt.colnr - 1);
        let isTriggered = opt.input == "" && !!opt.triggerCharacter;
        let uri = getUri(opt.filepath, opt.bufnr, "", workspace_default.env.isCygwin);
        if (isTriggered)
          return this.getTriggerSources(pre, filetype, uri);
        return this.getNormalSources(opt.filetype, uri);
      }
      getNormalSources(filetype, uri) {
        return this.sources.filter((source) => {
          let { filetypes, triggerOnly, documentSelector, enable } = source;
          if (!enable || triggerOnly || filetypes && !filetypes.includes(filetype)) {
            return false;
          }
          if (documentSelector && score(documentSelector, uri, filetype) == 0) {
            return false;
          }
          if (this.disabledByLanguageId(source, filetype)) {
            return false;
          }
          return true;
        });
      }
      checkTrigger(source, pre, character) {
        let { triggerCharacters, triggerPatterns } = source;
        if (!triggerCharacters && !triggerPatterns)
          return false;
        if (character && triggerCharacters && triggerCharacters.includes(character)) {
          return true;
        }
        if (triggerPatterns && triggerPatterns.findIndex((p) => p.test(pre)) !== -1) {
          return true;
        }
        return false;
      }
      shouldTrigger(pre, languageId, uri) {
        let sources = this.getTriggerSources(pre, languageId, uri);
        return sources.length > 0;
      }
      getTriggerSources(pre, languageId, uri) {
        let character = pre.length ? pre[pre.length - 1] : "";
        if (!character)
          return [];
        return this.sources.filter((source) => {
          let { filetypes, enable, documentSelector } = source;
          if (!enable || filetypes && !filetypes.includes(languageId)) {
            return false;
          }
          if (documentSelector && score(documentSelector, uri, languageId) == 0) {
            return false;
          }
          if (this.disabledByLanguageId(source, languageId))
            return false;
          return this.checkTrigger(source, pre, character);
        });
      }
      addSource(source) {
        let { name: name2 } = source;
        if (this.names.includes(name2)) {
          logger70.warn(`Recreate source ${name2}`);
        }
        this.sourceMap.set(name2, source);
        return import_vscode_languageserver_protocol68.Disposable.create(() => {
          this.sourceMap.delete(name2);
        });
      }
      removeSource(source) {
        let name2 = typeof source == "string" ? source : source.name;
        this.sourceMap.delete(name2);
      }
      async refresh(name2) {
        for (let source of this.sources) {
          if (!name2 || source.name == name2) {
            if (typeof source.refresh === "function") {
              await Promise.resolve(source.refresh());
            }
          }
        }
      }
      toggleSource(name2) {
        if (!name2)
          return;
        let source = this.getSource(name2);
        if (!source)
          return;
        if (typeof source.toggle === "function") {
          source.toggle();
        }
      }
      sourceStats() {
        let res = [];
        let items = this.sources;
        for (let item of items) {
          res.push({
            name: item.name,
            priority: item.priority,
            triggerCharacters: item.triggerCharacters || [],
            shortcut: item.shortcut || "",
            filetypes: item.filetypes || [],
            filepath: item.filepath || "",
            type: item.sourceType == SourceType.Native ? "native" : item.sourceType == SourceType.Remote ? "remote" : "service",
            disabled: !item.enable
          });
        }
        return res;
      }
      onDocumentEnter(bufnr) {
        let { sources } = this;
        for (let s of sources) {
          if (!s.enable)
            continue;
          if (typeof s.onEnter == "function") {
            s.onEnter(bufnr);
          }
        }
      }
      createSource(config) {
        if (!config.name || !config.doComplete) {
          console.error(`name and doComplete required for createSource`);
          return;
        }
        let source = new Source(Object.assign({ sourceType: SourceType.Service }, config));
        return this.addSource(source);
      }
      disabledByLanguageId(source, languageId) {
        let map = workspace_default.env.disabledSources;
        let list2 = map ? map[languageId] : [];
        return Array.isArray(list2) && list2.includes(source.name);
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
    sources_default = new Sources();
  }
});

// src/completion/match.ts
function nextWordIndex(start = 0, codes) {
  for (let i = start; i < codes.length; i++) {
    if (isWordIndex(i, codes)) {
      return i;
    }
  }
  return -1;
}
function upperCase(code) {
  return code >= 65 && code <= 90;
}
function isWordIndex(index, codes) {
  if (index == 0)
    return true;
  let curr = codes[index];
  if (!wordChar(curr))
    return false;
  let pre = codes[index - 1];
  if (!wordChar(pre))
    return true;
  if (upperCase(curr) && !upperCase(pre))
    return true;
  return false;
}
function matchScore(word, input) {
  if (input.length == 0 || word.length < input.length)
    return 0;
  let codes = getCharCodes(word);
  let curr = codes[0];
  let score5 = 0;
  let first = input[0];
  let idx = 1;
  let allowFuzzy = true;
  if (caseMatch(first, curr)) {
    score5 = first == curr ? 5 : 2.5;
    idx = 1;
  } else {
    let next2 = nextWordIndex(1, codes);
    if (next2 != -1) {
      if (caseMatch(first, codes[next2])) {
        score5 = first == codes[next2] ? 2.5 : 2;
        idx = next2 + 1;
      }
    }
    if (score5 == 0) {
      for (let i = 1; i < codes.length; i++) {
        if (caseMatch(first, codes[i])) {
          score5 = first == codes[i] ? 1 : 0.5;
          idx = i + 1;
          allowFuzzy = false;
        }
      }
    }
  }
  if (input.length == 1 || score5 == 0)
    return score5;
  let next = nextScore(codes, idx, input.slice(1), allowFuzzy);
  return next == 0 ? 0 : score5 + next;
}
function nextScore(codes, index, inputCodes, allowFuzzy = true) {
  if (index >= codes.length)
    return 0;
  let scores = [];
  let input = inputCodes[0];
  let len = codes.length;
  let isFinal = inputCodes.length == 1;
  if (!wordChar(input)) {
    for (let i = index; i < len; i++) {
      if (codes[i] == input) {
        if (isFinal)
          return 1;
        let next = nextScore(codes, i + 1, inputCodes.slice(1), allowFuzzy);
        return next == 0 ? 0 : 1 + next;
      }
    }
    return 0;
  }
  let curr = codes[index];
  let match = caseMatch(input, curr);
  if (match) {
    let score5 = input == curr ? 1 : 0.5;
    if (!isFinal) {
      let next = nextScore(codes, index + 1, inputCodes.slice(1), allowFuzzy);
      score5 = next == 0 ? 0 : score5 + next;
    }
    scores.push(score5);
  }
  if (wordChar(input) && !isWordIndex(index, codes)) {
    let idx = nextWordIndex(index + 1, codes);
    if (idx !== -1) {
      let next = codes[idx];
      if (caseMatch(input, next)) {
        let score5 = input == next ? 1 : 0.75;
        if (!isFinal) {
          let next2 = nextScore(codes, idx + 1, inputCodes.slice(1), allowFuzzy);
          score5 = next2 == 0 ? 0 : score5 + next2;
        }
        scores.push(score5);
      }
    }
  }
  if (!match && allowFuzzy) {
    for (let i = index + 1; i < len; i++) {
      let code = codes[i];
      if (caseMatch(input, code)) {
        let score5 = input == code ? 0.1 : 0.05;
        if (!isFinal) {
          let next = nextScore(codes, i + 1, inputCodes.slice(1), false);
          score5 = next == 0 ? 0 : score5 + next;
        }
        scores.push(score5);
      }
    }
  }
  if (!scores.length)
    return 0;
  return Math.max(...scores);
}
var init_match2 = __esm({
  "src/completion/match.ts"() {
    init_fuzzy();
  }
});

// src/completion/complete.ts
var import_vscode_languageserver_protocol69, logger71, FIRST_TIMEOUT, Complete;
var init_complete2 = __esm({
  "src/completion/complete.ts"() {
    import_vscode_languageserver_protocol69 = __toModule(require_main2());
    init_fuzzy();
    init_string();
    init_match2();
    logger71 = require_logger2()("completion-complete");
    FIRST_TIMEOUT = 500;
    Complete = class {
      constructor(option, document2, recentScores, config, sources, nvim) {
        this.option = option;
        this.document = document2;
        this.config = config;
        this.sources = sources;
        this.nvim = nvim;
        this.results = [];
        this.completing = new Set();
        this._canceled = false;
        this.tokenSources = new Map();
        this._onDidComplete = new import_vscode_languageserver_protocol69.Emitter();
        this.onDidComplete = this._onDidComplete.event;
        Object.defineProperty(this, "recentScores", {
          get: () => recentScores || {}
        });
      }
      get isCompleting() {
        return this.completing.size > 0;
      }
      get isCanceled() {
        return this._canceled;
      }
      get isEmpty() {
        return this.results.length == 0;
      }
      get startcol() {
        return this.option.col || 0;
      }
      get input() {
        return this.option.input;
      }
      get isIncomplete() {
        return this.results.findIndex((o) => o.isIncomplete) !== -1;
      }
      async completeSource(source) {
        let { col } = this.option;
        let opt = Object.assign({}, this.option);
        let timeout = this.config.timeout;
        timeout = Math.max(Math.min(timeout, 15e3), 500);
        try {
          if (typeof source.shouldComplete === "function") {
            let shouldRun = await Promise.resolve(source.shouldComplete(opt));
            if (!shouldRun)
              return null;
          }
          let start = Date.now();
          let oldSource = this.tokenSources.get(source.name);
          if (oldSource)
            oldSource.cancel();
          let tokenSource = new import_vscode_languageserver_protocol69.CancellationTokenSource();
          this.tokenSources.set(source.name, tokenSource);
          await new Promise((resolve3, reject) => {
            let { name: name2 } = source;
            let timer = setTimeout(() => {
              this.nvim.command(`echohl WarningMsg| echom 'source ${source.name} timeout after ${timeout}ms'|echohl None`, true);
              tokenSource.cancel();
            }, timeout);
            let cancelled = false;
            let called = false;
            let empty = false;
            let ft = setTimeout(() => {
              if (called)
                return;
              empty = true;
              resolve3(void 0);
            }, FIRST_TIMEOUT);
            let onFinished = () => {
              if (called)
                return;
              called = true;
              disposable.dispose();
              clearTimeout(ft);
              clearTimeout(timer);
              this.tokenSources.delete(name2);
            };
            let disposable = tokenSource.token.onCancellationRequested(() => {
              disposable.dispose();
              this.completing.delete(name2);
              cancelled = true;
              onFinished();
              logger71.debug(`Source "${name2}" cancelled`);
              resolve3(void 0);
            });
            this.completing.add(name2);
            Promise.resolve(source.doComplete(opt, tokenSource.token)).then((result) => {
              this.completing.delete(name2);
              if (cancelled)
                return;
              onFinished();
              let dt = Date.now() - start;
              logger71.debug(`Source "${name2}" takes ${dt}ms`);
              if (result && result.items && result.items.length) {
                result.priority = source.priority;
                result.source = name2;
                if (empty && result.startcol && result.startcol != col) {
                  this.results = [result];
                } else {
                  let { results } = this;
                  let idx = results.findIndex((o) => o.source == name2);
                  if (idx != -1) {
                    results.splice(idx, 1, result);
                  } else {
                    results.push(result);
                  }
                }
                if (empty)
                  this._onDidComplete.fire();
                resolve3(void 0);
              } else {
                resolve3(void 0);
              }
            }, (err) => {
              this.completing.delete(name2);
              onFinished();
              reject(err);
            });
          });
        } catch (err) {
          this.nvim.command(`echoerr 'Complete ${source.name} error: ${err.message.replace(/'/g, "''")}'`, true);
          logger71.error("Complete error:", source.name, err);
        }
      }
      async completeInComplete(resumeInput) {
        let { results, document: document2 } = this;
        let remains = results.filter((res) => !res.isIncomplete);
        remains.forEach((res) => {
          res.items.forEach((item) => delete item.user_data);
        });
        let arr = results.filter((res) => res.isIncomplete);
        let names = arr.map((o) => o.source);
        let { input, colnr, linenr } = this.option;
        Object.assign(this.option, {
          input: resumeInput,
          line: document2.getline(linenr - 1),
          colnr: colnr + (resumeInput.length - input.length),
          triggerCharacter: null,
          triggerForInComplete: true
        });
        let sources = this.sources.filter((s) => names.includes(s.name));
        await Promise.all(sources.map((s) => this.completeSource(s)));
        return this.filterResults(resumeInput, Math.floor(Date.now() / 1e3));
      }
      filterResults(input, cid = 0) {
        let { results } = this;
        results.sort((a, b) => {
          if (a.source == "tabnine")
            return 1;
          if (b.source == "tabnine")
            return -1;
          return b.priority - a.priority;
        });
        let now = Date.now();
        let { bufnr } = this.option;
        let { snippetIndicator, removeDuplicateItems, fixInsertedWord, asciiCharactersOnly } = this.config;
        let followPart = !fixInsertedWord || cid == 0 ? "" : this.getFollowPart();
        if (results.length == 0)
          return [];
        let arr = [];
        let codes = getCharCodes(input);
        let words = new Set();
        for (let i = 0, l = results.length; i < l; i++) {
          let res = results[i];
          let { items, source, priority } = res;
          for (let idx = 0; idx < items.length; idx++) {
            let item = items[idx];
            if (!item || typeof item.word !== "string") {
              continue;
            }
            let { word } = item;
            if (asciiCharactersOnly && !/^[\x00-\x7F]*$/.test(word)) {
              continue;
            }
            if (!item.dup && words.has(word))
              continue;
            if (removeDuplicateItems && !item.isSnippet && words.has(word) && item.line == void 0)
              continue;
            let filterText = item.filterText || item.word;
            item.filterText = filterText;
            if (filterText.length < input.length)
              continue;
            let score5 = item.kind && filterText == input ? 64 : matchScore(filterText, codes);
            if (input.length && score5 == 0)
              continue;
            if (followPart.length && !item.isSnippet) {
              if (item.word.endsWith(followPart)) {
                let { word: word2 } = item;
                item.word = item.word.slice(0, -followPart.length);
                item.abbr = item.abbr || word2;
              }
            }
            if (!item.user_data) {
              let user_data = { cid, source };
              user_data.index = item.index || idx;
              if (item.isSnippet) {
                let abbr = item.abbr || item.word;
                if (!abbr.endsWith(snippetIndicator)) {
                  item.abbr = `${item.abbr || item.word}${snippetIndicator}`;
                }
              }
              if (item.signature)
                user_data.signature = item.signature;
              item.user_data = JSON.stringify(user_data);
              item.source = source;
              let recentScore = this.recentScores[`${bufnr}|${word}`];
              if (recentScore && now - recentScore < 60 * 1e3) {
                item.recentScore = recentScore;
              } else {
                item.recentScore = 0;
              }
            }
            item.priority = priority;
            item.abbr = item.abbr || item.word;
            item.score = input.length ? score5 * (item.sourceScore || 1) : 0;
            item.localBonus = this.localBonus ? this.localBonus.get(filterText) || 0 : 0;
            words.add(word);
            if (item.isSnippet && item.word == input) {
              item.preselect = true;
            }
            arr.push(item);
          }
        }
        arr.sort((a, b) => {
          let sa = a.sortText;
          let sb = b.sortText;
          let wa = a.filterText;
          let wb = b.filterText;
          if (a.score != b.score)
            return b.score - a.score;
          if (a.priority != b.priority)
            return b.priority - a.priority;
          if (sa && sb && sa != sb)
            return sa < sb ? -1 : 1;
          if (a.recentScore != b.recentScore)
            return b.recentScore - a.recentScore;
          if (a.localBonus != b.localBonus) {
            if (a.localBonus && b.localBonus && wa != wb) {
              if (wa.startsWith(wb))
                return 1;
              if (wb.startsWith(wa))
                return -1;
            }
            return b.localBonus - a.localBonus;
          }
          switch (this.config.defaultSortMethod) {
            case "none":
              return 0;
            case "alphabetical":
              return a.filterText.localeCompare(b.filterText);
            case "length":
            default:
              return a.filterText.length - b.filterText.length;
          }
        });
        return this.limitCompleteItems(arr.slice(0, this.config.maxItemCount));
      }
      limitCompleteItems(items) {
        let { highPrioritySourceLimit, lowPrioritySourceLimit } = this.config;
        if (!highPrioritySourceLimit && !lowPrioritySourceLimit)
          return items;
        let counts = new Map();
        return items.filter((item) => {
          let { priority, source } = item;
          let isLow = priority < 90;
          let curr = counts.get(source) || 0;
          if (lowPrioritySourceLimit && isLow && curr == lowPrioritySourceLimit || highPrioritySourceLimit && !isLow && curr == highPrioritySourceLimit) {
            return false;
          }
          counts.set(source, curr + 1);
          return true;
        });
      }
      hasMatch(input) {
        let { results } = this;
        if (!results)
          return false;
        let codes = getCharCodes(input);
        for (let i = 0, l = results.length; i < l; i++) {
          let items = results[i].items;
          let idx = items.findIndex((item) => fuzzyMatch(codes, item.filterText || item.word));
          if (idx !== -1)
            return true;
        }
        return false;
      }
      async doComplete() {
        let opts = this.option;
        let { line, colnr, linenr, col } = this.option;
        if (this.config.localityBonus) {
          let line2 = linenr - 1;
          this.localBonus = this.document.getLocalifyBonus(import_vscode_languageserver_protocol69.Position.create(line2, opts.col - 1), import_vscode_languageserver_protocol69.Position.create(line2, colnr));
        } else {
          this.localBonus = new Map();
        }
        await Promise.all(this.sources.map((s) => this.completeSource(s)));
        let { results } = this;
        if (results.length == 0)
          return [];
        let engrossResult = results.find((r) => r.startcol != null && r.startcol != col);
        if (engrossResult) {
          let { startcol } = engrossResult;
          opts.col = startcol;
          opts.input = byteSlice(line, startcol, colnr - 1);
          this.results = [engrossResult];
        }
        logger71.info(`Results from: ${this.results.map((s) => s.source).join(",")}`);
        return this.filterResults(opts.input, Math.floor(Date.now() / 1e3));
      }
      resolveCompletionItem(item) {
        let { results } = this;
        if (!results)
          return null;
        try {
          if (item.user_data) {
            let { source } = JSON.parse(item.user_data);
            let result = results.find((res) => res.source == source);
            return result.items.find((o) => o.user_data == item.user_data);
          }
          for (let result of results) {
            let res = result.items.find((o) => o.abbr == item.abbr && o.info == item.info);
            if (res)
              return res;
          }
          return null;
        } catch (e) {
          return null;
        }
      }
      getFollowPart() {
        let { colnr, line } = this.option;
        let idx = characterIndex(line, colnr - 1);
        if (idx == line.length)
          return "";
        let part = line.slice(idx - line.length);
        return part.match(/^\S?[\w-]*/)[0];
      }
      dispose() {
        if (this._canceled)
          return;
        this._onDidComplete.dispose();
        this._canceled = true;
        for (let tokenSource of this.tokenSources.values()) {
          tokenSource.cancel();
        }
        this.tokenSources.clear();
        this.sources = [];
        this.results = [];
      }
    };
  }
});

// src/completion/floating.ts
var logger72, Floating;
var init_floating = __esm({
  "src/completion/floating.ts"() {
    init_markdown();
    logger72 = require_logger2()("floating");
    Floating = class {
      constructor(nvim, isVim6) {
        this.nvim = nvim;
        this.isVim = isVim6;
        this.winid = 0;
        this.bufnr = 0;
      }
      async show(docs, bounding, config, token) {
        let { nvim } = this;
        docs = docs.filter((o) => o.content.trim().length > 0);
        let { lines, codes, highlights } = parseDocuments(docs, { excludeImages: config.excludeImages });
        if (lines.length == 0) {
          this.close();
          return;
        }
        let res = await nvim.call("coc#float#create_pum_float", [this.winid, this.bufnr, lines, {
          codes,
          highlights,
          maxWidth: config.maxPreviewWidth,
          pumbounding: bounding
        }]);
        if (this.isVim)
          nvim.command("redraw", true);
        if (!res || res.length == 0)
          return;
        this.winid = res[0];
        this.bufnr = res[1];
        if (token.isCancellationRequested) {
          this.close();
          return;
        }
      }
      close() {
        let { winid, nvim } = this;
        this.winid = 0;
        if (!winid)
          return;
        nvim.call("coc#float#close", [winid], true);
        if (this.isVim)
          nvim.command("redraw", true);
      }
    };
  }
});

// src/util/throttle.ts
function throttle(func2, wait2) {
  let args;
  let rtn;
  let timeoutID;
  let last = 0;
  function fn() {
    args = arguments;
    let delta = Date.now() - last;
    if (!timeoutID) {
      if (last != 0 && delta >= wait2) {
        call();
      } else {
        timeoutID = setTimeout(call, wait2 - delta);
      }
    }
    return rtn;
  }
  function call() {
    timeoutID = 0;
    last = Date.now();
    rtn = func2.apply(null, args);
    args = null;
  }
  fn.clear = () => {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  };
  return fn;
}
var init_throttle = __esm({
  "src/util/throttle.ts"() {
  }
});

// src/completion/index.ts
var import_vscode_languageserver_protocol70, logger73, completeItemKeys, Completion, completion_default;
var init_completion = __esm({
  "src/completion/index.ts"() {
    import_vscode_languageserver_protocol70 = __toModule(require_main2());
    init_events();
    init_sources2();
    init_util();
    init_workspace();
    init_complete2();
    init_floating();
    init_throttle();
    init_object();
    init_string();
    logger73 = require_logger2()("completion");
    completeItemKeys = ["abbr", "menu", "info", "kind", "icase", "dup", "empty", "user_data"];
    Completion = class {
      constructor() {
        this.activated = false;
        this.disposables = [];
        this.complete = null;
        this.recentScores = {};
        this.changedTick = 0;
        this.insertCharTs = 0;
        this.insertLeaveTs = 0;
      }
      init() {
        this.config = this.getCompleteConfig();
        this.excludeImages = workspace_default.getConfiguration("coc.preferences").get("excludeImageLinksInMarkdownDocument");
        this.floating = new Floating(workspace_default.nvim, workspace_default.env.isVim);
        events_default.on(["InsertCharPre", "MenuPopupChanged", "TextChangedI", "CursorMovedI", "InsertLeave"], () => {
          if (this.triggerTimer) {
            clearTimeout(this.triggerTimer);
            this.triggerTimer = null;
          }
        }, this, this.disposables);
        events_default.on("InsertCharPre", this.onInsertCharPre, this, this.disposables);
        events_default.on("InsertLeave", this.onInsertLeave, this, this.disposables);
        events_default.on("InsertEnter", this.onInsertEnter, this, this.disposables);
        events_default.on("TextChangedP", this.onTextChangedP, this, this.disposables);
        events_default.on("TextChangedI", this.onTextChangedI, this, this.disposables);
        let fn = throttle(this.onPumChange.bind(this), workspace_default.isVim ? 200 : 100);
        events_default.on("CompleteDone", async (item) => {
          this.currItem = null;
          this.cancelResolve();
          this.floating.close();
          await this.onCompleteDone(item);
        }, this, this.disposables);
        events_default.on("MenuPopupChanged", (ev) => {
          if (!this.activated || this.isCommandLine)
            return;
          let { completed_item } = ev;
          let item = completed_item.hasOwnProperty("word") ? completed_item : null;
          if (equals(item, this.currItem))
            return;
          this.cancelResolve();
          this.currItem = item;
          fn(ev);
        }, this, this.disposables);
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("suggest")) {
            this.config = this.getCompleteConfig();
          }
        }, null, this.disposables);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      get option() {
        if (!this.complete)
          return null;
        return this.complete.option;
      }
      get isCommandLine() {
        var _a2;
        return (_a2 = this.document) == null ? void 0 : _a2.uri.endsWith("%5BCommand%20Line%5D");
      }
      addRecent(word, bufnr) {
        if (!word)
          return;
        this.recentScores[`${bufnr}|${word}`] = Date.now();
      }
      get isActivated() {
        return this.activated;
      }
      get document() {
        if (!this.option)
          return null;
        return workspace_default.getDocument(this.option.bufnr);
      }
      getCompleteConfig() {
        let suggest = workspace_default.getConfiguration("suggest");
        function getConfig(key, defaultValue) {
          return suggest.get(key, defaultValue);
        }
        let keepCompleteopt = getConfig("keepCompleteopt", false);
        let autoTrigger = getConfig("autoTrigger", "always");
        if (keepCompleteopt && autoTrigger != "none") {
          let { completeOpt } = workspace_default;
          if (!completeOpt.includes("noinsert") && !completeOpt.includes("noselect")) {
            autoTrigger = "none";
          }
        }
        let floatEnable = workspace_default.floatSupported && getConfig("floatEnable", true);
        let acceptSuggestionOnCommitCharacter = workspace_default.env.pumevent && getConfig("acceptSuggestionOnCommitCharacter", false);
        return {
          autoTrigger,
          floatEnable,
          keepCompleteopt,
          defaultSortMethod: getConfig("defaultSortMethod", "length"),
          removeDuplicateItems: getConfig("removeDuplicateItems", false),
          disableMenuShortcut: getConfig("disableMenuShortcut", false),
          acceptSuggestionOnCommitCharacter,
          disableKind: getConfig("disableKind", false),
          disableMenu: getConfig("disableMenu", false),
          previewIsKeyword: getConfig("previewIsKeyword", "@,48-57,_192-255"),
          enablePreview: getConfig("enablePreview", false),
          enablePreselect: getConfig("enablePreselect", false),
          maxPreviewWidth: getConfig("maxPreviewWidth", 80),
          triggerCompletionWait: getConfig("triggerCompletionWait", 100),
          labelMaxLength: getConfig("labelMaxLength", 200),
          triggerAfterInsertEnter: getConfig("triggerAfterInsertEnter", false),
          noselect: getConfig("noselect", true),
          numberSelect: getConfig("numberSelect", false),
          maxItemCount: getConfig("maxCompleteItemCount", 50),
          timeout: getConfig("timeout", 500),
          minTriggerInputLength: getConfig("minTriggerInputLength", 1),
          snippetIndicator: getConfig("snippetIndicator", "~"),
          fixInsertedWord: getConfig("fixInsertedWord", true),
          localityBonus: getConfig("localityBonus", true),
          highPrioritySourceLimit: getConfig("highPrioritySourceLimit", null),
          lowPrioritySourceLimit: getConfig("lowPrioritySourceLimit", null),
          asciiCharactersOnly: getConfig("asciiCharactersOnly", false)
        };
      }
      async startCompletion(option) {
        this.pretext = byteSlice(option.line, 0, option.colnr - 1);
        try {
          await this._doComplete(option);
        } catch (e) {
          this.stop(false);
          logger73.error("Complete error:", e.stack);
        }
      }
      async resumeCompletion(force = false) {
        let { document: document2, complete: complete2 } = this;
        if (!document2 || complete2.isCanceled || !complete2.results || complete2.results.length == 0)
          return;
        let search = this.getResumeInput();
        if (search == this.input && !force)
          return;
        if (!search || search.endsWith(" ") || !search.startsWith(complete2.input)) {
          this.stop();
          return;
        }
        this.input = search;
        let items = [];
        if (complete2.isIncomplete) {
          await document2.patchChange();
          let { changedtick } = document2;
          items = await complete2.completeInComplete(search);
          if (complete2.isCanceled || document2.changedtick != changedtick)
            return;
        } else {
          items = complete2.filterResults(search);
        }
        if (!complete2.isCompleting && items.length === 0) {
          this.stop();
          return;
        }
        await this.showCompletion(complete2.option.col, items);
      }
      hasSelected() {
        if (workspace_default.env.pumevent)
          return this.currItem != null;
        if (!this.config.noselect)
          return true;
        return false;
      }
      async showCompletion(col, items) {
        let { nvim, document: document2, option } = this;
        let { numberSelect, disableKind, labelMaxLength, disableMenuShortcut, disableMenu } = this.config;
        let preselect = this.config.enablePreselect ? items.findIndex((o) => o.preselect) : -1;
        if (numberSelect && option.input.length && !/^\d/.test(option.input)) {
          items = items.map((item, i) => {
            let idx = i + 1;
            if (i < 9) {
              return Object.assign({}, item, {
                abbr: item.abbr ? `${idx} ${item.abbr}` : `${idx} ${item.word}`
              });
            }
            return item;
          });
          nvim.call("coc#_map", [], true);
        }
        this.changedTick = document2.changedtick;
        let validKeys2 = completeItemKeys.slice();
        if (disableKind)
          validKeys2 = validKeys2.filter((s) => s != "kind");
        if (disableMenu)
          validKeys2 = validKeys2.filter((s) => s != "menu");
        let vimItems = items.map((item) => {
          let obj = { word: item.word, equal: 1 };
          for (let key of validKeys2) {
            if (item.hasOwnProperty(key)) {
              if (disableMenuShortcut && key == "menu") {
                obj[key] = item[key].replace(/\[.+\]$/, "");
              } else if (key == "abbr" && item[key].length > labelMaxLength) {
                obj[key] = item[key].slice(0, labelMaxLength);
              } else {
                obj[key] = item[key];
              }
            }
          }
          return obj;
        });
        nvim.call("coc#_do_complete", [col, vimItems, preselect], true);
      }
      async _doComplete(option) {
        let { source } = option;
        let { nvim, config } = this;
        let doc = workspace_default.getDocument(option.bufnr);
        if (!doc || !doc.attached)
          return;
        option.filetype = doc.filetype;
        this.input = option.input;
        let arr = [];
        if (source == null) {
          arr = sources_default.getCompleteSources(option);
        } else {
          let s = sources_default.getSource(source);
          if (s)
            arr.push(s);
        }
        if (!arr.length)
          return;
        await doc.patchChange();
        if (doc.changedtick != option.changedtick)
          return;
        let complete2 = new Complete(option, doc, this.recentScores, config, arr, nvim);
        this.start(complete2);
        let items = await this.complete.doComplete();
        if (complete2.isCanceled)
          return;
        if (items.length == 0 && !complete2.isCompleting) {
          this.stop();
          return;
        }
        complete2.onDidComplete(async () => {
          if (this.currItem != null)
            return;
          let search = this.getResumeInput();
          if (complete2.isCanceled || search == null)
            return;
          let { input } = this.option;
          if (search == input) {
            let items2 = complete2.filterResults(search, Math.floor(Date.now() / 1e3));
            await this.showCompletion(option.col, items2);
          } else {
            await this.resumeCompletion();
          }
        });
        if (items.length) {
          let search = this.getResumeInput();
          if (search == option.input) {
            await this.showCompletion(option.col, items);
          } else {
            await this.resumeCompletion(true);
          }
        }
      }
      async onTextChangedP(bufnr, info) {
        let { option, document: document2 } = this;
        let pretext = this.pretext = info.pre;
        if (!option || option.bufnr != bufnr || info.changedtick == this.changedTick)
          return;
        let hasInsert = this.latestInsert != null;
        this.lastInsert = null;
        if (info.pre.match(/^\s*/)[0] !== option.line.match(/^\s*/)[0]) {
          logger73.warn("Complete stopped by indent change.");
          this.stop();
          return;
        }
        if (!hasInsert || !pretext)
          return;
        if (sources_default.shouldTrigger(pretext, document2.filetype, document2.uri)) {
          await this.triggerCompletion(document2, pretext);
        } else {
          await this.resumeCompletion();
        }
      }
      async onTextChangedI(bufnr, info) {
        let { nvim, latestInsertChar, option } = this;
        let noChange = this.pretext == info.pre;
        let pretext = this.pretext = info.pre;
        this.lastInsert = null;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return;
        if (!this.activated) {
          if (!latestInsertChar)
            return;
          let triggerSources = sources_default.getTriggerSources(pretext, doc.filetype, doc.uri);
          if (triggerSources.length) {
            await this.triggerCompletion(doc, this.pretext);
            return;
          }
          this.triggerTimer = setTimeout(async () => {
            await this.triggerCompletion(doc, pretext);
          }, this.config.triggerCompletionWait);
          return;
        }
        if (!option || bufnr != option.bufnr)
          return;
        if (option.linenr != info.lnum || option.col >= info.col - 1) {
          this.stop();
          return;
        }
        if (noChange && !latestInsertChar) {
          this.stop(false);
          return;
        }
        if (pretext && this.currItem && this.config.acceptSuggestionOnCommitCharacter && latestInsertChar) {
          let resolvedItem = this.getCompleteItem(this.currItem);
          let last = pretext[pretext.length - 1];
          if (sources_default.shouldCommit(resolvedItem, last)) {
            let { linenr, col, line, colnr } = this.option;
            this.stop();
            let { word } = resolvedItem;
            let newLine = `${line.slice(0, col)}${word}${latestInsertChar}${line.slice(colnr - 1)}`;
            await nvim.call("coc#util#setline", [linenr, newLine]);
            let curcol = col + word.length + 2;
            await nvim.call("cursor", [linenr, curcol]);
            await doc.patchChange();
            return;
          }
        }
        if (sources_default.shouldTrigger(pretext, doc.filetype, doc.uri)) {
          await this.triggerCompletion(doc, pretext);
        } else {
          await this.resumeCompletion();
        }
      }
      async triggerCompletion(doc, pre) {
        if (!doc || !doc.attached) {
          logger73.warn("Document not attached, suggest disabled.");
          return;
        }
        let shouldTrigger = this.shouldTrigger(doc, pre);
        if (!shouldTrigger)
          return;
        if (doc.getVar("suggest_disable")) {
          logger73.warn(`Suggest disabled by b:coc_suggest_disable`);
          return;
        }
        await doc.patchChange();
        let [disabled, option] = await this.nvim.eval('[get(b:,"coc_suggest_disable",0),coc#util#get_complete_option()]');
        if (disabled == 1) {
          logger73.warn(`Suggest disabled by b:coc_suggest_disable`);
          return;
        }
        if (option.blacklist && option.blacklist.includes(option.input)) {
          logger73.warn(`Suggest disabled by b:coc_suggest_blacklist`, option.blacklist);
          return;
        }
        if (pre.length) {
          option.triggerCharacter = pre.slice(-1);
        }
        logger73.debug("trigger completion with", option);
        await this.startCompletion(option);
      }
      async onCompleteDone(item) {
        let { document: document2, isActivated } = this;
        if (!isActivated || !document2 || !item.hasOwnProperty("word"))
          return;
        let opt = Object.assign({}, this.option);
        let resolvedItem = this.getCompleteItem(item);
        this.stop(false);
        if (!resolvedItem)
          return;
        let timestamp = this.insertCharTs;
        let insertLeaveTs = this.insertLeaveTs;
        try {
          await sources_default.doCompleteResolve(resolvedItem, new import_vscode_languageserver_protocol70.CancellationTokenSource().token);
          this.addRecent(resolvedItem.word, document2.bufnr);
          await wait(50);
          if (this.insertCharTs != timestamp || this.insertLeaveTs != insertLeaveTs)
            return;
          let [visible, lnum, pre] = await this.nvim.eval(`[pumvisible(),line('.'),strpart(getline('.'), 0, col('.') - 1)]`);
          if (visible || lnum != opt.linenr || this.activated || !pre.endsWith(resolvedItem.word))
            return;
          await document2.patchChange();
          await sources_default.doCompleteDone(resolvedItem, opt);
        } catch (e) {
          logger73.error(`error on complete done`, e.stack);
        }
      }
      async onInsertLeave() {
        this.insertLeaveTs = Date.now();
        this.stop(false);
      }
      async onInsertEnter(bufnr) {
        if (!this.config.triggerAfterInsertEnter || this.config.autoTrigger !== "always")
          return;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return;
        let pre = await this.nvim.eval(`strpart(getline('.'), 0, col('.') - 1)`);
        if (!pre)
          return;
        await this.triggerCompletion(doc, pre);
      }
      async onInsertCharPre(character) {
        this.lastInsert = {
          character,
          timestamp: Date.now()
        };
        this.insertCharTs = this.lastInsert.timestamp;
      }
      get latestInsert() {
        let { lastInsert } = this;
        if (!lastInsert || Date.now() - lastInsert.timestamp > 500) {
          return null;
        }
        return lastInsert;
      }
      get latestInsertChar() {
        let { latestInsert } = this;
        if (!latestInsert)
          return "";
        return latestInsert.character;
      }
      shouldTrigger(doc, pre) {
        let autoTrigger = this.config.autoTrigger;
        if (autoTrigger == "none")
          return false;
        if (sources_default.shouldTrigger(pre, doc.filetype, doc.uri))
          return true;
        if (autoTrigger !== "always" || this.isActivated)
          return false;
        let last = pre.slice(-1);
        if (last && (doc.isWord(pre.slice(-1)) || last.codePointAt(0) > 255)) {
          let minLength = this.config.minTriggerInputLength;
          if (minLength == 1)
            return true;
          let input = this.getInput(doc, pre);
          return input.length >= minLength;
        }
        return false;
      }
      async onPumChange(ev) {
        if (!this.activated)
          return;
        let { completed_item, col, row, height, width, scrollbar } = ev;
        let bounding = { col, row, height, width, scrollbar };
        let resolvedItem = this.getCompleteItem(completed_item);
        if (!resolvedItem) {
          this.floating.close();
          return;
        }
        let source = this.resolveTokenSource = new import_vscode_languageserver_protocol70.CancellationTokenSource();
        let { token } = source;
        await sources_default.doCompleteResolve(resolvedItem, token);
        this.resolveTokenSource = null;
        if (token.isCancellationRequested)
          return;
        let docs = resolvedItem.documentation;
        if (!docs && resolvedItem.info) {
          let { info } = resolvedItem;
          let isText = /^[\w-\s.,\t]+$/.test(info);
          docs = [{ filetype: isText ? "txt" : this.document.filetype, content: info }];
        }
        if (!this.isActivated)
          return;
        if (!docs || docs.length == 0) {
          this.floating.close();
        } else {
          if (this.config.floatEnable) {
            await this.floating.show(docs, bounding, { maxPreviewWidth: this.config.maxPreviewWidth, excludeImages: this.excludeImages }, token);
          }
          if (!this.isActivated) {
            this.floating.close();
          }
        }
      }
      start(complete2) {
        let { activated } = this;
        this.activated = true;
        if (activated) {
          this.complete.dispose();
        }
        this.complete = complete2;
        if (!this.config.keepCompleteopt) {
          this.nvim.command(`noa set completeopt=${this.completeOpt}`, true);
        }
      }
      cancelResolve() {
        if (this.resolveTokenSource) {
          this.resolveTokenSource.cancel();
          this.resolveTokenSource = null;
        }
      }
      stop(hide = true) {
        let { nvim } = this;
        if (!this.activated)
          return;
        this.cancelResolve();
        this.currItem = null;
        this.activated = false;
        if (this.complete) {
          this.complete.dispose();
          this.complete = null;
        }
        nvim.pauseNotification();
        if (hide) {
          nvim.call("coc#_hide", [], true);
        }
        this.floating.close();
        if (this.config.numberSelect) {
          nvim.call("coc#_unmap", [], true);
        }
        if (!this.config.keepCompleteopt) {
          this.nvim.command(`noa set completeopt=${workspace_default.completeOpt}`, true);
        }
        nvim.command(`let g:coc#_context['candidates'] = []`, true);
        nvim.call("coc#_cancel", [], true);
        nvim.resumeNotification(false, true);
      }
      getInput(document2, pre) {
        let input = "";
        for (let i = pre.length - 1; i >= 0; i--) {
          let ch = i == 0 ? null : pre[i - 1];
          if (!ch || !document2.isWord(ch)) {
            input = pre.slice(i, pre.length);
            break;
          }
        }
        return input;
      }
      getResumeInput() {
        let { option, pretext } = this;
        if (!option)
          return null;
        let buf = Buffer.from(pretext, "utf8");
        if (buf.length < option.col)
          return null;
        let input = buf.slice(option.col).toString("utf8");
        if (option.blacklist && option.blacklist.includes(input))
          return null;
        return input;
      }
      get completeOpt() {
        let { noselect, enablePreview } = this.config;
        let preview = enablePreview && !workspace_default.env.pumevent ? ",preview" : "";
        if (noselect)
          return `noselect,menuone${preview}`;
        return `noinsert,menuone${preview}`;
      }
      getCompleteItem(item) {
        if (!this.complete || item == null)
          return null;
        return this.complete.resolveCompletionItem(item);
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
    completion_default = new Completion();
  }
});

// src/snippets/snippet.ts
var import_vscode_languageserver_protocol71, logger74, CocSnippet;
var init_snippet = __esm({
  "src/snippets/snippet.ts"() {
    import_vscode_languageserver_protocol71 = __toModule(require_main2());
    init_main2();
    init_position();
    init_parser2();
    init_string();
    logger74 = require_logger2()("snippets-snipet");
    CocSnippet = class {
      constructor(_snippetString, position, _variableResolver) {
        this._snippetString = _snippetString;
        this.position = position;
        this._variableResolver = _variableResolver;
        this._parser = new SnippetParser();
      }
      async init() {
        const snippet = this._parser.parse(this._snippetString, true);
        let { _variableResolver } = this;
        if (_variableResolver) {
          await snippet.resolveVariables(_variableResolver);
        }
        this.tmSnippet = snippet;
        this.update();
      }
      adjustPosition(characterCount, lineCount) {
        let { line, character } = this.position;
        this.position = {
          line: line + lineCount,
          character: character + characterCount
        };
        this.update();
      }
      adjustTextEdit(edit2) {
        let { range, newText } = edit2;
        if (comparePosition(this.range.start, range.end) < 0)
          return false;
        if (!newText.includes("\n") && comparePosition(range.start, range.end) == 0 && comparePosition(this.range.start, range.start) == 0) {
          let idx = this._placeholders.findIndex((o) => comparePosition(o.range.start, range.start) == 0);
          if (idx !== -1)
            return false;
        }
        let changed = getChangedPosition(this.range.start, edit2);
        if (changed.line == 0 && changed.character == 0)
          return true;
        this.adjustPosition(changed.character, changed.line);
        return true;
      }
      get isPlainText() {
        if (this._placeholders.length > 1)
          return false;
        return this._placeholders.every((o) => o.value == "");
      }
      get finalCount() {
        return this._placeholders.filter((o) => o.isFinalTabstop).length;
      }
      toString() {
        return this.tmSnippet.toString();
      }
      get range() {
        let { position } = this;
        const content = this.tmSnippet.toString();
        const doc = TextDocument2.create("untitled:/1", "snippet", 0, content);
        const pos = doc.positionAt(content.length);
        const end = pos.line == 0 ? position.character + pos.character : pos.character;
        return import_vscode_languageserver_protocol71.Range.create(position, import_vscode_languageserver_protocol71.Position.create(position.line + pos.line, end));
      }
      get firstPlaceholder() {
        let index = 0;
        for (let p of this._placeholders) {
          if (p.index == 0)
            continue;
          if (index == 0 || p.index < index) {
            index = p.index;
          }
        }
        return this.getPlaceholder(index);
      }
      get lastPlaceholder() {
        let index = 0;
        for (let p of this._placeholders) {
          if (index == 0 || p.index > index) {
            index = p.index;
          }
        }
        return this.getPlaceholder(index);
      }
      getPlaceholderById(id) {
        return this._placeholders.find((o) => o.id == id);
      }
      getPlaceholder(index) {
        let placeholders = this._placeholders.filter((o) => o.index == index);
        let filtered = placeholders.filter((o) => !o.transform);
        return filtered.length ? filtered[0] : placeholders[0];
      }
      getPrevPlaceholder(index) {
        if (index == 0)
          return this.lastPlaceholder;
        let prev = this.getPlaceholder(index - 1);
        if (!prev)
          return this.getPrevPlaceholder(index - 1);
        return prev;
      }
      getNextPlaceholder(index) {
        let indexes = this._placeholders.map((o) => o.index);
        let max = Math.max.apply(null, indexes);
        if (index >= max)
          return this.finalPlaceholder;
        let next = this.getPlaceholder(index + 1);
        if (!next)
          return this.getNextPlaceholder(index + 1);
        return next;
      }
      get finalPlaceholder() {
        return this._placeholders.find((o) => o.isFinalTabstop);
      }
      getPlaceholderByRange(range) {
        return this._placeholders.find((o) => rangeInRange(range, o.range));
      }
      insertSnippet(placeholder, snippet, range) {
        let { start } = placeholder.range;
        let editStart = import_vscode_languageserver_protocol71.Position.create(range.start.line - start.line, range.start.line == start.line ? range.start.character - start.character : range.start.character);
        let editEnd = import_vscode_languageserver_protocol71.Position.create(range.end.line - start.line, range.end.line == start.line ? range.end.character - start.character : range.end.character);
        let editRange2 = import_vscode_languageserver_protocol71.Range.create(editStart, editEnd);
        let first = this.tmSnippet.insertSnippet(snippet, placeholder.id, editRange2);
        this.update();
        return first;
      }
      updatePlaceholder(placeholder, edit2) {
        let { start, end } = edit2.range;
        let { range } = this;
        let { value, id, index } = placeholder;
        let newText = editRange(placeholder.range, value, edit2);
        let delta = 0;
        if (!newText.includes("\n")) {
          for (let p of this._placeholders) {
            if (p.index == index && p.id < id && p.line == placeholder.range.start.line) {
              let text = this.tmSnippet.getPlaceholderText(p.id, newText);
              delta = delta + byteLength(text) - byteLength(p.value);
            }
          }
        }
        if (placeholder.isVariable) {
          this.tmSnippet.updateVariable(id, newText);
        } else {
          this.tmSnippet.updatePlaceholder(id, newText);
        }
        let endPosition = adjustPosition(range.end, edit2);
        let snippetEdit = {
          range: import_vscode_languageserver_protocol71.Range.create(range.start, endPosition),
          newText: this.tmSnippet.toString()
        };
        this.update();
        return { edits: [snippetEdit], delta };
      }
      update() {
        const snippet = this.tmSnippet;
        const { line, character } = this.position;
        const document2 = TextDocument2.create("untitled:/1", "snippet", 0, snippet.toString());
        const { placeholders, variables, maxIndexNumber } = snippet;
        const variableIndexMap = new Map();
        let variableIndex = maxIndexNumber + 1;
        this._placeholders = [...placeholders, ...variables].map((p, idx) => {
          const offset = snippet.offset(p);
          const position = document2.positionAt(offset);
          const start = {
            line: line + position.line,
            character: position.line == 0 ? character + position.character : position.character
          };
          let index;
          if (p instanceof Variable) {
            let key = p.name;
            if (variableIndexMap.has(key)) {
              index = variableIndexMap.get(key);
            } else {
              variableIndexMap.set(key, variableIndex);
              index = variableIndex;
              variableIndex = variableIndex + 1;
            }
          } else {
            index = p.index;
          }
          const value = p.toString();
          const lines = value.split(/\r?\n/);
          let res = {
            range: import_vscode_languageserver_protocol71.Range.create(start, {
              line: start.line + lines.length - 1,
              character: lines.length == 1 ? start.character + value.length : lines[lines.length - 1].length
            }),
            transform: p.transform != null,
            line: start.line,
            id: idx,
            index,
            value,
            isVariable: p instanceof Variable,
            isFinalTabstop: p.index === 0
          };
          Object.defineProperty(res, "snippet", {
            enumerable: false
          });
          if (p instanceof Placeholder && p.choice) {
            let { options } = p.choice;
            if (options && options.length) {
              res.choice = options.map((o) => o.value);
            }
          }
          return res;
        });
      }
    };
  }
});

// src/snippets/variableResolve.ts
var import_path31, logger75, SnippetVariableResolver;
var init_variableResolve = __esm({
  "src/snippets/variableResolve.ts"() {
    import_path31 = __toModule(require("path"));
    init_window();
    logger75 = require_logger2()("snippets-variable");
    SnippetVariableResolver = class {
      constructor() {
        this._variableToValue = {};
        const currentDate = new Date();
        Object.assign(this._variableToValue, {
          CURRENT_YEAR: currentDate.getFullYear().toString(),
          CURRENT_YEAR_SHORT: currentDate.getFullYear().toString().slice(-2),
          CURRENT_MONTH: (currentDate.getMonth() + 1).toString(),
          CURRENT_DATE: currentDate.getDate().toString(),
          CURRENT_HOUR: currentDate.getHours().toString(),
          CURRENT_MINUTE: currentDate.getMinutes().toString(),
          CURRENT_SECOND: currentDate.getSeconds().toString(),
          CURRENT_DAY_NAME: currentDate.toLocaleString("en-US", { weekday: "long" }),
          CURRENT_DAY_NAME_SHORT: currentDate.toLocaleString("en-US", { weekday: "short" }),
          CURRENT_MONTH_NAME: currentDate.toLocaleString("en-US", { month: "long" }),
          CURRENT_MONTH_NAME_SHORT: currentDate.toLocaleString("en-US", { month: "short" }),
          TM_FILENAME: null,
          TM_FILENAME_BASE: null,
          TM_DIRECTORY: null,
          TM_FILEPATH: null,
          YANK: null,
          TM_LINE_INDEX: null,
          TM_LINE_NUMBER: null,
          TM_CURRENT_LINE: null,
          TM_CURRENT_WORD: null,
          TM_SELECTED_TEXT: null,
          CLIPBOARD: null
        });
      }
      async resovleValue(name2) {
        let { nvim } = window_default;
        if (["TM_FILENAME", "TM_FILENAME_BASE", "TM_DIRECTORY", "TM_FILEPATH"].includes(name2)) {
          let filepath = await nvim.eval('expand("%:p")');
          if (name2 == "TM_FILENAME")
            return import_path31.default.basename(filepath);
          if (name2 == "TM_FILENAME_BASE")
            return import_path31.default.basename(filepath, import_path31.default.extname(filepath));
          if (name2 == "TM_DIRECTORY")
            return import_path31.default.dirname(filepath);
          if (name2 == "TM_FILEPATH")
            return filepath;
        }
        if (name2 == "YANK") {
          let yank = await nvim.call("getreg", ['""']);
          return yank;
        }
        if (name2 == "TM_LINE_INDEX") {
          let lnum = await nvim.call("line", ["."]);
          return (lnum - 1).toString();
        }
        if (name2 == "TM_LINE_NUMBER") {
          let lnum = await nvim.call("line", ["."]);
          return lnum.toString();
        }
        if (name2 == "TM_CURRENT_LINE") {
          let line = await nvim.call("getline", ["."]);
          return line;
        }
        if (name2 == "TM_CURRENT_WORD") {
          let word = await nvim.eval(`expand('<cword>')`);
          return word;
        }
        if (name2 == "TM_SELECTED_TEXT") {
          let text = await nvim.eval(`get(g:,'coc_selected_text', '')`);
          return text;
        }
        if (name2 == "CLIPBOARD") {
          return await nvim.eval("@*");
        }
      }
      async resolve(variable) {
        const name2 = variable.name;
        let resolved = this._variableToValue[name2];
        if (resolved != null)
          return resolved.toString();
        let value = await this.resovleValue(name2);
        if (value)
          return value;
        if (variable.children && variable.children.length) {
          return variable.toString();
        }
        if (!this._variableToValue.hasOwnProperty(name2)) {
          return name2;
        }
        return "";
      }
    };
  }
});

// src/snippets/session.ts
function normalizeSnippetString(snippet, indent, opts) {
  let lines = snippet.split(/\r?\n/);
  let ind = opts.insertSpaces ? " ".repeat(opts.tabSize) : "	";
  let tabSize = opts.tabSize || 2;
  lines = lines.map((line, idx) => {
    let space = line.match(/^\s*/)[0];
    let pre = space;
    let isTab = space.startsWith("	");
    if (isTab && opts.insertSpaces) {
      pre = ind.repeat(space.length);
    } else if (!isTab && !opts.insertSpaces) {
      pre = ind.repeat(space.length / tabSize);
    }
    return (idx == 0 || line.length == 0 ? "" : indent) + pre + line.slice(space.length);
  });
  return lines.join("\n");
}
var import_vscode_languageserver_protocol72, logger76, SnippetSession;
var init_session2 = __esm({
  "src/snippets/session.ts"() {
    import_vscode_languageserver_protocol72 = __toModule(require_main2());
    init_completion();
    init_position();
    init_string();
    init_workspace();
    init_window();
    init_events();
    init_snippet();
    init_variableResolve();
    logger76 = require_logger2()("snippets-session");
    SnippetSession = class {
      constructor(nvim, bufnr) {
        this.nvim = nvim;
        this.bufnr = bufnr;
        this._isActive = false;
        this._currId = 0;
        this.applying = false;
        this.preferComplete = false;
        this._snippet = null;
        this._onCancelEvent = new import_vscode_languageserver_protocol72.Emitter();
        this.onCancel = this._onCancelEvent.event;
        let config = workspace_default.getConfiguration("coc.preferences");
        let suggest = workspace_default.getConfiguration("suggest");
        this.preferComplete = config.get("preferCompleteThanJumpPlaceholder", suggest.get("preferCompleteThanJumpPlaceholder", false));
      }
      async start(snippetString, select = true, range) {
        const { document: document2 } = this;
        if (!document2 || !document2.attached)
          return false;
        events_default.fire("InsertSnippet", []).logError();
        if (!range) {
          let position2 = await window_default.getCursorPosition();
          range = import_vscode_languageserver_protocol72.Range.create(position2, position2);
        }
        let position = range.start;
        const formatOptions = await workspace_default.getFormatOptions(this.document.uri);
        await document2.patchChange(true);
        const currentLine = document2.getline(position.line);
        const currentIndent = currentLine.match(/^\s*/)[0];
        let inserted = normalizeSnippetString(snippetString, currentIndent, formatOptions);
        const resolver = new SnippetVariableResolver();
        const snippet = new CocSnippet(inserted, position, resolver);
        await snippet.init();
        const edit2 = import_vscode_languageserver_protocol72.TextEdit.replace(range, snippet.toString());
        if (snippetString.endsWith("\n") && currentLine.slice(position.character).length) {
          edit2.newText = edit2.newText + currentIndent;
          inserted = inserted + currentIndent;
        }
        this.applying = true;
        await document2.applyEdits([edit2]);
        this.applying = false;
        if (this._isActive) {
          let placeholder = this.findPlaceholder(range);
          if (placeholder && !placeholder.isFinalTabstop) {
            let index = this.snippet.insertSnippet(placeholder, inserted, range);
            let p = this.snippet.getPlaceholder(index);
            this._currId = p.id;
            if (select)
              await this.selectPlaceholder(p);
            return true;
          }
        }
        if (snippet.isPlainText) {
          this.deactivate();
          let placeholder = snippet.finalPlaceholder;
          await window_default.moveTo(placeholder.range.start);
          return false;
        }
        this._snippet = snippet;
        this._currId = snippet.firstPlaceholder.id;
        if (select)
          await this.selectPlaceholder(snippet.firstPlaceholder);
        this.activate();
        return true;
      }
      activate() {
        if (this._isActive)
          return;
        this._isActive = true;
        this.nvim.call("coc#snippet#enable", [], true);
      }
      deactivate() {
        if (this._isActive) {
          this._isActive = false;
          this._snippet = null;
          this.nvim.call("coc#snippet#disable", [], true);
          logger76.debug("[SnippetManager::cancel]");
        }
        this._onCancelEvent.fire(void 0);
        this._onCancelEvent.dispose();
      }
      get isActive() {
        return this._isActive;
      }
      async nextPlaceholder() {
        if (!this.isActive)
          return;
        await this.document.patchChange();
        let curr = this.placeholder;
        let next = this.snippet.getNextPlaceholder(curr.index);
        await this.selectPlaceholder(next);
      }
      async previousPlaceholder() {
        if (!this.isActive)
          return;
        await this.document.patchChange();
        let curr = this.placeholder;
        let prev = this.snippet.getPrevPlaceholder(curr.index);
        await this.selectPlaceholder(prev);
      }
      async synchronizeUpdatedPlaceholders(change) {
        if (!this.isActive || !this.document || this.applying)
          return;
        let edit2 = { range: change.range, newText: change.text };
        let { snippet } = this;
        let adjusted = snippet.adjustTextEdit(edit2);
        if (adjusted)
          return;
        if (comparePosition(edit2.range.start, snippet.range.end) > 0) {
          if (!edit2.newText)
            return;
          logger76.info("Content change after snippet, cancelling snippet session");
          this.deactivate();
          return;
        }
        let placeholder = this.findPlaceholder(edit2.range);
        if (!placeholder) {
          logger76.info("Change outside placeholder, cancelling snippet session");
          this.deactivate();
          return;
        }
        if (placeholder.isFinalTabstop && snippet.finalCount <= 1) {
          logger76.info("Change final placeholder, cancelling snippet session");
          this.deactivate();
          return;
        }
        this._currId = placeholder.id;
        let { edits, delta } = snippet.updatePlaceholder(placeholder, edit2);
        if (!edits.length)
          return;
        this.applying = true;
        await this.document.applyEdits(edits);
        this.applying = false;
        if (delta) {
          await this.nvim.call("coc#util#move_cursor", delta);
        }
      }
      async selectCurrentPlaceholder(triggerAutocmd = true) {
        let placeholder = this.snippet.getPlaceholderById(this._currId);
        if (placeholder)
          await this.selectPlaceholder(placeholder, triggerAutocmd);
      }
      async selectPlaceholder(placeholder, triggerAutocmd = true) {
        let { nvim, document: document2 } = this;
        if (!document2 || !placeholder)
          return;
        let { start, end } = placeholder.range;
        const len = end.character - start.character;
        const col = byteLength(document2.getline(start.line).slice(0, start.character)) + 1;
        this._currId = placeholder.id;
        if (placeholder.choice) {
          await nvim.call("coc#snippet#show_choices", [start.line + 1, col, len, placeholder.choice]);
          if (triggerAutocmd)
            nvim.call("coc#util#do_autocmd", ["CocJumpPlaceholder"], true);
        } else {
          await this.select(placeholder, triggerAutocmd);
        }
      }
      async select(placeholder, triggerAutocmd = true) {
        let { range, value, isFinalTabstop } = placeholder;
        let { document: document2, nvim } = this;
        let { start, end } = range;
        let { textDocument } = document2;
        let len = textDocument.offsetAt(end) - textDocument.offsetAt(start);
        let line = document2.getline(start.line);
        let col = line ? byteLength(line.slice(0, start.character)) : 0;
        let endLine = document2.getline(end.line);
        let endCol = endLine ? byteLength(endLine.slice(0, end.character)) : 0;
        nvim.setVar("coc_last_placeholder", {
          current_text: value,
          start: { line: start.line, col },
          end: { line: end.line, col: endCol }
        }, true);
        let [ve, selection, pumvisible, mode] = await nvim.eval("[&virtualedit, &selection, pumvisible(), mode()]");
        let move_cmd = "";
        if (pumvisible && this.preferComplete) {
          let pre = completion_default.hasSelected() ? "" : "\\<C-n>";
          await nvim.eval(`feedkeys("${pre}\\<C-y>", 'in')`);
          return;
        }
        if (mode != "n")
          move_cmd += "\\<Esc>";
        if (len == 0) {
          if (col == 0 || !mode.startsWith("i") && col < byteLength(line)) {
            move_cmd += "i";
          } else {
            move_cmd += "a";
          }
        } else {
          move_cmd += "v";
          endCol = await this.getVirtualCol(end.line + 1, endCol);
          if (selection == "inclusive") {
            if (end.character == 0) {
              move_cmd += `${end.line}G`;
            } else {
              move_cmd += `${end.line + 1}G${endCol}|`;
            }
          } else if (selection == "old") {
            move_cmd += `${end.line + 1}G${endCol}|`;
          } else {
            move_cmd += `${end.line + 1}G${endCol + 1}|`;
          }
          col = await this.getVirtualCol(start.line + 1, col);
          move_cmd += `o${start.line + 1}G${col + 1}|o\\<c-g>`;
        }
        if (mode == "i" && move_cmd == "\\<Esc>a") {
          move_cmd = "";
        }
        nvim.pauseNotification();
        nvim.setOption("virtualedit", "onemore", true);
        nvim.call("cursor", [start.line + 1, col + (move_cmd == "a" ? 0 : 1)], true);
        if (move_cmd) {
          nvim.call("eval", [`feedkeys("${move_cmd}", 'in')`], true);
        }
        if (mode == "i") {
          nvim.call("coc#_cancel", [], true);
        }
        nvim.setOption("virtualedit", ve, true);
        if (isFinalTabstop) {
          if (this.snippet.finalCount == 1) {
            logger76.info("Jump to final placeholder, cancelling snippet session");
            this.deactivate();
          } else {
            nvim.call("coc#snippet#disable", [], true);
          }
        }
        if (workspace_default.env.isVim)
          nvim.command("redraw", true);
        await nvim.resumeNotification();
        if (triggerAutocmd)
          nvim.call("coc#util#do_autocmd", ["CocJumpPlaceholder"], true);
      }
      async getVirtualCol(line, col) {
        let { nvim } = this;
        return await nvim.eval(`virtcol([${line}, ${col}])`);
      }
      async checkPosition() {
        if (!this.isActive)
          return;
        let position = await window_default.getCursorPosition();
        if (this.snippet && positionInRange(position, this.snippet.range) != 0) {
          logger76.info("Cursor insert out of range, cancelling snippet session");
          this.deactivate();
        }
      }
      findPlaceholder(range) {
        if (!this.snippet)
          return null;
        let { placeholder } = this;
        if (placeholder && rangeInRange(range, placeholder.range))
          return placeholder;
        return this.snippet.getPlaceholderByRange(range) || null;
      }
      get placeholder() {
        if (!this.snippet)
          return null;
        return this.snippet.getPlaceholderById(this._currId);
      }
      get snippet() {
        return this._snippet;
      }
      get document() {
        return workspace_default.getDocument(this.bufnr);
      }
    };
  }
});

// src/snippets/manager.ts
var logger77, SnippetManager, manager_default2;
var init_manager4 = __esm({
  "src/snippets/manager.ts"() {
    init_events();
    init_workspace();
    init_window();
    init_parser2();
    init_session2();
    init_variableResolve();
    logger77 = require_logger2()("snippets-manager");
    SnippetManager = class {
      constructor() {
        this.sessionMap = new Map();
        this.disposables = [];
        workspace_default.onDidChangeTextDocument(async (e) => {
          let session = this.getSession(e.bufnr);
          if (session) {
            await session.synchronizeUpdatedPlaceholders(e.contentChanges[0]);
          }
        }, null, this.disposables);
        workspace_default.onDidCloseTextDocument((textDocument) => {
          let doc = workspace_default.getDocument(textDocument.uri);
          if (!doc)
            return;
          let session = this.getSession(doc.bufnr);
          if (session)
            session.deactivate();
        }, null, this.disposables);
        events_default.on("BufEnter", async (bufnr) => {
          let session = this.getSession(bufnr);
          if (!this.statusItem)
            return;
          if (session && session.isActive) {
            this.statusItem.show();
          } else {
            this.statusItem.hide();
          }
        }, null, this.disposables);
        events_default.on("InsertEnter", async () => {
          let { session } = this;
          if (!session)
            return;
          await session.checkPosition();
        }, null, this.disposables);
      }
      init() {
        let config = workspace_default.getConfiguration("coc.preferences");
        this.statusItem = window_default.createStatusBarItem(0);
        this.statusItem.text = config.get("snippetStatusText", "SNIP");
      }
      async insertSnippet(snippet, select = true, range) {
        let { bufnr } = workspace_default;
        let session = this.getSession(bufnr);
        if (!session) {
          session = new SnippetSession(workspace_default.nvim, bufnr);
          this.sessionMap.set(bufnr, session);
          session.onCancel(() => {
            this.sessionMap.delete(bufnr);
            if (workspace_default.bufnr == bufnr) {
              this.statusItem.hide();
            }
          });
        }
        let isActive = await session.start(snippet, select, range);
        if (isActive)
          this.statusItem.show();
        return isActive;
      }
      async selectCurrentPlaceholder(triggerAutocmd = true) {
        let { session } = this;
        if (session)
          return await session.selectCurrentPlaceholder(triggerAutocmd);
      }
      async nextPlaceholder() {
        let { session } = this;
        if (session)
          return await session.nextPlaceholder();
        workspace_default.nvim.call("coc#snippet#disable", [], true);
        this.statusItem.hide();
      }
      async previousPlaceholder() {
        let { session } = this;
        if (session)
          return await session.previousPlaceholder();
        workspace_default.nvim.call("coc#snippet#disable", [], true);
        this.statusItem.hide();
      }
      cancel() {
        let session = this.getSession(workspace_default.bufnr);
        if (session)
          return session.deactivate();
        workspace_default.nvim.call("coc#snippet#disable", [], true);
        if (this.statusItem)
          this.statusItem.hide();
      }
      get session() {
        let session = this.getSession(workspace_default.bufnr);
        return session && session.isActive ? session : null;
      }
      isActived(bufnr) {
        let session = this.getSession(bufnr);
        return session && session.isActive;
      }
      jumpable() {
        let { session } = this;
        if (!session)
          return false;
        let placeholder = session.placeholder;
        if (placeholder && !placeholder.isFinalTabstop) {
          return true;
        }
        return false;
      }
      getSession(bufnr) {
        return this.sessionMap.get(bufnr);
      }
      async resolveSnippet(body) {
        let parser2 = new SnippetParser();
        const snippet = parser2.parse(body, true);
        const resolver = new SnippetVariableResolver();
        await snippet.resolveVariables(resolver);
        return snippet;
      }
      dispose() {
        this.cancel();
        for (let d of this.disposables) {
          d.dispose();
        }
      }
    };
    manager_default2 = new SnippetManager();
  }
});

// src/commands.ts
var import_vscode_languageserver_protocol73, logger78, CommandItem, CommandManager, commands_default;
var init_commands2 = __esm({
  "src/commands.ts"() {
    import_vscode_languageserver_protocol73 = __toModule(require_main2());
    init_esm2();
    init_manager();
    init_manager4();
    init_util();
    init_workspace();
    init_window();
    logger78 = require_logger2()("commands");
    CommandItem = class {
      constructor(id, impl, thisArg, internal = false) {
        this.id = id;
        this.impl = impl;
        this.thisArg = thisArg;
        this.internal = internal;
      }
      execute(...args) {
        let { impl, thisArg } = this;
        return impl.apply(thisArg, args || []);
      }
      dispose() {
        this.thisArg = null;
        this.impl = null;
      }
    };
    CommandManager = class {
      constructor() {
        this.commands = new Map();
        this.titles = new Map();
        this.onCommandList = [];
      }
      init(nvim, plugin) {
        this.mru = workspace_default.createMru("commands");
        this.register({
          id: "vscode.open",
          execute: async (url) => {
            nvim.call("coc#util#open_url", url.toString(), true);
          }
        }, true);
        this.register({
          id: "workbench.action.reloadWindow",
          execute: async () => {
            await nvim.command("edit");
          }
        }, true);
        this.register({
          id: "editor.action.insertSnippet",
          execute: async (edit2) => {
            nvim.call("coc#_cancel", [], true);
            return await manager_default2.insertSnippet(edit2.newText, true, edit2.range);
          }
        }, true);
        this.register({
          id: "editor.action.doCodeAction",
          execute: async (action) => {
            await plugin.cocAction("doCodeAction", action);
          }
        }, true);
        this.register({
          id: "editor.action.triggerSuggest",
          execute: async () => {
            await wait(60);
            nvim.call("coc#start", [], true);
          }
        }, true);
        this.register({
          id: "editor.action.triggerParameterHints",
          execute: async () => {
            await wait(60);
            await plugin.cocAction("showSignatureHelp");
          }
        }, true);
        this.register({
          id: "editor.action.addRanges",
          execute: async (ranges) => {
            await plugin.cocAction("addRanges", ranges);
          }
        }, true);
        this.register({
          id: "editor.action.restart",
          execute: async () => {
            await wait(30);
            nvim.command("CocRestart", true);
          }
        }, true);
        this.register({
          id: "editor.action.showReferences",
          execute: async (_filepath, _position, references) => {
            await workspace_default.showLocations(references);
          }
        }, true);
        this.register({
          id: "editor.action.rename",
          execute: async (uri, position) => {
            await workspace_default.jumpTo(uri, position);
            await plugin.cocAction("rename");
          }
        }, true);
        this.register({
          id: "editor.action.format",
          execute: async () => {
            await plugin.cocAction("format");
          }
        }, true);
        this.register({
          id: "workspace.diffDocument",
          execute: async () => {
            let document2 = await workspace_default.document;
            if (!document2)
              return;
            await nvim.call("coc#util#diff_content", [document2.getLines()]);
          }
        });
        this.register({
          id: "workspace.clearWatchman",
          execute: async () => {
            let res = await window_default.runTerminalCommand("watchman watch-del-all");
            if (res.success)
              window_default.showMessage("Cleared watchman watching directories.");
          }
        }, false, "run watch-del-all for watchman to free up memory.");
        this.register({
          id: "workspace.workspaceFolders",
          execute: async () => {
            let folders = workspace_default.workspaceFolders;
            let lines = folders.map((folder) => URI.parse(folder.uri).fsPath);
            await window_default.echoLines(lines);
          }
        }, false, "show opened workspaceFolders.");
        this.register({
          id: "workspace.renameCurrentFile",
          execute: async () => {
            await workspace_default.renameCurrent();
          }
        }, false, "change current filename to a new name and reload it.");
        this.register({
          id: "extensions.toggleAutoUpdate",
          execute: async () => {
            let config = workspace_default.getConfiguration("coc.preferences");
            let interval = config.get("extensionUpdateCheck", "daily");
            if (interval == "never") {
              config.update("extensionUpdateCheck", "daily", true);
              window_default.showMessage("Extension auto update enabled.", "more");
            } else {
              config.update("extensionUpdateCheck", "never", true);
              window_default.showMessage("Extension auto update disabled.", "more");
            }
          }
        }, false, "toggle auto update of extensions.");
        this.register({
          id: "workspace.diagnosticRelated",
          execute: () => manager_default.jumpRelated()
        }, false, "jump to related locations of current diagnostic.");
        this.register({
          id: "workspace.showOutput",
          execute: async (name2) => {
            if (name2) {
              window_default.showOutputChannel(name2);
            } else {
              let names = workspace_default.channelNames;
              if (names.length == 0)
                return;
              if (names.length == 1) {
                window_default.showOutputChannel(names[0]);
              } else {
                let idx = await window_default.showQuickpick(names);
                if (idx == -1)
                  return;
                let name3 = names[idx];
                window_default.showOutputChannel(name3);
              }
            }
          }
        }, false, "open output buffer to show output from languageservers or extensions.");
        this.register({
          id: "document.echoFiletype",
          execute: async () => {
            let bufnr = await nvim.call("bufnr", "%");
            let doc = workspace_default.getDocument(bufnr);
            if (!doc)
              return;
            await window_default.echoLines([doc.filetype]);
          }
        }, false, "echo the mapped filetype of the current buffer");
        this.register({
          id: "document.renameCurrentWord",
          execute: async () => {
            let bufnr = await nvim.call("bufnr", "%");
            let doc = workspace_default.getDocument(bufnr);
            if (!doc)
              return;
            let edit2 = await plugin.cocAction("getWordEdit");
            if (!edit2) {
              window_default.showMessage("Invalid position", "warning");
              return;
            }
            let ranges = [];
            let { changes, documentChanges } = edit2;
            if (changes) {
              let edits = changes[doc.uri];
              if (edits)
                ranges = edits.map((e) => e.range);
            } else if (documentChanges) {
              for (let c of documentChanges) {
                if (import_vscode_languageserver_protocol73.TextDocumentEdit.is(c) && c.textDocument.uri == doc.uri) {
                  ranges = c.edits.map((e) => e.range);
                }
              }
            }
            if (ranges.length) {
              await plugin.cocAction("addRanges", ranges);
            }
          }
        }, false, "rename word under cursor in current buffer by use multiple cursors.");
        this.register({
          id: "document.jumpToNextSymbol",
          execute: async () => {
            let doc = await workspace_default.document;
            if (!doc)
              return;
            let ranges = await plugin.cocAction("symbolRanges");
            if (!ranges)
              return;
            let { textDocument } = doc;
            let offset = await window_default.getOffset();
            ranges.sort((a, b) => {
              if (a.start.line != b.start.line) {
                return a.start.line - b.start.line;
              }
              return a.start.character - b.start.character;
            });
            for (let i = 0; i <= ranges.length - 1; i++) {
              if (textDocument.offsetAt(ranges[i].start) > offset) {
                await window_default.moveTo(ranges[i].start);
                return;
              }
            }
            await window_default.moveTo(ranges[0].start);
          }
        }, false, "Jump to next symbol highlight position.");
        this.register({
          id: "document.jumpToPrevSymbol",
          execute: async () => {
            let doc = await workspace_default.document;
            if (!doc)
              return;
            let ranges = await plugin.cocAction("symbolRanges");
            if (!ranges)
              return;
            let { textDocument } = doc;
            let offset = await window_default.getOffset();
            ranges.sort((a, b) => {
              if (a.start.line != b.start.line) {
                return a.start.line - b.start.line;
              }
              return a.start.character - b.start.character;
            });
            for (let i = ranges.length - 1; i >= 0; i--) {
              if (textDocument.offsetAt(ranges[i].end) < offset) {
                await window_default.moveTo(ranges[i].start);
                return;
              }
            }
            await window_default.moveTo(ranges[ranges.length - 1].start);
          }
        }, false, "Jump to previous symbol highlight position.");
      }
      get commandList() {
        let res = [];
        for (let item of this.commands.values()) {
          if (!item.internal)
            res.push(item);
        }
        return res;
      }
      dispose() {
        for (const registration of this.commands.values()) {
          registration.dispose();
        }
        this.commands.clear();
      }
      execute(command) {
        let args = [command.command];
        let arr = command.arguments;
        if (arr)
          args.push(...arr);
        this.executeCommand.apply(this, args);
      }
      register(command, internal = false, description) {
        for (const id of Array.isArray(command.id) ? command.id : [command.id]) {
          this.registerCommand(id, command.execute, command, internal);
          if (description)
            this.titles.set(id, description);
        }
        return command;
      }
      has(id) {
        return this.commands.has(id);
      }
      unregister(id) {
        let item = this.commands.get(id);
        if (!item)
          return;
        item.dispose();
        this.commands.delete(id);
      }
      registerCommand(id, impl, thisArg, internal = false) {
        if (id.startsWith("_"))
          internal = true;
        this.commands.set(id, new CommandItem(id, impl, thisArg, internal));
        return import_vscode_languageserver_protocol73.Disposable.create(() => {
          this.commands.delete(id);
        });
      }
      executeCommand(command, ...rest) {
        let cmd = this.commands.get(command);
        if (!cmd)
          throw new Error(`Command: ${command} not found`);
        return Promise.resolve(cmd.execute.apply(cmd, rest));
      }
      async addRecent(cmd) {
        await this.mru.add(cmd);
        await workspace_default.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`);
      }
      async repeatCommand() {
        let mruList = await this.mru.load();
        let first = mruList[0];
        if (first) {
          await this.executeCommand(first);
          await workspace_default.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`);
        }
      }
    };
    commands_default = new CommandManager();
  }
});

// src/cursors/range.ts
var logger79, TextRange;
var init_range = __esm({
  "src/cursors/range.ts"() {
    init_main();
    init_position();
    logger79 = require_logger2()("cursors-range");
    TextRange = class {
      constructor(line, start, end, text, preCount) {
        this.line = line;
        this.start = start;
        this.end = end;
        this.text = text;
        this.preCount = preCount;
        this.currStart = start;
        this.currEnd = end;
      }
      add(offset, add) {
        let { text, preCount } = this;
        let pre = offset == 0 ? "" : text.slice(0, offset);
        let post = text.slice(offset);
        this.text = `${pre}${add}${post}`;
        this.currStart = this.currStart + preCount * add.length;
        this.currEnd = this.currEnd + (preCount + 1) * add.length;
      }
      replace(begin, end, add = "") {
        let { text, preCount } = this;
        let pre = begin == 0 ? "" : text.slice(0, begin);
        let post = text.slice(end);
        this.text = pre + add + post;
        let l = end - begin - add.length;
        this.currStart = this.currStart - preCount * l;
        this.currEnd = this.currEnd - (preCount + 1) * l;
      }
      get range() {
        return Range.create(this.line, this.start, this.line, this.end);
      }
      get currRange() {
        return Range.create(this.line, this.currStart, this.line, this.currEnd);
      }
      applyEdit(edit2) {
        let { range, newText } = edit2;
        let start = range.start.character;
        let end = range.end.character;
        let isAdd = start == end;
        if (isAdd) {
          this.add(start - this.currStart, newText);
        } else {
          this.replace(start - this.currStart, end - this.currStart, newText);
        }
      }
      adjustFromEdit(edit2) {
        let { range, newText } = edit2;
        if (comparePosition(range.start, Position.create(this.line, this.currEnd)) > 0) {
          return;
        }
        let newLines = newText.split("\n");
        let changeCount = newLines.length - (range.end.line - range.start.line + 1);
        this.line = this.line + changeCount;
        if (range.end.line == this.line) {
          let remove = range.start.line == range.end.line ? range.end.character - range.start.character : range.end.character;
          if (newLines.length > 1 && range.start.line == range.end.line) {
            remove = remove + range.start.character;
          }
          let add = 0;
          if (newLines.length > 1) {
            add = newLines[newLines.length - 1].length;
          } else {
            if (range.start.line == range.end.line) {
              add = newText.length;
            } else {
              add = range.start.character + newText.length;
            }
          }
          let delta = add - remove;
          for (let key of ["start", "end", "currStart", "currEnd"]) {
            this[key] += delta;
          }
        }
      }
      sync() {
        this.start = this.currStart;
        this.end = this.currEnd;
      }
      get textEdit() {
        return {
          range: this.range,
          newText: this.text
        };
      }
    };
  }
});

// src/cursors/util.ts
function splitRange(doc, range) {
  let splited = [];
  for (let i = range.start.line; i <= range.end.line; i++) {
    let curr = doc.getline(i) || "";
    let sc = i == range.start.line ? range.start.character : 0;
    let ec = i == range.end.line ? range.end.character : curr.length;
    if (sc == ec)
      continue;
    splited.push(import_vscode_languageserver_protocol74.Range.create(i, sc, i, ec));
  }
  return splited;
}
function getVisualRanges(doc, range) {
  let { start, end } = range;
  if (start.line > end.line) {
    [start, end] = [end, start];
  }
  let sc = start.character < end.character ? start.character : end.character;
  let ec = start.character < end.character ? end.character : start.character;
  let ranges = [];
  for (let i = start.line; i <= end.line; i++) {
    let line = doc.getline(i);
    ranges.push(import_vscode_languageserver_protocol74.Range.create(i, sc, i, Math.min(line.length, ec)));
  }
  return ranges;
}
function adjustPosition2(position, delta) {
  let { line, character } = delta;
  return import_vscode_languageserver_protocol74.Position.create(position.line + line, line == 0 ? position.character + character : character);
}
function equalEdit(one, two) {
  if (one.newText.length != two.newText.length)
    return false;
  let { range } = one;
  if (range.end.character - range.start.character != two.range.end.character - two.range.start.character) {
    return false;
  }
  return true;
}
var import_vscode_languageserver_protocol74;
var init_util4 = __esm({
  "src/cursors/util.ts"() {
    import_vscode_languageserver_protocol74 = __toModule(require_main2());
  }
});

// src/cursors/session.ts
var import_fast_diff4, import_vscode_languageserver_protocol75, logger80, CursorSession;
var init_session3 = __esm({
  "src/cursors/session.ts"() {
    import_fast_diff4 = __toModule(require_diff2());
    import_vscode_languageserver_protocol75 = __toModule(require_main2());
    init_main2();
    init_events();
    init_position();
    init_window();
    init_workspace();
    init_range();
    init_util4();
    logger80 = require_logger2()("cursors-session");
    CursorSession = class {
      constructor(nvim, doc, config) {
        this.nvim = nvim;
        this.doc = doc;
        this.config = config;
        this._onDidCancel = new import_vscode_languageserver_protocol75.Emitter();
        this.onDidCancel = this._onDidCancel.event;
        this.disposables = [];
        this.ranges = [];
        this.activated = true;
        this.changing = false;
        this.changed = false;
        this.doc.forceSync();
        this.textDocument = this.doc.textDocument;
        this.buffer.setVar("coc_cursors_activated", 1, true);
        let { cancelKey, nextKey, previousKey } = this.config;
        this.disposables.push(workspace_default.registerLocalKeymap("n", cancelKey, () => {
          this.cancel();
        }, true));
        this.disposables.push(workspace_default.registerLocalKeymap("n", nextKey, async () => {
          if (!this.activated)
            return;
          let ranges = this.ranges.map((o) => o.currRange);
          let curr = await window_default.getCursorPosition();
          for (let r of ranges) {
            if (comparePosition(r.start, curr) > 0) {
              await window_default.moveTo(r.start);
              return;
            }
          }
          if (ranges.length)
            await window_default.moveTo(ranges[0].start);
        }, true));
        this.disposables.push(workspace_default.registerLocalKeymap("n", previousKey, async () => {
          if (!this.activated)
            return;
          let ranges = this.ranges.map((o) => o.currRange);
          ranges.reverse();
          let curr = await window_default.getCursorPosition();
          for (let r of ranges) {
            if (comparePosition(r.end, curr) < 0) {
              await window_default.moveTo(r.start);
              return;
            }
          }
          if (ranges.length)
            await window_default.moveTo(ranges[ranges.length - 1].start);
        }, true));
        this.doc.onDocumentChange(this.onChange, this, this.disposables);
      }
      async onChange(e) {
        if (!this.activated || this.ranges.length == 0)
          return;
        if (this.changing)
          return;
        let change = e.contentChanges[0];
        let { text, range } = change;
        let intersect = this.ranges.some((r) => rangeIntersect(range, r.currRange));
        let begin = this.ranges[0].currRange.start;
        if (text.endsWith("\n") && comparePosition(begin, range.end) == 0) {
          intersect = false;
        }
        if (!intersect) {
          this.ranges.forEach((r) => {
            r.adjustFromEdit({ range, newText: text });
          });
          this.doHighlights();
          this.textDocument = this.doc.textDocument;
          return;
        }
        this.changed = true;
        let textRange = this.getTextRange(range, text);
        if (textRange) {
          await this.applySingleEdit(textRange, { range, newText: text });
        } else {
          this.applyComposedEdit(e.original, { range, newText: text });
          if (this.activated) {
            this.ranges.forEach((r) => {
              r.sync();
            });
            this.textDocument = this.doc.textDocument;
          }
        }
      }
      doHighlights() {
        let { nvim, buffer, ranges } = this;
        buffer.clearNamespace("cursors");
        let arr = ranges.map((o) => o.currRange);
        buffer.highlightRanges("cursors", "CocCursorRange", arr);
        nvim.command("redraw", true);
      }
      addRanges(ranges) {
        let { nvim, doc } = this;
        if (this.changed) {
          window_default.showMessage(`Can't add ranges after range change.`);
          return false;
        }
        this.ranges = this.ranges.filter((r) => {
          let { currRange } = r;
          return !ranges.some((range) => rangeOverlap(range, currRange));
        });
        let { textDocument } = doc;
        for (let range of ranges) {
          let { line } = range.start;
          let textRange = new TextRange(line, range.start.character, range.end.character, textDocument.getText(range), 0);
          this.ranges.push(textRange);
        }
        this.ranges.sort((a, b) => comparePosition(a.range.start, b.range.start));
        let preCount = 0;
        let currline = -1;
        for (let range of this.ranges) {
          let { line } = range;
          if (line != currline) {
            preCount = 0;
          }
          range.preCount = preCount;
          preCount = preCount + 1;
          currline = line;
        }
        nvim.pauseNotification();
        this.doHighlights();
        nvim.resumeNotification(false, true);
        return true;
      }
      cancel() {
        if (!this.activated)
          return;
        let { nvim } = this;
        this.activated = false;
        let { cancelKey, nextKey, previousKey } = this.config;
        nvim.pauseNotification();
        this.buffer.clearNamespace("cursors");
        this.buffer.setVar("coc_cursors_activated", 0, true);
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
        this._onDidCancel.fire();
      }
      dispose() {
        if (!this.doc)
          return;
        this._onDidCancel.dispose();
        for (let disposable of this.disposables) {
          disposable.dispose();
        }
        this.ranges = [];
        this.doc = null;
        this.textDocument = null;
      }
      get buffer() {
        return this.nvim.createBuffer(this.doc.bufnr);
      }
      getTextRange(range, text) {
        let { ranges } = this;
        if (text.indexOf("\n") !== -1 || range.start.line != range.end.line) {
          return null;
        }
        ranges.sort((a, b) => {
          if (a.line != b.line)
            return a.line - b.line;
          return a.currRange.start.character - b.currRange.start.character;
        });
        for (let i = 0; i < ranges.length; i++) {
          let r = ranges[i];
          if (rangeInRange(range, r.currRange)) {
            return r;
          }
          if (r.line != range.start.line) {
            continue;
          }
          if (text.length && range.start.character == r.currRange.end.character) {
            let next = ranges[i + 1];
            if (!next)
              return r;
            return positionInRange(next.currRange.start, range) ? null : r;
          }
        }
        return null;
      }
      adjustRanges(textRange, range, text) {
        let { ranges } = this;
        if (range.start.character == range.end.character) {
          let isEnd = textRange.currRange.end.character == range.start.character;
          if (isEnd) {
            ranges.forEach((r) => {
              r.add(r.text.length, text);
            });
          } else {
            let d = range.start.character - textRange.currRange.start.character;
            ranges.forEach((r) => {
              r.add(Math.min(r.text.length, d), text);
            });
          }
        } else {
          let d = range.end.character - range.start.character;
          let isEnd = textRange.currRange.end.character == range.end.character;
          if (isEnd) {
            if (textRange.currRange.start.character == range.start.character) {
              if (text.includes(textRange.text)) {
                let idx = text.indexOf(textRange.text);
                let pre = idx == 0 ? "" : text.slice(0, idx);
                let post = text.slice(idx + textRange.text.length);
                if (pre)
                  ranges.forEach((r) => r.add(0, pre));
                if (post)
                  ranges.forEach((r) => r.add(r.text.length, post));
              } else if (textRange.text.includes(text)) {
                let idx = textRange.text.indexOf(text);
                let offset = textRange.text.length - (idx + text.length);
                if (idx != 0)
                  ranges.forEach((r) => r.replace(0, idx));
                if (offset > 0)
                  ranges.forEach((r) => r.replace(r.text.length - offset, r.text.length));
              } else {
                this.cancel();
              }
            } else {
              ranges.forEach((r) => {
                let l = r.text.length;
                r.replace(Math.max(0, l - d), l, text);
              });
            }
          } else {
            let start = range.start.character - textRange.currRange.start.character;
            ranges.forEach((r) => {
              let l = r.text.length;
              r.replace(start, Math.min(start + d, l), text);
            });
          }
        }
      }
      addRange(range, text) {
        if (this.changed) {
          window_default.showMessage(`Can't add range after range change.`);
          return;
        }
        let { ranges } = this;
        let idx = ranges.findIndex((o) => rangeIntersect(o.range, range));
        if (idx !== -1) {
          ranges.splice(idx, 1);
          for (let r of ranges) {
            if (r.line == range.start.line && r.start > range.start.character) {
              r.preCount = r.preCount - 1;
            }
          }
        } else {
          let preCount = 0;
          let idx2 = 0;
          let { line } = range.start;
          for (let r of ranges) {
            if (r.line > line || r.line == line && r.start > range.end.character) {
              break;
            }
            if (r.line == line)
              preCount++;
            idx2++;
          }
          let created = new TextRange(line, range.start.character, range.end.character, text, preCount);
          ranges.splice(idx2, 0, created);
          for (let r of ranges) {
            if (r.line == range.start.line && r.start > range.start.character) {
              r.preCount = r.preCount + 1;
            }
          }
        }
        if (this.ranges.length == 0) {
          this.cancel();
        } else {
          this.doHighlights();
        }
      }
      async applySingleEdit(textRange, edit2) {
        let { range, newText } = edit2;
        let { doc } = this;
        this.adjustRanges(textRange, range, newText);
        if (this.ranges.length == 1) {
          this.doHighlights();
          return;
        }
        let edits = this.ranges.map((o) => o.textEdit);
        let content = TextDocument2.applyEdits(this.textDocument, edits);
        let newLines = content.split("\n");
        let changedLnum = new Set();
        let arr = [];
        for (let r of this.ranges) {
          if (!changedLnum.has(r.line)) {
            changedLnum.add(r.line);
            arr.push([r.line, newLines[r.line]]);
          }
        }
        let { nvim } = this;
        this.changing = true;
        await doc.changeLines(arr);
        this.changing = false;
        if (this.activated) {
          this.ranges.forEach((r) => {
            r.sync();
          });
          this.textDocument = this.doc.textDocument;
        }
        nvim.pauseNotification();
        let { cursor } = events_default;
        if (textRange.preCount > 0 && cursor.bufnr == doc.bufnr && textRange.line + 1 == cursor.lnum) {
          let changed = textRange.preCount * (newText.length - (range.end.character - range.start.character));
          nvim.call("cursor", [cursor.lnum, cursor.col + changed], true);
        }
        this.doHighlights();
        nvim.resumeNotification(false, true);
      }
      applyComposedEdit(original, edit2) {
        let { range, newText } = edit2;
        let { ranges } = this;
        let doc = TextDocument2.create("file:///1", "", 0, original);
        let edits = [];
        let diffs = (0, import_fast_diff4.default)(original, newText);
        let offset = 0;
        for (let i = 0; i < diffs.length; i++) {
          let diff = diffs[i];
          let pos = adjustPosition2(range.start, doc.positionAt(offset));
          if (diff[0] == import_fast_diff4.default.EQUAL) {
            offset = offset + diff[1].length;
          } else if (diff[0] == import_fast_diff4.default.DELETE) {
            let end = adjustPosition2(range.start, doc.positionAt(offset + diff[1].length));
            if (diffs[i + 1] && diffs[i + 1][0] == import_fast_diff4.default.INSERT) {
              edits.push({ range: import_vscode_languageserver_protocol75.Range.create(pos, end), newText: diffs[i + 1][1] });
              i = i + 1;
            } else {
              edits.push({ range: import_vscode_languageserver_protocol75.Range.create(pos, end), newText: "" });
            }
            offset = offset + diff[1].length;
          } else if (diff[0] == import_fast_diff4.default.INSERT) {
            edits.push({ range: import_vscode_languageserver_protocol75.Range.create(pos, pos), newText: diff[1] });
          }
        }
        if (edits.some((edit3) => edit3.newText.includes("\n") || edit3.range.start.line != edit3.range.end.line)) {
          this.cancel();
          return;
        }
        if (edits.length == ranges.length) {
          let last;
          for (let i = 0; i < edits.length; i++) {
            let edit3 = edits[i];
            let textRange = this.ranges[i];
            if (!rangeIntersect(textRange.currRange, edit3.range)) {
              this.cancel();
              return;
            }
            if (last && !equalEdit(edit3, last)) {
              this.cancel();
              return;
            }
            textRange.applyEdit(edit3);
            last = edit3;
          }
        } else if (edits.length == ranges.length * 2) {
          for (let i = 0; i < edits.length - 1; i = i + 2) {
            let edit3 = edits[i];
            let next = edits[i + 1];
            if (edit3.newText.length == 0 && next.newText.length == 0) {
              let textRange = this.ranges[i / 2];
              if (comparePosition(textRange.currRange.end, next.range.end) != 0) {
                this.cancel();
                return;
              }
              let start = edit3.range.start.character - textRange.currRange.start.character;
              textRange.replace(start, edit3.range.end.character - edit3.range.start.character, "");
              let offset2 = next.range.end.character - next.range.start.character;
              let len = textRange.text.length;
              textRange.replace(len - offset2, len);
            } else if (emptyRange(edit3.range) && emptyRange(next.range)) {
              let textRange = this.ranges[i / 2];
              if (comparePosition(textRange.currRange.end, next.range.start) != 0) {
                this.cancel();
                return;
              }
              let start = edit3.range.start.character - textRange.currRange.start.character;
              textRange.add(start, edit3.newText);
              let len = textRange.text.length;
              textRange.add(len, next.newText);
            } else {
              this.cancel();
              return;
            }
          }
        } else {
          this.cancel();
          return;
        }
        this.doHighlights();
      }
    };
  }
});

// src/cursors/index.ts
var logger81, Cursors;
var init_cursors = __esm({
  "src/cursors/index.ts"() {
    init_main();
    init_events();
    init_position();
    init_window();
    init_workspace();
    init_session3();
    init_util4();
    logger81 = require_logger2()("cursors");
    Cursors = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.sessionsMap = new Map();
        this.disposables = [];
        this.loadConfig();
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("cursors")) {
            this.loadConfig();
          }
        }, null, this.disposables);
        events_default.on("BufUnload", (bufnr) => {
          let session = this.getSession(bufnr);
          if (!session)
            return;
          session.dispose();
          this.sessionsMap.delete(bufnr);
        }, null, this.disposables);
      }
      loadConfig() {
        let config = workspace_default.getConfiguration("cursors");
        this.config = {
          nextKey: config.get("nextKey", "<C-n>"),
          previousKey: config.get("previousKey", "<C-p>"),
          cancelKey: config.get("cancelKey", "<esc>")
        };
      }
      getSession(bufnr) {
        return this.sessionsMap.get(bufnr);
      }
      async isActivated() {
        let bufnr = await this.nvim.call("bufnr", ["%"]);
        return this.sessionsMap.get(bufnr) != null;
      }
      async select(bufnr, kind, mode) {
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached) {
          window_default.showMessage(`buffer ${bufnr} not attached.`);
          return;
        }
        let { nvim } = this;
        let session = this.createSession(doc);
        let pos = await window_default.getCursorPosition();
        let range;
        if (kind == "operator") {
          await nvim.command(`normal! ${mode == "line" ? `'[` : "`["}`);
          let start = await window_default.getCursorPosition();
          await nvim.command(`normal! ${mode == "line" ? `']` : "`]"}`);
          let end = await window_default.getCursorPosition();
          await window_default.moveTo(pos);
          let relative = comparePosition(start, end);
          if (relative == 0)
            return;
          if (relative >= 0)
            [start, end] = [end, start];
          let line = doc.getline(end.line);
          if (end.character < line.length) {
            end.character = end.character + 1;
          }
          let ranges = splitRange(doc, Range.create(start, end));
          for (let r of ranges) {
            let text = doc.textDocument.getText(r);
            session.addRange(r, text);
          }
        } else if (kind == "word") {
          range = doc.getWordRangeAtPosition(pos);
          if (!range) {
            let line2 = doc.getline(pos.line);
            if (pos.character == line2.length) {
              range = Range.create(pos.line, Math.max(0, line2.length - 1), pos.line, line2.length);
            } else {
              range = Range.create(pos.line, pos.character, pos.line, pos.character + 1);
            }
          }
          let line = doc.getline(pos.line);
          let text = line.slice(range.start.character, range.end.character);
          session.addRange(range, text);
        } else if (kind == "position") {
          let line = doc.getline(pos.line);
          if (pos.character >= line.length) {
            range = Range.create(pos.line, line.length - 1, pos.line, line.length);
          } else {
            range = Range.create(pos.line, pos.character, pos.line, pos.character + 1);
          }
          session.addRange(range, line.slice(range.start.character, range.end.character));
        } else if (kind == "range") {
          await nvim.call("eval", 'feedkeys("\\<esc>", "in")');
          let range2 = await workspace_default.getSelectedRange(mode, doc);
          if (!range2 || comparePosition(range2.start, range2.end) == 0)
            return;
          let ranges = mode == "" ? getVisualRanges(doc, range2) : splitRange(doc, range2);
          for (let r of ranges) {
            let text = doc.textDocument.getText(r);
            session.addRange(r, text);
          }
        } else {
          window_default.showMessage(`${kind} not supported`, "error");
          return;
        }
        if (kind == "word" || kind == "position") {
          await nvim.command(`silent! call repeat#set("\\<Plug>(coc-cursors-${kind})", -1)`);
        }
      }
      createSession(doc) {
        let session = this.getSession(doc.bufnr);
        if (session)
          return session;
        session = new CursorSession(this.nvim, doc, this.config);
        this.sessionsMap.set(doc.bufnr, session);
        session.onDidCancel(() => {
          session.dispose();
          this.sessionsMap.delete(doc.bufnr);
        });
        return session;
      }
      async addRanges(ranges) {
        let { nvim } = this;
        let bufnr = await nvim.call("bufnr", ["%"]);
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached) {
          window_default.showMessage("Document not attached", "error");
          return false;
        }
        let session = this.createSession(doc);
        return session.addRanges(ranges);
      }
      reset() {
        for (let session of this.sessionsMap.values()) {
          session.cancel();
        }
        this.sessionsMap.clear();
      }
      dispose() {
        for (let session of this.sessionsMap.values()) {
          session.dispose();
        }
        this.sessionsMap.clear();
        for (let disposable of this.disposables) {
          disposable.dispose();
        }
      }
    };
  }
});

// src/handler/codelens/buffer.ts
var import_debounce10, import_vscode_languageserver_protocol76, logger82, CodeLensBuffer;
var init_buffer3 = __esm({
  "src/handler/codelens/buffer.ts"() {
    import_debounce10 = __toModule(require_debounce());
    import_vscode_languageserver_protocol76 = __toModule(require_main2());
    init_languages();
    init_window();
    init_workspace();
    init_commands2();
    logger82 = require_logger2()("codelens-buffer");
    CodeLensBuffer = class {
      constructor(nvim, bufnr, config) {
        this.nvim = nvim;
        this.bufnr = bufnr;
        this.config = config;
        this._disposed = false;
        this.fetchCodelenses = (0, import_debounce10.default)(() => {
          this._fetchCodeLenses().logError();
        }, global.hasOwnProperty("__TEST__") ? 10 : 100);
        this.resolveCodeLens = (0, import_debounce10.default)(() => {
          this._resolveCodeLenses().logError();
        }, global.hasOwnProperty("__TEST__") ? 10 : 100);
        this.forceFetch().logError();
      }
      async forceFetch() {
        this.fetchCodelenses.clear();
        await this._fetchCodeLenses();
      }
      get textDocument() {
        var _a2;
        return (_a2 = workspace_default.getDocument(this.bufnr)) == null ? void 0 : _a2.textDocument;
      }
      get hasProvider() {
        let { textDocument } = this;
        if (!textDocument)
          return false;
        return languages_default.hasProvider("codeLens", textDocument);
      }
      async _fetchCodeLenses() {
        if (!this.config.enabled || !this.hasProvider)
          return;
        let { textDocument } = this;
        let version2 = textDocument.version;
        if (this.codeLenses && this.codeLenses.codeLenses.length > 0 && version2 == this.codeLenses.version) {
          let res = await this._resolveCodeLenses(true);
          if (!res)
            this.clear();
          return;
        }
        this.cancel();
        let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol76.CancellationTokenSource();
        let token = tokenSource.token;
        let codeLenses = await languages_default.getCodeLens(textDocument, token);
        this.tokenSource = void 0;
        if (token.isCancellationRequested)
          return;
        this.resolveCodeLens.clear();
        if (Array.isArray(codeLenses)) {
          this.codeLenses = { version: version2, codeLenses };
          let res = await this._resolveCodeLenses(true);
          if (!res)
            this.clear();
        }
      }
      async _resolveCodeLenses(clear = false) {
        if (!this.config.enabled || !this.codeLenses || this._disposed)
          return false;
        let { codeLenses, version: version2 } = this.codeLenses;
        let [bufnr, start, end] = await this.nvim.eval(`[bufnr('%'),line('w0'),line('w$')]`);
        if (!this.textDocument || this.textDocument.version != version2)
          return false;
        if (bufnr != this.bufnr)
          return false;
        codeLenses = codeLenses.filter((o) => {
          let lnum = o.range.start.line + 1;
          return lnum >= start && lnum <= end;
        });
        if (!clear)
          codeLenses = codeLenses.filter((o) => o.command == null);
        if (!codeLenses.length)
          return false;
        let tokenSource = new import_vscode_languageserver_protocol76.CancellationTokenSource();
        let token = tokenSource.token;
        let timer = setTimeout(() => {
          tokenSource.cancel();
        }, 1e3);
        await Promise.all(codeLenses.map((codeLens) => languages_default.resolveCodeLens(codeLens, token)));
        clearTimeout(timer);
        this.tokenSource = void 0;
        if (token.isCancellationRequested || this._disposed)
          return false;
        this.srcId = await this.nvim.createNamespace("coc-codelens");
        this.nvim.pauseNotification();
        if (clear)
          this.clear();
        this.setVirtualText(codeLenses);
        let res = await this.nvim.resumeNotification();
        if (Array.isArray(res) && res[1] != null) {
          logger82.error(`Error on resolve codeLens`, res[1][2]);
          return false;
        }
        return true;
      }
      setVirtualText(codeLenses) {
        if (codeLenses.length == 0)
          return;
        let list2 = new Map();
        for (let codeLens of codeLenses) {
          let { range, command } = codeLens;
          if (!command)
            continue;
          let { line } = range.start;
          if (list2.has(line)) {
            list2.get(line).push(codeLens);
          } else {
            list2.set(line, [codeLens]);
          }
        }
        for (let lnum of list2.keys()) {
          let codeLenses2 = list2.get(lnum);
          let commands = codeLenses2.map((codeLens) => codeLens.command);
          commands = commands.filter((c) => c && c.title);
          let chunks = [];
          let n_commands = commands.length;
          for (let i = 0; i < n_commands; i++) {
            let c = commands[i];
            chunks.push([c.title.replace(/(\r\n|\r|\n) */g, " "), "CocCodeLens"]);
            if (i != n_commands - 1) {
              chunks.push([this.config.subseparator, "CocCodeLens"]);
            }
          }
          chunks.unshift([`${this.config.separator} `, "CocCodeLens"]);
          this.nvim.call("nvim_buf_set_virtual_text", [this.bufnr, this.srcId, lnum, chunks, {}], true);
        }
      }
      clear() {
        if (!this.srcId)
          return;
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.clearNamespace(this.srcId);
      }
      getCodelenses() {
        var _a2;
        return (_a2 = this.codeLenses) == null ? void 0 : _a2.codeLenses;
      }
      async doAction(line) {
        var _a2;
        let { codeLenses } = (_a2 = this.codeLenses) != null ? _a2 : {};
        if (!codeLenses || codeLenses.length == 0) {
          window_default.showMessage("No codeLenses available", "warning");
          return;
        }
        let list2 = new Map();
        for (let codeLens of codeLenses) {
          let { range, command } = codeLens;
          if (!command)
            continue;
          let { line: line2 } = range.start;
          if (list2.has(line2)) {
            list2.get(line2).push(codeLens);
          } else {
            list2.set(line2, [codeLens]);
          }
        }
        let current = null;
        for (let i = line; i >= 0; i--) {
          if (list2.has(i)) {
            current = list2.get(i);
            break;
          }
        }
        if (!current) {
          window_default.showMessage("No codeLenses available", "warning");
          return;
        }
        let commands = current.map((o) => o.command);
        commands = commands.filter((c) => c.command != null && c.command != "");
        if (commands.length == 0) {
          window_default.showMessage("CodeLenses command not found", "warning");
        } else if (commands.length == 1) {
          commands_default.execute(commands[0]);
        } else {
          let res = await window_default.showMenuPicker(commands.map((c) => c.title));
          if (res == -1)
            return;
          commands_default.execute(commands[res]);
        }
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource.dispose();
          this.tokenSource = null;
        }
      }
      onChange() {
        if (!this.config.enabled)
          return;
        this.cancel();
        this.resolveCodeLens.clear();
      }
      dispose() {
        this._disposed = true;
        this.codeLenses = void 0;
        this.cancel();
        this.fetchCodelenses.clear();
        this.resolveCodeLens.clear();
      }
    };
  }
});

// src/handler/codelens/index.ts
var logger83, CodeLensManager2;
var init_codelens = __esm({
  "src/handler/codelens/index.ts"() {
    init_events();
    init_util();
    init_workspace();
    init_buffer3();
    logger83 = require_logger2()("codelens");
    CodeLensManager2 = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        this.setConfiguration();
        workspace_default.onDidChangeConfiguration((e) => {
          this.setConfiguration(e);
        }, null, this.disposables);
        this.buffers = workspace_default.registerBufferSync((doc) => {
          if (doc.buftype != "")
            return void 0;
          return new CodeLensBuffer(nvim, doc.bufnr, this.config);
        });
        events_default.on("ready", () => {
          this.checkProvider();
        }, null, this.disposables);
        events_default.on("CursorMoved", (bufnr) => {
          let buf = this.buffers.getItem(bufnr);
          if (buf)
            buf.resolveCodeLens();
        }, null, this.disposables);
        let forceFetch = async (bufnr) => {
          let buf = this.buffers.getItem(bufnr);
          if (buf)
            await buf.forceFetch();
        };
        events_default.on("CursorHold", forceFetch, this, this.disposables);
      }
      checkProvider() {
        for (let buf of this.buffers.items) {
          if (buf.hasProvider) {
            buf.fetchCodelenses();
          }
        }
      }
      setConfiguration(e) {
        if (e && !e.affectsConfiguration("codeLens"))
          return;
        let config = workspace_default.getConfiguration("codeLens");
        let enable = this.nvim.hasFunction("nvim_buf_set_virtual_text") && config.get("enable", false);
        if (e && enable != this.config.enabled) {
          for (let buf of this.buffers.items) {
            if (enable) {
              buf.forceFetch().logError();
            } else {
              buf.clear();
            }
          }
        }
        this.config = Object.assign(this.config || {}, {
          enabled: enable,
          separator: config.get("separator", "\u2023"),
          subseparator: config.get("subseparator", " ")
        });
      }
      async doAction() {
        let { nvim } = this;
        let bufnr = await nvim.call("bufnr", "%");
        let line = await nvim.call("line", ".") - 1;
        let buf = this.buffers.getItem(bufnr);
        await (buf == null ? void 0 : buf.doAction(line));
      }
      dispose() {
        this.buffers.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// node_modules/has/src/index.js
var require_src3 = __commonJS({
  "node_modules/has/src/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var asyncGenFunction = getEvalledConstructor("async function* () {}");
    var asyncGenFunctionPrototype = asyncGenFunction ? asyncGenFunction.prototype : undefined2;
    var asyncGenPrototype = asyncGenFunctionPrototype ? asyncGenFunctionPrototype.prototype : undefined2;
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": getEvalledConstructor("async function () {}"),
      "%AsyncGenerator%": asyncGenFunctionPrototype,
      "%AsyncGeneratorFunction%": asyncGenFunction,
      "%AsyncIteratorPrototype%": asyncGenPrototype ? getProto(asyncGenPrototype) : undefined2,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": getEvalledConstructor("function* () {}"),
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto(new Map()[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto(new Set()[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src3();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string2) {
      var first = $strSlice(string2, 0, 1);
      var last = $strSlice(string2, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string2, rePropName, function(match, number2, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind() {
      return $reflectApply(bind, $call, arguments);
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/GetIntrinsic.js
var require_GetIntrinsic2 = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/GetIntrinsic.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var asyncGenFunction = getEvalledConstructor("async function* () {}");
    var asyncGenFunctionPrototype = asyncGenFunction ? asyncGenFunction.prototype : undefined2;
    var asyncGenPrototype = asyncGenFunctionPrototype ? asyncGenFunctionPrototype.prototype : undefined2;
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": getEvalledConstructor("async function () {}"),
      "%AsyncGenerator%": asyncGenFunctionPrototype,
      "%AsyncGeneratorFunction%": asyncGenFunction,
      "%AsyncIteratorPrototype%": asyncGenPrototype ? getProto(asyncGenPrototype) : undefined2,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": getEvalledConstructor("function* () {}"),
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto(new Map()[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto(new Set()[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src3();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string2) {
      var result = [];
      $replace(string2, rePropName, function(match, number2, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (!allowMissing && !(part in value)) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/callBind.js
var require_callBind = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/callBind.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_GetIntrinsic2();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind() {
      return $reflectApply(bind, $call, arguments);
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/callBound.js
var require_callBound = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var callBind = require_callBind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.")) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/Call.js
var require_Call = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/Call.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var callBound = require_callBound();
    var $apply = GetIntrinsic("%Reflect.apply%", true) || callBound("%Function.prototype.apply%");
    module2.exports = function Call(F, V) {
      var args = arguments.length > 2 ? arguments[2] : [];
      return $apply(F, V, args);
    };
  }
});

// node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS({
  "node_modules/object-inspect/util.inspect.js"(exports2, module2) {
    module2.exports = require("util").inspect;
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var match = String.prototype.match;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" ? Symbol.prototype.toString : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var inspectCustom = require_util_inspect().custom;
    var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean") {
        throw new TypeError('option "customInspect", if provided, must be `true` or `false`');
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        return String(obj);
      }
      if (typeof obj === "bigint") {
        return String(obj) + "n";
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = seen.slice();
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function") {
        var name2 = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys.length > 0 ? " { " + keys.join(", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = symToString.call(obj);
        return typeof obj === "object" ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + String(obj.nodeName).toLowerCase() + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + xs.join(", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + parts.join(", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function") {
          return obj[inspectSymbol]();
        } else if (typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        if (ys.length === 0) {
          return "{}";
        }
        if (indent) {
          return "{" + indentedJoin(ys, indent) + "}";
        }
        return "{ " + ys.join(", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return String(s).replace(/"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]";
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]";
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]";
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]";
    }
    function isSymbol(obj) {
      return toStr(obj) === "[object Symbol]";
    }
    function isString(obj) {
      return toStr(obj) === "[object String]";
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]";
    }
    function isBigInt(obj) {
      return toStr(obj) === "[object BigInt]";
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]";
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
      }
      var s = str.replace(/(['\\])/g, "\\$1").replace(/[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + n.toString(16).toUpperCase();
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = Array(opts.indent + 1).join(" ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: Array(depth + 1).join(baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + xs.join("," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (/[^\w$]/.test(key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        var syms = gOPS(obj);
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsPropertyKey.js
var require_IsPropertyKey = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsPropertyKey.js"(exports2, module2) {
    "use strict";
    module2.exports = function IsPropertyKey(argument) {
      return typeof argument === "string" || typeof argument === "symbol";
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/5/Type.js
var require_Type3 = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/5/Type.js"(exports2, module2) {
    "use strict";
    module2.exports = function Type(x) {
      if (x === null) {
        return "Null";
      }
      if (typeof x === "undefined") {
        return "Undefined";
      }
      if (typeof x === "function" || typeof x === "object") {
        return "Object";
      }
      if (typeof x === "number") {
        return "Number";
      }
      if (typeof x === "boolean") {
        return "Boolean";
      }
      if (typeof x === "string") {
        return "String";
      }
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/Type.js
var require_Type4 = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/Type.js"(exports2, module2) {
    "use strict";
    var ES5Type = require_Type3();
    module2.exports = function Type(x) {
      if (typeof x === "symbol") {
        return "Symbol";
      }
      if (typeof x === "bigint") {
        return "BigInt";
      }
      return ES5Type(x);
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/Get.js
var require_Get = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/Get.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $TypeError = GetIntrinsic("%TypeError%");
    var inspect = require_object_inspect();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type4();
    module2.exports = function Get(O, P) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true, got " + inspect(P));
      }
      return O[P];
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/5/CheckObjectCoercible.js
var require_CheckObjectCoercible = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/5/CheckObjectCoercible.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $TypeError = GetIntrinsic("%TypeError%");
    module2.exports = function CheckObjectCoercible(value, optMessage) {
      if (value == null) {
        throw new $TypeError(optMessage || "Cannot call method on " + value);
      }
      return value;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/RequireObjectCoercible.js
var require_RequireObjectCoercible = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/RequireObjectCoercible.js"(exports2, module2) {
    "use strict";
    module2.exports = require_CheckObjectCoercible();
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToObject.js
var require_ToObject = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToObject.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $Object = GetIntrinsic("%Object%");
    var RequireObjectCoercible = require_RequireObjectCoercible();
    module2.exports = function ToObject(value) {
      RequireObjectCoercible(value);
      return $Object(value);
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/GetV.js
var require_GetV = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/GetV.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsPropertyKey = require_IsPropertyKey();
    var ToObject = require_ToObject();
    module2.exports = function GetV(V, P) {
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var O = ToObject(V);
      return O[P];
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/is-callable/index.js
var require_is_callable2 = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/is-callable/index.js"(exports2, module2) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
    module2.exports = reflectApply ? function isCallable(value) {
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (typeof value === "function" && !value.prototype) {
        return true;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value);
    } : function isCallable(value) {
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (typeof value === "function" && !value.prototype) {
        return true;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      return strClass === fnClass || strClass === genClass;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsCallable.js
var require_IsCallable2 = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsCallable.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_callable2();
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/GetMethod.js
var require_GetMethod = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/GetMethod.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $TypeError = GetIntrinsic("%TypeError%");
    var GetV = require_GetV();
    var IsCallable = require_IsCallable2();
    var IsPropertyKey = require_IsPropertyKey();
    module2.exports = function GetMethod(O, P) {
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var func2 = GetV(O, P);
      if (func2 == null) {
        return void 0;
      }
      if (!IsCallable(func2)) {
        throw new $TypeError(P + "is not a function");
      }
      return func2;
    };
  }
});

// node_modules/is-regex/index.js
var require_is_regex = __commonJS({
  "node_modules/is-regex/index.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_has_symbols()();
    var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === "symbol";
    var hasOwnProperty3;
    var regexExec;
    var isRegexMarker;
    var badStringifier;
    if (hasToStringTag) {
      hasOwnProperty3 = Function.call.bind(Object.prototype.hasOwnProperty);
      regexExec = Function.call.bind(RegExp.prototype.exec);
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
    }
    var throwRegexMarker;
    var toStr = Object.prototype.toString;
    var gOPD = Object.getOwnPropertyDescriptor;
    var regexClass = "[object RegExp]";
    module2.exports = hasToStringTag ? function isRegex(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = gOPD(value, "lastIndex");
      var hasLastIndexDataProperty = descriptor && hasOwnProperty3(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        regexExec(value, badStringifier);
      } catch (e) {
        return e === isRegexMarker;
      }
    } : function isRegex(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return toStr.call(value) === regexClass;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToBoolean.js
var require_ToBoolean = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToBoolean.js"(exports2, module2) {
    "use strict";
    module2.exports = function ToBoolean(value) {
      return !!value;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsRegExp.js
var require_IsRegExp = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsRegExp.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $match = GetIntrinsic("%Symbol.match%", true);
    var hasRegExpMatcher = require_is_regex();
    var ToBoolean = require_ToBoolean();
    module2.exports = function IsRegExp(argument) {
      if (!argument || typeof argument !== "object") {
        return false;
      }
      if ($match) {
        var isRegExp = argument[$match];
        if (typeof isRegExp !== "undefined") {
          return ToBoolean(isRegExp);
        }
      }
      return hasRegExpMatcher(argument);
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToString.js
var require_ToString = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToString.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $String = GetIntrinsic("%String%");
    var $TypeError = GetIntrinsic("%TypeError%");
    module2.exports = function ToString(argument) {
      if (typeof argument === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a string");
      }
      return $String(argument);
    };
  }
});

// node_modules/call-bind/callBound.js
var require_callBound2 = __commonJS({
  "node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/es-abstract/GetIntrinsic.js
var require_GetIntrinsic3 = __commonJS({
  "node_modules/es-abstract/GetIntrinsic.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $TypeError = TypeError;
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var generator;
    var generatorFunction = generator ? getProto(generator) : undefined2;
    var asyncFn;
    var asyncFunction = asyncFn ? asyncFn.constructor : undefined2;
    var asyncGen;
    var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined2;
    var asyncGenIterator = asyncGen ? asyncGen() : undefined2;
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer.prototype,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%ArrayPrototype%": Array.prototype,
      "%ArrayProto_entries%": Array.prototype.entries,
      "%ArrayProto_forEach%": Array.prototype.forEach,
      "%ArrayProto_keys%": Array.prototype.keys,
      "%ArrayProto_values%": Array.prototype.values,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": asyncFunction,
      "%AsyncFunctionPrototype%": asyncFunction ? asyncFunction.prototype : undefined2,
      "%AsyncGenerator%": asyncGen ? getProto(asyncGenIterator) : undefined2,
      "%AsyncGeneratorFunction%": asyncGenFunction,
      "%AsyncGeneratorPrototype%": asyncGenFunction ? asyncGenFunction.prototype : undefined2,
      "%AsyncIteratorPrototype%": asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined2,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%Boolean%": Boolean,
      "%BooleanPrototype%": Boolean.prototype,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%DataViewPrototype%": typeof DataView === "undefined" ? undefined2 : DataView.prototype,
      "%Date%": Date,
      "%DatePrototype%": Date.prototype,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%ErrorPrototype%": Error.prototype,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%EvalErrorPrototype%": EvalError.prototype,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined2 : Float32Array.prototype,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined2 : Float64Array.prototype,
      "%Function%": Function,
      "%FunctionPrototype%": Function.prototype,
      "%Generator%": generator ? getProto(generator()) : undefined2,
      "%GeneratorFunction%": generatorFunction,
      "%GeneratorPrototype%": generatorFunction ? generatorFunction.prototype : undefined2,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined2 : Int8Array.prototype,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined2 : Int8Array.prototype,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined2 : Int32Array.prototype,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto(new Map()[Symbol.iterator]()),
      "%MapPrototype%": typeof Map === "undefined" ? undefined2 : Map.prototype,
      "%Math%": Math,
      "%Number%": Number,
      "%NumberPrototype%": Number.prototype,
      "%Object%": Object,
      "%ObjectPrototype%": Object.prototype,
      "%ObjProto_toString%": Object.prototype.toString,
      "%ObjProto_valueOf%": Object.prototype.valueOf,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%PromisePrototype%": typeof Promise === "undefined" ? undefined2 : Promise.prototype,
      "%PromiseProto_then%": typeof Promise === "undefined" ? undefined2 : Promise.prototype.then,
      "%Promise_all%": typeof Promise === "undefined" ? undefined2 : Promise.all,
      "%Promise_reject%": typeof Promise === "undefined" ? undefined2 : Promise.reject,
      "%Promise_resolve%": typeof Promise === "undefined" ? undefined2 : Promise.resolve,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%RangeErrorPrototype%": RangeError.prototype,
      "%ReferenceError%": ReferenceError,
      "%ReferenceErrorPrototype%": ReferenceError.prototype,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%RegExpPrototype%": RegExp.prototype,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto(new Set()[Symbol.iterator]()),
      "%SetPrototype%": typeof Set === "undefined" ? undefined2 : Set.prototype,
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer.prototype,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%StringPrototype%": String.prototype,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SymbolPrototype%": hasSymbols ? Symbol.prototype : undefined2,
      "%SyntaxError%": SyntaxError,
      "%SyntaxErrorPrototype%": SyntaxError.prototype,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypedArrayPrototype%": TypedArray ? TypedArray.prototype : undefined2,
      "%TypeError%": $TypeError,
      "%TypeErrorPrototype%": $TypeError.prototype,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array.prototype,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray.prototype,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array.prototype,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array.prototype,
      "%URIError%": URIError,
      "%URIErrorPrototype%": URIError.prototype,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined2 : WeakMap.prototype,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined2 : WeakSet.prototype
    };
    var bind = require_function_bind();
    var $replace = bind.call(Function.call, String.prototype.replace);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string2) {
      var result = [];
      $replace(string2, rePropName, function(match, number2, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      if (!(name2 in INTRINSICS)) {
        throw new SyntaxError("intrinsic " + name2 + " does not exist!");
      }
      if (typeof INTRINSICS[name2] === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
      }
      return INTRINSICS[name2];
    };
    module2.exports = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath(name2);
      var value = getBaseIntrinsic("%" + (parts.length > 0 ? parts[0] : "") + "%", allowMissing);
      for (var i = 1; i < parts.length; i += 1) {
        if (value != null) {
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, parts[i]);
            if (!allowMissing && !(parts[i] in value)) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            value = desc && "get" in desc && !("originalValue" in desc.get) ? desc.get : value[parts[i]];
          } else {
            value = value[parts[i]];
          }
        }
      }
      return value;
    };
  }
});

// node_modules/es-abstract/helpers/callBind.js
var require_callBind2 = __commonJS({
  "node_modules/es-abstract/helpers/callBind.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_GetIntrinsic3();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind() {
      return $reflectApply(bind, $call, arguments);
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/regexp.prototype.flags/implementation.js
var require_implementation4 = __commonJS({
  "node_modules/regexp.prototype.flags/implementation.js"(exports2, module2) {
    "use strict";
    var $Object = Object;
    var $TypeError = TypeError;
    module2.exports = function flags() {
      if (this != null && this !== $Object(this)) {
        throw new $TypeError("RegExp.prototype.flags getter called on non-object");
      }
      var result = "";
      if (this.global) {
        result += "g";
      }
      if (this.ignoreCase) {
        result += "i";
      }
      if (this.multiline) {
        result += "m";
      }
      if (this.dotAll) {
        result += "s";
      }
      if (this.unicode) {
        result += "u";
      }
      if (this.sticky) {
        result += "y";
      }
      return result;
    };
  }
});

// node_modules/regexp.prototype.flags/polyfill.js
var require_polyfill2 = __commonJS({
  "node_modules/regexp.prototype.flags/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation4();
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var $gOPD = Object.getOwnPropertyDescriptor;
    var $TypeError = TypeError;
    module2.exports = function getPolyfill() {
      if (!supportsDescriptors) {
        throw new $TypeError("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
      }
      if (/a/mig.flags === "gim") {
        var descriptor = $gOPD(RegExp.prototype, "flags");
        if (descriptor && typeof descriptor.get === "function" && typeof /a/.dotAll === "boolean") {
          return descriptor.get;
        }
      }
      return implementation;
    };
  }
});

// node_modules/regexp.prototype.flags/shim.js
var require_shim2 = __commonJS({
  "node_modules/regexp.prototype.flags/shim.js"(exports2, module2) {
    "use strict";
    var supportsDescriptors = require_define_properties().supportsDescriptors;
    var getPolyfill = require_polyfill2();
    var gOPD = Object.getOwnPropertyDescriptor;
    var defineProperty = Object.defineProperty;
    var TypeErr = TypeError;
    var getProto = Object.getPrototypeOf;
    var regex = /a/;
    module2.exports = function shimFlags() {
      if (!supportsDescriptors || !getProto) {
        throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
      }
      var polyfill = getPolyfill();
      var proto = getProto(regex);
      var descriptor = gOPD(proto, "flags");
      if (!descriptor || descriptor.get !== polyfill) {
        defineProperty(proto, "flags", {
          configurable: true,
          enumerable: false,
          get: polyfill
        });
      }
      return polyfill;
    };
  }
});

// node_modules/regexp.prototype.flags/index.js
var require_regexp_prototype = __commonJS({
  "node_modules/regexp.prototype.flags/index.js"(exports2, module2) {
    "use strict";
    var define = require_define_properties();
    var callBind = require_callBind2();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim2();
    var flagsBound = callBind(implementation);
    define(flagsBound, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = flagsBound;
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/SameValue.js
var require_SameValue = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/SameValue.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function SameValue(x, y) {
      if (x === y) {
        if (x === 0) {
          return 1 / x === 1 / y;
        }
        return true;
      }
      return $isNaN(x) && $isNaN(y);
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/Set.js
var require_Set = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/Set.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var Type = require_Type4();
    var noThrowOnStrictViolation = function() {
      try {
        delete [].length;
        return true;
      } catch (e) {
        return false;
      }
    }();
    module2.exports = function Set2(O, P, V, Throw) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: `O` must be an Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: `P` must be a Property Key");
      }
      if (Type(Throw) !== "Boolean") {
        throw new $TypeError("Assertion failed: `Throw` must be a Boolean");
      }
      if (Throw) {
        O[P] = V;
        if (noThrowOnStrictViolation && !SameValue(O[P], V)) {
          throw new $TypeError("Attempted to assign to readonly property.");
        }
        return true;
      } else {
        try {
          O[P] = V;
          return noThrowOnStrictViolation ? SameValue(O[P], V) : true;
        } catch (e) {
          return false;
        }
      }
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/isPropertyDescriptor.js
var require_isPropertyDescriptor = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/isPropertyDescriptor.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var has = require_src3();
    var $TypeError = GetIntrinsic("%TypeError%");
    module2.exports = function IsPropertyDescriptor(ES, Desc) {
      if (ES.Type(Desc) !== "Object") {
        return false;
      }
      var allowed = {
        "[[Configurable]]": true,
        "[[Enumerable]]": true,
        "[[Get]]": true,
        "[[Set]]": true,
        "[[Value]]": true,
        "[[Writable]]": true
      };
      for (var key in Desc) {
        if (has(Desc, key) && !allowed[key]) {
          return false;
        }
      }
      if (ES.IsDataDescriptor(Desc) && ES.IsAccessorDescriptor(Desc)) {
        throw new $TypeError("Property Descriptors may not be both accessor and data descriptors");
      }
      return true;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/DefineOwnProperty.js
var require_DefineOwnProperty = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/DefineOwnProperty.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    module2.exports = function DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, desc) {
      if (!$defineProperty) {
        if (!IsDataDescriptor(desc)) {
          return false;
        }
        if (!desc["[[Configurable]]"] || !desc["[[Writable]]"]) {
          return false;
        }
        if (P in O && $isEnumerable(O, P) !== !!desc["[[Enumerable]]"]) {
          return false;
        }
        var V = desc["[[Value]]"];
        O[P] = V;
        return SameValue(O[P], V);
      }
      $defineProperty(O, P, FromPropertyDescriptor(desc));
      return true;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/assertRecord.js
var require_assertRecord = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/assertRecord.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var has = require_src3();
    var predicates = {
      "Property Descriptor": function isPropertyDescriptor(Type, Desc) {
        if (Type(Desc) !== "Object") {
          return false;
        }
        var allowed = {
          "[[Configurable]]": true,
          "[[Enumerable]]": true,
          "[[Get]]": true,
          "[[Set]]": true,
          "[[Value]]": true,
          "[[Writable]]": true
        };
        for (var key in Desc) {
          if (has(Desc, key) && !allowed[key]) {
            return false;
          }
        }
        var isData = has(Desc, "[[Value]]");
        var IsAccessor = has(Desc, "[[Get]]") || has(Desc, "[[Set]]");
        if (isData && IsAccessor) {
          throw new $TypeError("Property Descriptors may not be both accessor and data descriptors");
        }
        return true;
      }
    };
    module2.exports = function assertRecord(Type, recordType, argumentName, value) {
      var predicate = predicates[recordType];
      if (typeof predicate !== "function") {
        throw new $SyntaxError("unknown record type: " + recordType);
      }
      if (!predicate(Type, value)) {
        throw new $TypeError(argumentName + " must be a " + recordType);
      }
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/FromPropertyDescriptor.js
var require_FromPropertyDescriptor = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/FromPropertyDescriptor.js"(exports2, module2) {
    "use strict";
    var assertRecord = require_assertRecord();
    var Type = require_Type4();
    module2.exports = function FromPropertyDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return Desc;
      }
      assertRecord(Type, "Property Descriptor", "Desc", Desc);
      var obj = {};
      if ("[[Value]]" in Desc) {
        obj.value = Desc["[[Value]]"];
      }
      if ("[[Writable]]" in Desc) {
        obj.writable = Desc["[[Writable]]"];
      }
      if ("[[Get]]" in Desc) {
        obj.get = Desc["[[Get]]"];
      }
      if ("[[Set]]" in Desc) {
        obj.set = Desc["[[Set]]"];
      }
      if ("[[Enumerable]]" in Desc) {
        obj.enumerable = Desc["[[Enumerable]]"];
      }
      if ("[[Configurable]]" in Desc) {
        obj.configurable = Desc["[[Configurable]]"];
      }
      return obj;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsAccessorDescriptor.js
var require_IsAccessorDescriptor = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsAccessorDescriptor.js"(exports2, module2) {
    "use strict";
    var has = require_src3();
    var assertRecord = require_assertRecord();
    var Type = require_Type4();
    module2.exports = function IsAccessorDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      assertRecord(Type, "Property Descriptor", "Desc", Desc);
      if (!has(Desc, "[[Get]]") && !has(Desc, "[[Set]]")) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsDataDescriptor.js
var require_IsDataDescriptor = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsDataDescriptor.js"(exports2, module2) {
    "use strict";
    var has = require_src3();
    var assertRecord = require_assertRecord();
    var Type = require_Type4();
    module2.exports = function IsDataDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      assertRecord(Type, "Property Descriptor", "Desc", Desc);
      if (!has(Desc, "[[Value]]") && !has(Desc, "[[Writable]]")) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToPropertyDescriptor.js
var require_ToPropertyDescriptor = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToPropertyDescriptor.js"(exports2, module2) {
    "use strict";
    var has = require_src3();
    var GetIntrinsic = require_GetIntrinsic2();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Type = require_Type4();
    var ToBoolean = require_ToBoolean();
    var IsCallable = require_IsCallable2();
    module2.exports = function ToPropertyDescriptor(Obj) {
      if (Type(Obj) !== "Object") {
        throw new $TypeError("ToPropertyDescriptor requires an object");
      }
      var desc = {};
      if (has(Obj, "enumerable")) {
        desc["[[Enumerable]]"] = ToBoolean(Obj.enumerable);
      }
      if (has(Obj, "configurable")) {
        desc["[[Configurable]]"] = ToBoolean(Obj.configurable);
      }
      if (has(Obj, "value")) {
        desc["[[Value]]"] = Obj.value;
      }
      if (has(Obj, "writable")) {
        desc["[[Writable]]"] = ToBoolean(Obj.writable);
      }
      if (has(Obj, "get")) {
        var getter = Obj.get;
        if (typeof getter !== "undefined" && !IsCallable(getter)) {
          throw new $TypeError("getter must be a function");
        }
        desc["[[Get]]"] = getter;
      }
      if (has(Obj, "set")) {
        var setter = Obj.set;
        if (typeof setter !== "undefined" && !IsCallable(setter)) {
          throw new $TypeError("setter must be a function");
        }
        desc["[[Set]]"] = setter;
      }
      if ((has(desc, "[[Get]]") || has(desc, "[[Set]]")) && (has(desc, "[[Value]]") || has(desc, "[[Writable]]"))) {
        throw new $TypeError("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
      }
      return desc;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/DefinePropertyOrThrow.js
var require_DefinePropertyOrThrow = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/DefinePropertyOrThrow.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $TypeError = GetIntrinsic("%TypeError%");
    var isPropertyDescriptor = require_isPropertyDescriptor();
    var DefineOwnProperty = require_DefineOwnProperty();
    var FromPropertyDescriptor = require_FromPropertyDescriptor();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var ToPropertyDescriptor = require_ToPropertyDescriptor();
    var Type = require_Type4();
    module2.exports = function DefinePropertyOrThrow(O, P, desc) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var Desc = isPropertyDescriptor({
        Type,
        IsDataDescriptor,
        IsAccessorDescriptor
      }, desc) ? desc : ToPropertyDescriptor(desc);
      if (!isPropertyDescriptor({
        Type,
        IsDataDescriptor,
        IsAccessorDescriptor
      }, Desc)) {
        throw new $TypeError("Assertion failed: Desc is not a valid Property Descriptor");
      }
      return DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, Desc);
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsConstructor.js
var require_IsConstructor2 = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsConstructor.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $construct = GetIntrinsic("%Reflect.construct%", true);
    var DefinePropertyOrThrow = require_DefinePropertyOrThrow();
    try {
      DefinePropertyOrThrow({}, "", { "[[Get]]": function() {
      } });
    } catch (e) {
      DefinePropertyOrThrow = null;
    }
    if (DefinePropertyOrThrow && $construct) {
      isConstructorMarker = {};
      badArrayLike = {};
      DefinePropertyOrThrow(badArrayLike, "length", {
        "[[Get]]": function() {
          throw isConstructorMarker;
        },
        "[[Enumerable]]": true
      });
      module2.exports = function IsConstructor(argument) {
        try {
          $construct(argument, badArrayLike);
        } catch (err) {
          return err === isConstructorMarker;
        }
      };
    } else {
      module2.exports = function IsConstructor(argument) {
        return typeof argument === "function" && !!argument.prototype;
      };
    }
    var isConstructorMarker;
    var badArrayLike;
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/SpeciesConstructor.js
var require_SpeciesConstructor2 = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/SpeciesConstructor.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $species = GetIntrinsic("%Symbol.species%", true);
    var $TypeError = GetIntrinsic("%TypeError%");
    var IsConstructor = require_IsConstructor2();
    var Type = require_Type4();
    module2.exports = function SpeciesConstructor(O, defaultConstructor) {
      if (Type(O) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      var C = O.constructor;
      if (typeof C === "undefined") {
        return defaultConstructor;
      }
      if (Type(C) !== "Object") {
        throw new $TypeError("O.constructor is not an Object");
      }
      var S = $species ? C[$species] : void 0;
      if (S == null) {
        return defaultConstructor;
      }
      if (IsConstructor(S)) {
        return S;
      }
      throw new $TypeError("no constructor found");
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/maxSafeInteger.js
var require_maxSafeInteger = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/maxSafeInteger.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $Math = GetIntrinsic("%Math%");
    var $Number = GetIntrinsic("%Number%");
    module2.exports = $Number.MAX_SAFE_INTEGER || $Math.pow(2, 53) - 1;
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/5/abs.js
var require_abs = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/5/abs.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $abs = GetIntrinsic("%Math.abs%");
    module2.exports = function abs(x) {
      return $abs(x);
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/5/floor.js
var require_floor = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/5/floor.js"(exports2, module2) {
    "use strict";
    var $floor = Math.floor;
    module2.exports = function floor(x) {
      return $floor(x);
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/5/ToNumber.js
var require_ToNumber = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/5/ToNumber.js"(exports2, module2) {
    "use strict";
    module2.exports = function ToNumber(value) {
      return +value;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/isFinite.js
var require_isFinite = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/isFinite.js"(exports2, module2) {
    "use strict";
    var $isNaN = Number.isNaN || function(a) {
      return a !== a;
    };
    module2.exports = Number.isFinite || function(x) {
      return typeof x === "number" && !$isNaN(x) && x !== Infinity && x !== -Infinity;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/sign.js
var require_sign = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/sign.js"(exports2, module2) {
    "use strict";
    module2.exports = function sign(number2) {
      return number2 >= 0 ? 1 : -1;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/5/ToInteger.js
var require_ToInteger = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/5/ToInteger.js"(exports2, module2) {
    "use strict";
    var abs = require_abs();
    var floor = require_floor();
    var ToNumber = require_ToNumber();
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    var $sign = require_sign();
    module2.exports = function ToInteger(value) {
      var number2 = ToNumber(value);
      if ($isNaN(number2)) {
        return 0;
      }
      if (number2 === 0 || !$isFinite(number2)) {
        return number2;
      }
      return $sign(number2) * floor(abs(number2));
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/regexTester.js
var require_regexTester = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/regexTester.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $test = GetIntrinsic("RegExp.prototype.test");
    var callBind = require_callBind();
    module2.exports = function regexTester(regex) {
      return callBind($test, regex);
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/isPrimitive.js
var require_isPrimitive = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/isPrimitive.js"(exports2, module2) {
    "use strict";
    module2.exports = function isPrimitive(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
  }
});

// node_modules/es-to-primitive/helpers/isPrimitive.js
var require_isPrimitive2 = __commonJS({
  "node_modules/es-to-primitive/helpers/isPrimitive.js"(exports2, module2) {
    "use strict";
    module2.exports = function isPrimitive(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
  }
});

// node_modules/is-date-object/index.js
var require_is_date_object = __commonJS({
  "node_modules/is-date-object/index.js"(exports2, module2) {
    "use strict";
    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateGetDayCall(value) {
      try {
        getDay.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var dateClass = "[object Date]";
    var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
    module2.exports = function isDateObject(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
    };
  }
});

// node_modules/is-symbol/index.js
var require_is_symbol = __commonJS({
  "node_modules/is-symbol/index.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    var hasSymbols = require_has_symbols()();
    if (hasSymbols) {
      symToStr = Symbol.prototype.toString;
      symStringRegex = /^Symbol\(.*\)$/;
      isSymbolObject = function isRealSymbolObject(value) {
        if (typeof value.valueOf() !== "symbol") {
          return false;
        }
        return symStringRegex.test(symToStr.call(value));
      };
      module2.exports = function isSymbol(value) {
        if (typeof value === "symbol") {
          return true;
        }
        if (toStr.call(value) !== "[object Symbol]") {
          return false;
        }
        try {
          return isSymbolObject(value);
        } catch (e) {
          return false;
        }
      };
    } else {
      module2.exports = function isSymbol(value) {
        return false;
      };
    }
    var symToStr;
    var symStringRegex;
    var isSymbolObject;
  }
});

// node_modules/es-to-primitive/es2015.js
var require_es2015 = __commonJS({
  "node_modules/es-to-primitive/es2015.js"(exports2, module2) {
    "use strict";
    var hasSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "symbol";
    var isPrimitive = require_isPrimitive2();
    var isCallable = require_is_callable();
    var isDate = require_is_date_object();
    var isSymbol = require_is_symbol();
    var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
      if (typeof O === "undefined" || O === null) {
        throw new TypeError("Cannot call method on " + O);
      }
      if (typeof hint !== "string" || hint !== "number" && hint !== "string") {
        throw new TypeError('hint must be "string" or "number"');
      }
      var methodNames = hint === "string" ? ["toString", "valueOf"] : ["valueOf", "toString"];
      var method, result, i;
      for (i = 0; i < methodNames.length; ++i) {
        method = O[methodNames[i]];
        if (isCallable(method)) {
          result = method.call(O);
          if (isPrimitive(result)) {
            return result;
          }
        }
      }
      throw new TypeError("No default value");
    };
    var GetMethod = function GetMethod2(O, P) {
      var func2 = O[P];
      if (func2 !== null && typeof func2 !== "undefined") {
        if (!isCallable(func2)) {
          throw new TypeError(func2 + " returned for property " + P + " of object " + O + " is not a function");
        }
        return func2;
      }
      return void 0;
    };
    module2.exports = function ToPrimitive(input) {
      if (isPrimitive(input)) {
        return input;
      }
      var hint = "default";
      if (arguments.length > 1) {
        if (arguments[1] === String) {
          hint = "string";
        } else if (arguments[1] === Number) {
          hint = "number";
        }
      }
      var exoticToPrim;
      if (hasSymbols) {
        if (Symbol.toPrimitive) {
          exoticToPrim = GetMethod(input, Symbol.toPrimitive);
        } else if (isSymbol(input)) {
          exoticToPrim = Symbol.prototype.valueOf;
        }
      }
      if (typeof exoticToPrim !== "undefined") {
        var result = exoticToPrim.call(input, hint);
        if (isPrimitive(result)) {
          return result;
        }
        throw new TypeError("unable to convert exotic object to primitive");
      }
      if (hint === "default" && (isDate(input) || isSymbol(input))) {
        hint = "string";
      }
      return ordinaryToPrimitive(input, hint === "default" ? "number" : hint);
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToPrimitive.js
var require_ToPrimitive = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToPrimitive.js"(exports2, module2) {
    "use strict";
    var toPrimitive = require_es2015();
    module2.exports = function ToPrimitive(input) {
      if (arguments.length > 1) {
        return toPrimitive(input, arguments[1]);
      }
      return toPrimitive(input);
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToNumber.js
var require_ToNumber2 = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToNumber.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $Number = GetIntrinsic("%Number%");
    var $RegExp = GetIntrinsic("%RegExp%");
    var $parseInteger = GetIntrinsic("%parseInt%");
    var callBound = require_callBound();
    var regexTester = require_regexTester();
    var isPrimitive = require_isPrimitive();
    var $strSlice = callBound("String.prototype.slice");
    var isBinary = regexTester(/^0b[01]+$/i);
    var isOctal = regexTester(/^0o[0-7]+$/i);
    var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
    var nonWS = ["\x85", "\u200B", "\uFFFE"].join("");
    var nonWSregex = new $RegExp("[" + nonWS + "]", "g");
    var hasNonWS = regexTester(nonWSregex);
    var ws = [
      "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003",
      "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028",
      "\u2029\uFEFF"
    ].join("");
    var trimRegex = new RegExp("(^[" + ws + "]+)|([" + ws + "]+$)", "g");
    var $replace = callBound("String.prototype.replace");
    var $trim = function(value) {
      return $replace(value, trimRegex, "");
    };
    var ToPrimitive = require_ToPrimitive();
    module2.exports = function ToNumber(argument) {
      var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
      if (typeof value === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a number");
      }
      if (typeof value === "string") {
        if (isBinary(value)) {
          return ToNumber($parseInteger($strSlice(value, 2), 2));
        } else if (isOctal(value)) {
          return ToNumber($parseInteger($strSlice(value, 2), 8));
        } else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
          return NaN;
        } else {
          var trimmed = $trim(value);
          if (trimmed !== value) {
            return ToNumber(trimmed);
          }
        }
      }
      return $Number(value);
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToInteger.js
var require_ToInteger2 = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToInteger.js"(exports2, module2) {
    "use strict";
    var ES5ToInteger = require_ToInteger();
    var ToNumber = require_ToNumber2();
    module2.exports = function ToInteger(value) {
      var number2 = ToNumber(value);
      if (number2 !== 0) {
        number2 = ES5ToInteger(number2);
      }
      return number2 === 0 ? 0 : number2;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToLength.js
var require_ToLength = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/ToLength.js"(exports2, module2) {
    "use strict";
    var MAX_SAFE_INTEGER = require_maxSafeInteger();
    var ToInteger = require_ToInteger2();
    module2.exports = function ToLength(argument) {
      var len = ToInteger(argument);
      if (len <= 0) {
        return 0;
      }
      if (len > MAX_SAFE_INTEGER) {
        return MAX_SAFE_INTEGER;
      }
      return len;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/isLeadingSurrogate.js
var require_isLeadingSurrogate = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/isLeadingSurrogate.js"(exports2, module2) {
    "use strict";
    module2.exports = function isLeadingSurrogate(charCode) {
      return typeof charCode === "number" && charCode >= 55296 && charCode <= 56319;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/isTrailingSurrogate.js
var require_isTrailingSurrogate = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/helpers/isTrailingSurrogate.js"(exports2, module2) {
    "use strict";
    module2.exports = function isTrailingSurrogate(charCode) {
      return typeof charCode === "number" && charCode >= 56320 && charCode <= 57343;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/UTF16DecodeSurrogatePair.js
var require_UTF16DecodeSurrogatePair = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/UTF16DecodeSurrogatePair.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $fromCharCode = GetIntrinsic("%String.fromCharCode%");
    var isLeadingSurrogate = require_isLeadingSurrogate();
    var isTrailingSurrogate = require_isTrailingSurrogate();
    module2.exports = function UTF16DecodeSurrogatePair(lead, trail) {
      if (!isLeadingSurrogate(lead) || !isTrailingSurrogate(trail)) {
        throw new $TypeError("Assertion failed: `lead` must be a leading surrogate char code, and `trail` must be a trailing surrogate char code");
      }
      return $fromCharCode(lead) + $fromCharCode(trail);
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/CodePointAt.js
var require_CodePointAt = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/CodePointAt.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $TypeError = GetIntrinsic("%TypeError%");
    var callBound = require_callBound();
    var isLeadingSurrogate = require_isLeadingSurrogate();
    var isTrailingSurrogate = require_isTrailingSurrogate();
    var Type = require_Type4();
    var UTF16DecodeSurrogatePair = require_UTF16DecodeSurrogatePair();
    var $charAt = callBound("String.prototype.charAt");
    var $charCodeAt = callBound("String.prototype.charCodeAt");
    module2.exports = function CodePointAt(string2, position) {
      if (Type(string2) !== "String") {
        throw new $TypeError("Assertion failed: `string` must be a String");
      }
      var size = string2.length;
      if (position < 0 || position >= size) {
        throw new $TypeError("Assertion failed: `position` must be >= 0, and < the length of `string`");
      }
      var first = $charCodeAt(string2, position);
      var cp3 = $charAt(string2, position);
      var firstIsLeading = isLeadingSurrogate(first);
      var firstIsTrailing = isTrailingSurrogate(first);
      if (!firstIsLeading && !firstIsTrailing) {
        return {
          "[[CodePoint]]": cp3,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": false
        };
      }
      if (firstIsTrailing || position + 1 === size) {
        return {
          "[[CodePoint]]": cp3,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": true
        };
      }
      var second = $charCodeAt(string2, position + 1);
      if (!isTrailingSurrogate(second)) {
        return {
          "[[CodePoint]]": cp3,
          "[[CodeUnitCount]]": 1,
          "[[IsUnpairedSurrogate]]": true
        };
      }
      return {
        "[[CodePoint]]": UTF16DecodeSurrogatePair(first, second),
        "[[CodeUnitCount]]": 2,
        "[[IsUnpairedSurrogate]]": false
      };
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/abs.js
var require_abs2 = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/abs.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $abs = GetIntrinsic("%Math.abs%");
    module2.exports = function abs(x) {
      return $abs(x);
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/floor.js
var require_floor2 = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/floor.js"(exports2, module2) {
    "use strict";
    var $floor = Math.floor;
    module2.exports = function floor(x) {
      return $floor(x);
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsInteger.js
var require_IsInteger = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsInteger.js"(exports2, module2) {
    "use strict";
    var abs = require_abs2();
    var floor = require_floor2();
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    module2.exports = function IsInteger(argument) {
      if (typeof argument !== "number" || $isNaN(argument) || !$isFinite(argument)) {
        return false;
      }
      var absValue = abs(argument);
      return floor(absValue) === absValue;
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/AdvanceStringIndex.js
var require_AdvanceStringIndex = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/AdvanceStringIndex.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var CodePointAt = require_CodePointAt();
    var IsInteger = require_IsInteger();
    var Type = require_Type4();
    var MAX_SAFE_INTEGER = require_maxSafeInteger();
    var $TypeError = GetIntrinsic("%TypeError%");
    module2.exports = function AdvanceStringIndex(S, index, unicode) {
      if (Type(S) !== "String") {
        throw new $TypeError("Assertion failed: `S` must be a String");
      }
      if (!IsInteger(index) || index < 0 || index > MAX_SAFE_INTEGER) {
        throw new $TypeError("Assertion failed: `length` must be an integer >= 0 and <= 2**53");
      }
      if (Type(unicode) !== "Boolean") {
        throw new $TypeError("Assertion failed: `unicode` must be a Boolean");
      }
      if (!unicode) {
        return index + 1;
      }
      var length = S.length;
      if (index + 1 >= length) {
        return index + 1;
      }
      var cp3 = CodePointAt(S, index);
      return index + cp3["[[CodeUnitCount]]"];
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/CreateIterResultObject.js
var require_CreateIterResultObject = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/CreateIterResultObject.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $TypeError = GetIntrinsic("%TypeError%");
    var Type = require_Type4();
    module2.exports = function CreateIterResultObject(value, done) {
      if (Type(done) !== "Boolean") {
        throw new $TypeError("Assertion failed: Type(done) is not Boolean");
      }
      return {
        value,
        done
      };
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsArray.js
var require_IsArray = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/IsArray.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $Array = GetIntrinsic("%Array%");
    var toStr = !$Array.isArray && require_callBound()("Object.prototype.toString");
    module2.exports = $Array.isArray || function IsArray(argument) {
      return toStr(argument) === "[object Array]";
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/OrdinaryObjectCreate.js
var require_OrdinaryObjectCreate = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/OrdinaryObjectCreate.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $ObjectCreate = GetIntrinsic("%Object.create%", true);
    var $TypeError = GetIntrinsic("%TypeError%");
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var IsArray = require_IsArray();
    var Type = require_Type4();
    var hasProto = !({ __proto__: null } instanceof Object);
    module2.exports = function OrdinaryObjectCreate(proto) {
      if (proto !== null && Type(proto) !== "Object") {
        throw new $TypeError("Assertion failed: `proto` must be null or an object");
      }
      var additionalInternalSlotsList = arguments.length < 2 ? [] : arguments[1];
      if (!IsArray(additionalInternalSlotsList)) {
        throw new $TypeError("Assertion failed: `additionalInternalSlotsList` must be an Array");
      }
      if (additionalInternalSlotsList.length > 0) {
        throw new $SyntaxError("es-abstract does not yet support internal slots");
      }
      if ($ObjectCreate) {
        return $ObjectCreate(proto);
      }
      if (hasProto) {
        return { __proto__: proto };
      }
      if (proto === null) {
        throw new $SyntaxError("native Object.create support is required to create null objects");
      }
      var T = function T2() {
      };
      T.prototype = proto;
      return new T();
    };
  }
});

// node_modules/string.prototype.matchall/node_modules/es-abstract/2020/RegExpExec.js
var require_RegExpExec = __commonJS({
  "node_modules/string.prototype.matchall/node_modules/es-abstract/2020/RegExpExec.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic2();
    var $TypeError = GetIntrinsic("%TypeError%");
    var regexExec = require_callBound()("RegExp.prototype.exec");
    var Call = require_Call();
    var Get = require_Get();
    var IsCallable = require_IsCallable2();
    var Type = require_Type4();
    module2.exports = function RegExpExec(R, S) {
      if (Type(R) !== "Object") {
        throw new $TypeError("Assertion failed: `R` must be an Object");
      }
      if (Type(S) !== "String") {
        throw new $TypeError("Assertion failed: `S` must be a String");
      }
      var exec3 = Get(R, "exec");
      if (IsCallable(exec3)) {
        var result = Call(exec3, R, [S]);
        if (result === null || Type(result) === "Object") {
          return result;
        }
        throw new $TypeError('"exec" method must return `null` or an Object');
      }
      return regexExec(R, S);
    };
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound2();
    var inspect = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list2, key) {
      for (var prev = list2, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = list2.next;
          list2.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/internal-slot/index.js
var require_internal_slot = __commonJS({
  "node_modules/internal-slot/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic3();
    var has = require_src3();
    var channel = require_side_channel()();
    var $TypeError = GetIntrinsic("%TypeError%");
    var SLOT = {
      assert: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        channel.assert(O);
      },
      get: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        return slots && slots["$" + slot];
      },
      has: function(O, slot) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        return !!slots && has(slots, "$" + slot);
      },
      set: function(O, slot, V) {
        if (!O || typeof O !== "object" && typeof O !== "function") {
          throw new $TypeError("`O` is not an object");
        }
        if (typeof slot !== "string") {
          throw new $TypeError("`slot` must be a string");
        }
        var slots = channel.get(O);
        if (!slots) {
          slots = {};
          channel.set(O, slots);
        }
        slots["$" + slot] = V;
      }
    };
    if (Object.freeze) {
      Object.freeze(SLOT);
    }
    module2.exports = SLOT;
  }
});

// node_modules/string.prototype.matchall/helpers/RegExpStringIterator.js
var require_RegExpStringIterator = __commonJS({
  "node_modules/string.prototype.matchall/helpers/RegExpStringIterator.js"(exports2, module2) {
    "use strict";
    var define = require_define_properties();
    var AdvanceStringIndex = require_AdvanceStringIndex();
    var CreateIterResultObject = require_CreateIterResultObject();
    var Get = require_Get();
    var GetIntrinsic = require_GetIntrinsic2();
    var OrdinaryObjectCreate = require_OrdinaryObjectCreate();
    var RegExpExec = require_RegExpExec();
    var Set2 = require_Set();
    var ToLength = require_ToLength();
    var ToString = require_ToString();
    var Type = require_Type4();
    var hasSymbols = require_has_symbols()();
    var SLOT = require_internal_slot();
    var undefined2;
    var RegExpStringIterator = function RegExpStringIterator2(R, S, global2, fullUnicode) {
      if (Type(S) !== "String") {
        throw new TypeError("S must be a string");
      }
      if (Type(global2) !== "Boolean") {
        throw new TypeError("global must be a boolean");
      }
      if (Type(fullUnicode) !== "Boolean") {
        throw new TypeError("fullUnicode must be a boolean");
      }
      SLOT.set(this, "[[IteratingRegExp]]", R);
      SLOT.set(this, "[[IteratedString]]", S);
      SLOT.set(this, "[[Global]]", global2);
      SLOT.set(this, "[[Unicode]]", fullUnicode);
      SLOT.set(this, "[[Done]]", false);
    };
    var IteratorPrototype = GetIntrinsic("%IteratorPrototype%", true);
    if (IteratorPrototype) {
      RegExpStringIterator.prototype = OrdinaryObjectCreate(IteratorPrototype);
    }
    define(RegExpStringIterator.prototype, {
      next: function next() {
        var O = this;
        if (Type(O) !== "Object") {
          throw new TypeError("receiver must be an object");
        }
        if (!(O instanceof RegExpStringIterator) || !SLOT.has(O, "[[IteratingRegExp]]") || !SLOT.has(O, "[[IteratedString]]") || !SLOT.has(O, "[[Global]]") || !SLOT.has(O, "[[Unicode]]") || !SLOT.has(O, "[[Done]]")) {
          throw new TypeError('"this" value must be a RegExpStringIterator instance');
        }
        if (SLOT.get(O, "[[Done]]")) {
          return CreateIterResultObject(undefined2, true);
        }
        var R = SLOT.get(O, "[[IteratingRegExp]]");
        var S = SLOT.get(O, "[[IteratedString]]");
        var global2 = SLOT.get(O, "[[Global]]");
        var fullUnicode = SLOT.get(O, "[[Unicode]]");
        var match = RegExpExec(R, S);
        if (match === null) {
          SLOT.set(O, "[[Done]]", true);
          return CreateIterResultObject(undefined2, true);
        }
        if (global2) {
          var matchStr = ToString(Get(match, "0"));
          if (matchStr === "") {
            var thisIndex = ToLength(Get(R, "lastIndex"));
            var nextIndex = AdvanceStringIndex(S, thisIndex, fullUnicode);
            Set2(R, "lastIndex", nextIndex, true);
          }
          return CreateIterResultObject(match, false);
        }
        SLOT.set(O, "[[Done]]", true);
        return CreateIterResultObject(match, false);
      }
    });
    if (hasSymbols) {
      defineP = Object.defineProperty;
      if (Symbol.toStringTag) {
        if (defineP) {
          defineP(RegExpStringIterator.prototype, Symbol.toStringTag, {
            configurable: true,
            enumerable: false,
            value: "RegExp String Iterator",
            writable: false
          });
        } else {
          RegExpStringIterator.prototype[Symbol.toStringTag] = "RegExp String Iterator";
        }
      }
      if (!IteratorPrototype && Symbol.iterator) {
        func2 = {};
        func2[Symbol.iterator] = RegExpStringIterator.prototype[Symbol.iterator] || function SymbolIterator() {
          return this;
        };
        predicate = {};
        predicate[Symbol.iterator] = function() {
          return RegExpStringIterator.prototype[Symbol.iterator] !== func2[Symbol.iterator];
        };
        define(RegExpStringIterator.prototype, func2, predicate);
      }
    }
    var defineP;
    var func2;
    var predicate;
    module2.exports = RegExpStringIterator;
  }
});

// node_modules/string.prototype.matchall/regexp-matchall.js
var require_regexp_matchall = __commonJS({
  "node_modules/string.prototype.matchall/regexp-matchall.js"(exports2, module2) {
    "use strict";
    var Get = require_Get();
    var Set2 = require_Set();
    var SpeciesConstructor = require_SpeciesConstructor2();
    var ToLength = require_ToLength();
    var ToString = require_ToString();
    var Type = require_Type4();
    var flagsGetter = require_regexp_prototype();
    var RegExpStringIterator = require_RegExpStringIterator();
    var OrigRegExp = RegExp;
    var CreateRegExpStringIterator = function CreateRegExpStringIterator2(R, S, global2, fullUnicode) {
      if (Type(S) !== "String") {
        throw new TypeError('"S" value must be a String');
      }
      if (Type(global2) !== "Boolean") {
        throw new TypeError('"global" value must be a Boolean');
      }
      if (Type(fullUnicode) !== "Boolean") {
        throw new TypeError('"fullUnicode" value must be a Boolean');
      }
      var iterator = new RegExpStringIterator(R, S, global2, fullUnicode);
      return iterator;
    };
    var supportsConstructingWithFlags = "flags" in RegExp.prototype;
    var constructRegexWithFlags = function constructRegex(C, R) {
      var matcher;
      var flags = "flags" in R ? Get(R, "flags") : ToString(flagsGetter(R));
      if (supportsConstructingWithFlags && typeof flags === "string") {
        matcher = new C(R, flags);
      } else if (C === OrigRegExp) {
        matcher = new C(R.source, flags);
      } else {
        matcher = new C(R, flags);
      }
      return { flags, matcher };
    };
    var regexMatchAll = function SymbolMatchAll(string2) {
      var R = this;
      if (Type(R) !== "Object") {
        throw new TypeError('"this" value must be an Object');
      }
      var S = ToString(string2);
      var C = SpeciesConstructor(R, OrigRegExp);
      var tmp = constructRegexWithFlags(C, R);
      var flags = tmp.flags;
      var matcher = tmp.matcher;
      var lastIndex = ToLength(Get(R, "lastIndex"));
      Set2(matcher, "lastIndex", lastIndex, true);
      var global2 = flags.indexOf("g") > -1;
      var fullUnicode = flags.indexOf("u") > -1;
      return CreateRegExpStringIterator(matcher, S, global2, fullUnicode);
    };
    var defineP = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    if (defineP && gOPD) {
      desc = gOPD(regexMatchAll, "name");
      if (desc && desc.configurable) {
        defineP(regexMatchAll, "name", { value: "[Symbol.matchAll]" });
      }
    }
    var desc;
    module2.exports = regexMatchAll;
  }
});

// node_modules/string.prototype.matchall/polyfill-regexp-matchall.js
var require_polyfill_regexp_matchall = __commonJS({
  "node_modules/string.prototype.matchall/polyfill-regexp-matchall.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_has_symbols()();
    var regexpMatchAll = require_regexp_matchall();
    module2.exports = function getRegExpMatchAllPolyfill() {
      if (!hasSymbols || typeof Symbol.matchAll !== "symbol" || typeof RegExp.prototype[Symbol.matchAll] !== "function") {
        return regexpMatchAll;
      }
      return RegExp.prototype[Symbol.matchAll];
    };
  }
});

// node_modules/string.prototype.matchall/implementation.js
var require_implementation5 = __commonJS({
  "node_modules/string.prototype.matchall/implementation.js"(exports2, module2) {
    "use strict";
    var Call = require_Call();
    var Get = require_Get();
    var GetMethod = require_GetMethod();
    var IsRegExp = require_IsRegExp();
    var ToString = require_ToString();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound2();
    var hasSymbols = require_has_symbols()();
    var flagsGetter = require_regexp_prototype();
    var $indexOf = callBound("String.prototype.indexOf");
    var regexpMatchAllPolyfill = require_polyfill_regexp_matchall();
    var getMatcher = function getMatcher2(regexp) {
      var matcherPolyfill = regexpMatchAllPolyfill();
      if (hasSymbols && typeof Symbol.matchAll === "symbol") {
        var matcher = GetMethod(regexp, Symbol.matchAll);
        if (matcher === RegExp.prototype[Symbol.matchAll] && matcher !== matcherPolyfill) {
          return matcherPolyfill;
        }
        return matcher;
      }
      if (IsRegExp(regexp)) {
        return matcherPolyfill;
      }
    };
    module2.exports = function matchAll2(regexp) {
      var O = RequireObjectCoercible(this);
      if (typeof regexp !== "undefined" && regexp !== null) {
        var isRegExp = IsRegExp(regexp);
        if (isRegExp) {
          var flags = "flags" in regexp ? Get(regexp, "flags") : flagsGetter(regexp);
          RequireObjectCoercible(flags);
          if ($indexOf(ToString(flags), "g") < 0) {
            throw new TypeError("matchAll requires a global regular expression");
          }
        }
        var matcher = getMatcher(regexp);
        if (typeof matcher !== "undefined") {
          return Call(matcher, regexp, [O]);
        }
      }
      var S = ToString(O);
      var rx = new RegExp(regexp, "g");
      return Call(getMatcher(rx), rx, [S]);
    };
  }
});

// node_modules/string.prototype.matchall/polyfill.js
var require_polyfill3 = __commonJS({
  "node_modules/string.prototype.matchall/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation5();
    module2.exports = function getPolyfill() {
      if (String.prototype.matchAll) {
        try {
          "".matchAll(RegExp.prototype);
        } catch (e) {
          return String.prototype.matchAll;
        }
      }
      return implementation;
    };
  }
});

// node_modules/string.prototype.matchall/shim.js
var require_shim3 = __commonJS({
  "node_modules/string.prototype.matchall/shim.js"(exports2, module2) {
    "use strict";
    var define = require_define_properties();
    var hasSymbols = require_has_symbols()();
    var getPolyfill = require_polyfill3();
    var regexpMatchAllPolyfill = require_polyfill_regexp_matchall();
    var defineP = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    module2.exports = function shimMatchAll() {
      var polyfill = getPolyfill();
      define(String.prototype, { matchAll: polyfill }, { matchAll: function() {
        return String.prototype.matchAll !== polyfill;
      } });
      if (hasSymbols) {
        var symbol = Symbol.matchAll || (Symbol["for"] ? Symbol["for"]("Symbol.matchAll") : Symbol("Symbol.matchAll"));
        define(Symbol, { matchAll: symbol }, { matchAll: function() {
          return Symbol.matchAll !== symbol;
        } });
        if (defineP && gOPD) {
          var desc = gOPD(Symbol, symbol);
          if (!desc || desc.configurable) {
            defineP(Symbol, symbol, {
              configurable: false,
              enumerable: false,
              value: symbol,
              writable: false
            });
          }
        }
        var regexpMatchAll = regexpMatchAllPolyfill();
        var func2 = {};
        func2[symbol] = regexpMatchAll;
        var predicate = {};
        predicate[symbol] = function() {
          return RegExp.prototype[symbol] !== regexpMatchAll;
        };
        define(RegExp.prototype, func2, predicate);
      }
      return polyfill;
    };
  }
});

// node_modules/string.prototype.matchall/index.js
var require_string_prototype = __commonJS({
  "node_modules/string.prototype.matchall/index.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind();
    var define = require_define_properties();
    var implementation = require_implementation5();
    var getPolyfill = require_polyfill3();
    var shim = require_shim3();
    var boundMatchAll = callBind(implementation);
    define(boundMatchAll, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = boundMatchAll;
  }
});

// src/handler/helper.ts
function getPreviousContainer(containerName, symbols) {
  if (!symbols.length)
    return null;
  let i = symbols.length - 1;
  let last = symbols[i];
  if (last.text == containerName) {
    return last;
  }
  while (i >= 0) {
    let sym = symbols[i];
    if (sym.text == containerName) {
      return sym;
    }
    i--;
  }
  return null;
}
function sortDocumentSymbols(a, b) {
  let ra = a.selectionRange;
  let rb = b.selectionRange;
  if (ra.start.line < rb.start.line) {
    return -1;
  }
  if (ra.start.line > rb.start.line) {
    return 1;
  }
  return ra.start.character - rb.start.character;
}
function addDocumentSymbol(res, sym, level) {
  let { name: name2, selectionRange, kind, children, range } = sym;
  let { start } = selectionRange;
  res.push({
    col: start.character + 1,
    lnum: start.line + 1,
    text: name2,
    level,
    kind: getSymbolKind(kind),
    range,
    selectionRange
  });
  if (children && children.length) {
    children.sort(sortDocumentSymbols);
    for (let sym2 of children) {
      addDocumentSymbol(res, sym2, level + 1);
    }
  }
}
function sortSymbolInformations(a, b) {
  let sa = a.location.range.start;
  let sb = b.location.range.start;
  let d = sa.line - sb.line;
  return d == 0 ? sa.character - sb.character : d;
}
function isDocumentSymbol(a) {
  return a && !a.hasOwnProperty("location");
}
function isDocumentSymbols(a) {
  return isDocumentSymbol(a[0]);
}
function isMarkdown(content) {
  if (import_vscode_languageserver_protocol77.MarkupContent.is(content) && content.kind == import_vscode_languageserver_protocol77.MarkupKind.Markdown) {
    return true;
  }
  return false;
}
function addDocument(docs, text, filetype, isPreview = false) {
  let content = text.trim();
  if (!content.length)
    return;
  if (isPreview && filetype !== "markdown") {
    content = "``` " + filetype + "\n" + content + "\n```";
  }
  docs.push({ content, filetype });
}
async function synchronizeDocument(doc) {
  let { changedtick } = doc;
  await doc.patchChange();
  if (changedtick != doc.changedtick) {
    await wait(50);
  }
}
function toHexString(color) {
  let c = toHexColor(color);
  return `${pad(c.red.toString(16))}${pad(c.green.toString(16))}${pad(c.blue.toString(16))}`;
}
function pad(str) {
  return str.length == 1 ? `0${str}` : str;
}
function toHexColor(color) {
  let { red, green, blue: blue2 } = color;
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue2 * 255)
  };
}
function isDark(color) {
  let rgb = [color.red, color.green, color.blue];
  let lum = [];
  for (let i = 0; i < rgb.length; i++) {
    let chan = rgb[i];
    lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
  }
  let luma = 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
  return luma <= 0.5;
}
var import_vscode_languageserver_protocol77, import_string_prototype;
var init_helper = __esm({
  "src/handler/helper.ts"() {
    import_vscode_languageserver_protocol77 = __toModule(require_main2());
    init_util();
    init_convert();
    import_string_prototype = __toModule(require_string_prototype());
    import_string_prototype.default.shim();
  }
});

// src/handler/colors/colorBuffer.ts
var import_debounce11, import_vscode_languageserver_protocol78, logger84, ColorBuffer;
var init_colorBuffer = __esm({
  "src/handler/colors/colorBuffer.ts"() {
    import_debounce11 = __toModule(require_debounce());
    import_vscode_languageserver_protocol78 = __toModule(require_main2());
    init_languages();
    init_array();
    init_object();
    init_position();
    init_workspace();
    init_helper();
    logger84 = require_logger2()("colors-buffer");
    ColorBuffer = class {
      constructor(nvim, bufnr, enabled, usedColors) {
        this.nvim = nvim;
        this.bufnr = bufnr;
        this.enabled = enabled;
        this.usedColors = usedColors;
        this._colors = [];
        this.highlight = (0, import_debounce11.default)(() => {
          this.doHighlight().catch((e) => {
            logger84.error("Error on color highlight:", e.stack);
          });
        }, global.hasOwnProperty("__TEST__") ? 10 : 500);
      }
      onChange() {
        this.cancel();
        this.highlight();
      }
      get buffer() {
        return this.nvim.createBuffer(this.bufnr);
      }
      get colors() {
        return this._colors;
      }
      hasColor() {
        return this._colors.length > 0;
      }
      setState(enabled) {
        this.enabled = enabled;
        if (enabled) {
          this.highlight();
        } else {
          this.clearHighlight();
        }
      }
      async doHighlight() {
        let doc = workspace_default.getDocument(this.bufnr);
        if (!doc || !this.enabled)
          return;
        try {
          this.tokenSource = new import_vscode_languageserver_protocol78.CancellationTokenSource();
          let { token } = this.tokenSource;
          if (this.version && doc.version == this.version)
            return;
          let { version: version2 } = doc;
          let colors;
          colors = await languages_default.provideDocumentColors(doc.textDocument, token);
          colors = colors || [];
          if (token.isCancellationRequested)
            return;
          this.version = version2;
          await this.addHighlight(colors, token);
        } catch (e) {
          logger84.error("Error on highlight:", e);
        }
      }
      async addHighlight(colors, token) {
        colors = colors || [];
        if (equals(this._colors, colors))
          return;
        let { nvim } = this;
        this._colors = colors;
        let groups = group(colors, 100);
        nvim.pauseNotification();
        this.buffer.clearNamespace("color");
        this.defineColors(colors);
        nvim.resumeNotification(false, true);
        for (let colors2 of groups) {
          if (token.isCancellationRequested) {
            this._colors = [];
            return;
          }
          nvim.pauseNotification();
          let colorRanges = this.getColorRanges(colors2);
          for (let o of colorRanges) {
            this.highlightColor(o.ranges, o.color);
          }
          nvim.resumeNotification(false, true);
        }
        if (workspace_default.isVim) {
          this.nvim.command("redraw", true);
        }
      }
      highlightColor(ranges, color) {
        let { red, green, blue: blue2 } = toHexColor(color);
        let hlGroup = `BG${toHexString(color)}`;
        this.buffer.highlightRanges("color", hlGroup, ranges);
      }
      defineColors(colors) {
        for (let color of colors) {
          let hex = toHexString(color.color);
          if (!this.usedColors.has(hex)) {
            this.nvim.command(`hi BG${hex} guibg=#${hex} guifg=#${isDark(color.color) ? "ffffff" : "000000"}`, true);
            this.usedColors.add(hex);
          }
        }
      }
      getColorRanges(infos) {
        let res = [];
        for (let info of infos) {
          let { color, range } = info;
          let idx = res.findIndex((o) => equals(toHexColor(o.color), toHexColor(color)));
          if (idx == -1) {
            res.push({
              color,
              ranges: [range]
            });
          } else {
            let r = res[idx];
            r.ranges.push(range);
          }
        }
        return res;
      }
      clearHighlight() {
        this.highlight.clear();
        this._colors = [];
        this.version = null;
        this.buffer.clearNamespace("color");
      }
      hasColorAtPostion(position) {
        let { colors } = this;
        return colors.some((o) => positionInRange(position, o.range) == 0);
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      dispose() {
        this.highlight.clear();
        this.cancel();
      }
    };
  }
});

// src/handler/colors/index.ts
var import_vscode_languageserver_protocol79, logger85, Colors;
var init_colors = __esm({
  "src/handler/colors/index.ts"() {
    import_vscode_languageserver_protocol79 = __toModule(require_main2());
    init_extensions2();
    init_languages();
    init_util();
    init_window();
    init_workspace();
    init_helper();
    init_colorBuffer();
    logger85 = require_logger2()("colors");
    Colors = class {
      constructor(nvim) {
        this.nvim = nvim;
        this._enabled = true;
        this.disposables = [];
        let config = workspace_default.getConfiguration("coc.preferences");
        this._enabled = config.get("colorSupport", true);
        if (workspace_default.isVim && !workspace_default.env.textprop) {
          this._enabled = false;
        }
        let usedColors = new Set();
        this.highlighters = workspace_default.registerBufferSync((doc) => {
          let buf = new ColorBuffer(this.nvim, doc.bufnr, this._enabled, usedColors);
          buf.highlight();
          return buf;
        });
        extensions_default.onDidActiveExtension(() => {
          this.highlightAll();
        }, null, this.disposables);
        workspace_default.onDidChangeConfiguration(async (e) => {
          if (workspace_default.isVim && !workspace_default.env.textprop)
            return;
          if (e.affectsConfiguration("coc.preferences.colorSupport")) {
            let config2 = workspace_default.getConfiguration("coc.preferences");
            let enabled = config2.get("colorSupport", true);
            if (enabled != this._enabled) {
              this._enabled = enabled;
              for (let buf of this.highlighters.items) {
                buf.setState(enabled);
              }
            }
          }
        }, null, this.disposables);
      }
      async pickPresentation() {
        let info = await this.currentColorInfomation();
        if (!info)
          return window_default.showMessage("Color not found at current position", "warning");
        let document2 = await workspace_default.document;
        let tokenSource = new import_vscode_languageserver_protocol79.CancellationTokenSource();
        let presentations = await languages_default.provideColorPresentations(info, document2.textDocument, tokenSource.token);
        if (!presentations || presentations.length == 0)
          return;
        let res = await window_default.showMenuPicker(presentations.map((o) => o.label), "choose color:");
        if (res == -1)
          return;
        let presentation = presentations[res];
        let { textEdit, additionalTextEdits, label } = presentation;
        if (!textEdit)
          textEdit = { range: info.range, newText: label };
        await document2.applyEdits([textEdit]);
        if (additionalTextEdits) {
          await document2.applyEdits(additionalTextEdits);
        }
      }
      async pickColor() {
        let info = await this.currentColorInfomation();
        if (!info)
          return window_default.showMessage("Color not found at current position", "warning");
        let { color } = info;
        let colorArr = [(color.red * 255).toFixed(0), (color.green * 255).toFixed(0), (color.blue * 255).toFixed(0)];
        let res = await this.nvim.call("coc#util#pick_color", [colorArr]);
        if (res === false) {
          return;
        }
        if (!res || res.length != 3) {
          window_default.showMessage("Failed to get color", "warning");
          return;
        }
        let hex = toHexString({
          red: res[0] / 65535,
          green: res[1] / 65535,
          blue: res[2] / 65535,
          alpha: 1
        });
        let document2 = await workspace_default.document;
        await document2.applyEdits([{
          range: info.range,
          newText: `#${hex}`
        }]);
      }
      get enabled() {
        return this._enabled;
      }
      clearHighlight(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
          return;
        highlighter.clearHighlight();
      }
      hasColor(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
          return false;
        return highlighter.hasColor();
      }
      hasColorAtPostion(bufnr, position) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
          return false;
        return highlighter.hasColorAtPostion(position);
      }
      highlightAll() {
        for (let buf of this.highlighters.items) {
          buf.highlight();
        }
      }
      async doHighlight(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
          return;
        await highlighter.doHighlight();
      }
      async currentColorInfomation() {
        let bufnr = await this.nvim.call("bufnr", "%");
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter)
          return null;
        let position = await window_default.getCursorPosition();
        for (let info of highlighter.colors) {
          let { range } = info;
          let { start, end } = range;
          if (position.line == start.line && position.character >= start.character && position.character <= end.character) {
            return info;
          }
        }
        return null;
      }
      dispose() {
        this.highlighters.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/format.ts
var import_vscode_languageserver_protocol80, logger86, pairs, FormatHandler;
var init_format2 = __esm({
  "src/handler/format.ts"() {
    import_vscode_languageserver_protocol80 = __toModule(require_main2());
    init_events();
    init_languages();
    init_manager4();
    init_util();
    init_position();
    init_string();
    init_window();
    init_workspace();
    init_helper();
    logger86 = require_logger2()("handler-format");
    pairs = new Map([
      ["<", ">"],
      [">", "<"],
      ["{", "}"],
      ["[", "]"],
      ["(", ")"]
    ]);
    FormatHandler = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        this.requestStatusItem = window_default.createStatusBarItem(0, { progress: true });
        this.loadPreferences();
        workspace_default.onDidChangeConfiguration(this.loadPreferences, this, this.disposables);
        workspace_default.onWillSaveTextDocument((event) => {
          let { languageId } = event.document;
          let filetypes = this.preferences.formatOnSaveFiletypes;
          if (filetypes.includes(languageId) || filetypes.some((item) => item === "*")) {
            let willSaveWaitUntil = async () => {
              if (!languages_default.hasFormatProvider(event.document)) {
                logger86.warn(`Format provider not found for ${event.document.uri}`);
                return void 0;
              }
              let options = await workspace_default.getFormatOptions(event.document.uri);
              let tokenSource = new import_vscode_languageserver_protocol80.CancellationTokenSource();
              let timer = setTimeout(() => {
                tokenSource.cancel();
              }, 1e3);
              let textEdits = await languages_default.provideDocumentFormattingEdits(event.document, options, tokenSource.token);
              clearTimeout(timer);
              return textEdits;
            };
            event.waitUntil(willSaveWaitUntil());
          }
        }, null, this.disposables);
        events_default.on(["CursorMoved", "CursorMovedI", "InsertEnter", "TextChangedI", "TextChangedP", "TextChanged"], () => {
          if (this.requestTokenSource) {
            this.requestTokenSource.cancel();
            this.requestTokenSource = null;
          }
        }, null, this.disposables);
        events_default.on("Enter", async (bufnr) => {
          let { bracketEnterImprove } = this.preferences;
          await this.tryFormatOnType("\n", bufnr);
          if (bracketEnterImprove) {
            let line = await nvim.call("line", ".") - 1;
            let doc = workspace_default.getDocument(bufnr);
            if (!doc)
              return;
            await doc.patchChange();
            let pre = doc.getline(line - 1);
            let curr = doc.getline(line);
            let prevChar = pre[pre.length - 1];
            if (prevChar && pairs.has(prevChar)) {
              let nextChar = curr.trim()[0];
              if (nextChar && pairs.get(prevChar) == nextChar) {
                let edits = [];
                let opts = await workspace_default.getFormatOptions(doc.uri);
                let space = opts.insertSpaces ? " ".repeat(opts.tabSize) : "	";
                let currIndent = curr.match(/^\s*/)[0];
                let pos = import_vscode_languageserver_protocol80.Position.create(line - 1, pre.length);
                if (doc.filetype == "vim") {
                  let newText = "\n" + currIndent + space;
                  edits.push({ range: import_vscode_languageserver_protocol80.Range.create(line, currIndent.length, line, currIndent.length), newText: "  \\ " });
                  newText = newText + "\\ ";
                  edits.push({ range: import_vscode_languageserver_protocol80.Range.create(pos, pos), newText });
                  await doc.applyEdits(edits);
                  await window_default.moveTo(import_vscode_languageserver_protocol80.Position.create(line, newText.length - 1));
                } else {
                  await nvim.eval(`feedkeys("\\<Esc>O", 'in')`);
                }
              }
            }
          }
        }, null, this.disposables);
        let changedTs;
        let lastInsert;
        events_default.on("InsertCharPre", async () => {
          lastInsert = Date.now();
        }, null, this.disposables);
        events_default.on("TextChangedI", async (bufnr, info) => {
          changedTs = Date.now();
          if (!lastInsert || changedTs - lastInsert > 300)
            return;
          lastInsert = null;
          let doc = workspace_default.getDocument(bufnr);
          if (!doc)
            return;
          let pre = info.pre[info.pre.length - 1];
          if (!pre || !languages_default.hasProvider("onTypeEdit", doc.textDocument))
            return;
          await this.tryFormatOnType(pre, bufnr);
        }, null, this.disposables);
        let lastEnterBufnr;
        let lastEnterTs;
        events_default.on("InsertEnter", (bufnr) => {
          lastEnterBufnr = bufnr;
          lastEnterTs = Date.now();
        });
        events_default.on("TextChangedI", async (bufnr, info) => {
          if (!this.preferences.formatOnType && !/^\s*$/.test(info.pre))
            return;
          if (lastEnterBufnr != bufnr || !lastEnterTs || Date.now() - lastEnterTs > 30)
            return;
          await this.tryFormatOnType("\n", bufnr, true);
        });
      }
      loadPreferences(e) {
        if (!e || e.affectsConfiguration("coc.preferences")) {
          let config = workspace_default.getConfiguration("coc.preferences");
          this.preferences = {
            formatOnType: config.get("formatOnType", false),
            formatOnSaveFiletypes: config.get("formatOnSaveFiletypes", []),
            formatOnTypeFiletypes: config.get("formatOnTypeFiletypes", []),
            bracketEnterImprove: config.get("bracketEnterImprove", true)
          };
        }
      }
      async withRequestToken(name2, fn) {
        if (this.requestTokenSource) {
          this.requestTokenSource.cancel();
          this.requestTokenSource.dispose();
        }
        let statusItem = this.requestStatusItem;
        this.requestTokenSource = new import_vscode_languageserver_protocol80.CancellationTokenSource();
        let { token } = this.requestTokenSource;
        token.onCancellationRequested(() => {
          statusItem.text = `${name2} request canceled`;
          statusItem.isProgress = false;
          statusItem.hide();
        });
        statusItem.isProgress = true;
        statusItem.text = `requesting ${name2}`;
        statusItem.show();
        let res;
        try {
          res = await Promise.resolve(fn(token));
        } catch (e) {
          window_default.showMessage(e.message, "error");
          logger86.error(`Error on ${name2}`, e);
        }
        if (this.requestTokenSource) {
          this.requestTokenSource.dispose();
          this.requestTokenSource = void 0;
        }
        if (token.isCancellationRequested)
          return null;
        statusItem.hide();
        if (res == null) {
          logger86.warn(`${name2} provider not found!`);
        }
        return res;
      }
      async tryFormatOnType(ch, bufnr, newLine = false) {
        if (!ch || isWord(ch) || !this.preferences.formatOnType)
          return;
        if (manager_default2.getSession(bufnr) != null)
          return;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached || doc.isCommandLine)
          return;
        const filetypes = this.preferences.formatOnTypeFiletypes;
        if (filetypes.length && !filetypes.includes(doc.filetype)) {
          return;
        }
        if (!languages_default.hasOnTypeProvider(ch, doc.textDocument))
          return;
        let position;
        let edits = await this.withRequestToken("onTypeFormat ", async (token) => {
          position = await window_default.getCursorPosition();
          let origLine = doc.getline(position.line - 1);
          if (newLine && /^\s*$/.test(origLine))
            return;
          let pos = newLine ? { line: position.line - 1, character: origLine.length } : position;
          await synchronizeDocument(doc);
          return await languages_default.provideDocumentOnTypeEdits(ch, doc.textDocument, pos, token);
        });
        if (!edits || !edits.length)
          return;
        let changed = getChangedFromEdits(position, edits);
        await doc.applyEdits(edits);
        let to = changed ? import_vscode_languageserver_protocol80.Position.create(position.line + changed.line, position.character + changed.character) : null;
        if (to && !newLine)
          await window_default.moveTo(to);
      }
      async documentFormat(doc) {
        await synchronizeDocument(doc);
        let options = await workspace_default.getFormatOptions(doc.uri);
        let textEdits = await this.withRequestToken("format", (token) => {
          return languages_default.provideDocumentFormattingEdits(doc.textDocument, options, token);
        });
        if (textEdits && textEdits.length > 0) {
          await doc.applyEdits(textEdits);
          return true;
        }
        return false;
      }
      async documentRangeFormat(doc, mode) {
        await synchronizeDocument(doc);
        let range;
        if (mode) {
          range = await workspace_default.getSelectedRange(mode, doc);
          if (!range)
            return -1;
        } else {
          let [lnum, count, mode2] = await this.nvim.eval("[v:lnum,v:count,mode()]");
          if (count == 0 || mode2 == "i" || mode2 == "R")
            return -1;
          range = import_vscode_languageserver_protocol80.Range.create(lnum - 1, 0, lnum - 1 + count, 0);
        }
        let options = await workspace_default.getFormatOptions(doc.uri);
        let textEdits = await this.withRequestToken("format", (token) => {
          return languages_default.provideDocumentRangeFormattingEdits(doc.textDocument, range, options, token);
        });
        if (textEdits && textEdits.length > 0) {
          await doc.applyEdits(textEdits);
          return 0;
        }
        return -1;
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/highlights.ts
var import_vscode_languageserver_protocol81, logger87, Highlights;
var init_highlights = __esm({
  "src/handler/highlights.ts"() {
    import_vscode_languageserver_protocol81 = __toModule(require_main2());
    init_events();
    init_languages();
    init_util();
    init_window();
    init_workspace();
    logger87 = require_logger2()("documentHighlight");
    Highlights = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        this.highlights = new Map();
        events_default.on(["TextChanged", "TextChangedI", "CursorMoved", "CursorMovedI"], () => {
          this.cancel();
          this.clearHighlights();
        }, null, this.disposables);
      }
      clearHighlights() {
        if (this.highlights.size == 0)
          return;
        let { nvim } = workspace_default;
        for (let winid of this.highlights.keys()) {
          let win = nvim.createWindow(winid);
          win.clearMatchGroup("^CocHighlight");
        }
        this.highlights.clear();
      }
      async highlight() {
        let { nvim } = this;
        this.cancel();
        let [bufnr, winid, cursors] = await nvim.eval(`[bufnr('%'),win_getid(),get(b:,'coc_cursors_activated',0)]`);
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached || !languages_default.hasProvider("documentHighlight", doc.textDocument))
          return;
        if (cursors)
          return;
        let position = await window_default.getCursorPosition();
        let highlights = await this.getHighlights(doc, position);
        if (!highlights)
          return;
        let groups = {};
        for (let hl of highlights) {
          if (!hl.range)
            continue;
          let hlGroup = hl.kind == import_vscode_languageserver_protocol81.DocumentHighlightKind.Text ? "CocHighlightText" : hl.kind == import_vscode_languageserver_protocol81.DocumentHighlightKind.Read ? "CocHighlightRead" : "CocHighlightWrite";
          groups[hlGroup] = groups[hlGroup] || [];
          groups[hlGroup].push(hl.range);
        }
        let win = nvim.createWindow(winid);
        nvim.pauseNotification();
        win.clearMatchGroup("^CocHighlight");
        for (let hlGroup of Object.keys(groups)) {
          win.highlightRanges(hlGroup, groups[hlGroup], -1, true);
        }
        if (workspace_default.isVim)
          nvim.command("redraw", true);
        let res = this.nvim.resumeNotification();
        if (Array.isArray(res) && res[1] != null) {
          logger87.error(`Error on highlight`, res[1][2]);
        } else {
          this.highlights.set(winid, highlights);
        }
      }
      hasHighlights(winid) {
        return this.highlights.get(winid) != null;
      }
      async getHighlights(doc, position) {
        if (!doc || !doc.attached || doc.isCommandLine)
          return null;
        let line = doc.getline(position.line);
        let ch = line[position.character];
        if (!ch || !doc.isWord(ch))
          return null;
        try {
          this.tokenSource = new import_vscode_languageserver_protocol81.CancellationTokenSource();
          doc.forceSync();
          let { token } = this.tokenSource;
          let highlights = await languages_default.getDocumentHighLight(doc.textDocument, position, token);
          this.tokenSource = null;
          if (token.isCancellationRequested)
            return null;
          return highlights;
        } catch (_e) {
          return null;
        }
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource.dispose();
          this.tokenSource = null;
        }
      }
      dispose() {
        this.highlights.clear();
        this.cancel();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/search.ts
function getPathFromArgs(args) {
  if (args.length < 2)
    return void 0;
  let len = args.length;
  if (args[len - 1].startsWith("-"))
    return void 0;
  if (["-e", "-f"].includes(args[len - 2]))
    return void 0;
  return args[len - 1];
}
var import_child_process6, import_events31, import_os10, import_path32, import_readline5, import_which5, logger88, defaultArgs, controlCode2, Task2, Search;
var init_search = __esm({
  "src/handler/search.ts"() {
    init_mutex();
    import_child_process6 = __toModule(require("child_process"));
    import_events31 = __toModule(require("events"));
    import_os10 = __toModule(require("os"));
    import_path32 = __toModule(require("path"));
    import_readline5 = __toModule(require("readline"));
    init_main();
    import_which5 = __toModule(require_which());
    init_highligher();
    init_ansiparse();
    init_window();
    logger88 = require_logger2()("handler-search");
    defaultArgs = ["--color", "ansi", "--colors", "path:fg:black", "--colors", "line:fg:green", "--colors", "match:fg:red", "--no-messages", "--heading", "-n"];
    controlCode2 = "";
    Task2 = class extends import_events31.EventEmitter {
      start(cmd, args, cwd) {
        this.process = (0, import_child_process6.spawn)(cmd, args, { cwd });
        this.process.on("error", (e) => {
          this.emit("error", e.message);
        });
        const rl = import_readline5.default.createInterface(this.process.stdout);
        let start;
        let fileItem;
        let lines = [];
        let highlights = [];
        let create = true;
        rl.on("line", (content) => {
          if (content.includes(controlCode2)) {
            let items = ansiparse(content);
            if (items[0].foreground == "black") {
              fileItem = { filepath: import_path32.default.join(cwd, items[0].text), ranges: [] };
              return;
            }
            let normalLine = items[0].foreground == "green";
            if (normalLine) {
              let lnum = parseInt(items[0].text, 10) - 1;
              let padlen2 = items[0].text.length + 1;
              if (create) {
                start = lnum;
                create = false;
              }
              let line = "";
              for (let item of items) {
                if (item.foreground == "red") {
                  let l = lnum - start;
                  let c = line.length - padlen2;
                  highlights.push(Range.create(l, c, l, c + item.text.length));
                }
                line += item.text;
              }
              let currline = line.slice(padlen2);
              lines.push(currline);
            }
          } else {
            let fileEnd = content.trim().length == 0;
            if (fileItem && (fileEnd || content.trim() == "--")) {
              let fileRange = {
                lines,
                highlights,
                start,
                end: start + lines.length
              };
              fileItem.ranges.push(fileRange);
            }
            if (fileEnd) {
              this.emit("item", fileItem);
              fileItem = null;
            }
            lines = [];
            highlights = [];
            create = true;
          }
        });
        rl.on("close", () => {
          if (fileItem) {
            if (lines.length) {
              let fileRange = {
                lines,
                highlights,
                start,
                end: start + lines.length
              };
              fileItem.ranges.push(fileRange);
            }
            this.emit("item", fileItem);
          }
          lines = highlights = fileItem = null;
          this.emit("end");
        });
      }
      dispose() {
        if (this.process) {
          this.process.kill();
        }
      }
    };
    Search = class {
      constructor(nvim, cmd = "rg") {
        this.nvim = nvim;
        this.cmd = cmd;
      }
      run(args, cwd, refactorBuf) {
        let { nvim, cmd } = this;
        let { afterContext, beforeContext } = refactorBuf.config;
        let argList = ["-A", afterContext.toString(), "-B", beforeContext.toString()].concat(defaultArgs, args);
        if (import_os10.default.platform() == "win32") {
          let p = getPathFromArgs(args);
          argList.push("--", p ? `./${p}` : "./");
        }
        try {
          cmd = import_which5.default.sync(cmd);
        } catch (e) {
          window_default.showMessage(`Please install ripgrep and make sure ${this.cmd} is in your $PATH`, "error");
          return Promise.reject(e);
        }
        this.task = new Task2();
        this.task.start(cmd, argList, cwd);
        let mutex = new Mutex();
        let files = 0;
        let matches = 0;
        let start = Date.now();
        let fileItems = [];
        const addFileItems = async () => {
          if (fileItems.length == 0)
            return;
          let items = fileItems.slice();
          fileItems = [];
          const release = await mutex.acquire();
          try {
            await refactorBuf.addFileItems(items);
          } catch (e) {
            logger88.error(e);
          }
          release();
        };
        return new Promise((resolve3, reject) => {
          let interval = setInterval(addFileItems, 300);
          this.task.on("item", async (fileItem) => {
            files++;
            matches = matches + fileItem.ranges.reduce((p, r) => p + r.highlights.length, 0);
            fileItems.push(fileItem);
          });
          this.task.on("error", (message) => {
            clearInterval(interval);
            window_default.showMessage(`Error on command "${cmd}": ${message}`, "error");
            this.task = null;
            reject(new Error(message));
          });
          this.task.on("end", async () => {
            clearInterval(interval);
            try {
              await addFileItems();
              const release = await mutex.acquire();
              release();
              this.task.removeAllListeners();
              this.task = null;
              let buf = refactorBuf.buffer;
              if (buf) {
                nvim.pauseNotification();
                if (files == 0) {
                  buf.setLines(["No match found"], { start: 1, end: 2, strictIndexing: false }, true);
                  buf.addHighlight({ line: 1, srcId: -1, colEnd: -1, colStart: 0, hlGroup: "Error" }).logError();
                  buf.setOption("modified", false, true);
                } else {
                  let highligher = new Highlighter();
                  highligher.addText("Files", "MoreMsg");
                  highligher.addText(": ");
                  highligher.addText(`${files} `, "Number");
                  highligher.addText("Matches", "MoreMsg");
                  highligher.addText(": ");
                  highligher.addText(`${matches} `, "Number");
                  highligher.addText("Duration", "MoreMsg");
                  highligher.addText(": ");
                  highligher.addText(`${Date.now() - start}ms`, "Number");
                  highligher.render(buf, 1, 2);
                }
                buf.setOption("modified", false, true);
                await nvim.resumeNotification(false, true);
              }
            } catch (e) {
              reject(e);
              return;
            }
            resolve3();
          });
        });
      }
    };
  }
});

// src/handler/refactor/buffer.ts
function adjustRange(range, offset) {
  let { start, end } = range;
  return import_vscode_languageserver_protocol82.Range.create(start.line - offset, start.character, end.line - offset, end.character);
}
var import_fast_diff5, import_path33, import_vscode_languageserver_protocol82, logger89, SEPARATOR, RefactorBuffer;
var init_buffer4 = __esm({
  "src/handler/refactor/buffer.ts"() {
    import_fast_diff5 = __toModule(require_diff2());
    import_path33 = __toModule(require("path"));
    import_vscode_languageserver_protocol82 = __toModule(require_main2());
    init_main2();
    init_esm2();
    init_commands2();
    init_highligher();
    init_util();
    init_fs();
    init_mutex();
    init_object();
    init_string();
    init_window();
    init_workspace();
    logger89 = require_logger2()("handler-refactorBuffer");
    SEPARATOR = "\u3000";
    RefactorBuffer = class {
      constructor(bufnr, srcId, nvim, config, opts) {
        this.bufnr = bufnr;
        this.srcId = srcId;
        this.nvim = nvim;
        this.config = config;
        this.opts = opts;
        this.mutex = new Mutex();
        this._disposed = false;
        this.disposables = [];
        this._fileItems = [];
        this.matchIds = new Set();
        this.changing = false;
        this.disposables.push(workspace_default.registerLocalKeymap("n", "<CR>", this.splitOpen.bind(this), true));
        workspace_default.onDidChangeTextDocument(this.onDocumentChange, this, this.disposables);
      }
      get fileItems() {
        return this._fileItems;
      }
      onChange(e) {
        if (this.changing)
          return;
        let doc = this.document;
        let { nvim, _fileItems: fileItems } = this;
        if (!fileItems.length)
          return;
        let change = e.contentChanges[0];
        if (!("range" in change))
          return;
        let { original } = e;
        if (change.range.end.line < 2)
          return;
        doc.buffer.setOption("modified", true, true);
        let { range, text } = change;
        let lines = text.split("\n");
        let lineChange = lines.length - (range.end.line - range.start.line) - 1;
        if (lineChange == 0)
          return;
        let lineChanges = [];
        if (text.includes("\u3000")) {
          let startLine = range.start.line;
          let diffs = (0, import_fast_diff5.default)(original, text);
          let offset = 0;
          let orig = TextDocument2.create("file:///1", "", 0, original);
          for (let i = 0; i < diffs.length; i++) {
            let diff = diffs[i];
            let pos = orig.positionAt(offset);
            if (diff[0] == import_fast_diff5.default.EQUAL) {
              offset = offset + diff[1].length;
            } else if (diff[0] == import_fast_diff5.default.DELETE) {
              let end = orig.positionAt(offset + diff[1].length);
              if (diffs[i + 1] && diffs[i + 1][0] == import_fast_diff5.default.INSERT) {
                let delta = diffs[i + 1][1].split("\n").length - (end.line - pos.line) - 1;
                if (delta != 0)
                  lineChanges.push({ delta, lnum: pos.line + startLine });
                i = i + 1;
              } else {
                let delta = -(end.line - pos.line);
                if (delta != 0)
                  lineChanges.push({ delta, lnum: pos.line + startLine });
              }
              offset = offset + diff[1].length;
            } else if (diff[0] == import_fast_diff5.default.INSERT) {
              let delta = diff[1].split("\n").length - 1;
              if (delta != 0)
                lineChanges.push({ delta, lnum: pos.line + startLine });
            }
          }
        } else {
          lineChanges = [{ delta: lineChange, lnum: range.start.line }];
        }
        let changed = false;
        for (let item of fileItems) {
          for (let range2 of item.ranges) {
            let arr = lineChanges.filter((o) => o.lnum < range2.lnum - 1);
            if (arr.length) {
              let total = arr.reduce((p, c) => p + c.delta, 0);
              range2.lnum = range2.lnum + total;
              changed = true;
            }
          }
        }
        if (!changed)
          return;
        nvim.pauseNotification();
        this.highlightLineNr();
        nvim.resumeNotification().then((res) => {
          if (Array.isArray(res) && res[1] != null) {
            logger89.error(`Error on highlightLineNr:`, res[1]);
          }
        }).logError();
      }
      async onDocumentChange(e) {
        if (e.bufnr == this.bufnr || this.changing)
          return;
        let { uri } = e.textDocument;
        let { range, text } = e.contentChanges[0];
        let filepath = URI.parse(uri).fsPath;
        let fileItem = this._fileItems.find((o) => o.filepath == filepath);
        if (!fileItem)
          return;
        let lineChange = text.split("\n").length - (range.end.line - range.start.line) - 1;
        let edits = [];
        for (let i = 0; i < fileItem.ranges.length; i++) {
          let r = fileItem.ranges[i];
          if (range.start.line >= r.end) {
            continue;
          }
          if (range.end.line < r.start) {
            if (lineChange == 0) {
              continue;
            } else {
              r.start = r.start + lineChange;
              r.end = r.end + lineChange;
            }
          } else {
            let doc = workspace_default.getDocument(uri);
            let newLines = doc.getLines(r.start, r.end);
            if (!newLines.length) {
              fileItem.ranges.splice(i, 1);
              edits.push({
                range: this.getFileRangeRange(r, false),
                newText: ""
              });
            } else {
              r.end = r.start + newLines.length;
              edits.push({
                range: this.getFileRangeRange(r, true),
                newText: newLines.join("\n") + "\n"
              });
            }
          }
        }
        this._fileItems = this._fileItems.filter((o) => o.ranges && o.ranges.length > 0);
        if (edits.length) {
          this.changing = true;
          await this.document.applyEdits(edits);
          this.changing = false;
        }
        this.nvim.pauseNotification();
        this.highlightLineNr();
        this.buffer.setOption("modified", false, true);
        await this.nvim.resumeNotification();
      }
      async getFileChanges() {
        if (this._disposed)
          return [];
        let changes = [];
        let lines = await this.buffer.lines;
        lines.push(SEPARATOR);
        let arr = [];
        let fsPath;
        let lnum;
        for (let i = 0; i < lines.length; i++) {
          let line = lines[i];
          if (line.startsWith(SEPARATOR)) {
            if (fsPath) {
              changes.push({
                filepath: fsPath,
                lines: arr.slice(),
                lnum
              });
              fsPath = void 0;
              arr = [];
            }
            if (line.length > 1) {
              let ms = line.match(/^\u3000(.*)/);
              if (ms) {
                fsPath = this.getAbsolutePath(ms[1].replace(/\s+$/, ""));
                lnum = i + 1;
                arr = [];
              }
            }
          } else {
            arr.push(line);
          }
        }
        return changes;
      }
      async splitOpen() {
        let { nvim } = this;
        let win = nvim.createWindow(this.opts.fromWinid);
        let valid = await win.valid;
        let lines = await nvim.eval('getline(1,line("."))');
        let len = lines.length;
        for (let i = 0; i < len; i++) {
          let line = lines[len - i - 1];
          let ms = line.match(/^\u3000(.+)/);
          if (ms) {
            let filepath = ms[1].trim();
            let r = this.getLinesRange(len - i);
            if (!r)
              return;
            let lnum = r[0] + i - 1;
            let bufname = this.getAbsolutePath(filepath);
            nvim.pauseNotification();
            if (valid) {
              nvim.call("win_gotoid", [this.opts.fromWinid], true);
              this.nvim.call("coc#util#jump", ["edit", bufname, [lnum, 1]], true);
            } else {
              this.nvim.call("coc#util#jump", ["belowright vs", bufname, [lnum, 1]], true);
            }
            nvim.command("normal! zz", true);
            let [, err] = await nvim.resumeNotification();
            if (err)
              window_default.showMessage(`Error on open ${filepath}: ${err}`, "error");
            if (!valid) {
              this.opts.fromWinid = await nvim.call("win_getid");
            }
            break;
          }
        }
      }
      async addFileItems(items) {
        if (this._disposed)
          return;
        let { cwd } = this.opts;
        let { document: document2 } = this;
        const release = await this.mutex.acquire();
        try {
          if (document2.dirty)
            document2.forceSync();
          for (let item of items) {
            let fileItem = this._fileItems.find((o) => o.filepath == item.filepath);
            if (fileItem) {
              fileItem.ranges.push(...item.ranges);
            } else {
              this._fileItems.push(item);
            }
          }
          let count = document2.lineCount;
          let highligher = new Highlighter();
          let hlRanges = [];
          for (let item of items) {
            for (let range of item.ranges) {
              highligher.addLine(SEPARATOR);
              highligher.addLine(SEPARATOR);
              range.lnum = count + highligher.length;
              highligher.addText(`${isParentFolder(cwd, item.filepath) ? import_path33.default.relative(cwd, item.filepath) : item.filepath}`);
              let n = String(range.start + 1).length + String(range.end).length + 4;
              if (!this.srcId)
                highligher.addText(" ".repeat(n));
              let base = 0 - highligher.length - count;
              if (range.highlights) {
                hlRanges.push(...range.highlights.map((r) => adjustRange(r, base)));
              }
              let { lines } = range;
              if (!lines) {
                lines = await this.getLines(item.filepath, range.start, range.end);
                range.lines = lines;
              }
              highligher.addLines(lines);
            }
          }
          let { nvim, buffer } = this;
          this.changing = true;
          nvim.pauseNotification();
          highligher.render(buffer, count);
          this.highlightLineNr();
          buffer.setOption("modified", false, true);
          buffer.setOption("undolevels", 1e3, true);
          if (count == 2 && hlRanges.length) {
            let pos = hlRanges[0].start;
            nvim.call("coc#util#jumpTo", [pos.line, pos.character], true);
          }
          if (workspace_default.isVim) {
            nvim.command("redraw", true);
          }
          let [, err] = await nvim.resumeNotification();
          if (err)
            throw new Error(err[2]);
          await document2.patchChange();
          this.changing = false;
          await commands_default.executeCommand("editor.action.addRanges", hlRanges);
        } catch (e) {
          this.changing = false;
          logger89.error(`Error on add file item:`, e);
        }
        release();
      }
      async save() {
        let { nvim } = this;
        let doc = this.document;
        let { buffer } = doc;
        await doc.patchChange();
        let changes = await this.getFileChanges();
        if (!changes)
          return;
        changes.sort((a, b) => a.lnum - b.lnum);
        let removeList = [];
        let deltaMap = new Map();
        for (let i = 0; i < changes.length; i++) {
          let change = changes[i];
          let { filepath, lnum } = change;
          let curr = deltaMap.get(filepath) || 0;
          let item = this._fileItems.find((o) => o.filepath == filepath);
          let range = item ? item.ranges.find((o) => o.lnum == lnum) : null;
          if (!range || equals(range.lines, change.lines)) {
            removeList.push(i);
            if (curr && range) {
              range.start = range.start + curr;
              range.end = range.end + curr;
            }
            continue;
          }
          change.start = range.start;
          change.end = range.end;
          if (curr != 0)
            range.start = range.start + curr;
          if (change.lines.length != range.lines.length) {
            let delta = change.lines.length - range.lines.length;
            let total = delta + curr;
            deltaMap.set(filepath, total);
            range.end = range.end + total;
          } else {
            range.end = range.end + curr;
          }
          range.lines = change.lines;
        }
        if (removeList.length)
          changes = changes.filter((_, i) => !removeList.includes(i));
        if (changes.length == 0) {
          window_default.showMessage("No change.", "more");
          await buffer.setOption("modified", false);
          return false;
        }
        let changeMap = {};
        for (let change of changes) {
          let uri = URI.file(change.filepath).toString();
          let edits = changeMap[uri] || [];
          edits.push({
            range: import_vscode_languageserver_protocol82.Range.create(change.start, 0, change.end, 0),
            newText: change.lines.join("\n") + "\n"
          });
          changeMap[uri] = edits;
        }
        this.changing = true;
        await workspace_default.applyEdit({ changes: changeMap });
        this.changing = false;
        nvim.pauseNotification();
        buffer.setOption("modified", false, true);
        if (this.config.saveToFile) {
          nvim.command("silent noa wa", true);
        }
        this.highlightLineNr();
        await nvim.resumeNotification();
        return true;
      }
      getFileRange(lnum) {
        for (let item of this._fileItems) {
          for (let r of item.ranges) {
            if (r.lnum == lnum) {
              return r;
            }
          }
        }
        return null;
      }
      getLinesRange(lnum) {
        for (let item of this._fileItems) {
          for (let range of item.ranges) {
            if (range.lnum == lnum) {
              return [range.start, range.end];
            }
          }
        }
        return null;
      }
      async getLines(fsPath, start, end) {
        let uri = URI.file(fsPath).toString();
        let doc = workspace_default.getDocument(uri);
        if (doc)
          return doc.getLines(start, end);
        return await readFileLines(fsPath, start, end - 1);
      }
      getAbsolutePath(filepath) {
        if (import_path33.default.isAbsolute(filepath))
          return filepath;
        return import_path33.default.join(this.opts.cwd, filepath);
      }
      getFileRangeRange(range, lineOnly = true) {
        let { document: document2 } = this;
        if (!document2)
          return null;
        let { lnum } = range;
        let first = document2.getline(lnum - 1);
        if (!first.startsWith("\u3000"))
          return null;
        let start = lineOnly ? lnum : lnum - 1;
        let end = document2.lineCount;
        for (let i = lnum; i < document2.lineCount; i++) {
          let line = document2.getline(i);
          if (line.startsWith("\u3000")) {
            end = lineOnly ? i : i + 1;
            break;
          }
        }
        return import_vscode_languageserver_protocol82.Range.create(start, 0, end, 0);
      }
      highlightLineNr() {
        let { _fileItems: fileItems, nvim, srcId, bufnr } = this;
        let { winid, cwd } = this.opts;
        let info = {};
        if (srcId) {
          nvim.call("nvim_buf_clear_namespace", [bufnr, srcId, 0, -1], true);
          for (let item of fileItems) {
            for (let range of item.ranges) {
              let text = `${range.start + 1}:${range.end}`;
              info[range.lnum] = [range.start + 1, range.end];
              nvim.call("nvim_buf_set_virtual_text", [bufnr, srcId, range.lnum - 1, [[text, "LineNr"]], {}], true);
            }
          }
        } else {
          if (this.matchIds.size) {
            nvim.call("coc#highlight#clear_matches", [winid, Array.from(this.matchIds)], true);
            this.matchIds.clear();
          }
          let id = 2e3;
          for (let item of fileItems) {
            let filename = `${cwd ? import_path33.default.relative(cwd, item.filepath) : item.filepath}`;
            let col = byteLength(filename) + 1;
            for (let range of item.ranges) {
              let text = `:${range.start + 1}:${range.end}`;
              for (let i = 0; i < text.length; i++) {
                let ch = text[i];
                this.matchIds.add(id);
                info[range.lnum] = [range.start + 1, range.end];
                nvim.call("matchaddpos", ["Conceal", [[range.lnum, col + i]], 99, id, { conceal: ch, window: winid }], true);
                id++;
              }
            }
          }
        }
        this.buffer.setVar("line_infos", info, true);
      }
      get valid() {
        return this.buffer.valid;
      }
      get buffer() {
        return this.nvim.createBuffer(this.bufnr);
      }
      get document() {
        if (this._disposed)
          return null;
        return workspace_default.getDocument(this.bufnr);
      }
      dispose() {
        this._disposed = true;
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/refactor/index.ts
function adjustRange2(range, offset) {
  let { start, end } = range;
  return import_vscode_languageserver_protocol83.Range.create(start.line - offset, start.character, end.line - offset, end.character);
}
function emptyWorkspaceEdit(edit2) {
  let { changes, documentChanges } = edit2;
  if (documentChanges && documentChanges.length)
    return false;
  if (changes && Object.keys(changes).length)
    return false;
  return true;
}
var import_vscode_languageserver_protocol83, logger90, name, refactorId, Refactor;
var init_refactor = __esm({
  "src/handler/refactor/index.ts"() {
    import_vscode_languageserver_protocol83 = __toModule(require_main2());
    init_esm2();
    init_util();
    init_fs();
    init_window();
    init_workspace();
    init_search();
    init_buffer4();
    logger90 = require_logger2()("handler-refactor");
    name = "__coc_refactor__";
    refactorId = 0;
    Refactor = class {
      constructor() {
        this.buffers = new Map();
        this.disposables = [];
        this._onCreate = new import_vscode_languageserver_protocol83.Emitter();
        this.onCreate = this._onCreate.event;
        this.nvim = workspace_default.nvim;
        if (workspace_default.isNvim && this.nvim.hasFunction("nvim_buf_set_virtual_text")) {
          this.srcId = workspace_default.createNameSpace("coc-refactor");
        }
        this.setConfiguration();
        workspace_default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);
        workspace_default.onDidCloseTextDocument((e) => {
          let buf = this.buffers.get(e.bufnr);
          if (buf) {
            buf.dispose();
            this.buffers.delete(e.bufnr);
          }
        }, null, this.disposables);
        workspace_default.onDidChangeTextDocument((e) => {
          let buf = this.buffers.get(e.bufnr);
          if (buf)
            buf.onChange(e);
        }, null, this.disposables);
      }
      setConfiguration(e) {
        if (e && !e.affectsConfiguration("refactor"))
          return;
        let config = workspace_default.getConfiguration("refactor");
        this.config = Object.assign(this.config || {}, {
          afterContext: config.get("afterContext", 3),
          beforeContext: config.get("beforeContext", 3),
          openCommand: config.get("openCommand", "edit"),
          saveToFile: config.get("saveToFile", true)
        });
      }
      getBuffer(bufnr) {
        return this.buffers.get(bufnr);
      }
      async search(args) {
        let buf = await this.createRefactorBuffer();
        if (!buf)
          return;
        let cwd = await this.nvim.call("getcwd", []);
        let search = new Search(this.nvim);
        await search.run(args, cwd, buf);
      }
      async createRefactorBuffer(filetype) {
        let { nvim } = this;
        let [fromWinid, cwd] = await nvim.eval("[win_getid(),getcwd()]");
        let { openCommand } = this.config;
        nvim.pauseNotification();
        nvim.command(`${openCommand} ${name}${refactorId++}`, true);
        nvim.command(`setl buftype=acwrite nobuflisted bufhidden=wipe nofen wrap conceallevel=2 concealcursor=n`, true);
        nvim.command(`setl undolevels=-1 nolist nospell noswapfile foldmethod=expr foldexpr=coc#util#refactor_foldlevel(v:lnum)`, true);
        nvim.command(`setl foldtext=coc#util#refactor_fold_text(v:foldstart)`, true);
        nvim.call("setline", [1, ["Save current buffer to make changes", SEPARATOR]], true);
        nvim.call("matchadd", ["Comment", "\\%1l"], true);
        nvim.call("matchadd", ["Conceal", "^\\%u3000"], true);
        nvim.call("matchadd", ["Label", "^\\%u3000\\zs\\S\\+"], true);
        nvim.command("setl nomod", true);
        if (filetype)
          nvim.command(`runtime! syntax/${filetype}.vim`, true);
        nvim.call("coc#util#do_autocmd", ["CocRefactorOpen"], true);
        let [, err] = await nvim.resumeNotification();
        if (err) {
          logger90.error(err);
          window_default.showMessage(`Error on open refactor window: ${err}`, "error");
          return;
        }
        let [bufnr, win] = await nvim.eval('[bufnr("%"),win_getid()]');
        let opts = { fromWinid, winid: win, cwd };
        await workspace_default.document;
        let buf = new RefactorBuffer(bufnr, this.srcId, this.nvim, this.config, opts);
        this.buffers.set(bufnr, buf);
        return buf;
      }
      async fromLines(lines) {
        let buf = await this.createRefactorBuffer();
        if (buf)
          await buf.buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false });
        return buf;
      }
      async fromLocations(locations, filetype) {
        if (!locations || locations.length == 0)
          return null;
        let changes = {};
        let edit2 = { changes };
        for (let location of locations) {
          let edits = changes[location.uri] || [];
          edits.push({ range: location.range, newText: "" });
          changes[location.uri] = edits;
        }
        return await this.fromWorkspaceEdit(edit2, filetype);
      }
      async fromWorkspaceEdit(edit2, filetype) {
        if (!edit2 || emptyWorkspaceEdit(edit2))
          return void 0;
        let items = [];
        let { beforeContext, afterContext } = this.config;
        let { changes, documentChanges } = edit2;
        if (!changes) {
          changes = {};
          for (let change of documentChanges || []) {
            if (import_vscode_languageserver_protocol83.TextDocumentEdit.is(change)) {
              let { textDocument, edits } = change;
              if (textDocument.uri.startsWith("file:")) {
                changes[textDocument.uri] = edits;
              }
            }
          }
        }
        for (let key of Object.keys(changes)) {
          let max = await this.getLineCount(key);
          let edits = changes[key];
          let ranges = [];
          let start = null;
          let end = null;
          let highlights = [];
          edits.sort((a, b) => a.range.start.line - b.range.start.line);
          for (let edit3 of edits) {
            let { line } = edit3.range.start;
            let s = Math.max(0, line - beforeContext);
            if (start != null && s < end) {
              end = Math.min(max, line + afterContext + 1);
              highlights.push(adjustRange2(edit3.range, start));
            } else {
              if (start != null)
                ranges.push({ start, end, highlights });
              start = s;
              end = Math.min(max, line + afterContext + 1);
              highlights = [adjustRange2(edit3.range, start)];
            }
          }
          if (start != null)
            ranges.push({ start, end, highlights });
          items.push({
            ranges,
            filepath: URI.parse(key).fsPath
          });
        }
        let buf = await this.createRefactorBuffer(filetype);
        await buf.addFileItems(items);
        return buf;
      }
      async save(bufnr) {
        let buf = this.buffers.get(bufnr);
        if (buf)
          return await buf.save();
      }
      async getLineCount(uri) {
        let doc = workspace_default.getDocument(uri);
        if (doc)
          return doc.lineCount;
        return await getFileLineCount(URI.parse(uri).fsPath);
      }
      reset() {
        if (this.timer) {
          clearTimeout(this.timer);
        }
        for (let buf of this.buffers.values()) {
          buf.dispose();
        }
        this.buffers.clear();
      }
      dispose() {
        if (this.timer) {
          clearTimeout(this.timer);
        }
        this._onCreate.dispose();
        for (let buf of this.buffers.values()) {
          buf.dispose();
        }
        this.buffers.clear();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/signature.ts
function isMarkdown2(content) {
  if (import_vscode_languageserver_protocol84.MarkupContent.is(content) && content.kind == import_vscode_languageserver_protocol84.MarkupKind.Markdown) {
    return true;
  }
  return false;
}
var import_vscode_languageserver_protocol84, logger91, Signature;
var init_signature = __esm({
  "src/handler/signature.ts"() {
    init_floatFactory();
    init_manager4();
    import_vscode_languageserver_protocol84 = __toModule(require_main2());
    init_workspace();
    init_events();
    init_string();
    init_languages();
    init_util();
    logger91 = require_logger2()("handler-signature");
    Signature = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        this.signatureFactory = new FloatFactory(nvim);
        this.loadConfiguration();
        this.disposables.push(this.signatureFactory);
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        events_default.on("CursorMovedI", async (bufnr, cursor) => {
          if (!this.signaturePosition)
            return;
          let doc = workspace_default.getDocument(bufnr);
          if (!doc)
            return;
          let { line, character } = this.signaturePosition;
          if (cursor[0] - 1 == line) {
            let currline = doc.getline(cursor[0] - 1);
            let col = byteLength(currline.slice(0, character)) + 1;
            if (cursor[1] >= col)
              return;
          }
          this.signatureFactory.close();
        }, null, this.disposables);
        events_default.on(["InsertLeave", "BufEnter"], () => {
          var _a2;
          (_a2 = this.tokenSource) == null ? void 0 : _a2.cancel();
          this.signatureFactory.close();
        }, null, this.disposables);
        events_default.on(["TextChangedI", "TextChangedP"], async () => {
          if (this.config.hideOnChange) {
            this.signatureFactory.close();
          }
        }, null, this.disposables);
        let lastInsert;
        events_default.on("InsertCharPre", async () => {
          lastInsert = Date.now();
        }, null, this.disposables);
        events_default.on("TextChangedI", async (bufnr, info) => {
          if (!this.config.trigger)
            return;
          if (!lastInsert || Date.now() - lastInsert > 300)
            return;
          lastInsert = null;
          let doc = workspace_default.getDocument(bufnr);
          if (!doc || doc.isCommandLine || !doc.attached)
            return;
          let pre = info.pre[info.pre.length - 1];
          if (!pre)
            return;
          if (languages_default.shouldTriggerSignatureHelp(doc.textDocument, pre)) {
            await this.triggerSignatureHelp(doc, { line: info.lnum - 1, character: info.pre.length }, false);
          }
        }, null, this.disposables);
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("signature")) {
          let config = workspace_default.getConfiguration("signature");
          let target = config.get("target", "float");
          if (target == "float" && !workspace_default.floatSupported) {
            target = "echo";
          }
          this.config = {
            target,
            trigger: config.get("enable", true),
            wait: Math.max(config.get("triggerSignatureWait", 500), 200),
            maxWindowHeight: config.get("maxWindowHeight", 80),
            maxWindowWidth: config.get("maxWindowWidth", 80),
            preferAbove: config.get("preferShownAbove", true),
            hideOnChange: config.get("hideOnTextChange", false)
          };
        }
      }
      async triggerSignatureHelp(doc, position, invoke = true) {
        var _a2;
        (_a2 = this.tokenSource) == null ? void 0 : _a2.cancel();
        let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol84.CancellationTokenSource();
        let token = tokenSource.token;
        token.onCancellationRequested(() => {
          tokenSource.dispose();
          this.tokenSource = void 0;
        });
        let { target } = this.config;
        let timer = this.timer = setTimeout(() => {
          tokenSource.cancel();
        }, this.config.wait);
        let { changedtick } = doc;
        await doc.patchChange();
        if (changedtick != doc.changedtick) {
          await wait(30);
        }
        if (token.isCancellationRequested) {
          return false;
        }
        let signatureHelp = await languages_default.getSignatureHelp(doc.textDocument, position, token, {
          isRetrigger: false,
          triggerKind: invoke ? import_vscode_languageserver_protocol84.SignatureHelpTriggerKind.Invoked : import_vscode_languageserver_protocol84.SignatureHelpTriggerKind.TriggerCharacter
        });
        clearTimeout(timer);
        if (token.isCancellationRequested)
          return false;
        if (!signatureHelp || signatureHelp.signatures.length == 0) {
          this.signatureFactory.close();
          return false;
        }
        let { activeSignature, signatures } = signatureHelp;
        if (activeSignature) {
          let [active] = signatures.splice(activeSignature, 1);
          if (active)
            signatures.unshift(active);
        }
        if (target == "echo") {
          this.echoSignature(signatureHelp);
        } else {
          await this.showSignatureHelp(doc, position, signatureHelp);
        }
      }
      async showSignatureHelp(doc, position, signatureHelp) {
        let { signatures, activeParameter } = signatureHelp;
        let offset = 0;
        let paramDoc = null;
        let docs = signatures.reduce((p, c, idx) => {
          var _a2;
          let activeIndexes = null;
          let nameIndex = c.label.indexOf("(");
          if (idx == 0 && activeParameter != null) {
            let active = (_a2 = c.parameters) == null ? void 0 : _a2[activeParameter];
            if (active) {
              let after = c.label.slice(nameIndex == -1 ? 0 : nameIndex);
              paramDoc = active.documentation;
              if (typeof active.label === "string") {
                let str = after.slice(0);
                let ms = str.match(new RegExp("\\b" + active.label.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b"));
                let index = ms ? ms.index : str.indexOf(active.label);
                if (index != -1) {
                  activeIndexes = [
                    index + nameIndex,
                    index + active.label.length + nameIndex
                  ];
                }
              } else {
                activeIndexes = active.label;
              }
            }
          }
          if (activeIndexes == null) {
            activeIndexes = [nameIndex + 1, nameIndex + 1];
          }
          if (offset == 0) {
            offset = activeIndexes[0] + 1;
          }
          p.push({
            content: c.label,
            filetype: doc.filetype,
            active: activeIndexes
          });
          if (paramDoc) {
            let content = typeof paramDoc === "string" ? paramDoc : paramDoc.value;
            if (content.trim().length) {
              p.push({
                content,
                filetype: isMarkdown2(c.documentation) ? "markdown" : "txt"
              });
            }
          }
          if (idx == 0 && c.documentation) {
            let { documentation } = c;
            let content = typeof documentation === "string" ? documentation : documentation.value;
            if (content.trim().length) {
              p.push({
                content,
                filetype: isMarkdown2(c.documentation) ? "markdown" : "txt"
              });
            }
          }
          return p;
        }, []);
        let session = manager_default2.getSession(doc.bufnr);
        if (session && session.isActive) {
          let { value } = session.placeholder;
          if (!value.includes("\n"))
            offset += value.length;
          this.signaturePosition = import_vscode_languageserver_protocol84.Position.create(position.line, position.character - value.length);
        } else {
          this.signaturePosition = position;
        }
        let { preferAbove, maxWindowHeight, maxWindowWidth } = this.config;
        const excludeImages = workspace_default.getConfiguration("coc.preferences").get("excludeImageLinksInMarkdownDocument");
        await this.signatureFactory.show(docs, {
          maxWidth: maxWindowWidth,
          maxHeight: maxWindowHeight,
          preferTop: preferAbove,
          autoHide: false,
          offsetX: offset,
          modes: ["i", "ic", "s"],
          excludeImages
        });
      }
      echoSignature(signatureHelp) {
        var _a2;
        let { signatures, activeParameter } = signatureHelp;
        let columns = workspace_default.env.columns;
        signatures = signatures.slice(0, workspace_default.env.cmdheight);
        let signatureList = [];
        for (let signature of signatures) {
          let parts = [];
          let { label } = signature;
          label = label.replace(/\n/g, " ");
          if (label.length >= columns - 16) {
            label = label.slice(0, columns - 16) + "...";
          }
          let nameIndex = label.indexOf("(");
          if (nameIndex == -1) {
            parts = [{ text: label, type: "Normal" }];
          } else {
            parts.push({
              text: label.slice(0, nameIndex),
              type: "Label"
            });
            let after = label.slice(nameIndex);
            if (signatureList.length == 0 && activeParameter != null) {
              let active = (_a2 = signature.parameters) == null ? void 0 : _a2[activeParameter];
              if (active) {
                let start;
                let end;
                if (typeof active.label === "string") {
                  let str = after.slice(0);
                  let ms = str.match(new RegExp("\\b" + active.label.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b"));
                  let idx = ms ? ms.index : str.indexOf(active.label);
                  if (idx == -1) {
                    parts.push({ text: after, type: "Normal" });
                  } else {
                    start = idx;
                    end = idx + active.label.length;
                  }
                } else {
                  [start, end] = active.label;
                  start = start - nameIndex;
                  end = end - nameIndex;
                }
                if (start != null && end != null) {
                  parts.push({ text: after.slice(0, start), type: "Normal" });
                  parts.push({ text: after.slice(start, end), type: "MoreMsg" });
                  parts.push({ text: after.slice(end), type: "Normal" });
                }
              }
            } else {
              parts.push({
                text: after,
                type: "Normal"
              });
            }
          }
          signatureList.push(parts);
        }
        this.nvim.callTimer("coc#util#echo_signatures", [signatureList], true);
      }
      dispose() {
        disposeAll(this.disposables);
        if (this.timer) {
          clearTimeout(this.timer);
        }
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource.dispose();
        }
      }
    };
  }
});

// src/handler/symbols.ts
var import_debounce12, import_vscode_languageserver_protocol85, Symbols2, SymbolsBuffer;
var init_symbols2 = __esm({
  "src/handler/symbols.ts"() {
    import_debounce12 = __toModule(require_debounce());
    import_vscode_languageserver_protocol85 = __toModule(require_main2());
    init_events();
    init_languages();
    init_convert();
    init_util();
    init_object();
    init_position();
    init_window();
    init_workspace();
    init_helper();
    Symbols2 = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        this.buffers = workspace_default.registerBufferSync((doc) => {
          if (doc.buftype != "")
            return void 0;
          let buf = new SymbolsBuffer(doc.bufnr);
          buf.onDidUpdate(async (symbols) => {
            await events_default.fire("SymbolsUpdate", [buf.bufnr, symbols]);
          });
          return buf;
        });
        events_default.on("CursorHold", async (bufnr) => {
          if (!this.functionUpdate || this.buffers.getItem(bufnr) == null)
            return;
          await this.getCurrentFunctionSymbol(bufnr);
        }, null, this.disposables);
        events_default.on("InsertEnter", (bufnr) => {
          let buf = this.buffers.getItem(bufnr);
          if (buf)
            buf.cancel();
        }, null, this.disposables);
      }
      get functionUpdate() {
        let config = workspace_default.getConfiguration("coc.preferences");
        return config.get("currentFunctionSymbolAutoUpdate", false);
      }
      get labels() {
        return workspace_default.getConfiguration("suggest").get("completionItemKindLabels", {});
      }
      async getDocumentSymbols(bufnr) {
        let buf = this.buffers.getItem(bufnr);
        return buf == null ? void 0 : buf.getSymbols();
      }
      async getCurrentFunctionSymbol(bufnr) {
        if (!bufnr)
          bufnr = await this.nvim.call("bufnr", ["%"]);
        let position = await window_default.getCursorPosition();
        let symbols = await this.getDocumentSymbols(bufnr);
        let buffer = this.nvim.createBuffer(bufnr);
        if (!symbols || symbols.length === 0) {
          buffer.setVar("coc_current_function", "", true);
          this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
          return "";
        }
        symbols = symbols.filter((s) => [
          "Class",
          "Method",
          "Function",
          "Struct"
        ].includes(s.kind));
        let functionName = "";
        for (let sym of symbols.reverse()) {
          if (sym.range && positionInRange(position, sym.range) == 0 && !sym.text.endsWith(") callback")) {
            functionName = sym.text;
            let label = this.labels[sym.kind.toLowerCase()];
            if (label)
              functionName = `${label} ${functionName}`;
            break;
          }
        }
        if (this.functionUpdate) {
          buffer.setVar("coc_current_function", functionName, true);
          this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
        }
        return functionName;
      }
      async selectSymbolRange(inner, visualmode, supportedSymbols) {
        let bufnr = await this.nvim.call("bufnr", ["%"]);
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached)
          return;
        let range;
        if (visualmode) {
          range = await workspace_default.getSelectedRange(visualmode, doc);
        } else {
          let pos = await window_default.getCursorPosition();
          range = import_vscode_languageserver_protocol85.Range.create(pos, pos);
        }
        let symbols = await this.getDocumentSymbols(bufnr);
        if (!symbols || symbols.length === 0) {
          window_default.showMessage("No symbols found", "warning");
          return;
        }
        let properties = symbols.filter((s) => s.kind == "Property");
        symbols = symbols.filter((s) => supportedSymbols.includes(s.kind));
        let selectRange;
        for (let sym of symbols.reverse()) {
          if (sym.range && !equals(sym.range, range) && rangeInRange(range, sym.range)) {
            selectRange = sym.range;
            break;
          }
        }
        if (!selectRange) {
          for (let sym of properties) {
            if (sym.range && !equals(sym.range, range) && rangeInRange(range, sym.range)) {
              selectRange = sym.range;
              break;
            }
          }
        }
        if (inner && selectRange) {
          let { start, end } = selectRange;
          let line = doc.getline(start.line + 1);
          let endLine = doc.getline(end.line - 1);
          selectRange = import_vscode_languageserver_protocol85.Range.create(start.line + 1, line.match(/^\s*/)[0].length, end.line - 1, endLine.length);
        }
        if (selectRange) {
          await workspace_default.selectRange(selectRange);
        } else if (["v", "V", ""].includes(visualmode)) {
          await this.nvim.command("normal! gv");
        }
      }
      dispose() {
        this.buffers.dispose();
        disposeAll(this.disposables);
      }
    };
    SymbolsBuffer = class {
      constructor(bufnr) {
        this.bufnr = bufnr;
        this.disposables = [];
        this.autoUpdate = false;
        this.symbols = [];
        this._onDidUpdate = new import_vscode_languageserver_protocol85.Emitter();
        this.onDidUpdate = this._onDidUpdate.event;
        this.fetchSymbols = (0, import_debounce12.default)(() => {
          this._fetchSymbols().logError();
        }, global.hasOwnProperty("__TEST__") ? 10 : 500);
      }
      async getSymbols() {
        let doc = workspace_default.getDocument(this.bufnr);
        if (!doc)
          return [];
        doc.forceSync();
        this.autoUpdate = true;
        if (doc.version == this.version)
          return this.symbols;
        this.cancel();
        await this._fetchSymbols();
        return this.symbols;
      }
      onChange() {
        this.cancel();
      }
      get textDocument() {
        var _a2;
        return (_a2 = workspace_default.getDocument(this.bufnr)) == null ? void 0 : _a2.textDocument;
      }
      async _fetchSymbols() {
        let { textDocument } = this;
        if (!textDocument || textDocument.version == this.version)
          return;
        let { version: version2 } = textDocument;
        let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol85.CancellationTokenSource();
        let { token } = tokenSource;
        let symbols = await languages_default.getDocumentSymbol(textDocument, token);
        this.tokenSource = void 0;
        if (symbols == null || token.isCancellationRequested)
          return;
        let level = 0;
        let res = [];
        let pre = null;
        if (isDocumentSymbols(symbols)) {
          symbols.sort(sortDocumentSymbols);
          symbols.forEach((s) => addDocumentSymbol(res, s, level));
        } else {
          symbols.sort(sortSymbolInformations);
          for (let sym of symbols) {
            let { name: name2, kind, location, containerName } = sym;
            if (!containerName || !pre) {
              level = 0;
            } else {
              if (pre.containerName == containerName) {
                level = pre.level || 0;
              } else {
                let container = getPreviousContainer(containerName, res);
                level = container ? container.level + 1 : 0;
              }
            }
            let { start } = location.range;
            let o = {
              col: start.character + 1,
              lnum: start.line + 1,
              text: name2,
              level,
              kind: getSymbolKind(kind),
              range: location.range,
              containerName
            };
            res.push(o);
            pre = o;
          }
        }
        this.version = version2;
        this.symbols = res;
        if (isDocumentSymbols(symbols)) {
          this._onDidUpdate.fire(symbols);
        } else {
          this._onDidUpdate.fire(symbols.map((o) => {
            return import_vscode_languageserver_protocol85.DocumentSymbol.create(o.name, "", o.kind, o.location.range, o.location.range);
          }));
        }
      }
      cancel() {
        this.fetchSymbols.clear();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      dispose() {
        this.cancel();
        this.symbols = void 0;
        this._onDidUpdate.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/index.ts
var import_vscode_languageserver_protocol86, logger92, Handler;
var init_handler = __esm({
  "src/handler/index.ts"() {
    import_vscode_languageserver_protocol86 = __toModule(require_main2());
    init_esm2();
    init_commands2();
    init_manager();
    init_events();
    init_languages();
    init_manager3();
    init_floatFactory();
    init_services();
    init_util();
    init_object();
    init_position();
    init_window();
    init_workspace();
    init_codelens();
    init_colors();
    init_format2();
    init_helper();
    init_highlights();
    init_refactor();
    init_signature();
    init_symbols2();
    logger92 = require_logger2()("Handler");
    Handler = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.documentLines = [];
        this.selectionRange = null;
        this.disposables = [];
        this.getPreferences();
        this.requestStatusItem = window_default.createStatusBarItem(0, { progress: true });
        workspace_default.onDidChangeConfiguration(() => {
          this.getPreferences();
        });
        this.refactor = new Refactor();
        this.hoverFactory = new FloatFactory(nvim);
        this.signature = new Signature(nvim);
        this.format = new FormatHandler(nvim);
        this.symbols = new Symbols2(nvim);
        this.codeLens = new CodeLensManager2(nvim);
        this.colors = new Colors(nvim);
        this.documentHighlighter = new Highlights(nvim);
        events_default.on(["CursorMoved", "CursorMovedI", "InsertEnter", "InsertSnippet", "InsertLeave"], () => {
          if (this.requestTokenSource) {
            this.requestTokenSource.cancel();
          }
        }, null, this.disposables);
        let provider = {
          onDidChange: null,
          provideTextDocumentContent: async () => {
            nvim.pauseNotification();
            nvim.command("setlocal conceallevel=2 nospell nofoldenable wrap", true);
            nvim.command("setlocal bufhidden=wipe nobuflisted", true);
            nvim.command("setfiletype markdown", true);
            nvim.command(`if winnr('j') != winnr('k') | exe "normal! z${Math.min(this.documentLines.length, this.preferences.previewMaxHeight)}\\<cr> | endif"`, true);
            await nvim.resumeNotification();
            return this.documentLines.join("\n");
          }
        };
        this.disposables.push(workspace_default.registerTextDocumentContentProvider("coc", provider));
        this.disposables.push(commands_default.registerCommand("editor.action.pickColor", () => {
          return this.pickColor();
        }));
        commands_default.titles.set("editor.action.pickColor", "pick color from system color picker when possible.");
        this.disposables.push(commands_default.registerCommand("editor.action.colorPresentation", () => {
          return this.pickPresentation();
        }));
        commands_default.titles.set("editor.action.colorPresentation", "change color presentation.");
        this.disposables.push(commands_default.registerCommand("editor.action.organizeImport", async (bufnr) => {
          await this.organizeImport(bufnr);
        }));
        commands_default.titles.set("editor.action.organizeImport", "run organize import code action.");
      }
      async organizeImport(bufnr) {
        if (!bufnr)
          bufnr = await this.nvim.call("bufnr", ["%"]);
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached)
          throw new Error(`buffer ${bufnr} not attached`);
        await synchronizeDocument(doc);
        let actions = await this.getCodeActions(doc, void 0, [import_vscode_languageserver_protocol86.CodeActionKind.SourceOrganizeImports]);
        if (actions && actions.length) {
          await this.applyCodeAction(actions[0]);
          return;
        }
        throw new Error("Organize import action not found.");
      }
      checkProvier(id, document2) {
        if (languages_default.hasProvider(id, document2))
          return;
        throw new Error(`${id} provider not found for current buffer, your language server doesn't support it.`);
      }
      async withRequestToken(name2, fn, checkEmpty) {
        if (this.requestTokenSource) {
          this.requestTokenSource.cancel();
          this.requestTokenSource.dispose();
        }
        if (this.requestTimer) {
          clearTimeout(this.requestTimer);
        }
        let statusItem = this.requestStatusItem;
        this.requestTokenSource = new import_vscode_languageserver_protocol86.CancellationTokenSource();
        let { token } = this.requestTokenSource;
        token.onCancellationRequested(() => {
          statusItem.text = `${name2} request canceled`;
          statusItem.isProgress = false;
          this.requestTimer = setTimeout(() => {
            statusItem.hide();
          }, 500);
        });
        statusItem.isProgress = true;
        statusItem.text = `requesting ${name2}`;
        statusItem.show();
        let res;
        try {
          res = await Promise.resolve(fn(token));
        } catch (e) {
          window_default.showMessage(e.message, "error");
          logger92.error(`Error on ${name2}`, e);
        }
        if (this.requestTokenSource) {
          this.requestTokenSource.dispose();
          this.requestTokenSource = void 0;
        }
        if (token.isCancellationRequested)
          return null;
        statusItem.hide();
        if (checkEmpty && (!res || Array.isArray(res) && res.length == 0)) {
          window_default.showMessage(`${name2} not found`, "warning");
          return null;
        }
        return res;
      }
      async getCurrentFunctionSymbol() {
        let { doc } = await this.getCurrentState();
        this.checkProvier("documentSymbol", doc.textDocument);
        return await this.symbols.getCurrentFunctionSymbol();
      }
      async selectSymbolRange(inner, visualmode, supportedSymbols) {
        let { doc } = await this.getCurrentState();
        this.checkProvier("documentSymbol", doc.textDocument);
        return await this.symbols.selectSymbolRange(inner, visualmode, supportedSymbols);
      }
      async getDocumentSymbols(bufnr) {
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached)
          throw new Error(`buffer ${bufnr} not attached`);
        this.checkProvier("documentSymbol", doc.textDocument);
        return await this.symbols.getDocumentSymbols(bufnr);
      }
      async hasProvider(id) {
        let bufnr = await this.nvim.call("bufnr", "%");
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return false;
        return languages_default.hasProvider(id, doc.textDocument);
      }
      async onHover(hoverTarget) {
        let { doc, position, winid } = await this.getCurrentState();
        this.checkProvier("hover", doc.textDocument);
        this.hoverFactory.close();
        await synchronizeDocument(doc);
        let hovers = await this.withRequestToken("hover", (token) => {
          return languages_default.getHover(doc.textDocument, position, token);
        }, true);
        if (hovers == null)
          return false;
        let hover = hovers.find((o) => import_vscode_languageserver_protocol86.Range.is(o.range));
        if (hover == null ? void 0 : hover.range) {
          let win = this.nvim.createWindow(winid);
          let ids = await win.highlightRanges("CocHoverRange", [hover.range], 99);
          setTimeout(() => {
            if (ids.length)
              win.clearMatches(ids);
            if (workspace_default.isVim)
              this.nvim.command("redraw", true);
          }, 500);
        }
        await this.previewHover(hovers, hoverTarget);
        return true;
      }
      async getHover() {
        let result = [];
        let { doc, position } = await this.getCurrentState();
        this.checkProvier("hover", doc.textDocument);
        await synchronizeDocument(doc);
        let tokenSource = new import_vscode_languageserver_protocol86.CancellationTokenSource();
        let hovers = await languages_default.getHover(doc.textDocument, position, tokenSource.token);
        if (Array.isArray(hovers)) {
          for (let h of hovers) {
            let { contents } = h;
            if (Array.isArray(contents)) {
              contents.forEach((c) => {
                result.push(typeof c === "string" ? c : c.value);
              });
            } else if (import_vscode_languageserver_protocol86.MarkupContent.is(contents)) {
              result.push(contents.value);
            } else {
              result.push(typeof contents === "string" ? contents : contents.value);
            }
          }
        }
        result = result.filter((s) => s != null && s.length > 0);
        return result;
      }
      async gotoDefinition(openCommand) {
        let { doc, position } = await this.getCurrentState();
        this.checkProvier("definition", doc.textDocument);
        await synchronizeDocument(doc);
        let definition = await this.withRequestToken("definition", (token) => {
          return languages_default.getDefinition(doc.textDocument, position, token);
        }, true);
        if (definition == null)
          return false;
        await this.handleLocations(definition, openCommand);
        return true;
      }
      async definitions() {
        const { doc, position } = await this.getCurrentState();
        if (!languages_default.hasProvider("reference", doc.textDocument))
          return [];
        await synchronizeDocument(doc);
        const tokenSource = new import_vscode_languageserver_protocol86.CancellationTokenSource();
        return languages_default.getDefinition(doc.textDocument, position, tokenSource.token);
      }
      async gotoDeclaration(openCommand) {
        let { doc, position } = await this.getCurrentState();
        this.checkProvier("declaration", doc.textDocument);
        await synchronizeDocument(doc);
        let definition = await this.withRequestToken("declaration", (token) => {
          return languages_default.getDeclaration(doc.textDocument, position, token);
        }, true);
        if (definition == null)
          return false;
        await this.handleLocations(definition, openCommand);
        return true;
      }
      async declarations() {
        const { doc, position } = await this.getCurrentState();
        if (!languages_default.hasProvider("declaration", doc.textDocument))
          return [];
        await synchronizeDocument(doc);
        const tokenSource = new import_vscode_languageserver_protocol86.CancellationTokenSource();
        return languages_default.getDeclaration(doc.textDocument, position, tokenSource.token);
      }
      async gotoTypeDefinition(openCommand) {
        let { doc, position } = await this.getCurrentState();
        this.checkProvier("typeDefinition", doc.textDocument);
        await synchronizeDocument(doc);
        let definition = await this.withRequestToken("type definition", (token) => {
          return languages_default.getTypeDefinition(doc.textDocument, position, token);
        }, true);
        if (definition == null)
          return false;
        await this.handleLocations(definition, openCommand);
        return true;
      }
      async typeDefinitions() {
        const { doc, position } = await this.getCurrentState();
        if (!languages_default.hasProvider("typeDefinition", doc.textDocument))
          return [];
        await synchronizeDocument(doc);
        const tokenSource = new import_vscode_languageserver_protocol86.CancellationTokenSource();
        return languages_default.getTypeDefinition(doc.textDocument, position, tokenSource.token);
      }
      async gotoImplementation(openCommand) {
        let { doc, position } = await this.getCurrentState();
        this.checkProvier("implementation", doc.textDocument);
        await synchronizeDocument(doc);
        let definition = await this.withRequestToken("implementation", (token) => {
          return languages_default.getImplementation(doc.textDocument, position, token);
        }, true);
        if (definition == null)
          return false;
        await this.handleLocations(definition, openCommand);
        return true;
      }
      async implementations() {
        const { doc, position } = await this.getCurrentState();
        if (!languages_default.hasProvider("implementation", doc.textDocument))
          return [];
        await synchronizeDocument(doc);
        const tokenSource = new import_vscode_languageserver_protocol86.CancellationTokenSource();
        return languages_default.getImplementation(doc.textDocument, position, tokenSource.token);
      }
      async gotoReferences(openCommand, includeDeclaration = true) {
        let { doc, position } = await this.getCurrentState();
        this.checkProvier("reference", doc.textDocument);
        await synchronizeDocument(doc);
        let definition = await this.withRequestToken("references", (token) => {
          return languages_default.getReferences(doc.textDocument, { includeDeclaration }, position, token);
        }, true);
        if (definition == null)
          return false;
        await this.handleLocations(definition, openCommand);
        return true;
      }
      async references() {
        const { doc, position } = await this.getCurrentState();
        if (!languages_default.hasProvider("reference", doc.textDocument))
          return [];
        await synchronizeDocument(doc);
        const tokenSource = new import_vscode_languageserver_protocol86.CancellationTokenSource();
        return languages_default.getReferences(doc.textDocument, { includeDeclaration: true }, position, tokenSource.token);
      }
      async getWordEdit() {
        let { doc, position } = await this.getCurrentState();
        let range = doc.getWordRangeAtPosition(position);
        if (!range || emptyRange(range))
          return null;
        let curname = doc.textDocument.getText(range);
        if (languages_default.hasProvider("rename", doc.textDocument)) {
          await synchronizeDocument(doc);
          let requestTokenSource = new import_vscode_languageserver_protocol86.CancellationTokenSource();
          let res = await languages_default.prepareRename(doc.textDocument, position, requestTokenSource.token);
          if (res === false)
            return null;
          let edit2 = await languages_default.provideRenameEdits(doc.textDocument, position, curname, requestTokenSource.token);
          if (edit2)
            return edit2;
        }
        window_default.showMessage("Rename provider not found, extract word ranges from current buffer", "more");
        let ranges = doc.getSymbolRanges(curname);
        return {
          changes: {
            [doc.uri]: ranges.map((r) => ({ range: r, newText: curname }))
          }
        };
      }
      async rename(newName) {
        let { doc, position } = await this.getCurrentState();
        this.checkProvier("rename", doc.textDocument);
        await synchronizeDocument(doc);
        let statusItem = this.requestStatusItem;
        try {
          let token = new import_vscode_languageserver_protocol86.CancellationTokenSource().token;
          let res = await languages_default.prepareRename(doc.textDocument, position, token);
          if (res === false) {
            statusItem.hide();
            window_default.showMessage("Invalid position for rename", "warning");
            return false;
          }
          if (token.isCancellationRequested)
            return false;
          let curname;
          if (!newName) {
            if (import_vscode_languageserver_protocol86.Range.is(res)) {
              curname = doc.textDocument.getText(res);
              await window_default.moveTo(res.start);
            } else if (res && typeof res.placeholder === "string") {
              curname = res.placeholder;
            } else {
              curname = await this.nvim.eval('expand("<cword>")');
            }
            newName = await window_default.requestInput("New name", curname);
          }
          if (!newName) {
            statusItem.hide();
            return false;
          }
          let edit2 = await languages_default.provideRenameEdits(doc.textDocument, position, newName, token);
          if (token.isCancellationRequested)
            return false;
          statusItem.hide();
          if (!edit2) {
            window_default.showMessage("Invalid position for rename", "warning");
            return false;
          }
          await workspace_default.applyEdit(edit2);
          if (workspace_default.isVim)
            this.nvim.command("redraw", true);
          return true;
        } catch (e) {
          statusItem.hide();
          window_default.showMessage(`Error on rename: ${e.message}`, "error");
          logger92.error(e);
          return false;
        }
      }
      async documentFormatting() {
        let { doc } = await this.getCurrentState();
        this.checkProvier("format", doc.textDocument);
        return await this.format.documentFormat(doc);
      }
      async documentRangeFormatting(mode) {
        let { doc } = await this.getCurrentState();
        this.checkProvier("formatRange", doc.textDocument);
        return await this.format.documentRangeFormat(doc, mode);
      }
      async getTagList() {
        let { doc, position } = await this.getCurrentState();
        let word = await this.nvim.call("expand", "<cword>");
        if (!word)
          return null;
        if (!languages_default.hasProvider("definition", doc.textDocument))
          return null;
        let tokenSource = new import_vscode_languageserver_protocol86.CancellationTokenSource();
        let definitions = await languages_default.getDefinition(doc.textDocument, position, tokenSource.token);
        if (!definitions || !definitions.length)
          return null;
        return definitions.map((location) => {
          let parsedURI = URI.parse(location.uri);
          const filename = parsedURI.scheme == "file" ? parsedURI.fsPath : parsedURI.toString();
          return {
            name: word,
            cmd: `keepjumps ${location.range.start.line + 1} | normal ${location.range.start.character + 1}|`,
            filename
          };
        });
      }
      async runCommand(id, ...args) {
        if (id) {
          await events_default.fire("Command", [id]);
          let res = await commands_default.executeCommand(id, ...args);
          if (args.length == 0) {
            await commands_default.addRecent(id);
          }
          return res;
        } else {
          await manager_default3.start(["commands"]);
        }
      }
      async getCodeActions(doc, range, only) {
        range = range || import_vscode_languageserver_protocol86.Range.create(0, 0, doc.lineCount, 0);
        let diagnostics = manager_default.getDiagnosticsInRange(doc.textDocument, range);
        let context = { diagnostics };
        if (only && Array.isArray(only))
          context.only = only;
        let codeActions = await this.withRequestToken("code action", (token) => {
          return languages_default.getCodeActions(doc.textDocument, range, context, token);
        });
        if (!codeActions || codeActions.length == 0)
          return [];
        codeActions.sort((a, b) => {
          if (a.isPreferred && !b.isPreferred) {
            return -1;
          }
          if (b.isPreferred && !a.isPreferred) {
            return 1;
          }
          return 0;
        });
        return codeActions;
      }
      async doCodeAction(mode, only) {
        let { doc } = await this.getCurrentState();
        let range;
        if (mode)
          range = await workspace_default.getSelectedRange(mode, doc);
        await synchronizeDocument(doc);
        let codeActions = await this.getCodeActions(doc, range, Array.isArray(only) ? only : null);
        if (only && typeof only == "string") {
          codeActions = codeActions.filter((o) => o.title == only || o.command && o.command.title == only);
          if (codeActions.length == 1) {
            await this.applyCodeAction(codeActions[0]);
            return;
          }
        }
        if (!codeActions || codeActions.length == 0) {
          window_default.showMessage(`No${only ? " " + only : ""} code action available`, "warning");
          return;
        }
        let idx = this.preferences.floatActions ? await window_default.showMenuPicker(codeActions.map((o) => o.title), "Choose action") : await window_default.showQuickpick(codeActions.map((o) => o.title));
        let action = codeActions[idx];
        if (action)
          await this.applyCodeAction(action);
      }
      async getCurrentCodeActions(mode, only) {
        let { doc } = await this.getCurrentState();
        let range;
        if (mode)
          range = await workspace_default.getSelectedRange(mode, doc);
        return await this.getCodeActions(doc, range, only);
      }
      async doQuickfix() {
        let actions = await this.getCurrentCodeActions("line", [import_vscode_languageserver_protocol86.CodeActionKind.QuickFix]);
        if (!actions || actions.length == 0) {
          window_default.showMessage("No quickfix action available", "warning");
          return false;
        }
        await this.applyCodeAction(actions[0]);
        await this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-fix-current)", -1)`);
        return true;
      }
      async applyCodeAction(action) {
        let { command, edit: edit2 } = action;
        if (edit2)
          await workspace_default.applyEdit(edit2);
        if (command) {
          if (commands_default.has(command.command)) {
            commands_default.execute(command);
          } else {
            let clientId = action.clientId;
            let service = services_default.getService(clientId);
            let params = {
              command: command.command,
              arguments: command.arguments
            };
            if (service.client) {
              let { client } = service;
              client.sendRequest(import_vscode_languageserver_protocol86.ExecuteCommandRequest.type, params).then(void 0, (error) => {
                window_default.showMessage(`Execute '${command.command} error: ${error}'`, "error");
              });
            }
          }
        }
      }
      async doCodeLensAction() {
        await this.codeLens.doAction();
      }
      async fold(kind) {
        let { doc, winid } = await this.getCurrentState();
        this.checkProvier("foldingRange", doc.textDocument);
        await synchronizeDocument(doc);
        let win = this.nvim.createWindow(winid);
        let [foldmethod, foldlevel] = await this.nvim.eval("[&foldmethod,&foldlevel]");
        if (foldmethod != "manual") {
          window_default.showMessage("foldmethod option should be manual!", "warning");
          return false;
        }
        let ranges = await this.withRequestToken("folding range", (token) => {
          return languages_default.provideFoldingRanges(doc.textDocument, {}, token);
        }, true);
        if (!ranges)
          return false;
        if (kind)
          ranges = ranges.filter((o) => o.kind == kind);
        if (ranges.length) {
          ranges.sort((a, b) => b.startLine - a.startLine);
          this.nvim.pauseNotification();
          this.nvim.command("normal! zE", true);
          for (let range of ranges) {
            let { startLine, endLine } = range;
            let cmd = `${startLine + 1}, ${endLine + 1}fold`;
            this.nvim.command(cmd, true);
          }
          win.setOption("foldenable", true, true);
          win.setOption("foldlevel", foldlevel, true);
          if (workspace_default.isVim)
            this.nvim.command("redraw", true);
          await this.nvim.resumeNotification();
          return true;
        }
        return false;
      }
      async pickColor() {
        let { doc } = await this.getCurrentState();
        this.checkProvier("documentColor", doc.textDocument);
        await this.colors.pickColor();
      }
      async pickPresentation() {
        let { doc } = await this.getCurrentState();
        this.checkProvier("documentColor", doc.textDocument);
        await this.colors.pickPresentation();
      }
      async highlight() {
        await this.documentHighlighter.highlight();
      }
      async getSymbolsRanges() {
        let { doc, position } = await this.getCurrentState();
        this.checkProvier("documentHighlight", doc.textDocument);
        let highlights = await this.documentHighlighter.getHighlights(doc, position);
        if (!highlights)
          return null;
        return highlights.map((o) => o.range);
      }
      async links() {
        let { doc } = await this.getCurrentState();
        this.checkProvier("documentLink", doc.textDocument);
        let links2 = await this.withRequestToken("links", (token) => {
          return languages_default.getDocumentLinks(doc.textDocument, token);
        });
        links2 = links2 || [];
        let res = [];
        for (let link of links2) {
          if (link.target) {
            res.push(link);
          } else {
            link = await languages_default.resolveDocumentLink(link);
            res.push(link);
          }
        }
        return links2;
      }
      async openLink() {
        let { doc, position } = await this.getCurrentState();
        this.checkProvier("documentLink", doc.textDocument);
        let links2 = await this.withRequestToken("links", (token) => {
          return languages_default.getDocumentLinks(doc.textDocument, token);
        });
        if (!links2 || links2.length == 0)
          return false;
        for (let link of links2) {
          if (positionInRange(position, link.range) == 0) {
            let { target } = link;
            if (!target) {
              link = await languages_default.resolveDocumentLink(link);
              target = link.target;
            }
            if (target) {
              await workspace_default.openResource(target);
              return true;
            }
            return false;
          }
        }
        return false;
      }
      async getCommands() {
        let list2 = commands_default.commandList;
        let res = [];
        let { titles } = commands_default;
        for (let item of list2) {
          res.push({
            id: item.id,
            title: titles.get(item.id) || ""
          });
        }
        return res;
      }
      async showSignatureHelp() {
        let { doc, position } = await this.getCurrentState();
        if (!languages_default.hasProvider("signature", doc.textDocument))
          return false;
        return await this.signature.triggerSignatureHelp(doc, position);
      }
      async findLocations(id, method, params, openCommand) {
        let { doc, position } = await this.getCurrentState();
        params = params || {};
        Object.assign(params, {
          textDocument: { uri: doc.uri },
          position
        });
        let res = await services_default.sendRequest(id, method, params);
        res = res || [];
        let locations = [];
        if (Array.isArray(res)) {
          locations = res;
        } else if (res.hasOwnProperty("location") && res.hasOwnProperty("children")) {
          let getLocation2 = (item) => {
            locations.push(item.location);
            if (item.children && item.children.length) {
              for (let loc of item.children) {
                getLocation2(loc);
              }
            }
          };
          getLocation2(res);
        }
        await this.handleLocations(locations, openCommand);
      }
      async handleLocations(definition, openCommand) {
        if (!definition)
          return;
        let locations = Array.isArray(definition) ? definition : [definition];
        let len = locations.length;
        if (len == 0)
          return;
        if (len == 1 && openCommand !== false) {
          let location = definition[0];
          if (import_vscode_languageserver_protocol86.LocationLink.is(definition[0])) {
            let link = definition[0];
            location = import_vscode_languageserver_protocol86.Location.create(link.targetUri, link.targetRange);
          }
          let { uri, range } = location;
          await workspace_default.jumpTo(uri, range.start, openCommand);
        } else {
          await workspace_default.showLocations(definition);
        }
      }
      async getSelectionRanges() {
        let { doc, position } = await this.getCurrentState();
        this.checkProvier("selectionRange", doc.textDocument);
        await synchronizeDocument(doc);
        let selectionRanges = await this.withRequestToken("selection ranges", (token) => {
          return languages_default.getSelectionRanges(doc.textDocument, [position], token);
        });
        if (selectionRanges && selectionRanges.length)
          return selectionRanges;
        return null;
      }
      async selectRange(visualmode, forward) {
        let { nvim } = this;
        let { doc } = await this.getCurrentState();
        this.checkProvier("selectionRange", doc.textDocument);
        let positions2 = [];
        if (!forward && (!this.selectionRange || !visualmode))
          return;
        if (visualmode) {
          let range = await workspace_default.getSelectedRange(visualmode, doc);
          positions2.push(range.start, range.end);
        } else {
          let position = await window_default.getCursorPosition();
          positions2.push(position);
        }
        if (!forward) {
          let curr = import_vscode_languageserver_protocol86.Range.create(positions2[0], positions2[1]);
          let { selectionRange: selectionRange2 } = this;
          while (selectionRange2 && selectionRange2.parent) {
            if (equals(selectionRange2.parent.range, curr)) {
              break;
            }
            selectionRange2 = selectionRange2.parent;
          }
          if (selectionRange2 && selectionRange2.parent) {
            await workspace_default.selectRange(selectionRange2.range);
          }
          return;
        }
        await synchronizeDocument(doc);
        let selectionRanges = await this.withRequestToken("selection ranges", (token) => {
          return languages_default.getSelectionRanges(doc.textDocument, positions2, token);
        });
        if (!selectionRanges || selectionRanges.length == 0)
          return;
        let mode = await nvim.eval("mode()");
        if (mode != "n")
          await nvim.eval(`feedkeys("\\<Esc>", 'in')`);
        let selectionRange;
        if (selectionRanges.length == 1) {
          selectionRange = selectionRanges[0];
        } else if (positions2.length > 1) {
          let r = import_vscode_languageserver_protocol86.Range.create(positions2[0], positions2[1]);
          selectionRange = selectionRanges[0];
          while (selectionRange) {
            if (equals(r, selectionRange.range)) {
              selectionRange = selectionRange.parent;
              continue;
            }
            if (positionInRange(positions2[1], selectionRange.range) == 0) {
              break;
            }
            selectionRange = selectionRange.parent;
          }
        }
        if (!selectionRange)
          return;
        this.selectionRange = selectionRanges[0];
        await workspace_default.selectRange(selectionRange.range);
      }
      async codeActionRange(start, end, only) {
        let { doc } = await this.getCurrentState();
        await synchronizeDocument(doc);
        let line = doc.getline(end - 1);
        let range = import_vscode_languageserver_protocol86.Range.create(start - 1, 0, end - 1, line.length);
        let codeActions = await this.getCodeActions(doc, range, only ? [only] : null);
        if (!codeActions || codeActions.length == 0) {
          window_default.showMessage(`No${only ? " " + only : ""} code action available`, "warning");
          return;
        }
        let idx = await window_default.showMenuPicker(codeActions.map((o) => o.title), "Choose action");
        let action = codeActions[idx];
        if (action)
          await this.applyCodeAction(action);
      }
      async doRefactor() {
        let { doc, position } = await this.getCurrentState();
        await synchronizeDocument(doc);
        let edit2 = await this.withRequestToken("refactor", async (token) => {
          let res = await languages_default.prepareRename(doc.textDocument, position, token);
          if (token.isCancellationRequested)
            return null;
          if (res === false) {
            window_default.showMessage("Invalid position", "warning");
            return null;
          }
          let edit3 = await languages_default.provideRenameEdits(doc.textDocument, position, "NewName", token);
          if (token.isCancellationRequested)
            return null;
          if (!edit3) {
            window_default.showMessage("Empty workspaceEdit from language server", "warning");
            return null;
          }
          return edit3;
        });
        if (edit2) {
          await this.refactor.fromWorkspaceEdit(edit2, doc.filetype);
        }
      }
      async saveRefactor(bufnr) {
        await this.refactor.save(bufnr);
      }
      async search(args) {
        await this.refactor.search(args);
      }
      async previewHover(hovers, target) {
        let docs = [];
        let hoverPreference = workspace_default.getConfiguration("hover");
        if (!target) {
          target = this.preferences.hoverTarget || hoverPreference.get("target", "float");
          if (target == "float" && !workspace_default.floatSupported)
            target = "preview";
        }
        let isPreview = target === "preview";
        for (let hover of hovers) {
          let { contents } = hover;
          if (Array.isArray(contents)) {
            for (let item of contents) {
              if (typeof item === "string") {
                addDocument(docs, item, "markdown", isPreview);
              } else {
                addDocument(docs, item.value, item.language, isPreview);
              }
            }
          } else if (import_vscode_languageserver_protocol86.MarkedString.is(contents)) {
            if (typeof contents == "string") {
              addDocument(docs, contents, "markdown", isPreview);
            } else {
              addDocument(docs, contents.value, contents.language, isPreview);
            }
          } else if (import_vscode_languageserver_protocol86.MarkupContent.is(contents)) {
            addDocument(docs, contents.value, isMarkdown(contents) ? "markdown" : "txt", isPreview);
          }
        }
        if (target == "float") {
          let opts = { modes: ["n"] };
          opts.maxWidth = hoverPreference.get("floatMaxWidth", 80);
          opts.maxHeight = hoverPreference.get("floatMaxHeight", void 0);
          opts.autoHide = hoverPreference.get("autoHide", true);
          opts.excludeImages = workspace_default.getConfiguration("coc.preferences").get("excludeImageLinksInMarkdownDocument", true);
          await this.hoverFactory.show(docs, opts);
          return;
        }
        let lines = docs.reduce((p, c) => {
          let arr = c.content.split(/\r?\n/);
          if (p.length > 0)
            p.push("");
          p.push(...arr);
          return p;
        }, []);
        if (target == "echo") {
          const msg = lines.join("\n").trim();
          if (msg.length) {
            await this.nvim.call("coc#util#echo_hover", msg);
          }
        } else {
          this.documentLines = lines;
          await this.nvim.command(`noswapfile pedit coc://document`);
        }
      }
      getPreferences() {
        let config = workspace_default.getConfiguration("coc.preferences");
        let hoverTarget = config.get("hoverTarget", void 0);
        this.preferences = {
          hoverTarget,
          previewMaxHeight: config.get("previewMaxHeight", 12),
          previewAutoClose: config.get("previewAutoClose", false),
          floatActions: config.get("floatActions", true)
        };
      }
      async getCurrentState() {
        let { nvim } = this;
        let [bufnr, [line, character], winid] = await nvim.eval("[bufnr('%'),coc#util#cursor(),win_getid()]");
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached)
          throw new Error(`current buffer ${bufnr} not attached`);
        return {
          doc,
          position: import_vscode_languageserver_protocol86.Position.create(line, character),
          winid
        };
      }
      dispose() {
        if (this.requestTimer) {
          clearTimeout(this.requestTimer);
          this.requestTimer = void 0;
        }
        this.refactor.dispose();
        this.signature.dispose();
        this.symbols.dispose();
        this.hoverFactory.dispose();
        this.colors.dispose();
        this.format.dispose();
        this.documentHighlighter.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/plugin.ts
var import_events35, import_path34, import_fs34, import_vscode_languageserver_protocol87, logger93, Plugin;
var init_plugin = __esm({
  "src/plugin.ts"() {
    import_events35 = __toModule(require("events"));
    import_path34 = __toModule(require("path"));
    import_fs34 = __toModule(require("fs"));
    import_vscode_languageserver_protocol87 = __toModule(require_main2());
    init_esm2();
    init_commands2();
    init_completion();
    init_cursors();
    init_manager();
    init_extensions2();
    init_handler();
    init_languages();
    init_manager3();
    init_services();
    init_manager4();
    init_sources2();
    init_types();
    init_util();
    init_workspace();
    init_window();
    init_events();
    logger93 = require_logger2()("plugin");
    Plugin = class extends import_events35.EventEmitter {
      constructor(nvim) {
        super();
        this.nvim = nvim;
        this._ready = false;
        this.actions = new Map();
        Object.defineProperty(workspace_default, "nvim", {
          get: () => this.nvim
        });
        this.cursors = new Cursors(nvim);
        this.addAction("hasProvider", (id) => this.handler.hasProvider(id));
        this.addAction("getTagList", async () => await this.handler.getTagList());
        this.addAction("hasSelected", () => completion_default.hasSelected());
        this.addAction("listNames", () => manager_default3.names);
        this.addAction("listDescriptions", () => manager_default3.descriptions);
        this.addAction("listLoadItems", async (name2) => await manager_default3.loadItems(name2));
        this.addAction("search", (...args) => this.handler.search(args));
        this.addAction("cursorsSelect", (bufnr, kind, mode) => this.cursors.select(bufnr, kind, mode));
        this.addAction("fillDiagnostics", (bufnr) => manager_default.setLocationlist(bufnr));
        this.addAction("getConfig", async (key) => {
          let document2 = await workspace_default.document;
          return workspace_default.getConfiguration(key, document2 ? document2.uri : void 0);
        });
        this.addAction("rootPatterns", (bufnr) => {
          let doc = workspace_default.getDocument(bufnr);
          if (!doc)
            return null;
          return {
            buffer: workspace_default.getRootPatterns(doc, PatternType.Buffer),
            server: workspace_default.getRootPatterns(doc, PatternType.LanguageServer),
            global: workspace_default.getRootPatterns(doc, PatternType.Global)
          };
        });
        this.addAction("installExtensions", async (...list2) => {
          await extensions_default.installExtensions(list2);
        });
        this.addAction("saveRefactor", async (bufnr) => {
          await this.handler.saveRefactor(bufnr);
        });
        this.addAction("updateExtensions", async (sync) => {
          await extensions_default.updateExtensions(sync);
        });
        this.addAction("commandList", () => commands_default.commandList.map((o) => o.id));
        this.addAction("openList", async (...args) => {
          await this.ready;
          await manager_default3.start(args);
        });
        this.addAction("selectSymbolRange", (inner, visualmode, supportedSymbols) => this.handler.selectSymbolRange(inner, visualmode, supportedSymbols));
        this.addAction("listResume", (name2) => manager_default3.resume(name2));
        this.addAction("listCancel", () => manager_default3.cancel(true));
        this.addAction("listPrev", (name2) => manager_default3.previous(name2));
        this.addAction("listNext", (name2) => manager_default3.next(name2));
        this.addAction("listFirst", (name2) => manager_default3.first(name2));
        this.addAction("listLast", (name2) => manager_default3.last(name2));
        this.addAction("sendRequest", (id, method, params) => services_default.sendRequest(id, method, params));
        this.addAction("sendNotification", (id, method, params) => {
          return services_default.sendNotification(id, method, params);
        });
        this.addAction("registNotification", (id, method) => {
          return services_default.registNotification(id, method);
        });
        this.addAction("doAutocmd", async (id, ...args) => {
          let autocmd = workspace_default.autocmds.get(id);
          if (autocmd) {
            try {
              await Promise.resolve(autocmd.callback.apply(autocmd.thisArg, args));
            } catch (e) {
              logger93.error(`Error on autocmd ${autocmd.event}`, e);
              window_default.showMessage(`Error on autocmd ${autocmd.event}: ${e.message}`);
            }
          }
        });
        this.addAction("updateConfig", (section2, val) => {
          workspace_default.configurations.updateUserConfig({ [section2]: val });
        });
        this.addAction("snippetNext", async () => {
          await manager_default2.nextPlaceholder();
          return "";
        });
        this.addAction("snippetPrev", async () => {
          await manager_default2.previousPlaceholder();
          return "";
        });
        this.addAction("snippetCancel", () => {
          manager_default2.cancel();
        });
        this.addAction("openLocalConfig", async () => {
          await window_default.openLocalConfig();
        });
        this.addAction("openLog", async () => {
          let file = logger93.getLogFile();
          await workspace_default.jumpTo(URI.file(file).toString());
        });
        this.addAction("attach", () => {
          return workspace_default.attach();
        });
        this.addAction("detach", () => {
          return workspace_default.detach();
        });
        this.addAction("doKeymap", async (key, defaultReturn = "", pressed) => {
          let keymap = workspace_default.keymaps.get(key);
          if (!keymap) {
            logger93.error(`keymap for ${key} not found`);
            this.nvim.command(`silent! unmap <buffer> ${pressed.startsWith("{") && pressed.endsWith("}") ? `<${pressed.slice(1, -1)}>` : pressed}`, true);
            return defaultReturn;
          }
          let [fn, repeat2] = keymap;
          let res = await Promise.resolve(fn());
          if (repeat2)
            await nvim.command(`silent! call repeat#set("\\<Plug>(coc-${key})", -1)`);
          return res != null ? res : defaultReturn;
        });
        this.addAction("registExtensions", async (...folders) => {
          for (let folder of folders) {
            await extensions_default.loadExtension(folder);
          }
        });
        this.addAction("snippetCheck", async (checkExpand, checkJump) => {
          if (checkExpand && !extensions_default.has("coc-snippets")) {
            console.error("coc-snippets required for check expand status!");
            return false;
          }
          if (checkJump) {
            let jumpable = manager_default2.jumpable();
            if (jumpable)
              return true;
          }
          if (checkExpand) {
            let api = extensions_default.getExtensionApi("coc-snippets");
            if (api && api.hasOwnProperty("expandable")) {
              let expandable = await Promise.resolve(api.expandable());
              if (expandable)
                return true;
            }
          }
          return false;
        });
        this.addAction("showInfo", async () => {
          if (!this.infoChannel) {
            this.infoChannel = window_default.createOutputChannel("info");
          } else {
            this.infoChannel.clear();
          }
          let channel = this.infoChannel;
          channel.appendLine("## versions");
          channel.appendLine("");
          let out = await this.nvim.call("execute", ["version"]);
          let first = out.trim().split(/\r?\n/, 2)[0].replace(/\(.*\)/, "").trim();
          channel.appendLine("vim version: " + first + `${workspace_default.isVim ? " " + workspace_default.env.version : ""}`);
          channel.appendLine("node version: " + process.version);
          channel.appendLine("coc.nvim version: " + this.version);
          channel.appendLine("coc.nvim directory: " + import_path34.default.dirname(__dirname));
          channel.appendLine("term: " + (process.env.TERM_PROGRAM || process.env.TERM));
          channel.appendLine("platform: " + process.platform);
          channel.appendLine("");
          channel.appendLine("## Log of coc.nvim");
          channel.appendLine("");
          let file = logger93.getLogFile();
          if (import_fs34.default.existsSync(file)) {
            let content = import_fs34.default.readFileSync(file, { encoding: "utf8" });
            channel.appendLine(content);
          }
          channel.show();
        });
        this.addAction("findLocations", (id, method, params, openCommand) => {
          return this.handler.findLocations(id, method, params, openCommand);
        });
        this.addAction("links", () => {
          return this.handler.links();
        });
        this.addAction("openLink", () => {
          return this.handler.openLink();
        });
        this.addAction("pickColor", () => {
          return this.handler.pickColor();
        });
        this.addAction("colorPresentation", () => {
          return this.handler.pickPresentation();
        });
        this.addAction("highlight", async () => {
          await this.handler.highlight();
        });
        this.addAction("fold", (kind) => {
          return this.handler.fold(kind);
        });
        this.addAction("startCompletion", async (option) => {
          await completion_default.startCompletion(option);
        });
        this.addAction("stopCompletion", () => {
          completion_default.stop(false);
        });
        this.addAction("sourceStat", () => {
          return sources_default.sourceStats();
        });
        this.addAction("refreshSource", async (name2) => {
          await sources_default.refresh(name2);
        });
        this.addAction("toggleSource", (name2) => {
          sources_default.toggleSource(name2);
        });
        this.addAction("diagnosticInfo", async () => {
          await manager_default.echoMessage();
        });
        this.addAction("diagnosticToggle", () => {
          manager_default.toggleDiagnostic();
        });
        this.addAction("diagnosticToggleBuffer", async (bufnr) => {
          if (!bufnr)
            bufnr = await nvim.call("bufnr", ["%"]);
          manager_default.toggleDiagnosticBuffer(bufnr);
        });
        this.addAction("diagnosticNext", async (severity) => {
          await manager_default.jumpNext(severity);
        });
        this.addAction("diagnosticPrevious", async (severity) => {
          await manager_default.jumpPrevious(severity);
        });
        this.addAction("diagnosticPreview", async () => {
          await manager_default.preview();
        });
        this.addAction("diagnosticList", () => {
          return manager_default.getDiagnosticList();
        });
        this.addAction("jumpDefinition", (openCommand) => {
          return this.handler.gotoDefinition(openCommand);
        });
        this.addAction("definitions", () => {
          return this.handler.definitions();
        });
        this.addAction("jumpDeclaration", (openCommand) => {
          return this.handler.gotoDeclaration(openCommand);
        });
        this.addAction("declarations", () => {
          return this.handler.declarations();
        });
        this.addAction("jumpImplementation", (openCommand) => {
          return this.handler.gotoImplementation(openCommand);
        });
        this.addAction("implementations", () => {
          return this.handler.implementations();
        });
        this.addAction("jumpTypeDefinition", (openCommand) => {
          return this.handler.gotoTypeDefinition(openCommand);
        });
        this.addAction("typeDefinitions", () => {
          return this.handler.typeDefinitions();
        });
        this.addAction("jumpReferences", (openCommand) => {
          return this.handler.gotoReferences(openCommand);
        });
        this.addAction("references", () => {
          return this.handler.references();
        });
        this.addAction("jumpUsed", (openCommand) => {
          return this.handler.gotoReferences(openCommand, false);
        });
        this.addAction("doHover", (hoverTarget) => {
          return this.handler.onHover(hoverTarget);
        });
        this.addAction("getHover", () => {
          return this.handler.getHover();
        });
        this.addAction("showSignatureHelp", () => {
          return this.handler.showSignatureHelp();
        });
        this.addAction("documentSymbols", async (bufnr) => {
          if (!bufnr)
            bufnr = await nvim.call("bufnr", ["%"]);
          return await this.handler.getDocumentSymbols(bufnr);
        });
        this.addAction("ensureDocument", async () => {
          let doc = await workspace_default.document;
          return doc && doc.attached;
        });
        this.addAction("symbolRanges", () => {
          return this.handler.getSymbolsRanges();
        });
        this.addAction("selectionRanges", () => {
          return this.handler.getSelectionRanges();
        });
        this.addAction("rangeSelect", (visualmode, forward) => {
          return this.handler.selectRange(visualmode, forward);
        });
        this.addAction("rename", (newName) => {
          return this.handler.rename(newName);
        });
        this.addAction("getWorkspaceSymbols", async (input) => {
          let tokenSource = new import_vscode_languageserver_protocol87.CancellationTokenSource();
          return await languages_default.getWorkspaceSymbols(input, tokenSource.token);
        });
        this.addAction("formatSelected", (mode) => {
          return this.handler.documentRangeFormatting(mode);
        });
        this.addAction("format", () => {
          return this.handler.documentFormatting();
        });
        this.addAction("commands", () => {
          return this.handler.getCommands();
        });
        this.addAction("services", () => {
          return services_default.getServiceStats();
        });
        this.addAction("toggleService", (name2) => {
          return services_default.toggle(name2);
        });
        this.addAction("codeAction", (mode, only) => {
          return this.handler.doCodeAction(mode, only);
        });
        this.addAction("organizeImport", () => {
          return this.handler.organizeImport();
        });
        this.addAction("fixAll", () => {
          return this.handler.doCodeAction(null, [import_vscode_languageserver_protocol87.CodeActionKind.SourceFixAll]);
        });
        this.addAction("doCodeAction", (codeAction) => {
          return this.handler.applyCodeAction(codeAction);
        });
        this.addAction("codeActions", (mode, only) => {
          return this.handler.getCurrentCodeActions(mode, only);
        });
        this.addAction("quickfixes", (mode) => {
          return this.handler.getCurrentCodeActions(mode, [import_vscode_languageserver_protocol87.CodeActionKind.QuickFix]);
        });
        this.addAction("codeLensAction", () => {
          return this.handler.doCodeLensAction();
        });
        this.addAction("runCommand", (...args) => {
          return this.handler.runCommand(...args);
        });
        this.addAction("doQuickfix", () => {
          return this.handler.doQuickfix();
        });
        this.addAction("refactor", () => {
          return this.handler.doRefactor();
        });
        this.addAction("repeatCommand", () => {
          return commands_default.repeatCommand();
        });
        this.addAction("extensionStats", () => {
          return extensions_default.getExtensionStates();
        });
        this.addAction("loadedExtensions", () => {
          return extensions_default.loadedExtensions();
        });
        this.addAction("watchExtension", (id) => {
          return extensions_default.watchExtension(id);
        });
        this.addAction("activeExtension", (name2) => {
          return extensions_default.activate(name2);
        });
        this.addAction("deactivateExtension", (name2) => {
          return extensions_default.deactivate(name2);
        });
        this.addAction("reloadExtension", (name2) => {
          return extensions_default.reloadExtension(name2);
        });
        this.addAction("toggleExtension", (name2) => {
          return extensions_default.toggleExtension(name2);
        });
        this.addAction("uninstallExtension", (...args) => {
          return extensions_default.uninstallExtension(args);
        });
        this.addAction("getCurrentFunctionSymbol", () => {
          return this.handler.getCurrentFunctionSymbol();
        });
        this.addAction("getWordEdit", () => {
          return this.handler.getWordEdit();
        });
        this.addAction("addRanges", async (ranges) => {
          await this.cursors.addRanges(ranges);
        });
        this.addAction("currentWorkspacePath", () => {
          return workspace_default.rootPath;
        });
        this.addAction("addCommand", (cmd) => {
          this.addCommand(cmd);
        });
        this.addAction("selectCurrentPlaceholder", (triggerAutocmd) => {
          return manager_default2.selectCurrentPlaceholder(!!triggerAutocmd);
        });
        this.addAction("codeActionRange", (start, end, only) => this.handler.codeActionRange(start, end, only));
        workspace_default.onDidChangeWorkspaceFolders(() => {
          nvim.setVar("WorkspaceFolders", workspace_default.folderPaths, true);
        });
        commands_default.init(nvim, this);
      }
      addAction(key, fn) {
        if (this.actions.has(key)) {
          throw new Error(`Action ${key} already exists`);
        }
        this.actions.set(key, fn);
      }
      addCommand(cmd) {
        let id = `vim.${cmd.id}`;
        commands_default.registerCommand(id, async () => {
          await this.nvim.command(cmd.cmd);
        });
        if (cmd.title)
          commands_default.titles.set(id, cmd.title);
      }
      async init() {
        let { nvim } = this;
        let s = Date.now();
        try {
          await extensions_default.init();
          await workspace_default.init();
          languages_default.init();
          for (let item of workspace_default.env.vimCommands) {
            this.addCommand(item);
          }
          manager_default2.init();
          completion_default.init();
          manager_default.init();
          manager_default3.init(nvim);
          nvim.setVar("coc_workspace_initialized", 1, true);
          nvim.setVar("WorkspaceFolders", workspace_default.folderPaths, true);
          sources_default.init();
          this.handler = new Handler(nvim);
          services_default.init();
          await extensions_default.activateExtensions();
          workspace_default.setupDynamicAutocmd(true);
          nvim.setVar("coc_service_initialized", 1, true);
          nvim.call("coc#util#do_autocmd", ["CocNvimInit"], true);
          this._ready = true;
          await events_default.fire("ready", []);
          logger93.info(`coc.nvim ${this.version} initialized with node: ${process.version} after ${Date.now() - s}ms`);
          this.emit("ready");
        } catch (e) {
          console.error(`Error on initialize: ${e.stack}`);
          logger93.error(e.stack);
        }
        workspace_default.onDidOpenTextDocument(async (doc) => {
          if (!doc.uri.endsWith(CONFIG_FILE_NAME))
            return;
          if (extensions_default.has("coc-json"))
            return;
          window_default.showMessage(`Run :CocInstall coc-json for json intellisense`, "more");
        });
      }
      get isReady() {
        return this._ready;
      }
      get ready() {
        if (this._ready)
          return Promise.resolve();
        return new Promise((resolve3) => {
          this.once("ready", () => {
            resolve3();
          });
        });
      }
      get version() {
        return workspace_default.version + (true ? "-171ff2bc99" : "");
      }
      hasAction(method) {
        return this.actions.has(method);
      }
      async cocAction(method, ...args) {
        let fn = this.actions.get(method);
        if (!fn)
          throw new Error(`Action "${method}" not exists`);
        return await Promise.resolve(fn.apply(null, args));
      }
      getHandler() {
        return this.handler;
      }
      dispose() {
        this.removeAllListeners();
        extensions_default.dispose();
        manager_default3.dispose();
        workspace_default.dispose();
        window_default.dispose();
        sources_default.dispose();
        services_default.stopAll();
        services_default.dispose();
        if (this.handler) {
          this.handler.dispose();
        }
        manager_default2.dispose();
        commands_default.dispose();
        completion_default.dispose();
        manager_default.dispose();
      }
    };
  }
});

// src/attach.ts
var attach_exports = {};
__export(attach_exports, {
  default: () => attach_default
});
var import_neovim2, import_log4js, import_semver4, logger94, isTest, attach_default;
var init_attach = __esm({
  "src/attach.ts"() {
    import_neovim2 = __toModule(require_lib6());
    import_log4js = __toModule(require_log4js());
    init_events();
    init_plugin();
    import_semver4 = __toModule(require_semver2());
    init_is();
    init_esm2();
    init_package();
    logger94 = require_logger2()("attach");
    isTest = global.hasOwnProperty("__TEST__");
    attach_default = (opts, requestApi = true) => {
      const nvim = (0, import_neovim2.attach)(opts, import_log4js.default.getLogger("node-client"), requestApi);
      if (!global.hasOwnProperty("__TEST__")) {
        nvim.call("coc#util#path_replace_patterns").then((prefixes) => {
          if (objectLiteral(prefixes)) {
            const old_uri = URI.file;
            URI.file = (path34) => {
              path34 = path34.replace(/\\/g, "/");
              Object.keys(prefixes).forEach((k) => path34 = path34.replace(new RegExp("^" + k), prefixes[k]));
              return old_uri(path34);
            };
          }
        }).logError();
      }
      nvim.setVar("coc_process_pid", process.pid, true);
      const plugin = new Plugin(nvim);
      let clientReady = false;
      let initialized = false;
      nvim.on("notification", async (method, args) => {
        switch (method) {
          case "VimEnter": {
            if (!initialized && clientReady) {
              initialized = true;
              await plugin.init();
            }
            break;
          }
          case "TaskExit":
          case "TaskStderr":
          case "TaskStdout":
          case "GlobalChange":
          case "PromptInsert":
          case "InputChar":
          case "MenuInput":
          case "OptionSet":
          case "FloatBtnClick":
            await events_default.fire(method, args);
            break;
          case "CocAutocmd":
            logger94.debug("Notification autocmd:", ...args);
            await events_default.fire(args[0], args.slice(1));
            break;
          default: {
            let exists = plugin.hasAction(method);
            if (!exists) {
              if (global.hasOwnProperty("__TEST__"))
                return;
              console.error(`action "${method}" not registered`);
              return;
            }
            try {
              if (!plugin.isReady) {
                logger94.warn(`Plugin not ready when received "${method}"`, args);
              } else {
                logger94.info("receive notification:", method, args);
              }
              await plugin.ready;
              await plugin.cocAction(method, ...args);
            } catch (e) {
              console.error(`Error on notification "${method}": ${e.message || e.toString()}`);
              logger94.error(`Notification error:`, method, args, e);
            }
          }
        }
      });
      nvim.on("request", async (method, args, resp) => {
        if (method != "redraw") {
          logger94.info("receive request:", method, args);
        }
        let timer = setTimeout(() => {
          logger94.error("Request cost more than 3s", method, args);
        }, 3e3);
        try {
          if (method == "CocAutocmd") {
            logger94.debug("Request autocmd:", ...args);
            await events_default.fire(args[0], args.slice(1));
            resp.send();
          } else {
            if (!plugin.isReady) {
              logger94.warn(`Plugin not ready when received "${method}"`, args);
            }
            let res = await plugin.cocAction(method, ...args);
            resp.send(res);
          }
          clearTimeout(timer);
        } catch (e) {
          clearTimeout(timer);
          resp.send(e.message || e.toString(), true);
          logger94.error(`Request error:`, method, args, e);
        }
      });
      nvim.channelId.then(async (channelId) => {
        clientReady = true;
        if (isTest)
          nvim.command(`let g:coc_node_channel_id = ${channelId}`, true);
        let { major, minor, patch } = import_semver4.default.parse(version);
        nvim.setClientInfo("coc", { major, minor, patch }, "remote", {}, {});
        let entered = await nvim.getVvar("vim_did_enter");
        if (entered && !initialized) {
          initialized = true;
          await plugin.init();
        }
      }).catch((e) => {
        console.error(`Channel create error: ${e.message}`);
      });
      return plugin;
    };
  }
});

// src/main.ts
var promiseFinally = require_promise_prototype();
require_extensions();
Object.defineProperty(console, "log", {
  value() {
    logger95.info(...arguments);
  }
});
promiseFinally.shim();
var logger95 = require_logger2()("server");
var attach2 = (init_attach(), attach_exports).default;
attach2({ reader: process.stdin, writer: process.stdout });
process.on("uncaughtException", function(err) {
  let msg = "Uncaught exception: " + err.message;
  console.error(msg);
  logger95.error("uncaughtException", err.stack);
});
process.on("unhandledRejection", function(reason, p) {
  if (reason instanceof Error) {
    console.error("UnhandledRejection: " + reason.message + "\n" + reason.stack);
  } else {
    console.error("UnhandledRejection: " + reason);
  }
  logger95.error("unhandledRejection ", p, reason);
});
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/*!
 * ISC License
 *
 * Copyright (c) 2018, Andrea Giammarchi, @WebReflection
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
 * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/**
 * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
 *
 * @copyright Yusuke Kawasaki
 * @license MIT
 * @constructor
 * @see https://github.com/kawanet/event-lite
 * @see http://kawanet.github.io/event-lite/EventLite.html
 * @example
 * var EventLite = require("event-lite");
 *
 * function MyClass() {...}             // your class
 *
 * EventLite.mixin(MyClass.prototype);  // import event methods
 *
 * var obj = new MyClass();
 * obj.on("foo", function() {...});     // add event listener
 * obj.once("bar", function() {...});   // add one-time event listener
 * obj.emit("foo");                     // dispatch event
 * obj.emit("bar");                     // dispatch another event
 * obj.off("foo");                      // remove event listener
 */
//# sourceMappingURL=index.js.map

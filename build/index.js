"use strict";
global.__starttime = Date.now();
global.__isMain = require.main === module;
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
    var wrapAnsi16m = (offset = 0) => (red, green, blue2) => `\x1B[${38 + offset};2;${red};${green};${blue2}m`;
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles3 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles3.color.gray = styles3.color.blackBright;
      styles3.bgColor.bgGray = styles3.bgColor.bgBlackBright;
      styles3.color.grey = styles3.color.blackBright;
      styles3.bgColor.bgGrey = styles3.bgColor.bgBlackBright;
      for (const [groupName2, group] of Object.entries(styles3)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles3[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles3[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles3, groupName2, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles3, "codes", {
        value: codes,
        enumerable: false
      });
      styles3.color.close = "\x1B[39m";
      styles3.bgColor.close = "\x1B[49m";
      styles3.color.ansi256 = wrapAnsi256();
      styles3.color.ansi16m = wrapAnsi16m();
      styles3.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles3.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      Object.defineProperties(styles3, {
        rgbToAnsi256: {
          value: (red, green, blue2) => {
            if (red === green && green === blue2) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue2 / 255 * 5);
          },
          enumerable: false
        },
        hexToRgb: {
          value: (hex) => {
            const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
            if (!matches) {
              return [0, 0, 0];
            }
            let { colorString } = matches.groups;
            if (colorString.length === 3) {
              colorString = colorString.split("").map((character) => character + character).join("");
            }
            const integer2 = Number.parseInt(colorString, 16);
            return [
              integer2 >> 16 & 255,
              integer2 >> 8 & 255,
              integer2 & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: (hex) => styles3.rgbToAnsi256(...styles3.hexToRgb(hex)),
          enumerable: false
        }
      });
      return styles3;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/debounce/index.js
var require_debounce = __commonJS({
  "node_modules/debounce/index.js"(exports2, module2) {
    function debounce3(func2, wait2, immediate) {
      var timeout2, args, context, timestamp, result;
      if (null == wait2) wait2 = 100;
      function later() {
        var last = Date.now() - timestamp;
        if (last < wait2 && last >= 0) {
          timeout2 = setTimeout(later, wait2 - last);
        } else {
          timeout2 = null;
          if (!immediate) {
            result = func2.apply(context, args);
            context = args = null;
          }
        }
      }
      ;
      var debounced = function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout2;
        if (!timeout2) timeout2 = setTimeout(later, wait2);
        if (callNow) {
          result = func2.apply(context, args);
          context = args = null;
        }
        return result;
      };
      debounced.clear = function() {
        if (timeout2) {
          clearTimeout(timeout2);
          timeout2 = null;
        }
      };
      debounced.flush = function() {
        if (timeout2) {
          result = func2.apply(context, args);
          context = args = null;
          clearTimeout(timeout2);
          timeout2 = null;
        }
      };
      return debounced;
    }
    debounce3.debounce = debounce3;
    module2.exports = debounce3;
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand2(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand2(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m) return [str];
      var pre = m.pre;
      var post = m.post.length ? expand2(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand2(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand2(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad2 = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad2) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand2(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/dist/commonjs/assert-valid-pattern.js
var require_assert_valid_pattern = __commonJS({
  "node_modules/minimatch/dist/commonjs/assert-valid-pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertValidPattern = void 0;
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    exports2.assertValidPattern = assertValidPattern;
  }
});

// node_modules/minimatch/dist/commonjs/brace-expressions.js
var require_brace_expressions = __commonJS({
  "node_modules/minimatch/dist/commonjs/brace-expressions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseClass = void 0;
    var posixClasses = {
      "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
      "[:alpha:]": ["\\p{L}\\p{Nl}", true],
      "[:ascii:]": ["\\x00-\\x7f", false],
      "[:blank:]": ["\\p{Zs}\\t", true],
      "[:cntrl:]": ["\\p{Cc}", true],
      "[:digit:]": ["\\p{Nd}", true],
      "[:graph:]": ["\\p{Z}\\p{C}", true, true],
      "[:lower:]": ["\\p{Ll}", true],
      "[:print:]": ["\\p{C}", true],
      "[:punct:]": ["\\p{P}", true],
      "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
      "[:upper:]": ["\\p{Lu}", true],
      "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
      "[:xdigit:]": ["A-Fa-f0-9", false]
    };
    var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
    var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var rangesToString = (ranges) => ranges.join("");
    var parseClass = (glob2, position) => {
      const pos = position;
      if (glob2.charAt(pos) !== "[") {
        throw new Error("not in a brace expression");
      }
      const ranges = [];
      const negs = [];
      let i = pos + 1;
      let sawStart = false;
      let uflag = false;
      let escaping = false;
      let negate = false;
      let endPos = pos;
      let rangeStart = "";
      WHILE: while (i < glob2.length) {
        const c = glob2.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
          negate = true;
          i++;
          continue;
        }
        if (c === "]" && sawStart && !escaping) {
          endPos = i + 1;
          break;
        }
        sawStart = true;
        if (c === "\\") {
          if (!escaping) {
            escaping = true;
            i++;
            continue;
          }
        }
        if (c === "[" && !escaping) {
          for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
            if (glob2.startsWith(cls, i)) {
              if (rangeStart) {
                return ["$.", false, glob2.length - pos, true];
              }
              i += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
          } else if (c === rangeStart) {
            ranges.push(braceEscape(c));
          }
          rangeStart = "";
          i++;
          continue;
        }
        if (glob2.startsWith("-]", i + 1)) {
          ranges.push(braceEscape(c + "-"));
          i += 2;
          continue;
        }
        if (glob2.startsWith("-", i + 1)) {
          rangeStart = c;
          i += 2;
          continue;
        }
        ranges.push(braceEscape(c));
        i++;
      }
      if (endPos < i) {
        return ["", false, 0, false];
      }
      if (!ranges.length && !negs.length) {
        return ["$.", false, glob2.length - pos, true];
      }
      if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
      }
      const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
      const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
      const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
      return [comb, uflag, endPos - pos, true];
    };
    exports2.parseClass = parseClass;
  }
});

// node_modules/minimatch/dist/commonjs/unescape.js
var require_unescape = __commonJS({
  "node_modules/minimatch/dist/commonjs/unescape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unescape = void 0;
    var unescape3 = (s, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
    };
    exports2.unescape = unescape3;
  }
});

// node_modules/minimatch/dist/commonjs/ast.js
var require_ast = __commonJS({
  "node_modules/minimatch/dist/commonjs/ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AST = void 0;
    var brace_expressions_js_1 = require_brace_expressions();
    var unescape_js_1 = require_unescape();
    var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
    var isExtglobType = (c) => types.has(c);
    var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
    var startNoDot = "(?!\\.)";
    var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
    var justDots = /* @__PURE__ */ new Set(["..", "."]);
    var reSpecials = new Set("().*{}+?[]^$\\!");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var qmark = "[^/]";
    var star = qmark + "*?";
    var starNoEmpty = qmark + "+?";
    var AST = class _AST {
      type;
      #root;
      #hasMagic;
      #uflag = false;
      #parts = [];
      #parent;
      #parentIndex;
      #negs;
      #filledNegs = false;
      #options;
      #toString;
      // set to true if it's an extglob with no children
      // (which really means one child of '')
      #emptyExt = false;
      constructor(type, parent, options2 = {}) {
        this.type = type;
        if (type)
          this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options2 : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === "!" && !this.#root.#filledNegs)
          this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
      }
      get hasMagic() {
        if (this.#hasMagic !== void 0)
          return this.#hasMagic;
        for (const p of this.#parts) {
          if (typeof p === "string")
            continue;
          if (p.type || p.hasMagic)
            return this.#hasMagic = true;
        }
        return this.#hasMagic;
      }
      // reconstructs the pattern
      toString() {
        if (this.#toString !== void 0)
          return this.#toString;
        if (!this.type) {
          return this.#toString = this.#parts.map((p) => String(p)).join("");
        } else {
          return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
        }
      }
      #fillNegs() {
        if (this !== this.#root)
          throw new Error("should only call on root");
        if (this.#filledNegs)
          return this;
        this.toString();
        this.#filledNegs = true;
        let n;
        while (n = this.#negs.pop()) {
          if (n.type !== "!")
            continue;
          let p = n;
          let pp = p.#parent;
          while (pp) {
            for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
              for (const part of n.#parts) {
                if (typeof part === "string") {
                  throw new Error("string part in extglob AST??");
                }
                part.copyIn(pp.#parts[i]);
              }
            }
            p = pp;
            pp = p.#parent;
          }
        }
        return this;
      }
      push(...parts) {
        for (const p of parts) {
          if (p === "")
            continue;
          if (typeof p !== "string" && !(p instanceof _AST && p.#parent === this)) {
            throw new Error("invalid part: " + p);
          }
          this.#parts.push(p);
        }
      }
      toJSON() {
        const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
        if (this.isStart() && !this.type)
          ret.unshift([]);
        if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
          ret.push({});
        }
        return ret;
      }
      isStart() {
        if (this.#root === this)
          return true;
        if (!this.#parent?.isStart())
          return false;
        if (this.#parentIndex === 0)
          return true;
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
          const pp = p.#parts[i];
          if (!(pp instanceof _AST && pp.type === "!")) {
            return false;
          }
        }
        return true;
      }
      isEnd() {
        if (this.#root === this)
          return true;
        if (this.#parent?.type === "!")
          return true;
        if (!this.#parent?.isEnd())
          return false;
        if (!this.type)
          return this.#parent?.isEnd();
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        return this.#parentIndex === pl - 1;
      }
      copyIn(part) {
        if (typeof part === "string")
          this.push(part);
        else
          this.push(part.clone(this));
      }
      clone(parent) {
        const c = new _AST(this.type, parent);
        for (const p of this.#parts) {
          c.copyIn(p);
        }
        return c;
      }
      static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
          let i2 = pos;
          let acc2 = "";
          while (i2 < str.length) {
            const c = str.charAt(i2++);
            if (escaping || c === "\\") {
              escaping = !escaping;
              acc2 += c;
              continue;
            }
            if (inBrace) {
              if (i2 === braceStart + 1) {
                if (c === "^" || c === "!") {
                  braceNeg = true;
                }
              } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
                inBrace = false;
              }
              acc2 += c;
              continue;
            } else if (c === "[") {
              inBrace = true;
              braceStart = i2;
              braceNeg = false;
              acc2 += c;
              continue;
            }
            if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
              ast.push(acc2);
              acc2 = "";
              const ext = new _AST(c, ast);
              i2 = _AST.#parseAST(str, ext, i2, opt);
              ast.push(ext);
              continue;
            }
            acc2 += c;
          }
          ast.push(acc2);
          return i2;
        }
        let i = pos + 1;
        let part = new _AST(null, ast);
        const parts = [];
        let acc = "";
        while (i < str.length) {
          const c = str.charAt(i++);
          if (escaping || c === "\\") {
            escaping = !escaping;
            acc += c;
            continue;
          }
          if (inBrace) {
            if (i === braceStart + 1) {
              if (c === "^" || c === "!") {
                braceNeg = true;
              }
            } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
              inBrace = false;
            }
            acc += c;
            continue;
          } else if (c === "[") {
            inBrace = true;
            braceStart = i;
            braceNeg = false;
            acc += c;
            continue;
          }
          if (isExtglobType(c) && str.charAt(i) === "(") {
            part.push(acc);
            acc = "";
            const ext = new _AST(c, part);
            part.push(ext);
            i = _AST.#parseAST(str, ext, i, opt);
            continue;
          }
          if (c === "|") {
            part.push(acc);
            acc = "";
            parts.push(part);
            part = new _AST(null, ast);
            continue;
          }
          if (c === ")") {
            if (acc === "" && ast.#parts.length === 0) {
              ast.#emptyExt = true;
            }
            part.push(acc);
            acc = "";
            ast.push(...parts, part);
            return i;
          }
          acc += c;
        }
        ast.type = null;
        ast.#hasMagic = void 0;
        ast.#parts = [str.substring(pos - 1)];
        return i;
      }
      static fromGlob(pattern, options2 = {}) {
        const ast = new _AST(null, void 0, options2);
        _AST.#parseAST(pattern, ast, 0, options2);
        return ast;
      }
      // returns the regular expression if there's magic, or the unescaped
      // string if not.
      toMMPattern() {
        if (this !== this.#root)
          return this.#root.toMMPattern();
        const glob2 = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob2.toUpperCase() !== glob2.toLowerCase();
        if (!anyMagic) {
          return body;
        }
        const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
        return Object.assign(new RegExp(`^${re}$`, flags), {
          _src: re,
          _glob: glob2
        });
      }
      get options() {
        return this.#options;
      }
      // returns the string match, the regexp source, whether there's magic
      // in the regexp (so a regular expression is required) and whether or
      // not the uflag is needed for the regular expression (for posix classes)
      // TODO: instead of injecting the start/end at this point, just return
      // the BODY of the regexp, along with the start/end portions suitable
      // for binding the start/end in either a joined full-path makeRe context
      // (where we bind to (^|/), or a standalone matchPart context (where
      // we bind to ^, and not /).  Otherwise slashes get duped!
      //
      // In part-matching mode, the start is:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: ^(?!\.\.?$)
      // - if dots allowed or not possible: ^
      // - if dots possible and not allowed: ^(?!\.)
      // end is:
      // - if not isEnd(): nothing
      // - else: $
      //
      // In full-path matching mode, we put the slash at the START of the
      // pattern, so start is:
      // - if first pattern: same as part-matching mode
      // - if not isStart(): nothing
      // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
      // - if dots allowed or not possible: /
      // - if dots possible and not allowed: /(?!\.)
      // end is:
      // - if last pattern, same as part-matching mode
      // - else nothing
      //
      // Always put the (?:$|/) on negated tails, though, because that has to be
      // there to bind the end of the negated pattern portion, and it's easier to
      // just stick it in now rather than try to inject it later in the middle of
      // the pattern.
      //
      // We can just always return the same end, and leave it up to the caller
      // to know whether it's going to be used joined or in parts.
      // And, if the start is adjusted slightly, can do the same there:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
      // - if dots allowed or not possible: (?:/|^)
      // - if dots possible and not allowed: (?:/|^)(?!\.)
      //
      // But it's better to have a simpler binding without a conditional, for
      // performance, so probably better to return both start options.
      //
      // Then the caller just ignores the end if it's not the first pattern,
      // and the start always gets applied.
      //
      // But that's always going to be $ if it's the ending pattern, or nothing,
      // so the caller can just attach $ at the end of the pattern when building.
      //
      // So the todo is:
      // - better detect what kind of start is needed
      // - return both flavors of starting pattern
      // - attach $ at the end of the pattern when creating the actual RegExp
      //
      // Ah, but wait, no, that all only applies to the root when the first pattern
      // is not an extglob. If the first pattern IS an extglob, then we need all
      // that dot prevention biz to live in the extglob portions, because eg
      // +(*|.x*) can match .xy but not .yx.
      //
      // So, return the two flavors if it's #root and the first child is not an
      // AST, otherwise leave it to the child AST to handle it, and there,
      // use the (?:^|/) style of start binding.
      //
      // Even simplified further:
      // - Since the start for a join is eg /(?!\.) and the start for a part
      // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
      // or start or whatever) and prepend ^ or / at the Regexp construction.
      toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
          this.#fillNegs();
        if (!this.type) {
          const noEmpty = this.isStart() && this.isEnd();
          const src = this.#parts.map((p) => {
            const [re, _, hasMagic, uflag] = typeof p === "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
            this.#hasMagic = this.#hasMagic || hasMagic;
            this.#uflag = this.#uflag || uflag;
            return re;
          }).join("");
          let start2 = "";
          if (this.isStart()) {
            if (typeof this.#parts[0] === "string") {
              const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
              if (!dotTravAllowed) {
                const aps = addPatternStart;
                const needNoTrav = (
                  // dots are allowed, and the pattern starts with [ or .
                  dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
                  src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
                  src.startsWith("\\.\\.") && aps.has(src.charAt(4))
                );
                const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
              }
            }
          }
          let end = "";
          if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
            end = "(?:$|\\/)";
          }
          const final2 = start2 + src + end;
          return [
            final2,
            (0, unescape_js_1.unescape)(src),
            this.#hasMagic = !!this.#hasMagic,
            this.#uflag
          ];
        }
        const repeated = this.type === "*" || this.type === "+";
        const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
          const s = this.toString();
          this.#parts = [s];
          this.type = null;
          this.#hasMagic = void 0;
          return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
        }
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
          bodyDotAllowed = "";
        }
        if (bodyDotAllowed) {
          body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        let final = "";
        if (this.type === "!" && this.#emptyExt) {
          final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
        } else {
          const close = this.type === "!" ? (
            // !() must match something,but !(x) can match ''
            "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
          ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
          final = start + body + close;
        }
        return [
          final,
          (0, unescape_js_1.unescape)(body),
          this.#hasMagic = !!this.#hasMagic,
          this.#uflag
        ];
      }
      #partsToRegExp(dot) {
        return this.#parts.map((p) => {
          if (typeof p === "string") {
            throw new Error("string type in extglob ast??");
          }
          const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
          this.#uflag = this.#uflag || uflag;
          return re;
        }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
      }
      static #parseGlob(glob2, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = "";
        let uflag = false;
        for (let i = 0; i < glob2.length; i++) {
          const c = glob2.charAt(i);
          if (escaping) {
            escaping = false;
            re += (reSpecials.has(c) ? "\\" : "") + c;
            continue;
          }
          if (c === "\\") {
            if (i === glob2.length - 1) {
              re += "\\\\";
            } else {
              escaping = true;
            }
            continue;
          }
          if (c === "[") {
            const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob2, i);
            if (consumed) {
              re += src;
              uflag = uflag || needUflag;
              i += consumed - 1;
              hasMagic = hasMagic || magic;
              continue;
            }
          }
          if (c === "*") {
            if (noEmpty && glob2 === "*")
              re += starNoEmpty;
            else
              re += star;
            hasMagic = true;
            continue;
          }
          if (c === "?") {
            re += qmark;
            hasMagic = true;
            continue;
          }
          re += regExpEscape(c);
        }
        return [re, (0, unescape_js_1.unescape)(glob2), !!hasMagic, uflag];
      }
    };
    exports2.AST = AST;
  }
});

// node_modules/minimatch/dist/commonjs/escape.js
var require_escape = __commonJS({
  "node_modules/minimatch/dist/commonjs/escape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escape = void 0;
    var escape2 = (s, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
    };
    exports2.escape = escape2;
  }
});

// node_modules/minimatch/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/minimatch/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unescape = exports2.escape = exports2.AST = exports2.Minimatch = exports2.match = exports2.makeRe = exports2.braceExpand = exports2.defaults = exports2.filter = exports2.GLOBSTAR = exports2.sep = exports2.minimatch = void 0;
    var brace_expansion_1 = __importDefault(require_brace_expansion());
    var assert_valid_pattern_js_1 = require_assert_valid_pattern();
    var ast_js_1 = require_ast();
    var escape_js_1 = require_escape();
    var unescape_js_1 = require_unescape();
    var minimatch2 = (p, pattern, options2 = {}) => {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options2).match(p);
    };
    exports2.minimatch = minimatch2;
    var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
    var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
    var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
    var starDotExtTestNocase = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
    };
    var starDotExtTestNocaseDot = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => f.toLowerCase().endsWith(ext2);
    };
    var starDotStarRE = /^\*+\.\*+$/;
    var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
    var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
    var dotStarRE = /^\.\*+$/;
    var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
    var starRE = /^\*+$/;
    var starTest = (f) => f.length !== 0 && !f.startsWith(".");
    var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
    var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
    var qmarksTestNocase = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    var qmarksTestDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    var qmarksTest = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    var qmarksTestNoExt = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && !f.startsWith(".");
    };
    var qmarksTestNoExtDot = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && f !== "." && f !== "..";
    };
    var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
    var path2 = {
      win32: { sep: "\\" },
      posix: { sep: "/" }
    };
    exports2.sep = defaultPlatform === "win32" ? path2.win32.sep : path2.posix.sep;
    exports2.minimatch.sep = exports2.sep;
    exports2.GLOBSTAR = Symbol("globstar **");
    exports2.minimatch.GLOBSTAR = exports2.GLOBSTAR;
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var filter2 = (pattern, options2 = {}) => (p) => (0, exports2.minimatch)(p, pattern, options2);
    exports2.filter = filter2;
    exports2.minimatch.filter = exports2.filter;
    var ext = (a, b = {}) => Object.assign({}, a, b);
    var defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return exports2.minimatch;
      }
      const orig = exports2.minimatch;
      const m = (p, pattern, options2 = {}) => orig(p, pattern, ext(def, options2));
      return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
          constructor(pattern, options2 = {}) {
            super(pattern, ext(def, options2));
          }
          static defaults(options2) {
            return orig.defaults(ext(def, options2)).Minimatch;
          }
        },
        AST: class AST extends orig.AST {
          /* c8 ignore start */
          constructor(type, parent, options2 = {}) {
            super(type, parent, ext(def, options2));
          }
          /* c8 ignore stop */
          static fromGlob(pattern, options2 = {}) {
            return orig.AST.fromGlob(pattern, ext(def, options2));
          }
        },
        unescape: (s, options2 = {}) => orig.unescape(s, ext(def, options2)),
        escape: (s, options2 = {}) => orig.escape(s, ext(def, options2)),
        filter: (pattern, options2 = {}) => orig.filter(pattern, ext(def, options2)),
        defaults: (options2) => orig.defaults(ext(def, options2)),
        makeRe: (pattern, options2 = {}) => orig.makeRe(pattern, ext(def, options2)),
        braceExpand: (pattern, options2 = {}) => orig.braceExpand(pattern, ext(def, options2)),
        match: (list2, pattern, options2 = {}) => orig.match(list2, pattern, ext(def, options2)),
        sep: orig.sep,
        GLOBSTAR: exports2.GLOBSTAR
      });
    };
    exports2.defaults = defaults;
    exports2.minimatch.defaults = exports2.defaults;
    var braceExpand = (pattern, options2 = {}) => {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return (0, brace_expansion_1.default)(pattern);
    };
    exports2.braceExpand = braceExpand;
    exports2.minimatch.braceExpand = exports2.braceExpand;
    var makeRe = (pattern, options2 = {}) => new Minimatch(pattern, options2).makeRe();
    exports2.makeRe = makeRe;
    exports2.minimatch.makeRe = exports2.makeRe;
    var match = (list2, pattern, options2 = {}) => {
      const mm = new Minimatch(pattern, options2);
      list2 = list2.filter((f) => mm.match(f));
      if (mm.options.nonull && !list2.length) {
        list2.push(pattern);
      }
      return list2;
    };
    exports2.match = match;
    exports2.minimatch.match = exports2.match;
    var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var Minimatch = class {
      options;
      set;
      pattern;
      windowsPathsNoEscape;
      nonegate;
      negate;
      comment;
      empty;
      preserveMultipleSlashes;
      partial;
      globSet;
      globParts;
      nocase;
      isWindows;
      platform;
      windowsNoMagicRoot;
      regexp;
      constructor(pattern, options2 = {}) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options2 = options2 || {};
        this.options = options2;
        this.pattern = pattern;
        this.platform = options2.platform || defaultPlatform;
        this.isWindows = this.platform === "win32";
        this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.preserveMultipleSlashes = !!options2.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options2.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options2.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot = options2.windowsNoMagicRoot !== void 0 ? options2.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        this.make();
      }
      hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
          return true;
        }
        for (const pattern of this.set) {
          for (const part of pattern) {
            if (typeof part !== "string")
              return true;
          }
        }
        return false;
      }
      debug(..._) {
      }
      make() {
        const pattern = this.pattern;
        const options2 = this.options;
        if (!options2.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        this.globSet = [...new Set(this.braceExpand())];
        if (options2.debug) {
          this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        let set = this.globParts.map((s, _, __) => {
          if (this.isWindows && this.windowsNoMagicRoot) {
            const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
            const isDrive = /^[a-z]:/i.test(s[0]);
            if (isUNC) {
              return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
            } else if (isDrive) {
              return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
            }
          }
          return s.map((ss) => this.parse(ss));
        });
        this.debug(this.pattern, set);
        this.set = set.filter((s) => s.indexOf(false) === -1);
        if (this.isWindows) {
          for (let i = 0; i < this.set.length; i++) {
            const p = this.set[i];
            if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
              p[2] = "?";
            }
          }
        }
        this.debug(this.pattern, this.set);
      }
      // various transforms to equivalent pattern sets that are
      // faster to process in a filesystem walk.  The goal is to
      // eliminate what we can, and push all ** patterns as far
      // to the right as possible, even if it increases the number
      // of patterns that we have to process.
      preprocess(globParts) {
        if (this.options.noglobstar) {
          for (let i = 0; i < globParts.length; i++) {
            for (let j = 0; j < globParts[i].length; j++) {
              if (globParts[i][j] === "**") {
                globParts[i][j] = "*";
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          globParts = this.firstPhasePreProcess(globParts);
          globParts = this.secondPhasePreProcess(globParts);
        } else if (optimizationLevel >= 1) {
          globParts = this.levelOneOptimize(globParts);
        } else {
          globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
      }
      // just get rid of adjascent ** portions
      adjascentGlobstarOptimize(globParts) {
        return globParts.map((parts) => {
          let gs = -1;
          while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
            let i = gs;
            while (parts[i + 1] === "**") {
              i++;
            }
            if (i !== gs) {
              parts.splice(gs, i - gs);
            }
          }
          return parts;
        });
      }
      // get rid of adjascent ** and resolve .. portions
      levelOneOptimize(globParts) {
        return globParts.map((parts) => {
          parts = parts.reduce((set, part) => {
            const prev = set[set.length - 1];
            if (part === "**" && prev === "**") {
              return set;
            }
            if (part === "..") {
              if (prev && prev !== ".." && prev !== "." && prev !== "**") {
                set.pop();
                return set;
              }
            }
            set.push(part);
            return set;
          }, []);
          return parts.length === 0 ? [""] : parts;
        });
      }
      levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
          parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
          didSomething = false;
          if (!this.preserveMultipleSlashes) {
            for (let i = 1; i < parts.length - 1; i++) {
              const p = parts[i];
              if (i === 1 && p === "" && parts[0] === "")
                continue;
              if (p === "." || p === "") {
                didSomething = true;
                parts.splice(i, 1);
                i--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd = 0;
          while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
            const p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = true;
              parts.splice(dd - 1, 2);
              dd -= 2;
            }
          }
        } while (didSomething);
        return parts.length === 0 ? [""] : parts;
      }
      // First phase: single-pattern processing
      // <pre> is 1 or more portions
      // <rest> is 1 or more portions
      // <p> is any portion other than ., .., '', or **
      // <e> is . or ''
      //
      // **/.. is *brutal* for filesystem walking performance, because
      // it effectively resets the recursive walk each time it occurs,
      // and ** cannot be reduced out by a .. pattern part like a regexp
      // or most strings (other than .., ., and '') can be.
      //
      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
      // <pre>/<e>/<rest> -> <pre>/<rest>
      // <pre>/<p>/../<rest> -> <pre>/<rest>
      // **/**/<rest> -> **/<rest>
      //
      // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
      // this WOULD be allowed if ** did follow symlinks, or * didn't
      firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
          didSomething = false;
          for (let parts of globParts) {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
              let gss = gs;
              while (parts[gss + 1] === "**") {
                gss++;
              }
              if (gss > gs) {
                parts.splice(gs + 1, gss - gs);
              }
              let next = parts[gs + 1];
              const p = parts[gs + 2];
              const p2 = parts[gs + 3];
              if (next !== "..")
                continue;
              if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
                continue;
              }
              didSomething = true;
              parts.splice(gs, 1);
              const other = parts.slice(0);
              other[gs] = "**";
              globParts.push(other);
              gs--;
            }
            if (!this.preserveMultipleSlashes) {
              for (let i = 1; i < parts.length - 1; i++) {
                const p = parts[i];
                if (i === 1 && p === "" && parts[0] === "")
                  continue;
                if (p === "." || p === "") {
                  didSomething = true;
                  parts.splice(i, 1);
                  i--;
                }
              }
              if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
                didSomething = true;
                parts.pop();
              }
            }
            let dd = 0;
            while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
              const p = parts[dd - 1];
              if (p && p !== "." && p !== ".." && p !== "**") {
                didSomething = true;
                const needDot = dd === 1 && parts[dd + 1] === "**";
                const splin = needDot ? ["."] : [];
                parts.splice(dd - 1, 2, ...splin);
                if (parts.length === 0)
                  parts.push("");
                dd -= 2;
              }
            }
          }
        } while (didSomething);
        return globParts;
      }
      // second phase: multi-pattern dedupes
      // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
      // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
      // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
      //
      // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
      // ^-- not valid because ** doens't follow symlinks
      secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
          for (let j = i + 1; j < globParts.length; j++) {
            const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
            if (!matched)
              continue;
            globParts[i] = matched;
            globParts[j] = [];
          }
        }
        return globParts.filter((gs) => gs.length);
      }
      partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which2 = "";
        while (ai < a.length && bi < b.length) {
          if (a[ai] === b[bi]) {
            result.push(which2 === "b" ? b[bi] : a[ai]);
            ai++;
            bi++;
          } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
            result.push(a[ai]);
            ai++;
          } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
            result.push(b[bi]);
            bi++;
          } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
            if (which2 === "b")
              return false;
            which2 = "a";
            result.push(a[ai]);
            ai++;
            bi++;
          } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
            if (which2 === "a")
              return false;
            which2 = "b";
            result.push(b[bi]);
            ai++;
            bi++;
          } else {
            return false;
          }
        }
        return a.length === b.length && result;
      }
      parseNegate() {
        if (this.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial = false) {
        const options2 = this.options;
        if (this.isWindows) {
          const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
          const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
          const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
          const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
          const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
          const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
          if (typeof fdi === "number" && typeof pdi === "number") {
            const [fd, pd] = [file[fdi], pattern[pdi]];
            if (fd.toLowerCase() === pd.toLowerCase()) {
              pattern[pdi] = fd;
              if (pdi > fdi) {
                pattern = pattern.slice(pdi);
              } else if (fdi > pdi) {
                file = file.slice(fdi);
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          file = this.levelTwoFileOptimize(file);
        }
        this.debug("matchOne", this, { file, pattern });
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false) {
            return false;
          }
          if (p === exports2.GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl) {
                return true;
              }
            }
            return false;
          }
          let hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = p.test(f);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        } else {
          throw new Error("wtf?");
        }
      }
      braceExpand() {
        return (0, exports2.braceExpand)(this.pattern, this.options);
      }
      parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options2 = this.options;
        if (pattern === "**")
          return exports2.GLOBSTAR;
        if (pattern === "")
          return "";
        let m;
        let fastTest = null;
        if (m = pattern.match(starRE)) {
          fastTest = options2.dot ? starTestDot : starTest;
        } else if (m = pattern.match(starDotExtRE)) {
          fastTest = (options2.nocase ? options2.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options2.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
        } else if (m = pattern.match(qmarksRE)) {
          fastTest = (options2.nocase ? options2.dot ? qmarksTestNocaseDot : qmarksTestNocase : options2.dot ? qmarksTestDot : qmarksTest)(m);
        } else if (m = pattern.match(starDotStarRE)) {
          fastTest = options2.dot ? starDotStarTestDot : starDotStarTest;
        } else if (m = pattern.match(dotStarRE)) {
          fastTest = dotStarTest;
        }
        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === "object") {
          Reflect.defineProperty(re, "test", { value: fastTest });
        }
        return re;
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options2 = this.options;
        const twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
        const flags = new Set(options2.nocase ? ["i"] : []);
        let re = set.map((pattern) => {
          const pp = pattern.map((p) => {
            if (p instanceof RegExp) {
              for (const f of p.flags.split(""))
                flags.add(f);
            }
            return typeof p === "string" ? regExpEscape(p) : p === exports2.GLOBSTAR ? exports2.GLOBSTAR : p._src;
          });
          pp.forEach((p, i) => {
            const next = pp[i + 1];
            const prev = pp[i - 1];
            if (p !== exports2.GLOBSTAR || prev === exports2.GLOBSTAR) {
              return;
            }
            if (prev === void 0) {
              if (next !== void 0 && next !== exports2.GLOBSTAR) {
                pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
              } else {
                pp[i] = twoStar;
              }
            } else if (next === void 0) {
              pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
            } else if (next !== exports2.GLOBSTAR) {
              pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
              pp[i + 1] = exports2.GLOBSTAR;
            }
          });
          return pp.filter((p) => p !== exports2.GLOBSTAR).join("/");
        }).join("|");
        const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
        re = "^" + open + re + close + "$";
        if (this.negate)
          re = "^(?!" + re + ").+$";
        try {
          this.regexp = new RegExp(re, [...flags].join(""));
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      slashSplit(p) {
        if (this.preserveMultipleSlashes) {
          return p.split("/");
        } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
          return ["", ...p.split(/\/+/)];
        } else {
          return p.split(/\/+/);
        }
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment) {
          return false;
        }
        if (this.empty) {
          return f === "";
        }
        if (f === "/" && partial) {
          return true;
        }
        const options2 = this.options;
        if (this.isWindows) {
          f = f.split("\\").join("/");
        }
        const ff = this.slashSplit(f);
        this.debug(this.pattern, "split", ff);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename = ff[ff.length - 1];
        if (!filename) {
          for (let i = ff.length - 2; !filename && i >= 0; i--) {
            filename = ff[i];
          }
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = ff;
          if (options2.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options2.flipNegate) {
              return true;
            }
            return !this.negate;
          }
        }
        if (options2.flipNegate) {
          return false;
        }
        return this.negate;
      }
      static defaults(def) {
        return exports2.minimatch.defaults(def).Minimatch;
      }
    };
    exports2.Minimatch = Minimatch;
    var ast_js_2 = require_ast();
    Object.defineProperty(exports2, "AST", { enumerable: true, get: function() {
      return ast_js_2.AST;
    } });
    var escape_js_2 = require_escape();
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    var unescape_js_2 = require_unescape();
    Object.defineProperty(exports2, "unescape", { enumerable: true, get: function() {
      return unescape_js_2.unescape;
    } });
    exports2.minimatch.AST = ast_js_1.AST;
    exports2.minimatch.Minimatch = Minimatch;
    exports2.minimatch.escape = escape_js_1.escape;
    exports2.minimatch.unescape = unescape_js_1.unescape;
  }
});

// node_modules/path-scurry/node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs2 = __commonJS({
  "node_modules/path-scurry/node_modules/lru-cache/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class _Stack {
      heap;
      length;
      // private constructor
      static #constructing = false;
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        _Stack.#constructing = true;
        const s = new _Stack(max, HeapCls);
        _Stack.#constructing = false;
        return s;
      }
      constructor(max, HeapCls) {
        if (!_Stack.#constructing) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache2 = class _LRUCache {
      // properties coming in from the options of these, only max and maxSize
      // really *need* to be protected. The rest can be modified, as they just
      // set defaults for various methods.
      #max;
      #maxSize;
      #dispose;
      #disposeAfter;
      #fetchMethod;
      /**
       * {@link LRUCache.OptionsBase.ttl}
       */
      ttl;
      /**
       * {@link LRUCache.OptionsBase.ttlResolution}
       */
      ttlResolution;
      /**
       * {@link LRUCache.OptionsBase.ttlAutopurge}
       */
      ttlAutopurge;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnGet}
       */
      updateAgeOnGet;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnHas}
       */
      updateAgeOnHas;
      /**
       * {@link LRUCache.OptionsBase.allowStale}
       */
      allowStale;
      /**
       * {@link LRUCache.OptionsBase.noDisposeOnSet}
       */
      noDisposeOnSet;
      /**
       * {@link LRUCache.OptionsBase.noUpdateTTL}
       */
      noUpdateTTL;
      /**
       * {@link LRUCache.OptionsBase.maxEntrySize}
       */
      maxEntrySize;
      /**
       * {@link LRUCache.OptionsBase.sizeCalculation}
       */
      sizeCalculation;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
       */
      noDeleteOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
       */
      noDeleteOnStaleGet;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
       */
      allowStaleOnFetchAbort;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
       */
      allowStaleOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.ignoreFetchAbort}
       */
      ignoreFetchAbort;
      // computed properties
      #size;
      #calculatedSize;
      #keyMap;
      #keyList;
      #valList;
      #next;
      #prev;
      #head;
      #tail;
      #free;
      #disposed;
      #sizes;
      #starts;
      #ttls;
      #hasDispose;
      #hasFetchMethod;
      #hasDisposeAfter;
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c) {
        return {
          // properties
          starts: c.#starts,
          ttls: c.#ttls,
          sizes: c.#sizes,
          keyMap: c.#keyMap,
          keyList: c.#keyList,
          valList: c.#valList,
          next: c.#next,
          prev: c.#prev,
          get head() {
            return c.#head;
          },
          get tail() {
            return c.#tail;
          },
          free: c.#free,
          // methods
          isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
          backgroundFetch: (k, index, options2, context) => c.#backgroundFetch(k, index, options2, context),
          moveToTail: (index) => c.#moveToTail(index),
          indexes: (options2) => c.#indexes(options2),
          rindexes: (options2) => c.#rindexes(options2),
          isStale: (index) => c.#isStale(index)
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return this.#max;
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return this.#maxSize;
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return this.#calculatedSize;
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return this.#size;
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return this.#fetchMethod;
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return this.#dispose;
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return this.#disposeAfter;
      }
      constructor(options2) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options2;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!this.#maxSize && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = /* @__PURE__ */ new Map();
        this.#keyList = new Array(max).fill(void 0);
        this.#valList = new Array(max).fill(void 0);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === "function") {
          this.#dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.#disposeAfter = disposeAfter;
          this.#disposed = [];
        } else {
          this.#disposeAfter = void 0;
          this.#disposed = void 0;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.#maxSize !== 0) {
            if (!isPosInt(this.#maxSize)) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.#initializeTTLTracking();
        }
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Return the remaining TTL time for a given entry key
       */
      getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
      }
      #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
          starts[index] = ttl !== 0 ? start : 0;
          ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.#isStale(index)) {
                this.delete(this.#keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.#updateItemAge = (index) => {
          starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
          if (ttls[index]) {
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start)
              return;
            status.ttl = ttl;
            status.start = start;
            status.now = cachedNow || getNow();
            const age = status.now - start;
            status.remainingTTL = ttl - age;
          }
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.#keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start) {
            return Infinity;
          }
          const age = (cachedNow || getNow()) - start;
          return ttl - age;
        };
        this.#isStale = (index) => {
          const s = starts[index];
          const t = ttls[index];
          return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
      }
      // conditionally set private methods related to TTL
      #updateItemAge = () => {
      };
      #statusTTL = () => {
      };
      #setItemTTL = () => {
      };
      /* c8 ignore stop */
      #isStale = () => false;
      #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index) => {
          this.#calculatedSize -= sizes[index];
          sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
          if (this.#isBackgroundFetch(v)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
            } else {
              throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
            }
          }
          return size;
        };
        this.#addItemSize = (index, size, status) => {
          sizes[index] = size;
          if (this.#maxSize) {
            const maxSize = this.#maxSize - sizes[index];
            while (this.#calculatedSize > maxSize) {
              this.#evict(true);
            }
          }
          this.#calculatedSize += sizes[index];
          if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = this.#calculatedSize;
          }
        };
      }
      #removeItemSize = (_i) => {
      };
      #addItemSize = (_i, _s, _st) => {
      };
      #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
        return 0;
      };
      *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#tail; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#head) {
              break;
            } else {
              i = this.#prev[i];
            }
          }
        }
      }
      *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#head; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#tail) {
              break;
            } else {
              i = this.#next[i];
            }
          }
        }
      }
      #isValidIndex(index) {
        return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i of this.#indexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i of this.#rindexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i of this.#indexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i of this.#rindexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * A String value that is used in the creation of the default string description of an object.
       * Called by the built-in method Object.prototype.toString.
       */
      [Symbol.toStringTag] = "LRUCache";
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to Array.find().  fn is called as fn(value, key, cache).
       */
      find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, this.#keyList[i], this)) {
            return this.get(this.#keyList[i], getOptions);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from
       * most recently used to least recently used.  fn is called as
       * fn(value, key, cache).  Does not update age or recenty of use.
       * Does not iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
          if (this.#isStale(i)) {
            this.delete(this.#keyList[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
       * single key. Always returns stale values, if their info is found in the
       * cache, so be sure to check for expired TTLs if relevant.
       */
      info(key) {
        const i = this.#keyMap.get(key);
        if (i === void 0)
          return void 0;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          return void 0;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          const ttl = this.#ttls[i];
          const start = this.#starts[i];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        return entry;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to cache.load()
       */
      dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
          const key = this.#keyList[i];
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key === void 0)
            continue;
          const entry = { value };
          if (this.#ttls && this.#starts) {
            entry.ttl = this.#ttls[i];
            const age = perf.now() - this.#starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.#sizes) {
            entry.size = this.#sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       * Note that the shape of the resulting cache may be different if the
       * same options are not used in both caches.
       */
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       */
      set(k, v, setOptions2 = {}) {
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions2;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions2;
        const size = this.#requireSize(k, v, setOptions2.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.delete(k);
          return this;
        }
        let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
        if (index === void 0) {
          index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
          this.#keyList[index] = k;
          this.#valList[index] = v;
          this.#keyMap.set(k, index);
          this.#next[this.#tail] = index;
          this.#prev[index] = this.#tail;
          this.#tail = index;
          this.#size++;
          this.#addItemSize(index, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
        } else {
          this.#moveToTail(index);
          const oldVal = this.#valList[index];
          if (v !== oldVal) {
            if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if (this.#hasDispose) {
                  this.#dispose?.(s, k, "set");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(oldVal, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([oldVal, k, "set"]);
              }
            }
            this.#removeItemSize(index);
            this.#addItemSize(index, size, status);
            this.#valList[index] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && !this.#ttls) {
          this.#initializeTTLTracking();
        }
        if (this.#ttls) {
          if (!noUpdateTTL) {
            this.#setItemTTL(index, ttl, start);
          }
          if (status)
            this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        try {
          while (this.#size) {
            const val = this.#valList[this.#head];
            this.#evict(true);
            if (this.#isBackgroundFetch(val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while (task = dt?.shift()) {
              this.#disposeAfter?.(...task);
            }
          }
        }
      }
      #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("evicted"));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
          if (this.#hasDispose) {
            this.#dispose?.(v, k, "evict");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, "evict"]);
          }
        }
        this.#removeItemSize(head);
        if (free) {
          this.#keyList[head] = void 0;
          this.#valList[head] = void 0;
          this.#free.push(head);
        }
        if (this.#size === 1) {
          this.#head = this.#tail = 0;
          this.#free.length = 0;
        } else {
          this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!this.#isStale(index)) {
            if (updateAgeOnHas) {
              this.#updateItemAge(index);
            }
            if (status) {
              status.has = "hit";
              this.#statusTTL(status, index);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            this.#statusTTL(status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === void 0 || !allowStale && this.#isStale(index)) {
          return;
        }
        const v = this.#valList[index];
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
      #backgroundFetch(k, index, options2, context) {
        const v = index === void 0 ? void 0 : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const { signal } = options2;
        signal?.addEventListener("abort", () => ac.abort(signal.reason), {
          signal: ac.signal
        });
        const fetchOpts = {
          signal: ac.signal,
          options: options2,
          context
        };
        const cb = (v2, updateCache = false) => {
          const { aborted } = ac.signal;
          const ignoreAbort = options2.ignoreFetchAbort && v2 !== void 0;
          if (options2.status) {
            if (aborted && !updateCache) {
              options2.status.fetchAborted = true;
              options2.status.fetchError = ac.signal.reason;
              if (ignoreAbort)
                options2.status.fetchAbortIgnored = true;
            } else {
              options2.status.fetchResolved = true;
            }
          }
          if (aborted && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          const bf2 = p;
          if (this.#valList[index] === p) {
            if (v2 === void 0) {
              if (bf2.__staleWhileFetching) {
                this.#valList[index] = bf2.__staleWhileFetching;
              } else {
                this.delete(k);
              }
            } else {
              if (options2.status)
                options2.status.fetchUpdated = true;
              this.set(k, v2, fetchOpts.options);
            }
          }
          return v2;
        };
        const eb = (er) => {
          if (options2.status) {
            options2.status.fetchRejected = true;
            options2.status.fetchError = er;
          }
          return fetchFail(er);
        };
        const fetchFail = (er) => {
          const { aborted } = ac.signal;
          const allowStaleAborted = aborted && options2.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options2.allowStaleOnFetchRejection;
          const noDelete = allowStale || options2.noDeleteOnFetchRejection;
          const bf2 = p;
          if (this.#valList[index] === p) {
            const del = !noDelete || bf2.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else if (!allowStaleAborted) {
              this.#valList[index] = bf2.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options2.status && bf2.__staleWhileFetching !== void 0) {
              options2.status.returnedStale = true;
            }
            return bf2.__staleWhileFetching;
          } else if (bf2.__returned === bf2) {
            throw er;
          }
        };
        const pcall = (res, rej) => {
          const fmp = this.#fetchMethod?.(k, v, fetchOpts);
          if (fmp && fmp instanceof Promise) {
            fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
          }
          ac.signal.addEventListener("abort", () => {
            if (!options2.ignoreFetchAbort || options2.allowStaleOnFetchAbort) {
              res(void 0);
              if (options2.allowStaleOnFetchAbort) {
                res = (v2) => cb(v2, true);
              }
            }
          });
        };
        if (options2.status)
          options2.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
          __abortController: ac,
          __staleWhileFetching: v,
          __returned: void 0
        });
        if (index === void 0) {
          this.set(k, bf, { ...fetchOpts.options, status: void 0 });
          index = this.#keyMap.get(k);
        } else {
          this.#valList[index] = bf;
        }
        return bf;
      }
      #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
          return false;
        const b = p;
        return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!this.#hasFetchMethod) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options2 = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = this.#keyMap.get(k);
        if (index === void 0) {
          if (status)
            status.fetch = "miss";
          const p = this.#backgroundFetch(k, index, options2, context);
          return p.__returned = p;
        } else {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = this.#isStale(index);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            if (status)
              this.#statusTTL(status, index);
            return v;
          }
          const p = this.#backgroundFetch(k, index, options2, context);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const value = this.#valList[index];
          const fetching = this.#isBackgroundFetch(value);
          if (status)
            this.#statusTTL(status, index);
          if (this.#isStale(index)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
      }
      #moveToTail(index) {
        if (index !== this.#tail) {
          if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            this.#connect(this.#prev[index], this.#next[index]);
          }
          this.#connect(this.#tail, index);
          this.#tail = index;
        }
      }
      /**
       * Deletes a key out of the cache.
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k) {
        let deleted = false;
        if (this.#size !== 0) {
          const index = this.#keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.#size === 1) {
              this.clear();
            } else {
              this.#removeItemSize(index);
              const v = this.#valList[index];
              if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
              } else if (this.#hasDispose || this.#hasDisposeAfter) {
                if (this.#hasDispose) {
                  this.#dispose?.(v, k, "delete");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([v, k, "delete"]);
                }
              }
              this.#keyMap.delete(k);
              this.#keyList[index] = void 0;
              this.#valList[index] = void 0;
              if (index === this.#tail) {
                this.#tail = this.#prev[index];
              } else if (index === this.#head) {
                this.#head = this.#next[index];
              } else {
                const pi = this.#prev[index];
                this.#next[pi] = this.#next[index];
                const ni = this.#next[index];
                this.#prev[ni] = this.#prev[index];
              }
              this.#size--;
              this.#free.push(index);
            }
          }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return deleted;
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        for (const index of this.#rindexes({ allowStale: true })) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.#keyList[index];
            if (this.#hasDispose) {
              this.#dispose?.(v, k, "delete");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, "delete"]);
            }
          }
        }
        this.#keyMap.clear();
        this.#valList.fill(void 0);
        this.#keyList.fill(void 0);
        if (this.#ttls && this.#starts) {
          this.#ttls.fill(0);
          this.#starts.fill(0);
        }
        if (this.#sizes) {
          this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    };
    exports2.LRUCache = LRUCache2;
  }
});

// node_modules/minipass/dist/commonjs/index.js
var require_commonjs3 = __commonJS({
  "node_modules/minipass/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Minipass = exports2.isWritable = exports2.isReadable = exports2.isStream = void 0;
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var node_events_1 = require("node:events");
    var node_stream_1 = __importDefault(require("node:stream"));
    var node_string_decoder_1 = require("node:string_decoder");
    var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof node_stream_1.default || (0, exports2.isReadable)(s) || (0, exports2.isWritable)(s));
    exports2.isStream = isStream;
    var isReadable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
    s.pipe !== node_stream_1.default.Writable.prototype.pipe;
    exports2.isReadable = isReadable;
    var isWritable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
    exports2.isWritable = isWritable;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFER = Symbol("buffer");
    var PIPES = Symbol("pipes");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var ERROR = Symbol("error");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var ABORT = Symbol("abort");
    var ABORTED = Symbol("aborted");
    var SIGNAL = Symbol("signal");
    var DATALISTENERS = Symbol("dataListeners");
    var DISCARDED = Symbol("discarded");
    var defer = (fn) => Promise.resolve().then(fn);
    var nodefer = (fn) => fn();
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      src;
      dest;
      opts;
      ondrain;
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        this.dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // only here for the prototype
      /* c8 ignore start */
      proxyErrors(_er) {
      }
      /* c8 ignore stop */
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    var isObjectModeOptions = (o) => !!o.objectMode;
    var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
    var Minipass = class extends node_events_1.EventEmitter {
      [FLOWING] = false;
      [PAUSED] = false;
      [PIPES] = [];
      [BUFFER] = [];
      [OBJECTMODE];
      [ENCODING];
      [ASYNC];
      [DECODER];
      [EOF] = false;
      [EMITTED_END] = false;
      [EMITTING_END] = false;
      [CLOSED] = false;
      [EMITTED_ERROR] = null;
      [BUFFERLENGTH] = 0;
      [DESTROYED] = false;
      [SIGNAL];
      [ABORTED] = false;
      [DATALISTENERS] = 0;
      [DISCARDED] = false;
      /**
       * true if the stream can be written
       */
      writable = true;
      /**
       * true if the stream can be read
       */
      readable = true;
      /**
       * If `RType` is Buffer, then options do not need to be provided.
       * Otherwise, an options object must be provided to specify either
       * {@link Minipass.SharedOptions.objectMode} or
       * {@link Minipass.SharedOptions.encoding}, as appropriate.
       */
      constructor(...args) {
        const options2 = args[0] || {};
        super();
        if (options2.objectMode && typeof options2.encoding === "string") {
          throw new TypeError("Encoding and objectMode may not be used together");
        }
        if (isObjectModeOptions(options2)) {
          this[OBJECTMODE] = true;
          this[ENCODING] = null;
        } else if (isEncodingOptions(options2)) {
          this[ENCODING] = options2.encoding;
          this[OBJECTMODE] = false;
        } else {
          this[OBJECTMODE] = false;
          this[ENCODING] = null;
        }
        this[ASYNC] = !!options2.async;
        this[DECODER] = this[ENCODING] ? new node_string_decoder_1.StringDecoder(this[ENCODING]) : null;
        if (options2 && options2.debugExposeBuffer === true) {
          Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
        }
        if (options2 && options2.debugExposePipes === true) {
          Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
        }
        const { signal } = options2;
        if (signal) {
          this[SIGNAL] = signal;
          if (signal.aborted) {
            this[ABORT]();
          } else {
            signal.addEventListener("abort", () => this[ABORT]());
          }
        }
      }
      /**
       * The amount of data stored in the buffer waiting to be read.
       *
       * For Buffer strings, this will be the total byte length.
       * For string encoding streams, this will be the string character length,
       * according to JavaScript's `string.length` logic.
       * For objectMode streams, this is a count of the items waiting to be
       * emitted.
       */
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      /**
       * The `BufferEncoding` currently in use, or `null`
       */
      get encoding() {
        return this[ENCODING];
      }
      /**
       * @deprecated - This is a read only property
       */
      set encoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * @deprecated - Encoding may only be set at instantiation time
       */
      setEncoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * True if this is an objectMode stream
       */
      get objectMode() {
        return this[OBJECTMODE];
      }
      /**
       * @deprecated - This is a read-only property
       */
      set objectMode(_om) {
        throw new Error("objectMode must be set at instantiation time");
      }
      /**
       * true if this is an async stream
       */
      get ["async"]() {
        return this[ASYNC];
      }
      /**
       * Set to true to make this stream async.
       *
       * Once set, it cannot be unset, as this would potentially cause incorrect
       * behavior.  Ie, a sync stream can be made async, but an async stream
       * cannot be safely made sync.
       */
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      // drop everything and get out of the flow completely
      [ABORT]() {
        this[ABORTED] = true;
        this.emit("abort", this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
      }
      /**
       * True if the stream has been aborted.
       */
      get aborted() {
        return this[ABORTED];
      }
      /**
       * No-op setter. Stream aborted status is set via the AbortSignal provided
       * in the constructor options.
       */
      set aborted(_) {
      }
      write(chunk, encoding2, cb) {
        if (this[ABORTED])
          return false;
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
          return true;
        }
        if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = "utf8";
        }
        if (!encoding2)
          encoding2 = "utf8";
        const fn = this[ASYNC] ? defer : nodefer;
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk)) {
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          } else if (isArrayBufferLike(chunk)) {
            chunk = Buffer.from(chunk);
          } else if (typeof chunk !== "string") {
            throw new Error("Non-contiguous data written to non-objectMode stream");
          }
        }
        if (this[OBJECTMODE]) {
          if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this[FLOWING])
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding2 === this[ENCODING] && !this[DECODER]?.lastNeed)) {
          chunk = Buffer.from(chunk, encoding2);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
          chunk = this[DECODER].write(chunk);
        }
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      /**
       * Low-level explicit read method.
       *
       * In objectMode, the argument is ignored, and one item is returned if
       * available.
       *
       * `n` is the number of bytes (or in the case of encoding streams,
       * characters) to consume. If `n` is not provided, then the entire buffer
       * is returned, or `null` is returned if no data is available.
       *
       * If `n` is greater that the amount of data in the internal buffer,
       * then `null` is returned.
       */
      read(n) {
        if (this[DESTROYED])
          return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
          this[BUFFER] = [
            this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
          ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (this[OBJECTMODE])
          this[BUFFERSHIFT]();
        else {
          const c = chunk;
          if (n === c.length || n === null)
            this[BUFFERSHIFT]();
          else if (typeof c === "string") {
            this[BUFFER][0] = c.slice(n);
            chunk = c.slice(0, n);
            this[BUFFERLENGTH] -= n;
          } else {
            this[BUFFER][0] = c.subarray(n);
            chunk = c.subarray(0, n);
            this[BUFFERLENGTH] -= n;
          }
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding2, cb) {
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = void 0;
        }
        if (typeof encoding2 === "function") {
          cb = encoding2;
          encoding2 = "utf8";
        }
        if (chunk !== void 0)
          this.write(chunk, encoding2);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this[FLOWING] || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
          this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      /**
       * Resume the stream if it is currently in a paused state
       *
       * If called when there are no pipe destinations or `data` event listeners,
       * this will place the stream in a "discarded" state, where all data will
       * be thrown away. The discarded state is removed if a pipe destination or
       * data handler is added, if pause() is called, or if any synchronous or
       * asynchronous iteration is started.
       */
      resume() {
        return this[RESUME]();
      }
      /**
       * Pause the stream
       */
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
      }
      /**
       * true if the stream has been forcibly destroyed
       */
      get destroyed() {
        return this[DESTROYED];
      }
      /**
       * true if the stream is currently in a flowing state, meaning that
       * any writes will be immediately emitted.
       */
      get flowing() {
        return this[FLOWING];
      }
      /**
       * true if the stream is currently in a paused state
       */
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
      }
      [FLUSH](noDrain = false) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        this.emit("data", chunk);
        return this[FLOWING];
      }
      /**
       * Pipe all data emitted by this stream into the destination provided.
       *
       * Triggers the flow of data.
       */
      pipe(dest, opts) {
        if (this[DESTROYED])
          return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      /**
       * Fully unhook a piped destination stream.
       *
       * If the destination stream was the only consumer of this stream (ie,
       * there are no other piped destinations or `'data'` event listeners)
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      unpipe(dest) {
        const p = this[PIPES].find((p2) => p2.dest === dest);
        if (p) {
          if (this[PIPES].length === 1) {
            if (this[FLOWING] && this[DATALISTENERS] === 0) {
              this[FLOWING] = false;
            }
            this[PIPES] = [];
          } else
            this[PIPES].splice(this[PIPES].indexOf(p), 1);
          p.unpipe();
        }
      }
      /**
       * Alias for {@link Minipass#on}
       */
      addListener(ev, handler) {
        return this.on(ev, handler);
      }
      /**
       * Mostly identical to `EventEmitter.on`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * - Adding a 'data' event handler will trigger the flow of data
       *
       * - Adding a 'readable' event handler when there is data waiting to be read
       *   will cause 'readable' to be emitted immediately.
       *
       * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
       *   already passed will cause the event to be emitted immediately and all
       *   handlers removed.
       *
       * - Adding an 'error' event handler after an error has been emitted will
       *   cause the event to be re-emitted immediately with the error previously
       *   raised.
       */
      on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === "data") {
          this[DISCARDED] = false;
          this[DATALISTENERS]++;
          if (!this[PIPES].length && !this[FLOWING]) {
            this[RESUME]();
          }
        } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
          super.emit("readable");
        } else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          const h = handler;
          if (this[ASYNC])
            defer(() => h.call(this, this[EMITTED_ERROR]));
          else
            h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      /**
       * Alias for {@link Minipass#off}
       */
      removeListener(ev, handler) {
        return this.off(ev, handler);
      }
      /**
       * Mostly identical to `EventEmitter.off`
       *
       * If a 'data' event handler is removed, and it was the last consumer
       * (ie, there are no pipe destinations or other 'data' event listeners),
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      off(ev, handler) {
        const ret = super.off(ev, handler);
        if (ev === "data") {
          this[DATALISTENERS] = this.listeners("data").length;
          if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * Mostly identical to `EventEmitter.removeAllListeners`
       *
       * If all 'data' event handlers are removed, and they were the last consumer
       * (ie, there are no pipe destinations), then the flow of data will stop
       * until there is another consumer or {@link Minipass#resume} is explicitly
       * called.
       */
      removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === "data" || ev === void 0) {
          this[DATALISTENERS] = 0;
          if (!this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * true if the 'end' event has been emitted
       */
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      /**
       * Mostly identical to `EventEmitter.emit`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * If the stream has been destroyed, and the event is something other
       * than 'close' or 'error', then `false` is returned and no handlers
       * are called.
       *
       * If the event is 'end', and has already been emitted, then the event
       * is ignored. If the stream is in a paused or non-flowing state, then
       * the event will be deferred until data flow resumes. If the stream is
       * async, then handlers will be called on the next tick rather than
       * immediately.
       *
       * If the event is 'close', and 'end' has not yet been emitted, then
       * the event will be deferred until after 'end' is emitted.
       *
       * If the event is 'error', and an AbortSignal was provided for the stream,
       * and there are no listeners, then the event is ignored, matching the
       * behavior of node core streams in the presense of an AbortSignal.
       *
       * If the event is 'finish' or 'prefinish', then all listeners will be
       * removed after emitting the event, to prevent double-firing.
       */
      emit(ev, ...args) {
        const data = args[0];
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
          return false;
        } else if (ev === "data") {
          return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return false;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          super.emit(ERROR, data);
          const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this[PIPES]) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this[PIPES]) {
              p.dest.write(data);
            }
            if (!this[DISCARDED])
              super.emit("data", data);
          }
        }
        for (const p of this[PIPES]) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      /**
       * Return a Promise that resolves to an array of all emitted data once
       * the stream ends.
       */
      async collect() {
        const buf = Object.assign([], {
          dataLength: 0
        });
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        await p;
        return buf;
      }
      /**
       * Return a Promise that resolves to the concatenation of all emitted data
       * once the stream ends.
       *
       * Not allowed on objectMode streams.
       */
      async concat() {
        if (this[OBJECTMODE]) {
          throw new Error("cannot concat in objectMode");
        }
        const buf = await this.collect();
        return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
      }
      /**
       * Return a void Promise that resolves once the stream ends.
       */
      async promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      /**
       * Asynchronous `for await of` iteration.
       *
       * This will continue emitting all chunks until the stream terminates.
       */
      [Symbol.asyncIterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
          this.pause();
          stopped = true;
          return { value: void 0, done: true };
        };
        const next = () => {
          if (stopped)
            return stop();
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return stop();
          let resolve;
          let reject;
          const onerr = (er) => {
            this.off("data", ondata);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            stop();
            reject(er);
          };
          const ondata = (value) => {
            this.off("error", onerr);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.off("error", onerr);
            this.off("data", ondata);
            this.off(DESTROYED, ondestroy);
            stop();
            resolve({ done: true, value: void 0 });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
      /**
       * Synchronous `for of` iteration.
       *
       * The iteration will terminate when the internal buffer runs out, even
       * if the stream has not yet terminated.
       */
      [Symbol.iterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
          this.pause();
          this.off(ERROR, stop);
          this.off(DESTROYED, stop);
          this.off("end", stop);
          stopped = true;
          return { done: true, value: void 0 };
        };
        const next = () => {
          if (stopped)
            return stop();
          const value = this.read();
          return value === null ? stop() : { done: false, value };
        };
        this.once("end", stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.iterator]() {
            return this;
          }
        };
      }
      /**
       * Destroy a stream, preventing it from being used for any further purpose.
       *
       * If the stream has a `close()` method, then it will be called on
       * destruction.
       *
       * After destruction, any attempt to write data, read data, or emit most
       * events will be ignored.
       *
       * If an error argument is provided, then it will be emitted in an
       * 'error' event.
       */
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === "function" && !this[CLOSED])
          wc.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      /**
       * Alias for {@link isStream}
       *
       * Former export location, maintained for backwards compatibility.
       *
       * @deprecated
       */
      static get isStream() {
        return exports2.isStream;
      }
    };
    exports2.Minipass = Minipass;
  }
});

// node_modules/path-scurry/dist/commonjs/index.js
var require_commonjs4 = __commonJS({
  "node_modules/path-scurry/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathScurry = exports2.Path = exports2.PathScurryDarwin = exports2.PathScurryPosix = exports2.PathScurryWin32 = exports2.PathScurryBase = exports2.PathPosix = exports2.PathWin32 = exports2.PathBase = exports2.ChildrenCache = exports2.ResolveCache = void 0;
    var lru_cache_1 = require_commonjs2();
    var node_path_1 = require("node:path");
    var node_url_1 = require("node:url");
    var fs_1 = require("fs");
    var actualFS = __importStar(require("node:fs"));
    var realpathSync = fs_1.realpathSync.native;
    var promises_1 = require("node:fs/promises");
    var minipass_1 = require_commonjs3();
    var defaultFS = {
      lstatSync: fs_1.lstatSync,
      readdir: fs_1.readdir,
      readdirSync: fs_1.readdirSync,
      readlinkSync: fs_1.readlinkSync,
      realpathSync,
      promises: {
        lstat: promises_1.lstat,
        readdir: promises_1.readdir,
        readlink: promises_1.readlink,
        realpath: promises_1.realpath
      }
    };
    var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
      ...defaultFS,
      ...fsOption,
      promises: {
        ...defaultFS.promises,
        ...fsOption.promises || {}
      }
    };
    var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
    var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    var eitherSep = /[\\\/]/;
    var UNKNOWN = 0;
    var IFIFO = 1;
    var IFCHR = 2;
    var IFDIR = 4;
    var IFBLK = 6;
    var IFREG = 8;
    var IFLNK = 10;
    var IFSOCK = 12;
    var IFMT = 15;
    var IFMT_UNKNOWN = ~IFMT;
    var READDIR_CALLED = 16;
    var LSTAT_CALLED = 32;
    var ENOTDIR = 64;
    var ENOENT = 128;
    var ENOREADLINK = 256;
    var ENOREALPATH = 512;
    var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
    var TYPEMASK = 1023;
    var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
    var normalizeCache = /* @__PURE__ */ new Map();
    var normalize = (s) => {
      const c = normalizeCache.get(s);
      if (c)
        return c;
      const n = s.normalize("NFKD");
      normalizeCache.set(s, n);
      return n;
    };
    var normalizeNocaseCache = /* @__PURE__ */ new Map();
    var normalizeNocase = (s) => {
      const c = normalizeNocaseCache.get(s);
      if (c)
        return c;
      const n = normalize(s.toLowerCase());
      normalizeNocaseCache.set(s, n);
      return n;
    };
    var ResolveCache = class extends lru_cache_1.LRUCache {
      constructor() {
        super({ max: 256 });
      }
    };
    exports2.ResolveCache = ResolveCache;
    var ChildrenCache = class extends lru_cache_1.LRUCache {
      constructor(maxSize = 16 * 1024) {
        super({
          maxSize,
          // parent + children
          sizeCalculation: (a) => a.length + 1
        });
      }
    };
    exports2.ChildrenCache = ChildrenCache;
    var setAsCwd = Symbol("PathScurry setAsCwd");
    var PathBase = class {
      /**
       * the basename of this path
       *
       * **Important**: *always* test the path name against any test string
       * usingthe {@link isNamed} method, and not by directly comparing this
       * string. Otherwise, unicode path strings that the system sees as identical
       * will not be properly treated as the same path, leading to incorrect
       * behavior and possible security issues.
       */
      name;
      /**
       * the Path entry corresponding to the path root.
       *
       * @internal
       */
      root;
      /**
       * All roots found within the current PathScurry family
       *
       * @internal
       */
      roots;
      /**
       * a reference to the parent path, or undefined in the case of root entries
       *
       * @internal
       */
      parent;
      /**
       * boolean indicating whether paths are compared case-insensitively
       * @internal
       */
      nocase;
      /**
       * boolean indicating that this path is the current working directory
       * of the PathScurry collection that contains it.
       */
      isCWD = false;
      // potential default fs override
      #fs;
      // Stats fields
      #dev;
      get dev() {
        return this.#dev;
      }
      #mode;
      get mode() {
        return this.#mode;
      }
      #nlink;
      get nlink() {
        return this.#nlink;
      }
      #uid;
      get uid() {
        return this.#uid;
      }
      #gid;
      get gid() {
        return this.#gid;
      }
      #rdev;
      get rdev() {
        return this.#rdev;
      }
      #blksize;
      get blksize() {
        return this.#blksize;
      }
      #ino;
      get ino() {
        return this.#ino;
      }
      #size;
      get size() {
        return this.#size;
      }
      #blocks;
      get blocks() {
        return this.#blocks;
      }
      #atimeMs;
      get atimeMs() {
        return this.#atimeMs;
      }
      #mtimeMs;
      get mtimeMs() {
        return this.#mtimeMs;
      }
      #ctimeMs;
      get ctimeMs() {
        return this.#ctimeMs;
      }
      #birthtimeMs;
      get birthtimeMs() {
        return this.#birthtimeMs;
      }
      #atime;
      get atime() {
        return this.#atime;
      }
      #mtime;
      get mtime() {
        return this.#mtime;
      }
      #ctime;
      get ctime() {
        return this.#ctime;
      }
      #birthtime;
      get birthtime() {
        return this.#birthtime;
      }
      #matchName;
      #depth;
      #fullpath;
      #fullpathPosix;
      #relative;
      #relativePosix;
      #type;
      #children;
      #linkTarget;
      #realpath;
      /**
       * This property is for compatibility with the Dirent class as of
       * Node v20, where Dirent['parentPath'] refers to the path of the
       * directory that was passed to readdir. For root entries, it's the path
       * to the entry itself.
       */
      get parentPath() {
        return (this.parent || this).fullpath();
      }
      /**
       * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
       * this property refers to the *parent* path, not the path object itself.
       */
      get path() {
        return this.parentPath;
      }
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name2, type = UNKNOWN, root, roots, nocase, children, opts) {
        this.name = name2;
        this.#matchName = nocase ? normalizeNocase(name2) : normalize(name2);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
          this.#fs = this.parent.#fs;
        } else {
          this.#fs = fsFromOption(opts.fs);
        }
      }
      /**
       * Returns the depth of the Path object from its root.
       *
       * For example, a path at `/foo/bar` would have a depth of 2.
       */
      depth() {
        if (this.#depth !== void 0)
          return this.#depth;
        if (!this.parent)
          return this.#depth = 0;
        return this.#depth = this.parent.depth() + 1;
      }
      /**
       * @internal
       */
      childrenCache() {
        return this.#children;
      }
      /**
       * Get the Path object referenced by the string path, resolved from this Path
       */
      resolve(path2) {
        if (!path2) {
          return this;
        }
        const rootPath = this.getRootString(path2);
        const dir = path2.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
        return result;
      }
      #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts) {
          p = p.child(part);
        }
        return p;
      }
      /**
       * Returns the cached children Path objects, if still available.  If they
       * have fallen out of the cache, then returns an empty array, and resets the
       * READDIR_CALLED bit, so that future calls to readdir() will require an fs
       * lookup.
       *
       * @internal
       */
      children() {
        const cached = this.#children.get(this);
        if (cached) {
          return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        this.#children.set(this, children);
        this.#type &= ~READDIR_CALLED;
        return children;
      }
      /**
       * Resolves a path portion and returns or creates the child Path.
       *
       * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
       * `'..'`.
       *
       * This should not be called directly.  If `pathPart` contains any path
       * separators, it will lead to unsafe undefined behavior.
       *
       * Use `Path.resolve()` instead.
       *
       * @internal
       */
      child(pathPart, opts) {
        if (pathPart === "" || pathPart === ".") {
          return this;
        }
        if (pathPart === "..") {
          return this.parent || this;
        }
        const children = this.children();
        const name2 = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
        for (const p of children) {
          if (p.#matchName === name2) {
            return p;
          }
        }
        const s = this.parent ? this.sep : "";
        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
        const pchild = this.newChild(pathPart, UNKNOWN, {
          ...opts,
          parent: this,
          fullpath
        });
        if (!this.canReaddir()) {
          pchild.#type |= ENOENT;
        }
        children.push(pchild);
        return pchild;
      }
      /**
       * The relative path from the cwd. If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpath()
       */
      relative() {
        if (this.isCWD)
          return "";
        if (this.#relative !== void 0) {
          return this.#relative;
        }
        const name2 = this.name;
        const p = this.parent;
        if (!p) {
          return this.#relative = this.name;
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? "" : this.sep) + name2;
      }
      /**
       * The relative path from the cwd, using / as the path separator.
       * If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpathPosix()
       * On posix systems, this is identical to relative().
       */
      relativePosix() {
        if (this.sep === "/")
          return this.relative();
        if (this.isCWD)
          return "";
        if (this.#relativePosix !== void 0)
          return this.#relativePosix;
        const name2 = this.name;
        const p = this.parent;
        if (!p) {
          return this.#relativePosix = this.fullpathPosix();
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? "" : "/") + name2;
      }
      /**
       * The fully resolved path string for this Path entry
       */
      fullpath() {
        if (this.#fullpath !== void 0) {
          return this.#fullpath;
        }
        const name2 = this.name;
        const p = this.parent;
        if (!p) {
          return this.#fullpath = this.name;
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? "" : this.sep) + name2;
        return this.#fullpath = fp;
      }
      /**
       * On platforms other than windows, this is identical to fullpath.
       *
       * On windows, this is overridden to return the forward-slash form of the
       * full UNC path.
       */
      fullpathPosix() {
        if (this.#fullpathPosix !== void 0)
          return this.#fullpathPosix;
        if (this.sep === "/")
          return this.#fullpathPosix = this.fullpath();
        if (!this.parent) {
          const p2 = this.fullpath().replace(/\\/g, "/");
          if (/^[a-z]:\//i.test(p2)) {
            return this.#fullpathPosix = `//?/${p2}`;
          } else {
            return this.#fullpathPosix = p2;
          }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
        return this.#fullpathPosix = fpp;
      }
      /**
       * Is the Path of an unknown type?
       *
       * Note that we might know *something* about it if there has been a previous
       * filesystem operation, for example that it does not exist, or is not a
       * link, or whether it has child entries.
       */
      isUnknown() {
        return (this.#type & IFMT) === UNKNOWN;
      }
      isType(type) {
        return this[`is${type}`]();
      }
      getType() {
        return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
          /* c8 ignore start */
          this.isSocket() ? "Socket" : "Unknown"
        );
      }
      /**
       * Is the Path a regular file?
       */
      isFile() {
        return (this.#type & IFMT) === IFREG;
      }
      /**
       * Is the Path a directory?
       */
      isDirectory() {
        return (this.#type & IFMT) === IFDIR;
      }
      /**
       * Is the path a character device?
       */
      isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
      }
      /**
       * Is the path a block device?
       */
      isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
      }
      /**
       * Is the path a FIFO pipe?
       */
      isFIFO() {
        return (this.#type & IFMT) === IFIFO;
      }
      /**
       * Is the path a socket?
       */
      isSocket() {
        return (this.#type & IFMT) === IFSOCK;
      }
      /**
       * Is the path a symbolic link?
       */
      isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
      }
      /**
       * Return the entry if it has been subject of a successful lstat, or
       * undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* simply
       * mean that we haven't called lstat on it.
       */
      lstatCached() {
        return this.#type & LSTAT_CALLED ? this : void 0;
      }
      /**
       * Return the cached link target if the entry has been the subject of a
       * successful readlink, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readlink() has been called at some point.
       */
      readlinkCached() {
        return this.#linkTarget;
      }
      /**
       * Returns the cached realpath target if the entry has been the subject
       * of a successful realpath, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * realpath() has been called at some point.
       */
      realpathCached() {
        return this.#realpath;
      }
      /**
       * Returns the cached child Path entries array if the entry has been the
       * subject of a successful readdir(), or [] otherwise.
       *
       * Does not read the filesystem, so an empty array *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readdir() has been called recently enough to still be valid.
       */
      readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
      }
      /**
       * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
       * any indication that readlink will definitely fail.
       *
       * Returns false if the path is known to not be a symlink, if a previous
       * readlink failed, or if the entry does not exist.
       */
      canReadlink() {
        if (this.#linkTarget)
          return true;
        if (!this.parent)
          return false;
        const ifmt = this.#type & IFMT;
        return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
      }
      /**
       * Return true if readdir has previously been successfully called on this
       * path, indicating that cachedReaddir() is likely valid.
       */
      calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
      }
      /**
       * Returns true if the path is known to not exist. That is, a previous lstat
       * or readdir failed to verify its existence when that would have been
       * expected, or a parent entry was marked either enoent or enotdir.
       */
      isENOENT() {
        return !!(this.#type & ENOENT);
      }
      /**
       * Return true if the path is a match for the given path name.  This handles
       * case sensitivity and unicode normalization.
       *
       * Note: even on case-sensitive systems, it is **not** safe to test the
       * equality of the `.name` property to determine whether a given pathname
       * matches, due to unicode normalization mismatches.
       *
       * Always use this method instead of testing the `path.name` property
       * directly.
       */
      isNamed(n) {
        return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
      }
      /**
       * Return the Path object corresponding to the target of a symbolic link.
       *
       * If the Path is not a symbolic link, or if the readlink call fails for any
       * reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       */
      async readlink() {
        const target = this.#linkTarget;
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read = await this.#fs.promises.readlink(this.fullpath());
          const linkTarget = (await this.parent.realpath())?.resolve(read);
          if (linkTarget) {
            return this.#linkTarget = linkTarget;
          }
        } catch (er) {
          this.#readlinkFail(er.code);
          return void 0;
        }
      }
      /**
       * Synchronous {@link PathBase.readlink}
       */
      readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read = this.#fs.readlinkSync(this.fullpath());
          const linkTarget = this.parent.realpathSync()?.resolve(read);
          if (linkTarget) {
            return this.#linkTarget = linkTarget;
          }
        } catch (er) {
          this.#readlinkFail(er.code);
          return void 0;
        }
      }
      #readdirSuccess(children) {
        this.#type |= READDIR_CALLED;
        for (let p = children.provisional; p < children.length; p++) {
          const c = children[p];
          if (c)
            c.#markENOENT();
        }
      }
      #markENOENT() {
        if (this.#type & ENOENT)
          return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
      }
      #markChildrenENOENT() {
        const children = this.children();
        children.provisional = 0;
        for (const p of children) {
          p.#markENOENT();
        }
      }
      #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
      }
      // save the information when we know the entry is not a dir
      #markENOTDIR() {
        if (this.#type & ENOTDIR)
          return;
        let t = this.#type;
        if ((t & IFMT) === IFDIR)
          t &= IFMT_UNKNOWN;
        this.#type = t | ENOTDIR;
        this.#markChildrenENOENT();
      }
      #readdirFail(code = "") {
        if (code === "ENOTDIR" || code === "EPERM") {
          this.#markENOTDIR();
        } else if (code === "ENOENT") {
          this.#markENOENT();
        } else {
          this.children().provisional = 0;
        }
      }
      #lstatFail(code = "") {
        if (code === "ENOTDIR") {
          const p = this.parent;
          p.#markENOTDIR();
        } else if (code === "ENOENT") {
          this.#markENOENT();
        }
      }
      #readlinkFail(code = "") {
        let ter = this.#type;
        ter |= ENOREADLINK;
        if (code === "ENOENT")
          ter |= ENOENT;
        if (code === "EINVAL" || code === "UNKNOWN") {
          ter &= IFMT_UNKNOWN;
        }
        this.#type = ter;
        if (code === "ENOTDIR" && this.parent) {
          this.parent.#markENOTDIR();
        }
      }
      #readdirAddChild(e, c) {
        return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
      }
      #readdirAddNewChild(e, c) {
        const type = entToType(e);
        const child = this.newChild(e.name, type, { parent: this });
        const ifmt = child.#type & IFMT;
        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
          child.#type |= ENOTDIR;
        }
        c.unshift(child);
        c.provisional++;
        return child;
      }
      #readdirMaybePromoteChild(e, c) {
        for (let p = c.provisional; p < c.length; p++) {
          const pchild = c[p];
          const name2 = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
          if (name2 !== pchild.#matchName) {
            continue;
          }
          return this.#readdirPromoteChild(e, pchild, p, c);
        }
      }
      #readdirPromoteChild(e, p, index, c) {
        const v = p.name;
        p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
        if (v !== e.name)
          p.name = e.name;
        if (index !== c.provisional) {
          if (index === c.length - 1)
            c.pop();
          else
            c.splice(index, 1);
          c.unshift(p);
        }
        c.provisional++;
        return p;
      }
      /**
       * Call lstat() on this Path, and update all known information that can be
       * determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat() {
        if ((this.#type & ENOENT) === 0) {
          try {
            this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
            return this;
          } catch (er) {
            this.#lstatFail(er.code);
          }
        }
      }
      /**
       * synchronous {@link PathBase.lstat}
       */
      lstatSync() {
        if ((this.#type & ENOENT) === 0) {
          try {
            this.#applyStat(this.#fs.lstatSync(this.fullpath()));
            return this;
          } catch (er) {
            this.#lstatFail(er.code);
          }
        }
      }
      #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
          this.#type |= ENOTDIR;
        }
      }
      #onReaddirCB = [];
      #readdirCBInFlight = false;
      #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach((cb) => cb(null, children));
      }
      /**
       * Standard node-style callback interface to get list of directory entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       *
       * @param cb The callback called with (er, entries).  Note that the `er`
       * param is somewhat extraneous, as all readdir() errors are handled and
       * simply result in an empty set of entries being returned.
       * @param allowZalgo Boolean indicating that immediately known results should
       * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
       * zalgo at your peril, the dark pony lord is devious and unforgiving.
       */
      readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
          if (allowZalgo)
            cb(null, []);
          else
            queueMicrotask(() => cb(null, []));
          return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
          const c = children.slice(0, children.provisional);
          if (allowZalgo)
            cb(null, c);
          else
            queueMicrotask(() => cb(null, c));
          return;
        }
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
          return;
        }
        this.#readdirCBInFlight = true;
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
          if (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
          } else {
            for (const e of entries) {
              this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
          }
          this.#callOnReaddirCB(children.slice(0, children.provisional));
          return;
        });
      }
      #asyncReaddirInFlight;
      /**
       * Return an array of known child entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async readdir() {
        if (!this.canReaddir()) {
          return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
          return children.slice(0, children.provisional);
        }
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
          await this.#asyncReaddirInFlight;
        } else {
          let resolve = () => {
          };
          this.#asyncReaddirInFlight = new Promise((res) => resolve = res);
          try {
            for (const e of await this.#fs.promises.readdir(fullpath, {
              withFileTypes: true
            })) {
              this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
          } catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
          }
          this.#asyncReaddirInFlight = void 0;
          resolve();
        }
        return children.slice(0, children.provisional);
      }
      /**
       * synchronous {@link PathBase.readdir}
       */
      readdirSync() {
        if (!this.canReaddir()) {
          return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
          return children.slice(0, children.provisional);
        }
        const fullpath = this.fullpath();
        try {
          for (const e of this.#fs.readdirSync(fullpath, {
            withFileTypes: true
          })) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        } catch (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        }
        return children.slice(0, children.provisional);
      }
      canReaddir() {
        if (this.#type & ENOCHILD)
          return false;
        const ifmt = IFMT & this.#type;
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
          return false;
        }
        return true;
      }
      shouldWalk(dirs, walkFilter) {
        return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
      }
      /**
       * Return the Path object corresponding to path as resolved
       * by realpath(3).
       *
       * If the realpath call fails for any reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       * On success, returns a Path object.
       */
      async realpath() {
        if (this.#realpath)
          return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
          return void 0;
        try {
          const rp = await this.#fs.promises.realpath(this.fullpath());
          return this.#realpath = this.resolve(rp);
        } catch (_) {
          this.#markENOREALPATH();
        }
      }
      /**
       * Synchronous {@link realpath}
       */
      realpathSync() {
        if (this.#realpath)
          return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
          return void 0;
        try {
          const rp = this.#fs.realpathSync(this.fullpath());
          return this.#realpath = this.resolve(rp);
        } catch (_) {
          this.#markENOREALPATH();
        }
      }
      /**
       * Internal method to mark this Path object as the scurry cwd,
       * called by {@link PathScurry#chdir}
       *
       * @internal
       */
      [setAsCwd](oldCwd) {
        if (oldCwd === this)
          return;
        oldCwd.isCWD = false;
        this.isCWD = true;
        const changed = /* @__PURE__ */ new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
          changed.add(p);
          p.#relative = rp.join(this.sep);
          p.#relativePosix = rp.join("/");
          p = p.parent;
          rp.push("..");
        }
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
          p.#relative = void 0;
          p.#relativePosix = void 0;
          p = p.parent;
        }
      }
    };
    exports2.PathBase = PathBase;
    var PathWin32 = class _PathWin32 extends PathBase {
      /**
       * Separator for generating path strings.
       */
      sep = "\\";
      /**
       * Separator for parsing path strings.
       */
      splitSep = eitherSep;
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name2, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name2, type, root, roots, nocase, children, opts);
      }
      /**
       * @internal
       */
      newChild(name2, type = UNKNOWN, opts = {}) {
        return new _PathWin32(name2, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
      /**
       * @internal
       */
      getRootString(path2) {
        return node_path_1.win32.parse(path2).root;
      }
      /**
       * @internal
       */
      getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
          return this.root;
        }
        for (const [compare2, root] of Object.entries(this.roots)) {
          if (this.sameRoot(rootPath, compare2)) {
            return this.roots[rootPath] = root;
          }
        }
        return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
      }
      /**
       * @internal
       */
      sameRoot(rootPath, compare2 = this.root.name) {
        rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
        return rootPath === compare2;
      }
    };
    exports2.PathWin32 = PathWin32;
    var PathPosix = class _PathPosix extends PathBase {
      /**
       * separator for parsing path strings
       */
      splitSep = "/";
      /**
       * separator for generating path strings
       */
      sep = "/";
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name2, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name2, type, root, roots, nocase, children, opts);
      }
      /**
       * @internal
       */
      getRootString(path2) {
        return path2.startsWith("/") ? "/" : "";
      }
      /**
       * @internal
       */
      getRoot(_rootPath) {
        return this.root;
      }
      /**
       * @internal
       */
      newChild(name2, type = UNKNOWN, opts = {}) {
        return new _PathPosix(name2, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
    };
    exports2.PathPosix = PathPosix;
    var PathScurryBase = class {
      /**
       * The root Path entry for the current working directory of this Scurry
       */
      root;
      /**
       * The string path for the root of this Scurry's current working directory
       */
      rootPath;
      /**
       * A collection of all roots encountered, referenced by rootPath
       */
      roots;
      /**
       * The Path entry corresponding to this PathScurry's current working directory.
       */
      cwd;
      #resolveCache;
      #resolvePosixCache;
      #children;
      /**
       * Perform path comparisons case-insensitively.
       *
       * Defaults true on Darwin and Windows systems, false elsewhere.
       */
      nocase;
      #fs;
      /**
       * This class should not be instantiated directly.
       *
       * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
       *
       * @internal
       */
      constructor(cwd2 = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs: fs2 = defaultFS } = {}) {
        this.#fs = fsFromOption(fs2);
        if (cwd2 instanceof URL || cwd2.startsWith("file://")) {
          cwd2 = (0, node_url_1.fileURLToPath)(cwd2);
        }
        const cwdPath = pathImpl.resolve(cwd2);
        this.roots = /* @__PURE__ */ Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        if (split.length === 1 && !split[0]) {
          split.pop();
        }
        if (nocase === void 0) {
          throw new TypeError("must provide nocase setting to PathScurryBase ctor");
        }
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
          const l = len--;
          prev = prev.child(part, {
            relative: new Array(l).fill("..").join(joinSep),
            relativePosix: new Array(l).fill("..").join("/"),
            fullpath: abs += (sawFirst ? "" : joinSep) + part
          });
          sawFirst = true;
        }
        this.cwd = prev;
      }
      /**
       * Get the depth of a provided path, string, or the cwd
       */
      depth(path2 = this.cwd) {
        if (typeof path2 === "string") {
          path2 = this.cwd.resolve(path2);
        }
        return path2.depth();
      }
      /**
       * Return the cache of child entries.  Exposed so subclasses can create
       * child Path objects in a platform-specific way.
       *
       * @internal
       */
      childrenCache() {
        return this.#children;
      }
      /**
       * Resolve one or more path strings to a resolved string
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolve(...paths) {
        let r = "";
        for (let i = paths.length - 1; i >= 0; i--) {
          const p = paths[i];
          if (!p || p === ".")
            continue;
          r = r ? `${p}/${r}` : p;
          if (this.isAbsolute(p)) {
            break;
          }
        }
        const cached = this.#resolveCache.get(r);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        this.#resolveCache.set(r, result);
        return result;
      }
      /**
       * Resolve one or more path strings to a resolved string, returning
       * the posix path.  Identical to .resolve() on posix systems, but on
       * windows will return a forward-slash separated UNC path.
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolvePosix(...paths) {
        let r = "";
        for (let i = paths.length - 1; i >= 0; i--) {
          const p = paths[i];
          if (!p || p === ".")
            continue;
          r = r ? `${p}/${r}` : p;
          if (this.isAbsolute(p)) {
            break;
          }
        }
        const cached = this.#resolvePosixCache.get(r);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r).fullpathPosix();
        this.#resolvePosixCache.set(r, result);
        return result;
      }
      /**
       * find the relative path from the cwd to the supplied path string or entry
       */
      relative(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.relative();
      }
      /**
       * find the relative path from the cwd to the supplied path string or
       * entry, using / as the path delimiter, even on Windows.
       */
      relativePosix(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.relativePosix();
      }
      /**
       * Return the basename for the provided string or Path object
       */
      basename(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.name;
      }
      /**
       * Return the dirname for the provided string or Path object
       */
      dirname(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return (entry.parent || entry).fullpath();
      }
      async readdir(entry = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes } = opts;
        if (!entry.canReaddir()) {
          return [];
        } else {
          const p = await entry.readdir();
          return withFileTypes ? p : p.map((e) => e.name);
        }
      }
      readdirSync(entry = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true } = opts;
        if (!entry.canReaddir()) {
          return [];
        } else if (withFileTypes) {
          return entry.readdirSync();
        } else {
          return entry.readdirSync().map((e) => e.name);
        }
      }
      /**
       * Call lstat() on the string or Path object, and update all known
       * information that can be determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.lstat();
      }
      /**
       * synchronous {@link PathScurryBase.lstat}
       */
      lstatSync(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.lstatSync();
      }
      async readlink(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = await entry.readlink();
        return withFileTypes ? e : e?.fullpath();
      }
      readlinkSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = entry.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
      }
      async realpath(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = await entry.realpath();
        return withFileTypes ? e : e?.fullpath();
      }
      realpathSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = entry.realpathSync();
        return withFileTypes ? e : e?.fullpath();
      }
      async walk(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        const results = [];
        if (!filter2 || filter2(entry)) {
          results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const walk2 = (dir, cb) => {
          dirs.add(dir);
          dir.readdirCB((er, entries) => {
            if (er) {
              return cb(er);
            }
            let len = entries.length;
            if (!len)
              return cb();
            const next = () => {
              if (--len === 0) {
                cb();
              }
            };
            for (const e of entries) {
              if (!filter2 || filter2(e)) {
                results.push(withFileTypes ? e : e.fullpath());
              }
              if (follow && e.isSymbolicLink()) {
                e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk2(r, next) : next());
              } else {
                if (e.shouldWalk(dirs, walkFilter)) {
                  walk2(e, next);
                } else {
                  next();
                }
              }
            }
          }, true);
        };
        const start = entry;
        return new Promise((res, rej) => {
          walk2(start, (er) => {
            if (er)
              return rej(er);
            res(results);
          });
        });
      }
      walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        const results = [];
        if (!filter2 || filter2(entry)) {
          results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set([entry]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter2 || filter2(e)) {
              results.push(withFileTypes ? e : e.fullpath());
            }
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              dirs.add(r);
            }
          }
        }
        return results;
      }
      /**
       * Support for `for await`
       *
       * Alias for {@link PathScurryBase.iterate}
       *
       * Note: As of Node 19, this is very slow, compared to other methods of
       * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
       * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
       */
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
      iterate(entry = this.cwd, options2 = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          options2 = entry;
          entry = this.cwd;
        }
        return this.stream(entry, options2)[Symbol.asyncIterator]();
      }
      /**
       * Iterating over a PathScurry performs a synchronous walk.
       *
       * Alias for {@link PathScurryBase.iterateSync}
       */
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        if (!filter2 || filter2(entry)) {
          yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = /* @__PURE__ */ new Set([entry]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter2 || filter2(e)) {
              yield withFileTypes ? e : e.fullpath();
            }
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              dirs.add(r);
            }
          }
        }
      }
      stream(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        const results = new minipass_1.Minipass({ objectMode: true });
        if (!filter2 || filter2(entry)) {
          results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const queue = [entry];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const onReaddir = (er, entries, didRealpaths = false) => {
              if (er)
                return results.emit("error", er);
              if (follow && !didRealpaths) {
                const promises = [];
                for (const e of entries) {
                  if (e.isSymbolicLink()) {
                    promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
                  }
                }
                if (promises.length) {
                  Promise.all(promises).then(() => onReaddir(null, entries, true));
                  return;
                }
              }
              for (const e of entries) {
                if (e && (!filter2 || filter2(e))) {
                  if (!results.write(withFileTypes ? e : e.fullpath())) {
                    paused = true;
                  }
                }
              }
              processing--;
              for (const e of entries) {
                const r = e.realpathCached() || e;
                if (r.shouldWalk(dirs, walkFilter)) {
                  queue.push(r);
                }
              }
              if (paused && !results.flowing) {
                results.once("drain", process2);
              } else if (!sync) {
                process2();
              }
            };
            let sync = true;
            dir.readdirCB(onReaddir, true);
            sync = false;
          }
        };
        process2();
        return results;
      }
      streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        const results = new minipass_1.Minipass({ objectMode: true });
        const dirs = /* @__PURE__ */ new Set();
        if (!filter2 || filter2(entry)) {
          results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [entry];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const entries = dir.readdirSync();
            for (const e of entries) {
              if (!filter2 || filter2(e)) {
                if (!results.write(withFileTypes ? e : e.fullpath())) {
                  paused = true;
                }
              }
            }
            processing--;
            for (const e of entries) {
              let r = e;
              if (e.isSymbolicLink()) {
                if (!(follow && (r = e.realpathSync())))
                  continue;
                if (r.isUnknown())
                  r.lstatSync();
              }
              if (r.shouldWalk(dirs, walkFilter)) {
                queue.push(r);
              }
            }
          }
          if (paused && !results.flowing)
            results.once("drain", process2);
        };
        process2();
        return results;
      }
      chdir(path2 = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path2 === "string" ? this.cwd.resolve(path2) : path2;
        this.cwd[setAsCwd](oldCwd);
      }
    };
    exports2.PathScurryBase = PathScurryBase;
    var PathScurryWin32 = class extends PathScurryBase {
      /**
       * separator for generating path strings
       */
      sep = "\\";
      constructor(cwd2 = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd2, node_path_1.win32, "\\", { ...opts, nocase });
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
          p.nocase = this.nocase;
        }
      }
      /**
       * @internal
       */
      parseRootPath(dir) {
        return node_path_1.win32.parse(dir).root.toUpperCase();
      }
      /**
       * @internal
       */
      newRoot(fs2) {
        return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs2 });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p) {
        return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
      }
    };
    exports2.PathScurryWin32 = PathScurryWin32;
    var PathScurryPosix = class extends PathScurryBase {
      /**
       * separator for generating path strings
       */
      sep = "/";
      constructor(cwd2 = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd2, node_path_1.posix, "/", { ...opts, nocase });
        this.nocase = nocase;
      }
      /**
       * @internal
       */
      parseRootPath(_dir) {
        return "/";
      }
      /**
       * @internal
       */
      newRoot(fs2) {
        return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs2 });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p) {
        return p.startsWith("/");
      }
    };
    exports2.PathScurryPosix = PathScurryPosix;
    var PathScurryDarwin = class extends PathScurryPosix {
      constructor(cwd2 = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd2, { ...opts, nocase });
      }
    };
    exports2.PathScurryDarwin = PathScurryDarwin;
    exports2.Path = process.platform === "win32" ? PathWin32 : PathPosix;
    exports2.PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;
  }
});

// node_modules/glob/dist/commonjs/pattern.js
var require_pattern = __commonJS({
  "node_modules/glob/dist/commonjs/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Pattern = void 0;
    var minimatch_1 = require_commonjs();
    var isPatternList = (pl) => pl.length >= 1;
    var isGlobList = (gl) => gl.length >= 1;
    var Pattern = class _Pattern {
      #patternList;
      #globList;
      #index;
      length;
      #platform;
      #rest;
      #globString;
      #isDrive;
      #isUNC;
      #isAbsolute;
      #followGlobstar = true;
      constructor(patternList, globList, index, platform2) {
        if (!isPatternList(patternList)) {
          throw new TypeError("empty pattern list");
        }
        if (!isGlobList(globList)) {
          throw new TypeError("empty glob list");
        }
        if (globList.length !== patternList.length) {
          throw new TypeError("mismatched pattern list and glob list lengths");
        }
        this.length = patternList.length;
        if (index < 0 || index >= this.length) {
          throw new TypeError("index out of range");
        }
        this.#patternList = patternList;
        this.#globList = globList;
        this.#index = index;
        this.#platform = platform2;
        if (this.#index === 0) {
          if (this.isUNC()) {
            const [p0, p1, p2, p3, ...prest] = this.#patternList;
            const [g0, g1, g2, g3, ...grest] = this.#globList;
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p = [p0, p1, p2, p3, ""].join("/");
            const g = [g0, g1, g2, g3, ""].join("/");
            this.#patternList = [p, ...prest];
            this.#globList = [g, ...grest];
            this.length = this.#patternList.length;
          } else if (this.isDrive() || this.isAbsolute()) {
            const [p1, ...prest] = this.#patternList;
            const [g1, ...grest] = this.#globList;
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p = p1 + "/";
            const g = g1 + "/";
            this.#patternList = [p, ...prest];
            this.#globList = [g, ...grest];
            this.length = this.#patternList.length;
          }
        }
      }
      /**
       * The first entry in the parsed list of patterns
       */
      pattern() {
        return this.#patternList[this.#index];
      }
      /**
       * true of if pattern() returns a string
       */
      isString() {
        return typeof this.#patternList[this.#index] === "string";
      }
      /**
       * true of if pattern() returns GLOBSTAR
       */
      isGlobstar() {
        return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;
      }
      /**
       * true if pattern() returns a regexp
       */
      isRegExp() {
        return this.#patternList[this.#index] instanceof RegExp;
      }
      /**
       * The /-joined set of glob parts that make up this pattern
       */
      globString() {
        return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
      }
      /**
       * true if there are more pattern parts after this one
       */
      hasMore() {
        return this.length > this.#index + 1;
      }
      /**
       * The rest of the pattern after this part, or null if this is the end
       */
      rest() {
        if (this.#rest !== void 0)
          return this.#rest;
        if (!this.hasMore())
          return this.#rest = null;
        this.#rest = new _Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
        this.#rest.#isAbsolute = this.#isAbsolute;
        this.#rest.#isUNC = this.#isUNC;
        this.#rest.#isDrive = this.#isDrive;
        return this.#rest;
      }
      /**
       * true if the pattern represents a //unc/path/ on windows
       */
      isUNC() {
        const pl = this.#patternList;
        return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
      }
      // pattern like C:/...
      // split = ['C:', ...]
      // XXX: would be nice to handle patterns like `c:*` to test the cwd
      // in c: for *, but I don't know of a way to even figure out what that
      // cwd is without actually chdir'ing into it?
      /**
       * True if the pattern starts with a drive letter on Windows
       */
      isDrive() {
        const pl = this.#patternList;
        return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
      }
      // pattern = '/' or '/...' or '/x/...'
      // split = ['', ''] or ['', ...] or ['', 'x', ...]
      // Drive and UNC both considered absolute on windows
      /**
       * True if the pattern is rooted on an absolute path
       */
      isAbsolute() {
        const pl = this.#patternList;
        return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
      }
      /**
       * consume the root of the pattern, and return it
       */
      root() {
        const p = this.#patternList[0];
        return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
      }
      /**
       * Check to see if the current globstar pattern is allowed to follow
       * a symbolic link.
       */
      checkFollowGlobstar() {
        return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
      }
      /**
       * Mark that the current globstar pattern is following a symbolic link
       */
      markFollowGlobstar() {
        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
          return false;
        this.#followGlobstar = false;
        return true;
      }
    };
    exports2.Pattern = Pattern;
  }
});

// node_modules/glob/dist/commonjs/ignore.js
var require_ignore = __commonJS({
  "node_modules/glob/dist/commonjs/ignore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Ignore = void 0;
    var minimatch_1 = require_commonjs();
    var pattern_js_1 = require_pattern();
    var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    var Ignore = class {
      relative;
      relativeChildren;
      absolute;
      absoluteChildren;
      constructor(ignored, { nobrace, nocase, noext, noglobstar, platform: platform2 = defaultPlatform }) {
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        const mmopts = {
          dot: true,
          nobrace,
          nocase,
          noext,
          noglobstar,
          optimizationLevel: 2,
          platform: platform2,
          nocomment: true,
          nonegate: true
        };
        for (const ign of ignored) {
          const mm = new minimatch_1.Minimatch(ign, mmopts);
          for (let i = 0; i < mm.set.length; i++) {
            const parsed = mm.set[i];
            const globParts = mm.globParts[i];
            if (!parsed || !globParts) {
              throw new Error("invalid pattern object");
            }
            while (parsed[0] === "." && globParts[0] === ".") {
              parsed.shift();
              globParts.shift();
            }
            const p = new pattern_js_1.Pattern(parsed, globParts, 0, platform2);
            const m = new minimatch_1.Minimatch(p.globString(), mmopts);
            const children = globParts[globParts.length - 1] === "**";
            const absolute = p.isAbsolute();
            if (absolute)
              this.absolute.push(m);
            else
              this.relative.push(m);
            if (children) {
              if (absolute)
                this.absoluteChildren.push(m);
              else
                this.relativeChildren.push(m);
            }
          }
        }
      }
      ignored(p) {
        const fullpath = p.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative = p.relative() || ".";
        const relatives = `${relative}/`;
        for (const m of this.relative) {
          if (m.match(relative) || m.match(relatives))
            return true;
        }
        for (const m of this.absolute) {
          if (m.match(fullpath) || m.match(fullpaths))
            return true;
        }
        return false;
      }
      childrenIgnored(p) {
        const fullpath = p.fullpath() + "/";
        const relative = (p.relative() || ".") + "/";
        for (const m of this.relativeChildren) {
          if (m.match(relative))
            return true;
        }
        for (const m of this.absoluteChildren) {
          if (m.match(fullpath))
            return true;
        }
        return false;
      }
    };
    exports2.Ignore = Ignore;
  }
});

// node_modules/glob/dist/commonjs/processor.js
var require_processor = __commonJS({
  "node_modules/glob/dist/commonjs/processor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Processor = exports2.SubWalks = exports2.MatchRecord = exports2.HasWalkedCache = void 0;
    var minimatch_1 = require_commonjs();
    var HasWalkedCache = class _HasWalkedCache {
      store;
      constructor(store = /* @__PURE__ */ new Map()) {
        this.store = store;
      }
      copy() {
        return new _HasWalkedCache(new Map(this.store));
      }
      hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
      }
      storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
          cached.add(pattern.globString());
        else
          this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
      }
    };
    exports2.HasWalkedCache = HasWalkedCache;
    var MatchRecord = class {
      store = /* @__PURE__ */ new Map();
      add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === void 0 ? n : n & current);
      }
      // match, absolute, ifdir
      entries() {
        return [...this.store.entries()].map(([path2, n]) => [
          path2,
          !!(n & 2),
          !!(n & 1)
        ]);
      }
    };
    exports2.MatchRecord = MatchRecord;
    var SubWalks = class {
      store = /* @__PURE__ */ new Map();
      add(target, pattern) {
        if (!target.canReaddir()) {
          return;
        }
        const subs = this.store.get(target);
        if (subs) {
          if (!subs.find((p) => p.globString() === pattern.globString())) {
            subs.push(pattern);
          }
        } else
          this.store.set(target, [pattern]);
      }
      get(target) {
        const subs = this.store.get(target);
        if (!subs) {
          throw new Error("attempting to walk unknown path");
        }
        return subs;
      }
      entries() {
        return this.keys().map((k) => [k, this.store.get(k)]);
      }
      keys() {
        return [...this.store.keys()].filter((t) => t.canReaddir());
      }
    };
    exports2.SubWalks = SubWalks;
    var Processor = class _Processor {
      hasWalkedCache;
      matches = new MatchRecord();
      subwalks = new SubWalks();
      patterns;
      follow;
      dot;
      opts;
      constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
      }
      processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map((p) => [target, p]);
        for (let [t, pattern] of processingSet) {
          this.hasWalkedCache.storeWalked(t, pattern);
          const root = pattern.root();
          const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
          if (root) {
            t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
            const rest2 = pattern.rest();
            if (!rest2) {
              this.matches.add(t, true, false);
              continue;
            } else {
              pattern = rest2;
            }
          }
          if (t.isENOENT())
            continue;
          let p;
          let rest;
          let changed = false;
          while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
            const c = t.resolve(p);
            t = c;
            pattern = rest;
            changed = true;
          }
          p = pattern.pattern();
          rest = pattern.rest();
          if (changed) {
            if (this.hasWalkedCache.hasWalked(t, pattern))
              continue;
            this.hasWalkedCache.storeWalked(t, pattern);
          }
          if (typeof p === "string") {
            const ifDir = p === ".." || p === "" || p === ".";
            this.matches.add(t.resolve(p), absolute, ifDir);
            continue;
          } else if (p === minimatch_1.GLOBSTAR) {
            if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
              this.subwalks.add(t, pattern);
            }
            const rp = rest?.pattern();
            const rrest = rest?.rest();
            if (!rest || (rp === "" || rp === ".") && !rrest) {
              this.matches.add(t, absolute, rp === "" || rp === ".");
            } else {
              if (rp === "..") {
                const tp = t.parent || t;
                if (!rrest)
                  this.matches.add(tp, absolute, true);
                else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                  this.subwalks.add(tp, rrest);
                }
              }
            }
          } else if (p instanceof RegExp) {
            this.subwalks.add(t, pattern);
          }
        }
        return this;
      }
      subwalkTargets() {
        return this.subwalks.keys();
      }
      child() {
        return new _Processor(this.opts, this.hasWalkedCache);
      }
      // return a new Processor containing the subwalks for each
      // child entry, and a set of matches, and
      // a hasWalkedCache that's a copy of this one
      // then we're going to call
      filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        const results = this.child();
        for (const e of entries) {
          for (const pattern of patterns) {
            const absolute = pattern.isAbsolute();
            const p = pattern.pattern();
            const rest = pattern.rest();
            if (p === minimatch_1.GLOBSTAR) {
              results.testGlobstar(e, pattern, rest, absolute);
            } else if (p instanceof RegExp) {
              results.testRegExp(e, p, rest, absolute);
            } else {
              results.testString(e, p, rest, absolute);
            }
          }
        }
        return results;
      }
      testGlobstar(e, pattern, rest, absolute) {
        if (this.dot || !e.name.startsWith(".")) {
          if (!pattern.hasMore()) {
            this.matches.add(e, absolute, false);
          }
          if (e.canReaddir()) {
            if (this.follow || !e.isSymbolicLink()) {
              this.subwalks.add(e, pattern);
            } else if (e.isSymbolicLink()) {
              if (rest && pattern.checkFollowGlobstar()) {
                this.subwalks.add(e, rest);
              } else if (pattern.markFollowGlobstar()) {
                this.subwalks.add(e, pattern);
              }
            }
          }
        }
        if (rest) {
          const rp = rest.pattern();
          if (typeof rp === "string" && // dots and empty were handled already
          rp !== ".." && rp !== "" && rp !== ".") {
            this.testString(e, rp, rest.rest(), absolute);
          } else if (rp === "..") {
            const ep = e.parent || e;
            this.subwalks.add(ep, rest);
          } else if (rp instanceof RegExp) {
            this.testRegExp(e, rp, rest.rest(), absolute);
          }
        }
      }
      testRegExp(e, p, rest, absolute) {
        if (!p.test(e.name))
          return;
        if (!rest) {
          this.matches.add(e, absolute, false);
        } else {
          this.subwalks.add(e, rest);
        }
      }
      testString(e, p, rest, absolute) {
        if (!e.isNamed(p))
          return;
        if (!rest) {
          this.matches.add(e, absolute, false);
        } else {
          this.subwalks.add(e, rest);
        }
      }
    };
    exports2.Processor = Processor;
  }
});

// node_modules/glob/dist/commonjs/walker.js
var require_walker = __commonJS({
  "node_modules/glob/dist/commonjs/walker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GlobStream = exports2.GlobWalker = exports2.GlobUtil = void 0;
    var minipass_1 = require_commonjs3();
    var ignore_js_1 = require_ignore();
    var processor_js_1 = require_processor();
    var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new ignore_js_1.Ignore([ignore], opts) : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts) : ignore;
    var GlobUtil = class {
      path;
      patterns;
      opts;
      seen = /* @__PURE__ */ new Set();
      paused = false;
      aborted = false;
      #onResume = [];
      #ignore;
      #sep;
      signal;
      maxDepth;
      constructor(patterns, path2, opts) {
        this.patterns = patterns;
        this.path = path2;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
        if (opts.ignore) {
          this.#ignore = makeIgnore(opts.ignore, opts);
        }
        this.maxDepth = opts.maxDepth || Infinity;
        if (opts.signal) {
          this.signal = opts.signal;
          this.signal.addEventListener("abort", () => {
            this.#onResume.length = 0;
          });
        }
      }
      #ignored(path2) {
        return this.seen.has(path2) || !!this.#ignore?.ignored?.(path2);
      }
      #childrenIgnored(path2) {
        return !!this.#ignore?.childrenIgnored?.(path2);
      }
      // backpressure mechanism
      pause() {
        this.paused = true;
      }
      resume() {
        if (this.signal?.aborted)
          return;
        this.paused = false;
        let fn = void 0;
        while (!this.paused && (fn = this.#onResume.shift())) {
          fn();
        }
      }
      onResume(fn) {
        if (this.signal?.aborted)
          return;
        if (!this.paused) {
          fn();
        } else {
          this.#onResume.push(fn);
        }
      }
      // do the requisite realpath/stat checking, and return the path
      // to add or undefined to filter it out.
      async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e.realpathCached() || await e.realpath();
          if (!rpc)
            return void 0;
          e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
          const target = await s.realpath();
          if (target && (target.isUnknown() || this.opts.stat)) {
            await target.lstat();
          }
        }
        return this.matchCheckTest(s, ifDir);
      }
      matchCheckTest(e, ifDir) {
        return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
      }
      matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e.realpathCached() || e.realpathSync();
          if (!rpc)
            return void 0;
          e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
          const target = s.realpathSync();
          if (target && (target?.isUnknown() || this.opts.stat)) {
            target.lstatSync();
          }
        }
        return this.matchCheckTest(s, ifDir);
      }
      matchFinish(e, absolute) {
        if (this.#ignored(e))
          return;
        const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
        if (this.opts.withFileTypes) {
          this.matchEmit(e);
        } else if (abs) {
          const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
          this.matchEmit(abs2 + mark);
        } else {
          const rel = this.opts.posix ? e.relativePosix() : e.relative();
          const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
          this.matchEmit(!rel ? "." + mark : pre + rel + mark);
        }
      }
      async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
          this.matchFinish(p, absolute);
      }
      matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
          this.matchFinish(p, absolute);
      }
      walkCB(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);
      }
      walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2(target, patterns, processor, cb));
          return;
        }
        processor.processPatterns(target, patterns);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          tasks++;
          this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks++;
          const childrenCached = t.readdirCached();
          if (t.calledReaddir())
            this.walkCB3(t, childrenCached, processor, next);
          else {
            t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
          }
        }
        next();
      }
      walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          tasks++;
          this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target2, patterns] of processor.subwalks.entries()) {
          tasks++;
          this.walkCB2(target2, patterns, processor.child(), next);
        }
        next();
      }
      walkCBSync(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);
      }
      walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
          return;
        }
        processor.processPatterns(target, patterns);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          this.matchSync(m, absolute, ifDir);
        }
        for (const t of processor.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks++;
          const children = t.readdirSync();
          this.walkCB3Sync(t, children, processor, next);
        }
        next();
      }
      walkCB3Sync(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          this.matchSync(m, absolute, ifDir);
        }
        for (const [target2, patterns] of processor.subwalks.entries()) {
          tasks++;
          this.walkCB2Sync(target2, patterns, processor.child(), next);
        }
        next();
      }
    };
    exports2.GlobUtil = GlobUtil;
    var GlobWalker = class extends GlobUtil {
      matches;
      constructor(patterns, path2, opts) {
        super(patterns, path2, opts);
        this.matches = /* @__PURE__ */ new Set();
      }
      matchEmit(e) {
        this.matches.add(e);
      }
      async walk() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          await this.path.lstat();
        }
        await new Promise((res, rej) => {
          this.walkCB(this.path, this.patterns, () => {
            if (this.signal?.aborted) {
              rej(this.signal.reason);
            } else {
              res(this.matches);
            }
          });
        });
        return this.matches;
      }
      walkSync() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => {
          if (this.signal?.aborted)
            throw this.signal.reason;
        });
        return this.matches;
      }
    };
    exports2.GlobWalker = GlobWalker;
    var GlobStream = class extends GlobUtil {
      results;
      constructor(patterns, path2, opts) {
        super(patterns, path2, opts);
        this.results = new minipass_1.Minipass({
          signal: this.signal,
          objectMode: true
        });
        this.results.on("drain", () => this.resume());
        this.results.on("resume", () => this.resume());
      }
      matchEmit(e) {
        this.results.write(e);
        if (!this.results.flowing)
          this.pause();
      }
      stream() {
        const target = this.path;
        if (target.isUnknown()) {
          target.lstat().then(() => {
            this.walkCB(target, this.patterns, () => this.results.end());
          });
        } else {
          this.walkCB(target, this.patterns, () => this.results.end());
        }
        return this.results;
      }
      streamSync() {
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => this.results.end());
        return this.results;
      }
    };
    exports2.GlobStream = GlobStream;
  }
});

// node_modules/glob/dist/commonjs/glob.js
var require_glob = __commonJS({
  "node_modules/glob/dist/commonjs/glob.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Glob = void 0;
    var minimatch_1 = require_commonjs();
    var path_scurry_1 = require_commonjs4();
    var node_url_1 = require("node:url");
    var pattern_js_1 = require_pattern();
    var walker_js_1 = require_walker();
    var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    var Glob = class {
      absolute;
      cwd;
      root;
      dot;
      dotRelative;
      follow;
      ignore;
      magicalBraces;
      mark;
      matchBase;
      maxDepth;
      nobrace;
      nocase;
      nodir;
      noext;
      noglobstar;
      pattern;
      platform;
      realpath;
      scurry;
      stat;
      signal;
      windowsPathsNoEscape;
      withFileTypes;
      /**
       * The options provided to the constructor.
       */
      opts;
      /**
       * An array of parsed immutable {@link Pattern} objects.
       */
      patterns;
      /**
       * All options are stored as properties on the `Glob` object.
       *
       * See {@link GlobOptions} for full options descriptions.
       *
       * Note that a previous `Glob` object can be passed as the
       * `GlobOptions` to another `Glob` instantiation to re-use settings
       * and caches with a new pattern.
       *
       * Traversal functions can be called multiple times to run the walk
       * again.
       */
      constructor(pattern, opts) {
        if (!opts)
          throw new TypeError("glob options required");
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
          this.cwd = "";
        } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
          opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);
        }
        this.cwd = opts.cwd || "";
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== void 0) {
          throw new Error("cannot set absolute and withFileTypes:true");
        }
        if (typeof pattern === "string") {
          pattern = [pattern];
        }
        this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          pattern = pattern.map((p) => p.replace(/\\/g, "/"));
        }
        if (this.matchBase) {
          if (opts.noglobstar) {
            throw new TypeError("base matching requires globstar");
          }
          pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
        }
        this.pattern = pattern;
        this.platform = opts.platform || defaultPlatform;
        this.opts = { ...opts, platform: this.platform };
        if (opts.scurry) {
          this.scurry = opts.scurry;
          if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
            throw new Error("nocase option contradicts provided scurry option");
          }
        } else {
          const Scurry = opts.platform === "win32" ? path_scurry_1.PathScurryWin32 : opts.platform === "darwin" ? path_scurry_1.PathScurryDarwin : opts.platform ? path_scurry_1.PathScurryPosix : path_scurry_1.PathScurry;
          this.scurry = new Scurry(this.cwd, {
            nocase: opts.nocase,
            fs: opts.fs
          });
        }
        this.nocase = this.scurry.nocase;
        const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
        const mmo = {
          // default nocase based on platform
          ...opts,
          dot: this.dot,
          matchBase: this.matchBase,
          nobrace: this.nobrace,
          nocase: this.nocase,
          nocaseMagicOnly,
          nocomment: true,
          noext: this.noext,
          nonegate: true,
          optimizationLevel: 2,
          platform: this.platform,
          windowsPathsNoEscape: this.windowsPathsNoEscape,
          debug: !!this.opts.debug
        };
        const mms = this.pattern.map((p) => new minimatch_1.Minimatch(p, mmo));
        const [matchSet, globParts] = mms.reduce((set, m) => {
          set[0].push(...m.set);
          set[1].push(...m.globParts);
          return set;
        }, [[], []]);
        this.patterns = matchSet.map((set, i) => {
          const g = globParts[i];
          if (!g)
            throw new Error("invalid pattern object");
          return new pattern_js_1.Pattern(set, g, 0, this.platform);
        });
      }
      async walk() {
        return [
          ...await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase
          }).walk()
        ];
      }
      walkSync() {
        return [
          ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase
          }).walkSync()
        ];
      }
      stream() {
        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase
        }).stream();
      }
      streamSync() {
        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase
        }).streamSync();
      }
      /**
       * Default sync iteration function. Returns a Generator that
       * iterates over the results.
       */
      iterateSync() {
        return this.streamSync()[Symbol.iterator]();
      }
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      /**
       * Default async iteration function. Returns an AsyncGenerator that
       * iterates over the results.
       */
      iterate() {
        return this.stream()[Symbol.asyncIterator]();
      }
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
    };
    exports2.Glob = Glob;
  }
});

// node_modules/glob/dist/commonjs/has-magic.js
var require_has_magic = __commonJS({
  "node_modules/glob/dist/commonjs/has-magic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasMagic = void 0;
    var minimatch_1 = require_commonjs();
    var hasMagic = (pattern, options2 = {}) => {
      if (!Array.isArray(pattern)) {
        pattern = [pattern];
      }
      for (const p of pattern) {
        if (new minimatch_1.Minimatch(p, options2).hasMagic())
          return true;
      }
      return false;
    };
    exports2.hasMagic = hasMagic;
  }
});

// node_modules/glob/dist/commonjs/index.js
var require_commonjs5 = __commonJS({
  "node_modules/glob/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.glob = exports2.hasMagic = exports2.Glob = exports2.unescape = exports2.escape = exports2.sync = exports2.iterate = exports2.iterateSync = exports2.stream = exports2.streamSync = exports2.globIterate = exports2.globIterateSync = exports2.globSync = exports2.globStream = exports2.globStreamSync = void 0;
    var minimatch_1 = require_commonjs();
    var glob_js_1 = require_glob();
    var has_magic_js_1 = require_has_magic();
    function globStreamSync(pattern, options2 = {}) {
      return new glob_js_1.Glob(pattern, options2).streamSync();
    }
    exports2.globStreamSync = globStreamSync;
    function globStream(pattern, options2 = {}) {
      return new glob_js_1.Glob(pattern, options2).stream();
    }
    exports2.globStream = globStream;
    function globSync(pattern, options2 = {}) {
      return new glob_js_1.Glob(pattern, options2).walkSync();
    }
    exports2.globSync = globSync;
    async function glob_(pattern, options2 = {}) {
      return new glob_js_1.Glob(pattern, options2).walk();
    }
    function globIterateSync(pattern, options2 = {}) {
      return new glob_js_1.Glob(pattern, options2).iterateSync();
    }
    exports2.globIterateSync = globIterateSync;
    function globIterate(pattern, options2 = {}) {
      return new glob_js_1.Glob(pattern, options2).iterate();
    }
    exports2.globIterate = globIterate;
    exports2.streamSync = globStreamSync;
    exports2.stream = Object.assign(globStream, { sync: globStreamSync });
    exports2.iterateSync = globIterateSync;
    exports2.iterate = Object.assign(globIterate, {
      sync: globIterateSync
    });
    exports2.sync = Object.assign(globSync, {
      stream: globStreamSync,
      iterate: globIterateSync
    });
    var minimatch_2 = require_commonjs();
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return minimatch_2.escape;
    } });
    Object.defineProperty(exports2, "unescape", { enumerable: true, get: function() {
      return minimatch_2.unescape;
    } });
    var glob_js_2 = require_glob();
    Object.defineProperty(exports2, "Glob", { enumerable: true, get: function() {
      return glob_js_2.Glob;
    } });
    var has_magic_js_2 = require_has_magic();
    Object.defineProperty(exports2, "hasMagic", { enumerable: true, get: function() {
      return has_magic_js_2.hasMagic;
    } });
    exports2.glob = Object.assign(glob_, {
      glob: glob_,
      globSync,
      sync: exports2.sync,
      globStream,
      stream: exports2.stream,
      globStreamSync,
      streamSync: exports2.streamSync,
      globIterate,
      iterate: exports2.iterate,
      globIterateSync,
      iterateSync: exports2.iterateSync,
      Glob: glob_js_1.Glob,
      hasMagic: has_magic_js_1.hasMagic,
      escape: minimatch_1.escape,
      unescape: minimatch_1.unescape
    });
    exports2.glob.glob = exports2.glob;
  }
});

// node_modules/isexe/dist/cjs/posix.js
var require_posix = __commonJS({
  "node_modules/isexe/dist/cjs/posix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sync = exports2.isexe = void 0;
    var fs_1 = require("fs");
    var promises_1 = require("fs/promises");
    var isexe = async (path2, options2 = {}) => {
      const { ignoreErrors = false } = options2;
      try {
        return checkStat(await (0, promises_1.stat)(path2), options2);
      } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES")
          return false;
        throw er;
      }
    };
    exports2.isexe = isexe;
    var sync = (path2, options2 = {}) => {
      const { ignoreErrors = false } = options2;
      try {
        return checkStat((0, fs_1.statSync)(path2), options2);
      } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES")
          return false;
        throw er;
      }
    };
    exports2.sync = sync;
    var checkStat = (stat, options2) => stat.isFile() && checkMode(stat, options2);
    var checkMode = (stat, options2) => {
      const myUid = options2.uid ?? process.getuid?.();
      const myGroups = options2.groups ?? process.getgroups?.() ?? [];
      const myGid = options2.gid ?? process.getgid?.() ?? myGroups[0];
      if (myUid === void 0 || myGid === void 0) {
        throw new Error("cannot get uid or gid");
      }
      const groups = /* @__PURE__ */ new Set([myGid, ...myGroups]);
      const mod = stat.mode;
      const uid = stat.uid;
      const gid = stat.gid;
      const u = parseInt("100", 8);
      const g = parseInt("010", 8);
      const o = parseInt("001", 8);
      const ug = u | g;
      return !!(mod & o || mod & g && groups.has(gid) || mod & u && uid === myUid || mod & ug && myUid === 0);
    };
  }
});

// node_modules/isexe/dist/cjs/win32.js
var require_win32 = __commonJS({
  "node_modules/isexe/dist/cjs/win32.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sync = exports2.isexe = void 0;
    var fs_1 = require("fs");
    var promises_1 = require("fs/promises");
    var isexe = async (path2, options2 = {}) => {
      const { ignoreErrors = false } = options2;
      try {
        return checkStat(await (0, promises_1.stat)(path2), path2, options2);
      } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES")
          return false;
        throw er;
      }
    };
    exports2.isexe = isexe;
    var sync = (path2, options2 = {}) => {
      const { ignoreErrors = false } = options2;
      try {
        return checkStat((0, fs_1.statSync)(path2), path2, options2);
      } catch (e) {
        const er = e;
        if (ignoreErrors || er.code === "EACCES")
          return false;
        throw er;
      }
    };
    exports2.sync = sync;
    var checkPathExt = (path2, options2) => {
      const { pathExt = process.env.PATHEXT || "" } = options2;
      const peSplit = pathExt.split(";");
      if (peSplit.indexOf("") !== -1) {
        return true;
      }
      for (let i = 0; i < peSplit.length; i++) {
        const p = peSplit[i].toLowerCase();
        const ext = path2.substring(path2.length - p.length).toLowerCase();
        if (p && ext === p) {
          return true;
        }
      }
      return false;
    };
    var checkStat = (stat, path2, options2) => stat.isFile() && checkPathExt(path2, options2);
  }
});

// node_modules/isexe/dist/cjs/options.js
var require_options = __commonJS({
  "node_modules/isexe/dist/cjs/options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/isexe/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/isexe/dist/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sync = exports2.isexe = exports2.posix = exports2.win32 = void 0;
    var posix = __importStar(require_posix());
    exports2.posix = posix;
    var win32 = __importStar(require_win32());
    exports2.win32 = win32;
    __exportStar(require_options(), exports2);
    var platform2 = process.env._ISEXE_TEST_PLATFORM_ || process.platform;
    var impl = platform2 === "win32" ? win32 : posix;
    exports2.isexe = impl.isexe;
    exports2.sync = impl.sync;
  }
});

// node_modules/which/lib/index.js
var require_lib = __commonJS({
  "node_modules/which/lib/index.js"(exports2, module2) {
    var { isexe, sync: isexeSync } = require_cjs();
    var { join, delimiter, sep, posix } = require("path");
    var isWindows2 = process.platform === "win32";
    var rSlash = new RegExp(`[${posix.sep}${sep === posix.sep ? "" : sep}]`.replace(/(\\)/g, "\\$1"));
    var rRel = new RegExp(`^\\.${rSlash.source}`);
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, {
      path: optPath = process.env.PATH,
      pathExt: optPathExt = process.env.PATHEXT,
      delimiter: optDelimiter = delimiter
    }) => {
      const pathEnv = cmd.match(rSlash) ? [""] : [
        // windows always checks the cwd first
        ...isWindows2 ? [process.cwd()] : [],
        ...(optPath || /* istanbul ignore next: very unusual */
        "").split(optDelimiter)
      ];
      if (isWindows2) {
        const pathExtExe = optPathExt || [".EXE", ".CMD", ".BAT", ".COM"].join(optDelimiter);
        const pathExt = pathExtExe.split(optDelimiter).flatMap((item) => [item, item.toLowerCase()]);
        if (cmd.includes(".") && pathExt[0] !== "") {
          pathExt.unshift("");
        }
        return { pathEnv, pathExt, pathExtExe };
      }
      return { pathEnv, pathExt: [""] };
    };
    var getPathPart = (raw, cmd) => {
      const pathPart = /^".*"$/.test(raw) ? raw.slice(1, -1) : raw;
      const prefix = !pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : "";
      return prefix + join(pathPart, cmd);
    };
    var which2 = async (cmd, opt = {}) => {
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (const envPart of pathEnv) {
        const p = getPathPart(envPart, cmd);
        for (const ext of pathExt) {
          const withExt = p + ext;
          const is = await isexe(withExt, { pathExt: pathExtExe, ignoreErrors: true });
          if (is) {
            if (!opt.all) {
              return withExt;
            }
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length) {
        return found;
      }
      if (opt.nothrow) {
        return null;
      }
      throw getNotFoundError(cmd);
    };
    var whichSync = (cmd, opt = {}) => {
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (const pathEnvPart of pathEnv) {
        const p = getPathPart(pathEnvPart, cmd);
        for (const ext of pathExt) {
          const withExt = p + ext;
          const is = isexeSync(withExt, { pathExt: pathExtExe, ignoreErrors: true });
          if (is) {
            if (!opt.all) {
              return withExt;
            }
            found.push(withExt);
          }
        }
      }
      if (opt.all && found.length) {
        return found;
      }
      if (opt.nothrow) {
        return null;
      }
      throw getNotFoundError(cmd);
    };
    module2.exports = which2;
    which2.sync = whichSync;
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name2, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name2, index, value);
      t[name2] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options2) => {
      if (!options2) {
        return emptyOpts;
      }
      if (typeof options2 !== "object") {
        return looseOption;
      }
      return options2;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version2, options2) {
        options2 = parseOptions(options2);
        if (version2 instanceof _SemVer) {
          if (version2.loose === !!options2.loose && version2.includePrerelease === !!options2.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        const m = version2.trim().match(options2.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id2) => {
            if (/^[0-9]+$/.test(id2)) {
              const num = +id2;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id2;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse3 = (version2, options2, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options2);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse3;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse3 = require_parse();
    var valid = (version2, options2) => {
      const v = parse3(version2, options2);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse3 = require_parse();
    var clean = (version2, options2) => {
      const s = parse3(version2.trim().replace(/^[=v]+/, ""), options2);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver();
    var inc = (version2, release, options2, identifier, identifierBase) => {
      if (typeof options2 === "string") {
        identifierBase = identifier;
        identifier = options2;
        options2 = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options2
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse3 = require_parse();
    var diff = (version1, version2) => {
      const v12 = parse3(version1, null, true);
      const v2 = parse3(version2, null, true);
      const comparison = v12.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v12 : v2;
      const lowVersion = v1Higher ? v2 : v12;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v12.major !== v2.major) {
        return prefix + "major";
      }
      if (v12.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v12.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse3 = require_parse();
    var prerelease = (version2, options2) => {
      const parsed = parse3(version2, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver();
    var compare2 = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare2;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare2 = require_compare();
    var rcompare = (a, b, loose) => compare2(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare2 = require_compare();
    var compareLoose = (a, b) => compare2(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list2, loose) => list2.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list2, loose) => list2.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare2 = require_compare();
    var gt = (a, b, loose) => compare2(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare2 = require_compare();
    var lt = (a, b, loose) => compare2(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare2 = require_compare();
    var eq = (a, b, loose) => compare2(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare2 = require_compare();
    var neq = (a, b, loose) => compare2(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare2 = require_compare();
    var gte = (a, b, loose) => compare2(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare2 = require_compare();
    var lte = (a, b, loose) => compare2(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver();
    var parse3 = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version2, options2) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options2 = options2 || {};
      let match = null;
      if (!options2.rtl) {
        match = version2.match(options2.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options2.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options2.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options2.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse3(`${major}.${minor}.${patch}${prerelease}${build}`, options2);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports2, module2) {
    var LRUCache2 = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache2;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    var SPACE_CHARACTERS = /\s+/g;
    var Range11 = class _Range {
      constructor(range, options2) {
        options2 = parseOptions(options2);
        if (range instanceof _Range) {
          if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options2);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options2) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options2) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options2);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range11;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options2) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options2);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options2) => {
      debug("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug("caret", comp);
      comp = replaceTildes(comp, options2);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug("xrange", comp);
      comp = replaceStars(comp, options2);
      debug("stars", comp);
      return comp;
    };
    var isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
    var replaceTildes = (comp, options2) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options2)).join(" ");
    };
    var replaceTilde = (comp, options2) => {
      const r = options2.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options2) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options2)).join(" ");
    };
    var replaceCaret = (comp, options2) => {
      debug("caret", comp, options2);
      const r = options2.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options2.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options2) => {
      debug("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options2)).join(" ");
    };
    var replaceXRange = (comp, options2) => {
      comp = comp.trim();
      const r = options2.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options2.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options2) => {
      debug("replaceStars", comp, options2);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options2) => {
      debug("replaceGTE0", comp, options2);
      return comp.trim().replace(re[options2.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options2) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options2.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options2) {
        options2 = parseOptions(options2);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options2.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options2) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range11(comp.value, options2).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range11(this.value, options2).test(comp.semver);
        }
        options2 = parseOptions(options2);
        if (options2.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options2.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options2) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options2) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range11 = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range11 = require_range();
    var satisfies = (version2, range, options2) => {
      try {
        range = new Range11(range, options2);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range11 = require_range();
    var toComparators = (range, options2) => new Range11(range, options2).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range11 = require_range();
    var maxSatisfying = (versions, range, options2) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range11(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options2);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range11 = require_range();
    var minSatisfying = (versions, range, options2) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range11(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options2);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver();
    var Range11 = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range11(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range11 = require_range();
    var validRange = (range, options2) => {
      try {
        return new Range11(range, options2).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range11 = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options2) => {
      version2 = new SemVer(version2, options2);
      range = new Range11(range, options2);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options2)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options2)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options2)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version2, range, options2) => outside(version2, range, ">", options2);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version2, range, options2) => outside(version2, range, "<", options2);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range11 = require_range();
    var intersects = (r1, r2, options2) => {
      r1 = new Range11(r1, options2);
      r2 = new Range11(r2, options2);
      return r1.intersects(r2, options2);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    module2.exports = (versions, range, options2) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare2(a, b, options2));
      for (const version2 of v) {
        const included = satisfies(version2, range, options2);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range11 = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    var subset = (sub, dom, options2 = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range11(sub, options2);
      dom = new Range11(dom, options2);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options2);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options2) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options2.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options2.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options2);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options2);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare2(gt.semver, lt.semver, options2);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options2)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options2)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options2)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options2.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options2.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options2);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options2)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options2);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options2)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options2) => {
      if (!a) {
        return b;
      }
      const comp = compare2(a.semver, b.semver, options2);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options2) => {
      if (!a) {
        return b;
      }
      const comp = compare2(a.semver, b.semver, options2);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse3 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare2 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range11 = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse3,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare: compare2,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range: Range11,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
  }
});

// node_modules/fast-diff/diff.js
var require_diff2 = __commonJS({
  "node_modules/fast-diff/diff.js"(exports2, module2) {
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    function diff_main(text1, text2, cursor_pos, cleanup, _fix_unicode) {
      if (text1 === text2) {
        if (text1) {
          return [[DIFF_EQUAL, text1]];
        }
        return [];
      }
      if (cursor_pos != null) {
        var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
        if (editdiff) {
          return editdiff;
        }
      }
      var commonlength = diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = diff_compute_(text1, text2);
      if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
      }
      if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
      }
      diff_cleanupMerge(diffs, _fix_unicode);
      if (cleanup) {
        diff_cleanupSemantic(diffs);
      }
      return diffs;
    }
    function diff_compute_(text1, text2) {
      var diffs;
      if (!text1) {
        return [[DIFF_INSERT, text2]];
      }
      if (!text2) {
        return [[DIFF_DELETE, text1]];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i !== -1) {
        diffs = [
          [DIFF_INSERT, longtext.substring(0, i)],
          [DIFF_EQUAL, shorttext],
          [DIFF_INSERT, longtext.substring(i + shorttext.length)]
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length === 1) {
        return [
          [DIFF_DELETE, text1],
          [DIFF_INSERT, text2]
        ];
      }
      var hm = diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = diff_main(text1_a, text2_a);
        var diffs_b = diff_main(text1_b, text2_b);
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
      }
      return diff_bisect_(text1, text2);
    }
    function diff_bisect_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v12 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v12[x] = -1;
        v2[x] = -1;
      }
      v12[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 !== 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 === -d || k1 !== d && v12[k1_offset - 1] < v12[k1_offset + 1]) {
            x1 = v12[k1_offset + 1];
          } else {
            x1 = v12[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v12[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v12[k1_offset] !== -1) {
              var x1 = v12[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
      }
      return [
        [DIFF_DELETE, text1],
        [DIFF_INSERT, text2]
      ];
    }
    function diff_bisectSplit_(text1, text2, x, y) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = diff_main(text1a, text2a);
      var diffsb = diff_main(text1b, text2b);
      return diffs.concat(diffsb);
    }
    function diff_commonPrefix(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_commonOverlap_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      if (text1_length == 0 || text2_length == 0) {
        return 0;
      }
      if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
      } else if (text1_length < text2_length) {
        text2 = text2.substring(0, text1_length);
      }
      var text_length = Math.min(text1_length, text2_length);
      if (text1 == text2) {
        return text_length;
      }
      var best = 0;
      var length = 1;
      while (true) {
        var pattern = text1.substring(text_length - length);
        var found = text2.indexOf(pattern);
        if (found == -1) {
          return best;
        }
        length += found;
        if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
          best = length;
          length++;
        }
      }
    }
    function diff_commonSuffix(text1, text2) {
      if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_halfMatch_(text1, text2) {
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
          var prefixLength = diff_commonPrefix(
            longtext2.substring(i),
            shorttext2.substring(j)
          );
          var suffixLength = diff_commonSuffix(
            longtext2.substring(0, i),
            shorttext2.substring(0, j)
          );
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 4)
      );
      var hm2 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 2)
      );
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    }
    function diff_cleanupSemantic(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastequality = null;
      var pointer = 0;
      var length_insertions1 = 0;
      var length_deletions1 = 0;
      var length_insertions2 = 0;
      var length_deletions2 = 0;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {
          equalities[equalitiesLength++] = pointer;
          length_insertions1 = length_insertions2;
          length_deletions1 = length_deletions2;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastequality = diffs[pointer][1];
        } else {
          if (diffs[pointer][0] == DIFF_INSERT) {
            length_insertions2 += diffs[pointer][1].length;
          } else {
            length_deletions2 += diffs[pointer][1].length;
          }
          if (lastequality && lastequality.length <= Math.max(length_insertions1, length_deletions1) && lastequality.length <= Math.max(length_insertions2, length_deletions2)) {
            diffs.splice(equalities[equalitiesLength - 1], 0, [
              DIFF_DELETE,
              lastequality
            ]);
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
            equalitiesLength--;
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            length_insertions1 = 0;
            length_deletions1 = 0;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastequality = null;
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs);
      }
      diff_cleanupSemanticLossless(diffs);
      pointer = 1;
      while (pointer < diffs.length) {
        if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
          var deletion = diffs[pointer - 1][1];
          var insertion = diffs[pointer][1];
          var overlap_length1 = diff_commonOverlap_(deletion, insertion);
          var overlap_length2 = diff_commonOverlap_(insertion, deletion);
          if (overlap_length1 >= overlap_length2) {
            if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
              diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                insertion.substring(0, overlap_length1)
              ]);
              diffs[pointer - 1][1] = deletion.substring(
                0,
                deletion.length - overlap_length1
              );
              diffs[pointer + 1][1] = insertion.substring(overlap_length1);
              pointer++;
            }
          } else {
            if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
              diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                deletion.substring(0, overlap_length2)
              ]);
              diffs[pointer - 1][0] = DIFF_INSERT;
              diffs[pointer - 1][1] = insertion.substring(
                0,
                insertion.length - overlap_length2
              );
              diffs[pointer + 1][0] = DIFF_DELETE;
              diffs[pointer + 1][1] = deletion.substring(overlap_length2);
              pointer++;
            }
          }
          pointer++;
        }
        pointer++;
      }
    }
    var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
    var whitespaceRegex_ = /\s/;
    var linebreakRegex_ = /[\r\n]/;
    var blanklineEndRegex_ = /\n\r?\n$/;
    var blanklineStartRegex_ = /^\r?\n\r?\n/;
    function diff_cleanupSemanticLossless(diffs) {
      function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
          return 6;
        }
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
        var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
        var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
        var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
        var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
        if (blankLine1 || blankLine2) {
          return 5;
        } else if (lineBreak1 || lineBreak2) {
          return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
          return 3;
        } else if (whitespace1 || whitespace2) {
          return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
          return 1;
        }
        return 0;
      }
      var pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          var equality1 = diffs[pointer - 1][1];
          var edit2 = diffs[pointer][1];
          var equality2 = diffs[pointer + 1][1];
          var commonOffset = diff_commonSuffix(equality1, edit2);
          if (commonOffset) {
            var commonString = edit2.substring(edit2.length - commonOffset);
            equality1 = equality1.substring(0, equality1.length - commonOffset);
            edit2 = commonString + edit2.substring(0, edit2.length - commonOffset);
            equality2 = commonString + equality2;
          }
          var bestEquality1 = equality1;
          var bestEdit = edit2;
          var bestEquality2 = equality2;
          var bestScore = diff_cleanupSemanticScore_(equality1, edit2) + diff_cleanupSemanticScore_(edit2, equality2);
          while (edit2.charAt(0) === equality2.charAt(0)) {
            equality1 += edit2.charAt(0);
            edit2 = edit2.substring(1) + equality2.charAt(0);
            equality2 = equality2.substring(1);
            var score3 = diff_cleanupSemanticScore_(equality1, edit2) + diff_cleanupSemanticScore_(edit2, equality2);
            if (score3 >= bestScore) {
              bestScore = score3;
              bestEquality1 = equality1;
              bestEdit = edit2;
              bestEquality2 = equality2;
            }
          }
          if (diffs[pointer - 1][1] != bestEquality1) {
            if (bestEquality1) {
              diffs[pointer - 1][1] = bestEquality1;
            } else {
              diffs.splice(pointer - 1, 1);
              pointer--;
            }
            diffs[pointer][1] = bestEdit;
            if (bestEquality2) {
              diffs[pointer + 1][1] = bestEquality2;
            } else {
              diffs.splice(pointer + 1, 1);
              pointer--;
            }
          }
        }
        pointer++;
      }
    }
    function diff_cleanupMerge(diffs, fix_unicode) {
      diffs.push([DIFF_EQUAL, ""]);
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
          diffs.splice(pointer, 1);
          continue;
        }
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            var previous_equality = pointer - count_insert - count_delete - 1;
            if (fix_unicode) {
              if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                var stray = diffs[previous_equality][1].slice(-1);
                diffs[previous_equality][1] = diffs[previous_equality][1].slice(
                  0,
                  -1
                );
                text_delete = stray + text_delete;
                text_insert = stray + text_insert;
                if (!diffs[previous_equality][1]) {
                  diffs.splice(previous_equality, 1);
                  pointer--;
                  var k = previous_equality - 1;
                  if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                    count_insert++;
                    text_insert = diffs[k][1] + text_insert;
                    k--;
                  }
                  if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                    count_delete++;
                    text_delete = diffs[k][1] + text_delete;
                    k--;
                  }
                  previous_equality = k;
                }
              }
              if (starts_with_pair_end(diffs[pointer][1])) {
                var stray = diffs[pointer][1].charAt(0);
                diffs[pointer][1] = diffs[pointer][1].slice(1);
                text_delete += stray;
                text_insert += stray;
              }
            }
            if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
              diffs.splice(pointer, 1);
              break;
            }
            if (text_delete.length > 0 || text_insert.length > 0) {
              if (text_delete.length > 0 && text_insert.length > 0) {
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (previous_equality >= 0) {
                    diffs[previous_equality][1] += text_insert.substring(
                      0,
                      commonlength
                    );
                  } else {
                    diffs.splice(0, 0, [
                      DIFF_EQUAL,
                      text_insert.substring(0, commonlength)
                    ]);
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(
                    0,
                    text_insert.length - commonlength
                  );
                  text_delete = text_delete.substring(
                    0,
                    text_delete.length - commonlength
                  );
                }
              }
              var n = count_insert + count_delete;
              if (text_delete.length === 0 && text_insert.length === 0) {
                diffs.splice(pointer - n, n);
                pointer = pointer - n;
              } else if (text_delete.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 1;
              } else if (text_insert.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
                pointer = pointer - n + 1;
              } else {
                diffs.splice(
                  pointer - n,
                  n,
                  [DIFF_DELETE, text_delete],
                  [DIFF_INSERT, text_insert]
                );
                pointer = pointer - n + 2;
              }
            }
            if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
          if (diffs[pointer][1].substring(
            diffs[pointer][1].length - diffs[pointer - 1][1].length
          ) === diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(
              0,
              diffs[pointer][1].length - diffs[pointer - 1][1].length
            );
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs, fix_unicode);
      }
    }
    function is_surrogate_pair_start(charCode) {
      return charCode >= 55296 && charCode <= 56319;
    }
    function is_surrogate_pair_end(charCode) {
      return charCode >= 56320 && charCode <= 57343;
    }
    function starts_with_pair_end(str) {
      return is_surrogate_pair_end(str.charCodeAt(0));
    }
    function ends_with_pair_start(str) {
      return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
    }
    function remove_empty_tuples(tuples) {
      var ret = [];
      for (var i = 0; i < tuples.length; i++) {
        if (tuples[i][1].length > 0) {
          ret.push(tuples[i]);
        }
      }
      return ret;
    }
    function make_edit_splice(before, oldMiddle, newMiddle, after) {
      if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
        return null;
      }
      return remove_empty_tuples([
        [DIFF_EQUAL, before],
        [DIFF_DELETE, oldMiddle],
        [DIFF_INSERT, newMiddle],
        [DIFF_EQUAL, after]
      ]);
    }
    function find_cursor_edit_diff(oldText, newText, cursor_pos) {
      var oldRange = typeof cursor_pos === "number" ? { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
      var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
      var oldLength = oldText.length;
      var newLength = newText.length;
      if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
        var oldCursor = oldRange.index;
        var oldBefore = oldText.slice(0, oldCursor);
        var oldAfter = oldText.slice(oldCursor);
        var maybeNewCursor = newRange ? newRange.index : null;
        editBefore: {
          var newCursor = oldCursor + newLength - oldLength;
          if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
            break editBefore;
          }
          if (newCursor < 0 || newCursor > newLength) {
            break editBefore;
          }
          var newBefore = newText.slice(0, newCursor);
          var newAfter = newText.slice(newCursor);
          if (newAfter !== oldAfter) {
            break editBefore;
          }
          var prefixLength = Math.min(oldCursor, newCursor);
          var oldPrefix = oldBefore.slice(0, prefixLength);
          var newPrefix = newBefore.slice(0, prefixLength);
          if (oldPrefix !== newPrefix) {
            break editBefore;
          }
          var oldMiddle = oldBefore.slice(prefixLength);
          var newMiddle = newBefore.slice(prefixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
        }
        editAfter: {
          if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
            break editAfter;
          }
          var cursor = oldCursor;
          var newBefore = newText.slice(0, cursor);
          var newAfter = newText.slice(cursor);
          if (newBefore !== oldBefore) {
            break editAfter;
          }
          var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
          var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
          var newSuffix = newAfter.slice(newAfter.length - suffixLength);
          if (oldSuffix !== newSuffix) {
            break editAfter;
          }
          var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
          var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
          return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
        }
      }
      if (oldRange.length > 0 && newRange && newRange.length === 0) {
        replaceRange: {
          var oldPrefix = oldText.slice(0, oldRange.index);
          var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
          var prefixLength = oldPrefix.length;
          var suffixLength = oldSuffix.length;
          if (newLength < prefixLength + suffixLength) {
            break replaceRange;
          }
          var newPrefix = newText.slice(0, prefixLength);
          var newSuffix = newText.slice(newLength - suffixLength);
          if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
            break replaceRange;
          }
          var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
          var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
        }
      }
      return null;
    }
    function diff(text1, text2, cursor_pos, cleanup) {
      return diff_main(text1, text2, cursor_pos, cleanup, true);
    }
    diff.INSERT = DIFF_INSERT;
    diff.DELETE = DIFF_DELETE;
    diff.EQUAL = DIFF_EQUAL;
    module2.exports = diff;
  }
});

// node_modules/unidecode/data/x00.js
var require_x00 = __commonJS({
  "node_modules/unidecode/data/x00.js"(exports2, module2) {
    module2.exports = ["\0", "", "", "", "", "", "", "\x07", "\b", "	", "\n", "\v", "\f", "\r", "", "", "", "", "", "", "", "", "", "", "", "", "", "\x1B", "", "", "", "", " ", "!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~", "\x7F", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", " ", "!", "C/", "PS", "$?", "Y=", "|", "SS", '"', "(c)", "a", "<<", "!", "", "(r)", "-", "deg", "+-", "2", "3", "'", "u", "P", "*", ",", "1", "o", ">>", "1/4", "1/2", "3/4", "?", "A", "A", "A", "A", "A", "A", "AE", "C", "E", "E", "E", "E", "I", "I", "I", "I", "D", "N", "O", "O", "O", "O", "O", "x", "O", "U", "U", "U", "U", "U", "Th", "ss", "a", "a", "a", "a", "a", "a", "ae", "c", "e", "e", "e", "e", "i", "i", "i", "i", "d", "n", "o", "o", "o", "o", "o", "/", "o", "u", "u", "u", "u", "y", "th", "y"];
  }
});

// node_modules/unidecode/data/x01.js
var require_x01 = __commonJS({
  "node_modules/unidecode/data/x01.js"(exports2, module2) {
    module2.exports = ["A", "a", "A", "a", "A", "a", "C", "c", "C", "c", "C", "c", "C", "c", "D", "d", "D", "d", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "G", "g", "G", "g", "G", "g", "G", "g", "H", "h", "H", "h", "I", "i", "I", "i", "I", "i", "I", "i", "I", "i", "IJ", "", "J", "j", "K", "k", "k", "L", "l", "L", "l", "L", "l", "L", "l", "L", "l", "N", "n", "N", "n", "N", "n", "'n", "ng", "NG", "O", "o", "O", "o", "O", "o", "OE", "oe", "R", "r", "R", "r", "R", "r", "S", "s", "S", "s", "S", "s", "S", "s", "T", "t", "T", "t", "T", "t", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "W", "w", "Y", "y", "Y", "Z", "z", "Z", "z", "Z", "z", "s", "b", "B", "B", "b", "6", "6", "O", "C", "c", "D", "D", "D", "d", "d", "3", "@", "E", "F", "f", "G", "G", "hv", "I", "I", "K", "k", "l", "l", "W", "N", "n", "O", "O", "o", "OI", "oi", "P", "p", "YR", "2", "2", "SH", "sh", "t", "T", "t", "T", "U", "u", "Y", "V", "Y", "y", "Z", "z", "ZH", "ZH", "zh", "zh", "2", "5", "5", "ts", "w", "|", "||", "|=", "!", "DZ", "Dz", "dz", "LJ", "Lj", "lj", "NJ", "Nj", "nj", "A", "a", "I", "i", "O", "o", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "@", "A", "a", "A", "a", "AE", "ae", "G", "g", "G", "g", "K", "k", "O", "o", "O", "o", "ZH", "zh", "j", "DZ", "D", "dz", "G", "g", "HV", "W", "N", "n", "A", "a", "AE", "ae", "O", "o"];
  }
});

// node_modules/unidecode/data/x02.js
var require_x02 = __commonJS({
  "node_modules/unidecode/data/x02.js"(exports2, module2) {
    module2.exports = ["A", "a", "A", "a", "E", "e", "E", "e", "I", "i", "I", "i", "O", "o", "O", "o", "R", "r", "R", "r", "U", "u", "U", "u", "S", "s", "T", "t", "Y", "y", "H", "h", "[?]", "[?]", "OU", "ou", "Z", "z", "A", "a", "E", "e", "O", "o", "O", "o", "O", "o", "O", "o", "Y", "y", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "a", "a", "b", "o", "c", "d", "d", "e", "@", "@", "e", "e", "e", "e", "j", "g", "g", "g", "g", "u", "Y", "h", "h", "i", "i", "I", "l", "l", "l", "lZ", "W", "W", "m", "n", "n", "n", "o", "OE", "O", "F", "R", "R", "R", "R", "r", "r", "R", "R", "R", "s", "S", "j", "S", "S", "t", "t", "U", "U", "v", "^", "W", "Y", "Y", "z", "z", "Z", "Z", "?", "?", "?", "C", "@", "B", "E", "G", "H", "j", "k", "L", "q", "?", "?", "dz", "dZ", "dz", "ts", "tS", "tC", "fN", "ls", "lz", "WW", "]]", "[?]", "[?]", "k", "h", "j", "r", "r", "r", "r", "w", "y", "'", '"', "`", "'", "`", "`", "'", "?", "?", "<", ">", "^", "V", "^", "V", "'", "-", "/", "\\", ",", "_", "\\", "/", ":", ".", "`", "'", "^", "V", "+", "-", "V", ".", "@", ",", "~", '"', "R", "X", "G", "l", "s", "x", "?", "", "", "", "", "", "", "", "V", "=", '"', "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x03.js
var require_x03 = __commonJS({
  "node_modules/unidecode/data/x03.js"(exports2, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "'", ",", "[?]", "[?]", "[?]", "[?]", "", "[?]", "[?]", "[?]", "?", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "A", ";", "E", "E", "I", "[?]", "O", "[?]", "U", "O", "I", "A", "B", "G", "D", "E", "Z", "E", "Th", "I", "K", "L", "M", "N", "Ks", "O", "P", "R", "[?]", "S", "T", "U", "Ph", "Kh", "Ps", "O", "I", "U", "a", "e", "e", "i", "u", "a", "b", "g", "d", "e", "z", "e", "th", "i", "k", "l", "m", "n", "x", "o", "p", "r", "s", "s", "t", "u", "ph", "kh", "ps", "o", "i", "u", "o", "u", "o", "[?]", "b", "th", "U", "U", "U", "ph", "p", "&", "[?]", "[?]", "St", "st", "W", "w", "Q", "q", "Sp", "sp", "Sh", "sh", "F", "f", "Kh", "kh", "H", "h", "G", "g", "CH", "ch", "Ti", "ti", "k", "r", "c", "j", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x04.js
var require_x04 = __commonJS({
  "node_modules/unidecode/data/x04.js"(exports2, module2) {
    module2.exports = ["Ie", "Io", "Dj", "Gj", "Ie", "Dz", "I", "Yi", "J", "Lj", "Nj", "Tsh", "Kj", "I", "U", "Dzh", "A", "B", "V", "G", "D", "Ie", "Zh", "Z", "I", "I", "K", "L", "M", "N", "O", "P", "R", "S", "T", "U", "F", "Kh", "Ts", "Ch", "Sh", "Shch", "", "Y", "'", "E", "Iu", "Ia", "a", "b", "v", "gh", "d", "ie", "zh", "z", "i", "i", "k", "l", "m", "n", "o", "p", "r", "s", "t", "u", "f", "kh", "ts", "ch", "sh", "shch", "", "y", "'", "e", "iu", "ia", "ie", "io", "dj", "gj", "ie", "dz", "i", "yi", "j", "lj", "nj", "tsh", "kj", "i", "u", "dzh", "O", "o", "E", "e", "Ie", "ie", "E", "e", "Ie", "ie", "O", "o", "Io", "io", "Ks", "ks", "Ps", "ps", "F", "f", "Y", "y", "Y", "y", "u", "u", "O", "o", "O", "o", "Ot", "ot", "Q", "q", "*1000*", "", "", "", "", "[?]", "*100.000*", "*1.000.000*", "[?]", "[?]", '"', '"', "R'", "r'", "G'", "g'", "G'", "g'", "G'", "g'", "Zh'", "zh'", "Z'", "z'", "K'", "k'", "K'", "k'", "K'", "k'", "K'", "k'", "N'", "n'", "Ng", "ng", "P'", "p'", "Kh", "kh", "S'", "s'", "T'", "t'", "U", "u", "U'", "u'", "Kh'", "kh'", "Tts", "tts", "Ch'", "ch'", "Ch'", "ch'", "H", "h", "Ch", "ch", "Ch'", "ch'", "`", "Zh", "zh", "K'", "k'", "[?]", "[?]", "N'", "n'", "[?]", "[?]", "Ch", "ch", "[?]", "[?]", "[?]", "a", "a", "A", "a", "Ae", "ae", "Ie", "ie", "@", "@", "@", "@", "Zh", "zh", "Z", "z", "Dz", "dz", "I", "i", "I", "i", "O", "o", "O", "o", "O", "o", "E", "e", "U", "u", "U", "u", "U", "u", "Ch", "ch", "[?]", "[?]", "Y", "y", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x05.js
var require_x05 = __commonJS({
  "node_modules/unidecode/data/x05.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "A", "B", "G", "D", "E", "Z", "E", "E", "T`", "Zh", "I", "L", "Kh", "Ts", "K", "H", "Dz", "Gh", "Ch", "M", "Y", "N", "Sh", "O", "Ch`", "P", "J", "Rh", "S", "V", "T", "R", "Ts`", "W", "P`", "K`", "O", "F", "[?]", "[?]", "<", "'", "/", "!", ",", "?", ".", "[?]", "a", "b", "g", "d", "e", "z", "e", "e", "t`", "zh", "i", "l", "kh", "ts", "k", "h", "dz", "gh", "ch", "m", "y", "n", "sh", "o", "ch`", "p", "j", "rh", "s", "v", "t", "r", "ts`", "w", "p`", "k`", "o", "f", "ew", "[?]", ".", "-", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "@", "e", "a", "o", "i", "e", "e", "a", "a", "o", "[?]", "u", "'", "", "", "", "", "", "", ":", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "b", "g", "d", "h", "v", "z", "kh", "t", "y", "k", "k", "l", "m", "m", "n", "n", "s", "`", "p", "p", "ts", "ts", "q", "r", "sh", "t", "[?]", "[?]", "[?]", "[?]", "[?]", "V", "oy", "i", "'", '"', "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x06.js
var require_x06 = __commonJS({
  "node_modules/unidecode/data/x06.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", ",", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", ";", "[?]", "[?]", "[?]", "?", "[?]", "", "a", "'", "w'", "", "y'", "", "b", "@", "t", "th", "j", "H", "kh", "d", "dh", "r", "z", "s", "sh", "S", "D", "T", "Z", "aa", "G", "[?]", "[?]", "[?]", "[?]", "[?]", "", "f", "q", "k", "l", "m", "n", "h", "w", "~", "y", "an", "un", "in", "a", "u", "i", "W", "", "", "'", "'", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "%", ".", ",", "*", "[?]", "[?]", "", "'", "'", "'", "", "'", "'w", "'u", "'y", "tt", "tth", "b", "t", "T", "p", "th", "bh", "'h", "H", "ny", "dy", "H", "ch", "cch", "dd", "D", "D", "Dt", "dh", "ddh", "d", "D", "D", "rr", "R", "R", "R", "R", "R", "R", "j", "R", "S", "S", "S", "S", "S", "T", "GH", "F", "F", "F", "v", "f", "ph", "Q", "Q", "kh", "k", "K", "K", "ng", "K", "g", "G", "N", "G", "G", "G", "L", "L", "L", "L", "N", "N", "N", "N", "N", "h", "Ch", "hy", "h", "H", "@", "W", "oe", "oe", "u", "yu", "yu", "W", "v", "y", "Y", "Y", "W", "", "", "y", "y'", ".", "ae", "", "", "", "", "", "", "", "@", "#", "", "", "", "", "", "", "", "", "", "", "^", "", "", "", "", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "Sh", "D", "Gh", "&", "+m"];
  }
});

// node_modules/unidecode/data/x07.js
var require_x07 = __commonJS({
  "node_modules/unidecode/data/x07.js"(exports2, module2) {
    module2.exports = ["//", "/", ",", "!", "!", "-", ",", ",", ";", "?", "~", "{", "}", "*", "[?]", "", "'", "", "b", "g", "g", "d", "d", "h", "w", "z", "H", "t", "t", "y", "yh", "k", "l", "m", "n", "s", "s", "`", "p", "p", "S", "q", "r", "sh", "t", "[?]", "[?]", "[?]", "a", "a", "a", "A", "A", "A", "e", "e", "e", "E", "i", "i", "u", "u", "u", "o", "", "`", "'", "", "", "X", "Q", "@", "@", "|", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "h", "sh", "n", "r", "b", "L", "k", "'", "v", "m", "f", "dh", "th", "l", "g", "ny", "s", "d", "z", "t", "y", "p", "j", "ch", "tt", "hh", "kh", "th", "z", "sh", "s", "d", "t", "z", "`", "gh", "q", "w", "a", "aa", "i", "ee", "u", "oo", "e", "ey", "o", "oa", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x09.js
var require_x09 = __commonJS({
  "node_modules/unidecode/data/x09.js"(exports2, module2) {
    module2.exports = ["[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "eN", "e", "e", "ai", "oN", "o", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "nnn", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "l", "lll", "v", "sh", "ss", "s", "h", "[?]", "[?]", "'", "'", "aa", "i", "ii", "u", "uu", "R", "RR", "eN", "e", "e", "ai", "oN", "o", "o", "au", "", "[?]", "[?]", "AUM", "'", "'", "`", "'", "[?]", "[?]", "[?]", "q", "khh", "ghh", "z", "dddh", "rh", "f", "yy", "RR", "LL", "L", "LL", " / ", " // ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "[?]", "l", "[?]", "[?]", "[?]", "sh", "ss", "s", "h", "[?]", "[?]", "'", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "[?]", "[?]", "[?]", "[?]", "rr", "rh", "[?]", "yy", "RR", "LL", "L", "LL", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "r'", "r`", "Rs", "Rs", "1/", "2/", "3/", "4/", " 1 - 1/", "/16", "", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0a.js
var require_x0a = __commonJS({
  "node_modules/unidecode/data/x0a.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "N", "[?]", "[?]", "a", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "[?]", "ee", "ai", "[?]", "[?]", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bb", "m", "y", "r", "[?]", "l", "ll", "[?]", "v", "sh", "[?]", "s", "h", "[?]", "[?]", "'", "[?]", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "[?]", "ee", "ai", "[?]", "[?]", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "khh", "ghh", "z", "rr", "[?]", "f", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "N", "H", "", "", "G.E.O.", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "[?]", "eN", "[?]", "e", "ai", "oN", "[?]", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "ya", "r", "[?]", "l", "ll", "[?]", "v", "sh", "ss", "s", "h", "[?]", "[?]", "'", "'", "aa", "i", "ii", "u", "uu", "R", "RR", "eN", "[?]", "e", "ai", "oN", "[?]", "o", "au", "", "[?]", "[?]", "AUM", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0b.js
var require_x0b = __commonJS({
  "node_modules/unidecode/data/x0b.js"(exports2, module2) {
    module2.exports = ["[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "[?]", "l", "ll", "[?]", "", "sh", "ss", "s", "h", "[?]", "[?]", "'", "'", "aa", "i", "ii", "u", "uu", "R", "[?]", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "+", "[?]", "[?]", "[?]", "[?]", "rr", "rh", "[?]", "yy", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "[?]", "[?]", "[?]", "ng", "c", "[?]", "j", "[?]", "ny", "tt", "[?]", "[?]", "[?]", "nn", "t", "[?]", "[?]", "[?]", "n", "nnn", "p", "[?]", "[?]", "[?]", "m", "y", "r", "rr", "l", "ll", "lll", "v", "[?]", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+10+", "+100+", "+1000+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0c.js
var require_x0c = __commonJS({
  "node_modules/unidecode/data/x0c.js"(exports2, module2) {
    module2.exports = ["[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", "[?]", "v", "sh", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", "[?]", "v", "sh", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "lll", "[?]", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0d.js
var require_x0d = __commonJS({
  "node_modules/unidecode/data/x0d.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", "lll", "v", "sh", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "[?]", "[?]", "e", "ee", "ai", "", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "H", "[?]", "a", "aa", "ae", "aae", "i", "ii", "u", "uu", "R", "RR", "L", "LL", "e", "ee", "ai", "o", "oo", "au", "[?]", "[?]", "[?]", "k", "kh", "g", "gh", "ng", "nng", "c", "ch", "j", "jh", "ny", "jny", "nyj", "tt", "tth", "dd", "ddh", "nn", "nndd", "t", "th", "d", "dh", "n", "[?]", "nd", "p", "ph", "b", "bh", "m", "mb", "y", "r", "[?]", "l", "[?]", "[?]", "v", "sh", "ss", "s", "h", "ll", "f", "[?]", "[?]", "[?]", "", "[?]", "[?]", "[?]", "[?]", "aa", "ae", "aae", "i", "ii", "u", "[?]", "uu", "[?]", "R", "e", "ee", "ai", "o", "oo", "au", "L", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "LL", " . ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0e.js
var require_x0e = __commonJS({
  "node_modules/unidecode/data/x0e.js"(exports2, module2) {
    module2.exports = ["[?]", "k", "kh", "kh", "kh", "kh", "kh", "ng", "cch", "ch", "ch", "ch", "ch", "y", "d", "t", "th", "th", "th", "n", "d", "t", "th", "th", "th", "n", "b", "p", "ph", "f", "ph", "f", "ph", "m", "y", "r", "R", "l", "L", "w", "s", "s", "s", "h", "l", "`", "h", "~", "a", "a", "aa", "am", "i", "ii", "ue", "uue", "u", "uu", "'", "[?]", "[?]", "[?]", "[?]", "Bh.", "e", "ae", "o", "ai", "ai", "ao", "+", "", "", "", "", "", "", "M", "", " * ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", " // ", " /// ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "k", "kh", "[?]", "kh", "[?]", "[?]", "ng", "ch", "[?]", "s", "[?]", "[?]", "ny", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "d", "h", "th", "th", "[?]", "n", "b", "p", "ph", "f", "ph", "f", "[?]", "m", "y", "r", "[?]", "l", "[?]", "w", "[?]", "[?]", "s", "h", "[?]", "`", "", "~", "a", "", "aa", "am", "i", "ii", "y", "yy", "u", "uu", "[?]", "o", "l", "ny", "[?]", "[?]", "e", "ei", "o", "ay", "ai", "[?]", "+", "[?]", "", "", "", "", "", "M", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "hn", "hm", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0f.js
var require_x0f = __commonJS({
  "node_modules/unidecode/data/x0f.js"(exports2, module2) {
    module2.exports = ["AUM", "", "", "", "", "", "", "", " // ", " * ", "", "-", " / ", " / ", " // ", " -/ ", " +/ ", " X/ ", " /XX/ ", " /X/ ", ", ", "", "", "", "", "", "", "", "", "", "", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".5", "1.5", "2.5", "3.5", "4.5", "5.5", "6.5", "7.5", "8.5", "-.5", "+", "*", "^", "_", "", "~", "[?]", "]", "[[", "]]", "", "", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "[?]", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "ts", "tsh", "dz", "dzh", "w", "zh", "z", "'", "y", "r", "l", "sh", "ssh", "s", "h", "a", "kss", "r", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "L", "LL", "e", "ee", "o", "oo", "M", "H", "i", "ii", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "[?]", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "ts", "tsh", "dz", "dzh", "w", "zh", "z", "'", "y", "r", "l", "sh", "ss", "s", "h", "a", "kss", "w", "y", "r", "[?]", "X", " :X: ", " /O/ ", " /o/ ", " \\o\\ ", " (O) ", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x10.js
var require_x10 = __commonJS({
  "node_modules/unidecode/data/x10.js"(exports2, module2) {
    module2.exports = ["k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "nny", "tt", "tth", "dd", "ddh", "nn", "tt", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "y", "r", "l", "w", "s", "h", "ll", "a", "[?]", "i", "ii", "u", "uu", "e", "[?]", "o", "au", "[?]", "aa", "i", "ii", "u", "uu", "e", "ai", "[?]", "[?]", "[?]", "N", "'", ":", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", " / ", " // ", "n*", "r*", "l*", "e*", "sh", "ss", "R", "RR", "L", "LL", "R", "RR", "L", "LL", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "A", "B", "G", "D", "E", "V", "Z", "T`", "I", "K", "L", "M", "N", "O", "P", "Zh", "R", "S", "T", "U", "P`", "K`", "G'", "Q", "Sh", "Ch`", "C`", "Z'", "C", "Ch", "X", "J", "H", "E", "Y", "W", "Xh", "OE", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "b", "g", "d", "e", "v", "z", "t`", "i", "k", "l", "m", "n", "o", "p", "zh", "r", "s", "t", "u", "p`", "k`", "g'", "q", "sh", "ch`", "c`", "z'", "c", "ch", "x", "j", "h", "e", "y", "w", "xh", "oe", "f", "[?]", "[?]", "[?]", "[?]", " // ", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x11.js
var require_x11 = __commonJS({
  "node_modules/unidecode/data/x11.js"(exports2, module2) {
    module2.exports = ["g", "gg", "n", "d", "dd", "r", "m", "b", "bb", "s", "ss", "", "j", "jj", "c", "k", "t", "p", "h", "ng", "nn", "nd", "nb", "dg", "rn", "rr", "rh", "rN", "mb", "mN", "bg", "bn", "", "bs", "bsg", "bst", "bsb", "bss", "bsj", "bj", "bc", "bt", "bp", "bN", "bbN", "sg", "sn", "sd", "sr", "sm", "sb", "sbg", "sss", "s", "sj", "sc", "sk", "st", "sp", "sh", "", "", "", "", "Z", "g", "d", "m", "b", "s", "Z", "", "j", "c", "t", "p", "N", "j", "", "", "", "", "ck", "ch", "", "", "pb", "pN", "hh", "Q", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "a", "ae", "ya", "yae", "eo", "e", "yeo", "ye", "o", "wa", "wae", "oe", "yo", "u", "weo", "we", "wi", "yu", "eu", "yi", "i", "a-o", "a-u", "ya-o", "ya-yo", "eo-o", "eo-u", "eo-eu", "yeo-o", "yeo-u", "o-eo", "o-e", "o-ye", "o-o", "o-u", "yo-ya", "yo-yae", "yo-yeo", "yo-o", "yo-i", "u-a", "u-ae", "u-eo-eu", "u-ye", "u-u", "yu-a", "yu-eo", "yu-e", "yu-yeo", "yu-ye", "yu-u", "yu-i", "eu-u", "eu-eu", "yi-u", "i-a", "i-ya", "i-o", "i-u", "i-eu", "i-U", "U", "U-eo", "U-u", "U-i", "UU", "[?]", "[?]", "[?]", "[?]", "[?]", "g", "gg", "gs", "n", "nj", "nh", "d", "l", "lg", "lm", "lb", "ls", "lt", "lp", "lh", "m", "b", "bs", "s", "ss", "ng", "j", "c", "k", "t", "p", "h", "gl", "gsg", "ng", "nd", "ns", "nZ", "nt", "dg", "tl", "lgs", "ln", "ld", "lth", "ll", "lmg", "lms", "lbs", "lbh", "rNp", "lss", "lZ", "lk", "lQ", "mg", "ml", "mb", "ms", "mss", "mZ", "mc", "mh", "mN", "bl", "bp", "ph", "pN", "sg", "sd", "sl", "sb", "Z", "g", "ss", "", "kh", "N", "Ns", "NZ", "pb", "pN", "hn", "hl", "hm", "hb", "Q", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x12.js
var require_x12 = __commonJS({
  "node_modules/unidecode/data/x12.js"(exports2, module2) {
    module2.exports = ["ha", "hu", "hi", "haa", "hee", "he", "ho", "[?]", "la", "lu", "li", "laa", "lee", "le", "lo", "lwa", "hha", "hhu", "hhi", "hhaa", "hhee", "hhe", "hho", "hhwa", "ma", "mu", "mi", "maa", "mee", "me", "mo", "mwa", "sza", "szu", "szi", "szaa", "szee", "sze", "szo", "szwa", "ra", "ru", "ri", "raa", "ree", "re", "ro", "rwa", "sa", "su", "si", "saa", "see", "se", "so", "swa", "sha", "shu", "shi", "shaa", "shee", "she", "sho", "shwa", "qa", "qu", "qi", "qaa", "qee", "qe", "qo", "[?]", "qwa", "[?]", "qwi", "qwaa", "qwee", "qwe", "[?]", "[?]", "qha", "qhu", "qhi", "qhaa", "qhee", "qhe", "qho", "[?]", "qhwa", "[?]", "qhwi", "qhwaa", "qhwee", "qhwe", "[?]", "[?]", "ba", "bu", "bi", "baa", "bee", "be", "bo", "bwa", "va", "vu", "vi", "vaa", "vee", "ve", "vo", "vwa", "ta", "tu", "ti", "taa", "tee", "te", "to", "twa", "ca", "cu", "ci", "caa", "cee", "ce", "co", "cwa", "xa", "xu", "xi", "xaa", "xee", "xe", "xo", "[?]", "xwa", "[?]", "xwi", "xwaa", "xwee", "xwe", "[?]", "[?]", "na", "nu", "ni", "naa", "nee", "ne", "no", "nwa", "nya", "nyu", "nyi", "nyaa", "nyee", "nye", "nyo", "nywa", "'a", "'u", "[?]", "'aa", "'ee", "'e", "'o", "'wa", "ka", "ku", "ki", "kaa", "kee", "ke", "ko", "[?]", "kwa", "[?]", "kwi", "kwaa", "kwee", "kwe", "[?]", "[?]", "kxa", "kxu", "kxi", "kxaa", "kxee", "kxe", "kxo", "[?]", "kxwa", "[?]", "kxwi", "kxwaa", "kxwee", "kxwe", "[?]", "[?]", "wa", "wu", "wi", "waa", "wee", "we", "wo", "[?]", "`a", "`u", "`i", "`aa", "`ee", "`e", "`o", "[?]", "za", "zu", "zi", "zaa", "zee", "ze", "zo", "zwa", "zha", "zhu", "zhi", "zhaa", "zhee", "zhe", "zho", "zhwa", "ya", "yu", "yi", "yaa", "yee", "ye", "yo", "[?]", "da", "du", "di", "daa", "dee", "de", "do", "dwa", "dda", "ddu", "ddi", "ddaa", "ddee", "dde", "ddo", "ddwa"];
  }
});

// node_modules/unidecode/data/x13.js
var require_x13 = __commonJS({
  "node_modules/unidecode/data/x13.js"(exports2, module2) {
    module2.exports = ["ja", "ju", "ji", "jaa", "jee", "je", "jo", "jwa", "ga", "gu", "gi", "gaa", "gee", "ge", "go", "[?]", "gwa", "[?]", "gwi", "gwaa", "gwee", "gwe", "[?]", "[?]", "gga", "ggu", "ggi", "ggaa", "ggee", "gge", "ggo", "[?]", "tha", "thu", "thi", "thaa", "thee", "the", "tho", "thwa", "cha", "chu", "chi", "chaa", "chee", "che", "cho", "chwa", "pha", "phu", "phi", "phaa", "phee", "phe", "pho", "phwa", "tsa", "tsu", "tsi", "tsaa", "tsee", "tse", "tso", "tswa", "tza", "tzu", "tzi", "tzaa", "tzee", "tze", "tzo", "[?]", "fa", "fu", "fi", "faa", "fee", "fe", "fo", "fwa", "pa", "pu", "pi", "paa", "pee", "pe", "po", "pwa", "rya", "mya", "fya", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", " ", ".", ",", ";", ":", ":: ", "?", "//", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10+", "20+", "30+", "40+", "50+", "60+", "70+", "80+", "90+", "100+", "10,000+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "e", "i", "o", "u", "v", "ga", "ka", "ge", "gi", "go", "gu", "gv", "ha", "he", "hi", "ho", "hu", "hv", "la", "le", "li", "lo", "lu", "lv", "ma", "me", "mi", "mo", "mu", "na", "hna", "nah", "ne", "ni", "no", "nu", "nv", "qua", "que", "qui", "quo", "quu", "quv", "sa", "s", "se", "si", "so", "su", "sv", "da", "ta", "de", "te", "di", "ti", "do", "du", "dv", "dla", "tla", "tle", "tli", "tlo", "tlu", "tlv", "tsa", "tse", "tsi", "tso", "tsu", "tsv", "wa", "we", "wi", "wo", "wu", "wv", "ya", "ye", "yi", "yo", "yu", "yv", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x14.js
var require_x14 = __commonJS({
  "node_modules/unidecode/data/x14.js"(exports2, module2) {
    module2.exports = ["[?]", "e", "aai", "i", "ii", "o", "oo", "oo", "ee", "i", "a", "aa", "we", "we", "wi", "wi", "wii", "wii", "wo", "wo", "woo", "woo", "woo", "wa", "wa", "waa", "waa", "waa", "ai", "w", "'", "t", "k", "sh", "s", "n", "w", "n", "[?]", "w", "c", "?", "l", "en", "in", "on", "an", "pe", "paai", "pi", "pii", "po", "poo", "poo", "hee", "hi", "pa", "paa", "pwe", "pwe", "pwi", "pwi", "pwii", "pwii", "pwo", "pwo", "pwoo", "pwoo", "pwa", "pwa", "pwaa", "pwaa", "pwaa", "p", "p", "h", "te", "taai", "ti", "tii", "to", "too", "too", "dee", "di", "ta", "taa", "twe", "twe", "twi", "twi", "twii", "twii", "two", "two", "twoo", "twoo", "twa", "twa", "twaa", "twaa", "twaa", "t", "tte", "tti", "tto", "tta", "ke", "kaai", "ki", "kii", "ko", "koo", "koo", "ka", "kaa", "kwe", "kwe", "kwi", "kwi", "kwii", "kwii", "kwo", "kwo", "kwoo", "kwoo", "kwa", "kwa", "kwaa", "kwaa", "kwaa", "k", "kw", "keh", "kih", "koh", "kah", "ce", "caai", "ci", "cii", "co", "coo", "coo", "ca", "caa", "cwe", "cwe", "cwi", "cwi", "cwii", "cwii", "cwo", "cwo", "cwoo", "cwoo", "cwa", "cwa", "cwaa", "cwaa", "cwaa", "c", "th", "me", "maai", "mi", "mii", "mo", "moo", "moo", "ma", "maa", "mwe", "mwe", "mwi", "mwi", "mwii", "mwii", "mwo", "mwo", "mwoo", "mwoo", "mwa", "mwa", "mwaa", "mwaa", "mwaa", "m", "m", "mh", "m", "m", "ne", "naai", "ni", "nii", "no", "noo", "noo", "na", "naa", "nwe", "nwe", "nwa", "nwa", "nwaa", "nwaa", "nwaa", "n", "ng", "nh", "le", "laai", "li", "lii", "lo", "loo", "loo", "la", "laa", "lwe", "lwe", "lwi", "lwi", "lwii", "lwii", "lwo", "lwo", "lwoo", "lwoo", "lwa", "lwa", "lwaa", "lwaa", "l", "l", "l", "se", "saai", "si", "sii", "so", "soo", "soo", "sa", "saa", "swe", "swe", "swi", "swi", "swii", "swii", "swo", "swo", "swoo", "swoo"];
  }
});

// node_modules/unidecode/data/x15.js
var require_x15 = __commonJS({
  "node_modules/unidecode/data/x15.js"(exports2, module2) {
    module2.exports = ["swa", "swa", "swaa", "swaa", "swaa", "s", "s", "sw", "s", "sk", "skw", "sW", "spwa", "stwa", "skwa", "scwa", "she", "shi", "shii", "sho", "shoo", "sha", "shaa", "shwe", "shwe", "shwi", "shwi", "shwii", "shwii", "shwo", "shwo", "shwoo", "shwoo", "shwa", "shwa", "shwaa", "shwaa", "sh", "ye", "yaai", "yi", "yii", "yo", "yoo", "yoo", "ya", "yaa", "ywe", "ywe", "ywi", "ywi", "ywii", "ywii", "ywo", "ywo", "ywoo", "ywoo", "ywa", "ywa", "ywaa", "ywaa", "ywaa", "y", "y", "y", "yi", "re", "re", "le", "raai", "ri", "rii", "ro", "roo", "lo", "ra", "raa", "la", "rwaa", "rwaa", "r", "r", "r", "fe", "faai", "fi", "fii", "fo", "foo", "fa", "faa", "fwaa", "fwaa", "f", "the", "the", "thi", "thi", "thii", "thii", "tho", "thoo", "tha", "thaa", "thwaa", "thwaa", "th", "tthe", "tthi", "ttho", "ttha", "tth", "tye", "tyi", "tyo", "tya", "he", "hi", "hii", "ho", "hoo", "ha", "haa", "h", "h", "hk", "qaai", "qi", "qii", "qo", "qoo", "qa", "qaa", "q", "tlhe", "tlhi", "tlho", "tlha", "re", "ri", "ro", "ra", "ngaai", "ngi", "ngii", "ngo", "ngoo", "nga", "ngaa", "ng", "nng", "she", "shi", "sho", "sha", "the", "thi", "tho", "tha", "th", "lhi", "lhii", "lho", "lhoo", "lha", "lhaa", "lh", "the", "thi", "thii", "tho", "thoo", "tha", "thaa", "th", "b", "e", "i", "o", "a", "we", "wi", "wo", "wa", "ne", "ni", "no", "na", "ke", "ki", "ko", "ka", "he", "hi", "ho", "ha", "ghu", "gho", "ghe", "ghee", "ghi", "gha", "ru", "ro", "re", "ree", "ri", "ra", "wu", "wo", "we", "wee", "wi", "wa", "hwu", "hwo", "hwe", "hwee", "hwi", "hwa", "thu", "tho", "the", "thee", "thi", "tha", "ttu", "tto", "tte", "ttee", "tti", "tta", "pu", "po", "pe", "pee", "pi", "pa", "p", "gu", "go", "ge", "gee", "gi", "ga", "khu", "kho", "khe", "khee", "khi", "kha", "kku", "kko", "kke", "kkee", "kki"];
  }
});

// node_modules/unidecode/data/x16.js
var require_x16 = __commonJS({
  "node_modules/unidecode/data/x16.js"(exports2, module2) {
    module2.exports = ["kka", "kk", "nu", "no", "ne", "nee", "ni", "na", "mu", "mo", "me", "mee", "mi", "ma", "yu", "yo", "ye", "yee", "yi", "ya", "ju", "ju", "jo", "je", "jee", "ji", "ji", "ja", "jju", "jjo", "jje", "jjee", "jji", "jja", "lu", "lo", "le", "lee", "li", "la", "dlu", "dlo", "dle", "dlee", "dli", "dla", "lhu", "lho", "lhe", "lhee", "lhi", "lha", "tlhu", "tlho", "tlhe", "tlhee", "tlhi", "tlha", "tlu", "tlo", "tle", "tlee", "tli", "tla", "zu", "zo", "ze", "zee", "zi", "za", "z", "z", "dzu", "dzo", "dze", "dzee", "dzi", "dza", "su", "so", "se", "see", "si", "sa", "shu", "sho", "she", "shee", "shi", "sha", "sh", "tsu", "tso", "tse", "tsee", "tsi", "tsa", "chu", "cho", "che", "chee", "chi", "cha", "ttsu", "ttso", "ttse", "ttsee", "ttsi", "ttsa", "X", ".", "qai", "ngai", "nngi", "nngii", "nngo", "nngoo", "nnga", "nngaa", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", " ", "b", "l", "f", "s", "n", "h", "d", "t", "c", "q", "m", "g", "ng", "z", "r", "a", "o", "u", "e", "i", "ch", "th", "ph", "p", "x", "p", "<", ">", "[?]", "[?]", "[?]", "f", "v", "u", "yr", "y", "w", "th", "th", "a", "o", "ac", "ae", "o", "o", "o", "oe", "on", "r", "k", "c", "k", "g", "ng", "g", "g", "w", "h", "h", "h", "h", "n", "n", "n", "i", "e", "j", "g", "ae", "a", "eo", "p", "z", "s", "s", "s", "c", "z", "t", "t", "d", "b", "b", "p", "p", "e", "m", "m", "m", "l", "l", "ng", "ng", "d", "o", "ear", "ior", "qu", "qu", "qu", "s", "yr", "yr", "yr", "q", "x", ".", ":", "+", "17", "18", "19", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x17.js
var require_x17 = __commonJS({
  "node_modules/unidecode/data/x17.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "t", "tth", "d", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "y", "r", "l", "v", "sh", "ss", "s", "h", "l", "q", "a", "aa", "i", "ii", "u", "uk", "uu", "uuv", "ry", "ryy", "ly", "lyy", "e", "ai", "oo", "oo", "au", "a", "aa", "aa", "i", "ii", "y", "yy", "u", "uu", "ua", "oe", "ya", "ie", "e", "ae", "ai", "oo", "au", "M", "H", "a`", "", "", "", "r", "", "!", "", "", "", "", "", ".", " // ", ":", "+", "++", " * ", " /// ", "KR", "'", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x18.js
var require_x18 = __commonJS({
  "node_modules/unidecode/data/x18.js"(exports2, module2) {
    module2.exports = [" @ ", " ... ", ", ", ". ", ": ", " // ", "", "-", ", ", ". ", "", "", "", "", "", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "e", "i", "o", "u", "O", "U", "ee", "n", "ng", "b", "p", "q", "g", "m", "l", "s", "sh", "t", "d", "ch", "j", "y", "r", "w", "f", "k", "kha", "ts", "z", "h", "zr", "lh", "zh", "ch", "-", "e", "i", "o", "u", "O", "U", "ng", "b", "p", "q", "g", "m", "t", "d", "ch", "j", "ts", "y", "w", "k", "g", "h", "jy", "ny", "dz", "e", "i", "iy", "U", "u", "ng", "k", "g", "h", "p", "sh", "t", "d", "j", "f", "g", "h", "ts", "z", "r", "ch", "zh", "i", "k", "r", "f", "zh", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "H", "X", "W", "M", " 3 ", " 333 ", "a", "i", "k", "ng", "c", "tt", "tth", "dd", "nn", "t", "d", "p", "ph", "ss", "zh", "z", "a", "t", "zh", "gh", "ng", "c", "jh", "tta", "ddh", "t", "dh", "ss", "cy", "zh", "z", "u", "y", "bh", "'", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x1e.js
var require_x1e = __commonJS({
  "node_modules/unidecode/data/x1e.js"(exports2, module2) {
    module2.exports = ["A", "a", "B", "b", "B", "b", "B", "b", "C", "c", "D", "d", "D", "d", "D", "d", "D", "d", "D", "d", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "F", "f", "G", "g", "H", "h", "H", "h", "H", "h", "H", "h", "H", "h", "I", "i", "I", "i", "K", "k", "K", "k", "K", "k", "L", "l", "L", "l", "L", "l", "L", "l", "M", "m", "M", "m", "M", "m", "N", "n", "N", "n", "N", "n", "N", "n", "O", "o", "O", "o", "O", "o", "O", "o", "P", "p", "P", "p", "R", "r", "R", "r", "R", "r", "R", "r", "S", "s", "S", "s", "S", "s", "S", "s", "S", "s", "T", "t", "T", "t", "T", "t", "T", "t", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "V", "v", "V", "v", "W", "w", "W", "w", "W", "w", "W", "w", "W", "w", "X", "x", "X", "x", "Y", "y", "Z", "z", "Z", "z", "Z", "z", "h", "t", "w", "y", "a", "S", "[?]", "[?]", "[?]", "[?]", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "I", "i", "I", "i", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "Y", "y", "Y", "y", "Y", "y", "Y", "y", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x1f.js
var require_x1f = __commonJS({
  "node_modules/unidecode/data/x1f.js"(exports2, module2) {
    module2.exports = ["a", "a", "a", "a", "a", "a", "a", "a", "A", "A", "A", "A", "A", "A", "A", "A", "e", "e", "e", "e", "e", "e", "[?]", "[?]", "E", "E", "E", "E", "E", "E", "[?]", "[?]", "e", "e", "e", "e", "e", "e", "e", "e", "E", "E", "E", "E", "E", "E", "E", "E", "i", "i", "i", "i", "i", "i", "i", "i", "I", "I", "I", "I", "I", "I", "I", "I", "o", "o", "o", "o", "o", "o", "[?]", "[?]", "O", "O", "O", "O", "O", "O", "[?]", "[?]", "u", "u", "u", "u", "u", "u", "u", "u", "[?]", "U", "[?]", "U", "[?]", "U", "[?]", "U", "o", "o", "o", "o", "o", "o", "o", "o", "O", "O", "O", "O", "O", "O", "O", "O", "a", "a", "e", "e", "e", "e", "i", "i", "o", "o", "u", "u", "o", "o", "[?]", "[?]", "a", "a", "a", "a", "a", "a", "a", "a", "A", "A", "A", "A", "A", "A", "A", "A", "e", "e", "e", "e", "e", "e", "e", "e", "E", "E", "E", "E", "E", "E", "E", "E", "o", "o", "o", "o", "o", "o", "o", "o", "O", "O", "O", "O", "O", "O", "O", "O", "a", "a", "a", "a", "a", "[?]", "a", "a", "A", "A", "A", "A", "A", "'", "i", "'", "~", '"~', "e", "e", "e", "[?]", "e", "e", "E", "E", "E", "E", "E", "'`", "''", "'~", "i", "i", "i", "i", "[?]", "[?]", "i", "i", "I", "I", "I", "I", "[?]", "`'", "`'", "`~", "u", "u", "u", "u", "R", "R", "u", "u", "U", "U", "U", "U", "R", '"`', `"'`, "`", "[?]", "[?]", "o", "o", "o", "[?]", "o", "o", "O", "O", "O", "O", "O", "'", "`"];
  }
});

// node_modules/unidecode/data/x20.js
var require_x20 = __commonJS({
  "node_modules/unidecode/data/x20.js"(exports2, module2) {
    module2.exports = [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "", "", "", "", "-", "-", "-", "-", "--", "--", "||", "_", "'", "'", ",", "'", '"', '"', ",,", '"', "+", "++", "*", "*>", ".", "..", "...", ".", "\n", "\n\n", "", "", "", "", "", " ", "%0", "%00", "'", "''", "'''", "`", "``", "```", "^", "<", ">", "*", "!!", "!?", "-", "_", "-", "^", "***", "--", "/", "-[", "]-", "[?]", "?!", "!?", "7", "PP", "(]", "[)", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "0", "", "", "", "4", "5", "6", "7", "8", "9", "+", "-", "=", "(", ")", "n", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "-", "=", "(", ")", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "ECU", "CL", "Cr", "FF", "L", "mil", "N", "Pts", "Rs", "W", "NS", "D", "EU", "K", "T", "Dr", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x21.js
var require_x21 = __commonJS({
  "node_modules/unidecode/data/x21.js"(exports2, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", " 1/3 ", " 2/3 ", " 1/5 ", " 2/5 ", " 3/5 ", " 4/5 ", " 1/6 ", " 5/6 ", " 1/8 ", " 3/8 ", " 5/8 ", " 7/8 ", " 1/", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "L", "C", "D", "M", "i", "ii", "iii", "iv", "v", "vi", "vii", "viii", "ix", "x", "xi", "xii", "l", "c", "d", "m", "(D", "D)", "((|))", ")", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "-", "|", "-", "|", "-", "|", "\\", "/", "\\", "/", "-", "-", "~", "~", "-", "|", "-", "|", "-", "-", "-", "|", "-", "|", "|", "-", "-", "-", "-", "-", "-", "|", "|", "|", "|", "|", "|", "|", "^", "V", "\\", "=", "V", "^", "-", "-", "|", "|", "-", "-", "|", "|", "=", "|", "=", "=", "|", "=", "|", "=", "=", "=", "=", "=", "=", "|", "=", "|", "=", "|", "\\", "/", "\\", "/", "=", "=", "~", "~", "|", "|", "-", "|", "-", "|", "-", "-", "-", "|", "-", "|", "|", "|", "|", "|", "|", "|", "-", "\\", "\\", "|", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x22.js
var require_x22 = __commonJS({
  "node_modules/unidecode/data/x22.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x23.js
var require_x23 = __commonJS({
  "node_modules/unidecode/data/x23.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x24.js
var require_x24 = __commonJS({
  "node_modules/unidecode/data/x24.js"(exports2, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x25.js
var require_x25 = __commonJS({
  "node_modules/unidecode/data/x25.js"(exports2, module2) {
    module2.exports = ["-", "-", "|", "|", "-", "-", "|", "|", "-", "-", "|", "|", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "-", "-", "|", "|", "-", "|", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "/", "\\", "X", "-", "|", "-", "|", "-", "|", "-", "|", "-", "|", "-", "|", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "-", "|", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "^", "^", "^", "^", ">", ">", ">", ">", ">", ">", "V", "V", "V", "V", "<", "<", "<", "<", "<", "<", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "#", "#", "#", "#", "#", "^", "^", "^", "O", "#", "#", "#", "#", "#", "#", "#", "#", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x26.js
var require_x26 = __commonJS({
  "node_modules/unidecode/data/x26.js"(exports2, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x27.js
var require_x27 = __commonJS({
  "node_modules/unidecode/data/x27.js"(exports2, module2) {
    module2.exports = ["[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x28.js
var require_x28 = __commonJS({
  "node_modules/unidecode/data/x28.js"(exports2, module2) {
    module2.exports = [" ", "a", "1", "b", "'", "k", "2", "l", "@", "c", "i", "f", "/", "m", "s", "p", '"', "e", "3", "h", "9", "o", "6", "r", "^", "d", "j", "g", ">", "n", "t", "q", ",", "*", "5", "<", "-", "u", "8", "v", ".", "%", "[", "$", "+", "x", "!", "&", ";", ":", "4", "\\", "0", "z", "7", "(", "_", "?", "w", "]", "#", "y", ")", "=", "[d7]", "[d17]", "[d27]", "[d127]", "[d37]", "[d137]", "[d237]", "[d1237]", "[d47]", "[d147]", "[d247]", "[d1247]", "[d347]", "[d1347]", "[d2347]", "[d12347]", "[d57]", "[d157]", "[d257]", "[d1257]", "[d357]", "[d1357]", "[d2357]", "[d12357]", "[d457]", "[d1457]", "[d2457]", "[d12457]", "[d3457]", "[d13457]", "[d23457]", "[d123457]", "[d67]", "[d167]", "[d267]", "[d1267]", "[d367]", "[d1367]", "[d2367]", "[d12367]", "[d467]", "[d1467]", "[d2467]", "[d12467]", "[d3467]", "[d13467]", "[d23467]", "[d123467]", "[d567]", "[d1567]", "[d2567]", "[d12567]", "[d3567]", "[d13567]", "[d23567]", "[d123567]", "[d4567]", "[d14567]", "[d24567]", "[d124567]", "[d34567]", "[d134567]", "[d234567]", "[d1234567]", "[d8]", "[d18]", "[d28]", "[d128]", "[d38]", "[d138]", "[d238]", "[d1238]", "[d48]", "[d148]", "[d248]", "[d1248]", "[d348]", "[d1348]", "[d2348]", "[d12348]", "[d58]", "[d158]", "[d258]", "[d1258]", "[d358]", "[d1358]", "[d2358]", "[d12358]", "[d458]", "[d1458]", "[d2458]", "[d12458]", "[d3458]", "[d13458]", "[d23458]", "[d123458]", "[d68]", "[d168]", "[d268]", "[d1268]", "[d368]", "[d1368]", "[d2368]", "[d12368]", "[d468]", "[d1468]", "[d2468]", "[d12468]", "[d3468]", "[d13468]", "[d23468]", "[d123468]", "[d568]", "[d1568]", "[d2568]", "[d12568]", "[d3568]", "[d13568]", "[d23568]", "[d123568]", "[d4568]", "[d14568]", "[d24568]", "[d124568]", "[d34568]", "[d134568]", "[d234568]", "[d1234568]", "[d78]", "[d178]", "[d278]", "[d1278]", "[d378]", "[d1378]", "[d2378]", "[d12378]", "[d478]", "[d1478]", "[d2478]", "[d12478]", "[d3478]", "[d13478]", "[d23478]", "[d123478]", "[d578]", "[d1578]", "[d2578]", "[d12578]", "[d3578]", "[d13578]", "[d23578]", "[d123578]", "[d4578]", "[d14578]", "[d24578]", "[d124578]", "[d34578]", "[d134578]", "[d234578]", "[d1234578]", "[d678]", "[d1678]", "[d2678]", "[d12678]", "[d3678]", "[d13678]", "[d23678]", "[d123678]", "[d4678]", "[d14678]", "[d24678]", "[d124678]", "[d34678]", "[d134678]", "[d234678]", "[d1234678]", "[d5678]", "[d15678]", "[d25678]", "[d125678]", "[d35678]", "[d135678]", "[d235678]", "[d1235678]", "[d45678]", "[d145678]", "[d245678]", "[d1245678]", "[d345678]", "[d1345678]", "[d2345678]", "[d12345678]"];
  }
});

// node_modules/unidecode/data/x2e.js
var require_x2e = __commonJS({
  "node_modules/unidecode/data/x2e.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x2f.js
var require_x2f = __commonJS({
  "node_modules/unidecode/data/x2f.js"(exports2, module2) {
    module2.exports = ["[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x30.js
var require_x30 = __commonJS({
  "node_modules/unidecode/data/x30.js"(exports2, module2) {
    module2.exports = [" ", ", ", ". ", '"', "[JIS]", '"', "/", "0", "<", "> ", "<<", ">> ", "[", "] ", "{", "} ", "[(", ")] ", "@", "X ", "[", "] ", "[[", "]] ", "((", ")) ", "[[", "]] ", "~ ", "``", "''", ",,", "@", "1", "2", "3", "4", "5", "6", "7", "8", "9", "", "", "", "", "", "", "~", "+", "+", "+", "+", "", "@", " // ", "+10+", "+20+", "+30+", "[?]", "[?]", "[?]", "", "", "[?]", "a", "a", "i", "i", "u", "u", "e", "e", "o", "o", "ka", "ga", "ki", "gi", "ku", "gu", "ke", "ge", "ko", "go", "sa", "za", "si", "zi", "su", "zu", "se", "ze", "so", "zo", "ta", "da", "ti", "di", "tu", "tu", "du", "te", "de", "to", "do", "na", "ni", "nu", "ne", "no", "ha", "ba", "pa", "hi", "bi", "pi", "hu", "bu", "pu", "he", "be", "pe", "ho", "bo", "po", "ma", "mi", "mu", "me", "mo", "ya", "ya", "yu", "yu", "yo", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wa", "wi", "we", "wo", "n", "vu", "[?]", "[?]", "[?]", "[?]", "", "", "", "", '"', '"', "[?]", "[?]", "a", "a", "i", "i", "u", "u", "e", "e", "o", "o", "ka", "ga", "ki", "gi", "ku", "gu", "ke", "ge", "ko", "go", "sa", "za", "si", "zi", "su", "zu", "se", "ze", "so", "zo", "ta", "da", "ti", "di", "tu", "tu", "du", "te", "de", "to", "do", "na", "ni", "nu", "ne", "no", "ha", "ba", "pa", "hi", "bi", "pi", "hu", "bu", "pu", "he", "be", "pe", "ho", "bo", "po", "ma", "mi", "mu", "me", "mo", "ya", "ya", "yu", "yu", "yo", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wa", "wi", "we", "wo", "n", "vu", "ka", "ke", "va", "vi", "ve", "vo", "", "", '"', '"'];
  }
});

// node_modules/unidecode/data/x31.js
var require_x31 = __commonJS({
  "node_modules/unidecode/data/x31.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "B", "P", "M", "F", "D", "T", "N", "L", "G", "K", "H", "J", "Q", "X", "ZH", "CH", "SH", "R", "Z", "C", "S", "A", "O", "E", "EH", "AI", "EI", "AU", "OU", "AN", "EN", "ANG", "ENG", "ER", "I", "U", "IU", "V", "NG", "GN", "[?]", "[?]", "[?]", "[?]", "g", "gg", "gs", "n", "nj", "nh", "d", "dd", "r", "lg", "lm", "lb", "ls", "lt", "lp", "rh", "m", "b", "bb", "bs", "s", "ss", "", "j", "jj", "c", "k", "t", "p", "h", "a", "ae", "ya", "yae", "eo", "e", "yeo", "ye", "o", "wa", "wae", "oe", "yo", "u", "weo", "we", "wi", "yu", "eu", "yi", "i", "", "nn", "nd", "ns", "nZ", "lgs", "ld", "lbs", "lZ", "lQ", "mb", "ms", "mZ", "mN", "bg", "", "bsg", "bst", "bj", "bt", "bN", "bbN", "sg", "sn", "sd", "sb", "sj", "Z", "", "N", "Ns", "NZ", "pN", "hh", "Q", "yo-ya", "yo-yae", "yo-i", "yu-yeo", "yu-ye", "yu-i", "U", "U-i", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "BU", "ZI", "JI", "GU", "EE", "ENN", "OO", "ONN", "IR", "ANN", "INN", "UNN", "IM", "NGG", "AINN", "AUNN", "AM", "OM", "ONG", "INNN", "P", "T", "K", "H", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x32.js
var require_x32 = __commonJS({
  "node_modules/unidecode/data/x32.js"(exports2, module2) {
    module2.exports = ["(g)", "(n)", "(d)", "(r)", "(m)", "(b)", "(s)", "()", "(j)", "(c)", "(k)", "(t)", "(p)", "(h)", "(ga)", "(na)", "(da)", "(ra)", "(ma)", "(ba)", "(sa)", "(a)", "(ja)", "(ca)", "(ka)", "(ta)", "(pa)", "(ha)", "(ju)", "[?]", "[?]", "[?]", "(1) ", "(2) ", "(3) ", "(4) ", "(5) ", "(6) ", "(7) ", "(8) ", "(9) ", "(10) ", "(Yue) ", "(Huo) ", "(Shui) ", "(Mu) ", "(Jin) ", "(Tu) ", "(Ri) ", "(Zhu) ", "(You) ", "(She) ", "(Ming) ", "(Te) ", "(Cai) ", "(Zhu) ", "(Lao) ", "(Dai) ", "(Hu) ", "(Xue) ", "(Jian) ", "(Qi) ", "(Zi) ", "(Xie) ", "(Ji) ", "(Xiu) ", "<<", ">>", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "(g)", "(n)", "(d)", "(r)", "(m)", "(b)", "(s)", "()", "(j)", "(c)", "(k)", "(t)", "(p)", "(h)", "(ga)", "(na)", "(da)", "(ra)", "(ma)", "(ba)", "(sa)", "(a)", "(ja)", "(ca)", "(ka)", "(ta)", "(pa)", "(ha)", "[?]", "[?]", "[?]", "KIS ", "(1) ", "(2) ", "(3) ", "(4) ", "(5) ", "(6) ", "(7) ", "(8) ", "(9) ", "(10) ", "(Yue) ", "(Huo) ", "(Shui) ", "(Mu) ", "(Jin) ", "(Tu) ", "(Ri) ", "(Zhu) ", "(You) ", "(She) ", "(Ming) ", "(Te) ", "(Cai) ", "(Zhu) ", "(Lao) ", "(Mi) ", "(Nan) ", "(Nu) ", "(Shi) ", "(You) ", "(Yin) ", "(Zhu) ", "(Xiang) ", "(Xiu) ", "(Xie) ", "(Zheng) ", "(Shang) ", "(Zhong) ", "(Xia) ", "(Zuo) ", "(You) ", "(Yi) ", "(Zong) ", "(Xue) ", "(Jian) ", "(Qi) ", "(Zi) ", "(Xie) ", "(Ye) ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "1M", "2M", "3M", "4M", "5M", "6M", "7M", "8M", "9M", "10M", "11M", "12M", "[?]", "[?]", "[?]", "[?]", "a", "i", "u", "u", "o", "ka", "ki", "ku", "ke", "ko", "sa", "si", "su", "se", "so", "ta", "ti", "tu", "te", "to", "na", "ni", "nu", "ne", "no", "ha", "hi", "hu", "he", "ho", "ma", "mi", "mu", "me", "mo", "ya", "yu", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wi", "we", "wo"];
  }
});

// node_modules/unidecode/data/x33.js
var require_x33 = __commonJS({
  "node_modules/unidecode/data/x33.js"(exports2, module2) {
    module2.exports = ["apartment", "alpha", "ampere", "are", "inning", "inch", "won", "escudo", "acre", "ounce", "ohm", "kai-ri", "carat", "calorie", "gallon", "gamma", "giga", "guinea", "curie", "guilder", "kilo", "kilogram", "kilometer", "kilowatt", "gram", "gram ton", "cruzeiro", "krone", "case", "koruna", "co-op", "cycle", "centime", "shilling", "centi", "cent", "dozen", "desi", "dollar", "ton", "nano", "knot", "heights", "percent", "parts", "barrel", "piaster", "picul", "pico", "building", "farad", "feet", "bushel", "franc", "hectare", "peso", "pfennig", "hertz", "pence", "page", "beta", "point", "volt", "hon", "pound", "hall", "horn", "micro", "mile", "mach", "mark", "mansion", "micron", "milli", "millibar", "mega", "megaton", "meter", "yard", "yard", "yuan", "liter", "lira", "rupee", "ruble", "rem", "roentgen", "watt", "0h", "1h", "2h", "3h", "4h", "5h", "6h", "7h", "8h", "9h", "10h", "11h", "12h", "13h", "14h", "15h", "16h", "17h", "18h", "19h", "20h", "21h", "22h", "23h", "24h", "HPA", "da", "AU", "bar", "oV", "pc", "[?]", "[?]", "[?]", "[?]", "Heisei", "Syouwa", "Taisyou", "Meiji", "Inc.", "pA", "nA", "microamp", "mA", "kA", "kB", "MB", "GB", "cal", "kcal", "pF", "nF", "microFarad", "microgram", "mg", "kg", "Hz", "kHz", "MHz", "GHz", "THz", "microliter", "ml", "dl", "kl", "fm", "nm", "micrometer", "mm", "cm", "km", "mm^2", "cm^2", "m^2", "km^2", "mm^4", "cm^3", "m^3", "km^3", "m/s", "m/s^2", "Pa", "kPa", "MPa", "GPa", "rad", "rad/s", "rad/s^2", "ps", "ns", "microsecond", "ms", "pV", "nV", "microvolt", "mV", "kV", "MV", "pW", "nW", "microwatt", "mW", "kW", "MW", "kOhm", "MOhm", "a.m.", "Bq", "cc", "cd", "C/kg", "Co.", "dB", "Gy", "ha", "HP", "in", "K.K.", "KM", "kt", "lm", "ln", "log", "lx", "mb", "mil", "mol", "pH", "p.m.", "PPM", "PR", "sr", "Sv", "Wb", "[?]", "[?]", "1d", "2d", "3d", "4d", "5d", "6d", "7d", "8d", "9d", "10d", "11d", "12d", "13d", "14d", "15d", "16d", "17d", "18d", "19d", "20d", "21d", "22d", "23d", "24d", "25d", "26d", "27d", "28d", "29d", "30d", "31d"];
  }
});

// node_modules/unidecode/data/x4d.js
var require_x4d = __commonJS({
  "node_modules/unidecode/data/x4d.js"(exports2, module2) {
    module2.exports = ["[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x4e.js
var require_x4e = __commonJS({
  "node_modules/unidecode/data/x4e.js"(exports2, module2) {
    module2.exports = ["Yi ", "Ding ", "Kao ", "Qi ", "Shang ", "Xia ", "[?] ", "Mo ", "Zhang ", "San ", "Shang ", "Xia ", "Ji ", "Bu ", "Yu ", "Mian ", "Gai ", "Chou ", "Chou ", "Zhuan ", "Qie ", "Pi ", "Shi ", "Shi ", "Qiu ", "Bing ", "Ye ", "Cong ", "Dong ", "Si ", "Cheng ", "Diu ", "Qiu ", "Liang ", "Diu ", "You ", "Liang ", "Yan ", "Bing ", "Sang ", "Gun ", "Jiu ", "Ge ", "Ya ", "Qiang ", "Zhong ", "Ji ", "Jie ", "Feng ", "Guan ", "Chuan ", "Chan ", "Lin ", "Zhuo ", "Zhu ", "Ha ", "Wan ", "Dan ", "Wei ", "Zhu ", "Jing ", "Li ", "Ju ", "Pie ", "Fu ", "Yi ", "Yi ", "Nai ", "Shime ", "Jiu ", "Jiu ", "Zhe ", "Yao ", "Yi ", "[?] ", "Zhi ", "Wu ", "Zha ", "Hu ", "Fa ", "Le ", "Zhong ", "Ping ", "Pang ", "Qiao ", "Hu ", "Guai ", "Cheng ", "Cheng ", "Yi ", "Yin ", "[?] ", "Mie ", "Jiu ", "Qi ", "Ye ", "Xi ", "Xiang ", "Gai ", "Diu ", "Hal ", "[?] ", "Shu ", "Twul ", "Shi ", "Ji ", "Nang ", "Jia ", "Kel ", "Shi ", "[?] ", "Ol ", "Mai ", "Luan ", "Cal ", "Ru ", "Xue ", "Yan ", "Fu ", "Sha ", "Na ", "Gan ", "Sol ", "El ", "Cwul ", "[?] ", "Gan ", "Chi ", "Gui ", "Gan ", "Luan ", "Lin ", "Yi ", "Jue ", "Liao ", "Ma ", "Yu ", "Zheng ", "Shi ", "Shi ", "Er ", "Chu ", "Yu ", "Yu ", "Yu ", "Yun ", "Hu ", "Qi ", "Wu ", "Jing ", "Si ", "Sui ", "Gen ", "Gen ", "Ya ", "Xie ", "Ya ", "Qi ", "Ya ", "Ji ", "Tou ", "Wang ", "Kang ", "Ta ", "Jiao ", "Hai ", "Yi ", "Chan ", "Heng ", "Mu ", "[?] ", "Xiang ", "Jing ", "Ting ", "Liang ", "Xiang ", "Jing ", "Ye ", "Qin ", "Bo ", "You ", "Xie ", "Dan ", "Lian ", "Duo ", "Wei ", "Ren ", "Ren ", "Ji ", "La ", "Wang ", "Yi ", "Shi ", "Ren ", "Le ", "Ding ", "Ze ", "Jin ", "Pu ", "Chou ", "Ba ", "Zhang ", "Jin ", "Jie ", "Bing ", "Reng ", "Cong ", "Fo ", "San ", "Lun ", "Sya ", "Cang ", "Zi ", "Shi ", "Ta ", "Zhang ", "Fu ", "Xian ", "Xian ", "Tuo ", "Hong ", "Tong ", "Ren ", "Qian ", "Gan ", "Yi ", "Di ", "Dai ", "Ling ", "Yi ", "Chao ", "Chang ", "Sa ", "[?] ", "Yi ", "Mu ", "Men ", "Ren ", "Jia ", "Chao ", "Yang ", "Qian ", "Zhong ", "Pi ", "Wan ", "Wu ", "Jian ", "Jie ", "Yao ", "Feng ", "Cang ", "Ren ", "Wang ", "Fen ", "Di ", "Fang "];
  }
});

// node_modules/unidecode/data/x4f.js
var require_x4f = __commonJS({
  "node_modules/unidecode/data/x4f.js"(exports2, module2) {
    module2.exports = ["Zhong ", "Qi ", "Pei ", "Yu ", "Diao ", "Dun ", "Wen ", "Yi ", "Xin ", "Kang ", "Yi ", "Ji ", "Ai ", "Wu ", "Ji ", "Fu ", "Fa ", "Xiu ", "Jin ", "Bei ", "Dan ", "Fu ", "Tang ", "Zhong ", "You ", "Huo ", "Hui ", "Yu ", "Cui ", "Chuan ", "San ", "Wei ", "Chuan ", "Che ", "Ya ", "Xian ", "Shang ", "Chang ", "Lun ", "Cang ", "Xun ", "Xin ", "Wei ", "Zhu ", "[?] ", "Xuan ", "Nu ", "Bo ", "Gu ", "Ni ", "Ni ", "Xie ", "Ban ", "Xu ", "Ling ", "Zhou ", "Shen ", "Qu ", "Si ", "Beng ", "Si ", "Jia ", "Pi ", "Yi ", "Si ", "Ai ", "Zheng ", "Dian ", "Han ", "Mai ", "Dan ", "Zhu ", "Bu ", "Qu ", "Bi ", "Shao ", "Ci ", "Wei ", "Di ", "Zhu ", "Zuo ", "You ", "Yang ", "Ti ", "Zhan ", "He ", "Bi ", "Tuo ", "She ", "Yu ", "Yi ", "Fo ", "Zuo ", "Kou ", "Ning ", "Tong ", "Ni ", "Xuan ", "Qu ", "Yong ", "Wa ", "Qian ", "[?] ", "Ka ", "[?] ", "Pei ", "Huai ", "He ", "Lao ", "Xiang ", "Ge ", "Yang ", "Bai ", "Fa ", "Ming ", "Jia ", "Er ", "Bing ", "Ji ", "Hen ", "Huo ", "Gui ", "Quan ", "Tiao ", "Jiao ", "Ci ", "Yi ", "Shi ", "Xing ", "Shen ", "Tuo ", "Kan ", "Zhi ", "Gai ", "Lai ", "Yi ", "Chi ", "Kua ", "Guang ", "Li ", "Yin ", "Shi ", "Mi ", "Zhu ", "Xu ", "You ", "An ", "Lu ", "Mou ", "Er ", "Lun ", "Tong ", "Cha ", "Chi ", "Xun ", "Gong ", "Zhou ", "Yi ", "Ru ", "Jian ", "Xia ", "Jia ", "Zai ", "Lu ", "Ko ", "Jiao ", "Zhen ", "Ce ", "Qiao ", "Kuai ", "Chai ", "Ning ", "Nong ", "Jin ", "Wu ", "Hou ", "Jiong ", "Cheng ", "Zhen ", "Zuo ", "Chou ", "Qin ", "Lu ", "Ju ", "Shu ", "Ting ", "Shen ", "Tuo ", "Bo ", "Nan ", "Hao ", "Bian ", "Tui ", "Yu ", "Xi ", "Cu ", "E ", "Qiu ", "Xu ", "Kuang ", "Ku ", "Wu ", "Jun ", "Yi ", "Fu ", "Lang ", "Zu ", "Qiao ", "Li ", "Yong ", "Hun ", "Jing ", "Xian ", "San ", "Pai ", "Su ", "Fu ", "Xi ", "Li ", "Fu ", "Ping ", "Bao ", "Yu ", "Si ", "Xia ", "Xin ", "Xiu ", "Yu ", "Ti ", "Che ", "Chou ", "[?] ", "Yan ", "Lia ", "Li ", "Lai ", "[?] ", "Jian ", "Xiu ", "Fu ", "He ", "Ju ", "Xiao ", "Pai ", "Jian ", "Biao ", "Chu ", "Fei ", "Feng ", "Ya ", "An ", "Bei ", "Yu ", "Xin ", "Bi ", "Jian "];
  }
});

// node_modules/unidecode/data/x50.js
var require_x50 = __commonJS({
  "node_modules/unidecode/data/x50.js"(exports2, module2) {
    module2.exports = ["Chang ", "Chi ", "Bing ", "Zan ", "Yao ", "Cui ", "Lia ", "Wan ", "Lai ", "Cang ", "Zong ", "Ge ", "Guan ", "Bei ", "Tian ", "Shu ", "Shu ", "Men ", "Dao ", "Tan ", "Jue ", "Chui ", "Xing ", "Peng ", "Tang ", "Hou ", "Yi ", "Qi ", "Ti ", "Gan ", "Jing ", "Jie ", "Sui ", "Chang ", "Jie ", "Fang ", "Zhi ", "Kong ", "Juan ", "Zong ", "Ju ", "Qian ", "Ni ", "Lun ", "Zhuo ", "Wei ", "Luo ", "Song ", "Leng ", "Hun ", "Dong ", "Zi ", "Ben ", "Wu ", "Ju ", "Nai ", "Cai ", "Jian ", "Zhai ", "Ye ", "Zhi ", "Sha ", "Qing ", "[?] ", "Ying ", "Cheng ", "Jian ", "Yan ", "Nuan ", "Zhong ", "Chun ", "Jia ", "Jie ", "Wei ", "Yu ", "Bing ", "Ruo ", "Ti ", "Wei ", "Pian ", "Yan ", "Feng ", "Tang ", "Wo ", "E ", "Xie ", "Che ", "Sheng ", "Kan ", "Di ", "Zuo ", "Cha ", "Ting ", "Bei ", "Ye ", "Huang ", "Yao ", "Zhan ", "Chou ", "Yan ", "You ", "Jian ", "Xu ", "Zha ", "Ci ", "Fu ", "Bi ", "Zhi ", "Zong ", "Mian ", "Ji ", "Yi ", "Xie ", "Xun ", "Si ", "Duan ", "Ce ", "Zhen ", "Ou ", "Tou ", "Tou ", "Bei ", "Za ", "Lu ", "Jie ", "Wei ", "Fen ", "Chang ", "Gui ", "Sou ", "Zhi ", "Su ", "Xia ", "Fu ", "Yuan ", "Rong ", "Li ", "Ru ", "Yun ", "Gou ", "Ma ", "Bang ", "Dian ", "Tang ", "Hao ", "Jie ", "Xi ", "Shan ", "Qian ", "Jue ", "Cang ", "Chu ", "San ", "Bei ", "Xiao ", "Yong ", "Yao ", "Tan ", "Suo ", "Yang ", "Fa ", "Bing ", "Jia ", "Dai ", "Zai ", "Tang ", "[?] ", "Bin ", "Chu ", "Nuo ", "Can ", "Lei ", "Cui ", "Yong ", "Zao ", "Zong ", "Peng ", "Song ", "Ao ", "Chuan ", "Yu ", "Zhai ", "Cou ", "Shang ", "Qiang ", "Jing ", "Chi ", "Sha ", "Han ", "Zhang ", "Qing ", "Yan ", "Di ", "Xi ", "Lu ", "Bei ", "Piao ", "Jin ", "Lian ", "Lu ", "Man ", "Qian ", "Xian ", "Tan ", "Ying ", "Dong ", "Zhuan ", "Xiang ", "Shan ", "Qiao ", "Jiong ", "Tui ", "Zun ", "Pu ", "Xi ", "Lao ", "Chang ", "Guang ", "Liao ", "Qi ", "Deng ", "Chan ", "Wei ", "Ji ", "Fan ", "Hui ", "Chuan ", "Jian ", "Dan ", "Jiao ", "Jiu ", "Seng ", "Fen ", "Xian ", "Jue ", "E ", "Jiao ", "Jian ", "Tong ", "Lin ", "Bo ", "Gu ", "[?] ", "Su ", "Xian ", "Jiang ", "Min ", "Ye ", "Jin ", "Jia ", "Qiao ", "Pi ", "Feng ", "Zhou ", "Ai ", "Sai "];
  }
});

// node_modules/unidecode/data/x51.js
var require_x51 = __commonJS({
  "node_modules/unidecode/data/x51.js"(exports2, module2) {
    module2.exports = ["Yi ", "Jun ", "Nong ", "Chan ", "Yi ", "Dang ", "Jing ", "Xuan ", "Kuai ", "Jian ", "Chu ", "Dan ", "Jiao ", "Sha ", "Zai ", "[?] ", "Bin ", "An ", "Ru ", "Tai ", "Chou ", "Chai ", "Lan ", "Ni ", "Jin ", "Qian ", "Meng ", "Wu ", "Ning ", "Qiong ", "Ni ", "Chang ", "Lie ", "Lei ", "Lu ", "Kuang ", "Bao ", "Du ", "Biao ", "Zan ", "Zhi ", "Si ", "You ", "Hao ", "Chen ", "Chen ", "Li ", "Teng ", "Wei ", "Long ", "Chu ", "Chan ", "Rang ", "Shu ", "Hui ", "Li ", "Luo ", "Zan ", "Nuo ", "Tang ", "Yan ", "Lei ", "Nang ", "Er ", "Wu ", "Yun ", "Zan ", "Yuan ", "Xiong ", "Chong ", "Zhao ", "Xiong ", "Xian ", "Guang ", "Dui ", "Ke ", "Dui ", "Mian ", "Tu ", "Chang ", "Er ", "Dui ", "Er ", "Xin ", "Tu ", "Si ", "Yan ", "Yan ", "Shi ", "Shi ", "Dang ", "Qian ", "Dou ", "Fen ", "Mao ", "Shen ", "Dou ", "Bai ", "Jing ", "Li ", "Huang ", "Ru ", "Wang ", "Nei ", "Quan ", "Liang ", "Yu ", "Ba ", "Gong ", "Liu ", "Xi ", "[?] ", "Lan ", "Gong ", "Tian ", "Guan ", "Xing ", "Bing ", "Qi ", "Ju ", "Dian ", "Zi ", "Ppwun ", "Yang ", "Jian ", "Shou ", "Ji ", "Yi ", "Ji ", "Chan ", "Jiong ", "Mao ", "Ran ", "Nei ", "Yuan ", "Mao ", "Gang ", "Ran ", "Ce ", "Jiong ", "Ce ", "Zai ", "Gua ", "Jiong ", "Mao ", "Zhou ", "Mou ", "Gou ", "Xu ", "Mian ", "Mi ", "Rong ", "Yin ", "Xie ", "Kan ", "Jun ", "Nong ", "Yi ", "Mi ", "Shi ", "Guan ", "Meng ", "Zhong ", "Ju ", "Yuan ", "Ming ", "Kou ", "Lam ", "Fu ", "Xie ", "Mi ", "Bing ", "Dong ", "Tai ", "Gang ", "Feng ", "Bing ", "Hu ", "Chong ", "Jue ", "Hu ", "Kuang ", "Ye ", "Leng ", "Pan ", "Fu ", "Min ", "Dong ", "Xian ", "Lie ", "Xia ", "Jian ", "Jing ", "Shu ", "Mei ", "Tu ", "Qi ", "Gu ", "Zhun ", "Song ", "Jing ", "Liang ", "Qing ", "Diao ", "Ling ", "Dong ", "Gan ", "Jian ", "Yin ", "Cou ", "Yi ", "Li ", "Cang ", "Ming ", "Zhuen ", "Cui ", "Si ", "Duo ", "Jin ", "Lin ", "Lin ", "Ning ", "Xi ", "Du ", "Ji ", "Fan ", "Fan ", "Fan ", "Feng ", "Ju ", "Chu ", "Tako ", "Feng ", "Mok ", "Ci ", "Fu ", "Feng ", "Ping ", "Feng ", "Kai ", "Huang ", "Kai ", "Gan ", "Deng ", "Ping ", "Qu ", "Xiong ", "Kuai ", "Tu ", "Ao ", "Chu ", "Ji ", "Dang ", "Han ", "Han ", "Zao "];
  }
});

// node_modules/unidecode/data/x52.js
var require_x52 = __commonJS({
  "node_modules/unidecode/data/x52.js"(exports2, module2) {
    module2.exports = ["Dao ", "Diao ", "Dao ", "Ren ", "Ren ", "Chuang ", "Fen ", "Qie ", "Yi ", "Ji ", "Kan ", "Qian ", "Cun ", "Chu ", "Wen ", "Ji ", "Dan ", "Xing ", "Hua ", "Wan ", "Jue ", "Li ", "Yue ", "Lie ", "Liu ", "Ze ", "Gang ", "Chuang ", "Fu ", "Chu ", "Qu ", "Ju ", "Shan ", "Min ", "Ling ", "Zhong ", "Pan ", "Bie ", "Jie ", "Jie ", "Bao ", "Li ", "Shan ", "Bie ", "Chan ", "Jing ", "Gua ", "Gen ", "Dao ", "Chuang ", "Kui ", "Ku ", "Duo ", "Er ", "Zhi ", "Shua ", "Quan ", "Cha ", "Ci ", "Ke ", "Jie ", "Gui ", "Ci ", "Gui ", "Kai ", "Duo ", "Ji ", "Ti ", "Jing ", "Lou ", "Gen ", "Ze ", "Yuan ", "Cuo ", "Xue ", "Ke ", "La ", "Qian ", "Cha ", "Chuang ", "Gua ", "Jian ", "Cuo ", "Li ", "Ti ", "Fei ", "Pou ", "Chan ", "Qi ", "Chuang ", "Zi ", "Gang ", "Wan ", "Bo ", "Ji ", "Duo ", "Qing ", "Yan ", "Zhuo ", "Jian ", "Ji ", "Bo ", "Yan ", "Ju ", "Huo ", "Sheng ", "Jian ", "Duo ", "Duan ", "Wu ", "Gua ", "Fu ", "Sheng ", "Jian ", "Ge ", "Zha ", "Kai ", "Chuang ", "Juan ", "Chan ", "Tuan ", "Lu ", "Li ", "Fou ", "Shan ", "Piao ", "Kou ", "Jiao ", "Gua ", "Qiao ", "Jue ", "Hua ", "Zha ", "Zhuo ", "Lian ", "Ju ", "Pi ", "Liu ", "Gui ", "Jiao ", "Gui ", "Jian ", "Jian ", "Tang ", "Huo ", "Ji ", "Jian ", "Yi ", "Jian ", "Zhi ", "Chan ", "Cuan ", "Mo ", "Li ", "Zhu ", "Li ", "Ya ", "Quan ", "Ban ", "Gong ", "Jia ", "Wu ", "Mai ", "Lie ", "Jin ", "Keng ", "Xie ", "Zhi ", "Dong ", "Zhu ", "Nu ", "Jie ", "Qu ", "Shao ", "Yi ", "Zhu ", "Miao ", "Li ", "Jing ", "Lao ", "Lao ", "Juan ", "Kou ", "Yang ", "Wa ", "Xiao ", "Mou ", "Kuang ", "Jie ", "Lie ", "He ", "Shi ", "Ke ", "Jing ", "Hao ", "Bo ", "Min ", "Chi ", "Lang ", "Yong ", "Yong ", "Mian ", "Ke ", "Xun ", "Juan ", "Qing ", "Lu ", "Pou ", "Meng ", "Lai ", "Le ", "Kai ", "Mian ", "Dong ", "Xu ", "Xu ", "Kan ", "Wu ", "Yi ", "Xun ", "Weng ", "Sheng ", "Lao ", "Mu ", "Lu ", "Piao ", "Shi ", "Ji ", "Qin ", "Qiang ", "Jiao ", "Quan ", "Yang ", "Yi ", "Jue ", "Fan ", "Juan ", "Tong ", "Ju ", "Dan ", "Xie ", "Mai ", "Xun ", "Xun ", "Lu ", "Li ", "Che ", "Rang ", "Quan ", "Bao ", "Shao ", "Yun ", "Jiu ", "Bao ", "Gou ", "Wu "];
  }
});

// node_modules/unidecode/data/x53.js
var require_x53 = __commonJS({
  "node_modules/unidecode/data/x53.js"(exports2, module2) {
    module2.exports = ["Yun ", "Mwun ", "Nay ", "Gai ", "Gai ", "Bao ", "Cong ", "[?] ", "Xiong ", "Peng ", "Ju ", "Tao ", "Ge ", "Pu ", "An ", "Pao ", "Fu ", "Gong ", "Da ", "Jiu ", "Qiong ", "Bi ", "Hua ", "Bei ", "Nao ", "Chi ", "Fang ", "Jiu ", "Yi ", "Za ", "Jiang ", "Kang ", "Jiang ", "Kuang ", "Hu ", "Xia ", "Qu ", "Bian ", "Gui ", "Qie ", "Zang ", "Kuang ", "Fei ", "Hu ", "Tou ", "Gui ", "Gui ", "Hui ", "Dan ", "Gui ", "Lian ", "Lian ", "Suan ", "Du ", "Jiu ", "Qu ", "Xi ", "Pi ", "Qu ", "Yi ", "Qia ", "Yan ", "Bian ", "Ni ", "Qu ", "Shi ", "Xin ", "Qian ", "Nian ", "Sa ", "Zu ", "Sheng ", "Wu ", "Hui ", "Ban ", "Shi ", "Xi ", "Wan ", "Hua ", "Xie ", "Wan ", "Bei ", "Zu ", "Zhuo ", "Xie ", "Dan ", "Mai ", "Nan ", "Dan ", "Ji ", "Bo ", "Shuai ", "Bu ", "Kuang ", "Bian ", "Bu ", "Zhan ", "Qia ", "Lu ", "You ", "Lu ", "Xi ", "Gua ", "Wo ", "Xie ", "Jie ", "Jie ", "Wei ", "Ang ", "Qiong ", "Zhi ", "Mao ", "Yin ", "Wei ", "Shao ", "Ji ", "Que ", "Luan ", "Shi ", "Juan ", "Xie ", "Xu ", "Jin ", "Que ", "Wu ", "Ji ", "E ", "Qing ", "Xi ", "[?] ", "Han ", "Zhan ", "E ", "Ting ", "Li ", "Zhe ", "Han ", "Li ", "Ya ", "Ya ", "Yan ", "She ", "Zhi ", "Zha ", "Pang ", "[?] ", "He ", "Ya ", "Zhi ", "Ce ", "Pang ", "Ti ", "Li ", "She ", "Hou ", "Ting ", "Zui ", "Cuo ", "Fei ", "Yuan ", "Ce ", "Yuan ", "Xiang ", "Yan ", "Li ", "Jue ", "Sha ", "Dian ", "Chu ", "Jiu ", "Qin ", "Ao ", "Gui ", "Yan ", "Si ", "Li ", "Chang ", "Lan ", "Li ", "Yan ", "Yan ", "Yuan ", "Si ", "Gong ", "Lin ", "Qiu ", "Qu ", "Qu ", "Uk ", "Lei ", "Du ", "Xian ", "Zhuan ", "San ", "Can ", "Can ", "Can ", "Can ", "Ai ", "Dai ", "You ", "Cha ", "Ji ", "You ", "Shuang ", "Fan ", "Shou ", "Guai ", "Ba ", "Fa ", "Ruo ", "Shi ", "Shu ", "Zhuo ", "Qu ", "Shou ", "Bian ", "Xu ", "Jia ", "Pan ", "Sou ", "Gao ", "Wei ", "Sou ", "Die ", "Rui ", "Cong ", "Kou ", "Gu ", "Ju ", "Ling ", "Gua ", "Tao ", "Kou ", "Zhi ", "Jiao ", "Zhao ", "Ba ", "Ding ", "Ke ", "Tai ", "Chi ", "Shi ", "You ", "Qiu ", "Po ", "Xie ", "Hao ", "Si ", "Tan ", "Chi ", "Le ", "Diao ", "Ji ", "[?] ", "Hong "];
  }
});

// node_modules/unidecode/data/x54.js
var require_x54 = __commonJS({
  "node_modules/unidecode/data/x54.js"(exports2, module2) {
    module2.exports = ["Mie ", "Xu ", "Mang ", "Chi ", "Ge ", "Xuan ", "Yao ", "Zi ", "He ", "Ji ", "Diao ", "Cun ", "Tong ", "Ming ", "Hou ", "Li ", "Tu ", "Xiang ", "Zha ", "Xia ", "Ye ", "Lu ", "A ", "Ma ", "Ou ", "Xue ", "Yi ", "Jun ", "Chou ", "Lin ", "Tun ", "Yin ", "Fei ", "Bi ", "Qin ", "Qin ", "Jie ", "Bu ", "Fou ", "Ba ", "Dun ", "Fen ", "E ", "Han ", "Ting ", "Hang ", "Shun ", "Qi ", "Hong ", "Zhi ", "Shen ", "Wu ", "Wu ", "Chao ", "Ne ", "Xue ", "Xi ", "Chui ", "Dou ", "Wen ", "Hou ", "Ou ", "Wu ", "Gao ", "Ya ", "Jun ", "Lu ", "E ", "Ge ", "Mei ", "Ai ", "Qi ", "Cheng ", "Wu ", "Gao ", "Fu ", "Jiao ", "Hong ", "Chi ", "Sheng ", "Ne ", "Tun ", "Fu ", "Yi ", "Dai ", "Ou ", "Li ", "Bai ", "Yuan ", "Kuai ", "[?] ", "Qiang ", "Wu ", "E ", "Shi ", "Quan ", "Pen ", "Wen ", "Ni ", "M ", "Ling ", "Ran ", "You ", "Di ", "Zhou ", "Shi ", "Zhou ", "Tie ", "Xi ", "Yi ", "Qi ", "Ping ", "Zi ", "Gu ", "Zi ", "Wei ", "Xu ", "He ", "Nao ", "Xia ", "Pei ", "Yi ", "Xiao ", "Shen ", "Hu ", "Ming ", "Da ", "Qu ", "Ju ", "Gem ", "Za ", "Tuo ", "Duo ", "Pou ", "Pao ", "Bi ", "Fu ", "Yang ", "He ", "Zha ", "He ", "Hai ", "Jiu ", "Yong ", "Fu ", "Que ", "Zhou ", "Wa ", "Ka ", "Gu ", "Ka ", "Zuo ", "Bu ", "Long ", "Dong ", "Ning ", "Tha ", "Si ", "Xian ", "Huo ", "Qi ", "Er ", "E ", "Guang ", "Zha ", "Xi ", "Yi ", "Lie ", "Zi ", "Mie ", "Mi ", "Zhi ", "Yao ", "Ji ", "Zhou ", "Ge ", "Shuai ", "Zan ", "Xiao ", "Ke ", "Hui ", "Kua ", "Huai ", "Tao ", "Xian ", "E ", "Xuan ", "Xiu ", "Wai ", "Yan ", "Lao ", "Yi ", "Ai ", "Pin ", "Shen ", "Tong ", "Hong ", "Xiong ", "Chi ", "Wa ", "Ha ", "Zai ", "Yu ", "Di ", "Pai ", "Xiang ", "Ai ", "Hen ", "Kuang ", "Ya ", "Da ", "Xiao ", "Bi ", "Yue ", "[?] ", "Hua ", "Sasou ", "Kuai ", "Duo ", "[?] ", "Ji ", "Nong ", "Mou ", "Yo ", "Hao ", "Yuan ", "Long ", "Pou ", "Mang ", "Ge ", "E ", "Chi ", "Shao ", "Li ", "Na ", "Zu ", "He ", "Ku ", "Xiao ", "Xian ", "Lao ", "Bo ", "Zhe ", "Zha ", "Liang ", "Ba ", "Mie ", "Le ", "Sui ", "Fou ", "Bu ", "Han ", "Heng ", "Geng ", "Shuo ", "Ge "];
  }
});

// node_modules/unidecode/data/x55.js
var require_x55 = __commonJS({
  "node_modules/unidecode/data/x55.js"(exports2, module2) {
    module2.exports = ["You ", "Yan ", "Gu ", "Gu ", "Bai ", "Han ", "Suo ", "Chun ", "Yi ", "Ai ", "Jia ", "Tu ", "Xian ", "Huan ", "Li ", "Xi ", "Tang ", "Zuo ", "Qiu ", "Che ", "Wu ", "Zao ", "Ya ", "Dou ", "Qi ", "Di ", "Qin ", "Ma ", "Mal ", "Hong ", "Dou ", "Kes ", "Lao ", "Liang ", "Suo ", "Zao ", "Huan ", "Lang ", "Sha ", "Ji ", "Zuo ", "Wo ", "Feng ", "Yin ", "Hu ", "Qi ", "Shou ", "Wei ", "Shua ", "Chang ", "Er ", "Li ", "Qiang ", "An ", "Jie ", "Yo ", "Nian ", "Yu ", "Tian ", "Lai ", "Sha ", "Xi ", "Tuo ", "Hu ", "Ai ", "Zhou ", "Nou ", "Ken ", "Zhuo ", "Zhuo ", "Shang ", "Di ", "Heng ", "Lan ", "A ", "Xiao ", "Xiang ", "Tun ", "Wu ", "Wen ", "Cui ", "Sha ", "Hu ", "Qi ", "Qi ", "Tao ", "Dan ", "Dan ", "Ye ", "Zi ", "Bi ", "Cui ", "Chuo ", "He ", "Ya ", "Qi ", "Zhe ", "Pei ", "Liang ", "Xian ", "Pi ", "Sha ", "La ", "Ze ", "Qing ", "Gua ", "Pa ", "Zhe ", "Se ", "Zhuan ", "Nie ", "Guo ", "Luo ", "Yan ", "Di ", "Quan ", "Tan ", "Bo ", "Ding ", "Lang ", "Xiao ", "[?] ", "Tang ", "Chi ", "Ti ", "An ", "Jiu ", "Dan ", "Ke ", "Yong ", "Wei ", "Nan ", "Shan ", "Yu ", "Zhe ", "La ", "Jie ", "Hou ", "Han ", "Die ", "Zhou ", "Chai ", "Wai ", "Re ", "Yu ", "Yin ", "Zan ", "Yao ", "Wo ", "Mian ", "Hu ", "Yun ", "Chuan ", "Hui ", "Huan ", "Huan ", "Xi ", "He ", "Ji ", "Kui ", "Zhong ", "Wei ", "Sha ", "Xu ", "Huang ", "Du ", "Nie ", "Xuan ", "Liang ", "Yu ", "Sang ", "Chi ", "Qiao ", "Yan ", "Dan ", "Pen ", "Can ", "Li ", "Yo ", "Zha ", "Wei ", "Miao ", "Ying ", "Pen ", "Phos ", "Kui ", "Xi ", "Yu ", "Jie ", "Lou ", "Ku ", "Sao ", "Huo ", "Ti ", "Yao ", "He ", "A ", "Xiu ", "Qiang ", "Se ", "Yong ", "Su ", "Hong ", "Xie ", "Yi ", "Suo ", "Ma ", "Cha ", "Hai ", "Ke ", "Ta ", "Sang ", "Tian ", "Ru ", "Sou ", "Wa ", "Ji ", "Pang ", "Wu ", "Xian ", "Shi ", "Ge ", "Zi ", "Jie ", "Luo ", "Weng ", "Wa ", "Si ", "Chi ", "Hao ", "Suo ", "Jia ", "Hai ", "Suo ", "Qin ", "Nie ", "He ", "Cis ", "Sai ", "Ng ", "Ge ", "Na ", "Dia ", "Ai ", "[?] ", "Tong ", "Bi ", "Ao ", "Ao ", "Lian ", "Cui ", "Zhe ", "Mo ", "Sou ", "Sou ", "Tan "];
  }
});

// node_modules/unidecode/data/x56.js
var require_x56 = __commonJS({
  "node_modules/unidecode/data/x56.js"(exports2, module2) {
    module2.exports = ["Di ", "Qi ", "Jiao ", "Chong ", "Jiao ", "Kai ", "Tan ", "San ", "Cao ", "Jia ", "Ai ", "Xiao ", "Piao ", "Lou ", "Ga ", "Gu ", "Xiao ", "Hu ", "Hui ", "Guo ", "Ou ", "Xian ", "Ze ", "Chang ", "Xu ", "Po ", "De ", "Ma ", "Ma ", "Hu ", "Lei ", "Du ", "Ga ", "Tang ", "Ye ", "Beng ", "Ying ", "Saai ", "Jiao ", "Mi ", "Xiao ", "Hua ", "Mai ", "Ran ", "Zuo ", "Peng ", "Lao ", "Xiao ", "Ji ", "Zhu ", "Chao ", "Kui ", "Zui ", "Xiao ", "Si ", "Hao ", "Fu ", "Liao ", "Qiao ", "Xi ", "Xiu ", "Tan ", "Tan ", "Mo ", "Xun ", "E ", "Zun ", "Fan ", "Chi ", "Hui ", "Zan ", "Chuang ", "Cu ", "Dan ", "Yu ", "Tun ", "Cheng ", "Jiao ", "Ye ", "Xi ", "Qi ", "Hao ", "Lian ", "Xu ", "Deng ", "Hui ", "Yin ", "Pu ", "Jue ", "Qin ", "Xun ", "Nie ", "Lu ", "Si ", "Yan ", "Ying ", "Da ", "Dan ", "Yu ", "Zhou ", "Jin ", "Nong ", "Yue ", "Hui ", "Qi ", "E ", "Zao ", "Yi ", "Shi ", "Jiao ", "Yuan ", "Ai ", "Yong ", "Jue ", "Kuai ", "Yu ", "Pen ", "Dao ", "Ge ", "Xin ", "Dun ", "Dang ", "Sin ", "Sai ", "Pi ", "Pi ", "Yin ", "Zui ", "Ning ", "Di ", "Lan ", "Ta ", "Huo ", "Ru ", "Hao ", "Xia ", "Ya ", "Duo ", "Xi ", "Chou ", "Ji ", "Jin ", "Hao ", "Ti ", "Chang ", "[?] ", "[?] ", "Ca ", "Ti ", "Lu ", "Hui ", "Bo ", "You ", "Nie ", "Yin ", "Hu ", "Mo ", "Huang ", "Zhe ", "Li ", "Liu ", "Haai ", "Nang ", "Xiao ", "Mo ", "Yan ", "Li ", "Lu ", "Long ", "Fu ", "Dan ", "Chen ", "Pin ", "Pi ", "Xiang ", "Huo ", "Mo ", "Xi ", "Duo ", "Ku ", "Yan ", "Chan ", "Ying ", "Rang ", "Dian ", "La ", "Ta ", "Xiao ", "Jiao ", "Chuo ", "Huan ", "Huo ", "Zhuan ", "Nie ", "Xiao ", "Ca ", "Li ", "Chan ", "Chai ", "Li ", "Yi ", "Luo ", "Nang ", "Zan ", "Su ", "Xi ", "So ", "Jian ", "Za ", "Zhu ", "Lan ", "Nie ", "Nang ", "[?] ", "[?] ", "Wei ", "Hui ", "Yin ", "Qiu ", "Si ", "Nin ", "Jian ", "Hui ", "Xin ", "Yin ", "Nan ", "Tuan ", "Tuan ", "Dun ", "Kang ", "Yuan ", "Jiong ", "Pian ", "Yun ", "Cong ", "Hu ", "Hui ", "Yuan ", "You ", "Guo ", "Kun ", "Cong ", "Wei ", "Tu ", "Wei ", "Lun ", "Guo ", "Qun ", "Ri ", "Ling ", "Gu ", "Guo ", "Tai ", "Guo ", "Tu ", "You "];
  }
});

// node_modules/unidecode/data/x57.js
var require_x57 = __commonJS({
  "node_modules/unidecode/data/x57.js"(exports2, module2) {
    module2.exports = ["Guo ", "Yin ", "Hun ", "Pu ", "Yu ", "Han ", "Yuan ", "Lun ", "Quan ", "Yu ", "Qing ", "Guo ", "Chuan ", "Wei ", "Yuan ", "Quan ", "Ku ", "Fu ", "Yuan ", "Yuan ", "E ", "Tu ", "Tu ", "Tu ", "Tuan ", "Lue ", "Hui ", "Yi ", "Yuan ", "Luan ", "Luan ", "Tu ", "Ya ", "Tu ", "Ting ", "Sheng ", "Pu ", "Lu ", "Iri ", "Ya ", "Zai ", "Wei ", "Ge ", "Yu ", "Wu ", "Gui ", "Pi ", "Yi ", "Di ", "Qian ", "Qian ", "Zhen ", "Zhuo ", "Dang ", "Qia ", "Akutsu ", "Yama ", "Kuang ", "Chang ", "Qi ", "Nie ", "Mo ", "Ji ", "Jia ", "Zhi ", "Zhi ", "Ban ", "Xun ", "Tou ", "Qin ", "Fen ", "Jun ", "Keng ", "Tun ", "Fang ", "Fen ", "Ben ", "Tan ", "Kan ", "Pi ", "Zuo ", "Keng ", "Bi ", "Xing ", "Di ", "Jing ", "Ji ", "Kuai ", "Di ", "Jing ", "Jian ", "Tan ", "Li ", "Ba ", "Wu ", "Fen ", "Zhui ", "Po ", "Pan ", "Tang ", "Kun ", "Qu ", "Tan ", "Zhi ", "Tuo ", "Gan ", "Ping ", "Dian ", "Gua ", "Ni ", "Tai ", "Pi ", "Jiong ", "Yang ", "Fo ", "Ao ", "Liu ", "Qiu ", "Mu ", "Ke ", "Gou ", "Xue ", "Ba ", "Chi ", "Che ", "Ling ", "Zhu ", "Fu ", "Hu ", "Zhi ", "Chui ", "La ", "Long ", "Long ", "Lu ", "Ao ", "Tay ", "Pao ", "[?] ", "Xing ", "Dong ", "Ji ", "Ke ", "Lu ", "Ci ", "Chi ", "Lei ", "Gai ", "Yin ", "Hou ", "Dui ", "Zhao ", "Fu ", "Guang ", "Yao ", "Duo ", "Duo ", "Gui ", "Cha ", "Yang ", "Yin ", "Fa ", "Gou ", "Yuan ", "Die ", "Xie ", "Ken ", "Jiong ", "Shou ", "E ", "Ha ", "Dian ", "Hong ", "Wu ", "Kua ", "[?] ", "Tao ", "Dang ", "Kai ", "Gake ", "Nao ", "An ", "Xing ", "Xian ", "Huan ", "Bang ", "Pei ", "Ba ", "Yi ", "Yin ", "Han ", "Xu ", "Chui ", "Cen ", "Geng ", "Ai ", "Peng ", "Fang ", "Que ", "Yong ", "Xun ", "Jia ", "Di ", "Mai ", "Lang ", "Xuan ", "Cheng ", "Yan ", "Jin ", "Zhe ", "Lei ", "Lie ", "Bu ", "Cheng ", "Gomi ", "Bu ", "Shi ", "Xun ", "Guo ", "Jiong ", "Ye ", "Nian ", "Di ", "Yu ", "Bu ", "Ya ", "Juan ", "Sui ", "Pi ", "Cheng ", "Wan ", "Ju ", "Lun ", "Zheng ", "Kong ", "Chong ", "Dong ", "Dai ", "Tan ", "An ", "Cai ", "Shu ", "Beng ", "Kan ", "Zhi ", "Duo ", "Yi ", "Zhi ", "Yi ", "Pei ", "Ji ", "Zhun ", "Qi ", "Sao ", "Ju ", "Ni "];
  }
});

// node_modules/unidecode/data/x58.js
var require_x58 = __commonJS({
  "node_modules/unidecode/data/x58.js"(exports2, module2) {
    module2.exports = ["Ku ", "Ke ", "Tang ", "Kun ", "Ni ", "Jian ", "Dui ", "Jin ", "Gang ", "Yu ", "E ", "Peng ", "Gu ", "Tu ", "Leng ", "[?] ", "Ya ", "Qian ", "[?] ", "An ", "[?] ", "Duo ", "Nao ", "Tu ", "Cheng ", "Yin ", "Hun ", "Bi ", "Lian ", "Guo ", "Die ", "Zhuan ", "Hou ", "Bao ", "Bao ", "Yu ", "Di ", "Mao ", "Jie ", "Ruan ", "E ", "Geng ", "Kan ", "Zong ", "Yu ", "Huang ", "E ", "Yao ", "Yan ", "Bao ", "Ji ", "Mei ", "Chang ", "Du ", "Tuo ", "Yin ", "Feng ", "Zhong ", "Jie ", "Zhen ", "Feng ", "Gang ", "Chuan ", "Jian ", "Pyeng ", "Toride ", "Xiang ", "Huang ", "Leng ", "Duan ", "[?] ", "Xuan ", "Ji ", "Ji ", "Kuai ", "Ying ", "Ta ", "Cheng ", "Yong ", "Kai ", "Su ", "Su ", "Shi ", "Mi ", "Ta ", "Weng ", "Cheng ", "Tu ", "Tang ", "Que ", "Zhong ", "Li ", "Peng ", "Bang ", "Sai ", "Zang ", "Dui ", "Tian ", "Wu ", "Cheng ", "Xun ", "Ge ", "Zhen ", "Ai ", "Gong ", "Yan ", "Kan ", "Tian ", "Yuan ", "Wen ", "Xie ", "Liu ", "Ama ", "Lang ", "Chang ", "Peng ", "Beng ", "Chen ", "Cu ", "Lu ", "Ou ", "Qian ", "Mei ", "Mo ", "Zhuan ", "Shuang ", "Shu ", "Lou ", "Chi ", "Man ", "Biao ", "Jing ", "Qi ", "Shu ", "Di ", "Zhang ", "Kan ", "Yong ", "Dian ", "Chen ", "Zhi ", "Xi ", "Guo ", "Qiang ", "Jin ", "Di ", "Shang ", "Mu ", "Cui ", "Yan ", "Ta ", "Zeng ", "Qi ", "Qiang ", "Liang ", "[?] ", "Zhui ", "Qiao ", "Zeng ", "Xu ", "Shan ", "Shan ", "Ba ", "Pu ", "Kuai ", "Dong ", "Fan ", "Que ", "Mo ", "Dun ", "Dun ", "Dun ", "Di ", "Sheng ", "Duo ", "Duo ", "Tan ", "Deng ", "Wu ", "Fen ", "Huang ", "Tan ", "Da ", "Ye ", "Sho ", "Mama ", "Yu ", "Qiang ", "Ji ", "Qiao ", "Ken ", "Yi ", "Pi ", "Bi ", "Dian ", "Jiang ", "Ye ", "Yong ", "Bo ", "Tan ", "Lan ", "Ju ", "Huai ", "Dang ", "Rang ", "Qian ", "Xun ", "Lan ", "Xi ", "He ", "Ai ", "Ya ", "Dao ", "Hao ", "Ruan ", "Mama ", "Lei ", "Kuang ", "Lu ", "Yan ", "Tan ", "Wei ", "Huai ", "Long ", "Long ", "Rui ", "Li ", "Lin ", "Rang ", "Ten ", "Xun ", "Yan ", "Lei ", "Ba ", "[?] ", "Shi ", "Ren ", "[?] ", "Zhuang ", "Zhuang ", "Sheng ", "Yi ", "Mai ", "Ke ", "Zhu ", "Zhuang ", "Hu ", "Hu ", "Kun ", "Yi ", "Hu ", "Xu ", "Kun ", "Shou ", "Mang ", "Zun "];
  }
});

// node_modules/unidecode/data/x59.js
var require_x59 = __commonJS({
  "node_modules/unidecode/data/x59.js"(exports2, module2) {
    module2.exports = ["Shou ", "Yi ", "Zhi ", "Gu ", "Chu ", "Jiang ", "Feng ", "Bei ", "Cay ", "Bian ", "Sui ", "Qun ", "Ling ", "Fu ", "Zuo ", "Xia ", "Xiong ", "[?] ", "Nao ", "Xia ", "Kui ", "Xi ", "Wai ", "Yuan ", "Mao ", "Su ", "Duo ", "Duo ", "Ye ", "Qing ", "Uys ", "Gou ", "Gou ", "Qi ", "Meng ", "Meng ", "Yin ", "Huo ", "Chen ", "Da ", "Ze ", "Tian ", "Tai ", "Fu ", "Guai ", "Yao ", "Yang ", "Hang ", "Gao ", "Shi ", "Ben ", "Tai ", "Tou ", "Yan ", "Bi ", "Yi ", "Kua ", "Jia ", "Duo ", "Kwu ", "Kuang ", "Yun ", "Jia ", "Pa ", "En ", "Lian ", "Huan ", "Di ", "Yan ", "Pao ", "Quan ", "Qi ", "Nai ", "Feng ", "Xie ", "Fen ", "Dian ", "[?] ", "Kui ", "Zou ", "Huan ", "Qi ", "Kai ", "Zha ", "Ben ", "Yi ", "Jiang ", "Tao ", "Zang ", "Ben ", "Xi ", "Xiang ", "Fei ", "Diao ", "Xun ", "Keng ", "Dian ", "Ao ", "She ", "Weng ", "Pan ", "Ao ", "Wu ", "Ao ", "Jiang ", "Lian ", "Duo ", "Yun ", "Jiang ", "Shi ", "Fen ", "Huo ", "Bi ", "Lian ", "Duo ", "Nu ", "Nu ", "Ding ", "Nai ", "Qian ", "Jian ", "Ta ", "Jiu ", "Nan ", "Cha ", "Hao ", "Xian ", "Fan ", "Ji ", "Shuo ", "Ru ", "Fei ", "Wang ", "Hong ", "Zhuang ", "Fu ", "Ma ", "Dan ", "Ren ", "Fu ", "Jing ", "Yan ", "Xie ", "Wen ", "Zhong ", "Pa ", "Du ", "Ji ", "Keng ", "Zhong ", "Yao ", "Jin ", "Yun ", "Miao ", "Pei ", "Shi ", "Yue ", "Zhuang ", "Niu ", "Yan ", "Na ", "Xin ", "Fen ", "Bi ", "Yu ", "Tuo ", "Feng ", "Yuan ", "Fang ", "Wu ", "Yu ", "Gui ", "Du ", "Ba ", "Ni ", "Zhou ", "Zhuo ", "Zhao ", "Da ", "Nai ", "Yuan ", "Tou ", "Xuan ", "Zhi ", "E ", "Mei ", "Mo ", "Qi ", "Bi ", "Shen ", "Qie ", "E ", "He ", "Xu ", "Fa ", "Zheng ", "Min ", "Ban ", "Mu ", "Fu ", "Ling ", "Zi ", "Zi ", "Shi ", "Ran ", "Shan ", "Yang ", "Man ", "Jie ", "Gu ", "Si ", "Xing ", "Wei ", "Zi ", "Ju ", "Shan ", "Pin ", "Ren ", "Yao ", "Tong ", "Jiang ", "Shu ", "Ji ", "Gai ", "Shang ", "Kuo ", "Juan ", "Jiao ", "Gou ", "Mu ", "Jian ", "Jian ", "Yi ", "Nian ", "Zhi ", "Ji ", "Ji ", "Xian ", "Heng ", "Guang ", "Jun ", "Kua ", "Yan ", "Ming ", "Lie ", "Pei ", "Yan ", "You ", "Yan ", "Cha ", "Shen ", "Yin ", "Chi ", "Gui ", "Quan ", "Zi "];
  }
});

// node_modules/unidecode/data/x5a.js
var require_x5a = __commonJS({
  "node_modules/unidecode/data/x5a.js"(exports2, module2) {
    module2.exports = ["Song ", "Wei ", "Hong ", "Wa ", "Lou ", "Ya ", "Rao ", "Jiao ", "Luan ", "Ping ", "Xian ", "Shao ", "Li ", "Cheng ", "Xiao ", "Mang ", "Fu ", "Suo ", "Wu ", "Wei ", "Ke ", "Lai ", "Chuo ", "Ding ", "Niang ", "Xing ", "Nan ", "Yu ", "Nuo ", "Pei ", "Nei ", "Juan ", "Shen ", "Zhi ", "Han ", "Di ", "Zhuang ", "E ", "Pin ", "Tui ", "Han ", "Mian ", "Wu ", "Yan ", "Wu ", "Xi ", "Yan ", "Yu ", "Si ", "Yu ", "Wa ", "[?] ", "Xian ", "Ju ", "Qu ", "Shui ", "Qi ", "Xian ", "Zhui ", "Dong ", "Chang ", "Lu ", "Ai ", "E ", "E ", "Lou ", "Mian ", "Cong ", "Pou ", "Ju ", "Po ", "Cai ", "Ding ", "Wan ", "Biao ", "Xiao ", "Shu ", "Qi ", "Hui ", "Fu ", "E ", "Wo ", "Tan ", "Fei ", "Wei ", "Jie ", "Tian ", "Ni ", "Quan ", "Jing ", "Hun ", "Jing ", "Qian ", "Dian ", "Xing ", "Hu ", "Wa ", "Lai ", "Bi ", "Yin ", "Chou ", "Chuo ", "Fu ", "Jing ", "Lun ", "Yan ", "Lan ", "Kun ", "Yin ", "Ya ", "Ju ", "Li ", "Dian ", "Xian ", "Hwa ", "Hua ", "Ying ", "Chan ", "Shen ", "Ting ", "Dang ", "Yao ", "Wu ", "Nan ", "Ruo ", "Jia ", "Tou ", "Xu ", "Yu ", "Wei ", "Ti ", "Rou ", "Mei ", "Dan ", "Ruan ", "Qin ", "Hui ", "Wu ", "Qian ", "Chun ", "Mao ", "Fu ", "Jie ", "Duan ", "Xi ", "Zhong ", "Mei ", "Huang ", "Mian ", "An ", "Ying ", "Xuan ", "Jie ", "Wei ", "Mei ", "Yuan ", "Zhen ", "Qiu ", "Ti ", "Xie ", "Tuo ", "Lian ", "Mao ", "Ran ", "Si ", "Pian ", "Wei ", "Wa ", "Jiu ", "Hu ", "Ao ", "[?] ", "Bou ", "Xu ", "Tou ", "Gui ", "Zou ", "Yao ", "Pi ", "Xi ", "Yuan ", "Ying ", "Rong ", "Ru ", "Chi ", "Liu ", "Mei ", "Pan ", "Ao ", "Ma ", "Gou ", "Kui ", "Qin ", "Jia ", "Sao ", "Zhen ", "Yuan ", "Cha ", "Yong ", "Ming ", "Ying ", "Ji ", "Su ", "Niao ", "Xian ", "Tao ", "Pang ", "Lang ", "Nao ", "Bao ", "Ai ", "Pi ", "Pin ", "Yi ", "Piao ", "Yu ", "Lei ", "Xuan ", "Man ", "Yi ", "Zhang ", "Kang ", "Yong ", "Ni ", "Li ", "Di ", "Gui ", "Yan ", "Jin ", "Zhuan ", "Chang ", "Ce ", "Han ", "Nen ", "Lao ", "Mo ", "Zhe ", "Hu ", "Hu ", "Ao ", "Nen ", "Qiang ", "Ma ", "Pie ", "Gu ", "Wu ", "Jiao ", "Tuo ", "Zhan ", "Mao ", "Xian ", "Xian ", "Mo ", "Liao ", "Lian ", "Hua "];
  }
});

// node_modules/unidecode/data/x5b.js
var require_x5b = __commonJS({
  "node_modules/unidecode/data/x5b.js"(exports2, module2) {
    module2.exports = ["Gui ", "Deng ", "Zhi ", "Xu ", "Yi ", "Hua ", "Xi ", "Hui ", "Rao ", "Xi ", "Yan ", "Chan ", "Jiao ", "Mei ", "Fan ", "Fan ", "Xian ", "Yi ", "Wei ", "Jiao ", "Fu ", "Shi ", "Bi ", "Shan ", "Sui ", "Qiang ", "Lian ", "Huan ", "Xin ", "Niao ", "Dong ", "Yi ", "Can ", "Ai ", "Niang ", "Neng ", "Ma ", "Tiao ", "Chou ", "Jin ", "Ci ", "Yu ", "Pin ", "Yong ", "Xu ", "Nai ", "Yan ", "Tai ", "Ying ", "Can ", "Niao ", "Wo ", "Ying ", "Mian ", "Kaka ", "Ma ", "Shen ", "Xing ", "Ni ", "Du ", "Liu ", "Yuan ", "Lan ", "Yan ", "Shuang ", "Ling ", "Jiao ", "Niang ", "Lan ", "Xian ", "Ying ", "Shuang ", "Shuai ", "Quan ", "Mi ", "Li ", "Luan ", "Yan ", "Zhu ", "Lan ", "Zi ", "Jie ", "Jue ", "Jue ", "Kong ", "Yun ", "Zi ", "Zi ", "Cun ", "Sun ", "Fu ", "Bei ", "Zi ", "Xiao ", "Xin ", "Meng ", "Si ", "Tai ", "Bao ", "Ji ", "Gu ", "Nu ", "Xue ", "[?] ", "Zhuan ", "Hai ", "Luan ", "Sun ", "Huai ", "Mie ", "Cong ", "Qian ", "Shu ", "Chan ", "Ya ", "Zi ", "Ni ", "Fu ", "Zi ", "Li ", "Xue ", "Bo ", "Ru ", "Lai ", "Nie ", "Nie ", "Ying ", "Luan ", "Mian ", "Zhu ", "Rong ", "Ta ", "Gui ", "Zhai ", "Qiong ", "Yu ", "Shou ", "An ", "Tu ", "Song ", "Wan ", "Rou ", "Yao ", "Hong ", "Yi ", "Jing ", "Zhun ", "Mi ", "Zhu ", "Dang ", "Hong ", "Zong ", "Guan ", "Zhou ", "Ding ", "Wan ", "Yi ", "Bao ", "Shi ", "Shi ", "Chong ", "Shen ", "Ke ", "Xuan ", "Shi ", "You ", "Huan ", "Yi ", "Tiao ", "Shi ", "Xian ", "Gong ", "Cheng ", "Qun ", "Gong ", "Xiao ", "Zai ", "Zha ", "Bao ", "Hai ", "Yan ", "Xiao ", "Jia ", "Shen ", "Chen ", "Rong ", "Huang ", "Mi ", "Kou ", "Kuan ", "Bin ", "Su ", "Cai ", "Zan ", "Ji ", "Yuan ", "Ji ", "Yin ", "Mi ", "Kou ", "Qing ", "Que ", "Zhen ", "Jian ", "Fu ", "Ning ", "Bing ", "Huan ", "Mei ", "Qin ", "Han ", "Yu ", "Shi ", "Ning ", "Qin ", "Ning ", "Zhi ", "Yu ", "Bao ", "Kuan ", "Ning ", "Qin ", "Mo ", "Cha ", "Ju ", "Gua ", "Qin ", "Hu ", "Wu ", "Liao ", "Shi ", "Zhu ", "Zhai ", "Shen ", "Wei ", "Xie ", "Kuan ", "Hui ", "Liao ", "Jun ", "Huan ", "Yi ", "Yi ", "Bao ", "Qin ", "Chong ", "Bao ", "Feng ", "Cun ", "Dui ", "Si ", "Xun ", "Dao ", "Lu ", "Dui ", "Shou "];
  }
});

// node_modules/unidecode/data/x5c.js
var require_x5c = __commonJS({
  "node_modules/unidecode/data/x5c.js"(exports2, module2) {
    module2.exports = ["Po ", "Feng ", "Zhuan ", "Fu ", "She ", "Ke ", "Jiang ", "Jiang ", "Zhuan ", "Wei ", "Zun ", "Xun ", "Shu ", "Dui ", "Dao ", "Xiao ", "Ji ", "Shao ", "Er ", "Er ", "Er ", "Ga ", "Jian ", "Shu ", "Chen ", "Shang ", "Shang ", "Mo ", "Ga ", "Chang ", "Liao ", "Xian ", "Xian ", "[?] ", "Wang ", "Wang ", "You ", "Liao ", "Liao ", "Yao ", "Mang ", "Wang ", "Wang ", "Wang ", "Ga ", "Yao ", "Duo ", "Kui ", "Zhong ", "Jiu ", "Gan ", "Gu ", "Gan ", "Tui ", "Gan ", "Gan ", "Shi ", "Yin ", "Chi ", "Kao ", "Ni ", "Jin ", "Wei ", "Niao ", "Ju ", "Pi ", "Ceng ", "Xi ", "Bi ", "Ju ", "Jie ", "Tian ", "Qu ", "Ti ", "Jie ", "Wu ", "Diao ", "Shi ", "Shi ", "Ping ", "Ji ", "Xie ", "Chen ", "Xi ", "Ni ", "Zhan ", "Xi ", "[?] ", "Man ", "E ", "Lou ", "Ping ", "Ti ", "Fei ", "Shu ", "Xie ", "Tu ", "Lu ", "Lu ", "Xi ", "Ceng ", "Lu ", "Ju ", "Xie ", "Ju ", "Jue ", "Liao ", "Jue ", "Shu ", "Xi ", "Che ", "Tun ", "Ni ", "Shan ", "[?] ", "Xian ", "Li ", "Xue ", "Nata ", "[?] ", "Long ", "Yi ", "Qi ", "Ren ", "Wu ", "Han ", "Shen ", "Yu ", "Chu ", "Sui ", "Qi ", "[?] ", "Yue ", "Ban ", "Yao ", "Ang ", "Ya ", "Wu ", "Jie ", "E ", "Ji ", "Qian ", "Fen ", "Yuan ", "Qi ", "Cen ", "Qian ", "Qi ", "Cha ", "Jie ", "Qu ", "Gang ", "Xian ", "Ao ", "Lan ", "Dao ", "Ba ", "Zuo ", "Zuo ", "Yang ", "Ju ", "Gang ", "Ke ", "Gou ", "Xue ", "Bei ", "Li ", "Tiao ", "Ju ", "Yan ", "Fu ", "Xiu ", "Jia ", "Ling ", "Tuo ", "Pei ", "You ", "Dai ", "Kuang ", "Yue ", "Qu ", "Hu ", "Po ", "Min ", "An ", "Tiao ", "Ling ", "Chi ", "Yuri ", "Dong ", "Cem ", "Kui ", "Xiu ", "Mao ", "Tong ", "Xue ", "Yi ", "Kura ", "He ", "Ke ", "Luo ", "E ", "Fu ", "Xun ", "Die ", "Lu ", "An ", "Er ", "Gai ", "Quan ", "Tong ", "Yi ", "Mu ", "Shi ", "An ", "Wei ", "Hu ", "Zhi ", "Mi ", "Li ", "Ji ", "Tong ", "Wei ", "You ", "Sang ", "Xia ", "Li ", "Yao ", "Jiao ", "Zheng ", "Luan ", "Jiao ", "E ", "E ", "Yu ", "Ye ", "Bu ", "Qiao ", "Qun ", "Feng ", "Feng ", "Nao ", "Li ", "You ", "Xian ", "Hong ", "Dao ", "Shen ", "Cheng ", "Tu ", "Geng ", "Jun ", "Hao ", "Xia ", "Yin ", "Yu "];
  }
});

// node_modules/unidecode/data/x5d.js
var require_x5d = __commonJS({
  "node_modules/unidecode/data/x5d.js"(exports2, module2) {
    module2.exports = ["Lang ", "Kan ", "Lao ", "Lai ", "Xian ", "Que ", "Kong ", "Chong ", "Chong ", "Ta ", "Lin ", "Hua ", "Ju ", "Lai ", "Qi ", "Min ", "Kun ", "Kun ", "Zu ", "Gu ", "Cui ", "Ya ", "Ya ", "Gang ", "Lun ", "Lun ", "Leng ", "Jue ", "Duo ", "Zheng ", "Guo ", "Yin ", "Dong ", "Han ", "Zheng ", "Wei ", "Yao ", "Pi ", "Yan ", "Song ", "Jie ", "Beng ", "Zu ", "Jue ", "Dong ", "Zhan ", "Gu ", "Yin ", "[?] ", "Ze ", "Huang ", "Yu ", "Wei ", "Yang ", "Feng ", "Qiu ", "Dun ", "Ti ", "Yi ", "Zhi ", "Shi ", "Zai ", "Yao ", "E ", "Zhu ", "Kan ", "Lu ", "Yan ", "Mei ", "Gan ", "Ji ", "Ji ", "Huan ", "Ting ", "Sheng ", "Mei ", "Qian ", "Wu ", "Yu ", "Zong ", "Lan ", "Jue ", "Yan ", "Yan ", "Wei ", "Zong ", "Cha ", "Sui ", "Rong ", "Yamashina ", "Qin ", "Yu ", "Kewashii ", "Lou ", "Tu ", "Dui ", "Xi ", "Weng ", "Cang ", "Dang ", "Hong ", "Jie ", "Ai ", "Liu ", "Wu ", "Song ", "Qiao ", "Zi ", "Wei ", "Beng ", "Dian ", "Cuo ", "Qian ", "Yong ", "Nie ", "Cuo ", "Ji ", "[?] ", "Tao ", "Song ", "Zong ", "Jiang ", "Liao ", "Kang ", "Chan ", "Die ", "Cen ", "Ding ", "Tu ", "Lou ", "Zhang ", "Zhan ", "Zhan ", "Ao ", "Cao ", "Qu ", "Qiang ", "Zui ", "Zui ", "Dao ", "Dao ", "Xi ", "Yu ", "Bo ", "Long ", "Xiang ", "Ceng ", "Bo ", "Qin ", "Jiao ", "Yan ", "Lao ", "Zhan ", "Lin ", "Liao ", "Liao ", "Jin ", "Deng ", "Duo ", "Zun ", "Jiao ", "Gui ", "Yao ", "Qiao ", "Yao ", "Jue ", "Zhan ", "Yi ", "Xue ", "Nao ", "Ye ", "Ye ", "Yi ", "E ", "Xian ", "Ji ", "Xie ", "Ke ", "Xi ", "Di ", "Ao ", "Zui ", "[?] ", "Ni ", "Rong ", "Dao ", "Ling ", "Za ", "Yu ", "Yue ", "Yin ", "[?] ", "Jie ", "Li ", "Sui ", "Long ", "Long ", "Dian ", "Ying ", "Xi ", "Ju ", "Chan ", "Ying ", "Kui ", "Yan ", "Wei ", "Nao ", "Quan ", "Chao ", "Cuan ", "Luan ", "Dian ", "Dian ", "[?] ", "Yan ", "Yan ", "Yan ", "Nao ", "Yan ", "Chuan ", "Gui ", "Chuan ", "Zhou ", "Huang ", "Jing ", "Xun ", "Chao ", "Chao ", "Lie ", "Gong ", "Zuo ", "Qiao ", "Ju ", "Gong ", "Kek ", "Wu ", "Pwu ", "Pwu ", "Chai ", "Qiu ", "Qiu ", "Ji ", "Yi ", "Si ", "Ba ", "Zhi ", "Zhao ", "Xiang ", "Yi ", "Jin ", "Xun ", "Juan ", "Phas ", "Xun ", "Jin ", "Fu "];
  }
});

// node_modules/unidecode/data/x5e.js
var require_x5e = __commonJS({
  "node_modules/unidecode/data/x5e.js"(exports2, module2) {
    module2.exports = ["Za ", "Bi ", "Shi ", "Bu ", "Ding ", "Shuai ", "Fan ", "Nie ", "Shi ", "Fen ", "Pa ", "Zhi ", "Xi ", "Hu ", "Dan ", "Wei ", "Zhang ", "Tang ", "Dai ", "Ma ", "Pei ", "Pa ", "Tie ", "Fu ", "Lian ", "Zhi ", "Zhou ", "Bo ", "Zhi ", "Di ", "Mo ", "Yi ", "Yi ", "Ping ", "Qia ", "Juan ", "Ru ", "Shuai ", "Dai ", "Zheng ", "Shui ", "Qiao ", "Zhen ", "Shi ", "Qun ", "Xi ", "Bang ", "Dai ", "Gui ", "Chou ", "Ping ", "Zhang ", "Sha ", "Wan ", "Dai ", "Wei ", "Chang ", "Sha ", "Qi ", "Ze ", "Guo ", "Mao ", "Du ", "Hou ", "Zheng ", "Xu ", "Mi ", "Wei ", "Wo ", "Fu ", "Yi ", "Bang ", "Ping ", "Tazuna ", "Gong ", "Pan ", "Huang ", "Dao ", "Mi ", "Jia ", "Teng ", "Hui ", "Zhong ", "Shan ", "Man ", "Mu ", "Biao ", "Guo ", "Ze ", "Mu ", "Bang ", "Zhang ", "Jiong ", "Chan ", "Fu ", "Zhi ", "Hu ", "Fan ", "Chuang ", "Bi ", "Hei ", "[?] ", "Mi ", "Qiao ", "Chan ", "Fen ", "Meng ", "Bang ", "Chou ", "Mie ", "Chu ", "Jie ", "Xian ", "Lan ", "Gan ", "Ping ", "Nian ", "Qian ", "Bing ", "Bing ", "Xing ", "Gan ", "Yao ", "Huan ", "You ", "You ", "Ji ", "Yan ", "Pi ", "Ting ", "Ze ", "Guang ", "Zhuang ", "Mo ", "Qing ", "Bi ", "Qin ", "Dun ", "Chuang ", "Gui ", "Ya ", "Bai ", "Jie ", "Xu ", "Lu ", "Wu ", "[?] ", "Ku ", "Ying ", "Di ", "Pao ", "Dian ", "Ya ", "Miao ", "Geng ", "Ci ", "Fu ", "Tong ", "Pang ", "Fei ", "Xiang ", "Yi ", "Zhi ", "Tiao ", "Zhi ", "Xiu ", "Du ", "Zuo ", "Xiao ", "Tu ", "Gui ", "Ku ", "Pang ", "Ting ", "You ", "Bu ", "Ding ", "Cheng ", "Lai ", "Bei ", "Ji ", "An ", "Shu ", "Kang ", "Yong ", "Tuo ", "Song ", "Shu ", "Qing ", "Yu ", "Yu ", "Miao ", "Sou ", "Ce ", "Xiang ", "Fei ", "Jiu ", "He ", "Hui ", "Liu ", "Sha ", "Lian ", "Lang ", "Sou ", "Jian ", "Pou ", "Qing ", "Jiu ", "Jiu ", "Qin ", "Ao ", "Kuo ", "Lou ", "Yin ", "Liao ", "Dai ", "Lu ", "Yi ", "Chu ", "Chan ", "Tu ", "Si ", "Xin ", "Miao ", "Chang ", "Wu ", "Fei ", "Guang ", "Koc ", "Kuai ", "Bi ", "Qiang ", "Xie ", "Lin ", "Lin ", "Liao ", "Lu ", "[?] ", "Ying ", "Xian ", "Ting ", "Yong ", "Li ", "Ting ", "Yin ", "Xun ", "Yan ", "Ting ", "Di ", "Po ", "Jian ", "Hui ", "Nai ", "Hui ", "Gong ", "Nian "];
  }
});

// node_modules/unidecode/data/x5f.js
var require_x5f = __commonJS({
  "node_modules/unidecode/data/x5f.js"(exports2, module2) {
    module2.exports = ["Kai ", "Bian ", "Yi ", "Qi ", "Nong ", "Fen ", "Ju ", "Yan ", "Yi ", "Zang ", "Bi ", "Yi ", "Yi ", "Er ", "San ", "Shi ", "Er ", "Shi ", "Shi ", "Gong ", "Diao ", "Yin ", "Hu ", "Fu ", "Hong ", "Wu ", "Tui ", "Chi ", "Jiang ", "Ba ", "Shen ", "Di ", "Zhang ", "Jue ", "Tao ", "Fu ", "Di ", "Mi ", "Xian ", "Hu ", "Chao ", "Nu ", "Jing ", "Zhen ", "Yi ", "Mi ", "Quan ", "Wan ", "Shao ", "Ruo ", "Xuan ", "Jing ", "Dun ", "Zhang ", "Jiang ", "Qiang ", "Peng ", "Dan ", "Qiang ", "Bi ", "Bi ", "She ", "Dan ", "Jian ", "Gou ", "Sei ", "Fa ", "Bi ", "Kou ", "Nagi ", "Bie ", "Xiao ", "Dan ", "Kuo ", "Qiang ", "Hong ", "Mi ", "Kuo ", "Wan ", "Jue ", "Ji ", "Ji ", "Gui ", "Dang ", "Lu ", "Lu ", "Tuan ", "Hui ", "Zhi ", "Hui ", "Hui ", "Yi ", "Yi ", "Yi ", "Yi ", "Huo ", "Huo ", "Shan ", "Xing ", "Wen ", "Tong ", "Yan ", "Yan ", "Yu ", "Chi ", "Cai ", "Biao ", "Diao ", "Bin ", "Peng ", "Yong ", "Piao ", "Zhang ", "Ying ", "Chi ", "Chi ", "Zhuo ", "Tuo ", "Ji ", "Pang ", "Zhong ", "Yi ", "Wang ", "Che ", "Bi ", "Chi ", "Ling ", "Fu ", "Wang ", "Zheng ", "Cu ", "Wang ", "Jing ", "Dai ", "Xi ", "Xun ", "Hen ", "Yang ", "Huai ", "Lu ", "Hou ", "Wa ", "Cheng ", "Zhi ", "Xu ", "Jing ", "Tu ", "Cong ", "[?] ", "Lai ", "Cong ", "De ", "Pai ", "Xi ", "[?] ", "Qi ", "Chang ", "Zhi ", "Cong ", "Zhou ", "Lai ", "Yu ", "Xie ", "Jie ", "Jian ", "Chi ", "Jia ", "Bian ", "Huang ", "Fu ", "Xun ", "Wei ", "Pang ", "Yao ", "Wei ", "Xi ", "Zheng ", "Piao ", "Chi ", "De ", "Zheng ", "Zheng ", "Bie ", "De ", "Chong ", "Che ", "Jiao ", "Wei ", "Jiao ", "Hui ", "Mei ", "Long ", "Xiang ", "Bao ", "Qu ", "Xin ", "Shu ", "Bi ", "Yi ", "Le ", "Ren ", "Dao ", "Ding ", "Gai ", "Ji ", "Ren ", "Ren ", "Chan ", "Tan ", "Te ", "Te ", "Gan ", "Qi ", "Shi ", "Cun ", "Zhi ", "Wang ", "Mang ", "Xi ", "Fan ", "Ying ", "Tian ", "Min ", "Min ", "Zhong ", "Chong ", "Wu ", "Ji ", "Wu ", "Xi ", "Ye ", "You ", "Wan ", "Cong ", "Zhong ", "Kuai ", "Yu ", "Bian ", "Zhi ", "Qi ", "Cui ", "Chen ", "Tai ", "Tun ", "Qian ", "Nian ", "Hun ", "Xiong ", "Niu ", "Wang ", "Xian ", "Xin ", "Kang ", "Hu ", "Kai ", "Fen "];
  }
});

// node_modules/unidecode/data/x60.js
var require_x60 = __commonJS({
  "node_modules/unidecode/data/x60.js"(exports2, module2) {
    module2.exports = ["Huai ", "Tai ", "Song ", "Wu ", "Ou ", "Chang ", "Chuang ", "Ju ", "Yi ", "Bao ", "Chao ", "Min ", "Pei ", "Zuo ", "Zen ", "Yang ", "Kou ", "Ban ", "Nu ", "Nao ", "Zheng ", "Pa ", "Bu ", "Tie ", "Gu ", "Hu ", "Ju ", "Da ", "Lian ", "Si ", "Chou ", "Di ", "Dai ", "Yi ", "Tu ", "You ", "Fu ", "Ji ", "Peng ", "Xing ", "Yuan ", "Ni ", "Guai ", "Fu ", "Xi ", "Bi ", "You ", "Qie ", "Xuan ", "Cong ", "Bing ", "Huang ", "Xu ", "Chu ", "Pi ", "Xi ", "Xi ", "Tan ", "Koraeru ", "Zong ", "Dui ", "[?] ", "Ki ", "Yi ", "Chi ", "Ren ", "Xun ", "Shi ", "Xi ", "Lao ", "Heng ", "Kuang ", "Mu ", "Zhi ", "Xie ", "Lian ", "Tiao ", "Huang ", "Die ", "Hao ", "Kong ", "Gui ", "Heng ", "Xi ", "Xiao ", "Shu ", "S ", "Kua ", "Qiu ", "Yang ", "Hui ", "Hui ", "Chi ", "Jia ", "Yi ", "Xiong ", "Guai ", "Lin ", "Hui ", "Zi ", "Xu ", "Chi ", "Xiang ", "Nu ", "Hen ", "En ", "Ke ", "Tong ", "Tian ", "Gong ", "Quan ", "Xi ", "Qia ", "Yue ", "Peng ", "Ken ", "De ", "Hui ", "E ", "Kyuu ", "Tong ", "Yan ", "Kai ", "Ce ", "Nao ", "Yun ", "Mang ", "Yong ", "Yong ", "Yuan ", "Pi ", "Kun ", "Qiao ", "Yue ", "Yu ", "Yu ", "Jie ", "Xi ", "Zhe ", "Lin ", "Ti ", "Han ", "Hao ", "Qie ", "Ti ", "Bu ", "Yi ", "Qian ", "Hui ", "Xi ", "Bei ", "Man ", "Yi ", "Heng ", "Song ", "Quan ", "Cheng ", "Hui ", "Wu ", "Wu ", "You ", "Li ", "Liang ", "Huan ", "Cong ", "Yi ", "Yue ", "Li ", "Nin ", "Nao ", "E ", "Que ", "Xuan ", "Qian ", "Wu ", "Min ", "Cong ", "Fei ", "Bei ", "Duo ", "Cui ", "Chang ", "Men ", "Li ", "Ji ", "Guan ", "Guan ", "Xing ", "Dao ", "Qi ", "Kong ", "Tian ", "Lun ", "Xi ", "Kan ", "Kun ", "Ni ", "Qing ", "Chou ", "Dun ", "Guo ", "Chan ", "Liang ", "Wan ", "Yuan ", "Jin ", "Ji ", "Lin ", "Yu ", "Huo ", "He ", "Quan ", "Tan ", "Ti ", "Ti ", "Nie ", "Wang ", "Chuo ", "Bu ", "Hun ", "Xi ", "Tang ", "Xin ", "Wei ", "Hui ", "E ", "Rui ", "Zong ", "Jian ", "Yong ", "Dian ", "Ju ", "Can ", "Cheng ", "De ", "Bei ", "Qie ", "Can ", "Dan ", "Guan ", "Duo ", "Nao ", "Yun ", "Xiang ", "Zhui ", "Die ", "Huang ", "Chun ", "Qiong ", "Re ", "Xing ", "Ce ", "Bian ", "Hun ", "Zong ", "Ti "];
  }
});

// node_modules/unidecode/data/x61.js
var require_x61 = __commonJS({
  "node_modules/unidecode/data/x61.js"(exports2, module2) {
    module2.exports = ["Qiao ", "Chou ", "Bei ", "Xuan ", "Wei ", "Ge ", "Qian ", "Wei ", "Yu ", "Yu ", "Bi ", "Xuan ", "Huan ", "Min ", "Bi ", "Yi ", "Mian ", "Yong ", "Kai ", "Dang ", "Yin ", "E ", "Chen ", "Mou ", "Ke ", "Ke ", "Yu ", "Ai ", "Qie ", "Yan ", "Nuo ", "Gan ", "Yun ", "Zong ", "Sai ", "Leng ", "Fen ", "[?] ", "Kui ", "Kui ", "Que ", "Gong ", "Yun ", "Su ", "Su ", "Qi ", "Yao ", "Song ", "Huang ", "Ji ", "Gu ", "Ju ", "Chuang ", "Ni ", "Xie ", "Kai ", "Zheng ", "Yong ", "Cao ", "Sun ", "Shen ", "Bo ", "Kai ", "Yuan ", "Xie ", "Hun ", "Yong ", "Yang ", "Li ", "Sao ", "Tao ", "Yin ", "Ci ", "Xu ", "Qian ", "Tai ", "Huang ", "Yun ", "Shen ", "Ming ", "[?] ", "She ", "Cong ", "Piao ", "Mo ", "Mu ", "Guo ", "Chi ", "Can ", "Can ", "Can ", "Cui ", "Min ", "Te ", "Zhang ", "Tong ", "Ao ", "Shuang ", "Man ", "Guan ", "Que ", "Zao ", "Jiu ", "Hui ", "Kai ", "Lian ", "Ou ", "Song ", "Jin ", "Yin ", "Lu ", "Shang ", "Wei ", "Tuan ", "Man ", "Qian ", "She ", "Yong ", "Qing ", "Kang ", "Di ", "Zhi ", "Lou ", "Juan ", "Qi ", "Qi ", "Yu ", "Ping ", "Liao ", "Cong ", "You ", "Chong ", "Zhi ", "Tong ", "Cheng ", "Qi ", "Qu ", "Peng ", "Bei ", "Bie ", "Chun ", "Jiao ", "Zeng ", "Chi ", "Lian ", "Ping ", "Kui ", "Hui ", "Qiao ", "Cheng ", "Yin ", "Yin ", "Xi ", "Xi ", "Dan ", "Tan ", "Duo ", "Dui ", "Dui ", "Su ", "Jue ", "Ce ", "Xiao ", "Fan ", "Fen ", "Lao ", "Lao ", "Chong ", "Han ", "Qi ", "Xian ", "Min ", "Jing ", "Liao ", "Wu ", "Can ", "Jue ", "Cu ", "Xian ", "Tan ", "Sheng ", "Pi ", "Yi ", "Chu ", "Xian ", "Nao ", "Dan ", "Tan ", "Jing ", "Song ", "Han ", "Jiao ", "Wai ", "Huan ", "Dong ", "Qin ", "Qin ", "Qu ", "Cao ", "Ken ", "Xie ", "Ying ", "Ao ", "Mao ", "Yi ", "Lin ", "Se ", "Jun ", "Huai ", "Men ", "Lan ", "Ai ", "Lin ", "Yan ", "Gua ", "Xia ", "Chi ", "Yu ", "Yin ", "Dai ", "Meng ", "Ai ", "Meng ", "Dui ", "Qi ", "Mo ", "Lan ", "Men ", "Chou ", "Zhi ", "Nuo ", "Nuo ", "Yan ", "Yang ", "Bo ", "Zhi ", "Kuang ", "Kuang ", "You ", "Fu ", "Liu ", "Mie ", "Cheng ", "[?] ", "Chan ", "Meng ", "Lan ", "Huai ", "Xuan ", "Rang ", "Chan ", "Ji ", "Ju ", "Huan ", "She ", "Yi "];
  }
});

// node_modules/unidecode/data/x62.js
var require_x62 = __commonJS({
  "node_modules/unidecode/data/x62.js"(exports2, module2) {
    module2.exports = ["Lian ", "Nan ", "Mi ", "Tang ", "Jue ", "Gang ", "Gang ", "Gang ", "Ge ", "Yue ", "Wu ", "Jian ", "Xu ", "Shu ", "Rong ", "Xi ", "Cheng ", "Wo ", "Jie ", "Ge ", "Jian ", "Qiang ", "Huo ", "Qiang ", "Zhan ", "Dong ", "Qi ", "Jia ", "Die ", "Zei ", "Jia ", "Ji ", "Shi ", "Kan ", "Ji ", "Kui ", "Gai ", "Deng ", "Zhan ", "Chuang ", "Ge ", "Jian ", "Jie ", "Yu ", "Jian ", "Yan ", "Lu ", "Xi ", "Zhan ", "Xi ", "Xi ", "Chuo ", "Dai ", "Qu ", "Hu ", "Hu ", "Hu ", "E ", "Shi ", "Li ", "Mao ", "Hu ", "Li ", "Fang ", "Suo ", "Bian ", "Dian ", "Jiong ", "Shang ", "Yi ", "Yi ", "Shan ", "Hu ", "Fei ", "Yan ", "Shou ", "T ", "Cai ", "Zha ", "Qiu ", "Le ", "Bu ", "Ba ", "Da ", "Reng ", "Fu ", "Hameru ", "Zai ", "Tuo ", "Zhang ", "Diao ", "Kang ", "Yu ", "Ku ", "Han ", "Shen ", "Cha ", "Yi ", "Gu ", "Kou ", "Wu ", "Tuo ", "Qian ", "Zhi ", "Ren ", "Kuo ", "Men ", "Sao ", "Yang ", "Niu ", "Ban ", "Che ", "Rao ", "Xi ", "Qian ", "Ban ", "Jia ", "Yu ", "Fu ", "Ao ", "Xi ", "Pi ", "Zhi ", "Zi ", "E ", "Dun ", "Zhao ", "Cheng ", "Ji ", "Yan ", "Kuang ", "Bian ", "Chao ", "Ju ", "Wen ", "Hu ", "Yue ", "Jue ", "Ba ", "Qin ", "Zhen ", "Zheng ", "Yun ", "Wan ", "Nu ", "Yi ", "Shu ", "Zhua ", "Pou ", "Tou ", "Dou ", "Kang ", "Zhe ", "Pou ", "Fu ", "Pao ", "Ba ", "Ao ", "Ze ", "Tuan ", "Kou ", "Lun ", "Qiang ", "[?] ", "Hu ", "Bao ", "Bing ", "Zhi ", "Peng ", "Tan ", "Pu ", "Pi ", "Tai ", "Yao ", "Zhen ", "Zha ", "Yang ", "Bao ", "He ", "Ni ", "Yi ", "Di ", "Chi ", "Pi ", "Za ", "Mo ", "Mo ", "Shen ", "Ya ", "Chou ", "Qu ", "Min ", "Chu ", "Jia ", "Fu ", "Zhan ", "Zhu ", "Dan ", "Chai ", "Mu ", "Nian ", "La ", "Fu ", "Pao ", "Ban ", "Pai ", "Ling ", "Na ", "Guai ", "Qian ", "Ju ", "Tuo ", "Ba ", "Tuo ", "Tuo ", "Ao ", "Ju ", "Zhuo ", "Pan ", "Zhao ", "Bai ", "Bai ", "Di ", "Ni ", "Ju ", "Kuo ", "Long ", "Jian ", "[?] ", "Yong ", "Lan ", "Ning ", "Bo ", "Ze ", "Qian ", "Hen ", "Gua ", "Shi ", "Jie ", "Zheng ", "Nin ", "Gong ", "Gong ", "Quan ", "Shuan ", "Cun ", "Zan ", "Kao ", "Chi ", "Xie ", "Ce ", "Hui ", "Pin ", "Zhuai ", "Shi ", "Na "];
  }
});

// node_modules/unidecode/data/x63.js
var require_x63 = __commonJS({
  "node_modules/unidecode/data/x63.js"(exports2, module2) {
    module2.exports = ["Bo ", "Chi ", "Gua ", "Zhi ", "Kuo ", "Duo ", "Duo ", "Zhi ", "Qie ", "An ", "Nong ", "Zhen ", "Ge ", "Jiao ", "Ku ", "Dong ", "Ru ", "Tiao ", "Lie ", "Zha ", "Lu ", "Die ", "Wa ", "Jue ", "Mushiru ", "Ju ", "Zhi ", "Luan ", "Ya ", "Zhua ", "Ta ", "Xie ", "Nao ", "Dang ", "Jiao ", "Zheng ", "Ji ", "Hui ", "Xun ", "Ku ", "Ai ", "Tuo ", "Nuo ", "Cuo ", "Bo ", "Geng ", "Ti ", "Zhen ", "Cheng ", "Suo ", "Suo ", "Keng ", "Mei ", "Long ", "Ju ", "Peng ", "Jian ", "Yi ", "Ting ", "Shan ", "Nuo ", "Wan ", "Xie ", "Cha ", "Feng ", "Jiao ", "Wu ", "Jun ", "Jiu ", "Tong ", "Kun ", "Huo ", "Tu ", "Zhuo ", "Pou ", "Le ", "Ba ", "Han ", "Shao ", "Nie ", "Juan ", "Ze ", "Song ", "Ye ", "Jue ", "Bu ", "Huan ", "Bu ", "Zun ", "Yi ", "Zhai ", "Lu ", "Sou ", "Tuo ", "Lao ", "Sun ", "Bang ", "Jian ", "Huan ", "Dao ", "[?] ", "Wan ", "Qin ", "Peng ", "She ", "Lie ", "Min ", "Men ", "Fu ", "Bai ", "Ju ", "Dao ", "Wo ", "Ai ", "Juan ", "Yue ", "Zong ", "Chen ", "Chui ", "Jie ", "Tu ", "Ben ", "Na ", "Nian ", "Nuo ", "Zu ", "Wo ", "Xi ", "Xian ", "Cheng ", "Dian ", "Sao ", "Lun ", "Qing ", "Gang ", "Duo ", "Shou ", "Diao ", "Pou ", "Di ", "Zhang ", "Gun ", "Ji ", "Tao ", "Qia ", "Qi ", "Pai ", "Shu ", "Qian ", "Ling ", "Yi ", "Ya ", "Jue ", "Zheng ", "Liang ", "Gua ", "Yi ", "Huo ", "Shan ", "Zheng ", "Lue ", "Cai ", "Tan ", "Che ", "Bing ", "Jie ", "Ti ", "Kong ", "Tui ", "Yan ", "Cuo ", "Zou ", "Ju ", "Tian ", "Qian ", "Ken ", "Bai ", "Shou ", "Jie ", "Lu ", "Guo ", "Haba ", "[?] ", "Zhi ", "Dan ", "Mang ", "Xian ", "Sao ", "Guan ", "Peng ", "Yuan ", "Nuo ", "Jian ", "Zhen ", "Jiu ", "Jian ", "Yu ", "Yan ", "Kui ", "Nan ", "Hong ", "Rou ", "Pi ", "Wei ", "Sai ", "Zou ", "Xuan ", "Miao ", "Ti ", "Nie ", "Cha ", "Shi ", "Zong ", "Zhen ", "Yi ", "Shun ", "Heng ", "Bian ", "Yang ", "Huan ", "Yan ", "Zuan ", "An ", "Xu ", "Ya ", "Wo ", "Ke ", "Chuai ", "Ji ", "Ti ", "La ", "La ", "Cheng ", "Kai ", "Jiu ", "Jiu ", "Tu ", "Jie ", "Hui ", "Geng ", "Chong ", "Shuo ", "She ", "Xie ", "Yuan ", "Qian ", "Ye ", "Cha ", "Zha ", "Bei ", "Yao ", "[?] ", "[?] ", "Lan ", "Wen ", "Qin "];
  }
});

// node_modules/unidecode/data/x64.js
var require_x64 = __commonJS({
  "node_modules/unidecode/data/x64.js"(exports2, module2) {
    module2.exports = ["Chan ", "Ge ", "Lou ", "Zong ", "Geng ", "Jiao ", "Gou ", "Qin ", "Yong ", "Que ", "Chou ", "Chi ", "Zhan ", "Sun ", "Sun ", "Bo ", "Chu ", "Rong ", "Beng ", "Cuo ", "Sao ", "Ke ", "Yao ", "Dao ", "Zhi ", "Nu ", "Xie ", "Jian ", "Sou ", "Qiu ", "Gao ", "Xian ", "Shuo ", "Sang ", "Jin ", "Mie ", "E ", "Chui ", "Nuo ", "Shan ", "Ta ", "Jie ", "Tang ", "Pan ", "Ban ", "Da ", "Li ", "Tao ", "Hu ", "Zhi ", "Wa ", "Xia ", "Qian ", "Wen ", "Qiang ", "Tian ", "Zhen ", "E ", "Xi ", "Nuo ", "Quan ", "Cha ", "Zha ", "Ge ", "Wu ", "En ", "She ", "Kang ", "She ", "Shu ", "Bai ", "Yao ", "Bin ", "Sou ", "Tan ", "Sa ", "Chan ", "Suo ", "Liao ", "Chong ", "Chuang ", "Guo ", "Bing ", "Feng ", "Shuai ", "Di ", "Qi ", "Sou ", "Zhai ", "Lian ", "Tang ", "Chi ", "Guan ", "Lu ", "Luo ", "Lou ", "Zong ", "Gai ", "Hu ", "Zha ", "Chuang ", "Tang ", "Hua ", "Cui ", "Nai ", "Mo ", "Jiang ", "Gui ", "Ying ", "Zhi ", "Ao ", "Zhi ", "Nie ", "Man ", "Shan ", "Kou ", "Shu ", "Suo ", "Tuan ", "Jiao ", "Mo ", "Mo ", "Zhe ", "Xian ", "Keng ", "Piao ", "Jiang ", "Yin ", "Gou ", "Qian ", "Lue ", "Ji ", "Ying ", "Jue ", "Pie ", "Pie ", "Lao ", "Dun ", "Xian ", "Ruan ", "Kui ", "Zan ", "Yi ", "Xun ", "Cheng ", "Cheng ", "Sa ", "Nao ", "Heng ", "Si ", "Qian ", "Huang ", "Da ", "Zun ", "Nian ", "Lin ", "Zheng ", "Hui ", "Zhuang ", "Jiao ", "Ji ", "Cao ", "Dan ", "Dan ", "Che ", "Bo ", "Che ", "Jue ", "Xiao ", "Liao ", "Ben ", "Fu ", "Qiao ", "Bo ", "Cuo ", "Zhuo ", "Zhuan ", "Tuo ", "Pu ", "Qin ", "Dun ", "Nian ", "[?] ", "Xie ", "Lu ", "Jiao ", "Cuan ", "Ta ", "Han ", "Qiao ", "Zhua ", "Jian ", "Gan ", "Yong ", "Lei ", "Kuo ", "Lu ", "Shan ", "Zhuo ", "Ze ", "Pu ", "Chuo ", "Ji ", "Dang ", "Suo ", "Cao ", "Qing ", "Jing ", "Huan ", "Jie ", "Qin ", "Kuai ", "Dan ", "Xi ", "Ge ", "Pi ", "Bo ", "Ao ", "Ju ", "Ye ", "[?] ", "Mang ", "Sou ", "Mi ", "Ji ", "Tai ", "Zhuo ", "Dao ", "Xing ", "Lan ", "Ca ", "Ju ", "Ye ", "Ru ", "Ye ", "Ye ", "Ni ", "Hu ", "Ji ", "Bin ", "Ning ", "Ge ", "Zhi ", "Jie ", "Kuo ", "Mo ", "Jian ", "Xie ", "Lie ", "Tan ", "Bai ", "Sou ", "Lu ", "Lue ", "Rao ", "Zhi "];
  }
});

// node_modules/unidecode/data/x65.js
var require_x65 = __commonJS({
  "node_modules/unidecode/data/x65.js"(exports2, module2) {
    module2.exports = ["Pan ", "Yang ", "Lei ", "Sa ", "Shu ", "Zan ", "Nian ", "Xian ", "Jun ", "Huo ", "Li ", "La ", "Han ", "Ying ", "Lu ", "Long ", "Qian ", "Qian ", "Zan ", "Qian ", "Lan ", "San ", "Ying ", "Mei ", "Rang ", "Chan ", "[?] ", "Cuan ", "Xi ", "She ", "Luo ", "Jun ", "Mi ", "Li ", "Zan ", "Luan ", "Tan ", "Zuan ", "Li ", "Dian ", "Wa ", "Dang ", "Jiao ", "Jue ", "Lan ", "Li ", "Nang ", "Zhi ", "Gui ", "Gui ", "Qi ", "Xin ", "Pu ", "Sui ", "Shou ", "Kao ", "You ", "Gai ", "Yi ", "Gong ", "Gan ", "Ban ", "Fang ", "Zheng ", "Bo ", "Dian ", "Kou ", "Min ", "Wu ", "Gu ", "He ", "Ce ", "Xiao ", "Mi ", "Chu ", "Ge ", "Di ", "Xu ", "Jiao ", "Min ", "Chen ", "Jiu ", "Zhen ", "Duo ", "Yu ", "Chi ", "Ao ", "Bai ", "Xu ", "Jiao ", "Duo ", "Lian ", "Nie ", "Bi ", "Chang ", "Dian ", "Duo ", "Yi ", "Gan ", "San ", "Ke ", "Yan ", "Dun ", "Qi ", "Dou ", "Xiao ", "Duo ", "Jiao ", "Jing ", "Yang ", "Xia ", "Min ", "Shu ", "Ai ", "Qiao ", "Ai ", "Zheng ", "Di ", "Zhen ", "Fu ", "Shu ", "Liao ", "Qu ", "Xiong ", "Xi ", "Jiao ", "Sen ", "Jiao ", "Zhuo ", "Yi ", "Lian ", "Bi ", "Li ", "Xiao ", "Xiao ", "Wen ", "Xue ", "Qi ", "Qi ", "Zhai ", "Bin ", "Jue ", "Zhai ", "[?] ", "Fei ", "Ban ", "Ban ", "Lan ", "Yu ", "Lan ", "Wei ", "Dou ", "Sheng ", "Liao ", "Jia ", "Hu ", "Xie ", "Jia ", "Yu ", "Zhen ", "Jiao ", "Wo ", "Tou ", "Chu ", "Jin ", "Chi ", "Yin ", "Fu ", "Qiang ", "Zhan ", "Qu ", "Zhuo ", "Zhan ", "Duan ", "Zhuo ", "Si ", "Xin ", "Zhuo ", "Zhuo ", "Qin ", "Lin ", "Zhuo ", "Chu ", "Duan ", "Zhu ", "Fang ", "Xie ", "Hang ", "Yu ", "Shi ", "Pei ", "You ", "Mye ", "Pang ", "Qi ", "Zhan ", "Mao ", "Lu ", "Pei ", "Pi ", "Liu ", "Fu ", "Fang ", "Xuan ", "Jing ", "Jing ", "Ni ", "Zu ", "Zhao ", "Yi ", "Liu ", "Shao ", "Jian ", "Es ", "Yi ", "Qi ", "Zhi ", "Fan ", "Piao ", "Fan ", "Zhan ", "Guai ", "Sui ", "Yu ", "Wu ", "Ji ", "Ji ", "Ji ", "Huo ", "Ri ", "Dan ", "Jiu ", "Zhi ", "Zao ", "Xie ", "Tiao ", "Xun ", "Xu ", "Xu ", "Xu ", "Gan ", "Han ", "Tai ", "Di ", "Xu ", "Chan ", "Shi ", "Kuang ", "Yang ", "Shi ", "Wang ", "Min ", "Min ", "Tun ", "Chun ", "Wu "];
  }
});

// node_modules/unidecode/data/x66.js
var require_x66 = __commonJS({
  "node_modules/unidecode/data/x66.js"(exports2, module2) {
    module2.exports = ["Yun ", "Bei ", "Ang ", "Ze ", "Ban ", "Jie ", "Kun ", "Sheng ", "Hu ", "Fang ", "Hao ", "Gui ", "Chang ", "Xuan ", "Ming ", "Hun ", "Fen ", "Qin ", "Hu ", "Yi ", "Xi ", "Xin ", "Yan ", "Ze ", "Fang ", "Tan ", "Shen ", "Ju ", "Yang ", "Zan ", "Bing ", "Xing ", "Ying ", "Xuan ", "Pei ", "Zhen ", "Ling ", "Chun ", "Hao ", "Mei ", "Zuo ", "Mo ", "Bian ", "Xu ", "Hun ", "Zhao ", "Zong ", "Shi ", "Shi ", "Yu ", "Fei ", "Die ", "Mao ", "Ni ", "Chang ", "Wen ", "Dong ", "Ai ", "Bing ", "Ang ", "Zhou ", "Long ", "Xian ", "Kuang ", "Tiao ", "Chao ", "Shi ", "Huang ", "Huang ", "Xuan ", "Kui ", "Xu ", "Jiao ", "Jin ", "Zhi ", "Jin ", "Shang ", "Tong ", "Hong ", "Yan ", "Gai ", "Xiang ", "Shai ", "Xiao ", "Ye ", "Yun ", "Hui ", "Han ", "Han ", "Jun ", "Wan ", "Xian ", "Kun ", "Zhou ", "Xi ", "Cheng ", "Sheng ", "Bu ", "Zhe ", "Zhe ", "Wu ", "Han ", "Hui ", "Hao ", "Chen ", "Wan ", "Tian ", "Zhuo ", "Zui ", "Zhou ", "Pu ", "Jing ", "Xi ", "Shan ", "Yi ", "Xi ", "Qing ", "Qi ", "Jing ", "Gui ", "Zhen ", "Yi ", "Zhi ", "An ", "Wan ", "Lin ", "Liang ", "Chang ", "Wang ", "Xiao ", "Zan ", "Hi ", "Xuan ", "Xuan ", "Yi ", "Xia ", "Yun ", "Hui ", "Fu ", "Min ", "Kui ", "He ", "Ying ", "Du ", "Wei ", "Shu ", "Qing ", "Mao ", "Nan ", "Jian ", "Nuan ", "An ", "Yang ", "Chun ", "Yao ", "Suo ", "Jin ", "Ming ", "Jiao ", "Kai ", "Gao ", "Weng ", "Chang ", "Qi ", "Hao ", "Yan ", "Li ", "Ai ", "Ji ", "Gui ", "Men ", "Zan ", "Xie ", "Hao ", "Mu ", "Mo ", "Cong ", "Ni ", "Zhang ", "Hui ", "Bao ", "Han ", "Xuan ", "Chuan ", "Liao ", "Xian ", "Dan ", "Jing ", "Pie ", "Lin ", "Tun ", "Xi ", "Yi ", "Ji ", "Huang ", "Tai ", "Ye ", "Ye ", "Li ", "Tan ", "Tong ", "Xiao ", "Fei ", "Qin ", "Zhao ", "Hao ", "Yi ", "Xiang ", "Xing ", "Sen ", "Jiao ", "Bao ", "Jing ", "Yian ", "Ai ", "Ye ", "Ru ", "Shu ", "Meng ", "Xun ", "Yao ", "Pu ", "Li ", "Chen ", "Kuang ", "Die ", "[?] ", "Yan ", "Huo ", "Lu ", "Xi ", "Rong ", "Long ", "Nang ", "Luo ", "Luan ", "Shai ", "Tang ", "Yan ", "Chu ", "Yue ", "Yue ", "Qu ", "Yi ", "Geng ", "Ye ", "Hu ", "He ", "Shu ", "Cao ", "Cao ", "Noboru ", "Man ", "Ceng ", "Ceng ", "Ti "];
  }
});

// node_modules/unidecode/data/x67.js
var require_x67 = __commonJS({
  "node_modules/unidecode/data/x67.js"(exports2, module2) {
    module2.exports = ["Zui ", "Can ", "Xu ", "Hui ", "Yin ", "Qie ", "Fen ", "Pi ", "Yue ", "You ", "Ruan ", "Peng ", "Ban ", "Fu ", "Ling ", "Fei ", "Qu ", "[?] ", "Nu ", "Tiao ", "Shuo ", "Zhen ", "Lang ", "Lang ", "Juan ", "Ming ", "Huang ", "Wang ", "Tun ", "Zhao ", "Ji ", "Qi ", "Ying ", "Zong ", "Wang ", "Tong ", "Lang ", "[?] ", "Meng ", "Long ", "Mu ", "Deng ", "Wei ", "Mo ", "Ben ", "Zha ", "Zhu ", "Zhu ", "[?] ", "Zhu ", "Ren ", "Ba ", "Po ", "Duo ", "Duo ", "Dao ", "Li ", "Qiu ", "Ji ", "Jiu ", "Bi ", "Xiu ", "Ting ", "Ci ", "Sha ", "Eburi ", "Za ", "Quan ", "Qian ", "Yu ", "Gan ", "Wu ", "Cha ", "Shan ", "Xun ", "Fan ", "Wu ", "Zi ", "Li ", "Xing ", "Cai ", "Cun ", "Ren ", "Shao ", "Tuo ", "Di ", "Zhang ", "Mang ", "Chi ", "Yi ", "Gu ", "Gong ", "Du ", "Yi ", "Qi ", "Shu ", "Gang ", "Tiao ", "Moku ", "Soma ", "Tochi ", "Lai ", "Sugi ", "Mang ", "Yang ", "Ma ", "Miao ", "Si ", "Yuan ", "Hang ", "Fei ", "Bei ", "Jie ", "Dong ", "Gao ", "Yao ", "Xian ", "Chu ", "Qun ", "Pa ", "Shu ", "Hua ", "Xin ", "Chou ", "Zhu ", "Chou ", "Song ", "Ban ", "Song ", "Ji ", "Yue ", "Jin ", "Gou ", "Ji ", "Mao ", "Pi ", "Bi ", "Wang ", "Ang ", "Fang ", "Fen ", "Yi ", "Fu ", "Nan ", "Xi ", "Hu ", "Ya ", "Dou ", "Xun ", "Zhen ", "Yao ", "Lin ", "Rui ", "E ", "Mei ", "Zhao ", "Guo ", "Zhi ", "Cong ", "Yun ", "Waku ", "Dou ", "Shu ", "Zao ", "[?] ", "Li ", "Haze ", "Jian ", "Cheng ", "Matsu ", "Qiang ", "Feng ", "Nan ", "Xiao ", "Xian ", "Ku ", "Ping ", "Yi ", "Xi ", "Zhi ", "Guai ", "Xiao ", "Jia ", "Jia ", "Gou ", "Fu ", "Mo ", "Yi ", "Ye ", "Ye ", "Shi ", "Nie ", "Bi ", "Duo ", "Yi ", "Ling ", "Bing ", "Ni ", "La ", "He ", "Pan ", "Fan ", "Zhong ", "Dai ", "Ci ", "Yang ", "Fu ", "Bo ", "Mou ", "Gan ", "Qi ", "Ran ", "Rou ", "Mao ", "Zhao ", "Song ", "Zhe ", "Xia ", "You ", "Shen ", "Ju ", "Tuo ", "Zuo ", "Nan ", "Ning ", "Yong ", "Di ", "Zhi ", "Zha ", "Cha ", "Dan ", "Gu ", "Pu ", "Jiu ", "Ao ", "Fu ", "Jian ", "Bo ", "Duo ", "Ke ", "Nai ", "Zhu ", "Bi ", "Liu ", "Chai ", "Zha ", "Si ", "Zhu ", "Pei ", "Shi ", "Guai ", "Cha ", "Yao ", "Jue ", "Jiu ", "Shi "];
  }
});

// node_modules/unidecode/data/x68.js
var require_x68 = __commonJS({
  "node_modules/unidecode/data/x68.js"(exports2, module2) {
    module2.exports = ["Zhi ", "Liu ", "Mei ", "Hoy ", "Rong ", "Zha ", "[?] ", "Biao ", "Zhan ", "Jie ", "Long ", "Dong ", "Lu ", "Sayng ", "Li ", "Lan ", "Yong ", "Shu ", "Xun ", "Shuan ", "Qi ", "Zhen ", "Qi ", "Li ", "Yi ", "Xiang ", "Zhen ", "Li ", "Su ", "Gua ", "Kan ", "Bing ", "Ren ", "Xiao ", "Bo ", "Ren ", "Bing ", "Zi ", "Chou ", "Yi ", "Jie ", "Xu ", "Zhu ", "Jian ", "Zui ", "Er ", "Er ", "You ", "Fa ", "Gong ", "Kao ", "Lao ", "Zhan ", "Li ", "Yin ", "Yang ", "He ", "Gen ", "Zhi ", "Chi ", "Ge ", "Zai ", "Luan ", "Fu ", "Jie ", "Hang ", "Gui ", "Tao ", "Guang ", "Wei ", "Kuang ", "Ru ", "An ", "An ", "Juan ", "Yi ", "Zhuo ", "Ku ", "Zhi ", "Qiong ", "Tong ", "Sang ", "Sang ", "Huan ", "Jie ", "Jiu ", "Xue ", "Duo ", "Zhui ", "Yu ", "Zan ", "Kasei ", "Ying ", "Masu ", "[?] ", "Zhan ", "Ya ", "Nao ", "Zhen ", "Dang ", "Qi ", "Qiao ", "Hua ", "Kuai ", "Jiang ", "Zhuang ", "Xun ", "Suo ", "Sha ", "Zhen ", "Bei ", "Ting ", "Gua ", "Jing ", "Bo ", "Ben ", "Fu ", "Rui ", "Tong ", "Jue ", "Xi ", "Lang ", "Liu ", "Feng ", "Qi ", "Wen ", "Jun ", "Gan ", "Cu ", "Liang ", "Qiu ", "Ting ", "You ", "Mei ", "Bang ", "Long ", "Peng ", "Zhuang ", "Di ", "Xuan ", "Tu ", "Zao ", "Ao ", "Gu ", "Bi ", "Di ", "Han ", "Zi ", "Zhi ", "Ren ", "Bei ", "Geng ", "Jian ", "Huan ", "Wan ", "Nuo ", "Jia ", "Tiao ", "Ji ", "Xiao ", "Lu ", "Huan ", "Shao ", "Cen ", "Fen ", "Song ", "Meng ", "Wu ", "Li ", "Li ", "Dou ", "Cen ", "Ying ", "Suo ", "Ju ", "Ti ", "Jie ", "Kun ", "Zhuo ", "Shu ", "Chan ", "Fan ", "Wei ", "Jing ", "Li ", "Bing ", "Fumoto ", "Shikimi ", "Tao ", "Zhi ", "Lai ", "Lian ", "Jian ", "Zhuo ", "Ling ", "Li ", "Qi ", "Bing ", "Zhun ", "Cong ", "Qian ", "Mian ", "Qi ", "Qi ", "Cai ", "Gun ", "Chan ", "Te ", "Fei ", "Pai ", "Bang ", "Pou ", "Hun ", "Zong ", "Cheng ", "Zao ", "Ji ", "Li ", "Peng ", "Yu ", "Yu ", "Gu ", "Hun ", "Dong ", "Tang ", "Gang ", "Wang ", "Di ", "Xi ", "Fan ", "Cheng ", "Zhan ", "Qi ", "Yuan ", "Yan ", "Yu ", "Quan ", "Yi ", "Sen ", "Ren ", "Chui ", "Leng ", "Qi ", "Zhuo ", "Fu ", "Ke ", "Lai ", "Zou ", "Zou ", "Zhuo ", "Guan ", "Fen ", "Fen ", "Chen ", "Qiong ", "Nie "];
  }
});

// node_modules/unidecode/data/x69.js
var require_x69 = __commonJS({
  "node_modules/unidecode/data/x69.js"(exports2, module2) {
    module2.exports = ["Wan ", "Guo ", "Lu ", "Hao ", "Jie ", "Yi ", "Chou ", "Ju ", "Ju ", "Cheng ", "Zuo ", "Liang ", "Qiang ", "Zhi ", "Zhui ", "Ya ", "Ju ", "Bei ", "Jiao ", "Zhuo ", "Zi ", "Bin ", "Peng ", "Ding ", "Chu ", "Chang ", "Kunugi ", "Momiji ", "Jian ", "Gui ", "Xi ", "Du ", "Qian ", "Kunugi ", "Soko ", "Shide ", "Luo ", "Zhi ", "Ken ", "Myeng ", "Tafu ", "[?] ", "Peng ", "Zhan ", "[?] ", "Tuo ", "Sen ", "Duo ", "Ye ", "Fou ", "Wei ", "Wei ", "Duan ", "Jia ", "Zong ", "Jian ", "Yi ", "Shen ", "Xi ", "Yan ", "Yan ", "Chuan ", "Zhan ", "Chun ", "Yu ", "He ", "Zha ", "Wo ", "Pian ", "Bi ", "Yao ", "Huo ", "Xu ", "Ruo ", "Yang ", "La ", "Yan ", "Ben ", "Hun ", "Kui ", "Jie ", "Kui ", "Si ", "Feng ", "Xie ", "Tuo ", "Zhi ", "Jian ", "Mu ", "Mao ", "Chu ", "Hu ", "Hu ", "Lian ", "Leng ", "Ting ", "Nan ", "Yu ", "You ", "Mei ", "Song ", "Xuan ", "Xuan ", "Ying ", "Zhen ", "Pian ", "Ye ", "Ji ", "Jie ", "Ye ", "Chu ", "Shun ", "Yu ", "Cou ", "Wei ", "Mei ", "Di ", "Ji ", "Jie ", "Kai ", "Qiu ", "Ying ", "Rou ", "Heng ", "Lou ", "Le ", "Hazou ", "Katsura ", "Pin ", "Muro ", "Gai ", "Tan ", "Lan ", "Yun ", "Yu ", "Chen ", "Lu ", "Ju ", "Sakaki ", "[?] ", "Pi ", "Xie ", "Jia ", "Yi ", "Zhan ", "Fu ", "Nai ", "Mi ", "Lang ", "Rong ", "Gu ", "Jian ", "Ju ", "Ta ", "Yao ", "Zhen ", "Bang ", "Sha ", "Yuan ", "Zi ", "Ming ", "Su ", "Jia ", "Yao ", "Jie ", "Huang ", "Gan ", "Fei ", "Zha ", "Qian ", "Ma ", "Sun ", "Yuan ", "Xie ", "Rong ", "Shi ", "Zhi ", "Cui ", "Yun ", "Ting ", "Liu ", "Rong ", "Tang ", "Que ", "Zhai ", "Si ", "Sheng ", "Ta ", "Ke ", "Xi ", "Gu ", "Qi ", "Kao ", "Gao ", "Sun ", "Pan ", "Tao ", "Ge ", "Xun ", "Dian ", "Nou ", "Ji ", "Shuo ", "Gou ", "Chui ", "Qiang ", "Cha ", "Qian ", "Huai ", "Mei ", "Xu ", "Gang ", "Gao ", "Zhuo ", "Tuo ", "Hashi ", "Yang ", "Dian ", "Jia ", "Jian ", "Zui ", "Kashi ", "Ori ", "Bin ", "Zhu ", "[?] ", "Xi ", "Qi ", "Lian ", "Hui ", "Yong ", "Qian ", "Guo ", "Gai ", "Gai ", "Tuan ", "Hua ", "Cu ", "Sen ", "Cui ", "Beng ", "You ", "Hu ", "Jiang ", "Hu ", "Huan ", "Kui ", "Yi ", "Nie ", "Gao ", "Kang ", "Gui ", "Gui ", "Cao ", "Man ", "Jin "];
  }
});

// node_modules/unidecode/data/x6a.js
var require_x6a = __commonJS({
  "node_modules/unidecode/data/x6a.js"(exports2, module2) {
    module2.exports = ["Di ", "Zhuang ", "Le ", "Lang ", "Chen ", "Cong ", "Li ", "Xiu ", "Qing ", "Shuang ", "Fan ", "Tong ", "Guan ", "Ji ", "Suo ", "Lei ", "Lu ", "Liang ", "Mi ", "Lou ", "Chao ", "Su ", "Ke ", "Shu ", "Tang ", "Biao ", "Lu ", "Jiu ", "Shu ", "Zha ", "Shu ", "Zhang ", "Men ", "Mo ", "Niao ", "Yang ", "Tiao ", "Peng ", "Zhu ", "Sha ", "Xi ", "Quan ", "Heng ", "Jian ", "Cong ", "[?] ", "Hokuso ", "Qiang ", "Tara ", "Ying ", "Er ", "Xin ", "Zhi ", "Qiao ", "Zui ", "Cong ", "Pu ", "Shu ", "Hua ", "Kui ", "Zhen ", "Zun ", "Yue ", "Zhan ", "Xi ", "Xun ", "Dian ", "Fa ", "Gan ", "Mo ", "Wu ", "Qiao ", "Nao ", "Lin ", "Liu ", "Qiao ", "Xian ", "Run ", "Fan ", "Zhan ", "Tuo ", "Lao ", "Yun ", "Shun ", "Tui ", "Cheng ", "Tang ", "Meng ", "Ju ", "Cheng ", "Su ", "Jue ", "Jue ", "Tan ", "Hui ", "Ji ", "Nuo ", "Xiang ", "Tuo ", "Ning ", "Rui ", "Zhu ", "Chuang ", "Zeng ", "Fen ", "Qiong ", "Ran ", "Heng ", "Cen ", "Gu ", "Liu ", "Lao ", "Gao ", "Chu ", "Zusa ", "Nude ", "Ca ", "San ", "Ji ", "Dou ", "Shou ", "Lu ", "[?] ", "[?] ", "Yuan ", "Ta ", "Shu ", "Jiang ", "Tan ", "Lin ", "Nong ", "Yin ", "Xi ", "Sui ", "Shan ", "Zui ", "Xuan ", "Cheng ", "Gan ", "Ju ", "Zui ", "Yi ", "Qin ", "Pu ", "Yan ", "Lei ", "Feng ", "Hui ", "Dang ", "Ji ", "Sui ", "Bo ", "Bi ", "Ding ", "Chu ", "Zhua ", "Kuai ", "Ji ", "Jie ", "Jia ", "Qing ", "Zhe ", "Jian ", "Qiang ", "Dao ", "Yi ", "Biao ", "Song ", "She ", "Lin ", "Kunugi ", "Cha ", "Meng ", "Yin ", "Tao ", "Tai ", "Mian ", "Qi ", "Toan ", "Bin ", "Huo ", "Ji ", "Qian ", "Mi ", "Ning ", "Yi ", "Gao ", "Jian ", "Yin ", "Er ", "Qing ", "Yan ", "Qi ", "Mi ", "Zhao ", "Gui ", "Chun ", "Ji ", "Kui ", "Po ", "Deng ", "Chu ", "[?] ", "Mian ", "You ", "Zhi ", "Guang ", "Qian ", "Lei ", "Lei ", "Sa ", "Lu ", "Li ", "Cuan ", "Lu ", "Mie ", "Hui ", "Ou ", "Lu ", "Jie ", "Gao ", "Du ", "Yuan ", "Li ", "Fei ", "Zhuo ", "Sou ", "Lian ", "Tamo ", "Chu ", "[?] ", "Zhu ", "Lu ", "Yan ", "Li ", "Zhu ", "Chen ", "Jie ", "E ", "Su ", "Huai ", "Nie ", "Yu ", "Long ", "Lai ", "[?] ", "Xian ", "Kwi ", "Ju ", "Xiao ", "Ling ", "Ying ", "Jian ", "Yin ", "You ", "Ying "];
  }
});

// node_modules/unidecode/data/x6b.js
var require_x6b = __commonJS({
  "node_modules/unidecode/data/x6b.js"(exports2, module2) {
    module2.exports = ["Xiang ", "Nong ", "Bo ", "Chan ", "Lan ", "Ju ", "Shuang ", "She ", "Wei ", "Cong ", "Quan ", "Qu ", "Cang ", "[?] ", "Yu ", "Luo ", "Li ", "Zan ", "Luan ", "Dang ", "Jue ", "Em ", "Lan ", "Lan ", "Zhu ", "Lei ", "Li ", "Ba ", "Nang ", "Yu ", "Ling ", "Tsuki ", "Qian ", "Ci ", "Huan ", "Xin ", "Yu ", "Yu ", "Qian ", "Ou ", "Xu ", "Chao ", "Chu ", "Chi ", "Kai ", "Yi ", "Jue ", "Xi ", "Xu ", "Xia ", "Yu ", "Kuai ", "Lang ", "Kuan ", "Shuo ", "Xi ", "Ai ", "Yi ", "Qi ", "Hu ", "Chi ", "Qin ", "Kuan ", "Kan ", "Kuan ", "Kan ", "Chuan ", "Sha ", "Gua ", "Yin ", "Xin ", "Xie ", "Yu ", "Qian ", "Xiao ", "Yi ", "Ge ", "Wu ", "Tan ", "Jin ", "Ou ", "Hu ", "Ti ", "Huan ", "Xu ", "Pen ", "Xi ", "Xiao ", "Xu ", "Xi ", "Sen ", "Lian ", "Chu ", "Yi ", "Kan ", "Yu ", "Chuo ", "Huan ", "Zhi ", "Zheng ", "Ci ", "Bu ", "Wu ", "Qi ", "Bu ", "Bu ", "Wai ", "Ju ", "Qian ", "Chi ", "Se ", "Chi ", "Se ", "Zhong ", "Sui ", "Sui ", "Li ", "Cuo ", "Yu ", "Li ", "Gui ", "Dai ", "Dai ", "Si ", "Jian ", "Zhe ", "Mo ", "Mo ", "Yao ", "Mo ", "Cu ", "Yang ", "Tian ", "Sheng ", "Dai ", "Shang ", "Xu ", "Xun ", "Shu ", "Can ", "Jue ", "Piao ", "Qia ", "Qiu ", "Su ", "Qing ", "Yun ", "Lian ", "Yi ", "Fou ", "Zhi ", "Ye ", "Can ", "Hun ", "Dan ", "Ji ", "Ye ", "Zhen ", "Yun ", "Wen ", "Chou ", "Bin ", "Ti ", "Jin ", "Shang ", "Yin ", "Diao ", "Cu ", "Hui ", "Cuan ", "Yi ", "Dan ", "Du ", "Jiang ", "Lian ", "Bin ", "Du ", "Tsukusu ", "Jian ", "Shu ", "Ou ", "Duan ", "Zhu ", "Yin ", "Qing ", "Yi ", "Sha ", "Que ", "Ke ", "Yao ", "Jun ", "Dian ", "Hui ", "Hui ", "Gu ", "Que ", "Ji ", "Yi ", "Ou ", "Hui ", "Duan ", "Yi ", "Xiao ", "Wu ", "Guan ", "Mu ", "Mei ", "Mei ", "Ai ", "Zuo ", "Du ", "Yu ", "Bi ", "Bi ", "Bi ", "Pi ", "Pi ", "Bi ", "Chan ", "Mao ", "[?] ", "[?] ", "Pu ", "Mushiru ", "Jia ", "Zhan ", "Sai ", "Mu ", "Tuo ", "Xun ", "Er ", "Rong ", "Xian ", "Ju ", "Mu ", "Hao ", "Qiu ", "Dou ", "Mushiru ", "Tan ", "Pei ", "Ju ", "Duo ", "Cui ", "Bi ", "San ", "[?] ", "Mao ", "Sui ", "Yu ", "Yu ", "Tuo ", "He ", "Jian ", "Ta ", "San "];
  }
});

// node_modules/unidecode/data/x6c.js
var require_x6c = __commonJS({
  "node_modules/unidecode/data/x6c.js"(exports2, module2) {
    module2.exports = ["Lu ", "Mu ", "Li ", "Tong ", "Rong ", "Chang ", "Pu ", "Luo ", "Zhan ", "Sao ", "Zhan ", "Meng ", "Luo ", "Qu ", "Die ", "Shi ", "Di ", "Min ", "Jue ", "Mang ", "Qi ", "Pie ", "Nai ", "Qi ", "Dao ", "Xian ", "Chuan ", "Fen ", "Ri ", "Nei ", "[?] ", "Fu ", "Shen ", "Dong ", "Qing ", "Qi ", "Yin ", "Xi ", "Hai ", "Yang ", "An ", "Ya ", "Ke ", "Qing ", "Ya ", "Dong ", "Dan ", "Lu ", "Qing ", "Yang ", "Yun ", "Yun ", "Shui ", "San ", "Zheng ", "Bing ", "Yong ", "Dang ", "Shitamizu ", "Le ", "Ni ", "Tun ", "Fan ", "Gui ", "Ting ", "Zhi ", "Qiu ", "Bin ", "Ze ", "Mian ", "Cuan ", "Hui ", "Diao ", "Yi ", "Cha ", "Zhuo ", "Chuan ", "Wan ", "Fan ", "Dai ", "Xi ", "Tuo ", "Mang ", "Qiu ", "Qi ", "Shan ", "Pai ", "Han ", "Qian ", "Wu ", "Wu ", "Xun ", "Si ", "Ru ", "Gong ", "Jiang ", "Chi ", "Wu ", "Tsuchi ", "[?] ", "Tang ", "Zhi ", "Chi ", "Qian ", "Mi ", "Yu ", "Wang ", "Qing ", "Jing ", "Rui ", "Jun ", "Hong ", "Tai ", "Quan ", "Ji ", "Bian ", "Bian ", "Gan ", "Wen ", "Zhong ", "Fang ", "Xiong ", "Jue ", "Hang ", "Niou ", "Qi ", "Fen ", "Xu ", "Xu ", "Qin ", "Yi ", "Wo ", "Yun ", "Yuan ", "Hang ", "Yan ", "Chen ", "Chen ", "Dan ", "You ", "Dun ", "Hu ", "Huo ", "Qie ", "Mu ", "Rou ", "Mei ", "Ta ", "Mian ", "Wu ", "Chong ", "Tian ", "Bi ", "Sha ", "Zhi ", "Pei ", "Pan ", "Zhui ", "Za ", "Gou ", "Liu ", "Mei ", "Ze ", "Feng ", "Ou ", "Li ", "Lun ", "Cang ", "Feng ", "Wei ", "Hu ", "Mo ", "Mei ", "Shu ", "Ju ", "Zan ", "Tuo ", "Tuo ", "Tuo ", "He ", "Li ", "Mi ", "Yi ", "Fa ", "Fei ", "You ", "Tian ", "Zhi ", "Zhao ", "Gu ", "Zhan ", "Yan ", "Si ", "Kuang ", "Jiong ", "Ju ", "Xie ", "Qiu ", "Yi ", "Jia ", "Zhong ", "Quan ", "Bo ", "Hui ", "Mi ", "Ben ", "Zhuo ", "Chu ", "Le ", "You ", "Gu ", "Hong ", "Gan ", "Fa ", "Mao ", "Si ", "Hu ", "Ping ", "Ci ", "Fan ", "Chi ", "Su ", "Ning ", "Cheng ", "Ling ", "Pao ", "Bo ", "Qi ", "Si ", "Ni ", "Ju ", "Yue ", "Zhu ", "Sheng ", "Lei ", "Xuan ", "Xue ", "Fu ", "Pan ", "Min ", "Tai ", "Yang ", "Ji ", "Yong ", "Guan ", "Beng ", "Xue ", "Long ", "Lu ", "[?] ", "Bo ", "Xie ", "Po ", "Ze ", "Jing ", "Yin "];
  }
});

// node_modules/unidecode/data/x6d.js
var require_x6d = __commonJS({
  "node_modules/unidecode/data/x6d.js"(exports2, module2) {
    module2.exports = ["Zhou ", "Ji ", "Yi ", "Hui ", "Hui ", "Zui ", "Cheng ", "Yin ", "Wei ", "Hou ", "Jian ", "Yang ", "Lie ", "Si ", "Ji ", "Er ", "Xing ", "Fu ", "Sa ", "Suo ", "Zhi ", "Yin ", "Wu ", "Xi ", "Kao ", "Zhu ", "Jiang ", "Luo ", "[?] ", "An ", "Dong ", "Yi ", "Mou ", "Lei ", "Yi ", "Mi ", "Quan ", "Jin ", "Mo ", "Wei ", "Xiao ", "Xie ", "Hong ", "Xu ", "Shuo ", "Kuang ", "Tao ", "Qie ", "Ju ", "Er ", "Zhou ", "Ru ", "Ping ", "Xun ", "Xiong ", "Zhi ", "Guang ", "Huan ", "Ming ", "Huo ", "Wa ", "Qia ", "Pai ", "Wu ", "Qu ", "Liu ", "Yi ", "Jia ", "Jing ", "Qian ", "Jiang ", "Jiao ", "Cheng ", "Shi ", "Zhuo ", "Ce ", "Pal ", "Kuai ", "Ji ", "Liu ", "Chan ", "Hun ", "Hu ", "Nong ", "Xun ", "Jin ", "Lie ", "Qiu ", "Wei ", "Zhe ", "Jun ", "Han ", "Bang ", "Mang ", "Zhuo ", "You ", "Xi ", "Bo ", "Dou ", "Wan ", "Hong ", "Yi ", "Pu ", "Ying ", "Lan ", "Hao ", "Lang ", "Han ", "Li ", "Geng ", "Fu ", "Wu ", "Lian ", "Chun ", "Feng ", "Yi ", "Yu ", "Tong ", "Lao ", "Hai ", "Jin ", "Jia ", "Chong ", "Weng ", "Mei ", "Sui ", "Cheng ", "Pei ", "Xian ", "Shen ", "Tu ", "Kun ", "Pin ", "Nie ", "Han ", "Jing ", "Xiao ", "She ", "Nian ", "Tu ", "Yong ", "Xiao ", "Xian ", "Ting ", "E ", "Su ", "Tun ", "Juan ", "Cen ", "Ti ", "Li ", "Shui ", "Si ", "Lei ", "Shui ", "Tao ", "Du ", "Lao ", "Lai ", "Lian ", "Wei ", "Wo ", "Yun ", "Huan ", "Di ", "[?] ", "Run ", "Jian ", "Zhang ", "Se ", "Fu ", "Guan ", "Xing ", "Shou ", "Shuan ", "Ya ", "Chuo ", "Zhang ", "Ye ", "Kong ", "Wo ", "Han ", "Tuo ", "Dong ", "He ", "Wo ", "Ju ", "Gan ", "Liang ", "Hun ", "Ta ", "Zhuo ", "Dian ", "Qie ", "De ", "Juan ", "Zi ", "Xi ", "Yao ", "Qi ", "Gu ", "Guo ", "Han ", "Lin ", "Tang ", "Zhou ", "Peng ", "Hao ", "Chang ", "Shu ", "Qi ", "Fang ", "Chi ", "Lu ", "Nao ", "Ju ", "Tao ", "Cong ", "Lei ", "Zhi ", "Peng ", "Fei ", "Song ", "Tian ", "Pi ", "Dan ", "Yu ", "Ni ", "Yu ", "Lu ", "Gan ", "Mi ", "Jing ", "Ling ", "Lun ", "Yin ", "Cui ", "Qu ", "Huai ", "Yu ", "Nian ", "Shen ", "Piao ", "Chun ", "Wa ", "Yuan ", "Lai ", "Hun ", "Qing ", "Yan ", "Qian ", "Tian ", "Miao ", "Zhi ", "Yin ", "Mi "];
  }
});

// node_modules/unidecode/data/x6e.js
var require_x6e = __commonJS({
  "node_modules/unidecode/data/x6e.js"(exports2, module2) {
    module2.exports = ["Ben ", "Yuan ", "Wen ", "Re ", "Fei ", "Qing ", "Yuan ", "Ke ", "Ji ", "She ", "Yuan ", "Shibui ", "Lu ", "Zi ", "Du ", "[?] ", "Jian ", "Min ", "Pi ", "Tani ", "Yu ", "Yuan ", "Shen ", "Shen ", "Rou ", "Huan ", "Zhu ", "Jian ", "Nuan ", "Yu ", "Qiu ", "Ting ", "Qu ", "Du ", "Feng ", "Zha ", "Bo ", "Wo ", "Wo ", "Di ", "Wei ", "Wen ", "Ru ", "Xie ", "Ce ", "Wei ", "Ge ", "Gang ", "Yan ", "Hong ", "Xuan ", "Mi ", "Ke ", "Mao ", "Ying ", "Yan ", "You ", "Hong ", "Miao ", "Xing ", "Mei ", "Zai ", "Hun ", "Nai ", "Kui ", "Shi ", "E ", "Pai ", "Mei ", "Lian ", "Qi ", "Qi ", "Mei ", "Tian ", "Cou ", "Wei ", "Can ", "Tuan ", "Mian ", "Hui ", "Mo ", "Xu ", "Ji ", "Pen ", "Jian ", "Jian ", "Hu ", "Feng ", "Xiang ", "Yi ", "Yin ", "Zhan ", "Shi ", "Jie ", "Cheng ", "Huang ", "Tan ", "Yu ", "Bi ", "Min ", "Shi ", "Tu ", "Sheng ", "Yong ", "Qu ", "Zhong ", "Suei ", "Jiu ", "Jiao ", "Qiou ", "Yin ", "Tang ", "Long ", "Huo ", "Yuan ", "Nan ", "Ban ", "You ", "Quan ", "Chui ", "Liang ", "Chan ", "Yan ", "Chun ", "Nie ", "Zi ", "Wan ", "Shi ", "Man ", "Ying ", "Ratsu ", "Kui ", "[?] ", "Jian ", "Xu ", "Lu ", "Gui ", "Gai ", "[?] ", "[?] ", "Po ", "Jin ", "Gui ", "Tang ", "Yuan ", "Suo ", "Yuan ", "Lian ", "Yao ", "Meng ", "Zhun ", "Sheng ", "Ke ", "Tai ", "Da ", "Wa ", "Liu ", "Gou ", "Sao ", "Ming ", "Zha ", "Shi ", "Yi ", "Lun ", "Ma ", "Pu ", "Wei ", "Li ", "Cai ", "Wu ", "Xi ", "Wen ", "Qiang ", "Ze ", "Shi ", "Su ", "Yi ", "Zhen ", "Sou ", "Yun ", "Xiu ", "Yin ", "Rong ", "Hun ", "Su ", "Su ", "Ni ", "Ta ", "Shi ", "Ru ", "Wei ", "Pan ", "Chu ", "Chu ", "Pang ", "Weng ", "Cang ", "Mie ", "He ", "Dian ", "Hao ", "Huang ", "Xi ", "Zi ", "Di ", "Zhi ", "Ying ", "Fu ", "Jie ", "Hua ", "Ge ", "Zi ", "Tao ", "Teng ", "Sui ", "Bi ", "Jiao ", "Hui ", "Gun ", "Yin ", "Gao ", "Long ", "Zhi ", "Yan ", "She ", "Man ", "Ying ", "Chun ", "Lu ", "Lan ", "Luan ", "[?] ", "Bin ", "Tan ", "Yu ", "Sou ", "Hu ", "Bi ", "Biao ", "Zhi ", "Jiang ", "Kou ", "Shen ", "Shang ", "Di ", "Mi ", "Ao ", "Lu ", "Hu ", "Hu ", "You ", "Chan ", "Fan ", "Yong ", "Gun ", "Man "];
  }
});

// node_modules/unidecode/data/x6f.js
var require_x6f = __commonJS({
  "node_modules/unidecode/data/x6f.js"(exports2, module2) {
    module2.exports = ["Qing ", "Yu ", "Piao ", "Ji ", "Ya ", "Jiao ", "Qi ", "Xi ", "Ji ", "Lu ", "Lu ", "Long ", "Jin ", "Guo ", "Cong ", "Lou ", "Zhi ", "Gai ", "Qiang ", "Li ", "Yan ", "Cao ", "Jiao ", "Cong ", "Qun ", "Tuan ", "Ou ", "Teng ", "Ye ", "Xi ", "Mi ", "Tang ", "Mo ", "Shang ", "Han ", "Lian ", "Lan ", "Wa ", "Li ", "Qian ", "Feng ", "Xuan ", "Yi ", "Man ", "Zi ", "Mang ", "Kang ", "Lei ", "Peng ", "Shu ", "Zhang ", "Zhang ", "Chong ", "Xu ", "Huan ", "Kuo ", "Jian ", "Yan ", "Chuang ", "Liao ", "Cui ", "Ti ", "Yang ", "Jiang ", "Cong ", "Ying ", "Hong ", "Xun ", "Shu ", "Guan ", "Ying ", "Xiao ", "[?] ", "[?] ", "Xu ", "Lian ", "Zhi ", "Wei ", "Pi ", "Jue ", "Jiao ", "Po ", "Dang ", "Hui ", "Jie ", "Wu ", "Pa ", "Ji ", "Pan ", "Gui ", "Xiao ", "Qian ", "Qian ", "Xi ", "Lu ", "Xi ", "Xuan ", "Dun ", "Huang ", "Min ", "Run ", "Su ", "Liao ", "Zhen ", "Zhong ", "Yi ", "Di ", "Wan ", "Dan ", "Tan ", "Chao ", "Xun ", "Kui ", "Yie ", "Shao ", "Tu ", "Zhu ", "San ", "Hei ", "Bi ", "Shan ", "Chan ", "Chan ", "Shu ", "Tong ", "Pu ", "Lin ", "Wei ", "Se ", "Se ", "Cheng ", "Jiong ", "Cheng ", "Hua ", "Jiao ", "Lao ", "Che ", "Gan ", "Cun ", "Heng ", "Si ", "Shu ", "Peng ", "Han ", "Yun ", "Liu ", "Hong ", "Fu ", "Hao ", "He ", "Xian ", "Jian ", "Shan ", "Xi ", "Oki ", "[?] ", "Lan ", "[?] ", "Yu ", "Lin ", "Min ", "Zao ", "Dang ", "Wan ", "Ze ", "Xie ", "Yu ", "Li ", "Shi ", "Xue ", "Ling ", "Man ", "Zi ", "Yong ", "Kuai ", "Can ", "Lian ", "Dian ", "Ye ", "Ao ", "Huan ", "Zhen ", "Chan ", "Man ", "Dan ", "Dan ", "Yi ", "Sui ", "Pi ", "Ju ", "Ta ", "Qin ", "Ji ", "Zhuo ", "Lian ", "Nong ", "Guo ", "Jin ", "Fen ", "Se ", "Ji ", "Sui ", "Hui ", "Chu ", "Ta ", "Song ", "Ding ", "[?] ", "Zhu ", "Lai ", "Bin ", "Lian ", "Mi ", "Shi ", "Shu ", "Mi ", "Ning ", "Ying ", "Ying ", "Meng ", "Jin ", "Qi ", "Pi ", "Ji ", "Hao ", "Ru ", "Zui ", "Wo ", "Tao ", "Yin ", "Yin ", "Dui ", "Ci ", "Huo ", "Jing ", "Lan ", "Jun ", "Ai ", "Pu ", "Zhuo ", "Wei ", "Bin ", "Gu ", "Qian ", "Xing ", "Hama ", "Kuo ", "Fei ", "[?] ", "Boku ", "Jian ", "Wei ", "Luo ", "Zan ", "Lu ", "Li "];
  }
});

// node_modules/unidecode/data/x70.js
var require_x70 = __commonJS({
  "node_modules/unidecode/data/x70.js"(exports2, module2) {
    module2.exports = ["You ", "Yang ", "Lu ", "Si ", "Jie ", "Ying ", "Du ", "Wang ", "Hui ", "Xie ", "Pan ", "Shen ", "Biao ", "Chan ", "Mo ", "Liu ", "Jian ", "Pu ", "Se ", "Cheng ", "Gu ", "Bin ", "Huo ", "Xian ", "Lu ", "Qin ", "Han ", "Ying ", "Yong ", "Li ", "Jing ", "Xiao ", "Ying ", "Sui ", "Wei ", "Xie ", "Huai ", "Hao ", "Zhu ", "Long ", "Lai ", "Dui ", "Fan ", "Hu ", "Lai ", "[?] ", "[?] ", "Ying ", "Mi ", "Ji ", "Lian ", "Jian ", "Ying ", "Fen ", "Lin ", "Yi ", "Jian ", "Yue ", "Chan ", "Dai ", "Rang ", "Jian ", "Lan ", "Fan ", "Shuang ", "Yuan ", "Zhuo ", "Feng ", "She ", "Lei ", "Lan ", "Cong ", "Qu ", "Yong ", "Qian ", "Fa ", "Guan ", "Que ", "Yan ", "Hao ", "Hyeng ", "Sa ", "Zan ", "Luan ", "Yan ", "Li ", "Mi ", "Shan ", "Tan ", "Dang ", "Jiao ", "Chan ", "[?] ", "Hao ", "Ba ", "Zhu ", "Lan ", "Lan ", "Nang ", "Wan ", "Luan ", "Xun ", "Xian ", "Yan ", "Gan ", "Yan ", "Yu ", "Huo ", "Si ", "Mie ", "Guang ", "Deng ", "Hui ", "Xiao ", "Xiao ", "Hu ", "Hong ", "Ling ", "Zao ", "Zhuan ", "Jiu ", "Zha ", "Xie ", "Chi ", "Zhuo ", "Zai ", "Zai ", "Can ", "Yang ", "Qi ", "Zhong ", "Fen ", "Niu ", "Jiong ", "Wen ", "Po ", "Yi ", "Lu ", "Chui ", "Pi ", "Kai ", "Pan ", "Yan ", "Kai ", "Pang ", "Mu ", "Chao ", "Liao ", "Gui ", "Kang ", "Tun ", "Guang ", "Xin ", "Zhi ", "Guang ", "Guang ", "Wei ", "Qiang ", "[?] ", "Da ", "Xia ", "Zheng ", "Zhu ", "Ke ", "Zhao ", "Fu ", "Ba ", "Duo ", "Duo ", "Ling ", "Zhuo ", "Xuan ", "Ju ", "Tan ", "Pao ", "Jiong ", "Pao ", "Tai ", "Tai ", "Bing ", "Yang ", "Tong ", "Han ", "Zhu ", "Zha ", "Dian ", "Wei ", "Shi ", "Lian ", "Chi ", "Huang ", "[?] ", "Hu ", "Shuo ", "Lan ", "Jing ", "Jiao ", "Xu ", "Xing ", "Quan ", "Lie ", "Huan ", "Yang ", "Xiao ", "Xiu ", "Xian ", "Yin ", "Wu ", "Zhou ", "Yao ", "Shi ", "Wei ", "Tong ", "Xue ", "Zai ", "Kai ", "Hong ", "Luo ", "Xia ", "Zhu ", "Xuan ", "Zheng ", "Po ", "Yan ", "Hui ", "Guang ", "Zhe ", "Hui ", "Kao ", "[?] ", "Fan ", "Shao ", "Ye ", "Hui ", "[?] ", "Tang ", "Jin ", "Re ", "[?] ", "Xi ", "Fu ", "Jiong ", "Che ", "Pu ", "Jing ", "Zhuo ", "Ting ", "Wan ", "Hai ", "Peng ", "Lang ", "Shan ", "Hu ", "Feng ", "Chi ", "Rong "];
  }
});

// node_modules/unidecode/data/x71.js
var require_x71 = __commonJS({
  "node_modules/unidecode/data/x71.js"(exports2, module2) {
    module2.exports = ["Hu ", "Xi ", "Shu ", "He ", "Xun ", "Ku ", "Jue ", "Xiao ", "Xi ", "Yan ", "Han ", "Zhuang ", "Jun ", "Di ", "Xie ", "Ji ", "Wu ", "[?] ", "[?] ", "Han ", "Yan ", "Huan ", "Men ", "Ju ", "Chou ", "Bei ", "Fen ", "Lin ", "Kun ", "Hun ", "Tun ", "Xi ", "Cui ", "Wu ", "Hong ", "Ju ", "Fu ", "Wo ", "Jiao ", "Cong ", "Feng ", "Ping ", "Qiong ", "Ruo ", "Xi ", "Qiong ", "Xin ", "Zhuo ", "Yan ", "Yan ", "Yi ", "Jue ", "Yu ", "Gang ", "Ran ", "Pi ", "Gu ", "[?] ", "Sheng ", "Chang ", "Shao ", "[?] ", "[?] ", "[?] ", "[?] ", "Chen ", "He ", "Kui ", "Zhong ", "Duan ", "Xia ", "Hui ", "Feng ", "Lian ", "Xuan ", "Xing ", "Huang ", "Jiao ", "Jian ", "Bi ", "Ying ", "Zhu ", "Wei ", "Tuan ", "Tian ", "Xi ", "Nuan ", "Nuan ", "Chan ", "Yan ", "Jiong ", "Jiong ", "Yu ", "Mei ", "Sha ", "Wei ", "Ye ", "Xin ", "Qiong ", "Rou ", "Mei ", "Huan ", "Xu ", "Zhao ", "Wei ", "Fan ", "Qiu ", "Sui ", "Yang ", "Lie ", "Zhu ", "Jie ", "Gao ", "Gua ", "Bao ", "Hu ", "Yun ", "Xia ", "[?] ", "[?] ", "Bian ", "Gou ", "Tui ", "Tang ", "Chao ", "Shan ", "N ", "Bo ", "Huang ", "Xie ", "Xi ", "Wu ", "Xi ", "Yun ", "He ", "He ", "Xi ", "Yun ", "Xiong ", "Nai ", "Shan ", "Qiong ", "Yao ", "Xun ", "Mi ", "Lian ", "Ying ", "Wen ", "Rong ", "Oozutsu ", "[?] ", "Qiang ", "Liu ", "Xi ", "Bi ", "Biao ", "Zong ", "Lu ", "Jian ", "Shou ", "Yi ", "Lou ", "Feng ", "Sui ", "Yi ", "Tong ", "Jue ", "Zong ", "Yun ", "Hu ", "Yi ", "Zhi ", "Ao ", "Wei ", "Liao ", "Han ", "Ou ", "Re ", "Jiong ", "Man ", "[?] ", "Shang ", "Cuan ", "Zeng ", "Jian ", "Xi ", "Xi ", "Xi ", "Yi ", "Xiao ", "Chi ", "Huang ", "Chan ", "Ye ", "Qian ", "Ran ", "Yan ", "Xian ", "Qiao ", "Zun ", "Deng ", "Dun ", "Shen ", "Jiao ", "Fen ", "Si ", "Liao ", "Yu ", "Lin ", "Tong ", "Shao ", "Fen ", "Fan ", "Yan ", "Xun ", "Lan ", "Mei ", "Tang ", "Yi ", "Jing ", "Men ", "[?] ", "[?] ", "Ying ", "Yu ", "Yi ", "Xue ", "Lan ", "Tai ", "Zao ", "Can ", "Sui ", "Xi ", "Que ", "Cong ", "Lian ", "Hui ", "Zhu ", "Xie ", "Ling ", "Wei ", "Yi ", "Xie ", "Zhao ", "Hui ", "Tatsu ", "Nung ", "Lan ", "Ru ", "Xian ", "Kao ", "Xun ", "Jin ", "Chou ", "Chou ", "Yao "];
  }
});

// node_modules/unidecode/data/x72.js
var require_x72 = __commonJS({
  "node_modules/unidecode/data/x72.js"(exports2, module2) {
    module2.exports = ["He ", "Lan ", "Biao ", "Rong ", "Li ", "Mo ", "Bao ", "Ruo ", "Lu ", "La ", "Ao ", "Xun ", "Kuang ", "Shuo ", "[?] ", "Li ", "Lu ", "Jue ", "Liao ", "Yan ", "Xi ", "Xie ", "Long ", "Ye ", "[?] ", "Rang ", "Yue ", "Lan ", "Cong ", "Jue ", "Tong ", "Guan ", "[?] ", "Che ", "Mi ", "Tang ", "Lan ", "Zhu ", "[?] ", "Ling ", "Cuan ", "Yu ", "Zhua ", "Tsumekanmuri ", "Pa ", "Zheng ", "Pao ", "Cheng ", "Yuan ", "Ai ", "Wei ", "[?] ", "Jue ", "Jue ", "Fu ", "Ye ", "Ba ", "Die ", "Ye ", "Yao ", "Zu ", "Shuang ", "Er ", "Qiang ", "Chuang ", "Ge ", "Zang ", "Die ", "Qiang ", "Yong ", "Qiang ", "Pian ", "Ban ", "Pan ", "Shao ", "Jian ", "Pai ", "Du ", "Chuang ", "Tou ", "Zha ", "Bian ", "Die ", "Bang ", "Bo ", "Chuang ", "You ", "[?] ", "Du ", "Ya ", "Cheng ", "Niu ", "Ushihen ", "Pin ", "Jiu ", "Mou ", "Tuo ", "Mu ", "Lao ", "Ren ", "Mang ", "Fang ", "Mao ", "Mu ", "Gang ", "Wu ", "Yan ", "Ge ", "Bei ", "Si ", "Jian ", "Gu ", "You ", "Ge ", "Sheng ", "Mu ", "Di ", "Qian ", "Quan ", "Quan ", "Zi ", "Te ", "Xi ", "Mang ", "Keng ", "Qian ", "Wu ", "Gu ", "Xi ", "Li ", "Li ", "Pou ", "Ji ", "Gang ", "Zhi ", "Ben ", "Quan ", "Run ", "Du ", "Ju ", "Jia ", "Jian ", "Feng ", "Pian ", "Ke ", "Ju ", "Kao ", "Chu ", "Xi ", "Bei ", "Luo ", "Jie ", "Ma ", "San ", "Wei ", "Li ", "Dun ", "Tong ", "[?] ", "Jiang ", "Ikenie ", "Li ", "Du ", "Lie ", "Pi ", "Piao ", "Bao ", "Xi ", "Chou ", "Wei ", "Kui ", "Chou ", "Quan ", "Fan ", "Ba ", "Fan ", "Qiu ", "Ji ", "Cai ", "Chuo ", "An ", "Jie ", "Zhuang ", "Guang ", "Ma ", "You ", "Kang ", "Bo ", "Hou ", "Ya ", "Yin ", "Huan ", "Zhuang ", "Yun ", "Kuang ", "Niu ", "Di ", "Qing ", "Zhong ", "Mu ", "Bei ", "Pi ", "Ju ", "Ni ", "Sheng ", "Pao ", "Xia ", "Tuo ", "Hu ", "Ling ", "Fei ", "Pi ", "Ni ", "Ao ", "You ", "Gou ", "Yue ", "Ju ", "Dan ", "Po ", "Gu ", "Xian ", "Ning ", "Huan ", "Hen ", "Jiao ", "He ", "Zhao ", "Ji ", "Xun ", "Shan ", "Ta ", "Rong ", "Shou ", "Tong ", "Lao ", "Du ", "Xia ", "Shi ", "Hua ", "Zheng ", "Yu ", "Sun ", "Yu ", "Bi ", "Mang ", "Xi ", "Juan ", "Li ", "Xia ", "Yin ", "Suan ", "Lang ", "Bei ", "Zhi ", "Yan "];
  }
});

// node_modules/unidecode/data/x73.js
var require_x73 = __commonJS({
  "node_modules/unidecode/data/x73.js"(exports2, module2) {
    module2.exports = ["Sha ", "Li ", "Han ", "Xian ", "Jing ", "Pai ", "Fei ", "Yao ", "Ba ", "Qi ", "Ni ", "Biao ", "Yin ", "Lai ", "Xi ", "Jian ", "Qiang ", "Kun ", "Yan ", "Guo ", "Zong ", "Mi ", "Chang ", "Yi ", "Zhi ", "Zheng ", "Ya ", "Meng ", "Cai ", "Cu ", "She ", "Kari ", "Cen ", "Luo ", "Hu ", "Zong ", "Ji ", "Wei ", "Feng ", "Wo ", "Yuan ", "Xing ", "Zhu ", "Mao ", "Wei ", "Yuan ", "Xian ", "Tuan ", "Ya ", "Nao ", "Xie ", "Jia ", "Hou ", "Bian ", "You ", "You ", "Mei ", "Zha ", "Yao ", "Sun ", "Bo ", "Ming ", "Hua ", "Yuan ", "Sou ", "Ma ", "Yuan ", "Dai ", "Yu ", "Shi ", "Hao ", "[?] ", "Yi ", "Zhen ", "Chuang ", "Hao ", "Man ", "Jing ", "Jiang ", "Mu ", "Zhang ", "Chan ", "Ao ", "Ao ", "Hao ", "Cui ", "Fen ", "Jue ", "Bi ", "Bi ", "Huang ", "Pu ", "Lin ", "Yu ", "Tong ", "Yao ", "Liao ", "Shuo ", "Xiao ", "Swu ", "Ton ", "Xi ", "Ge ", "Juan ", "Du ", "Hui ", "Kuai ", "Xian ", "Xie ", "Ta ", "Xian ", "Xun ", "Ning ", "Pin ", "Huo ", "Nou ", "Meng ", "Lie ", "Nao ", "Guang ", "Shou ", "Lu ", "Ta ", "Xian ", "Mi ", "Rang ", "Huan ", "Nao ", "Luo ", "Xian ", "Qi ", "Jue ", "Xuan ", "Miao ", "Zi ", "Lu ", "Lu ", "Yu ", "Su ", "Wang ", "Qiu ", "Ga ", "Ding ", "Le ", "Ba ", "Ji ", "Hong ", "Di ", "Quan ", "Gan ", "Jiu ", "Yu ", "Ji ", "Yu ", "Yang ", "Ma ", "Gong ", "Wu ", "Fu ", "Wen ", "Jie ", "Ya ", "Fen ", "Bian ", "Beng ", "Yue ", "Jue ", "Yun ", "Jue ", "Wan ", "Jian ", "Mei ", "Dan ", "Pi ", "Wei ", "Huan ", "Xian ", "Qiang ", "Ling ", "Dai ", "Yi ", "An ", "Ping ", "Dian ", "Fu ", "Xuan ", "Xi ", "Bo ", "Ci ", "Gou ", "Jia ", "Shao ", "Po ", "Ci ", "Ke ", "Ran ", "Sheng ", "Shen ", "Yi ", "Zu ", "Jia ", "Min ", "Shan ", "Liu ", "Bi ", "Zhen ", "Zhen ", "Jue ", "Fa ", "Long ", "Jin ", "Jiao ", "Jian ", "Li ", "Guang ", "Xian ", "Zhou ", "Gong ", "Yan ", "Xiu ", "Yang ", "Xu ", "Luo ", "Su ", "Zhu ", "Qin ", "Ken ", "Xun ", "Bao ", "Er ", "Xiang ", "Yao ", "Xia ", "Heng ", "Gui ", "Chong ", "Xu ", "Ban ", "Pei ", "[?] ", "Dang ", "Ei ", "Hun ", "Wen ", "E ", "Cheng ", "Ti ", "Wu ", "Wu ", "Cheng ", "Jun ", "Mei ", "Bei ", "Ting ", "Xian ", "Chuo "];
  }
});

// node_modules/unidecode/data/x74.js
var require_x74 = __commonJS({
  "node_modules/unidecode/data/x74.js"(exports2, module2) {
    module2.exports = ["Han ", "Xuan ", "Yan ", "Qiu ", "Quan ", "Lang ", "Li ", "Xiu ", "Fu ", "Liu ", "Ye ", "Xi ", "Ling ", "Li ", "Jin ", "Lian ", "Suo ", "Chiisai ", "[?] ", "Wan ", "Dian ", "Pin ", "Zhan ", "Cui ", "Min ", "Yu ", "Ju ", "Chen ", "Lai ", "Wen ", "Sheng ", "Wei ", "Dian ", "Chu ", "Zhuo ", "Pei ", "Cheng ", "Hu ", "Qi ", "E ", "Kun ", "Chang ", "Qi ", "Beng ", "Wan ", "Lu ", "Cong ", "Guan ", "Yan ", "Diao ", "Bei ", "Lin ", "Qin ", "Pi ", "Pa ", "Que ", "Zhuo ", "Qin ", "Fa ", "[?] ", "Qiong ", "Du ", "Jie ", "Hun ", "Yu ", "Mao ", "Mei ", "Chun ", "Xuan ", "Ti ", "Xing ", "Dai ", "Rou ", "Min ", "Zhen ", "Wei ", "Ruan ", "Huan ", "Jie ", "Chuan ", "Jian ", "Zhuan ", "Yang ", "Lian ", "Quan ", "Xia ", "Duan ", "Yuan ", "Ye ", "Nao ", "Hu ", "Ying ", "Yu ", "Huang ", "Rui ", "Se ", "Liu ", "Shi ", "Rong ", "Suo ", "Yao ", "Wen ", "Wu ", "Jin ", "Jin ", "Ying ", "Ma ", "Tao ", "Liu ", "Tang ", "Li ", "Lang ", "Gui ", "Zhen ", "Qiang ", "Cuo ", "Jue ", "Zhao ", "Yao ", "Ai ", "Bin ", "Tu ", "Chang ", "Kun ", "Zhuan ", "Cong ", "Jin ", "Yi ", "Cui ", "Cong ", "Qi ", "Li ", "Ying ", "Suo ", "Qiu ", "Xuan ", "Ao ", "Lian ", "Man ", "Zhang ", "Yin ", "[?] ", "Ying ", "Zhi ", "Lu ", "Wu ", "Deng ", "Xiou ", "Zeng ", "Xun ", "Qu ", "Dang ", "Lin ", "Liao ", "Qiong ", "Su ", "Huang ", "Gui ", "Pu ", "Jing ", "Fan ", "Jin ", "Liu ", "Ji ", "[?] ", "Jing ", "Ai ", "Bi ", "Can ", "Qu ", "Zao ", "Dang ", "Jiao ", "Gun ", "Tan ", "Hui ", "Huan ", "Se ", "Sui ", "Tian ", "[?] ", "Yu ", "Jin ", "Lu ", "Bin ", "Shou ", "Wen ", "Zui ", "Lan ", "Xi ", "Ji ", "Xuan ", "Ruan ", "Huo ", "Gai ", "Lei ", "Du ", "Li ", "Zhi ", "Rou ", "Li ", "Zan ", "Qiong ", "Zhe ", "Gui ", "Sui ", "La ", "Long ", "Lu ", "Li ", "Zan ", "Lan ", "Ying ", "Mi ", "Xiang ", "Xi ", "Guan ", "Dao ", "Zan ", "Huan ", "Gua ", "Bo ", "Die ", "Bao ", "Hu ", "Zhi ", "Piao ", "Ban ", "Rang ", "Li ", "Wa ", "Dekaguramu ", "Jiang ", "Qian ", "Fan ", "Pen ", "Fang ", "Dan ", "Weng ", "Ou ", "Deshiguramu ", "Miriguramu ", "Thon ", "Hu ", "Ling ", "Yi ", "Ping ", "Ci ", "Hekutogura ", "Juan ", "Chang ", "Chi ", "Sarake ", "Dang ", "Meng ", "Pou "];
  }
});

// node_modules/unidecode/data/x75.js
var require_x75 = __commonJS({
  "node_modules/unidecode/data/x75.js"(exports2, module2) {
    module2.exports = ["Zhui ", "Ping ", "Bian ", "Zhou ", "Zhen ", "Senchigura ", "Ci ", "Ying ", "Qi ", "Xian ", "Lou ", "Di ", "Ou ", "Meng ", "Zhuan ", "Peng ", "Lin ", "Zeng ", "Wu ", "Pi ", "Dan ", "Weng ", "Ying ", "Yan ", "Gan ", "Dai ", "Shen ", "Tian ", "Tian ", "Han ", "Chang ", "Sheng ", "Qing ", "Sheng ", "Chan ", "Chan ", "Rui ", "Sheng ", "Su ", "Sen ", "Yong ", "Shuai ", "Lu ", "Fu ", "Yong ", "Beng ", "Feng ", "Ning ", "Tian ", "You ", "Jia ", "Shen ", "Zha ", "Dian ", "Fu ", "Nan ", "Dian ", "Ping ", "Ting ", "Hua ", "Ting ", "Quan ", "Zi ", "Meng ", "Bi ", "Qi ", "Liu ", "Xun ", "Liu ", "Chang ", "Mu ", "Yun ", "Fan ", "Fu ", "Geng ", "Tian ", "Jie ", "Jie ", "Quan ", "Wei ", "Fu ", "Tian ", "Mu ", "Tap ", "Pan ", "Jiang ", "Wa ", "Da ", "Nan ", "Liu ", "Ben ", "Zhen ", "Chu ", "Mu ", "Mu ", "Ce ", "Cen ", "Gai ", "Bi ", "Da ", "Zhi ", "Lue ", "Qi ", "Lue ", "Pan ", "Kesa ", "Fan ", "Hua ", "Yu ", "Yu ", "Mu ", "Jun ", "Yi ", "Liu ", "Yu ", "Die ", "Chou ", "Hua ", "Dang ", "Chuo ", "Ji ", "Wan ", "Jiang ", "Sheng ", "Chang ", "Tuan ", "Lei ", "Ji ", "Cha ", "Liu ", "Tatamu ", "Tuan ", "Lin ", "Jiang ", "Jiang ", "Chou ", "Bo ", "Die ", "Die ", "Pi ", "Nie ", "Dan ", "Shu ", "Shu ", "Zhi ", "Yi ", "Chuang ", "Nai ", "Ding ", "Bi ", "Jie ", "Liao ", "Gong ", "Ge ", "Jiu ", "Zhou ", "Xia ", "Shan ", "Xu ", "Nue ", "Li ", "Yang ", "Chen ", "You ", "Ba ", "Jie ", "Jue ", "Zhi ", "Xia ", "Cui ", "Bi ", "Yi ", "Li ", "Zong ", "Chuang ", "Feng ", "Zhu ", "Pao ", "Pi ", "Gan ", "Ke ", "Ci ", "Xie ", "Qi ", "Dan ", "Zhen ", "Fa ", "Zhi ", "Teng ", "Ju ", "Ji ", "Fei ", "Qu ", "Dian ", "Jia ", "Xian ", "Cha ", "Bing ", "Ni ", "Zheng ", "Yong ", "Jing ", "Quan ", "Chong ", "Tong ", "Yi ", "Kai ", "Wei ", "Hui ", "Duo ", "Yang ", "Chi ", "Zhi ", "Hen ", "Ya ", "Mei ", "Dou ", "Jing ", "Xiao ", "Tong ", "Tu ", "Mang ", "Pi ", "Xiao ", "Suan ", "Pu ", "Li ", "Zhi ", "Cuo ", "Duo ", "Wu ", "Sha ", "Lao ", "Shou ", "Huan ", "Xian ", "Yi ", "Peng ", "Zhang ", "Guan ", "Tan ", "Fei ", "Ma ", "Lin ", "Chi ", "Ji ", "Dian ", "An ", "Chi ", "Bi ", "Bei ", "Min ", "Gu ", "Dui ", "E ", "Wei "];
  }
});

// node_modules/unidecode/data/x76.js
var require_x76 = __commonJS({
  "node_modules/unidecode/data/x76.js"(exports2, module2) {
    module2.exports = ["Yu ", "Cui ", "Ya ", "Zhu ", "Cu ", "Dan ", "Shen ", "Zhung ", "Ji ", "Yu ", "Hou ", "Feng ", "La ", "Yang ", "Shen ", "Tu ", "Yu ", "Gua ", "Wen ", "Huan ", "Ku ", "Jia ", "Yin ", "Yi ", "Lu ", "Sao ", "Jue ", "Chi ", "Xi ", "Guan ", "Yi ", "Wen ", "Ji ", "Chuang ", "Ban ", "Lei ", "Liu ", "Chai ", "Shou ", "Nue ", "Dian ", "Da ", "Pie ", "Tan ", "Zhang ", "Biao ", "Shen ", "Cu ", "Luo ", "Yi ", "Zong ", "Chou ", "Zhang ", "Zhai ", "Sou ", "Suo ", "Que ", "Diao ", "Lou ", "Lu ", "Mo ", "Jin ", "Yin ", "Ying ", "Huang ", "Fu ", "Liao ", "Long ", "Qiao ", "Liu ", "Lao ", "Xian ", "Fei ", "Dan ", "Yin ", "He ", "Yan ", "Ban ", "Xian ", "Guan ", "Guai ", "Nong ", "Yu ", "Wei ", "Yi ", "Yong ", "Pi ", "Lei ", "Li ", "Shu ", "Dan ", "Lin ", "Dian ", "Lin ", "Lai ", "Pie ", "Ji ", "Chi ", "Yang ", "Xian ", "Jie ", "Zheng ", "[?] ", "Li ", "Huo ", "Lai ", "Shaku ", "Dian ", "Xian ", "Ying ", "Yin ", "Qu ", "Yong ", "Tan ", "Dian ", "Luo ", "Luan ", "Luan ", "Bo ", "[?] ", "Gui ", "Po ", "Fa ", "Deng ", "Fa ", "Bai ", "Bai ", "Qie ", "Bi ", "Zao ", "Zao ", "Mao ", "De ", "Pa ", "Jie ", "Huang ", "Gui ", "Ci ", "Ling ", "Gao ", "Mo ", "Ji ", "Jiao ", "Peng ", "Gao ", "Ai ", "E ", "Hao ", "Han ", "Bi ", "Wan ", "Chou ", "Qian ", "Xi ", "Ai ", "Jiong ", "Hao ", "Huang ", "Hao ", "Ze ", "Cui ", "Hao ", "Xiao ", "Ye ", "Po ", "Hao ", "Jiao ", "Ai ", "Xing ", "Huang ", "Li ", "Piao ", "He ", "Jiao ", "Pi ", "Gan ", "Pao ", "Zhou ", "Jun ", "Qiu ", "Cun ", "Que ", "Zha ", "Gu ", "Jun ", "Jun ", "Zhou ", "Zha ", "Gu ", "Zhan ", "Du ", "Min ", "Qi ", "Ying ", "Yu ", "Bei ", "Zhao ", "Zhong ", "Pen ", "He ", "Ying ", "He ", "Yi ", "Bo ", "Wan ", "He ", "Ang ", "Zhan ", "Yan ", "Jian ", "He ", "Yu ", "Kui ", "Fan ", "Gai ", "Dao ", "Pan ", "Fu ", "Qiu ", "Sheng ", "Dao ", "Lu ", "Zhan ", "Meng ", "Li ", "Jin ", "Xu ", "Jian ", "Pan ", "Guan ", "An ", "Lu ", "Shu ", "Zhou ", "Dang ", "An ", "Gu ", "Li ", "Mu ", "Cheng ", "Gan ", "Xu ", "Mang ", "Mang ", "Zhi ", "Qi ", "Ruan ", "Tian ", "Xiang ", "Dun ", "Xin ", "Xi ", "Pan ", "Feng ", "Dun ", "Min "];
  }
});

// node_modules/unidecode/data/x77.js
var require_x77 = __commonJS({
  "node_modules/unidecode/data/x77.js"(exports2, module2) {
    module2.exports = ["Ming ", "Sheng ", "Shi ", "Yun ", "Mian ", "Pan ", "Fang ", "Miao ", "Dan ", "Mei ", "Mao ", "Kan ", "Xian ", "Ou ", "Shi ", "Yang ", "Zheng ", "Yao ", "Shen ", "Huo ", "Da ", "Zhen ", "Kuang ", "Ju ", "Shen ", "Chi ", "Sheng ", "Mei ", "Mo ", "Zhu ", "Zhen ", "Zhen ", "Mian ", "Di ", "Yuan ", "Die ", "Yi ", "Zi ", "Zi ", "Chao ", "Zha ", "Xuan ", "Bing ", "Mi ", "Long ", "Sui ", "Dong ", "Mi ", "Die ", "Yi ", "Er ", "Ming ", "Xuan ", "Chi ", "Kuang ", "Juan ", "Mou ", "Zhen ", "Tiao ", "Yang ", "Yan ", "Mo ", "Zhong ", "Mai ", "Zhao ", "Zheng ", "Mei ", "Jun ", "Shao ", "Han ", "Huan ", "Di ", "Cheng ", "Cuo ", "Juan ", "E ", "Wan ", "Xian ", "Xi ", "Kun ", "Lai ", "Jian ", "Shan ", "Tian ", "Hun ", "Wan ", "Ling ", "Shi ", "Qiong ", "Lie ", "Yai ", "Jing ", "Zheng ", "Li ", "Lai ", "Sui ", "Juan ", "Shui ", "Sui ", "Du ", "Bi ", "Bi ", "Mu ", "Hun ", "Ni ", "Lu ", "Yi ", "Jie ", "Cai ", "Zhou ", "Yu ", "Hun ", "Ma ", "Xia ", "Xing ", "Xi ", "Gun ", "Cai ", "Chun ", "Jian ", "Mei ", "Du ", "Hou ", "Xuan ", "Ti ", "Kui ", "Gao ", "Rui ", "Mou ", "Xu ", "Fa ", "Wen ", "Miao ", "Chou ", "Kui ", "Mi ", "Weng ", "Kou ", "Dang ", "Chen ", "Ke ", "Sou ", "Xia ", "Qiong ", "Mao ", "Ming ", "Man ", "Shui ", "Ze ", "Zhang ", "Yi ", "Diao ", "Ou ", "Mo ", "Shun ", "Cong ", "Lou ", "Chi ", "Man ", "Piao ", "Cheng ", "Ji ", "Meng ", "[?] ", "Run ", "Pie ", "Xi ", "Qiao ", "Pu ", "Zhu ", "Deng ", "Shen ", "Shun ", "Liao ", "Che ", "Xian ", "Kan ", "Ye ", "Xu ", "Tong ", "Mou ", "Lin ", "Kui ", "Xian ", "Ye ", "Ai ", "Hui ", "Zhan ", "Jian ", "Gu ", "Zhao ", "Qu ", "Wei ", "Chou ", "Sao ", "Ning ", "Xun ", "Yao ", "Huo ", "Meng ", "Mian ", "Bin ", "Mian ", "Li ", "Kuang ", "Jue ", "Xuan ", "Mian ", "Huo ", "Lu ", "Meng ", "Long ", "Guan ", "Man ", "Xi ", "Chu ", "Tang ", "Kan ", "Zhu ", "Mao ", "Jin ", "Lin ", "Yu ", "Shuo ", "Ce ", "Jue ", "Shi ", "Yi ", "Shen ", "Zhi ", "Hou ", "Shen ", "Ying ", "Ju ", "Zhou ", "Jiao ", "Cuo ", "Duan ", "Ai ", "Jiao ", "Zeng ", "Huo ", "Bai ", "Shi ", "Ding ", "Qi ", "Ji ", "Zi ", "Gan ", "Wu ", "Tuo ", "Ku ", "Qiang ", "Xi ", "Fan ", "Kuang "];
  }
});

// node_modules/unidecode/data/x78.js
var require_x78 = __commonJS({
  "node_modules/unidecode/data/x78.js"(exports2, module2) {
    module2.exports = ["Dang ", "Ma ", "Sha ", "Dan ", "Jue ", "Li ", "Fu ", "Min ", "Nuo ", "Huo ", "Kang ", "Zhi ", "Qi ", "Kan ", "Jie ", "Fen ", "E ", "Ya ", "Pi ", "Zhe ", "Yan ", "Sui ", "Zhuan ", "Che ", "Dun ", "Pan ", "Yan ", "[?] ", "Feng ", "Fa ", "Mo ", "Zha ", "Qu ", "Yu ", "Luo ", "Tuo ", "Tuo ", "Di ", "Zhai ", "Zhen ", "Ai ", "Fei ", "Mu ", "Zhu ", "Li ", "Bian ", "Nu ", "Ping ", "Peng ", "Ling ", "Pao ", "Le ", "Po ", "Bo ", "Po ", "Shen ", "Za ", "Nuo ", "Li ", "Long ", "Tong ", "[?] ", "Li ", "Aragane ", "Chu ", "Keng ", "Quan ", "Zhu ", "Kuang ", "Huo ", "E ", "Nao ", "Jia ", "Lu ", "Wei ", "Ai ", "Luo ", "Ken ", "Xing ", "Yan ", "Tong ", "Peng ", "Xi ", "[?] ", "Hong ", "Shuo ", "Xia ", "Qiao ", "[?] ", "Wei ", "Qiao ", "[?] ", "Keng ", "Xiao ", "Que ", "Chan ", "Lang ", "Hong ", "Yu ", "Xiao ", "Xia ", "Mang ", "Long ", "Iong ", "Che ", "Che ", "E ", "Liu ", "Ying ", "Mang ", "Que ", "Yan ", "Sha ", "Kun ", "Yu ", "[?] ", "Kaki ", "Lu ", "Chen ", "Jian ", "Nue ", "Song ", "Zhuo ", "Keng ", "Peng ", "Yan ", "Zhui ", "Kong ", "Ceng ", "Qi ", "Zong ", "Qing ", "Lin ", "Jun ", "Bo ", "Ding ", "Min ", "Diao ", "Jian ", "He ", "Lu ", "Ai ", "Sui ", "Que ", "Ling ", "Bei ", "Yin ", "Dui ", "Wu ", "Qi ", "Lun ", "Wan ", "Dian ", "Gang ", "Pei ", "Qi ", "Chen ", "Ruan ", "Yan ", "Die ", "Ding ", "Du ", "Tuo ", "Jie ", "Ying ", "Bian ", "Ke ", "Bi ", "Wei ", "Shuo ", "Zhen ", "Duan ", "Xia ", "Dang ", "Ti ", "Nao ", "Peng ", "Jian ", "Di ", "Tan ", "Cha ", "Seki ", "Qi ", "[?] ", "Feng ", "Xuan ", "Que ", "Que ", "Ma ", "Gong ", "Nian ", "Su ", "E ", "Ci ", "Liu ", "Si ", "Tang ", "Bang ", "Hua ", "Pi ", "Wei ", "Sang ", "Lei ", "Cuo ", "Zhen ", "Xia ", "Qi ", "Lian ", "Pan ", "Wei ", "Yun ", "Dui ", "Zhe ", "Ke ", "La ", "[?] ", "Qing ", "Gun ", "Zhuan ", "Chan ", "Qi ", "Ao ", "Peng ", "Lu ", "Lu ", "Kan ", "Qiang ", "Chen ", "Yin ", "Lei ", "Biao ", "Qi ", "Mo ", "Qi ", "Cui ", "Zong ", "Qing ", "Chuo ", "[?] ", "Ji ", "Shan ", "Lao ", "Qu ", "Zeng ", "Deng ", "Jian ", "Xi ", "Lin ", "Ding ", "Dian ", "Huang ", "Pan ", "Za ", "Qiao ", "Di ", "Li "];
  }
});

// node_modules/unidecode/data/x79.js
var require_x79 = __commonJS({
  "node_modules/unidecode/data/x79.js"(exports2, module2) {
    module2.exports = ["Tani ", "Jiao ", "[?] ", "Zhang ", "Qiao ", "Dun ", "Xian ", "Yu ", "Zhui ", "He ", "Huo ", "Zhai ", "Lei ", "Ke ", "Chu ", "Ji ", "Que ", "Dang ", "Yi ", "Jiang ", "Pi ", "Pi ", "Yu ", "Pin ", "Qi ", "Ai ", "Kai ", "Jian ", "Yu ", "Ruan ", "Meng ", "Pao ", "Ci ", "[?] ", "[?] ", "Mie ", "Ca ", "Xian ", "Kuang ", "Lei ", "Lei ", "Zhi ", "Li ", "Li ", "Fan ", "Que ", "Pao ", "Ying ", "Li ", "Long ", "Long ", "Mo ", "Bo ", "Shuang ", "Guan ", "Lan ", "Zan ", "Yan ", "Shi ", "Shi ", "Li ", "Reng ", "She ", "Yue ", "Si ", "Qi ", "Ta ", "Ma ", "Xie ", "Xian ", "Xian ", "Zhi ", "Qi ", "Zhi ", "Beng ", "Dui ", "Zhong ", "[?] ", "Yi ", "Shi ", "You ", "Zhi ", "Tiao ", "Fu ", "Fu ", "Mi ", "Zu ", "Zhi ", "Suan ", "Mei ", "Zuo ", "Qu ", "Hu ", "Zhu ", "Shen ", "Sui ", "Ci ", "Chai ", "Mi ", "Lu ", "Yu ", "Xiang ", "Wu ", "Tiao ", "Piao ", "Zhu ", "Gui ", "Xia ", "Zhi ", "Ji ", "Gao ", "Zhen ", "Gao ", "Shui ", "Jin ", "Chen ", "Gai ", "Kun ", "Di ", "Dao ", "Huo ", "Tao ", "Qi ", "Gu ", "Guan ", "Zui ", "Ling ", "Lu ", "Bing ", "Jin ", "Dao ", "Zhi ", "Lu ", "Shan ", "Bei ", "Zhe ", "Hui ", "You ", "Xi ", "Yin ", "Zi ", "Huo ", "Zhen ", "Fu ", "Yuan ", "Wu ", "Xian ", "Yang ", "Ti ", "Yi ", "Mei ", "Si ", "Di ", "[?] ", "Zhuo ", "Zhen ", "Yong ", "Ji ", "Gao ", "Tang ", "Si ", "Ma ", "Ta ", "[?] ", "Xuan ", "Qi ", "Yu ", "Xi ", "Ji ", "Si ", "Chan ", "Tan ", "Kuai ", "Sui ", "Li ", "Nong ", "Ni ", "Dao ", "Li ", "Rang ", "Yue ", "Ti ", "Zan ", "Lei ", "Rou ", "Yu ", "Yu ", "Chi ", "Xie ", "Qin ", "He ", "Tu ", "Xiu ", "Si ", "Ren ", "Tu ", "Zi ", "Cha ", "Gan ", "Yi ", "Xian ", "Bing ", "Nian ", "Qiu ", "Qiu ", "Chong ", "Fen ", "Hao ", "Yun ", "Ke ", "Miao ", "Zhi ", "Geng ", "Bi ", "Zhi ", "Yu ", "Mi ", "Ku ", "Ban ", "Pi ", "Ni ", "Li ", "You ", "Zu ", "Pi ", "Ba ", "Ling ", "Mo ", "Cheng ", "Nian ", "Qin ", "Yang ", "Zuo ", "Zhi ", "Zhi ", "Shu ", "Ju ", "Zi ", "Huo ", "Ji ", "Cheng ", "Tong ", "Zhi ", "Huo ", "He ", "Yin ", "Zi ", "Zhi ", "Jie ", "Ren ", "Du ", "Yi ", "Zhu ", "Hui ", "Nong ", "Fu "];
  }
});

// node_modules/unidecode/data/x7a.js
var require_x7a = __commonJS({
  "node_modules/unidecode/data/x7a.js"(exports2, module2) {
    module2.exports = ["Xi ", "Kao ", "Lang ", "Fu ", "Ze ", "Shui ", "Lu ", "Kun ", "Gan ", "Geng ", "Ti ", "Cheng ", "Tu ", "Shao ", "Shui ", "Ya ", "Lun ", "Lu ", "Gu ", "Zuo ", "Ren ", "Zhun ", "Bang ", "Bai ", "Ji ", "Zhi ", "Zhi ", "Kun ", "Leng ", "Peng ", "Ke ", "Bing ", "Chou ", "Zu ", "Yu ", "Su ", "Lue ", "[?] ", "Yi ", "Xi ", "Bian ", "Ji ", "Fu ", "Bi ", "Nuo ", "Jie ", "Zhong ", "Zong ", "Xu ", "Cheng ", "Dao ", "Wen ", "Lian ", "Zi ", "Yu ", "Ji ", "Xu ", "Zhen ", "Zhi ", "Dao ", "Jia ", "Ji ", "Gao ", "Gao ", "Gu ", "Rong ", "Sui ", "You ", "Ji ", "Kang ", "Mu ", "Shan ", "Men ", "Zhi ", "Ji ", "Lu ", "Su ", "Ji ", "Ying ", "Wen ", "Qiu ", "Se ", "[?] ", "Yi ", "Huang ", "Qie ", "Ji ", "Sui ", "Xiao ", "Pu ", "Jiao ", "Zhuo ", "Tong ", "Sai ", "Lu ", "Sui ", "Nong ", "Se ", "Hui ", "Rang ", "Nuo ", "Yu ", "Bin ", "Ji ", "Tui ", "Wen ", "Cheng ", "Huo ", "Gong ", "Lu ", "Biao ", "[?] ", "Rang ", "Zhuo ", "Li ", "Zan ", "Xue ", "Wa ", "Jiu ", "Qiong ", "Xi ", "Qiong ", "Kong ", "Yu ", "Sen ", "Jing ", "Yao ", "Chuan ", "Zhun ", "Tu ", "Lao ", "Qie ", "Zhai ", "Yao ", "Bian ", "Bao ", "Yao ", "Bing ", "Wa ", "Zhu ", "Jiao ", "Qiao ", "Diao ", "Wu ", "Gui ", "Yao ", "Zhi ", "Chuang ", "Yao ", "Tiao ", "Jiao ", "Chuang ", "Jiong ", "Xiao ", "Cheng ", "Kou ", "Cuan ", "Wo ", "Dan ", "Ku ", "Ke ", "Zhui ", "Xu ", "Su ", "Guan ", "Kui ", "Dou ", "[?] ", "Yin ", "Wo ", "Wa ", "Ya ", "Yu ", "Ju ", "Qiong ", "Yao ", "Yao ", "Tiao ", "Chao ", "Yu ", "Tian ", "Diao ", "Ju ", "Liao ", "Xi ", "Wu ", "Kui ", "Chuang ", "Zhao ", "[?] ", "Kuan ", "Long ", "Cheng ", "Cui ", "Piao ", "Zao ", "Cuan ", "Qiao ", "Qiong ", "Dou ", "Zao ", "Long ", "Qie ", "Li ", "Chu ", "Shi ", "Fou ", "Qian ", "Chu ", "Hong ", "Qi ", "Qian ", "Gong ", "Shi ", "Shu ", "Miao ", "Ju ", "Zhan ", "Zhu ", "Ling ", "Long ", "Bing ", "Jing ", "Jing ", "Zhang ", "Yi ", "Si ", "Jun ", "Hong ", "Tong ", "Song ", "Jing ", "Diao ", "Yi ", "Shu ", "Jing ", "Qu ", "Jie ", "Ping ", "Duan ", "Shao ", "Zhuan ", "Ceng ", "Deng ", "Cui ", "Huai ", "Jing ", "Kan ", "Jing ", "Zhu ", "Zhu ", "Le ", "Peng ", "Yu ", "Chi ", "Gan "];
  }
});

// node_modules/unidecode/data/x7b.js
var require_x7b = __commonJS({
  "node_modules/unidecode/data/x7b.js"(exports2, module2) {
    module2.exports = ["Mang ", "Zhu ", "Utsubo ", "Du ", "Ji ", "Xiao ", "Ba ", "Suan ", "Ji ", "Zhen ", "Zhao ", "Sun ", "Ya ", "Zhui ", "Yuan ", "Hu ", "Gang ", "Xiao ", "Cen ", "Pi ", "Bi ", "Jian ", "Yi ", "Dong ", "Shan ", "Sheng ", "Xia ", "Di ", "Zhu ", "Na ", "Chi ", "Gu ", "Li ", "Qie ", "Min ", "Bao ", "Tiao ", "Si ", "Fu ", "Ce ", "Ben ", "Pei ", "Da ", "Zi ", "Di ", "Ling ", "Ze ", "Nu ", "Fu ", "Gou ", "Fan ", "Jia ", "Ge ", "Fan ", "Shi ", "Mao ", "Po ", "Sey ", "Jian ", "Qiong ", "Long ", "Souke ", "Bian ", "Luo ", "Gui ", "Qu ", "Chi ", "Yin ", "Yao ", "Xian ", "Bi ", "Qiong ", "Gua ", "Deng ", "Jiao ", "Jin ", "Quan ", "Sun ", "Ru ", "Fa ", "Kuang ", "Zhu ", "Tong ", "Ji ", "Da ", "Xing ", "Ce ", "Zhong ", "Kou ", "Lai ", "Bi ", "Shai ", "Dang ", "Zheng ", "Ce ", "Fu ", "Yun ", "Tu ", "Pa ", "Li ", "Lang ", "Ju ", "Guan ", "Jian ", "Han ", "Tong ", "Xia ", "Zhi ", "Cheng ", "Suan ", "Shi ", "Zhu ", "Zuo ", "Xiao ", "Shao ", "Ting ", "Ce ", "Yan ", "Gao ", "Kuai ", "Gan ", "Chou ", "Kago ", "Gang ", "Yun ", "O ", "Qian ", "Xiao ", "Jian ", "Pu ", "Lai ", "Zou ", "Bi ", "Bi ", "Bi ", "Ge ", "Chi ", "Guai ", "Yu ", "Jian ", "Zhao ", "Gu ", "Chi ", "Zheng ", "Jing ", "Sha ", "Zhou ", "Lu ", "Bo ", "Ji ", "Lin ", "Suan ", "Jun ", "Fu ", "Zha ", "Gu ", "Kong ", "Qian ", "Quan ", "Jun ", "Chui ", "Guan ", "Yuan ", "Ce ", "Ju ", "Bo ", "Ze ", "Qie ", "Tuo ", "Luo ", "Dan ", "Xiao ", "Ruo ", "Jian ", "Xuan ", "Bian ", "Sun ", "Xiang ", "Xian ", "Ping ", "Zhen ", "Sheng ", "Hu ", "Shi ", "Zhu ", "Yue ", "Chun ", "Lu ", "Wu ", "Dong ", "Xiao ", "Ji ", "Jie ", "Huang ", "Xing ", "Mei ", "Fan ", "Chui ", "Zhuan ", "Pian ", "Feng ", "Zhu ", "Hong ", "Qie ", "Hou ", "Qiu ", "Miao ", "Qian ", "[?] ", "Kui ", "Sik ", "Lou ", "Yun ", "He ", "Tang ", "Yue ", "Chou ", "Gao ", "Fei ", "Ruo ", "Zheng ", "Gou ", "Nie ", "Qian ", "Xiao ", "Cuan ", "Gong ", "Pang ", "Du ", "Li ", "Bi ", "Zhuo ", "Chu ", "Shai ", "Chi ", "Zhu ", "Qiang ", "Long ", "Lan ", "Jian ", "Bu ", "Li ", "Hui ", "Bi ", "Di ", "Cong ", "Yan ", "Peng ", "Sen ", "Zhuan ", "Pai ", "Piao ", "Dou ", "Yu ", "Mie ", "Zhuan "];
  }
});

// node_modules/unidecode/data/x7c.js
var require_x7c = __commonJS({
  "node_modules/unidecode/data/x7c.js"(exports2, module2) {
    module2.exports = ["Ze ", "Xi ", "Guo ", "Yi ", "Hu ", "Chan ", "Kou ", "Cu ", "Ping ", "Chou ", "Ji ", "Gui ", "Su ", "Lou ", "Zha ", "Lu ", "Nian ", "Suo ", "Cuan ", "Sasara ", "Suo ", "Le ", "Duan ", "Yana ", "Xiao ", "Bo ", "Mi ", "Si ", "Dang ", "Liao ", "Dan ", "Dian ", "Fu ", "Jian ", "Min ", "Kui ", "Dai ", "Qiao ", "Deng ", "Huang ", "Sun ", "Lao ", "Zan ", "Xiao ", "Du ", "Shi ", "Zan ", "[?] ", "Pai ", "Hata ", "Pai ", "Gan ", "Ju ", "Du ", "Lu ", "Yan ", "Bo ", "Dang ", "Sai ", "Ke ", "Long ", "Qian ", "Lian ", "Bo ", "Zhou ", "Lai ", "[?] ", "Lan ", "Kui ", "Yu ", "Yue ", "Hao ", "Zhen ", "Tai ", "Ti ", "Mi ", "Chou ", "Ji ", "[?] ", "Hata ", "Teng ", "Zhuan ", "Zhou ", "Fan ", "Sou ", "Zhou ", "Kuji ", "Zhuo ", "Teng ", "Lu ", "Lu ", "Jian ", "Tuo ", "Ying ", "Yu ", "Lai ", "Long ", "Shinshi ", "Lian ", "Lan ", "Qian ", "Yue ", "Zhong ", "Qu ", "Lian ", "Bian ", "Duan ", "Zuan ", "Li ", "Si ", "Luo ", "Ying ", "Yue ", "Zhuo ", "Xu ", "Mi ", "Di ", "Fan ", "Shen ", "Zhe ", "Shen ", "Nu ", "Xie ", "Lei ", "Xian ", "Zi ", "Ni ", "Cun ", "[?] ", "Qian ", "Kume ", "Bi ", "Ban ", "Wu ", "Sha ", "Kang ", "Rou ", "Fen ", "Bi ", "Cui ", "[?] ", "Li ", "Chi ", "Nukamiso ", "Ro ", "Ba ", "Li ", "Gan ", "Ju ", "Po ", "Mo ", "Cu ", "Nian ", "Zhou ", "Li ", "Su ", "Tiao ", "Li ", "Qi ", "Su ", "Hong ", "Tong ", "Zi ", "Ce ", "Yue ", "Zhou ", "Lin ", "Zhuang ", "Bai ", "[?] ", "Fen ", "Ji ", "[?] ", "Sukumo ", "Liang ", "Xian ", "Fu ", "Liang ", "Can ", "Geng ", "Li ", "Yue ", "Lu ", "Ju ", "Qi ", "Cui ", "Bai ", "Zhang ", "Lin ", "Zong ", "Jing ", "Guo ", "Kouji ", "San ", "San ", "Tang ", "Bian ", "Rou ", "Mian ", "Hou ", "Xu ", "Zong ", "Hu ", "Jian ", "Zan ", "Ci ", "Li ", "Xie ", "Fu ", "Ni ", "Bei ", "Gu ", "Xiu ", "Gao ", "Tang ", "Qiu ", "Sukumo ", "Cao ", "Zhuang ", "Tang ", "Mi ", "San ", "Fen ", "Zao ", "Kang ", "Jiang ", "Mo ", "San ", "San ", "Nuo ", "Xi ", "Liang ", "Jiang ", "Kuai ", "Bo ", "Huan ", "[?] ", "Zong ", "Xian ", "Nuo ", "Tuan ", "Nie ", "Li ", "Zuo ", "Di ", "Nie ", "Tiao ", "Lan ", "Mi ", "Jiao ", "Jiu ", "Xi ", "Gong ", "Zheng ", "Jiu ", "You "];
  }
});

// node_modules/unidecode/data/x7d.js
var require_x7d = __commonJS({
  "node_modules/unidecode/data/x7d.js"(exports2, module2) {
    module2.exports = ["Ji ", "Cha ", "Zhou ", "Xun ", "Yue ", "Hong ", "Yu ", "He ", "Wan ", "Ren ", "Wen ", "Wen ", "Qiu ", "Na ", "Zi ", "Tou ", "Niu ", "Fou ", "Jie ", "Shu ", "Chun ", "Pi ", "Yin ", "Sha ", "Hong ", "Zhi ", "Ji ", "Fen ", "Yun ", "Ren ", "Dan ", "Jin ", "Su ", "Fang ", "Suo ", "Cui ", "Jiu ", "Zha ", "Kinu ", "Jin ", "Fu ", "Zhi ", "Ci ", "Zi ", "Chou ", "Hong ", "Zha ", "Lei ", "Xi ", "Fu ", "Xie ", "Shen ", "Bei ", "Zhu ", "Qu ", "Ling ", "Zhu ", "Shao ", "Gan ", "Yang ", "Fu ", "Tuo ", "Zhen ", "Dai ", "Zhuo ", "Shi ", "Zhong ", "Xian ", "Zu ", "Jiong ", "Ban ", "Ju ", "Mo ", "Shu ", "Zui ", "Wata ", "Jing ", "Ren ", "Heng ", "Xie ", "Jie ", "Zhu ", "Chou ", "Gua ", "Bai ", "Jue ", "Kuang ", "Hu ", "Ci ", "Geng ", "Geng ", "Tao ", "Xie ", "Ku ", "Jiao ", "Quan ", "Gai ", "Luo ", "Xuan ", "Bing ", "Xian ", "Fu ", "Gei ", "Tong ", "Rong ", "Tiao ", "Yin ", "Lei ", "Xie ", "Quan ", "Xu ", "Lun ", "Die ", "Tong ", "Si ", "Jiang ", "Xiang ", "Hui ", "Jue ", "Zhi ", "Jian ", "Juan ", "Chi ", "Mian ", "Zhen ", "Lu ", "Cheng ", "Qiu ", "Shu ", "Bang ", "Tong ", "Xiao ", "Wan ", "Qin ", "Geng ", "Xiu ", "Ti ", "Xiu ", "Xie ", "Hong ", "Xi ", "Fu ", "Ting ", "Sui ", "Dui ", "Kun ", "Fu ", "Jing ", "Hu ", "Zhi ", "Yan ", "Jiong ", "Feng ", "Ji ", "Sok ", "Kase ", "Zong ", "Lin ", "Duo ", "Li ", "Lu ", "Liang ", "Chou ", "Quan ", "Shao ", "Qi ", "Qi ", "Zhun ", "Qi ", "Wan ", "Qian ", "Xian ", "Shou ", "Wei ", "Qi ", "Tao ", "Wan ", "Gang ", "Wang ", "Beng ", "Zhui ", "Cai ", "Guo ", "Cui ", "Lun ", "Liu ", "Qi ", "Zhan ", "Bei ", "Chuo ", "Ling ", "Mian ", "Qi ", "Qie ", "Tan ", "Zong ", "Gun ", "Zou ", "Yi ", "Zi ", "Xing ", "Liang ", "Jin ", "Fei ", "Rui ", "Min ", "Yu ", "Zong ", "Fan ", "Lu ", "Xu ", "Yingl ", "Zhang ", "Kasuri ", "Xu ", "Xiang ", "Jian ", "Ke ", "Xian ", "Ruan ", "Mian ", "Qi ", "Duan ", "Zhong ", "Di ", "Min ", "Miao ", "Yuan ", "Xie ", "Bao ", "Si ", "Qiu ", "Bian ", "Huan ", "Geng ", "Cong ", "Mian ", "Wei ", "Fu ", "Wei ", "Yu ", "Gou ", "Miao ", "Xie ", "Lian ", "Zong ", "Bian ", "Yun ", "Yin ", "Ti ", "Gua ", "Zhi ", "Yun ", "Cheng ", "Chan ", "Dai "];
  }
});

// node_modules/unidecode/data/x7e.js
var require_x7e = __commonJS({
  "node_modules/unidecode/data/x7e.js"(exports2, module2) {
    module2.exports = ["Xia ", "Yuan ", "Zong ", "Xu ", "Nawa ", "Odoshi ", "Geng ", "Sen ", "Ying ", "Jin ", "Yi ", "Zhui ", "Ni ", "Bang ", "Gu ", "Pan ", "Zhou ", "Jian ", "Cuo ", "Quan ", "Shuang ", "Yun ", "Xia ", "Shuai ", "Xi ", "Rong ", "Tao ", "Fu ", "Yun ", "Zhen ", "Gao ", "Ru ", "Hu ", "Zai ", "Teng ", "Xian ", "Su ", "Zhen ", "Zong ", "Tao ", "Horo ", "Cai ", "Bi ", "Feng ", "Cu ", "Li ", "Suo ", "Yin ", "Xi ", "Zong ", "Lei ", "Zhuan ", "Qian ", "Man ", "Zhi ", "Lu ", "Mo ", "Piao ", "Lian ", "Mi ", "Xuan ", "Zong ", "Ji ", "Shan ", "Sui ", "Fan ", "Shuai ", "Beng ", "Yi ", "Sao ", "Mou ", "Zhou ", "Qiang ", "Hun ", "Sem ", "Xi ", "Jung ", "Xiu ", "Ran ", "Xuan ", "Hui ", "Qiao ", "Zeng ", "Zuo ", "Zhi ", "Shan ", "San ", "Lin ", "Yu ", "Fan ", "Liao ", "Chuo ", "Zun ", "Jian ", "Rao ", "Chan ", "Rui ", "Xiu ", "Hui ", "Hua ", "Zuan ", "Xi ", "Qiang ", "Un ", "Da ", "Sheng ", "Hui ", "Xi ", "Se ", "Jian ", "Jiang ", "Huan ", "Zao ", "Cong ", "Jie ", "Jiao ", "Bo ", "Chan ", "Yi ", "Nao ", "Sui ", "Yi ", "Shai ", "Xu ", "Ji ", "Bin ", "Qian ", "Lan ", "Pu ", "Xun ", "Zuan ", "Qi ", "Peng ", "Li ", "Mo ", "Lei ", "Xie ", "Zuan ", "Kuang ", "You ", "Xu ", "Lei ", "Xian ", "Chan ", "Kou ", "Lu ", "Chan ", "Ying ", "Cai ", "Xiang ", "Xian ", "Zui ", "Zuan ", "Luo ", "Xi ", "Dao ", "Lan ", "Lei ", "Lian ", "Si ", "Jiu ", "Yu ", "Hong ", "Zhou ", "Xian ", "He ", "Yue ", "Ji ", "Wan ", "Kuang ", "Ji ", "Ren ", "Wei ", "Yun ", "Hong ", "Chun ", "Pi ", "Sha ", "Gang ", "Na ", "Ren ", "Zong ", "Lun ", "Fen ", "Zhi ", "Wen ", "Fang ", "Zhu ", "Yin ", "Niu ", "Shu ", "Xian ", "Gan ", "Xie ", "Fu ", "Lian ", "Zu ", "Shen ", "Xi ", "Zhi ", "Zhong ", "Zhou ", "Ban ", "Fu ", "Zhuo ", "Shao ", "Yi ", "Jing ", "Dai ", "Bang ", "Rong ", "Jie ", "Ku ", "Rao ", "Die ", "Heng ", "Hui ", "Gei ", "Xuan ", "Jiang ", "Luo ", "Jue ", "Jiao ", "Tong ", "Geng ", "Xiao ", "Juan ", "Xiu ", "Xi ", "Sui ", "Tao ", "Ji ", "Ti ", "Ji ", "Xu ", "Ling ", "[?] ", "Xu ", "Qi ", "Fei ", "Chuo ", "Zhang ", "Gun ", "Sheng ", "Wei ", "Mian ", "Shou ", "Beng ", "Chou ", "Tao ", "Liu ", "Quan ", "Zong ", "Zhan ", "Wan ", "Lu "];
  }
});

// node_modules/unidecode/data/x7f.js
var require_x7f = __commonJS({
  "node_modules/unidecode/data/x7f.js"(exports2, module2) {
    module2.exports = ["Zhui ", "Zi ", "Ke ", "Xiang ", "Jian ", "Mian ", "Lan ", "Ti ", "Miao ", "Qi ", "Yun ", "Hui ", "Si ", "Duo ", "Duan ", "Bian ", "Xian ", "Gou ", "Zhui ", "Huan ", "Di ", "Lu ", "Bian ", "Min ", "Yuan ", "Jin ", "Fu ", "Ru ", "Zhen ", "Feng ", "Shuai ", "Gao ", "Chan ", "Li ", "Yi ", "Jian ", "Bin ", "Piao ", "Man ", "Lei ", "Ying ", "Suo ", "Mou ", "Sao ", "Xie ", "Liao ", "Shan ", "Zeng ", "Jiang ", "Qian ", "Zao ", "Huan ", "Jiao ", "Zuan ", "Fou ", "Xie ", "Gang ", "Fou ", "Que ", "Fou ", "Kaakeru ", "Bo ", "Ping ", "Hou ", "[?] ", "Gang ", "Ying ", "Ying ", "Qing ", "Xia ", "Guan ", "Zun ", "Tan ", "Chang ", "Qi ", "Weng ", "Ying ", "Lei ", "Tan ", "Lu ", "Guan ", "Wang ", "Wang ", "Gang ", "Wang ", "Han ", "[?] ", "Luo ", "Fu ", "Mi ", "Fa ", "Gu ", "Zhu ", "Ju ", "Mao ", "Gu ", "Min ", "Gang ", "Ba ", "Gua ", "Ti ", "Juan ", "Fu ", "Lin ", "Yan ", "Zhao ", "Zui ", "Gua ", "Zhuo ", "Yu ", "Zhi ", "An ", "Fa ", "Nan ", "Shu ", "Si ", "Pi ", "Ma ", "Liu ", "Ba ", "Fa ", "Li ", "Chao ", "Wei ", "Bi ", "Ji ", "Zeng ", "Tong ", "Liu ", "Ji ", "Juan ", "Mi ", "Zhao ", "Luo ", "Pi ", "Ji ", "Ji ", "Luan ", "Yang ", "Mie ", "Qiang ", "Ta ", "Mei ", "Yang ", "You ", "You ", "Fen ", "Ba ", "Gao ", "Yang ", "Gu ", "Qiang ", "Zang ", "Gao ", "Ling ", "Yi ", "Zhu ", "Di ", "Xiu ", "Qian ", "Yi ", "Xian ", "Rong ", "Qun ", "Qun ", "Qian ", "Huan ", "Zui ", "Xian ", "Yi ", "Yashinau ", "Qiang ", "Xian ", "Yu ", "Geng ", "Jie ", "Tang ", "Yuan ", "Xi ", "Fan ", "Shan ", "Fen ", "Shan ", "Lian ", "Lei ", "Geng ", "Nou ", "Qiang ", "Chan ", "Yu ", "Gong ", "Yi ", "Chong ", "Weng ", "Fen ", "Hong ", "Chi ", "Chi ", "Cui ", "Fu ", "Xia ", "Pen ", "Yi ", "La ", "Yi ", "Pi ", "Ling ", "Liu ", "Zhi ", "Qu ", "Xi ", "Xie ", "Xiang ", "Xi ", "Xi ", "Qi ", "Qiao ", "Hui ", "Hui ", "Xiao ", "Se ", "Hong ", "Jiang ", "Di ", "Cui ", "Fei ", "Tao ", "Sha ", "Chi ", "Zhu ", "Jian ", "Xuan ", "Shi ", "Pian ", "Zong ", "Wan ", "Hui ", "Hou ", "He ", "He ", "Han ", "Ao ", "Piao ", "Yi ", "Lian ", "Qu ", "[?] ", "Lin ", "Pen ", "Qiao ", "Ao ", "Fan ", "Yi ", "Hui ", "Xuan ", "Dao "];
  }
});

// node_modules/unidecode/data/x80.js
var require_x80 = __commonJS({
  "node_modules/unidecode/data/x80.js"(exports2, module2) {
    module2.exports = ["Yao ", "Lao ", "[?] ", "Kao ", "Mao ", "Zhe ", "Qi ", "Gou ", "Gou ", "Gou ", "Die ", "Die ", "Er ", "Shua ", "Ruan ", "Er ", "Nai ", "Zhuan ", "Lei ", "Ting ", "Zi ", "Geng ", "Chao ", "Hao ", "Yun ", "Pa ", "Pi ", "Chi ", "Si ", "Chu ", "Jia ", "Ju ", "He ", "Chu ", "Lao ", "Lun ", "Ji ", "Tang ", "Ou ", "Lou ", "Nou ", "Gou ", "Pang ", "Ze ", "Lou ", "Ji ", "Lao ", "Huo ", "You ", "Mo ", "Huai ", "Er ", "Zhe ", "Ting ", "Ye ", "Da ", "Song ", "Qin ", "Yun ", "Chi ", "Dan ", "Dan ", "Hong ", "Geng ", "Zhi ", "[?] ", "Nie ", "Dan ", "Zhen ", "Che ", "Ling ", "Zheng ", "You ", "Wa ", "Liao ", "Long ", "Zhi ", "Ning ", "Tiao ", "Er ", "Ya ", "Die ", "Gua ", "[?] ", "Lian ", "Hao ", "Sheng ", "Lie ", "Pin ", "Jing ", "Ju ", "Bi ", "Di ", "Guo ", "Wen ", "Xu ", "Ping ", "Cong ", "Shikato ", "[?] ", "Ting ", "Yu ", "Cong ", "Kui ", "Tsuraneru ", "Kui ", "Cong ", "Lian ", "Weng ", "Kui ", "Lian ", "Lian ", "Cong ", "Ao ", "Sheng ", "Song ", "Ting ", "Kui ", "Nie ", "Zhi ", "Dan ", "Ning ", "Qie ", "Ji ", "Ting ", "Ting ", "Long ", "Yu ", "Yu ", "Zhao ", "Si ", "Su ", "Yi ", "Su ", "Si ", "Zhao ", "Zhao ", "Rou ", "Yi ", "Le ", "Ji ", "Qiu ", "Ken ", "Cao ", "Ge ", "Di ", "Huan ", "Huang ", "Yi ", "Ren ", "Xiao ", "Ru ", "Zhou ", "Yuan ", "Du ", "Gang ", "Rong ", "Gan ", "Cha ", "Wo ", "Chang ", "Gu ", "Zhi ", "Han ", "Fu ", "Fei ", "Fen ", "Pei ", "Pang ", "Jian ", "Fang ", "Zhun ", "You ", "Na ", "Hang ", "Ken ", "Ran ", "Gong ", "Yu ", "Wen ", "Yao ", "Jin ", "Pi ", "Qian ", "Xi ", "Xi ", "Fei ", "Ken ", "Jing ", "Tai ", "Shen ", "Zhong ", "Zhang ", "Xie ", "Shen ", "Wei ", "Zhou ", "Die ", "Dan ", "Fei ", "Ba ", "Bo ", "Qu ", "Tian ", "Bei ", "Gua ", "Tai ", "Zi ", "Ku ", "Zhi ", "Ni ", "Ping ", "Zi ", "Fu ", "Pang ", "Zhen ", "Xian ", "Zuo ", "Pei ", "Jia ", "Sheng ", "Zhi ", "Bao ", "Mu ", "Qu ", "Hu ", "Ke ", "Yi ", "Yin ", "Xu ", "Yang ", "Long ", "Dong ", "Ka ", "Lu ", "Jing ", "Nu ", "Yan ", "Pang ", "Kua ", "Yi ", "Guang ", "Gai ", "Ge ", "Dong ", "Zhi ", "Xiao ", "Xiong ", "Xiong ", "Er ", "E ", "Xing ", "Pian ", "Neng ", "Zi ", "Gui "];
  }
});

// node_modules/unidecode/data/x81.js
var require_x81 = __commonJS({
  "node_modules/unidecode/data/x81.js"(exports2, module2) {
    module2.exports = ["Cheng ", "Tiao ", "Zhi ", "Cui ", "Mei ", "Xie ", "Cui ", "Xie ", "Mo ", "Mai ", "Ji ", "Obiyaakasu ", "[?] ", "Kuai ", "Sa ", "Zang ", "Qi ", "Nao ", "Mi ", "Nong ", "Luan ", "Wan ", "Bo ", "Wen ", "Guan ", "Qiu ", "Jiao ", "Jing ", "Rou ", "Heng ", "Cuo ", "Lie ", "Shan ", "Ting ", "Mei ", "Chun ", "Shen ", "Xie ", "De ", "Zui ", "Cu ", "Xiu ", "Xin ", "Tuo ", "Pao ", "Cheng ", "Nei ", "Fu ", "Dou ", "Tuo ", "Niao ", "Noy ", "Pi ", "Gu ", "Gua ", "Li ", "Lian ", "Zhang ", "Cui ", "Jie ", "Liang ", "Zhou ", "Pi ", "Biao ", "Lun ", "Pian ", "Guo ", "Kui ", "Chui ", "Dan ", "Tian ", "Nei ", "Jing ", "Jie ", "La ", "Yi ", "An ", "Ren ", "Shen ", "Chuo ", "Fu ", "Fu ", "Ju ", "Fei ", "Qiang ", "Wan ", "Dong ", "Pi ", "Guo ", "Zong ", "Ding ", "Wu ", "Mei ", "Ruan ", "Zhuan ", "Zhi ", "Cou ", "Gua ", "Ou ", "Di ", "An ", "Xing ", "Nao ", "Yu ", "Chuan ", "Nan ", "Yun ", "Zhong ", "Rou ", "E ", "Sai ", "Tu ", "Yao ", "Jian ", "Wei ", "Jiao ", "Yu ", "Jia ", "Duan ", "Bi ", "Chang ", "Fu ", "Xian ", "Ni ", "Mian ", "Wa ", "Teng ", "Tui ", "Bang ", "Qian ", "Lu ", "Wa ", "Sou ", "Tang ", "Su ", "Zhui ", "Ge ", "Yi ", "Bo ", "Liao ", "Ji ", "Pi ", "Xie ", "Gao ", "Lu ", "Bin ", "Ou ", "Chang ", "Lu ", "Guo ", "Pang ", "Chuai ", "Piao ", "Jiang ", "Fu ", "Tang ", "Mo ", "Xi ", "Zhuan ", "Lu ", "Jiao ", "Ying ", "Lu ", "Zhi ", "Tara ", "Chun ", "Lian ", "Tong ", "Peng ", "Ni ", "Zha ", "Liao ", "Cui ", "Gui ", "Xiao ", "Teng ", "Fan ", "Zhi ", "Jiao ", "Shan ", "Wu ", "Cui ", "Run ", "Xiang ", "Sui ", "Fen ", "Ying ", "Tan ", "Zhua ", "Dan ", "Kuai ", "Nong ", "Tun ", "Lian ", "Bi ", "Yong ", "Jue ", "Chu ", "Yi ", "Juan ", "La ", "Lian ", "Sao ", "Tun ", "Gu ", "Qi ", "Cui ", "Bin ", "Xun ", "Ru ", "Huo ", "Zang ", "Xian ", "Biao ", "Xing ", "Kuan ", "La ", "Yan ", "Lu ", "Huo ", "Zang ", "Luo ", "Qu ", "Zang ", "Luan ", "Ni ", "Zang ", "Chen ", "Qian ", "Wo ", "Guang ", "Zang ", "Lin ", "Guang ", "Zi ", "Jiao ", "Nie ", "Chou ", "Ji ", "Gao ", "Chou ", "Mian ", "Nie ", "Zhi ", "Zhi ", "Ge ", "Jian ", "Die ", "Zhi ", "Xiu ", "Tai ", "Zhen ", "Jiu ", "Xian ", "Yu ", "Cha "];
  }
});

// node_modules/unidecode/data/x82.js
var require_x82 = __commonJS({
  "node_modules/unidecode/data/x82.js"(exports2, module2) {
    module2.exports = ["Yao ", "Yu ", "Chong ", "Xi ", "Xi ", "Jiu ", "Yu ", "Yu ", "Xing ", "Ju ", "Jiu ", "Xin ", "She ", "She ", "Yadoru ", "Jiu ", "Shi ", "Tan ", "Shu ", "Shi ", "Tian ", "Dan ", "Pu ", "Pu ", "Guan ", "Hua ", "Tan ", "Chuan ", "Shun ", "Xia ", "Wu ", "Zhou ", "Dao ", "Gang ", "Shan ", "Yi ", "[?] ", "Pa ", "Tai ", "Fan ", "Ban ", "Chuan ", "Hang ", "Fang ", "Ban ", "Que ", "Hesaki ", "Zhong ", "Jian ", "Cang ", "Ling ", "Zhu ", "Ze ", "Duo ", "Bo ", "Xian ", "Ge ", "Chuan ", "Jia ", "Lu ", "Hong ", "Pang ", "Xi ", "[?] ", "Fu ", "Zao ", "Feng ", "Li ", "Shao ", "Yu ", "Lang ", "Ting ", "[?] ", "Wei ", "Bo ", "Meng ", "Nian ", "Ju ", "Huang ", "Shou ", "Zong ", "Bian ", "Mao ", "Die ", "[?] ", "Bang ", "Cha ", "Yi ", "Sao ", "Cang ", "Cao ", "Lou ", "Dai ", "Sori ", "Yao ", "Tong ", "Yofune ", "Dang ", "Tan ", "Lu ", "Yi ", "Jie ", "Jian ", "Huo ", "Meng ", "Qi ", "Lu ", "Lu ", "Chan ", "Shuang ", "Gen ", "Liang ", "Jian ", "Jian ", "Se ", "Yan ", "Fu ", "Ping ", "Yan ", "Yan ", "Cao ", "Cao ", "Yi ", "Le ", "Ting ", "Qiu ", "Ai ", "Nai ", "Tiao ", "Jiao ", "Jie ", "Peng ", "Wan ", "Yi ", "Chai ", "Mian ", "Mie ", "Gan ", "Qian ", "Yu ", "Yu ", "Shuo ", "Qiong ", "Tu ", "Xia ", "Qi ", "Mang ", "Zi ", "Hui ", "Sui ", "Zhi ", "Xiang ", "Bi ", "Fu ", "Tun ", "Wei ", "Wu ", "Zhi ", "Qi ", "Shan ", "Wen ", "Qian ", "Ren ", "Fou ", "Kou ", "Jie ", "Lu ", "Xu ", "Ji ", "Qin ", "Qi ", "Yuan ", "Fen ", "Ba ", "Rui ", "Xin ", "Ji ", "Hua ", "Hua ", "Fang ", "Wu ", "Jue ", "Gou ", "Zhi ", "Yun ", "Qin ", "Ao ", "Chu ", "Mao ", "Ya ", "Fei ", "Reng ", "Hang ", "Cong ", "Yin ", "You ", "Bian ", "Yi ", "Susa ", "Wei ", "Li ", "Pi ", "E ", "Xian ", "Chang ", "Cang ", "Meng ", "Su ", "Yi ", "Yuan ", "Ran ", "Ling ", "Tai ", "Tiao ", "Di ", "Miao ", "Qiong ", "Li ", "Yong ", "Ke ", "Mu ", "Pei ", "Bao ", "Gou ", "Min ", "Yi ", "Yi ", "Ju ", "Pi ", "Ruo ", "Ku ", "Zhu ", "Ni ", "Bo ", "Bing ", "Shan ", "Qiu ", "Yao ", "Xian ", "Ben ", "Hong ", "Ying ", "Zha ", "Dong ", "Ju ", "Die ", "Nie ", "Gan ", "Hu ", "Ping ", "Mei ", "Fu ", "Sheng ", "Gu ", "Bi ", "Wei "];
  }
});

// node_modules/unidecode/data/x83.js
var require_x83 = __commonJS({
  "node_modules/unidecode/data/x83.js"(exports2, module2) {
    module2.exports = ["Fu ", "Zhuo ", "Mao ", "Fan ", "Qie ", "Mao ", "Mao ", "Ba ", "Zi ", "Mo ", "Zi ", "Di ", "Chi ", "Ji ", "Jing ", "Long ", "[?] ", "Niao ", "[?] ", "Xue ", "Ying ", "Qiong ", "Ge ", "Ming ", "Li ", "Rong ", "Yin ", "Gen ", "Qian ", "Chai ", "Chen ", "Yu ", "Xiu ", "Zi ", "Lie ", "Wu ", "Ji ", "Kui ", "Ce ", "Chong ", "Ci ", "Gou ", "Guang ", "Mang ", "Chi ", "Jiao ", "Jiao ", "Fu ", "Yu ", "Zhu ", "Zi ", "Jiang ", "Hui ", "Yin ", "Cha ", "Fa ", "Rong ", "Ru ", "Chong ", "Mang ", "Tong ", "Zhong ", "[?] ", "Zhu ", "Xun ", "Huan ", "Kua ", "Quan ", "Gai ", "Da ", "Jing ", "Xing ", "Quan ", "Cao ", "Jing ", "Er ", "An ", "Shou ", "Chi ", "Ren ", "Jian ", "Ti ", "Huang ", "Ping ", "Li ", "Jin ", "Lao ", "Shu ", "Zhuang ", "Da ", "Jia ", "Rao ", "Bi ", "Ze ", "Qiao ", "Hui ", "Qi ", "Dang ", "[?] ", "Rong ", "Hun ", "Ying ", "Luo ", "Ying ", "Xun ", "Jin ", "Sun ", "Yin ", "Mai ", "Hong ", "Zhou ", "Yao ", "Du ", "Wei ", "Chu ", "Dou ", "Fu ", "Ren ", "Yin ", "He ", "Bi ", "Bu ", "Yun ", "Di ", "Tu ", "Sui ", "Sui ", "Cheng ", "Chen ", "Wu ", "Bie ", "Xi ", "Geng ", "Li ", "Fu ", "Zhu ", "Mo ", "Li ", "Zhuang ", "Ji ", "Duo ", "Qiu ", "Sha ", "Suo ", "Chen ", "Feng ", "Ju ", "Mei ", "Meng ", "Xing ", "Jing ", "Che ", "Xin ", "Jun ", "Yan ", "Ting ", "Diao ", "Cuo ", "Wan ", "Han ", "You ", "Cuo ", "Jia ", "Wang ", "You ", "Niu ", "Shao ", "Xian ", "Lang ", "Fu ", "E ", "Mo ", "Wen ", "Jie ", "Nan ", "Mu ", "Kan ", "Lai ", "Lian ", "Shi ", "Wo ", "Usagi ", "Lian ", "Huo ", "You ", "Ying ", "Ying ", "Nuc ", "Chun ", "Mang ", "Mang ", "Ci ", "Wan ", "Jing ", "Di ", "Qu ", "Dong ", "Jian ", "Zou ", "Gu ", "La ", "Lu ", "Ju ", "Wei ", "Jun ", "Nie ", "Kun ", "He ", "Pu ", "Zi ", "Gao ", "Guo ", "Fu ", "Lun ", "Chang ", "Chou ", "Song ", "Chui ", "Zhan ", "Men ", "Cai ", "Ba ", "Li ", "Tu ", "Bo ", "Han ", "Bao ", "Qin ", "Juan ", "Xi ", "Qin ", "Di ", "Jie ", "Pu ", "Dang ", "Jin ", "Zhao ", "Tai ", "Geng ", "Hua ", "Gu ", "Ling ", "Fei ", "Jin ", "An ", "Wang ", "Beng ", "Zhou ", "Yan ", "Ju ", "Jian ", "Lin ", "Tan ", "Shu ", "Tian ", "Dao "];
  }
});

// node_modules/unidecode/data/x84.js
var require_x84 = __commonJS({
  "node_modules/unidecode/data/x84.js"(exports2, module2) {
    module2.exports = ["Hu ", "Qi ", "He ", "Cui ", "Tao ", "Chun ", "Bei ", "Chang ", "Huan ", "Fei ", "Lai ", "Qi ", "Meng ", "Ping ", "Wei ", "Dan ", "Sha ", "Huan ", "Yan ", "Yi ", "Tiao ", "Qi ", "Wan ", "Ce ", "Nai ", "Kutabireru ", "Tuo ", "Jiu ", "Tie ", "Luo ", "[?] ", "[?] ", "Meng ", "[?] ", "Yaji ", "[?] ", "Ying ", "Ying ", "Ying ", "Xiao ", "Sa ", "Qiu ", "Ke ", "Xiang ", "Wan ", "Yu ", "Yu ", "Fu ", "Lian ", "Xuan ", "Yuan ", "Nan ", "Ze ", "Wo ", "Chun ", "Xiao ", "Yu ", "Pian ", "Mao ", "An ", "E ", "Luo ", "Ying ", "Huo ", "Gua ", "Jiang ", "Mian ", "Zuo ", "Zuo ", "Ju ", "Bao ", "Rou ", "Xi ", "Xie ", "An ", "Qu ", "Jian ", "Fu ", "Lu ", "Jing ", "Pen ", "Feng ", "Hong ", "Hong ", "Hou ", "Yan ", "Tu ", "Zhu ", "Zi ", "Xiang ", "Shen ", "Ge ", "Jie ", "Jing ", "Mi ", "Huang ", "Shen ", "Pu ", "Gai ", "Dong ", "Zhou ", "Qian ", "Wei ", "Bo ", "Wei ", "Pa ", "Ji ", "Hu ", "Zang ", "Jia ", "Duan ", "Yao ", "Jun ", "Cong ", "Quan ", "Wei ", "Xian ", "Kui ", "Ting ", "Hun ", "Xi ", "Shi ", "Qi ", "Lan ", "Zong ", "Yao ", "Yuan ", "Mei ", "Yun ", "Shu ", "Di ", "Zhuan ", "Guan ", "Sukumo ", "Xue ", "Chan ", "Kai ", "Kui ", "[?] ", "Jiang ", "Lou ", "Wei ", "Pai ", "[?] ", "Sou ", "Yin ", "Shi ", "Chun ", "Shi ", "Yun ", "Zhen ", "Lang ", "Nu ", "Meng ", "He ", "Que ", "Suan ", "Yuan ", "Li ", "Ju ", "Xi ", "Pang ", "Chu ", "Xu ", "Tu ", "Liu ", "Wo ", "Zhen ", "Qian ", "Zu ", "Po ", "Cuo ", "Yuan ", "Chu ", "Yu ", "Kuai ", "Pan ", "Pu ", "Pu ", "Na ", "Shuo ", "Xi ", "Fen ", "Yun ", "Zheng ", "Jian ", "Ji ", "Ruo ", "Cang ", "En ", "Mi ", "Hao ", "Sun ", "Zhen ", "Ming ", "Sou ", "Xu ", "Liu ", "Xi ", "Gu ", "Lang ", "Rong ", "Weng ", "Gai ", "Cuo ", "Shi ", "Tang ", "Luo ", "Ru ", "Suo ", "Xian ", "Bei ", "Yao ", "Gui ", "Bi ", "Zong ", "Gun ", "Za ", "Xiu ", "Ce ", "Hai ", "Lan ", "[?] ", "Ji ", "Li ", "Can ", "Lang ", "Yu ", "[?] ", "Ying ", "Mo ", "Diao ", "Tiao ", "Mao ", "Tong ", "Zhu ", "Peng ", "An ", "Lian ", "Cong ", "Xi ", "Ping ", "Qiu ", "Jin ", "Chun ", "Jie ", "Wei ", "Tui ", "Cao ", "Yu ", "Yi ", "Ji ", "Liao ", "Bi ", "Lu ", "Su "];
  }
});

// node_modules/unidecode/data/x85.js
var require_x85 = __commonJS({
  "node_modules/unidecode/data/x85.js"(exports2, module2) {
    module2.exports = ["Bu ", "Zhang ", "Luo ", "Jiang ", "Man ", "Yan ", "Ling ", "Ji ", "Piao ", "Gun ", "Han ", "Di ", "Su ", "Lu ", "She ", "Shang ", "Di ", "Mie ", "Xun ", "Man ", "Bo ", "Di ", "Cuo ", "Zhe ", "Sen ", "Xuan ", "Wei ", "Hu ", "Ao ", "Mi ", "Lou ", "Cu ", "Zhong ", "Cai ", "Po ", "Jiang ", "Mi ", "Cong ", "Niao ", "Hui ", "Jun ", "Yin ", "Jian ", "Yan ", "Shu ", "Yin ", "Kui ", "Chen ", "Hu ", "Sha ", "Kou ", "Qian ", "Ma ", "Zang ", "Sonoko ", "Qiang ", "Dou ", "Lian ", "Lin ", "Kou ", "Ai ", "Bi ", "Li ", "Wei ", "Ji ", "Xun ", "Sheng ", "Fan ", "Meng ", "Ou ", "Chan ", "Dian ", "Xun ", "Jiao ", "Rui ", "Rui ", "Lei ", "Yu ", "Qiao ", "Chu ", "Hua ", "Jian ", "Mai ", "Yun ", "Bao ", "You ", "Qu ", "Lu ", "Rao ", "Hui ", "E ", "Teng ", "Fei ", "Jue ", "Zui ", "Fa ", "Ru ", "Fen ", "Kui ", "Shun ", "Rui ", "Ya ", "Xu ", "Fu ", "Jue ", "Dang ", "Wu ", "Tong ", "Si ", "Xiao ", "Xi ", "Long ", "Yun ", "[?] ", "Qi ", "Jian ", "Yun ", "Sun ", "Ling ", "Yu ", "Xia ", "Yong ", "Ji ", "Hong ", "Si ", "Nong ", "Lei ", "Xuan ", "Yun ", "Yu ", "Xi ", "Hao ", "Bo ", "Hao ", "Ai ", "Wei ", "Hui ", "Wei ", "Ji ", "Ci ", "Xiang ", "Luan ", "Mie ", "Yi ", "Leng ", "Jiang ", "Can ", "Shen ", "Qiang ", "Lian ", "Ke ", "Yuan ", "Da ", "Ti ", "Tang ", "Xie ", "Bi ", "Zhan ", "Sun ", "Lian ", "Fan ", "Ding ", "Jie ", "Gu ", "Xie ", "Shu ", "Jian ", "Kao ", "Hong ", "Sa ", "Xin ", "Xun ", "Yao ", "Hie ", "Sou ", "Shu ", "Xun ", "Dui ", "Pin ", "Wei ", "Neng ", "Chou ", "Mai ", "Ru ", "Piao ", "Tai ", "Qi ", "Zao ", "Chen ", "Zhen ", "Er ", "Ni ", "Ying ", "Gao ", "Cong ", "Xiao ", "Qi ", "Fa ", "Jian ", "Xu ", "Kui ", "Jie ", "Bian ", "Diao ", "Mi ", "Lan ", "Jin ", "Cang ", "Miao ", "Qiong ", "Qie ", "Xian ", "[?] ", "Ou ", "Xian ", "Su ", "Lu ", "Yi ", "Xu ", "Xie ", "Li ", "Yi ", "La ", "Lei ", "Xiao ", "Di ", "Zhi ", "Bei ", "Teng ", "Yao ", "Mo ", "Huan ", "Piao ", "Fan ", "Sou ", "Tan ", "Tui ", "Qiong ", "Qiao ", "Wei ", "Liu ", "Hui ", "[?] ", "Gao ", "Yun ", "[?] ", "Li ", "Shu ", "Chu ", "Ai ", "Lin ", "Zao ", "Xuan ", "Chen ", "Lai ", "Huo "];
  }
});

// node_modules/unidecode/data/x86.js
var require_x86 = __commonJS({
  "node_modules/unidecode/data/x86.js"(exports2, module2) {
    module2.exports = ["Tuo ", "Wu ", "Rui ", "Rui ", "Qi ", "Heng ", "Lu ", "Su ", "Tui ", "Mang ", "Yun ", "Pin ", "Yu ", "Xun ", "Ji ", "Jiong ", "Xian ", "Mo ", "Hagi ", "Su ", "Jiong ", "[?] ", "Nie ", "Bo ", "Rang ", "Yi ", "Xian ", "Yu ", "Ju ", "Lian ", "Lian ", "Yin ", "Qiang ", "Ying ", "Long ", "Tong ", "Wei ", "Yue ", "Ling ", "Qu ", "Yao ", "Fan ", "Mi ", "Lan ", "Kui ", "Lan ", "Ji ", "Dang ", "Katsura ", "Lei ", "Lei ", "Hua ", "Feng ", "Zhi ", "Wei ", "Kui ", "Zhan ", "Huai ", "Li ", "Ji ", "Mi ", "Lei ", "Huai ", "Luo ", "Ji ", "Kui ", "Lu ", "Jian ", "San ", "[?] ", "Lei ", "Quan ", "Xiao ", "Yi ", "Luan ", "Men ", "Bie ", "Hu ", "Hu ", "Lu ", "Nue ", "Lu ", "Si ", "Xiao ", "Qian ", "Chu ", "Hu ", "Xu ", "Cuo ", "Fu ", "Xu ", "Xu ", "Lu ", "Hu ", "Yu ", "Hao ", "Jiao ", "Ju ", "Guo ", "Bao ", "Yan ", "Zhan ", "Zhan ", "Kui ", "Ban ", "Xi ", "Shu ", "Chong ", "Qiu ", "Diao ", "Ji ", "Qiu ", "Cheng ", "Shi ", "[?] ", "Di ", "Zhe ", "She ", "Yu ", "Gan ", "Zi ", "Hong ", "Hui ", "Meng ", "Ge ", "Sui ", "Xia ", "Chai ", "Shi ", "Yi ", "Ma ", "Xiang ", "Fang ", "E ", "Pa ", "Chi ", "Qian ", "Wen ", "Wen ", "Rui ", "Bang ", "Bi ", "Yue ", "Yue ", "Jun ", "Qi ", "Ran ", "Yin ", "Qi ", "Tian ", "Yuan ", "Jue ", "Hui ", "Qin ", "Qi ", "Zhong ", "Ya ", "Ci ", "Mu ", "Wang ", "Fen ", "Fen ", "Hang ", "Gong ", "Zao ", "Fu ", "Ran ", "Jie ", "Fu ", "Chi ", "Dou ", "Piao ", "Xian ", "Ni ", "Te ", "Qiu ", "You ", "Zha ", "Ping ", "Chi ", "You ", "He ", "Han ", "Ju ", "Li ", "Fu ", "Ran ", "Zha ", "Gou ", "Pi ", "Bo ", "Xian ", "Zhu ", "Diao ", "Bie ", "Bing ", "Gu ", "Ran ", "Qu ", "She ", "Tie ", "Ling ", "Gu ", "Dan ", "Gu ", "Ying ", "Li ", "Cheng ", "Qu ", "Mou ", "Ge ", "Ci ", "Hui ", "Hui ", "Mang ", "Fu ", "Yang ", "Wa ", "Lie ", "Zhu ", "Yi ", "Xian ", "Kuo ", "Jiao ", "Li ", "Yi ", "Ping ", "Ji ", "Ha ", "She ", "Yi ", "Wang ", "Mo ", "Qiong ", "Qie ", "Gui ", "Gong ", "Zhi ", "Man ", "Ebi ", "Zhi ", "Jia ", "Rao ", "Si ", "Qi ", "Xing ", "Lie ", "Qiu ", "Shao ", "Yong ", "Jia ", "Shui ", "Che ", "Bai ", "E ", "Han "];
  }
});

// node_modules/unidecode/data/x87.js
var require_x87 = __commonJS({
  "node_modules/unidecode/data/x87.js"(exports2, module2) {
    module2.exports = ["Shu ", "Xuan ", "Feng ", "Shen ", "Zhen ", "Fu ", "Xian ", "Zhe ", "Wu ", "Fu ", "Li ", "Lang ", "Bi ", "Chu ", "Yuan ", "You ", "Jie ", "Dan ", "Yan ", "Ting ", "Dian ", "Shui ", "Hui ", "Gua ", "Zhi ", "Song ", "Fei ", "Ju ", "Mi ", "Qi ", "Qi ", "Yu ", "Jun ", "Zha ", "Meng ", "Qiang ", "Si ", "Xi ", "Lun ", "Li ", "Die ", "Tiao ", "Tao ", "Kun ", "Gan ", "Han ", "Yu ", "Bang ", "Fei ", "Pi ", "Wei ", "Dun ", "Yi ", "Yuan ", "Su ", "Quan ", "Qian ", "Rui ", "Ni ", "Qing ", "Wei ", "Liang ", "Guo ", "Wan ", "Dong ", "E ", "Ban ", "Di ", "Wang ", "Can ", "Yang ", "Ying ", "Guo ", "Chan ", "[?] ", "La ", "Ke ", "Ji ", "He ", "Ting ", "Mai ", "Xu ", "Mian ", "Yu ", "Jie ", "Shi ", "Xuan ", "Huang ", "Yan ", "Bian ", "Rou ", "Wei ", "Fu ", "Yuan ", "Mei ", "Wei ", "Fu ", "Ruan ", "Xie ", "You ", "Qiu ", "Mao ", "Xia ", "Ying ", "Shi ", "Chong ", "Tang ", "Zhu ", "Zong ", "Ti ", "Fu ", "Yuan ", "Hui ", "Meng ", "La ", "Du ", "Hu ", "Qiu ", "Die ", "Li ", "Gua ", "Yun ", "Ju ", "Nan ", "Lou ", "Qun ", "Rong ", "Ying ", "Jiang ", "[?] ", "Lang ", "Pang ", "Si ", "Xi ", "Ci ", "Xi ", "Yuan ", "Weng ", "Lian ", "Sou ", "Ban ", "Rong ", "Rong ", "Ji ", "Wu ", "Qiu ", "Han ", "Qin ", "Yi ", "Bi ", "Hua ", "Tang ", "Yi ", "Du ", "Nai ", "He ", "Hu ", "Hui ", "Ma ", "Ming ", "Yi ", "Wen ", "Ying ", "Teng ", "Yu ", "Cang ", "So ", "Ebi ", "Man ", "[?] ", "Shang ", "Zhe ", "Cao ", "Chi ", "Di ", "Ao ", "Lu ", "Wei ", "Zhi ", "Tang ", "Chen ", "Piao ", "Qu ", "Pi ", "Yu ", "Jian ", "Luo ", "Lou ", "Qin ", "Zhong ", "Yin ", "Jiang ", "Shuai ", "Wen ", "Jiao ", "Wan ", "Zhi ", "Zhe ", "Ma ", "Ma ", "Guo ", "Liu ", "Mao ", "Xi ", "Cong ", "Li ", "Man ", "Xiao ", "Kamakiri ", "Zhang ", "Mang ", "Xiang ", "Mo ", "Zui ", "Si ", "Qiu ", "Te ", "Zhi ", "Peng ", "Peng ", "Jiao ", "Qu ", "Bie ", "Liao ", "Pan ", "Gui ", "Xi ", "Ji ", "Zhuan ", "Huang ", "Fei ", "Lao ", "Jue ", "Jue ", "Hui ", "Yin ", "Chan ", "Jiao ", "Shan ", "Rao ", "Xiao ", "Mou ", "Chong ", "Xun ", "Si ", "[?] ", "Cheng ", "Dang ", "Li ", "Xie ", "Shan ", "Yi ", "Jing ", "Da ", "Chan ", "Qi "];
  }
});

// node_modules/unidecode/data/x88.js
var require_x88 = __commonJS({
  "node_modules/unidecode/data/x88.js"(exports2, module2) {
    module2.exports = ["Ci ", "Xiang ", "She ", "Luo ", "Qin ", "Ying ", "Chai ", "Li ", "Ze ", "Xuan ", "Lian ", "Zhu ", "Ze ", "Xie ", "Mang ", "Xie ", "Qi ", "Rong ", "Jian ", "Meng ", "Hao ", "Ruan ", "Huo ", "Zhuo ", "Jie ", "Bin ", "He ", "Mie ", "Fan ", "Lei ", "Jie ", "La ", "Mi ", "Li ", "Chun ", "Li ", "Qiu ", "Nie ", "Lu ", "Du ", "Xiao ", "Zhu ", "Long ", "Li ", "Long ", "Feng ", "Ye ", "Beng ", "Shang ", "Gu ", "Juan ", "Ying ", "[?] ", "Xi ", "Can ", "Qu ", "Quan ", "Du ", "Can ", "Man ", "Jue ", "Jie ", "Zhu ", "Zha ", "Xie ", "Huang ", "Niu ", "Pei ", "Nu ", "Xin ", "Zhong ", "Mo ", "Er ", "Ke ", "Mie ", "Xi ", "Xing ", "Yan ", "Kan ", "Yuan ", "[?] ", "Ling ", "Xuan ", "Shu ", "Xian ", "Tong ", "Long ", "Jie ", "Xian ", "Ya ", "Hu ", "Wei ", "Dao ", "Chong ", "Wei ", "Dao ", "Zhun ", "Heng ", "Qu ", "Yi ", "Yi ", "Bu ", "Gan ", "Yu ", "Biao ", "Cha ", "Yi ", "Shan ", "Chen ", "Fu ", "Gun ", "Fen ", "Shuai ", "Jie ", "Na ", "Zhong ", "Dan ", "Ri ", "Zhong ", "Zhong ", "Xie ", "Qi ", "Xie ", "Ran ", "Zhi ", "Ren ", "Qin ", "Jin ", "Jun ", "Yuan ", "Mei ", "Chai ", "Ao ", "Niao ", "Hui ", "Ran ", "Jia ", "Tuo ", "Ling ", "Dai ", "Bao ", "Pao ", "Yao ", "Zuo ", "Bi ", "Shao ", "Tan ", "Ju ", "He ", "Shu ", "Xiu ", "Zhen ", "Yi ", "Pa ", "Bo ", "Di ", "Wa ", "Fu ", "Gun ", "Zhi ", "Zhi ", "Ran ", "Pan ", "Yi ", "Mao ", "Tuo ", "Na ", "Kou ", "Xian ", "Chan ", "Qu ", "Bei ", "Gun ", "Xi ", "Ne ", "Bo ", "Horo ", "Fu ", "Yi ", "Chi ", "Ku ", "Ren ", "Jiang ", "Jia ", "Cun ", "Mo ", "Jie ", "Er ", "Luo ", "Ru ", "Zhu ", "Gui ", "Yin ", "Cai ", "Lie ", "Kamishimo ", "Yuki ", "Zhuang ", "Dang ", "[?] ", "Kun ", "Ken ", "Niao ", "Shu ", "Jia ", "Kun ", "Cheng ", "Li ", "Juan ", "Shen ", "Pou ", "Ge ", "Yi ", "Yu ", "Zhen ", "Liu ", "Qiu ", "Qun ", "Ji ", "Yi ", "Bu ", "Zhuang ", "Shui ", "Sha ", "Qun ", "Li ", "Lian ", "Lian ", "Ku ", "Jian ", "Fou ", "Chan ", "Bi ", "Gun ", "Tao ", "Yuan ", "Ling ", "Chi ", "Chang ", "Chou ", "Duo ", "Biao ", "Liang ", "Chang ", "Pei ", "Pei ", "Fei ", "Yuan ", "Luo ", "Guo ", "Yan ", "Du ", "Xi ", "Zhi ", "Ju ", "Qi "];
  }
});

// node_modules/unidecode/data/x89.js
var require_x89 = __commonJS({
  "node_modules/unidecode/data/x89.js"(exports2, module2) {
    module2.exports = ["Ji ", "Zhi ", "Gua ", "Ken ", "Che ", "Ti ", "Ti ", "Fu ", "Chong ", "Xie ", "Bian ", "Die ", "Kun ", "Duan ", "Xiu ", "Xiu ", "He ", "Yuan ", "Bao ", "Bao ", "Fu ", "Yu ", "Tuan ", "Yan ", "Hui ", "Bei ", "Chu ", "Lu ", "Ena ", "Hitoe ", "Yun ", "Da ", "Gou ", "Da ", "Huai ", "Rong ", "Yuan ", "Ru ", "Nai ", "Jiong ", "Suo ", "Ban ", "Tun ", "Chi ", "Sang ", "Niao ", "Ying ", "Jie ", "Qian ", "Huai ", "Ku ", "Lian ", "Bao ", "Li ", "Zhe ", "Shi ", "Lu ", "Yi ", "Die ", "Xie ", "Xian ", "Wei ", "Biao ", "Cao ", "Ji ", "Jiang ", "Sen ", "Bao ", "Xiang ", "Chihaya ", "Pu ", "Jian ", "Zhuan ", "Jian ", "Zui ", "Ji ", "Dan ", "Za ", "Fan ", "Bo ", "Xiang ", "Xin ", "Bie ", "Rao ", "Man ", "Lan ", "Ao ", "Duo ", "Gui ", "Cao ", "Sui ", "Nong ", "Chan ", "Lian ", "Bi ", "Jin ", "Dang ", "Shu ", "Tan ", "Bi ", "Lan ", "Pu ", "Ru ", "Zhi ", "[?] ", "Shu ", "Wa ", "Shi ", "Bai ", "Xie ", "Bo ", "Chen ", "Lai ", "Long ", "Xi ", "Xian ", "Lan ", "Zhe ", "Dai ", "Tasuki ", "Zan ", "Shi ", "Jian ", "Pan ", "Yi ", "Ran ", "Ya ", "Xi ", "Xi ", "Yao ", "Feng ", "Tan ", "[?] ", "Biao ", "Fu ", "Ba ", "He ", "Ji ", "Ji ", "Jian ", "Guan ", "Bian ", "Yan ", "Gui ", "Jue ", "Pian ", "Mao ", "Mi ", "Mi ", "Mie ", "Shi ", "Si ", "Zhan ", "Luo ", "Jue ", "Mi ", "Tiao ", "Lian ", "Yao ", "Zhi ", "Jun ", "Xi ", "Shan ", "Wei ", "Xi ", "Tian ", "Yu ", "Lan ", "E ", "Du ", "Qin ", "Pang ", "Ji ", "Ming ", "Ying ", "Gou ", "Qu ", "Zhan ", "Jin ", "Guan ", "Deng ", "Jian ", "Luo ", "Qu ", "Jian ", "Wei ", "Jue ", "Qu ", "Luo ", "Lan ", "Shen ", "Di ", "Guan ", "Jian ", "Guan ", "Yan ", "Gui ", "Mi ", "Shi ", "Zhan ", "Lan ", "Jue ", "Ji ", "Xi ", "Di ", "Tian ", "Yu ", "Gou ", "Jin ", "Qu ", "Jiao ", "Jiu ", "Jin ", "Cu ", "Jue ", "Zhi ", "Chao ", "Ji ", "Gu ", "Dan ", "Zui ", "Di ", "Shang ", "Hua ", "Quan ", "Ge ", "Chi ", "Jie ", "Gui ", "Gong ", "Hong ", "Jie ", "Hun ", "Qiu ", "Xing ", "Su ", "Ni ", "Ji ", "Lu ", "Zhi ", "Zha ", "Bi ", "Xing ", "Hu ", "Shang ", "Gong ", "Zhi ", "Xue ", "Chu ", "Xi ", "Yi ", "Lu ", "Jue ", "Xi ", "Yan ", "Xi "];
  }
});

// node_modules/unidecode/data/x8a.js
var require_x8a = __commonJS({
  "node_modules/unidecode/data/x8a.js"(exports2, module2) {
    module2.exports = ["Yan ", "Yan ", "Ding ", "Fu ", "Qiu ", "Qiu ", "Jiao ", "Hong ", "Ji ", "Fan ", "Xun ", "Diao ", "Hong ", "Cha ", "Tao ", "Xu ", "Jie ", "Yi ", "Ren ", "Xun ", "Yin ", "Shan ", "Qi ", "Tuo ", "Ji ", "Xun ", "Yin ", "E ", "Fen ", "Ya ", "Yao ", "Song ", "Shen ", "Yin ", "Xin ", "Jue ", "Xiao ", "Ne ", "Chen ", "You ", "Zhi ", "Xiong ", "Fang ", "Xin ", "Chao ", "She ", "Xian ", "Sha ", "Tun ", "Xu ", "Yi ", "Yi ", "Su ", "Chi ", "He ", "Shen ", "He ", "Xu ", "Zhen ", "Zhu ", "Zheng ", "Gou ", "Zi ", "Zi ", "Zhan ", "Gu ", "Fu ", "Quan ", "Die ", "Ling ", "Di ", "Yang ", "Li ", "Nao ", "Pan ", "Zhou ", "Gan ", "Yi ", "Ju ", "Ao ", "Zha ", "Tuo ", "Yi ", "Qu ", "Zhao ", "Ping ", "Bi ", "Xiong ", "Qu ", "Ba ", "Da ", "Zu ", "Tao ", "Zhu ", "Ci ", "Zhe ", "Yong ", "Xu ", "Xun ", "Yi ", "Huang ", "He ", "Shi ", "Cha ", "Jiao ", "Shi ", "Hen ", "Cha ", "Gou ", "Gui ", "Quan ", "Hui ", "Jie ", "Hua ", "Gai ", "Xiang ", "Wei ", "Shen ", "Chou ", "Tong ", "Mi ", "Zhan ", "Ming ", "E ", "Hui ", "Yan ", "Xiong ", "Gua ", "Er ", "Beng ", "Tiao ", "Chi ", "Lei ", "Zhu ", "Kuang ", "Kua ", "Wu ", "Yu ", "Teng ", "Ji ", "Zhi ", "Ren ", "Su ", "Lang ", "E ", "Kuang ", "E ", "Shi ", "Ting ", "Dan ", "Bo ", "Chan ", "You ", "Heng ", "Qiao ", "Qin ", "Shua ", "An ", "Yu ", "Xiao ", "Cheng ", "Jie ", "Xian ", "Wu ", "Wu ", "Gao ", "Song ", "Pu ", "Hui ", "Jing ", "Shuo ", "Zhen ", "Shuo ", "Du ", "Yasashi ", "Chang ", "Shui ", "Jie ", "Ke ", "Qu ", "Cong ", "Xiao ", "Sui ", "Wang ", "Xuan ", "Fei ", "Chi ", "Ta ", "Yi ", "Na ", "Yin ", "Diao ", "Pi ", "Chuo ", "Chan ", "Chen ", "Zhun ", "Ji ", "Qi ", "Tan ", "Zhui ", "Wei ", "Ju ", "Qing ", "Jian ", "Zheng ", "Ze ", "Zou ", "Qian ", "Zhuo ", "Liang ", "Jian ", "Zhu ", "Hao ", "Lun ", "Shen ", "Biao ", "Huai ", "Pian ", "Yu ", "Die ", "Xu ", "Pian ", "Shi ", "Xuan ", "Shi ", "Hun ", "Hua ", "E ", "Zhong ", "Di ", "Xie ", "Fu ", "Pu ", "Ting ", "Jian ", "Qi ", "Yu ", "Zi ", "Chuan ", "Xi ", "Hui ", "Yin ", "An ", "Xian ", "Nan ", "Chen ", "Feng ", "Zhu ", "Yang ", "Yan ", "Heng ", "Xuan ", "Ge ", "Nuo ", "Qi "];
  }
});

// node_modules/unidecode/data/x8b.js
var require_x8b = __commonJS({
  "node_modules/unidecode/data/x8b.js"(exports2, module2) {
    module2.exports = ["Mou ", "Ye ", "Wei ", "[?] ", "Teng ", "Zou ", "Shan ", "Jian ", "Bo ", "Ku ", "Huang ", "Huo ", "Ge ", "Ying ", "Mi ", "Xiao ", "Mi ", "Xi ", "Qiang ", "Chen ", "Nue ", "Ti ", "Su ", "Bang ", "Chi ", "Qian ", "Shi ", "Jiang ", "Yuan ", "Xie ", "Xue ", "Tao ", "Yao ", "Yao ", "[?] ", "Yu ", "Biao ", "Cong ", "Qing ", "Li ", "Mo ", "Mo ", "Shang ", "Zhe ", "Miu ", "Jian ", "Ze ", "Jie ", "Lian ", "Lou ", "Can ", "Ou ", "Guan ", "Xi ", "Zhuo ", "Ao ", "Ao ", "Jin ", "Zhe ", "Yi ", "Hu ", "Jiang ", "Man ", "Chao ", "Han ", "Hua ", "Chan ", "Xu ", "Zeng ", "Se ", "Xi ", "She ", "Dui ", "Zheng ", "Nao ", "Lan ", "E ", "Ying ", "Jue ", "Ji ", "Zun ", "Jiao ", "Bo ", "Hui ", "Zhuan ", "Mu ", "Zen ", "Zha ", "Shi ", "Qiao ", "Tan ", "Zen ", "Pu ", "Sheng ", "Xuan ", "Zao ", "Tan ", "Dang ", "Sui ", "Qian ", "Ji ", "Jiao ", "Jing ", "Lian ", "Nou ", "Yi ", "Ai ", "Zhan ", "Pi ", "Hui ", "Hua ", "Yi ", "Yi ", "Shan ", "Rang ", "Nou ", "Qian ", "Zhui ", "Ta ", "Hu ", "Zhou ", "Hao ", "Ye ", "Ying ", "Jian ", "Yu ", "Jian ", "Hui ", "Du ", "Zhe ", "Xuan ", "Zan ", "Lei ", "Shen ", "Wei ", "Chan ", "Li ", "Yi ", "Bian ", "Zhe ", "Yan ", "E ", "Chou ", "Wei ", "Chou ", "Yao ", "Chan ", "Rang ", "Yin ", "Lan ", "Chen ", "Huo ", "Zhe ", "Huan ", "Zan ", "Yi ", "Dang ", "Zhan ", "Yan ", "Du ", "Yan ", "Ji ", "Ding ", "Fu ", "Ren ", "Ji ", "Jie ", "Hong ", "Tao ", "Rang ", "Shan ", "Qi ", "Tuo ", "Xun ", "Yi ", "Xun ", "Ji ", "Ren ", "Jiang ", "Hui ", "Ou ", "Ju ", "Ya ", "Ne ", "Xu ", "E ", "Lun ", "Xiong ", "Song ", "Feng ", "She ", "Fang ", "Jue ", "Zheng ", "Gu ", "He ", "Ping ", "Zu ", "Shi ", "Xiong ", "Zha ", "Su ", "Zhen ", "Di ", "Zou ", "Ci ", "Qu ", "Zhao ", "Bi ", "Yi ", "Yi ", "Kuang ", "Lei ", "Shi ", "Gua ", "Shi ", "Jie ", "Hui ", "Cheng ", "Zhu ", "Shen ", "Hua ", "Dan ", "Gou ", "Quan ", "Gui ", "Xun ", "Yi ", "Zheng ", "Gai ", "Xiang ", "Cha ", "Hun ", "Xu ", "Zhou ", "Jie ", "Wu ", "Yu ", "Qiao ", "Wu ", "Gao ", "You ", "Hui ", "Kuang ", "Shuo ", "Song ", "Ai ", "Qing ", "Zhu ", "Zou ", "Nuo ", "Du ", "Zhuo ", "Fei ", "Ke ", "Wei "];
  }
});

// node_modules/unidecode/data/x8c.js
var require_x8c = __commonJS({
  "node_modules/unidecode/data/x8c.js"(exports2, module2) {
    module2.exports = ["Yu ", "Shui ", "Shen ", "Diao ", "Chan ", "Liang ", "Zhun ", "Sui ", "Tan ", "Shen ", "Yi ", "Mou ", "Chen ", "Die ", "Huang ", "Jian ", "Xie ", "Nue ", "Ye ", "Wei ", "E ", "Yu ", "Xuan ", "Chan ", "Zi ", "An ", "Yan ", "Di ", "Mi ", "Pian ", "Xu ", "Mo ", "Dang ", "Su ", "Xie ", "Yao ", "Bang ", "Shi ", "Qian ", "Mi ", "Jin ", "Man ", "Zhe ", "Jian ", "Miu ", "Tan ", "Zen ", "Qiao ", "Lan ", "Pu ", "Jue ", "Yan ", "Qian ", "Zhan ", "Chen ", "Gu ", "Qian ", "Hong ", "Xia ", "Jue ", "Hong ", "Han ", "Hong ", "Xi ", "Xi ", "Huo ", "Liao ", "Han ", "Du ", "Long ", "Dou ", "Jiang ", "Qi ", "Shi ", "Li ", "Deng ", "Wan ", "Bi ", "Shu ", "Xian ", "Feng ", "Zhi ", "Zhi ", "Yan ", "Yan ", "Shi ", "Chu ", "Hui ", "Tun ", "Yi ", "Tun ", "Yi ", "Jian ", "Ba ", "Hou ", "E ", "Cu ", "Xiang ", "Huan ", "Jian ", "Ken ", "Gai ", "Qu ", "Fu ", "Xi ", "Bin ", "Hao ", "Yu ", "Zhu ", "Jia ", "[?] ", "Xi ", "Bo ", "Wen ", "Huan ", "Bin ", "Di ", "Zong ", "Fen ", "Yi ", "Zhi ", "Bao ", "Chai ", "Han ", "Pi ", "Na ", "Pi ", "Gou ", "Na ", "You ", "Diao ", "Mo ", "Si ", "Xiu ", "Huan ", "Kun ", "He ", "He ", "Mo ", "Han ", "Mao ", "Li ", "Ni ", "Bi ", "Yu ", "Jia ", "Tuan ", "Mao ", "Pi ", "Xi ", "E ", "Ju ", "Mo ", "Chu ", "Tan ", "Huan ", "Jue ", "Bei ", "Zhen ", "Yuan ", "Fu ", "Cai ", "Gong ", "Te ", "Yi ", "Hang ", "Wan ", "Pin ", "Huo ", "Fan ", "Tan ", "Guan ", "Ze ", "Zhi ", "Er ", "Zhu ", "Shi ", "Bi ", "Zi ", "Er ", "Gui ", "Pian ", "Bian ", "Mai ", "Dai ", "Sheng ", "Kuang ", "Fei ", "Tie ", "Yi ", "Chi ", "Mao ", "He ", "Bi ", "Lu ", "Ren ", "Hui ", "Gai ", "Pian ", "Zi ", "Jia ", "Xu ", "Zei ", "Jiao ", "Gai ", "Zang ", "Jian ", "Ying ", "Xun ", "Zhen ", "She ", "Bin ", "Bin ", "Qiu ", "She ", "Chuan ", "Zang ", "Zhou ", "Lai ", "Zan ", "Si ", "Chen ", "Shang ", "Tian ", "Pei ", "Geng ", "Xian ", "Mai ", "Jian ", "Sui ", "Fu ", "Tan ", "Cong ", "Cong ", "Zhi ", "Ji ", "Zhang ", "Du ", "Jin ", "Xiong ", "Shun ", "Yun ", "Bao ", "Zai ", "Lai ", "Feng ", "Cang ", "Ji ", "Sheng ", "Ai ", "Zhuan ", "Fu ", "Gou ", "Sai ", "Ze ", "Liao "];
  }
});

// node_modules/unidecode/data/x8d.js
var require_x8d = __commonJS({
  "node_modules/unidecode/data/x8d.js"(exports2, module2) {
    module2.exports = ["Wei ", "Bai ", "Chen ", "Zhuan ", "Zhi ", "Zhui ", "Biao ", "Yun ", "Zeng ", "Tan ", "Zan ", "Yan ", "[?] ", "Shan ", "Wan ", "Ying ", "Jin ", "Gan ", "Xian ", "Zang ", "Bi ", "Du ", "Shu ", "Yan ", "[?] ", "Xuan ", "Long ", "Gan ", "Zang ", "Bei ", "Zhen ", "Fu ", "Yuan ", "Gong ", "Cai ", "Ze ", "Xian ", "Bai ", "Zhang ", "Huo ", "Zhi ", "Fan ", "Tan ", "Pin ", "Bian ", "Gou ", "Zhu ", "Guan ", "Er ", "Jian ", "Bi ", "Shi ", "Tie ", "Gui ", "Kuang ", "Dai ", "Mao ", "Fei ", "He ", "Yi ", "Zei ", "Zhi ", "Jia ", "Hui ", "Zi ", "Ren ", "Lu ", "Zang ", "Zi ", "Gai ", "Jin ", "Qiu ", "Zhen ", "Lai ", "She ", "Fu ", "Du ", "Ji ", "Shu ", "Shang ", "Si ", "Bi ", "Zhou ", "Geng ", "Pei ", "Tan ", "Lai ", "Feng ", "Zhui ", "Fu ", "Zhuan ", "Sai ", "Ze ", "Yan ", "Zan ", "Yun ", "Zeng ", "Shan ", "Ying ", "Gan ", "Chi ", "Xi ", "She ", "Nan ", "Xiong ", "Xi ", "Cheng ", "He ", "Cheng ", "Zhe ", "Xia ", "Tang ", "Zou ", "Zou ", "Li ", "Jiu ", "Fu ", "Zhao ", "Gan ", "Qi ", "Shan ", "Qiong ", "Qin ", "Xian ", "Ci ", "Jue ", "Qin ", "Chi ", "Ci ", "Chen ", "Chen ", "Die ", "Ju ", "Chao ", "Di ", "Se ", "Zhan ", "Zhu ", "Yue ", "Qu ", "Jie ", "Chi ", "Chu ", "Gua ", "Xue ", "Ci ", "Tiao ", "Duo ", "Lie ", "Gan ", "Suo ", "Cu ", "Xi ", "Zhao ", "Su ", "Yin ", "Ju ", "Jian ", "Que ", "Tang ", "Chuo ", "Cui ", "Lu ", "Qu ", "Dang ", "Qiu ", "Zi ", "Ti ", "Qu ", "Chi ", "Huang ", "Qiao ", "Qiao ", "Yao ", "Zao ", "Ti ", "[?] ", "Zan ", "Zan ", "Zu ", "Pa ", "Bao ", "Ku ", "Ke ", "Dun ", "Jue ", "Fu ", "Chen ", "Jian ", "Fang ", "Zhi ", "Sa ", "Yue ", "Pa ", "Qi ", "Yue ", "Qiang ", "Tuo ", "Tai ", "Yi ", "Nian ", "Ling ", "Mei ", "Ba ", "Die ", "Ku ", "Tuo ", "Jia ", "Ci ", "Pao ", "Qia ", "Zhu ", "Ju ", "Die ", "Zhi ", "Fu ", "Pan ", "Ju ", "Shan ", "Bo ", "Ni ", "Ju ", "Li ", "Gen ", "Yi ", "Ji ", "Dai ", "Xian ", "Jiao ", "Duo ", "Zhu ", "Zhuan ", "Kua ", "Zhuai ", "Gui ", "Qiong ", "Kui ", "Xiang ", "Chi ", "Lu ", "Beng ", "Zhi ", "Jia ", "Tiao ", "Cai ", "Jian ", "Ta ", "Qiao ", "Bi ", "Xian ", "Duo ", "Ji ", "Ju ", "Ji ", "Shu ", "Tu "];
  }
});

// node_modules/unidecode/data/x8e.js
var require_x8e = __commonJS({
  "node_modules/unidecode/data/x8e.js"(exports2, module2) {
    module2.exports = ["Chu ", "Jing ", "Nie ", "Xiao ", "Bo ", "Chi ", "Qun ", "Mou ", "Shu ", "Lang ", "Yong ", "Jiao ", "Chou ", "Qiao ", "[?] ", "Ta ", "Jian ", "Qi ", "Wo ", "Wei ", "Zhuo ", "Jie ", "Ji ", "Nie ", "Ju ", "Ju ", "Lun ", "Lu ", "Leng ", "Huai ", "Ju ", "Chi ", "Wan ", "Quan ", "Ti ", "Bo ", "Zu ", "Qie ", "Ji ", "Cu ", "Zong ", "Cai ", "Zong ", "Peng ", "Zhi ", "Zheng ", "Dian ", "Zhi ", "Yu ", "Duo ", "Dun ", "Chun ", "Yong ", "Zhong ", "Di ", "Zhe ", "Chen ", "Chuai ", "Jian ", "Gua ", "Tang ", "Ju ", "Fu ", "Zu ", "Die ", "Pian ", "Rou ", "Nuo ", "Ti ", "Cha ", "Tui ", "Jian ", "Dao ", "Cuo ", "Xi ", "Ta ", "Qiang ", "Zhan ", "Dian ", "Ti ", "Ji ", "Nie ", "Man ", "Liu ", "Zhan ", "Bi ", "Chong ", "Lu ", "Liao ", "Cu ", "Tang ", "Dai ", "Suo ", "Xi ", "Kui ", "Ji ", "Zhi ", "Qiang ", "Di ", "Man ", "Zong ", "Lian ", "Beng ", "Zao ", "Nian ", "Bie ", "Tui ", "Ju ", "Deng ", "Ceng ", "Xian ", "Fan ", "Chu ", "Zhong ", "Dun ", "Bo ", "Cu ", "Zu ", "Jue ", "Jue ", "Lin ", "Ta ", "Qiao ", "Qiao ", "Pu ", "Liao ", "Dun ", "Cuan ", "Kuang ", "Zao ", "Ta ", "Bi ", "Bi ", "Zhu ", "Ju ", "Chu ", "Qiao ", "Dun ", "Chou ", "Ji ", "Wu ", "Yue ", "Nian ", "Lin ", "Lie ", "Zhi ", "Li ", "Zhi ", "Chan ", "Chu ", "Duan ", "Wei ", "Long ", "Lin ", "Xian ", "Wei ", "Zuan ", "Lan ", "Xie ", "Rang ", "Xie ", "Nie ", "Ta ", "Qu ", "Jie ", "Cuan ", "Zuan ", "Xi ", "Kui ", "Jue ", "Lin ", "Shen ", "Gong ", "Dan ", "Segare ", "Qu ", "Ti ", "Duo ", "Duo ", "Gong ", "Lang ", "Nerau ", "Luo ", "Ai ", "Ji ", "Ju ", "Tang ", "Utsuke ", "[?] ", "Yan ", "Shitsuke ", "Kang ", "Qu ", "Lou ", "Lao ", "Tuo ", "Zhi ", "Yagate ", "Ti ", "Dao ", "Yagate ", "Yu ", "Che ", "Ya ", "Gui ", "Jun ", "Wei ", "Yue ", "Xin ", "Di ", "Xuan ", "Fan ", "Ren ", "Shan ", "Qiang ", "Shu ", "Tun ", "Chen ", "Dai ", "E ", "Na ", "Qi ", "Mao ", "Ruan ", "Ren ", "Fan ", "Zhuan ", "Hong ", "Hu ", "Qu ", "Huang ", "Di ", "Ling ", "Dai ", "Ao ", "Zhen ", "Fan ", "Kuang ", "Ang ", "Peng ", "Bei ", "Gu ", "Ku ", "Pao ", "Zhu ", "Rong ", "E ", "Ba ", "Zhou ", "Zhi ", "Yao ", "Ke ", "Yi ", "Qing ", "Shi ", "Ping "];
  }
});

// node_modules/unidecode/data/x8f.js
var require_x8f = __commonJS({
  "node_modules/unidecode/data/x8f.js"(exports2, module2) {
    module2.exports = ["Er ", "Qiong ", "Ju ", "Jiao ", "Guang ", "Lu ", "Kai ", "Quan ", "Zhou ", "Zai ", "Zhi ", "She ", "Liang ", "Yu ", "Shao ", "You ", "Huan ", "Yun ", "Zhe ", "Wan ", "Fu ", "Qing ", "Zhou ", "Ni ", "Ling ", "Zhe ", "Zhan ", "Liang ", "Zi ", "Hui ", "Wang ", "Chuo ", "Guo ", "Kan ", "Yi ", "Peng ", "Qian ", "Gun ", "Nian ", "Pian ", "Guan ", "Bei ", "Lun ", "Pai ", "Liang ", "Ruan ", "Rou ", "Ji ", "Yang ", "Xian ", "Chuan ", "Cou ", "Qun ", "Ge ", "You ", "Hong ", "Shu ", "Fu ", "Zi ", "Fu ", "Wen ", "Ben ", "Zhan ", "Yu ", "Wen ", "Tao ", "Gu ", "Zhen ", "Xia ", "Yuan ", "Lu ", "Jiu ", "Chao ", "Zhuan ", "Wei ", "Hun ", "Sori ", "Che ", "Jiao ", "Zhan ", "Pu ", "Lao ", "Fen ", "Fan ", "Lin ", "Ge ", "Se ", "Kan ", "Huan ", "Yi ", "Ji ", "Dui ", "Er ", "Yu ", "Xian ", "Hong ", "Lei ", "Pei ", "Li ", "Li ", "Lu ", "Lin ", "Che ", "Ya ", "Gui ", "Xuan ", "Di ", "Ren ", "Zhuan ", "E ", "Lun ", "Ruan ", "Hong ", "Ku ", "Ke ", "Lu ", "Zhou ", "Zhi ", "Yi ", "Hu ", "Zhen ", "Li ", "Yao ", "Qing ", "Shi ", "Zai ", "Zhi ", "Jiao ", "Zhou ", "Quan ", "Lu ", "Jiao ", "Zhe ", "Fu ", "Liang ", "Nian ", "Bei ", "Hui ", "Gun ", "Wang ", "Liang ", "Chuo ", "Zi ", "Cou ", "Fu ", "Ji ", "Wen ", "Shu ", "Pei ", "Yuan ", "Xia ", "Zhan ", "Lu ", "Che ", "Lin ", "Xin ", "Gu ", "Ci ", "Ci ", "Pi ", "Zui ", "Bian ", "La ", "La ", "Ci ", "Xue ", "Ban ", "Bian ", "Bian ", "Bian ", "[?] ", "Bian ", "Ban ", "Ci ", "Bian ", "Bian ", "Chen ", "Ru ", "Nong ", "Nong ", "Zhen ", "Chuo ", "Chuo ", "Suberu ", "Reng ", "Bian ", "Bian ", "Sip ", "Ip ", "Liao ", "Da ", "Chan ", "Gan ", "Qian ", "Yu ", "Yu ", "Qi ", "Xun ", "Yi ", "Guo ", "Mai ", "Qi ", "Za ", "Wang ", "Jia ", "Zhun ", "Ying ", "Ti ", "Yun ", "Jin ", "Hang ", "Ya ", "Fan ", "Wu ", "Da ", "E ", "Huan ", "Zhe ", "Totemo ", "Jin ", "Yuan ", "Wei ", "Lian ", "Chi ", "Che ", "Ni ", "Tiao ", "Zhi ", "Yi ", "Jiong ", "Jia ", "Chen ", "Dai ", "Er ", "Di ", "Po ", "Wang ", "Die ", "Ze ", "Tao ", "Shu ", "Tuo ", "Kep ", "Jing ", "Hui ", "Tong ", "You ", "Mi ", "Beng ", "Ji ", "Nai ", "Yi ", "Jie ", "Zhui ", "Lie ", "Xun "];
  }
});

// node_modules/unidecode/data/x90.js
var require_x90 = __commonJS({
  "node_modules/unidecode/data/x90.js"(exports2, module2) {
    module2.exports = ["Tui ", "Song ", "Gua ", "Tao ", "Pang ", "Hou ", "Ni ", "Dun ", "Jiong ", "Xuan ", "Xun ", "Bu ", "You ", "Xiao ", "Qiu ", "Tou ", "Zhu ", "Qiu ", "Di ", "Di ", "Tu ", "Jing ", "Ti ", "Dou ", "Yi ", "Zhe ", "Tong ", "Guang ", "Wu ", "Shi ", "Cheng ", "Su ", "Zao ", "Qun ", "Feng ", "Lian ", "Suo ", "Hui ", "Li ", "Sako ", "Lai ", "Ben ", "Cuo ", "Jue ", "Beng ", "Huan ", "Dai ", "Lu ", "You ", "Zhou ", "Jin ", "Yu ", "Chuo ", "Kui ", "Wei ", "Ti ", "Yi ", "Da ", "Yuan ", "Luo ", "Bi ", "Nuo ", "Yu ", "Dang ", "Sui ", "Dun ", "Sui ", "Yan ", "Chuan ", "Chi ", "Ti ", "Yu ", "Shi ", "Zhen ", "You ", "Yun ", "E ", "Bian ", "Guo ", "E ", "Xia ", "Huang ", "Qiu ", "Dao ", "Da ", "Wei ", "Appare ", "Yi ", "Gou ", "Yao ", "Chu ", "Liu ", "Xun ", "Ta ", "Di ", "Chi ", "Yuan ", "Su ", "Ta ", "Qian ", "[?] ", "Yao ", "Guan ", "Zhang ", "Ao ", "Shi ", "Ce ", "Chi ", "Su ", "Zao ", "Zhe ", "Dun ", "Di ", "Lou ", "Chi ", "Cuo ", "Lin ", "Zun ", "Rao ", "Qian ", "Xuan ", "Yu ", "Yi ", "Wu ", "Liao ", "Ju ", "Shi ", "Bi ", "Yao ", "Mai ", "Xie ", "Sui ", "Huan ", "Zhan ", "Teng ", "Er ", "Miao ", "Bian ", "Bian ", "La ", "Li ", "Yuan ", "Yao ", "Luo ", "Li ", "Yi ", "Ting ", "Deng ", "Qi ", "Yong ", "Shan ", "Han ", "Yu ", "Mang ", "Ru ", "Qiong ", "[?] ", "Kuang ", "Fu ", "Kang ", "Bin ", "Fang ", "Xing ", "Na ", "Xin ", "Shen ", "Bang ", "Yuan ", "Cun ", "Huo ", "Xie ", "Bang ", "Wu ", "Ju ", "You ", "Han ", "Tai ", "Qiu ", "Bi ", "Pei ", "Bing ", "Shao ", "Bei ", "Wa ", "Di ", "Zou ", "Ye ", "Lin ", "Kuang ", "Gui ", "Zhu ", "Shi ", "Ku ", "Yu ", "Gai ", "Ge ", "Xi ", "Zhi ", "Ji ", "Xun ", "Hou ", "Xing ", "Jiao ", "Xi ", "Gui ", "Nuo ", "Lang ", "Jia ", "Kuai ", "Zheng ", "Otoko ", "Yun ", "Yan ", "Cheng ", "Dou ", "Chi ", "Lu ", "Fu ", "Wu ", "Fu ", "Gao ", "Hao ", "Lang ", "Jia ", "Geng ", "Jun ", "Ying ", "Bo ", "Xi ", "Bei ", "Li ", "Yun ", "Bu ", "Xiao ", "Qi ", "Pi ", "Qing ", "Guo ", "Zhou ", "Tan ", "Zou ", "Ping ", "Lai ", "Ni ", "Chen ", "You ", "Bu ", "Xiang ", "Dan ", "Ju ", "Yong ", "Qiao ", "Yi ", "Du ", "Yan ", "Mei "];
  }
});

// node_modules/unidecode/data/x91.js
var require_x91 = __commonJS({
  "node_modules/unidecode/data/x91.js"(exports2, module2) {
    module2.exports = ["Ruo ", "Bei ", "E ", "Yu ", "Juan ", "Yu ", "Yun ", "Hou ", "Kui ", "Xiang ", "Xiang ", "Sou ", "Tang ", "Ming ", "Xi ", "Ru ", "Chu ", "Zi ", "Zou ", "Ju ", "Wu ", "Xiang ", "Yun ", "Hao ", "Yong ", "Bi ", "Mo ", "Chao ", "Fu ", "Liao ", "Yin ", "Zhuan ", "Hu ", "Qiao ", "Yan ", "Zhang ", "Fan ", "Qiao ", "Xu ", "Deng ", "Bi ", "Xin ", "Bi ", "Ceng ", "Wei ", "Zheng ", "Mao ", "Shan ", "Lin ", "Po ", "Dan ", "Meng ", "Ye ", "Cao ", "Kuai ", "Feng ", "Meng ", "Zou ", "Kuang ", "Lian ", "Zan ", "Chan ", "You ", "Qi ", "Yan ", "Chan ", "Zan ", "Ling ", "Huan ", "Xi ", "Feng ", "Zan ", "Li ", "You ", "Ding ", "Qiu ", "Zhuo ", "Pei ", "Zhou ", "Yi ", "Hang ", "Yu ", "Jiu ", "Yan ", "Zui ", "Mao ", "Dan ", "Xu ", "Tou ", "Zhen ", "Fen ", "Sakenomoto ", "[?] ", "Yun ", "Tai ", "Tian ", "Qia ", "Tuo ", "Zuo ", "Han ", "Gu ", "Su ", "Po ", "Chou ", "Zai ", "Ming ", "Luo ", "Chuo ", "Chou ", "You ", "Tong ", "Zhi ", "Xian ", "Jiang ", "Cheng ", "Yin ", "Tu ", "Xiao ", "Mei ", "Ku ", "Suan ", "Lei ", "Pu ", "Zui ", "Hai ", "Yan ", "Xi ", "Niang ", "Wei ", "Lu ", "Lan ", "Yan ", "Tao ", "Pei ", "Zhan ", "Chun ", "Tan ", "Zui ", "Chuo ", "Cu ", "Kun ", "Ti ", "Mian ", "Du ", "Hu ", "Xu ", "Xing ", "Tan ", "Jiu ", "Chun ", "Yun ", "Po ", "Ke ", "Sou ", "Mi ", "Quan ", "Chou ", "Cuo ", "Yun ", "Yong ", "Ang ", "Zha ", "Hai ", "Tang ", "Jiang ", "Piao ", "Shan ", "Yu ", "Li ", "Zao ", "Lao ", "Yi ", "Jiang ", "Pu ", "Jiao ", "Xi ", "Tan ", "Po ", "Nong ", "Yi ", "Li ", "Ju ", "Jiao ", "Yi ", "Niang ", "Ru ", "Xun ", "Chou ", "Yan ", "Ling ", "Mi ", "Mi ", "Niang ", "Xin ", "Jiao ", "Xi ", "Mi ", "Yan ", "Bian ", "Cai ", "Shi ", "You ", "Shi ", "Shi ", "Li ", "Zhong ", "Ye ", "Liang ", "Li ", "Jin ", "Jin ", "Qiu ", "Yi ", "Diao ", "Dao ", "Zhao ", "Ding ", "Po ", "Qiu ", "He ", "Fu ", "Zhen ", "Zhi ", "Ba ", "Luan ", "Fu ", "Nai ", "Diao ", "Shan ", "Qiao ", "Kou ", "Chuan ", "Zi ", "Fan ", "Yu ", "Hua ", "Han ", "Gong ", "Qi ", "Mang ", "Ri ", "Di ", "Si ", "Xi ", "Yi ", "Chai ", "Shi ", "Tu ", "Xi ", "Nu ", "Qian ", "Ishiyumi ", "Jian ", "Pi ", "Ye ", "Yin "];
  }
});

// node_modules/unidecode/data/x92.js
var require_x92 = __commonJS({
  "node_modules/unidecode/data/x92.js"(exports2, module2) {
    module2.exports = ["Ba ", "Fang ", "Chen ", "Xing ", "Tou ", "Yue ", "Yan ", "Fu ", "Pi ", "Na ", "Xin ", "E ", "Jue ", "Dun ", "Gou ", "Yin ", "Qian ", "Ban ", "Ji ", "Ren ", "Chao ", "Niu ", "Fen ", "Yun ", "Ji ", "Qin ", "Pi ", "Guo ", "Hong ", "Yin ", "Jun ", "Shi ", "Yi ", "Zhong ", "Nie ", "Gai ", "Ri ", "Huo ", "Tai ", "Kang ", "Habaki ", "Irori ", "Ngaak ", "[?] ", "Duo ", "Zi ", "Ni ", "Tu ", "Shi ", "Min ", "Gu ", "E ", "Ling ", "Bing ", "Yi ", "Gu ", "Ba ", "Pi ", "Yu ", "Si ", "Zuo ", "Bu ", "You ", "Dian ", "Jia ", "Zhen ", "Shi ", "Shi ", "Tie ", "Ju ", "Zhan ", "Shi ", "She ", "Xuan ", "Zhao ", "Bao ", "He ", "Bi ", "Sheng ", "Chu ", "Shi ", "Bo ", "Zhu ", "Chi ", "Za ", "Po ", "Tong ", "Qian ", "Fu ", "Zhai ", "Liu ", "Qian ", "Fu ", "Li ", "Yue ", "Pi ", "Yang ", "Ban ", "Bo ", "Jie ", "Gou ", "Shu ", "Zheng ", "Mu ", "Ni ", "Nie ", "Di ", "Jia ", "Mu ", "Dan ", "Shen ", "Yi ", "Si ", "Kuang ", "Ka ", "Bei ", "Jian ", "Tong ", "Xing ", "Hong ", "Jiao ", "Chi ", "Er ", "Ge ", "Bing ", "Shi ", "Mou ", "Jia ", "Yin ", "Jun ", "Zhou ", "Chong ", "Shang ", "Tong ", "Mo ", "Lei ", "Ji ", "Yu ", "Xu ", "Ren ", "Zun ", "Zhi ", "Qiong ", "Shan ", "Chi ", "Xian ", "Xing ", "Quan ", "Pi ", "Tie ", "Zhu ", "Hou ", "Ming ", "Kua ", "Yao ", "Xian ", "Xian ", "Xiu ", "Jun ", "Cha ", "Lao ", "Ji ", "Pi ", "Ru ", "Mi ", "Yi ", "Yin ", "Guang ", "An ", "Diou ", "You ", "Se ", "Kao ", "Qian ", "Luan ", "Kasugai ", "Ai ", "Diao ", "Han ", "Rui ", "Shi ", "Keng ", "Qiu ", "Xiao ", "Zhe ", "Xiu ", "Zang ", "Ti ", "Cuo ", "Gua ", "Gong ", "Zhong ", "Dou ", "Lu ", "Mei ", "Lang ", "Wan ", "Xin ", "Yun ", "Bei ", "Wu ", "Su ", "Yu ", "Chan ", "Ting ", "Bo ", "Han ", "Jia ", "Hong ", "Cuan ", "Feng ", "Chan ", "Wan ", "Zhi ", "Si ", "Xuan ", "Wu ", "Wu ", "Tiao ", "Gong ", "Zhuo ", "Lue ", "Xing ", "Qian ", "Shen ", "Han ", "Lue ", "Xie ", "Chu ", "Zheng ", "Ju ", "Xian ", "Tie ", "Mang ", "Pu ", "Li ", "Pan ", "Rui ", "Cheng ", "Gao ", "Li ", "Te ", "Pyeng ", "Zhu ", "[?] ", "Tu ", "Liu ", "Zui ", "Ju ", "Chang ", "Yuan ", "Jian ", "Gang ", "Diao ", "Tao ", "Chang "];
  }
});

// node_modules/unidecode/data/x93.js
var require_x93 = __commonJS({
  "node_modules/unidecode/data/x93.js"(exports2, module2) {
    module2.exports = ["Lun ", "Kua ", "Ling ", "Bei ", "Lu ", "Li ", "Qiang ", "Pou ", "Juan ", "Min ", "Zui ", "Peng ", "An ", "Pi ", "Xian ", "Ya ", "Zhui ", "Lei ", "A ", "Kong ", "Ta ", "Kun ", "Du ", "Wei ", "Chui ", "Zi ", "Zheng ", "Ben ", "Nie ", "Cong ", "Qun ", "Tan ", "Ding ", "Qi ", "Qian ", "Zhuo ", "Qi ", "Yu ", "Jin ", "Guan ", "Mao ", "Chang ", "Tian ", "Xi ", "Lian ", "Tao ", "Gu ", "Cuo ", "Shu ", "Zhen ", "Lu ", "Meng ", "Lu ", "Hua ", "Biao ", "Ga ", "Lai ", "Ken ", "Kazari ", "Bu ", "Nai ", "Wan ", "Zan ", "[?] ", "De ", "Xian ", "[?] ", "Huo ", "Liang ", "[?] ", "Men ", "Kai ", "Ying ", "Di ", "Lian ", "Guo ", "Xian ", "Du ", "Tu ", "Wei ", "Cong ", "Fu ", "Rou ", "Ji ", "E ", "Rou ", "Chen ", "Ti ", "Zha ", "Hong ", "Yang ", "Duan ", "Xia ", "Yu ", "Keng ", "Xing ", "Huang ", "Wei ", "Fu ", "Zhao ", "Cha ", "Qie ", "She ", "Hong ", "Kui ", "Tian ", "Mou ", "Qiao ", "Qiao ", "Hou ", "Tou ", "Cong ", "Huan ", "Ye ", "Min ", "Jian ", "Duan ", "Jian ", "Song ", "Kui ", "Hu ", "Xuan ", "Duo ", "Jie ", "Zhen ", "Bian ", "Zhong ", "Zi ", "Xiu ", "Ye ", "Mei ", "Pai ", "Ai ", "Jie ", "[?] ", "Mei ", "Chuo ", "Ta ", "Bang ", "Xia ", "Lian ", "Suo ", "Xi ", "Liu ", "Zu ", "Ye ", "Nou ", "Weng ", "Rong ", "Tang ", "Suo ", "Qiang ", "Ge ", "Shuo ", "Chui ", "Bo ", "Pan ", "Sa ", "Bi ", "Sang ", "Gang ", "Zi ", "Wu ", "Ying ", "Huang ", "Tiao ", "Liu ", "Kai ", "Sun ", "Sha ", "Sou ", "Wan ", "Hao ", "Zhen ", "Zhen ", "Luo ", "Yi ", "Yuan ", "Tang ", "Nie ", "Xi ", "Jia ", "Ge ", "Ma ", "Juan ", "Kasugai ", "Habaki ", "Suo ", "[?] ", "[?] ", "[?] ", "Na ", "Lu ", "Suo ", "Ou ", "Zu ", "Tuan ", "Xiu ", "Guan ", "Xuan ", "Lian ", "Shou ", "Ao ", "Man ", "Mo ", "Luo ", "Bi ", "Wei ", "Liu ", "Di ", "Qiao ", "Cong ", "Yi ", "Lu ", "Ao ", "Keng ", "Qiang ", "Cui ", "Qi ", "Chang ", "Tang ", "Man ", "Yong ", "Chan ", "Feng ", "Jing ", "Biao ", "Shu ", "Lou ", "Xiu ", "Cong ", "Long ", "Zan ", "Jian ", "Cao ", "Li ", "Xia ", "Xi ", "Kang ", "[?] ", "Beng ", "[?] ", "[?] ", "Zheng ", "Lu ", "Hua ", "Ji ", "Pu ", "Hui ", "Qiang ", "Po ", "Lin ", "Suo ", "Xiu ", "San ", "Cheng "];
  }
});

// node_modules/unidecode/data/x94.js
var require_x94 = __commonJS({
  "node_modules/unidecode/data/x94.js"(exports2, module2) {
    module2.exports = ["Kui ", "Si ", "Liu ", "Nao ", "Heng ", "Pie ", "Sui ", "Fan ", "Qiao ", "Quan ", "Yang ", "Tang ", "Xiang ", "Jue ", "Jiao ", "Zun ", "Liao ", "Jie ", "Lao ", "Dui ", "Tan ", "Zan ", "Ji ", "Jian ", "Zhong ", "Deng ", "Ya ", "Ying ", "Dui ", "Jue ", "Nou ", "Ti ", "Pu ", "Tie ", "[?] ", "[?] ", "Ding ", "Shan ", "Kai ", "Jian ", "Fei ", "Sui ", "Lu ", "Juan ", "Hui ", "Yu ", "Lian ", "Zhuo ", "Qiao ", "Qian ", "Zhuo ", "Lei ", "Bi ", "Tie ", "Huan ", "Ye ", "Duo ", "Guo ", "Dang ", "Ju ", "Fen ", "Da ", "Bei ", "Yi ", "Ai ", "Zong ", "Xun ", "Diao ", "Zhu ", "Heng ", "Zhui ", "Ji ", "Nie ", "Ta ", "Huo ", "Qing ", "Bin ", "Ying ", "Kui ", "Ning ", "Xu ", "Jian ", "Jian ", "Yari ", "Cha ", "Zhi ", "Mie ", "Li ", "Lei ", "Ji ", "Zuan ", "Kuang ", "Shang ", "Peng ", "La ", "Du ", "Shuo ", "Chuo ", "Lu ", "Biao ", "Bao ", "Lu ", "[?] ", "[?] ", "Long ", "E ", "Lu ", "Xin ", "Jian ", "Lan ", "Bo ", "Jian ", "Yao ", "Chan ", "Xiang ", "Jian ", "Xi ", "Guan ", "Cang ", "Nie ", "Lei ", "Cuan ", "Qu ", "Pan ", "Luo ", "Zuan ", "Luan ", "Zao ", "Nie ", "Jue ", "Tang ", "Shu ", "Lan ", "Jin ", "Qiu ", "Yi ", "Zhen ", "Ding ", "Zhao ", "Po ", "Diao ", "Tu ", "Qian ", "Chuan ", "Shan ", "Ji ", "Fan ", "Diao ", "Men ", "Nu ", "Xi ", "Chai ", "Xing ", "Gai ", "Bu ", "Tai ", "Ju ", "Dun ", "Chao ", "Zhong ", "Na ", "Bei ", "Gang ", "Ban ", "Qian ", "Yao ", "Qin ", "Jun ", "Wu ", "Gou ", "Kang ", "Fang ", "Huo ", "Tou ", "Niu ", "Ba ", "Yu ", "Qian ", "Zheng ", "Qian ", "Gu ", "Bo ", "E ", "Po ", "Bu ", "Ba ", "Yue ", "Zuan ", "Mu ", "Dan ", "Jia ", "Dian ", "You ", "Tie ", "Bo ", "Ling ", "Shuo ", "Qian ", "Liu ", "Bao ", "Shi ", "Xuan ", "She ", "Bi ", "Ni ", "Pi ", "Duo ", "Xing ", "Kao ", "Lao ", "Er ", "Mang ", "Ya ", "You ", "Cheng ", "Jia ", "Ye ", "Nao ", "Zhi ", "Dang ", "Tong ", "Lu ", "Diao ", "Yin ", "Kai ", "Zha ", "Zhu ", "Xian ", "Ting ", "Diu ", "Xian ", "Hua ", "Quan ", "Sha ", "Jia ", "Yao ", "Ge ", "Ming ", "Zheng ", "Se ", "Jiao ", "Yi ", "Chan ", "Chong ", "Tang ", "An ", "Yin ", "Ru ", "Zhu ", "Lao ", "Pu ", "Wu ", "Lai ", "Te ", "Lian ", "Keng "];
  }
});

// node_modules/unidecode/data/x95.js
var require_x95 = __commonJS({
  "node_modules/unidecode/data/x95.js"(exports2, module2) {
    module2.exports = ["Xiao ", "Suo ", "Li ", "Zheng ", "Chu ", "Guo ", "Gao ", "Tie ", "Xiu ", "Cuo ", "Lue ", "Feng ", "Xin ", "Liu ", "Kai ", "Jian ", "Rui ", "Ti ", "Lang ", "Qian ", "Ju ", "A ", "Qiang ", "Duo ", "Tian ", "Cuo ", "Mao ", "Ben ", "Qi ", "De ", "Kua ", "Kun ", "Chang ", "Xi ", "Gu ", "Luo ", "Chui ", "Zhui ", "Jin ", "Zhi ", "Xian ", "Juan ", "Huo ", "Pou ", "Tan ", "Ding ", "Jian ", "Ju ", "Meng ", "Zi ", "Qie ", "Ying ", "Kai ", "Qiang ", "Song ", "E ", "Cha ", "Qiao ", "Zhong ", "Duan ", "Sou ", "Huang ", "Huan ", "Ai ", "Du ", "Mei ", "Lou ", "Zi ", "Fei ", "Mei ", "Mo ", "Zhen ", "Bo ", "Ge ", "Nie ", "Tang ", "Juan ", "Nie ", "Na ", "Liu ", "Hao ", "Bang ", "Yi ", "Jia ", "Bin ", "Rong ", "Biao ", "Tang ", "Man ", "Luo ", "Beng ", "Yong ", "Jing ", "Di ", "Zu ", "Xuan ", "Liu ", "Tan ", "Jue ", "Liao ", "Pu ", "Lu ", "Dui ", "Lan ", "Pu ", "Cuan ", "Qiang ", "Deng ", "Huo ", "Lei ", "Huan ", "Zhuo ", "Lian ", "Yi ", "Cha ", "Biao ", "La ", "Chan ", "Xiang ", "Chang ", "Chang ", "Jiu ", "Ao ", "Die ", "Qu ", "Liao ", "Mi ", "Chang ", "Men ", "Ma ", "Shuan ", "Shan ", "Huo ", "Men ", "Yan ", "Bi ", "Han ", "Bi ", "San ", "Kai ", "Kang ", "Beng ", "Hong ", "Run ", "San ", "Xian ", "Xian ", "Jian ", "Min ", "Xia ", "Yuru ", "Dou ", "Zha ", "Nao ", "Jian ", "Peng ", "Xia ", "Ling ", "Bian ", "Bi ", "Run ", "He ", "Guan ", "Ge ", "Ge ", "Fa ", "Chu ", "Hong ", "Gui ", "Min ", "Se ", "Kun ", "Lang ", "Lu ", "Ting ", "Sha ", "Ju ", "Yue ", "Yue ", "Chan ", "Qu ", "Lin ", "Chang ", "Shai ", "Kun ", "Yan ", "Min ", "Yan ", "E ", "Hun ", "Yu ", "Wen ", "Xiang ", "Bao ", "Xiang ", "Qu ", "Yao ", "Wen ", "Ban ", "An ", "Wei ", "Yin ", "Kuo ", "Que ", "Lan ", "Du ", "[?] ", "Phwung ", "Tian ", "Nie ", "Ta ", "Kai ", "He ", "Que ", "Chuang ", "Guan ", "Dou ", "Qi ", "Kui ", "Tang ", "Guan ", "Piao ", "Kan ", "Xi ", "Hui ", "Chan ", "Pi ", "Dang ", "Huan ", "Ta ", "Wen ", "[?] ", "Men ", "Shuan ", "Shan ", "Yan ", "Han ", "Bi ", "Wen ", "Chuang ", "Run ", "Wei ", "Xian ", "Hong ", "Jian ", "Min ", "Kang ", "Men ", "Zha ", "Nao ", "Gui ", "Wen ", "Ta ", "Min ", "Lu ", "Kai "];
  }
});

// node_modules/unidecode/data/x96.js
var require_x96 = __commonJS({
  "node_modules/unidecode/data/x96.js"(exports2, module2) {
    module2.exports = ["Fa ", "Ge ", "He ", "Kun ", "Jiu ", "Yue ", "Lang ", "Du ", "Yu ", "Yan ", "Chang ", "Xi ", "Wen ", "Hun ", "Yan ", "E ", "Chan ", "Lan ", "Qu ", "Hui ", "Kuo ", "Que ", "Ge ", "Tian ", "Ta ", "Que ", "Kan ", "Huan ", "Fu ", "Fu ", "Le ", "Dui ", "Xin ", "Qian ", "Wu ", "Yi ", "Tuo ", "Yin ", "Yang ", "Dou ", "E ", "Sheng ", "Ban ", "Pei ", "Keng ", "Yun ", "Ruan ", "Zhi ", "Pi ", "Jing ", "Fang ", "Yang ", "Yin ", "Zhen ", "Jie ", "Cheng ", "E ", "Qu ", "Di ", "Zu ", "Zuo ", "Dian ", "Ling ", "A ", "Tuo ", "Tuo ", "Po ", "Bing ", "Fu ", "Ji ", "Lu ", "Long ", "Chen ", "Xing ", "Duo ", "Lou ", "Mo ", "Jiang ", "Shu ", "Duo ", "Xian ", "Er ", "Gui ", "Yu ", "Gai ", "Shan ", "Xun ", "Qiao ", "Xing ", "Chun ", "Fu ", "Bi ", "Xia ", "Shan ", "Sheng ", "Zhi ", "Pu ", "Dou ", "Yuan ", "Zhen ", "Chu ", "Xian ", "Tou ", "Nie ", "Yun ", "Xian ", "Pei ", "Pei ", "Zou ", "Yi ", "Dui ", "Lun ", "Yin ", "Ju ", "Chui ", "Chen ", "Pi ", "Ling ", "Tao ", "Xian ", "Lu ", "Sheng ", "Xian ", "Yin ", "Zhu ", "Yang ", "Reng ", "Shan ", "Chong ", "Yan ", "Yin ", "Yu ", "Ti ", "Yu ", "Long ", "Wei ", "Wei ", "Nie ", "Dui ", "Sui ", "An ", "Huang ", "Jie ", "Sui ", "Yin ", "Gai ", "Yan ", "Hui ", "Ge ", "Yun ", "Wu ", "Wei ", "Ai ", "Xi ", "Tang ", "Ji ", "Zhang ", "Dao ", "Ao ", "Xi ", "Yin ", "[?] ", "Rao ", "Lin ", "Tui ", "Deng ", "Pi ", "Sui ", "Sui ", "Yu ", "Xian ", "Fen ", "Ni ", "Er ", "Ji ", "Dao ", "Xi ", "Yin ", "E ", "Hui ", "Long ", "Xi ", "Li ", "Li ", "Li ", "Zhui ", "He ", "Zhi ", "Zhun ", "Jun ", "Nan ", "Yi ", "Que ", "Yan ", "Qian ", "Ya ", "Xiong ", "Ya ", "Ji ", "Gu ", "Huan ", "Zhi ", "Gou ", "Jun ", "Ci ", "Yong ", "Ju ", "Chu ", "Hu ", "Za ", "Luo ", "Yu ", "Chou ", "Diao ", "Sui ", "Han ", "Huo ", "Shuang ", "Guan ", "Chu ", "Za ", "Yong ", "Ji ", "Xi ", "Chou ", "Liu ", "Li ", "Nan ", "Xue ", "Za ", "Ji ", "Ji ", "Yu ", "Yu ", "Xue ", "Na ", "Fou ", "Se ", "Mu ", "Wen ", "Fen ", "Pang ", "Yun ", "Li ", "Li ", "Ang ", "Ling ", "Lei ", "An ", "Bao ", "Meng ", "Dian ", "Dang ", "Xing ", "Wu ", "Zhao "];
  }
});

// node_modules/unidecode/data/x97.js
var require_x97 = __commonJS({
  "node_modules/unidecode/data/x97.js"(exports2, module2) {
    module2.exports = ["Xu ", "Ji ", "Mu ", "Chen ", "Xiao ", "Zha ", "Ting ", "Zhen ", "Pei ", "Mei ", "Ling ", "Qi ", "Chou ", "Huo ", "Sha ", "Fei ", "Weng ", "Zhan ", "Yin ", "Ni ", "Chou ", "Tun ", "Lin ", "[?] ", "Dong ", "Ying ", "Wu ", "Ling ", "Shuang ", "Ling ", "Xia ", "Hong ", "Yin ", "Mo ", "Mai ", "Yun ", "Liu ", "Meng ", "Bin ", "Wu ", "Wei ", "Huo ", "Yin ", "Xi ", "Yi ", "Ai ", "Dan ", "Deng ", "Xian ", "Yu ", "Lu ", "Long ", "Dai ", "Ji ", "Pang ", "Yang ", "Ba ", "Pi ", "Wei ", "[?] ", "Xi ", "Ji ", "Mai ", "Meng ", "Meng ", "Lei ", "Li ", "Huo ", "Ai ", "Fei ", "Dai ", "Long ", "Ling ", "Ai ", "Feng ", "Li ", "Bao ", "[?] ", "He ", "He ", "Bing ", "Qing ", "Qing ", "Jing ", "Tian ", "Zhen ", "Jing ", "Cheng ", "Qing ", "Jing ", "Jing ", "Dian ", "Jing ", "Tian ", "Fei ", "Fei ", "Kao ", "Mi ", "Mian ", "Mian ", "Pao ", "Ye ", "Tian ", "Hui ", "Ye ", "Ge ", "Ding ", "Cha ", "Jian ", "Ren ", "Di ", "Du ", "Wu ", "Ren ", "Qin ", "Jin ", "Xue ", "Niu ", "Ba ", "Yin ", "Sa ", "Na ", "Mo ", "Zu ", "Da ", "Ban ", "Yi ", "Yao ", "Tao ", "Tuo ", "Jia ", "Hong ", "Pao ", "Yang ", "Tomo ", "Yin ", "Jia ", "Tao ", "Ji ", "Xie ", "An ", "An ", "Hen ", "Gong ", "Kohaze ", "Da ", "Qiao ", "Ting ", "Wan ", "Ying ", "Sui ", "Tiao ", "Qiao ", "Xuan ", "Kong ", "Beng ", "Ta ", "Zhang ", "Bing ", "Kuo ", "Ju ", "La ", "Xie ", "Rou ", "Bang ", "Yi ", "Qiu ", "Qiu ", "He ", "Xiao ", "Mu ", "Ju ", "Jian ", "Bian ", "Di ", "Jian ", "On ", "Tao ", "Gou ", "Ta ", "Bei ", "Xie ", "Pan ", "Ge ", "Bi ", "Kuo ", "Tang ", "Lou ", "Gui ", "Qiao ", "Xue ", "Ji ", "Jian ", "Jiang ", "Chan ", "Da ", "Huo ", "Xian ", "Qian ", "Du ", "Wa ", "Jian ", "Lan ", "Wei ", "Ren ", "Fu ", "Mei ", "Juan ", "Ge ", "Wei ", "Qiao ", "Han ", "Chang ", "[?] ", "Rou ", "Xun ", "She ", "Wei ", "Ge ", "Bei ", "Tao ", "Gou ", "Yun ", "[?] ", "Bi ", "Wei ", "Hui ", "Du ", "Wa ", "Du ", "Wei ", "Ren ", "Fu ", "Han ", "Wei ", "Yun ", "Tao ", "Jiu ", "Jiu ", "Xian ", "Xie ", "Xian ", "Ji ", "Yin ", "Za ", "Yun ", "Shao ", "Le ", "Peng ", "Heng ", "Ying ", "Yun ", "Peng ", "Yin ", "Yin ", "Xiang "];
  }
});

// node_modules/unidecode/data/x98.js
var require_x98 = __commonJS({
  "node_modules/unidecode/data/x98.js"(exports2, module2) {
    module2.exports = ["Hu ", "Ye ", "Ding ", "Qing ", "Pan ", "Xiang ", "Shun ", "Han ", "Xu ", "Yi ", "Xu ", "Gu ", "Song ", "Kui ", "Qi ", "Hang ", "Yu ", "Wan ", "Ban ", "Dun ", "Di ", "Dan ", "Pan ", "Po ", "Ling ", "Ce ", "Jing ", "Lei ", "He ", "Qiao ", "E ", "E ", "Wei ", "Jie ", "Gua ", "Shen ", "Yi ", "Shen ", "Hai ", "Dui ", "Pian ", "Ping ", "Lei ", "Fu ", "Jia ", "Tou ", "Hui ", "Kui ", "Jia ", "Le ", "Tian ", "Cheng ", "Ying ", "Jun ", "Hu ", "Han ", "Jing ", "Tui ", "Tui ", "Pin ", "Lai ", "Tui ", "Zi ", "Zi ", "Chui ", "Ding ", "Lai ", "Yan ", "Han ", "Jian ", "Ke ", "Cui ", "Jiong ", "Qin ", "Yi ", "Sai ", "Ti ", "E ", "E ", "Yan ", "Hun ", "Kan ", "Yong ", "Zhuan ", "Yan ", "Xian ", "Xin ", "Yi ", "Yuan ", "Sang ", "Dian ", "Dian ", "Jiang ", "Ku ", "Lei ", "Liao ", "Piao ", "Yi ", "Man ", "Qi ", "Rao ", "Hao ", "Qiao ", "Gu ", "Xun ", "Qian ", "Hui ", "Zhan ", "Ru ", "Hong ", "Bin ", "Xian ", "Pin ", "Lu ", "Lan ", "Nie ", "Quan ", "Ye ", "Ding ", "Qing ", "Han ", "Xiang ", "Shun ", "Xu ", "Xu ", "Wan ", "Gu ", "Dun ", "Qi ", "Ban ", "Song ", "Hang ", "Yu ", "Lu ", "Ling ", "Po ", "Jing ", "Jie ", "Jia ", "Tian ", "Han ", "Ying ", "Jiong ", "Hai ", "Yi ", "Pin ", "Hui ", "Tui ", "Han ", "Ying ", "Ying ", "Ke ", "Ti ", "Yong ", "E ", "Zhuan ", "Yan ", "E ", "Nie ", "Man ", "Dian ", "Sang ", "Hao ", "Lei ", "Zhan ", "Ru ", "Pin ", "Quan ", "Feng ", "Biao ", "Oroshi ", "Fu ", "Xia ", "Zhan ", "Biao ", "Sa ", "Ba ", "Tai ", "Lie ", "Gua ", "Xuan ", "Shao ", "Ju ", "Bi ", "Si ", "Wei ", "Yang ", "Yao ", "Sou ", "Kai ", "Sao ", "Fan ", "Liu ", "Xi ", "Liao ", "Piao ", "Piao ", "Liu ", "Biao ", "Biao ", "Biao ", "Liao ", "[?] ", "Se ", "Feng ", "Biao ", "Feng ", "Yang ", "Zhan ", "Biao ", "Sa ", "Ju ", "Si ", "Sou ", "Yao ", "Liu ", "Piao ", "Biao ", "Biao ", "Fei ", "Fan ", "Fei ", "Fei ", "Shi ", "Shi ", "Can ", "Ji ", "Ding ", "Si ", "Tuo ", "Zhan ", "Sun ", "Xiang ", "Tun ", "Ren ", "Yu ", "Juan ", "Chi ", "Yin ", "Fan ", "Fan ", "Sun ", "Yin ", "Zhu ", "Yi ", "Zhai ", "Bi ", "Jie ", "Tao ", "Liu ", "Ci ", "Tie ", "Si ", "Bao ", "Shi ", "Duo "];
  }
});

// node_modules/unidecode/data/x99.js
var require_x99 = __commonJS({
  "node_modules/unidecode/data/x99.js"(exports2, module2) {
    module2.exports = ["Hai ", "Ren ", "Tian ", "Jiao ", "Jia ", "Bing ", "Yao ", "Tong ", "Ci ", "Xiang ", "Yang ", "Yang ", "Er ", "Yan ", "Le ", "Yi ", "Can ", "Bo ", "Nei ", "E ", "Bu ", "Jun ", "Dou ", "Su ", "Yu ", "Shi ", "Yao ", "Hun ", "Guo ", "Shi ", "Jian ", "Zhui ", "Bing ", "Xian ", "Bu ", "Ye ", "Tan ", "Fei ", "Zhang ", "Wei ", "Guan ", "E ", "Nuan ", "Hun ", "Hu ", "Huang ", "Tie ", "Hui ", "Jian ", "Hou ", "He ", "Xing ", "Fen ", "Wei ", "Gu ", "Cha ", "Song ", "Tang ", "Bo ", "Gao ", "Xi ", "Kui ", "Liu ", "Sou ", "Tao ", "Ye ", "Yun ", "Mo ", "Tang ", "Man ", "Bi ", "Yu ", "Xiu ", "Jin ", "San ", "Kui ", "Zhuan ", "Shan ", "Chi ", "Dan ", "Yi ", "Ji ", "Rao ", "Cheng ", "Yong ", "Tao ", "Hui ", "Xiang ", "Zhan ", "Fen ", "Hai ", "Meng ", "Yan ", "Mo ", "Chan ", "Xiang ", "Luo ", "Zuan ", "Nang ", "Shi ", "Ding ", "Ji ", "Tuo ", "Xing ", "Tun ", "Xi ", "Ren ", "Yu ", "Chi ", "Fan ", "Yin ", "Jian ", "Shi ", "Bao ", "Si ", "Duo ", "Yi ", "Er ", "Rao ", "Xiang ", "Jia ", "Le ", "Jiao ", "Yi ", "Bing ", "Bo ", "Dou ", "E ", "Yu ", "Nei ", "Jun ", "Guo ", "Hun ", "Xian ", "Guan ", "Cha ", "Kui ", "Gu ", "Sou ", "Chan ", "Ye ", "Mo ", "Bo ", "Liu ", "Xiu ", "Jin ", "Man ", "San ", "Zhuan ", "Nang ", "Shou ", "Kui ", "Guo ", "Xiang ", "Fen ", "Ba ", "Ni ", "Bi ", "Bo ", "Tu ", "Han ", "Fei ", "Jian ", "An ", "Ai ", "Fu ", "Xian ", "Wen ", "Xin ", "Fen ", "Bin ", "Xing ", "Ma ", "Yu ", "Feng ", "Han ", "Di ", "Tuo ", "Tuo ", "Chi ", "Xun ", "Zhu ", "Zhi ", "Pei ", "Xin ", "Ri ", "Sa ", "Yin ", "Wen ", "Zhi ", "Dan ", "Lu ", "You ", "Bo ", "Bao ", "Kuai ", "Tuo ", "Yi ", "Qu ", "[?] ", "Qu ", "Jiong ", "Bo ", "Zhao ", "Yuan ", "Peng ", "Zhou ", "Ju ", "Zhu ", "Nu ", "Ju ", "Pi ", "Zang ", "Jia ", "Ling ", "Zhen ", "Tai ", "Fu ", "Yang ", "Shi ", "Bi ", "Tuo ", "Tuo ", "Si ", "Liu ", "Ma ", "Pian ", "Tao ", "Zhi ", "Rong ", "Teng ", "Dong ", "Xun ", "Quan ", "Shen ", "Jiong ", "Er ", "Hai ", "Bo ", "Zhu ", "Yin ", "Luo ", "Shuu ", "Dan ", "Xie ", "Liu ", "Ju ", "Song ", "Qin ", "Mang ", "Liang ", "Han ", "Tu ", "Xuan ", "Tui ", "Jun "];
  }
});

// node_modules/unidecode/data/x9a.js
var require_x9a = __commonJS({
  "node_modules/unidecode/data/x9a.js"(exports2, module2) {
    module2.exports = ["E ", "Cheng ", "Xin ", "Ai ", "Lu ", "Zhui ", "Zhou ", "She ", "Pian ", "Kun ", "Tao ", "Lai ", "Zong ", "Ke ", "Qi ", "Qi ", "Yan ", "Fei ", "Sao ", "Yan ", "Jie ", "Yao ", "Wu ", "Pian ", "Cong ", "Pian ", "Qian ", "Fei ", "Huang ", "Jian ", "Huo ", "Yu ", "Ti ", "Quan ", "Xia ", "Zong ", "Kui ", "Rou ", "Si ", "Gua ", "Tuo ", "Kui ", "Sou ", "Qian ", "Cheng ", "Zhi ", "Liu ", "Pang ", "Teng ", "Xi ", "Cao ", "Du ", "Yan ", "Yuan ", "Zou ", "Sao ", "Shan ", "Li ", "Zhi ", "Shuang ", "Lu ", "Xi ", "Luo ", "Zhang ", "Mo ", "Ao ", "Can ", "Piao ", "Cong ", "Qu ", "Bi ", "Zhi ", "Yu ", "Xu ", "Hua ", "Bo ", "Su ", "Xiao ", "Lin ", "Chan ", "Dun ", "Liu ", "Tuo ", "Zeng ", "Tan ", "Jiao ", "Tie ", "Yan ", "Luo ", "Zhan ", "Jing ", "Yi ", "Ye ", "Tuo ", "Bin ", "Zou ", "Yan ", "Peng ", "Lu ", "Teng ", "Xiang ", "Ji ", "Shuang ", "Ju ", "Xi ", "Huan ", "Li ", "Biao ", "Ma ", "Yu ", "Tuo ", "Xun ", "Chi ", "Qu ", "Ri ", "Bo ", "Lu ", "Zang ", "Shi ", "Si ", "Fu ", "Ju ", "Zou ", "Zhu ", "Tuo ", "Nu ", "Jia ", "Yi ", "Tai ", "Xiao ", "Ma ", "Yin ", "Jiao ", "Hua ", "Luo ", "Hai ", "Pian ", "Biao ", "Li ", "Cheng ", "Yan ", "Xin ", "Qin ", "Jun ", "Qi ", "Qi ", "Ke ", "Zhui ", "Zong ", "Su ", "Can ", "Pian ", "Zhi ", "Kui ", "Sao ", "Wu ", "Ao ", "Liu ", "Qian ", "Shan ", "Piao ", "Luo ", "Cong ", "Chan ", "Zou ", "Ji ", "Shuang ", "Xiang ", "Gu ", "Wei ", "Wei ", "Wei ", "Yu ", "Gan ", "Yi ", "Ang ", "Tou ", "Xie ", "Bao ", "Bi ", "Chi ", "Ti ", "Di ", "Ku ", "Hai ", "Qiao ", "Gou ", "Kua ", "Ge ", "Tui ", "Geng ", "Pian ", "Bi ", "Ke ", "Ka ", "Yu ", "Sui ", "Lou ", "Bo ", "Xiao ", "Pang ", "Bo ", "Ci ", "Kuan ", "Bin ", "Mo ", "Liao ", "Lou ", "Nao ", "Du ", "Zang ", "Sui ", "Ti ", "Bin ", "Kuan ", "Lu ", "Gao ", "Gao ", "Qiao ", "Kao ", "Qiao ", "Lao ", "Zao ", "Biao ", "Kun ", "Kun ", "Ti ", "Fang ", "Xiu ", "Ran ", "Mao ", "Dan ", "Kun ", "Bin ", "Fa ", "Tiao ", "Peng ", "Zi ", "Fa ", "Ran ", "Ti ", "Pao ", "Pi ", "Mao ", "Fu ", "Er ", "Rong ", "Qu ", "Gong ", "Xiu ", "Gua ", "Ji ", "Peng ", "Zhua ", "Shao ", "Sha "];
  }
});

// node_modules/unidecode/data/x9b.js
var require_x9b = __commonJS({
  "node_modules/unidecode/data/x9b.js"(exports2, module2) {
    module2.exports = ["Ti ", "Li ", "Bin ", "Zong ", "Ti ", "Peng ", "Song ", "Zheng ", "Quan ", "Zong ", "Shun ", "Jian ", "Duo ", "Hu ", "La ", "Jiu ", "Qi ", "Lian ", "Zhen ", "Bin ", "Peng ", "Mo ", "San ", "Man ", "Man ", "Seng ", "Xu ", "Lie ", "Qian ", "Qian ", "Nong ", "Huan ", "Kuai ", "Ning ", "Bin ", "Lie ", "Rang ", "Dou ", "Dou ", "Nao ", "Hong ", "Xi ", "Dou ", "Han ", "Dou ", "Dou ", "Jiu ", "Chang ", "Yu ", "Yu ", "Li ", "Juan ", "Fu ", "Qian ", "Gui ", "Zong ", "Liu ", "Gui ", "Shang ", "Yu ", "Gui ", "Mei ", "Ji ", "Qi ", "Jie ", "Kui ", "Hun ", "Ba ", "Po ", "Mei ", "Xu ", "Yan ", "Xiao ", "Liang ", "Yu ", "Tui ", "Qi ", "Wang ", "Liang ", "Wei ", "Jian ", "Chi ", "Piao ", "Bi ", "Mo ", "Ji ", "Xu ", "Chou ", "Yan ", "Zhan ", "Yu ", "Dao ", "Ren ", "Ji ", "Eri ", "Gong ", "Tuo ", "Diao ", "Ji ", "Xu ", "E ", "E ", "Sha ", "Hang ", "Tun ", "Mo ", "Jie ", "Shen ", "Fan ", "Yuan ", "Bi ", "Lu ", "Wen ", "Hu ", "Lu ", "Za ", "Fang ", "Fen ", "Na ", "You ", "Namazu ", "Todo ", "He ", "Xia ", "Qu ", "Han ", "Pi ", "Ling ", "Tuo ", "Bo ", "Qiu ", "Ping ", "Fu ", "Bi ", "Ji ", "Wei ", "Ju ", "Diao ", "Bo ", "You ", "Gun ", "Pi ", "Nian ", "Xing ", "Tai ", "Bao ", "Fu ", "Zha ", "Ju ", "Gu ", "Kajika ", "Tong ", "[?] ", "Ta ", "Jie ", "Shu ", "Hou ", "Xiang ", "Er ", "An ", "Wei ", "Tiao ", "Zhu ", "Yin ", "Lie ", "Luo ", "Tong ", "Yi ", "Qi ", "Bing ", "Wei ", "Jiao ", "Bu ", "Gui ", "Xian ", "Ge ", "Hui ", "Bora ", "Mate ", "Kao ", "Gori ", "Duo ", "Jun ", "Ti ", "Man ", "Xiao ", "Za ", "Sha ", "Qin ", "Yu ", "Nei ", "Zhe ", "Gun ", "Geng ", "Su ", "Wu ", "Qiu ", "Ting ", "Fu ", "Wan ", "You ", "Li ", "Sha ", "Sha ", "Gao ", "Meng ", "Ugui ", "Asari ", "Subashiri ", "Kazunoko ", "Yong ", "Ni ", "Zi ", "Qi ", "Qing ", "Xiang ", "Nei ", "Chun ", "Ji ", "Diao ", "Qie ", "Gu ", "Zhou ", "Dong ", "Lai ", "Fei ", "Ni ", "Yi ", "Kun ", "Lu ", "Jiu ", "Chang ", "Jing ", "Lun ", "Ling ", "Zou ", "Li ", "Meng ", "Zong ", "Zhi ", "Nian ", "Shachi ", "Dojou ", "Sukesou ", "Shi ", "Shen ", "Hun ", "Shi ", "Hou ", "Xing ", "Zhu ", "La ", "Zong ", "Ji ", "Bian ", "Bian "];
  }
});

// node_modules/unidecode/data/x9c.js
var require_x9c = __commonJS({
  "node_modules/unidecode/data/x9c.js"(exports2, module2) {
    module2.exports = ["Huan ", "Quan ", "Ze ", "Wei ", "Wei ", "Yu ", "Qun ", "Rou ", "Die ", "Huang ", "Lian ", "Yan ", "Qiu ", "Qiu ", "Jian ", "Bi ", "E ", "Yang ", "Fu ", "Sai ", "Jian ", "Xia ", "Tuo ", "Hu ", "Muroaji ", "Ruo ", "Haraka ", "Wen ", "Jian ", "Hao ", "Wu ", "Fang ", "Sao ", "Liu ", "Ma ", "Shi ", "Shi ", "Yin ", "Z ", "Teng ", "Ta ", "Yao ", "Ge ", "Rong ", "Qian ", "Qi ", "Wen ", "Ruo ", "Hatahata ", "Lian ", "Ao ", "Le ", "Hui ", "Min ", "Ji ", "Tiao ", "Qu ", "Jian ", "Sao ", "Man ", "Xi ", "Qiu ", "Biao ", "Ji ", "Ji ", "Zhu ", "Jiang ", "Qiu ", "Zhuan ", "Yong ", "Zhang ", "Kang ", "Xue ", "Bie ", "Jue ", "Qu ", "Xiang ", "Bo ", "Jiao ", "Xun ", "Su ", "Huang ", "Zun ", "Shan ", "Shan ", "Fan ", "Jue ", "Lin ", "Xun ", "Miao ", "Xi ", "Eso ", "Kyou ", "Fen ", "Guan ", "Hou ", "Kuai ", "Zei ", "Sao ", "Zhan ", "Gan ", "Gui ", "Sheng ", "Li ", "Chang ", "Hatahata ", "Shiira ", "Mutsu ", "Ru ", "Ji ", "Xu ", "Huo ", "Shiira ", "Li ", "Lie ", "Li ", "Mie ", "Zhen ", "Xiang ", "E ", "Lu ", "Guan ", "Li ", "Xian ", "Yu ", "Dao ", "Ji ", "You ", "Tun ", "Lu ", "Fang ", "Ba ", "He ", "Bo ", "Ping ", "Nian ", "Lu ", "You ", "Zha ", "Fu ", "Bo ", "Bao ", "Hou ", "Pi ", "Tai ", "Gui ", "Jie ", "Kao ", "Wei ", "Er ", "Tong ", "Ze ", "Hou ", "Kuai ", "Ji ", "Jiao ", "Xian ", "Za ", "Xiang ", "Xun ", "Geng ", "Li ", "Lian ", "Jian ", "Li ", "Shi ", "Tiao ", "Gun ", "Sha ", "Wan ", "Jun ", "Ji ", "Yong ", "Qing ", "Ling ", "Qi ", "Zou ", "Fei ", "Kun ", "Chang ", "Gu ", "Ni ", "Nian ", "Diao ", "Jing ", "Shen ", "Shi ", "Zi ", "Fen ", "Die ", "Bi ", "Chang ", "Shi ", "Wen ", "Wei ", "Sai ", "E ", "Qiu ", "Fu ", "Huang ", "Quan ", "Jiang ", "Bian ", "Sao ", "Ao ", "Qi ", "Ta ", "Yin ", "Yao ", "Fang ", "Jian ", "Le ", "Biao ", "Xue ", "Bie ", "Man ", "Min ", "Yong ", "Wei ", "Xi ", "Jue ", "Shan ", "Lin ", "Zun ", "Huo ", "Gan ", "Li ", "Zhan ", "Guan ", "Niao ", "Yi ", "Fu ", "Li ", "Jiu ", "Bu ", "Yan ", "Fu ", "Diao ", "Ji ", "Feng ", "Nio ", "Gan ", "Shi ", "Feng ", "Ming ", "Bao ", "Yuan ", "Zhi ", "Hu ", "Qin ", "Fu ", "Fen ", "Wen ", "Jian ", "Shi ", "Yu "];
  }
});

// node_modules/unidecode/data/x9d.js
var require_x9d = __commonJS({
  "node_modules/unidecode/data/x9d.js"(exports2, module2) {
    module2.exports = ["Fou ", "Yiao ", "Jue ", "Jue ", "Pi ", "Huan ", "Zhen ", "Bao ", "Yan ", "Ya ", "Zheng ", "Fang ", "Feng ", "Wen ", "Ou ", "Te ", "Jia ", "Nu ", "Ling ", "Mie ", "Fu ", "Tuo ", "Wen ", "Li ", "Bian ", "Zhi ", "Ge ", "Yuan ", "Zi ", "Qu ", "Xiao ", "Zhi ", "Dan ", "Ju ", "You ", "Gu ", "Zhong ", "Yu ", "Yang ", "Rong ", "Ya ", "Tie ", "Yu ", "Shigi ", "Ying ", "Zhui ", "Wu ", "Er ", "Gua ", "Ai ", "Zhi ", "Yan ", "Heng ", "Jiao ", "Ji ", "Lie ", "Zhu ", "Ren ", "Yi ", "Hong ", "Luo ", "Ru ", "Mou ", "Ge ", "Ren ", "Jiao ", "Xiu ", "Zhou ", "Zhi ", "Luo ", "Chidori ", "Toki ", "Ten ", "Luan ", "Jia ", "Ji ", "Yu ", "Huan ", "Tuo ", "Bu ", "Wu ", "Juan ", "Yu ", "Bo ", "Xun ", "Xun ", "Bi ", "Xi ", "Jun ", "Ju ", "Tu ", "Jing ", "Ti ", "E ", "E ", "Kuang ", "Hu ", "Wu ", "Shen ", "Lai ", "Ikaruga ", "Kakesu ", "Lu ", "Ping ", "Shu ", "Fu ", "An ", "Zhao ", "Peng ", "Qin ", "Qian ", "Bei ", "Diao ", "Lu ", "Que ", "Jian ", "Ju ", "Tu ", "Ya ", "Yuan ", "Qi ", "Li ", "Ye ", "Zhui ", "Kong ", "Zhui ", "Kun ", "Sheng ", "Qi ", "Jing ", "Yi ", "Yi ", "Jing ", "Zi ", "Lai ", "Dong ", "Qi ", "Chun ", "Geng ", "Ju ", "Qu ", "Isuka ", "Kikuitadaki ", "Ji ", "Shu ", "[?] ", "Chi ", "Miao ", "Rou ", "An ", "Qiu ", "Ti ", "Hu ", "Ti ", "E ", "Jie ", "Mao ", "Fu ", "Chun ", "Tu ", "Yan ", "He ", "Yuan ", "Pian ", "Yun ", "Mei ", "Hu ", "Ying ", "Dun ", "Mu ", "Ju ", "Tsugumi ", "Cang ", "Fang ", "Gu ", "Ying ", "Yuan ", "Xuan ", "Weng ", "Shi ", "He ", "Chu ", "Tang ", "Xia ", "Ruo ", "Liu ", "Ji ", "Gu ", "Jian ", "Zhun ", "Han ", "Zi ", "Zi ", "Ni ", "Yao ", "Yan ", "Ji ", "Li ", "Tian ", "Kou ", "Ti ", "Ti ", "Ni ", "Tu ", "Ma ", "Jiao ", "Gao ", "Tian ", "Chen ", "Li ", "Zhuan ", "Zhe ", "Ao ", "Yao ", "Yi ", "Ou ", "Chi ", "Zhi ", "Liao ", "Rong ", "Lou ", "Bi ", "Shuang ", "Zhuo ", "Yu ", "Wu ", "Jue ", "Yin ", "Quan ", "Si ", "Jiao ", "Yi ", "Hua ", "Bi ", "Ying ", "Su ", "Huang ", "Fan ", "Jiao ", "Liao ", "Yan ", "Kao ", "Jiu ", "Xian ", "Xian ", "Tu ", "Mai ", "Zun ", "Yu ", "Ying ", "Lu ", "Tuan ", "Xian ", "Xue ", "Yi ", "Pi "];
  }
});

// node_modules/unidecode/data/x9e.js
var require_x9e = __commonJS({
  "node_modules/unidecode/data/x9e.js"(exports2, module2) {
    module2.exports = ["Shu ", "Luo ", "Qi ", "Yi ", "Ji ", "Zhe ", "Yu ", "Zhan ", "Ye ", "Yang ", "Pi ", "Ning ", "Huo ", "Mi ", "Ying ", "Meng ", "Di ", "Yue ", "Yu ", "Lei ", "Bao ", "Lu ", "He ", "Long ", "Shuang ", "Yue ", "Ying ", "Guan ", "Qu ", "Li ", "Luan ", "Niao ", "Jiu ", "Ji ", "Yuan ", "Ming ", "Shi ", "Ou ", "Ya ", "Cang ", "Bao ", "Zhen ", "Gu ", "Dong ", "Lu ", "Ya ", "Xiao ", "Yang ", "Ling ", "Zhi ", "Qu ", "Yuan ", "Xue ", "Tuo ", "Si ", "Zhi ", "Er ", "Gua ", "Xiu ", "Heng ", "Zhou ", "Ge ", "Luan ", "Hong ", "Wu ", "Bo ", "Li ", "Juan ", "Hu ", "E ", "Yu ", "Xian ", "Ti ", "Wu ", "Que ", "Miao ", "An ", "Kun ", "Bei ", "Peng ", "Qian ", "Chun ", "Geng ", "Yuan ", "Su ", "Hu ", "He ", "E ", "Gu ", "Qiu ", "Zi ", "Mei ", "Mu ", "Ni ", "Yao ", "Weng ", "Liu ", "Ji ", "Ni ", "Jian ", "He ", "Yi ", "Ying ", "Zhe ", "Liao ", "Liao ", "Jiao ", "Jiu ", "Yu ", "Lu ", "Xuan ", "Zhan ", "Ying ", "Huo ", "Meng ", "Guan ", "Shuang ", "Lu ", "Jin ", "Ling ", "Jian ", "Xian ", "Cuo ", "Jian ", "Jian ", "Yan ", "Cuo ", "Lu ", "You ", "Cu ", "Ji ", "Biao ", "Cu ", "Biao ", "Zhu ", "Jun ", "Zhu ", "Jian ", "Mi ", "Mi ", "Wu ", "Liu ", "Chen ", "Jun ", "Lin ", "Ni ", "Qi ", "Lu ", "Jiu ", "Jun ", "Jing ", "Li ", "Xiang ", "Yan ", "Jia ", "Mi ", "Li ", "She ", "Zhang ", "Lin ", "Jing ", "Ji ", "Ling ", "Yan ", "Cu ", "Mai ", "Mai ", "Ge ", "Chao ", "Fu ", "Mian ", "Mian ", "Fu ", "Pao ", "Qu ", "Qu ", "Mou ", "Fu ", "Xian ", "Lai ", "Qu ", "Mian ", "[?] ", "Feng ", "Fu ", "Qu ", "Mian ", "Ma ", "Mo ", "Mo ", "Hui ", "Ma ", "Zou ", "Nen ", "Fen ", "Huang ", "Huang ", "Jin ", "Guang ", "Tian ", "Tou ", "Heng ", "Xi ", "Kuang ", "Heng ", "Shu ", "Li ", "Nian ", "Chi ", "Hei ", "Hei ", "Yi ", "Qian ", "Dan ", "Xi ", "Tuan ", "Mo ", "Mo ", "Qian ", "Dai ", "Chu ", "You ", "Dian ", "Yi ", "Xia ", "Yan ", "Qu ", "Mei ", "Yan ", "Jing ", "Yu ", "Li ", "Dang ", "Du ", "Can ", "Yin ", "An ", "Yan ", "Tan ", "An ", "Zhen ", "Dai ", "Can ", "Yi ", "Mei ", "Dan ", "Yan ", "Du ", "Lu ", "Zhi ", "Fen ", "Fu ", "Fu ", "Min ", "Min ", "Yuan "];
  }
});

// node_modules/unidecode/data/x9f.js
var require_x9f = __commonJS({
  "node_modules/unidecode/data/x9f.js"(exports2, module2) {
    module2.exports = ["Cu ", "Qu ", "Chao ", "Wa ", "Zhu ", "Zhi ", "Mang ", "Ao ", "Bie ", "Tuo ", "Bi ", "Yuan ", "Chao ", "Tuo ", "Ding ", "Mi ", "Nai ", "Ding ", "Zi ", "Gu ", "Gu ", "Dong ", "Fen ", "Tao ", "Yuan ", "Pi ", "Chang ", "Gao ", "Qi ", "Yuan ", "Tang ", "Teng ", "Shu ", "Shu ", "Fen ", "Fei ", "Wen ", "Ba ", "Diao ", "Tuo ", "Tong ", "Qu ", "Sheng ", "Shi ", "You ", "Shi ", "Ting ", "Wu ", "Nian ", "Jing ", "Hun ", "Ju ", "Yan ", "Tu ", "Ti ", "Xi ", "Xian ", "Yan ", "Lei ", "Bi ", "Yao ", "Qiu ", "Han ", "Wu ", "Wu ", "Hou ", "Xi ", "Ge ", "Zha ", "Xiu ", "Weng ", "Zha ", "Nong ", "Nang ", "Qi ", "Zhai ", "Ji ", "Zi ", "Ji ", "Ji ", "Qi ", "Ji ", "Chi ", "Chen ", "Chen ", "He ", "Ya ", "Ken ", "Xie ", "Pao ", "Cuo ", "Shi ", "Zi ", "Chi ", "Nian ", "Ju ", "Tiao ", "Ling ", "Ling ", "Chu ", "Quan ", "Xie ", "Ken ", "Nie ", "Jiu ", "Yao ", "Chuo ", "Kun ", "Yu ", "Chu ", "Yi ", "Ni ", "Cuo ", "Zou ", "Qu ", "Nen ", "Xian ", "Ou ", "E ", "Wo ", "Yi ", "Chuo ", "Zou ", "Dian ", "Chu ", "Jin ", "Ya ", "Chi ", "Chen ", "He ", "Ken ", "Ju ", "Ling ", "Pao ", "Tiao ", "Zi ", "Ken ", "Yu ", "Chuo ", "Qu ", "Wo ", "Long ", "Pang ", "Gong ", "Pang ", "Yan ", "Long ", "Long ", "Gong ", "Kan ", "Ta ", "Ling ", "Ta ", "Long ", "Gong ", "Kan ", "Gui ", "Qiu ", "Bie ", "Gui ", "Yue ", "Chui ", "He ", "Jue ", "Xie ", "Yu ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xa0.js
var require_xa0 = __commonJS({
  "node_modules/unidecode/data/xa0.js"(exports2, module2) {
    module2.exports = ["it", "ix", "i", "ip", "iet", "iex", "ie", "iep", "at", "ax", "a", "ap", "uox", "uo", "uop", "ot", "ox", "o", "op", "ex", "e", "wu", "bit", "bix", "bi", "bip", "biet", "biex", "bie", "biep", "bat", "bax", "ba", "bap", "buox", "buo", "buop", "bot", "box", "bo", "bop", "bex", "be", "bep", "but", "bux", "bu", "bup", "burx", "bur", "byt", "byx", "by", "byp", "byrx", "byr", "pit", "pix", "pi", "pip", "piex", "pie", "piep", "pat", "pax", "pa", "pap", "puox", "puo", "puop", "pot", "pox", "po", "pop", "put", "pux", "pu", "pup", "purx", "pur", "pyt", "pyx", "py", "pyp", "pyrx", "pyr", "bbit", "bbix", "bbi", "bbip", "bbiet", "bbiex", "bbie", "bbiep", "bbat", "bbax", "bba", "bbap", "bbuox", "bbuo", "bbuop", "bbot", "bbox", "bbo", "bbop", "bbex", "bbe", "bbep", "bbut", "bbux", "bbu", "bbup", "bburx", "bbur", "bbyt", "bbyx", "bby", "bbyp", "nbit", "nbix", "nbi", "nbip", "nbiex", "nbie", "nbiep", "nbat", "nbax", "nba", "nbap", "nbot", "nbox", "nbo", "nbop", "nbut", "nbux", "nbu", "nbup", "nburx", "nbur", "nbyt", "nbyx", "nby", "nbyp", "nbyrx", "nbyr", "hmit", "hmix", "hmi", "hmip", "hmiex", "hmie", "hmiep", "hmat", "hmax", "hma", "hmap", "hmuox", "hmuo", "hmuop", "hmot", "hmox", "hmo", "hmop", "hmut", "hmux", "hmu", "hmup", "hmurx", "hmur", "hmyx", "hmy", "hmyp", "hmyrx", "hmyr", "mit", "mix", "mi", "mip", "miex", "mie", "miep", "mat", "max", "ma", "map", "muot", "muox", "muo", "muop", "mot", "mox", "mo", "mop", "mex", "me", "mut", "mux", "mu", "mup", "murx", "mur", "myt", "myx", "my", "myp", "fit", "fix", "fi", "fip", "fat", "fax", "fa", "fap", "fox", "fo", "fop", "fut", "fux", "fu", "fup", "furx", "fur", "fyt", "fyx", "fy", "fyp", "vit", "vix", "vi", "vip", "viet", "viex", "vie", "viep", "vat", "vax", "va", "vap", "vot", "vox", "vo", "vop", "vex", "vep", "vut", "vux", "vu", "vup", "vurx", "vur", "vyt", "vyx", "vy", "vyp", "vyrx", "vyr"];
  }
});

// node_modules/unidecode/data/xa1.js
var require_xa1 = __commonJS({
  "node_modules/unidecode/data/xa1.js"(exports2, module2) {
    module2.exports = ["dit", "dix", "di", "dip", "diex", "die", "diep", "dat", "dax", "da", "dap", "duox", "duo", "dot", "dox", "do", "dop", "dex", "de", "dep", "dut", "dux", "du", "dup", "durx", "dur", "tit", "tix", "ti", "tip", "tiex", "tie", "tiep", "tat", "tax", "ta", "tap", "tuot", "tuox", "tuo", "tuop", "tot", "tox", "to", "top", "tex", "te", "tep", "tut", "tux", "tu", "tup", "turx", "tur", "ddit", "ddix", "ddi", "ddip", "ddiex", "ddie", "ddiep", "ddat", "ddax", "dda", "ddap", "dduox", "dduo", "dduop", "ddot", "ddox", "ddo", "ddop", "ddex", "dde", "ddep", "ddut", "ddux", "ddu", "ddup", "ddurx", "ddur", "ndit", "ndix", "ndi", "ndip", "ndiex", "ndie", "ndat", "ndax", "nda", "ndap", "ndot", "ndox", "ndo", "ndop", "ndex", "nde", "ndep", "ndut", "ndux", "ndu", "ndup", "ndurx", "ndur", "hnit", "hnix", "hni", "hnip", "hniet", "hniex", "hnie", "hniep", "hnat", "hnax", "hna", "hnap", "hnuox", "hnuo", "hnot", "hnox", "hnop", "hnex", "hne", "hnep", "hnut", "nit", "nix", "ni", "nip", "niex", "nie", "niep", "nax", "na", "nap", "nuox", "nuo", "nuop", "not", "nox", "no", "nop", "nex", "ne", "nep", "nut", "nux", "nu", "nup", "nurx", "nur", "hlit", "hlix", "hli", "hlip", "hliex", "hlie", "hliep", "hlat", "hlax", "hla", "hlap", "hluox", "hluo", "hluop", "hlox", "hlo", "hlop", "hlex", "hle", "hlep", "hlut", "hlux", "hlu", "hlup", "hlurx", "hlur", "hlyt", "hlyx", "hly", "hlyp", "hlyrx", "hlyr", "lit", "lix", "li", "lip", "liet", "liex", "lie", "liep", "lat", "lax", "la", "lap", "luot", "luox", "luo", "luop", "lot", "lox", "lo", "lop", "lex", "le", "lep", "lut", "lux", "lu", "lup", "lurx", "lur", "lyt", "lyx", "ly", "lyp", "lyrx", "lyr", "git", "gix", "gi", "gip", "giet", "giex", "gie", "giep", "gat", "gax", "ga", "gap", "guot", "guox", "guo", "guop", "got", "gox", "go", "gop", "get", "gex", "ge", "gep", "gut", "gux", "gu", "gup", "gurx", "gur", "kit", "kix", "ki", "kip", "kiex", "kie", "kiep", "kat"];
  }
});

// node_modules/unidecode/data/xa2.js
var require_xa2 = __commonJS({
  "node_modules/unidecode/data/xa2.js"(exports2, module2) {
    module2.exports = ["kax", "ka", "kap", "kuox", "kuo", "kuop", "kot", "kox", "ko", "kop", "ket", "kex", "ke", "kep", "kut", "kux", "ku", "kup", "kurx", "kur", "ggit", "ggix", "ggi", "ggiex", "ggie", "ggiep", "ggat", "ggax", "gga", "ggap", "gguot", "gguox", "gguo", "gguop", "ggot", "ggox", "ggo", "ggop", "gget", "ggex", "gge", "ggep", "ggut", "ggux", "ggu", "ggup", "ggurx", "ggur", "mgiex", "mgie", "mgat", "mgax", "mga", "mgap", "mguox", "mguo", "mguop", "mgot", "mgox", "mgo", "mgop", "mgex", "mge", "mgep", "mgut", "mgux", "mgu", "mgup", "mgurx", "mgur", "hxit", "hxix", "hxi", "hxip", "hxiet", "hxiex", "hxie", "hxiep", "hxat", "hxax", "hxa", "hxap", "hxuot", "hxuox", "hxuo", "hxuop", "hxot", "hxox", "hxo", "hxop", "hxex", "hxe", "hxep", "ngiex", "ngie", "ngiep", "ngat", "ngax", "nga", "ngap", "nguot", "nguox", "nguo", "ngot", "ngox", "ngo", "ngop", "ngex", "nge", "ngep", "hit", "hiex", "hie", "hat", "hax", "ha", "hap", "huot", "huox", "huo", "huop", "hot", "hox", "ho", "hop", "hex", "he", "hep", "wat", "wax", "wa", "wap", "wuox", "wuo", "wuop", "wox", "wo", "wop", "wex", "we", "wep", "zit", "zix", "zi", "zip", "ziex", "zie", "ziep", "zat", "zax", "za", "zap", "zuox", "zuo", "zuop", "zot", "zox", "zo", "zop", "zex", "ze", "zep", "zut", "zux", "zu", "zup", "zurx", "zur", "zyt", "zyx", "zy", "zyp", "zyrx", "zyr", "cit", "cix", "ci", "cip", "ciet", "ciex", "cie", "ciep", "cat", "cax", "ca", "cap", "cuox", "cuo", "cuop", "cot", "cox", "co", "cop", "cex", "ce", "cep", "cut", "cux", "cu", "cup", "curx", "cur", "cyt", "cyx", "cy", "cyp", "cyrx", "cyr", "zzit", "zzix", "zzi", "zzip", "zziet", "zziex", "zzie", "zziep", "zzat", "zzax", "zza", "zzap", "zzox", "zzo", "zzop", "zzex", "zze", "zzep", "zzux", "zzu", "zzup", "zzurx", "zzur", "zzyt", "zzyx", "zzy", "zzyp", "zzyrx", "zzyr", "nzit", "nzix", "nzi", "nzip", "nziex", "nzie", "nziep", "nzat", "nzax", "nza", "nzap", "nzuox", "nzuo", "nzox", "nzop", "nzex", "nze", "nzux", "nzu"];
  }
});

// node_modules/unidecode/data/xa3.js
var require_xa3 = __commonJS({
  "node_modules/unidecode/data/xa3.js"(exports2, module2) {
    module2.exports = ["nzup", "nzurx", "nzur", "nzyt", "nzyx", "nzy", "nzyp", "nzyrx", "nzyr", "sit", "six", "si", "sip", "siex", "sie", "siep", "sat", "sax", "sa", "sap", "suox", "suo", "suop", "sot", "sox", "so", "sop", "sex", "se", "sep", "sut", "sux", "su", "sup", "surx", "sur", "syt", "syx", "sy", "syp", "syrx", "syr", "ssit", "ssix", "ssi", "ssip", "ssiex", "ssie", "ssiep", "ssat", "ssax", "ssa", "ssap", "ssot", "ssox", "sso", "ssop", "ssex", "sse", "ssep", "ssut", "ssux", "ssu", "ssup", "ssyt", "ssyx", "ssy", "ssyp", "ssyrx", "ssyr", "zhat", "zhax", "zha", "zhap", "zhuox", "zhuo", "zhuop", "zhot", "zhox", "zho", "zhop", "zhet", "zhex", "zhe", "zhep", "zhut", "zhux", "zhu", "zhup", "zhurx", "zhur", "zhyt", "zhyx", "zhy", "zhyp", "zhyrx", "zhyr", "chat", "chax", "cha", "chap", "chuot", "chuox", "chuo", "chuop", "chot", "chox", "cho", "chop", "chet", "chex", "che", "chep", "chux", "chu", "chup", "churx", "chur", "chyt", "chyx", "chy", "chyp", "chyrx", "chyr", "rrax", "rra", "rruox", "rruo", "rrot", "rrox", "rro", "rrop", "rret", "rrex", "rre", "rrep", "rrut", "rrux", "rru", "rrup", "rrurx", "rrur", "rryt", "rryx", "rry", "rryp", "rryrx", "rryr", "nrat", "nrax", "nra", "nrap", "nrox", "nro", "nrop", "nret", "nrex", "nre", "nrep", "nrut", "nrux", "nru", "nrup", "nrurx", "nrur", "nryt", "nryx", "nry", "nryp", "nryrx", "nryr", "shat", "shax", "sha", "shap", "shuox", "shuo", "shuop", "shot", "shox", "sho", "shop", "shet", "shex", "she", "shep", "shut", "shux", "shu", "shup", "shurx", "shur", "shyt", "shyx", "shy", "shyp", "shyrx", "shyr", "rat", "rax", "ra", "rap", "ruox", "ruo", "ruop", "rot", "rox", "ro", "rop", "rex", "re", "rep", "rut", "rux", "ru", "rup", "rurx", "rur", "ryt", "ryx", "ry", "ryp", "ryrx", "ryr", "jit", "jix", "ji", "jip", "jiet", "jiex", "jie", "jiep", "juot", "juox", "juo", "juop", "jot", "jox", "jo", "jop", "jut", "jux", "ju", "jup", "jurx", "jur", "jyt", "jyx", "jy", "jyp", "jyrx", "jyr", "qit", "qix", "qi", "qip"];
  }
});

// node_modules/unidecode/data/xa4.js
var require_xa4 = __commonJS({
  "node_modules/unidecode/data/xa4.js"(exports2, module2) {
    module2.exports = ["qiet", "qiex", "qie", "qiep", "quot", "quox", "quo", "quop", "qot", "qox", "qo", "qop", "qut", "qux", "qu", "qup", "qurx", "qur", "qyt", "qyx", "qy", "qyp", "qyrx", "qyr", "jjit", "jjix", "jji", "jjip", "jjiet", "jjiex", "jjie", "jjiep", "jjuox", "jjuo", "jjuop", "jjot", "jjox", "jjo", "jjop", "jjut", "jjux", "jju", "jjup", "jjurx", "jjur", "jjyt", "jjyx", "jjy", "jjyp", "njit", "njix", "nji", "njip", "njiet", "njiex", "njie", "njiep", "njuox", "njuo", "njot", "njox", "njo", "njop", "njux", "nju", "njup", "njurx", "njur", "njyt", "njyx", "njy", "njyp", "njyrx", "njyr", "nyit", "nyix", "nyi", "nyip", "nyiet", "nyiex", "nyie", "nyiep", "nyuox", "nyuo", "nyuop", "nyot", "nyox", "nyo", "nyop", "nyut", "nyux", "nyu", "nyup", "xit", "xix", "xi", "xip", "xiet", "xiex", "xie", "xiep", "xuox", "xuo", "xot", "xox", "xo", "xop", "xyt", "xyx", "xy", "xyp", "xyrx", "xyr", "yit", "yix", "yi", "yip", "yiet", "yiex", "yie", "yiep", "yuot", "yuox", "yuo", "yuop", "yot", "yox", "yo", "yop", "yut", "yux", "yu", "yup", "yurx", "yur", "yyt", "yyx", "yy", "yyp", "yyrx", "yyr", "[?]", "[?]", "[?]", "Qot", "Li", "Kit", "Nyip", "Cyp", "Ssi", "Ggop", "Gep", "Mi", "Hxit", "Lyr", "Bbut", "Mop", "Yo", "Put", "Hxuo", "Tat", "Ga", "[?]", "[?]", "Ddur", "Bur", "Gguo", "Nyop", "Tu", "Op", "Jjut", "Zot", "Pyt", "Hmo", "Yit", "Vur", "Shy", "Vep", "Za", "Jo", "[?]", "Jjy", "Got", "Jjie", "Wo", "Du", "Shur", "Lie", "Cy", "Cuop", "Cip", "Hxop", "Shat", "[?]", "Shop", "Che", "Zziet", "[?]", "Ke", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xac.js
var require_xac = __commonJS({
  "node_modules/unidecode/data/xac.js"(exports2, module2) {
    module2.exports = ["ga", "gag", "gagg", "gags", "gan", "ganj", "ganh", "gad", "gal", "galg", "galm", "galb", "gals", "galt", "galp", "galh", "gam", "gab", "gabs", "gas", "gass", "gang", "gaj", "gac", "gak", "gat", "gap", "gah", "gae", "gaeg", "gaegg", "gaegs", "gaen", "gaenj", "gaenh", "gaed", "gael", "gaelg", "gaelm", "gaelb", "gaels", "gaelt", "gaelp", "gaelh", "gaem", "gaeb", "gaebs", "gaes", "gaess", "gaeng", "gaej", "gaec", "gaek", "gaet", "gaep", "gaeh", "gya", "gyag", "gyagg", "gyags", "gyan", "gyanj", "gyanh", "gyad", "gyal", "gyalg", "gyalm", "gyalb", "gyals", "gyalt", "gyalp", "gyalh", "gyam", "gyab", "gyabs", "gyas", "gyass", "gyang", "gyaj", "gyac", "gyak", "gyat", "gyap", "gyah", "gyae", "gyaeg", "gyaegg", "gyaegs", "gyaen", "gyaenj", "gyaenh", "gyaed", "gyael", "gyaelg", "gyaelm", "gyaelb", "gyaels", "gyaelt", "gyaelp", "gyaelh", "gyaem", "gyaeb", "gyaebs", "gyaes", "gyaess", "gyaeng", "gyaej", "gyaec", "gyaek", "gyaet", "gyaep", "gyaeh", "geo", "geog", "geogg", "geogs", "geon", "geonj", "geonh", "geod", "geol", "geolg", "geolm", "geolb", "geols", "geolt", "geolp", "geolh", "geom", "geob", "geobs", "geos", "geoss", "geong", "geoj", "geoc", "geok", "geot", "geop", "geoh", "ge", "geg", "gegg", "gegs", "gen", "genj", "genh", "ged", "gel", "gelg", "gelm", "gelb", "gels", "gelt", "gelp", "gelh", "gem", "geb", "gebs", "ges", "gess", "geng", "gej", "gec", "gek", "get", "gep", "geh", "gyeo", "gyeog", "gyeogg", "gyeogs", "gyeon", "gyeonj", "gyeonh", "gyeod", "gyeol", "gyeolg", "gyeolm", "gyeolb", "gyeols", "gyeolt", "gyeolp", "gyeolh", "gyeom", "gyeob", "gyeobs", "gyeos", "gyeoss", "gyeong", "gyeoj", "gyeoc", "gyeok", "gyeot", "gyeop", "gyeoh", "gye", "gyeg", "gyegg", "gyegs", "gyen", "gyenj", "gyenh", "gyed", "gyel", "gyelg", "gyelm", "gyelb", "gyels", "gyelt", "gyelp", "gyelh", "gyem", "gyeb", "gyebs", "gyes", "gyess", "gyeng", "gyej", "gyec", "gyek", "gyet", "gyep", "gyeh", "go", "gog", "gogg", "gogs", "gon", "gonj", "gonh", "god", "gol", "golg", "golm", "golb", "gols", "golt", "golp", "golh", "gom", "gob", "gobs", "gos", "goss", "gong", "goj", "goc", "gok", "got", "gop", "goh", "gwa", "gwag", "gwagg", "gwags"];
  }
});

// node_modules/unidecode/data/xad.js
var require_xad = __commonJS({
  "node_modules/unidecode/data/xad.js"(exports2, module2) {
    module2.exports = ["gwan", "gwanj", "gwanh", "gwad", "gwal", "gwalg", "gwalm", "gwalb", "gwals", "gwalt", "gwalp", "gwalh", "gwam", "gwab", "gwabs", "gwas", "gwass", "gwang", "gwaj", "gwac", "gwak", "gwat", "gwap", "gwah", "gwae", "gwaeg", "gwaegg", "gwaegs", "gwaen", "gwaenj", "gwaenh", "gwaed", "gwael", "gwaelg", "gwaelm", "gwaelb", "gwaels", "gwaelt", "gwaelp", "gwaelh", "gwaem", "gwaeb", "gwaebs", "gwaes", "gwaess", "gwaeng", "gwaej", "gwaec", "gwaek", "gwaet", "gwaep", "gwaeh", "goe", "goeg", "goegg", "goegs", "goen", "goenj", "goenh", "goed", "goel", "goelg", "goelm", "goelb", "goels", "goelt", "goelp", "goelh", "goem", "goeb", "goebs", "goes", "goess", "goeng", "goej", "goec", "goek", "goet", "goep", "goeh", "gyo", "gyog", "gyogg", "gyogs", "gyon", "gyonj", "gyonh", "gyod", "gyol", "gyolg", "gyolm", "gyolb", "gyols", "gyolt", "gyolp", "gyolh", "gyom", "gyob", "gyobs", "gyos", "gyoss", "gyong", "gyoj", "gyoc", "gyok", "gyot", "gyop", "gyoh", "gu", "gug", "gugg", "gugs", "gun", "gunj", "gunh", "gud", "gul", "gulg", "gulm", "gulb", "guls", "gult", "gulp", "gulh", "gum", "gub", "gubs", "gus", "guss", "gung", "guj", "guc", "guk", "gut", "gup", "guh", "gweo", "gweog", "gweogg", "gweogs", "gweon", "gweonj", "gweonh", "gweod", "gweol", "gweolg", "gweolm", "gweolb", "gweols", "gweolt", "gweolp", "gweolh", "gweom", "gweob", "gweobs", "gweos", "gweoss", "gweong", "gweoj", "gweoc", "gweok", "gweot", "gweop", "gweoh", "gwe", "gweg", "gwegg", "gwegs", "gwen", "gwenj", "gwenh", "gwed", "gwel", "gwelg", "gwelm", "gwelb", "gwels", "gwelt", "gwelp", "gwelh", "gwem", "gweb", "gwebs", "gwes", "gwess", "gweng", "gwej", "gwec", "gwek", "gwet", "gwep", "gweh", "gwi", "gwig", "gwigg", "gwigs", "gwin", "gwinj", "gwinh", "gwid", "gwil", "gwilg", "gwilm", "gwilb", "gwils", "gwilt", "gwilp", "gwilh", "gwim", "gwib", "gwibs", "gwis", "gwiss", "gwing", "gwij", "gwic", "gwik", "gwit", "gwip", "gwih", "gyu", "gyug", "gyugg", "gyugs", "gyun", "gyunj", "gyunh", "gyud", "gyul", "gyulg", "gyulm", "gyulb", "gyuls", "gyult", "gyulp", "gyulh", "gyum", "gyub", "gyubs", "gyus", "gyuss", "gyung", "gyuj", "gyuc", "gyuk", "gyut", "gyup", "gyuh", "geu", "geug", "geugg", "geugs", "geun", "geunj", "geunh", "geud"];
  }
});

// node_modules/unidecode/data/xae.js
var require_xae = __commonJS({
  "node_modules/unidecode/data/xae.js"(exports2, module2) {
    module2.exports = ["geul", "geulg", "geulm", "geulb", "geuls", "geult", "geulp", "geulh", "geum", "geub", "geubs", "geus", "geuss", "geung", "geuj", "geuc", "geuk", "geut", "geup", "geuh", "gyi", "gyig", "gyigg", "gyigs", "gyin", "gyinj", "gyinh", "gyid", "gyil", "gyilg", "gyilm", "gyilb", "gyils", "gyilt", "gyilp", "gyilh", "gyim", "gyib", "gyibs", "gyis", "gyiss", "gying", "gyij", "gyic", "gyik", "gyit", "gyip", "gyih", "gi", "gig", "gigg", "gigs", "gin", "ginj", "ginh", "gid", "gil", "gilg", "gilm", "gilb", "gils", "gilt", "gilp", "gilh", "gim", "gib", "gibs", "gis", "giss", "ging", "gij", "gic", "gik", "git", "gip", "gih", "gga", "ggag", "ggagg", "ggags", "ggan", "gganj", "gganh", "ggad", "ggal", "ggalg", "ggalm", "ggalb", "ggals", "ggalt", "ggalp", "ggalh", "ggam", "ggab", "ggabs", "ggas", "ggass", "ggang", "ggaj", "ggac", "ggak", "ggat", "ggap", "ggah", "ggae", "ggaeg", "ggaegg", "ggaegs", "ggaen", "ggaenj", "ggaenh", "ggaed", "ggael", "ggaelg", "ggaelm", "ggaelb", "ggaels", "ggaelt", "ggaelp", "ggaelh", "ggaem", "ggaeb", "ggaebs", "ggaes", "ggaess", "ggaeng", "ggaej", "ggaec", "ggaek", "ggaet", "ggaep", "ggaeh", "ggya", "ggyag", "ggyagg", "ggyags", "ggyan", "ggyanj", "ggyanh", "ggyad", "ggyal", "ggyalg", "ggyalm", "ggyalb", "ggyals", "ggyalt", "ggyalp", "ggyalh", "ggyam", "ggyab", "ggyabs", "ggyas", "ggyass", "ggyang", "ggyaj", "ggyac", "ggyak", "ggyat", "ggyap", "ggyah", "ggyae", "ggyaeg", "ggyaegg", "ggyaegs", "ggyaen", "ggyaenj", "ggyaenh", "ggyaed", "ggyael", "ggyaelg", "ggyaelm", "ggyaelb", "ggyaels", "ggyaelt", "ggyaelp", "ggyaelh", "ggyaem", "ggyaeb", "ggyaebs", "ggyaes", "ggyaess", "ggyaeng", "ggyaej", "ggyaec", "ggyaek", "ggyaet", "ggyaep", "ggyaeh", "ggeo", "ggeog", "ggeogg", "ggeogs", "ggeon", "ggeonj", "ggeonh", "ggeod", "ggeol", "ggeolg", "ggeolm", "ggeolb", "ggeols", "ggeolt", "ggeolp", "ggeolh", "ggeom", "ggeob", "ggeobs", "ggeos", "ggeoss", "ggeong", "ggeoj", "ggeoc", "ggeok", "ggeot", "ggeop", "ggeoh", "gge", "ggeg", "ggegg", "ggegs", "ggen", "ggenj", "ggenh", "gged", "ggel", "ggelg", "ggelm", "ggelb", "ggels", "ggelt", "ggelp", "ggelh", "ggem", "ggeb", "ggebs", "gges", "ggess", "ggeng", "ggej", "ggec", "ggek", "gget", "ggep", "ggeh", "ggyeo", "ggyeog", "ggyeogg", "ggyeogs", "ggyeon", "ggyeonj", "ggyeonh", "ggyeod", "ggyeol", "ggyeolg", "ggyeolm", "ggyeolb"];
  }
});

// node_modules/unidecode/data/xaf.js
var require_xaf = __commonJS({
  "node_modules/unidecode/data/xaf.js"(exports2, module2) {
    module2.exports = ["ggyeols", "ggyeolt", "ggyeolp", "ggyeolh", "ggyeom", "ggyeob", "ggyeobs", "ggyeos", "ggyeoss", "ggyeong", "ggyeoj", "ggyeoc", "ggyeok", "ggyeot", "ggyeop", "ggyeoh", "ggye", "ggyeg", "ggyegg", "ggyegs", "ggyen", "ggyenj", "ggyenh", "ggyed", "ggyel", "ggyelg", "ggyelm", "ggyelb", "ggyels", "ggyelt", "ggyelp", "ggyelh", "ggyem", "ggyeb", "ggyebs", "ggyes", "ggyess", "ggyeng", "ggyej", "ggyec", "ggyek", "ggyet", "ggyep", "ggyeh", "ggo", "ggog", "ggogg", "ggogs", "ggon", "ggonj", "ggonh", "ggod", "ggol", "ggolg", "ggolm", "ggolb", "ggols", "ggolt", "ggolp", "ggolh", "ggom", "ggob", "ggobs", "ggos", "ggoss", "ggong", "ggoj", "ggoc", "ggok", "ggot", "ggop", "ggoh", "ggwa", "ggwag", "ggwagg", "ggwags", "ggwan", "ggwanj", "ggwanh", "ggwad", "ggwal", "ggwalg", "ggwalm", "ggwalb", "ggwals", "ggwalt", "ggwalp", "ggwalh", "ggwam", "ggwab", "ggwabs", "ggwas", "ggwass", "ggwang", "ggwaj", "ggwac", "ggwak", "ggwat", "ggwap", "ggwah", "ggwae", "ggwaeg", "ggwaegg", "ggwaegs", "ggwaen", "ggwaenj", "ggwaenh", "ggwaed", "ggwael", "ggwaelg", "ggwaelm", "ggwaelb", "ggwaels", "ggwaelt", "ggwaelp", "ggwaelh", "ggwaem", "ggwaeb", "ggwaebs", "ggwaes", "ggwaess", "ggwaeng", "ggwaej", "ggwaec", "ggwaek", "ggwaet", "ggwaep", "ggwaeh", "ggoe", "ggoeg", "ggoegg", "ggoegs", "ggoen", "ggoenj", "ggoenh", "ggoed", "ggoel", "ggoelg", "ggoelm", "ggoelb", "ggoels", "ggoelt", "ggoelp", "ggoelh", "ggoem", "ggoeb", "ggoebs", "ggoes", "ggoess", "ggoeng", "ggoej", "ggoec", "ggoek", "ggoet", "ggoep", "ggoeh", "ggyo", "ggyog", "ggyogg", "ggyogs", "ggyon", "ggyonj", "ggyonh", "ggyod", "ggyol", "ggyolg", "ggyolm", "ggyolb", "ggyols", "ggyolt", "ggyolp", "ggyolh", "ggyom", "ggyob", "ggyobs", "ggyos", "ggyoss", "ggyong", "ggyoj", "ggyoc", "ggyok", "ggyot", "ggyop", "ggyoh", "ggu", "ggug", "ggugg", "ggugs", "ggun", "ggunj", "ggunh", "ggud", "ggul", "ggulg", "ggulm", "ggulb", "gguls", "ggult", "ggulp", "ggulh", "ggum", "ggub", "ggubs", "ggus", "gguss", "ggung", "gguj", "gguc", "gguk", "ggut", "ggup", "gguh", "ggweo", "ggweog", "ggweogg", "ggweogs", "ggweon", "ggweonj", "ggweonh", "ggweod", "ggweol", "ggweolg", "ggweolm", "ggweolb", "ggweols", "ggweolt", "ggweolp", "ggweolh", "ggweom", "ggweob", "ggweobs", "ggweos", "ggweoss", "ggweong", "ggweoj", "ggweoc", "ggweok", "ggweot", "ggweop", "ggweoh", "ggwe", "ggweg", "ggwegg", "ggwegs", "ggwen", "ggwenj", "ggwenh", "ggwed", "ggwel", "ggwelg", "ggwelm", "ggwelb", "ggwels", "ggwelt", "ggwelp", "ggwelh"];
  }
});

// node_modules/unidecode/data/xb0.js
var require_xb0 = __commonJS({
  "node_modules/unidecode/data/xb0.js"(exports2, module2) {
    module2.exports = ["ggwem", "ggweb", "ggwebs", "ggwes", "ggwess", "ggweng", "ggwej", "ggwec", "ggwek", "ggwet", "ggwep", "ggweh", "ggwi", "ggwig", "ggwigg", "ggwigs", "ggwin", "ggwinj", "ggwinh", "ggwid", "ggwil", "ggwilg", "ggwilm", "ggwilb", "ggwils", "ggwilt", "ggwilp", "ggwilh", "ggwim", "ggwib", "ggwibs", "ggwis", "ggwiss", "ggwing", "ggwij", "ggwic", "ggwik", "ggwit", "ggwip", "ggwih", "ggyu", "ggyug", "ggyugg", "ggyugs", "ggyun", "ggyunj", "ggyunh", "ggyud", "ggyul", "ggyulg", "ggyulm", "ggyulb", "ggyuls", "ggyult", "ggyulp", "ggyulh", "ggyum", "ggyub", "ggyubs", "ggyus", "ggyuss", "ggyung", "ggyuj", "ggyuc", "ggyuk", "ggyut", "ggyup", "ggyuh", "ggeu", "ggeug", "ggeugg", "ggeugs", "ggeun", "ggeunj", "ggeunh", "ggeud", "ggeul", "ggeulg", "ggeulm", "ggeulb", "ggeuls", "ggeult", "ggeulp", "ggeulh", "ggeum", "ggeub", "ggeubs", "ggeus", "ggeuss", "ggeung", "ggeuj", "ggeuc", "ggeuk", "ggeut", "ggeup", "ggeuh", "ggyi", "ggyig", "ggyigg", "ggyigs", "ggyin", "ggyinj", "ggyinh", "ggyid", "ggyil", "ggyilg", "ggyilm", "ggyilb", "ggyils", "ggyilt", "ggyilp", "ggyilh", "ggyim", "ggyib", "ggyibs", "ggyis", "ggyiss", "ggying", "ggyij", "ggyic", "ggyik", "ggyit", "ggyip", "ggyih", "ggi", "ggig", "ggigg", "ggigs", "ggin", "gginj", "gginh", "ggid", "ggil", "ggilg", "ggilm", "ggilb", "ggils", "ggilt", "ggilp", "ggilh", "ggim", "ggib", "ggibs", "ggis", "ggiss", "gging", "ggij", "ggic", "ggik", "ggit", "ggip", "ggih", "na", "nag", "nagg", "nags", "nan", "nanj", "nanh", "nad", "nal", "nalg", "nalm", "nalb", "nals", "nalt", "nalp", "nalh", "nam", "nab", "nabs", "nas", "nass", "nang", "naj", "nac", "nak", "nat", "nap", "nah", "nae", "naeg", "naegg", "naegs", "naen", "naenj", "naenh", "naed", "nael", "naelg", "naelm", "naelb", "naels", "naelt", "naelp", "naelh", "naem", "naeb", "naebs", "naes", "naess", "naeng", "naej", "naec", "naek", "naet", "naep", "naeh", "nya", "nyag", "nyagg", "nyags", "nyan", "nyanj", "nyanh", "nyad", "nyal", "nyalg", "nyalm", "nyalb", "nyals", "nyalt", "nyalp", "nyalh", "nyam", "nyab", "nyabs", "nyas", "nyass", "nyang", "nyaj", "nyac", "nyak", "nyat", "nyap", "nyah", "nyae", "nyaeg", "nyaegg", "nyaegs", "nyaen", "nyaenj", "nyaenh", "nyaed", "nyael", "nyaelg", "nyaelm", "nyaelb", "nyaels", "nyaelt", "nyaelp", "nyaelh", "nyaem", "nyaeb", "nyaebs", "nyaes"];
  }
});

// node_modules/unidecode/data/xb1.js
var require_xb1 = __commonJS({
  "node_modules/unidecode/data/xb1.js"(exports2, module2) {
    module2.exports = ["nyaess", "nyaeng", "nyaej", "nyaec", "nyaek", "nyaet", "nyaep", "nyaeh", "neo", "neog", "neogg", "neogs", "neon", "neonj", "neonh", "neod", "neol", "neolg", "neolm", "neolb", "neols", "neolt", "neolp", "neolh", "neom", "neob", "neobs", "neos", "neoss", "neong", "neoj", "neoc", "neok", "neot", "neop", "neoh", "ne", "neg", "negg", "negs", "nen", "nenj", "nenh", "ned", "nel", "nelg", "nelm", "nelb", "nels", "nelt", "nelp", "nelh", "nem", "neb", "nebs", "nes", "ness", "neng", "nej", "nec", "nek", "net", "nep", "neh", "nyeo", "nyeog", "nyeogg", "nyeogs", "nyeon", "nyeonj", "nyeonh", "nyeod", "nyeol", "nyeolg", "nyeolm", "nyeolb", "nyeols", "nyeolt", "nyeolp", "nyeolh", "nyeom", "nyeob", "nyeobs", "nyeos", "nyeoss", "nyeong", "nyeoj", "nyeoc", "nyeok", "nyeot", "nyeop", "nyeoh", "nye", "nyeg", "nyegg", "nyegs", "nyen", "nyenj", "nyenh", "nyed", "nyel", "nyelg", "nyelm", "nyelb", "nyels", "nyelt", "nyelp", "nyelh", "nyem", "nyeb", "nyebs", "nyes", "nyess", "nyeng", "nyej", "nyec", "nyek", "nyet", "nyep", "nyeh", "no", "nog", "nogg", "nogs", "non", "nonj", "nonh", "nod", "nol", "nolg", "nolm", "nolb", "nols", "nolt", "nolp", "nolh", "nom", "nob", "nobs", "nos", "noss", "nong", "noj", "noc", "nok", "not", "nop", "noh", "nwa", "nwag", "nwagg", "nwags", "nwan", "nwanj", "nwanh", "nwad", "nwal", "nwalg", "nwalm", "nwalb", "nwals", "nwalt", "nwalp", "nwalh", "nwam", "nwab", "nwabs", "nwas", "nwass", "nwang", "nwaj", "nwac", "nwak", "nwat", "nwap", "nwah", "nwae", "nwaeg", "nwaegg", "nwaegs", "nwaen", "nwaenj", "nwaenh", "nwaed", "nwael", "nwaelg", "nwaelm", "nwaelb", "nwaels", "nwaelt", "nwaelp", "nwaelh", "nwaem", "nwaeb", "nwaebs", "nwaes", "nwaess", "nwaeng", "nwaej", "nwaec", "nwaek", "nwaet", "nwaep", "nwaeh", "noe", "noeg", "noegg", "noegs", "noen", "noenj", "noenh", "noed", "noel", "noelg", "noelm", "noelb", "noels", "noelt", "noelp", "noelh", "noem", "noeb", "noebs", "noes", "noess", "noeng", "noej", "noec", "noek", "noet", "noep", "noeh", "nyo", "nyog", "nyogg", "nyogs", "nyon", "nyonj", "nyonh", "nyod", "nyol", "nyolg", "nyolm", "nyolb", "nyols", "nyolt", "nyolp", "nyolh", "nyom", "nyob", "nyobs", "nyos", "nyoss", "nyong", "nyoj", "nyoc"];
  }
});

// node_modules/unidecode/data/xb2.js
var require_xb2 = __commonJS({
  "node_modules/unidecode/data/xb2.js"(exports2, module2) {
    module2.exports = ["nyok", "nyot", "nyop", "nyoh", "nu", "nug", "nugg", "nugs", "nun", "nunj", "nunh", "nud", "nul", "nulg", "nulm", "nulb", "nuls", "nult", "nulp", "nulh", "num", "nub", "nubs", "nus", "nuss", "nung", "nuj", "nuc", "nuk", "nut", "nup", "nuh", "nweo", "nweog", "nweogg", "nweogs", "nweon", "nweonj", "nweonh", "nweod", "nweol", "nweolg", "nweolm", "nweolb", "nweols", "nweolt", "nweolp", "nweolh", "nweom", "nweob", "nweobs", "nweos", "nweoss", "nweong", "nweoj", "nweoc", "nweok", "nweot", "nweop", "nweoh", "nwe", "nweg", "nwegg", "nwegs", "nwen", "nwenj", "nwenh", "nwed", "nwel", "nwelg", "nwelm", "nwelb", "nwels", "nwelt", "nwelp", "nwelh", "nwem", "nweb", "nwebs", "nwes", "nwess", "nweng", "nwej", "nwec", "nwek", "nwet", "nwep", "nweh", "nwi", "nwig", "nwigg", "nwigs", "nwin", "nwinj", "nwinh", "nwid", "nwil", "nwilg", "nwilm", "nwilb", "nwils", "nwilt", "nwilp", "nwilh", "nwim", "nwib", "nwibs", "nwis", "nwiss", "nwing", "nwij", "nwic", "nwik", "nwit", "nwip", "nwih", "nyu", "nyug", "nyugg", "nyugs", "nyun", "nyunj", "nyunh", "nyud", "nyul", "nyulg", "nyulm", "nyulb", "nyuls", "nyult", "nyulp", "nyulh", "nyum", "nyub", "nyubs", "nyus", "nyuss", "nyung", "nyuj", "nyuc", "nyuk", "nyut", "nyup", "nyuh", "neu", "neug", "neugg", "neugs", "neun", "neunj", "neunh", "neud", "neul", "neulg", "neulm", "neulb", "neuls", "neult", "neulp", "neulh", "neum", "neub", "neubs", "neus", "neuss", "neung", "neuj", "neuc", "neuk", "neut", "neup", "neuh", "nyi", "nyig", "nyigg", "nyigs", "nyin", "nyinj", "nyinh", "nyid", "nyil", "nyilg", "nyilm", "nyilb", "nyils", "nyilt", "nyilp", "nyilh", "nyim", "nyib", "nyibs", "nyis", "nyiss", "nying", "nyij", "nyic", "nyik", "nyit", "nyip", "nyih", "ni", "nig", "nigg", "nigs", "nin", "ninj", "ninh", "nid", "nil", "nilg", "nilm", "nilb", "nils", "nilt", "nilp", "nilh", "nim", "nib", "nibs", "nis", "niss", "ning", "nij", "nic", "nik", "nit", "nip", "nih", "da", "dag", "dagg", "dags", "dan", "danj", "danh", "dad", "dal", "dalg", "dalm", "dalb", "dals", "dalt", "dalp", "dalh", "dam", "dab", "dabs", "das", "dass", "dang", "daj", "dac", "dak", "dat", "dap", "dah"];
  }
});

// node_modules/unidecode/data/xb3.js
var require_xb3 = __commonJS({
  "node_modules/unidecode/data/xb3.js"(exports2, module2) {
    module2.exports = ["dae", "daeg", "daegg", "daegs", "daen", "daenj", "daenh", "daed", "dael", "daelg", "daelm", "daelb", "daels", "daelt", "daelp", "daelh", "daem", "daeb", "daebs", "daes", "daess", "daeng", "daej", "daec", "daek", "daet", "daep", "daeh", "dya", "dyag", "dyagg", "dyags", "dyan", "dyanj", "dyanh", "dyad", "dyal", "dyalg", "dyalm", "dyalb", "dyals", "dyalt", "dyalp", "dyalh", "dyam", "dyab", "dyabs", "dyas", "dyass", "dyang", "dyaj", "dyac", "dyak", "dyat", "dyap", "dyah", "dyae", "dyaeg", "dyaegg", "dyaegs", "dyaen", "dyaenj", "dyaenh", "dyaed", "dyael", "dyaelg", "dyaelm", "dyaelb", "dyaels", "dyaelt", "dyaelp", "dyaelh", "dyaem", "dyaeb", "dyaebs", "dyaes", "dyaess", "dyaeng", "dyaej", "dyaec", "dyaek", "dyaet", "dyaep", "dyaeh", "deo", "deog", "deogg", "deogs", "deon", "deonj", "deonh", "deod", "deol", "deolg", "deolm", "deolb", "deols", "deolt", "deolp", "deolh", "deom", "deob", "deobs", "deos", "deoss", "deong", "deoj", "deoc", "deok", "deot", "deop", "deoh", "de", "deg", "degg", "degs", "den", "denj", "denh", "ded", "del", "delg", "delm", "delb", "dels", "delt", "delp", "delh", "dem", "deb", "debs", "des", "dess", "deng", "dej", "dec", "dek", "det", "dep", "deh", "dyeo", "dyeog", "dyeogg", "dyeogs", "dyeon", "dyeonj", "dyeonh", "dyeod", "dyeol", "dyeolg", "dyeolm", "dyeolb", "dyeols", "dyeolt", "dyeolp", "dyeolh", "dyeom", "dyeob", "dyeobs", "dyeos", "dyeoss", "dyeong", "dyeoj", "dyeoc", "dyeok", "dyeot", "dyeop", "dyeoh", "dye", "dyeg", "dyegg", "dyegs", "dyen", "dyenj", "dyenh", "dyed", "dyel", "dyelg", "dyelm", "dyelb", "dyels", "dyelt", "dyelp", "dyelh", "dyem", "dyeb", "dyebs", "dyes", "dyess", "dyeng", "dyej", "dyec", "dyek", "dyet", "dyep", "dyeh", "do", "dog", "dogg", "dogs", "don", "donj", "donh", "dod", "dol", "dolg", "dolm", "dolb", "dols", "dolt", "dolp", "dolh", "dom", "dob", "dobs", "dos", "doss", "dong", "doj", "doc", "dok", "dot", "dop", "doh", "dwa", "dwag", "dwagg", "dwags", "dwan", "dwanj", "dwanh", "dwad", "dwal", "dwalg", "dwalm", "dwalb", "dwals", "dwalt", "dwalp", "dwalh", "dwam", "dwab", "dwabs", "dwas", "dwass", "dwang", "dwaj", "dwac", "dwak", "dwat", "dwap", "dwah", "dwae", "dwaeg", "dwaegg", "dwaegs"];
  }
});

// node_modules/unidecode/data/xb4.js
var require_xb4 = __commonJS({
  "node_modules/unidecode/data/xb4.js"(exports2, module2) {
    module2.exports = ["dwaen", "dwaenj", "dwaenh", "dwaed", "dwael", "dwaelg", "dwaelm", "dwaelb", "dwaels", "dwaelt", "dwaelp", "dwaelh", "dwaem", "dwaeb", "dwaebs", "dwaes", "dwaess", "dwaeng", "dwaej", "dwaec", "dwaek", "dwaet", "dwaep", "dwaeh", "doe", "doeg", "doegg", "doegs", "doen", "doenj", "doenh", "doed", "doel", "doelg", "doelm", "doelb", "doels", "doelt", "doelp", "doelh", "doem", "doeb", "doebs", "does", "doess", "doeng", "doej", "doec", "doek", "doet", "doep", "doeh", "dyo", "dyog", "dyogg", "dyogs", "dyon", "dyonj", "dyonh", "dyod", "dyol", "dyolg", "dyolm", "dyolb", "dyols", "dyolt", "dyolp", "dyolh", "dyom", "dyob", "dyobs", "dyos", "dyoss", "dyong", "dyoj", "dyoc", "dyok", "dyot", "dyop", "dyoh", "du", "dug", "dugg", "dugs", "dun", "dunj", "dunh", "dud", "dul", "dulg", "dulm", "dulb", "duls", "dult", "dulp", "dulh", "dum", "dub", "dubs", "dus", "duss", "dung", "duj", "duc", "duk", "dut", "dup", "duh", "dweo", "dweog", "dweogg", "dweogs", "dweon", "dweonj", "dweonh", "dweod", "dweol", "dweolg", "dweolm", "dweolb", "dweols", "dweolt", "dweolp", "dweolh", "dweom", "dweob", "dweobs", "dweos", "dweoss", "dweong", "dweoj", "dweoc", "dweok", "dweot", "dweop", "dweoh", "dwe", "dweg", "dwegg", "dwegs", "dwen", "dwenj", "dwenh", "dwed", "dwel", "dwelg", "dwelm", "dwelb", "dwels", "dwelt", "dwelp", "dwelh", "dwem", "dweb", "dwebs", "dwes", "dwess", "dweng", "dwej", "dwec", "dwek", "dwet", "dwep", "dweh", "dwi", "dwig", "dwigg", "dwigs", "dwin", "dwinj", "dwinh", "dwid", "dwil", "dwilg", "dwilm", "dwilb", "dwils", "dwilt", "dwilp", "dwilh", "dwim", "dwib", "dwibs", "dwis", "dwiss", "dwing", "dwij", "dwic", "dwik", "dwit", "dwip", "dwih", "dyu", "dyug", "dyugg", "dyugs", "dyun", "dyunj", "dyunh", "dyud", "dyul", "dyulg", "dyulm", "dyulb", "dyuls", "dyult", "dyulp", "dyulh", "dyum", "dyub", "dyubs", "dyus", "dyuss", "dyung", "dyuj", "dyuc", "dyuk", "dyut", "dyup", "dyuh", "deu", "deug", "deugg", "deugs", "deun", "deunj", "deunh", "deud", "deul", "deulg", "deulm", "deulb", "deuls", "deult", "deulp", "deulh", "deum", "deub", "deubs", "deus", "deuss", "deung", "deuj", "deuc", "deuk", "deut", "deup", "deuh", "dyi", "dyig", "dyigg", "dyigs", "dyin", "dyinj", "dyinh", "dyid"];
  }
});

// node_modules/unidecode/data/xb5.js
var require_xb5 = __commonJS({
  "node_modules/unidecode/data/xb5.js"(exports2, module2) {
    module2.exports = ["dyil", "dyilg", "dyilm", "dyilb", "dyils", "dyilt", "dyilp", "dyilh", "dyim", "dyib", "dyibs", "dyis", "dyiss", "dying", "dyij", "dyic", "dyik", "dyit", "dyip", "dyih", "di", "dig", "digg", "digs", "din", "dinj", "dinh", "did", "dil", "dilg", "dilm", "dilb", "dils", "dilt", "dilp", "dilh", "dim", "dib", "dibs", "dis", "diss", "ding", "dij", "dic", "dik", "dit", "dip", "dih", "dda", "ddag", "ddagg", "ddags", "ddan", "ddanj", "ddanh", "ddad", "ddal", "ddalg", "ddalm", "ddalb", "ddals", "ddalt", "ddalp", "ddalh", "ddam", "ddab", "ddabs", "ddas", "ddass", "ddang", "ddaj", "ddac", "ddak", "ddat", "ddap", "ddah", "ddae", "ddaeg", "ddaegg", "ddaegs", "ddaen", "ddaenj", "ddaenh", "ddaed", "ddael", "ddaelg", "ddaelm", "ddaelb", "ddaels", "ddaelt", "ddaelp", "ddaelh", "ddaem", "ddaeb", "ddaebs", "ddaes", "ddaess", "ddaeng", "ddaej", "ddaec", "ddaek", "ddaet", "ddaep", "ddaeh", "ddya", "ddyag", "ddyagg", "ddyags", "ddyan", "ddyanj", "ddyanh", "ddyad", "ddyal", "ddyalg", "ddyalm", "ddyalb", "ddyals", "ddyalt", "ddyalp", "ddyalh", "ddyam", "ddyab", "ddyabs", "ddyas", "ddyass", "ddyang", "ddyaj", "ddyac", "ddyak", "ddyat", "ddyap", "ddyah", "ddyae", "ddyaeg", "ddyaegg", "ddyaegs", "ddyaen", "ddyaenj", "ddyaenh", "ddyaed", "ddyael", "ddyaelg", "ddyaelm", "ddyaelb", "ddyaels", "ddyaelt", "ddyaelp", "ddyaelh", "ddyaem", "ddyaeb", "ddyaebs", "ddyaes", "ddyaess", "ddyaeng", "ddyaej", "ddyaec", "ddyaek", "ddyaet", "ddyaep", "ddyaeh", "ddeo", "ddeog", "ddeogg", "ddeogs", "ddeon", "ddeonj", "ddeonh", "ddeod", "ddeol", "ddeolg", "ddeolm", "ddeolb", "ddeols", "ddeolt", "ddeolp", "ddeolh", "ddeom", "ddeob", "ddeobs", "ddeos", "ddeoss", "ddeong", "ddeoj", "ddeoc", "ddeok", "ddeot", "ddeop", "ddeoh", "dde", "ddeg", "ddegg", "ddegs", "dden", "ddenj", "ddenh", "dded", "ddel", "ddelg", "ddelm", "ddelb", "ddels", "ddelt", "ddelp", "ddelh", "ddem", "ddeb", "ddebs", "ddes", "ddess", "ddeng", "ddej", "ddec", "ddek", "ddet", "ddep", "ddeh", "ddyeo", "ddyeog", "ddyeogg", "ddyeogs", "ddyeon", "ddyeonj", "ddyeonh", "ddyeod", "ddyeol", "ddyeolg", "ddyeolm", "ddyeolb", "ddyeols", "ddyeolt", "ddyeolp", "ddyeolh", "ddyeom", "ddyeob", "ddyeobs", "ddyeos", "ddyeoss", "ddyeong", "ddyeoj", "ddyeoc", "ddyeok", "ddyeot", "ddyeop", "ddyeoh", "ddye", "ddyeg", "ddyegg", "ddyegs", "ddyen", "ddyenj", "ddyenh", "ddyed", "ddyel", "ddyelg", "ddyelm", "ddyelb"];
  }
});

// node_modules/unidecode/data/xb6.js
var require_xb6 = __commonJS({
  "node_modules/unidecode/data/xb6.js"(exports2, module2) {
    module2.exports = ["ddyels", "ddyelt", "ddyelp", "ddyelh", "ddyem", "ddyeb", "ddyebs", "ddyes", "ddyess", "ddyeng", "ddyej", "ddyec", "ddyek", "ddyet", "ddyep", "ddyeh", "ddo", "ddog", "ddogg", "ddogs", "ddon", "ddonj", "ddonh", "ddod", "ddol", "ddolg", "ddolm", "ddolb", "ddols", "ddolt", "ddolp", "ddolh", "ddom", "ddob", "ddobs", "ddos", "ddoss", "ddong", "ddoj", "ddoc", "ddok", "ddot", "ddop", "ddoh", "ddwa", "ddwag", "ddwagg", "ddwags", "ddwan", "ddwanj", "ddwanh", "ddwad", "ddwal", "ddwalg", "ddwalm", "ddwalb", "ddwals", "ddwalt", "ddwalp", "ddwalh", "ddwam", "ddwab", "ddwabs", "ddwas", "ddwass", "ddwang", "ddwaj", "ddwac", "ddwak", "ddwat", "ddwap", "ddwah", "ddwae", "ddwaeg", "ddwaegg", "ddwaegs", "ddwaen", "ddwaenj", "ddwaenh", "ddwaed", "ddwael", "ddwaelg", "ddwaelm", "ddwaelb", "ddwaels", "ddwaelt", "ddwaelp", "ddwaelh", "ddwaem", "ddwaeb", "ddwaebs", "ddwaes", "ddwaess", "ddwaeng", "ddwaej", "ddwaec", "ddwaek", "ddwaet", "ddwaep", "ddwaeh", "ddoe", "ddoeg", "ddoegg", "ddoegs", "ddoen", "ddoenj", "ddoenh", "ddoed", "ddoel", "ddoelg", "ddoelm", "ddoelb", "ddoels", "ddoelt", "ddoelp", "ddoelh", "ddoem", "ddoeb", "ddoebs", "ddoes", "ddoess", "ddoeng", "ddoej", "ddoec", "ddoek", "ddoet", "ddoep", "ddoeh", "ddyo", "ddyog", "ddyogg", "ddyogs", "ddyon", "ddyonj", "ddyonh", "ddyod", "ddyol", "ddyolg", "ddyolm", "ddyolb", "ddyols", "ddyolt", "ddyolp", "ddyolh", "ddyom", "ddyob", "ddyobs", "ddyos", "ddyoss", "ddyong", "ddyoj", "ddyoc", "ddyok", "ddyot", "ddyop", "ddyoh", "ddu", "ddug", "ddugg", "ddugs", "ddun", "ddunj", "ddunh", "ddud", "ddul", "ddulg", "ddulm", "ddulb", "dduls", "ddult", "ddulp", "ddulh", "ddum", "ddub", "ddubs", "ddus", "dduss", "ddung", "dduj", "dduc", "dduk", "ddut", "ddup", "dduh", "ddweo", "ddweog", "ddweogg", "ddweogs", "ddweon", "ddweonj", "ddweonh", "ddweod", "ddweol", "ddweolg", "ddweolm", "ddweolb", "ddweols", "ddweolt", "ddweolp", "ddweolh", "ddweom", "ddweob", "ddweobs", "ddweos", "ddweoss", "ddweong", "ddweoj", "ddweoc", "ddweok", "ddweot", "ddweop", "ddweoh", "ddwe", "ddweg", "ddwegg", "ddwegs", "ddwen", "ddwenj", "ddwenh", "ddwed", "ddwel", "ddwelg", "ddwelm", "ddwelb", "ddwels", "ddwelt", "ddwelp", "ddwelh", "ddwem", "ddweb", "ddwebs", "ddwes", "ddwess", "ddweng", "ddwej", "ddwec", "ddwek", "ddwet", "ddwep", "ddweh", "ddwi", "ddwig", "ddwigg", "ddwigs", "ddwin", "ddwinj", "ddwinh", "ddwid", "ddwil", "ddwilg", "ddwilm", "ddwilb", "ddwils", "ddwilt", "ddwilp", "ddwilh"];
  }
});

// node_modules/unidecode/data/xb7.js
var require_xb7 = __commonJS({
  "node_modules/unidecode/data/xb7.js"(exports2, module2) {
    module2.exports = ["ddwim", "ddwib", "ddwibs", "ddwis", "ddwiss", "ddwing", "ddwij", "ddwic", "ddwik", "ddwit", "ddwip", "ddwih", "ddyu", "ddyug", "ddyugg", "ddyugs", "ddyun", "ddyunj", "ddyunh", "ddyud", "ddyul", "ddyulg", "ddyulm", "ddyulb", "ddyuls", "ddyult", "ddyulp", "ddyulh", "ddyum", "ddyub", "ddyubs", "ddyus", "ddyuss", "ddyung", "ddyuj", "ddyuc", "ddyuk", "ddyut", "ddyup", "ddyuh", "ddeu", "ddeug", "ddeugg", "ddeugs", "ddeun", "ddeunj", "ddeunh", "ddeud", "ddeul", "ddeulg", "ddeulm", "ddeulb", "ddeuls", "ddeult", "ddeulp", "ddeulh", "ddeum", "ddeub", "ddeubs", "ddeus", "ddeuss", "ddeung", "ddeuj", "ddeuc", "ddeuk", "ddeut", "ddeup", "ddeuh", "ddyi", "ddyig", "ddyigg", "ddyigs", "ddyin", "ddyinj", "ddyinh", "ddyid", "ddyil", "ddyilg", "ddyilm", "ddyilb", "ddyils", "ddyilt", "ddyilp", "ddyilh", "ddyim", "ddyib", "ddyibs", "ddyis", "ddyiss", "ddying", "ddyij", "ddyic", "ddyik", "ddyit", "ddyip", "ddyih", "ddi", "ddig", "ddigg", "ddigs", "ddin", "ddinj", "ddinh", "ddid", "ddil", "ddilg", "ddilm", "ddilb", "ddils", "ddilt", "ddilp", "ddilh", "ddim", "ddib", "ddibs", "ddis", "ddiss", "dding", "ddij", "ddic", "ddik", "ddit", "ddip", "ddih", "ra", "rag", "ragg", "rags", "ran", "ranj", "ranh", "rad", "ral", "ralg", "ralm", "ralb", "rals", "ralt", "ralp", "ralh", "ram", "rab", "rabs", "ras", "rass", "rang", "raj", "rac", "rak", "rat", "rap", "rah", "rae", "raeg", "raegg", "raegs", "raen", "raenj", "raenh", "raed", "rael", "raelg", "raelm", "raelb", "raels", "raelt", "raelp", "raelh", "raem", "raeb", "raebs", "raes", "raess", "raeng", "raej", "raec", "raek", "raet", "raep", "raeh", "rya", "ryag", "ryagg", "ryags", "ryan", "ryanj", "ryanh", "ryad", "ryal", "ryalg", "ryalm", "ryalb", "ryals", "ryalt", "ryalp", "ryalh", "ryam", "ryab", "ryabs", "ryas", "ryass", "ryang", "ryaj", "ryac", "ryak", "ryat", "ryap", "ryah", "ryae", "ryaeg", "ryaegg", "ryaegs", "ryaen", "ryaenj", "ryaenh", "ryaed", "ryael", "ryaelg", "ryaelm", "ryaelb", "ryaels", "ryaelt", "ryaelp", "ryaelh", "ryaem", "ryaeb", "ryaebs", "ryaes", "ryaess", "ryaeng", "ryaej", "ryaec", "ryaek", "ryaet", "ryaep", "ryaeh", "reo", "reog", "reogg", "reogs", "reon", "reonj", "reonh", "reod", "reol", "reolg", "reolm", "reolb", "reols", "reolt", "reolp", "reolh", "reom", "reob", "reobs", "reos"];
  }
});

// node_modules/unidecode/data/xb8.js
var require_xb8 = __commonJS({
  "node_modules/unidecode/data/xb8.js"(exports2, module2) {
    module2.exports = ["reoss", "reong", "reoj", "reoc", "reok", "reot", "reop", "reoh", "re", "reg", "regg", "regs", "ren", "renj", "renh", "red", "rel", "relg", "relm", "relb", "rels", "relt", "relp", "relh", "rem", "reb", "rebs", "res", "ress", "reng", "rej", "rec", "rek", "ret", "rep", "reh", "ryeo", "ryeog", "ryeogg", "ryeogs", "ryeon", "ryeonj", "ryeonh", "ryeod", "ryeol", "ryeolg", "ryeolm", "ryeolb", "ryeols", "ryeolt", "ryeolp", "ryeolh", "ryeom", "ryeob", "ryeobs", "ryeos", "ryeoss", "ryeong", "ryeoj", "ryeoc", "ryeok", "ryeot", "ryeop", "ryeoh", "rye", "ryeg", "ryegg", "ryegs", "ryen", "ryenj", "ryenh", "ryed", "ryel", "ryelg", "ryelm", "ryelb", "ryels", "ryelt", "ryelp", "ryelh", "ryem", "ryeb", "ryebs", "ryes", "ryess", "ryeng", "ryej", "ryec", "ryek", "ryet", "ryep", "ryeh", "ro", "rog", "rogg", "rogs", "ron", "ronj", "ronh", "rod", "rol", "rolg", "rolm", "rolb", "rols", "rolt", "rolp", "rolh", "rom", "rob", "robs", "ros", "ross", "rong", "roj", "roc", "rok", "rot", "rop", "roh", "rwa", "rwag", "rwagg", "rwags", "rwan", "rwanj", "rwanh", "rwad", "rwal", "rwalg", "rwalm", "rwalb", "rwals", "rwalt", "rwalp", "rwalh", "rwam", "rwab", "rwabs", "rwas", "rwass", "rwang", "rwaj", "rwac", "rwak", "rwat", "rwap", "rwah", "rwae", "rwaeg", "rwaegg", "rwaegs", "rwaen", "rwaenj", "rwaenh", "rwaed", "rwael", "rwaelg", "rwaelm", "rwaelb", "rwaels", "rwaelt", "rwaelp", "rwaelh", "rwaem", "rwaeb", "rwaebs", "rwaes", "rwaess", "rwaeng", "rwaej", "rwaec", "rwaek", "rwaet", "rwaep", "rwaeh", "roe", "roeg", "roegg", "roegs", "roen", "roenj", "roenh", "roed", "roel", "roelg", "roelm", "roelb", "roels", "roelt", "roelp", "roelh", "roem", "roeb", "roebs", "roes", "roess", "roeng", "roej", "roec", "roek", "roet", "roep", "roeh", "ryo", "ryog", "ryogg", "ryogs", "ryon", "ryonj", "ryonh", "ryod", "ryol", "ryolg", "ryolm", "ryolb", "ryols", "ryolt", "ryolp", "ryolh", "ryom", "ryob", "ryobs", "ryos", "ryoss", "ryong", "ryoj", "ryoc", "ryok", "ryot", "ryop", "ryoh", "ru", "rug", "rugg", "rugs", "run", "runj", "runh", "rud", "rul", "rulg", "rulm", "rulb", "ruls", "rult", "rulp", "rulh", "rum", "rub", "rubs", "rus", "russ", "rung", "ruj", "ruc"];
  }
});

// node_modules/unidecode/data/xb9.js
var require_xb9 = __commonJS({
  "node_modules/unidecode/data/xb9.js"(exports2, module2) {
    module2.exports = ["ruk", "rut", "rup", "ruh", "rweo", "rweog", "rweogg", "rweogs", "rweon", "rweonj", "rweonh", "rweod", "rweol", "rweolg", "rweolm", "rweolb", "rweols", "rweolt", "rweolp", "rweolh", "rweom", "rweob", "rweobs", "rweos", "rweoss", "rweong", "rweoj", "rweoc", "rweok", "rweot", "rweop", "rweoh", "rwe", "rweg", "rwegg", "rwegs", "rwen", "rwenj", "rwenh", "rwed", "rwel", "rwelg", "rwelm", "rwelb", "rwels", "rwelt", "rwelp", "rwelh", "rwem", "rweb", "rwebs", "rwes", "rwess", "rweng", "rwej", "rwec", "rwek", "rwet", "rwep", "rweh", "rwi", "rwig", "rwigg", "rwigs", "rwin", "rwinj", "rwinh", "rwid", "rwil", "rwilg", "rwilm", "rwilb", "rwils", "rwilt", "rwilp", "rwilh", "rwim", "rwib", "rwibs", "rwis", "rwiss", "rwing", "rwij", "rwic", "rwik", "rwit", "rwip", "rwih", "ryu", "ryug", "ryugg", "ryugs", "ryun", "ryunj", "ryunh", "ryud", "ryul", "ryulg", "ryulm", "ryulb", "ryuls", "ryult", "ryulp", "ryulh", "ryum", "ryub", "ryubs", "ryus", "ryuss", "ryung", "ryuj", "ryuc", "ryuk", "ryut", "ryup", "ryuh", "reu", "reug", "reugg", "reugs", "reun", "reunj", "reunh", "reud", "reul", "reulg", "reulm", "reulb", "reuls", "reult", "reulp", "reulh", "reum", "reub", "reubs", "reus", "reuss", "reung", "reuj", "reuc", "reuk", "reut", "reup", "reuh", "ryi", "ryig", "ryigg", "ryigs", "ryin", "ryinj", "ryinh", "ryid", "ryil", "ryilg", "ryilm", "ryilb", "ryils", "ryilt", "ryilp", "ryilh", "ryim", "ryib", "ryibs", "ryis", "ryiss", "rying", "ryij", "ryic", "ryik", "ryit", "ryip", "ryih", "ri", "rig", "rigg", "rigs", "rin", "rinj", "rinh", "rid", "ril", "rilg", "rilm", "rilb", "rils", "rilt", "rilp", "rilh", "rim", "rib", "ribs", "ris", "riss", "ring", "rij", "ric", "rik", "rit", "rip", "rih", "ma", "mag", "magg", "mags", "man", "manj", "manh", "mad", "mal", "malg", "malm", "malb", "mals", "malt", "malp", "malh", "mam", "mab", "mabs", "mas", "mass", "mang", "maj", "mac", "mak", "mat", "map", "mah", "mae", "maeg", "maegg", "maegs", "maen", "maenj", "maenh", "maed", "mael", "maelg", "maelm", "maelb", "maels", "maelt", "maelp", "maelh", "maem", "maeb", "maebs", "maes", "maess", "maeng", "maej", "maec", "maek", "maet", "maep", "maeh"];
  }
});

// node_modules/unidecode/data/xba.js
var require_xba = __commonJS({
  "node_modules/unidecode/data/xba.js"(exports2, module2) {
    module2.exports = ["mya", "myag", "myagg", "myags", "myan", "myanj", "myanh", "myad", "myal", "myalg", "myalm", "myalb", "myals", "myalt", "myalp", "myalh", "myam", "myab", "myabs", "myas", "myass", "myang", "myaj", "myac", "myak", "myat", "myap", "myah", "myae", "myaeg", "myaegg", "myaegs", "myaen", "myaenj", "myaenh", "myaed", "myael", "myaelg", "myaelm", "myaelb", "myaels", "myaelt", "myaelp", "myaelh", "myaem", "myaeb", "myaebs", "myaes", "myaess", "myaeng", "myaej", "myaec", "myaek", "myaet", "myaep", "myaeh", "meo", "meog", "meogg", "meogs", "meon", "meonj", "meonh", "meod", "meol", "meolg", "meolm", "meolb", "meols", "meolt", "meolp", "meolh", "meom", "meob", "meobs", "meos", "meoss", "meong", "meoj", "meoc", "meok", "meot", "meop", "meoh", "me", "meg", "megg", "megs", "men", "menj", "menh", "med", "mel", "melg", "melm", "melb", "mels", "melt", "melp", "melh", "mem", "meb", "mebs", "mes", "mess", "meng", "mej", "mec", "mek", "met", "mep", "meh", "myeo", "myeog", "myeogg", "myeogs", "myeon", "myeonj", "myeonh", "myeod", "myeol", "myeolg", "myeolm", "myeolb", "myeols", "myeolt", "myeolp", "myeolh", "myeom", "myeob", "myeobs", "myeos", "myeoss", "myeong", "myeoj", "myeoc", "myeok", "myeot", "myeop", "myeoh", "mye", "myeg", "myegg", "myegs", "myen", "myenj", "myenh", "myed", "myel", "myelg", "myelm", "myelb", "myels", "myelt", "myelp", "myelh", "myem", "myeb", "myebs", "myes", "myess", "myeng", "myej", "myec", "myek", "myet", "myep", "myeh", "mo", "mog", "mogg", "mogs", "mon", "monj", "monh", "mod", "mol", "molg", "molm", "molb", "mols", "molt", "molp", "molh", "mom", "mob", "mobs", "mos", "moss", "mong", "moj", "moc", "mok", "mot", "mop", "moh", "mwa", "mwag", "mwagg", "mwags", "mwan", "mwanj", "mwanh", "mwad", "mwal", "mwalg", "mwalm", "mwalb", "mwals", "mwalt", "mwalp", "mwalh", "mwam", "mwab", "mwabs", "mwas", "mwass", "mwang", "mwaj", "mwac", "mwak", "mwat", "mwap", "mwah", "mwae", "mwaeg", "mwaegg", "mwaegs", "mwaen", "mwaenj", "mwaenh", "mwaed", "mwael", "mwaelg", "mwaelm", "mwaelb", "mwaels", "mwaelt", "mwaelp", "mwaelh", "mwaem", "mwaeb", "mwaebs", "mwaes", "mwaess", "mwaeng", "mwaej", "mwaec", "mwaek", "mwaet", "mwaep", "mwaeh", "moe", "moeg", "moegg", "moegs"];
  }
});

// node_modules/unidecode/data/xbb.js
var require_xbb = __commonJS({
  "node_modules/unidecode/data/xbb.js"(exports2, module2) {
    module2.exports = ["moen", "moenj", "moenh", "moed", "moel", "moelg", "moelm", "moelb", "moels", "moelt", "moelp", "moelh", "moem", "moeb", "moebs", "moes", "moess", "moeng", "moej", "moec", "moek", "moet", "moep", "moeh", "myo", "myog", "myogg", "myogs", "myon", "myonj", "myonh", "myod", "myol", "myolg", "myolm", "myolb", "myols", "myolt", "myolp", "myolh", "myom", "myob", "myobs", "myos", "myoss", "myong", "myoj", "myoc", "myok", "myot", "myop", "myoh", "mu", "mug", "mugg", "mugs", "mun", "munj", "munh", "mud", "mul", "mulg", "mulm", "mulb", "muls", "mult", "mulp", "mulh", "mum", "mub", "mubs", "mus", "muss", "mung", "muj", "muc", "muk", "mut", "mup", "muh", "mweo", "mweog", "mweogg", "mweogs", "mweon", "mweonj", "mweonh", "mweod", "mweol", "mweolg", "mweolm", "mweolb", "mweols", "mweolt", "mweolp", "mweolh", "mweom", "mweob", "mweobs", "mweos", "mweoss", "mweong", "mweoj", "mweoc", "mweok", "mweot", "mweop", "mweoh", "mwe", "mweg", "mwegg", "mwegs", "mwen", "mwenj", "mwenh", "mwed", "mwel", "mwelg", "mwelm", "mwelb", "mwels", "mwelt", "mwelp", "mwelh", "mwem", "mweb", "mwebs", "mwes", "mwess", "mweng", "mwej", "mwec", "mwek", "mwet", "mwep", "mweh", "mwi", "mwig", "mwigg", "mwigs", "mwin", "mwinj", "mwinh", "mwid", "mwil", "mwilg", "mwilm", "mwilb", "mwils", "mwilt", "mwilp", "mwilh", "mwim", "mwib", "mwibs", "mwis", "mwiss", "mwing", "mwij", "mwic", "mwik", "mwit", "mwip", "mwih", "myu", "myug", "myugg", "myugs", "myun", "myunj", "myunh", "myud", "myul", "myulg", "myulm", "myulb", "myuls", "myult", "myulp", "myulh", "myum", "myub", "myubs", "myus", "myuss", "myung", "myuj", "myuc", "myuk", "myut", "myup", "myuh", "meu", "meug", "meugg", "meugs", "meun", "meunj", "meunh", "meud", "meul", "meulg", "meulm", "meulb", "meuls", "meult", "meulp", "meulh", "meum", "meub", "meubs", "meus", "meuss", "meung", "meuj", "meuc", "meuk", "meut", "meup", "meuh", "myi", "myig", "myigg", "myigs", "myin", "myinj", "myinh", "myid", "myil", "myilg", "myilm", "myilb", "myils", "myilt", "myilp", "myilh", "myim", "myib", "myibs", "myis", "myiss", "mying", "myij", "myic", "myik", "myit", "myip", "myih", "mi", "mig", "migg", "migs", "min", "minj", "minh", "mid"];
  }
});

// node_modules/unidecode/data/xbc.js
var require_xbc = __commonJS({
  "node_modules/unidecode/data/xbc.js"(exports2, module2) {
    module2.exports = ["mil", "milg", "milm", "milb", "mils", "milt", "milp", "milh", "mim", "mib", "mibs", "mis", "miss", "ming", "mij", "mic", "mik", "mit", "mip", "mih", "ba", "bag", "bagg", "bags", "ban", "banj", "banh", "bad", "bal", "balg", "balm", "balb", "bals", "balt", "balp", "balh", "bam", "bab", "babs", "bas", "bass", "bang", "baj", "bac", "bak", "bat", "bap", "bah", "bae", "baeg", "baegg", "baegs", "baen", "baenj", "baenh", "baed", "bael", "baelg", "baelm", "baelb", "baels", "baelt", "baelp", "baelh", "baem", "baeb", "baebs", "baes", "baess", "baeng", "baej", "baec", "baek", "baet", "baep", "baeh", "bya", "byag", "byagg", "byags", "byan", "byanj", "byanh", "byad", "byal", "byalg", "byalm", "byalb", "byals", "byalt", "byalp", "byalh", "byam", "byab", "byabs", "byas", "byass", "byang", "byaj", "byac", "byak", "byat", "byap", "byah", "byae", "byaeg", "byaegg", "byaegs", "byaen", "byaenj", "byaenh", "byaed", "byael", "byaelg", "byaelm", "byaelb", "byaels", "byaelt", "byaelp", "byaelh", "byaem", "byaeb", "byaebs", "byaes", "byaess", "byaeng", "byaej", "byaec", "byaek", "byaet", "byaep", "byaeh", "beo", "beog", "beogg", "beogs", "beon", "beonj", "beonh", "beod", "beol", "beolg", "beolm", "beolb", "beols", "beolt", "beolp", "beolh", "beom", "beob", "beobs", "beos", "beoss", "beong", "beoj", "beoc", "beok", "beot", "beop", "beoh", "be", "beg", "begg", "begs", "ben", "benj", "benh", "bed", "bel", "belg", "belm", "belb", "bels", "belt", "belp", "belh", "bem", "beb", "bebs", "bes", "bess", "beng", "bej", "bec", "bek", "bet", "bep", "beh", "byeo", "byeog", "byeogg", "byeogs", "byeon", "byeonj", "byeonh", "byeod", "byeol", "byeolg", "byeolm", "byeolb", "byeols", "byeolt", "byeolp", "byeolh", "byeom", "byeob", "byeobs", "byeos", "byeoss", "byeong", "byeoj", "byeoc", "byeok", "byeot", "byeop", "byeoh", "bye", "byeg", "byegg", "byegs", "byen", "byenj", "byenh", "byed", "byel", "byelg", "byelm", "byelb", "byels", "byelt", "byelp", "byelh", "byem", "byeb", "byebs", "byes", "byess", "byeng", "byej", "byec", "byek", "byet", "byep", "byeh", "bo", "bog", "bogg", "bogs", "bon", "bonj", "bonh", "bod", "bol", "bolg", "bolm", "bolb"];
  }
});

// node_modules/unidecode/data/xbd.js
var require_xbd = __commonJS({
  "node_modules/unidecode/data/xbd.js"(exports2, module2) {
    module2.exports = ["bols", "bolt", "bolp", "bolh", "bom", "bob", "bobs", "bos", "boss", "bong", "boj", "boc", "bok", "bot", "bop", "boh", "bwa", "bwag", "bwagg", "bwags", "bwan", "bwanj", "bwanh", "bwad", "bwal", "bwalg", "bwalm", "bwalb", "bwals", "bwalt", "bwalp", "bwalh", "bwam", "bwab", "bwabs", "bwas", "bwass", "bwang", "bwaj", "bwac", "bwak", "bwat", "bwap", "bwah", "bwae", "bwaeg", "bwaegg", "bwaegs", "bwaen", "bwaenj", "bwaenh", "bwaed", "bwael", "bwaelg", "bwaelm", "bwaelb", "bwaels", "bwaelt", "bwaelp", "bwaelh", "bwaem", "bwaeb", "bwaebs", "bwaes", "bwaess", "bwaeng", "bwaej", "bwaec", "bwaek", "bwaet", "bwaep", "bwaeh", "boe", "boeg", "boegg", "boegs", "boen", "boenj", "boenh", "boed", "boel", "boelg", "boelm", "boelb", "boels", "boelt", "boelp", "boelh", "boem", "boeb", "boebs", "boes", "boess", "boeng", "boej", "boec", "boek", "boet", "boep", "boeh", "byo", "byog", "byogg", "byogs", "byon", "byonj", "byonh", "byod", "byol", "byolg", "byolm", "byolb", "byols", "byolt", "byolp", "byolh", "byom", "byob", "byobs", "byos", "byoss", "byong", "byoj", "byoc", "byok", "byot", "byop", "byoh", "bu", "bug", "bugg", "bugs", "bun", "bunj", "bunh", "bud", "bul", "bulg", "bulm", "bulb", "buls", "bult", "bulp", "bulh", "bum", "bub", "bubs", "bus", "buss", "bung", "buj", "buc", "buk", "but", "bup", "buh", "bweo", "bweog", "bweogg", "bweogs", "bweon", "bweonj", "bweonh", "bweod", "bweol", "bweolg", "bweolm", "bweolb", "bweols", "bweolt", "bweolp", "bweolh", "bweom", "bweob", "bweobs", "bweos", "bweoss", "bweong", "bweoj", "bweoc", "bweok", "bweot", "bweop", "bweoh", "bwe", "bweg", "bwegg", "bwegs", "bwen", "bwenj", "bwenh", "bwed", "bwel", "bwelg", "bwelm", "bwelb", "bwels", "bwelt", "bwelp", "bwelh", "bwem", "bweb", "bwebs", "bwes", "bwess", "bweng", "bwej", "bwec", "bwek", "bwet", "bwep", "bweh", "bwi", "bwig", "bwigg", "bwigs", "bwin", "bwinj", "bwinh", "bwid", "bwil", "bwilg", "bwilm", "bwilb", "bwils", "bwilt", "bwilp", "bwilh", "bwim", "bwib", "bwibs", "bwis", "bwiss", "bwing", "bwij", "bwic", "bwik", "bwit", "bwip", "bwih", "byu", "byug", "byugg", "byugs", "byun", "byunj", "byunh", "byud", "byul", "byulg", "byulm", "byulb", "byuls", "byult", "byulp", "byulh"];
  }
});

// node_modules/unidecode/data/xbe.js
var require_xbe = __commonJS({
  "node_modules/unidecode/data/xbe.js"(exports2, module2) {
    module2.exports = ["byum", "byub", "byubs", "byus", "byuss", "byung", "byuj", "byuc", "byuk", "byut", "byup", "byuh", "beu", "beug", "beugg", "beugs", "beun", "beunj", "beunh", "beud", "beul", "beulg", "beulm", "beulb", "beuls", "beult", "beulp", "beulh", "beum", "beub", "beubs", "beus", "beuss", "beung", "beuj", "beuc", "beuk", "beut", "beup", "beuh", "byi", "byig", "byigg", "byigs", "byin", "byinj", "byinh", "byid", "byil", "byilg", "byilm", "byilb", "byils", "byilt", "byilp", "byilh", "byim", "byib", "byibs", "byis", "byiss", "bying", "byij", "byic", "byik", "byit", "byip", "byih", "bi", "big", "bigg", "bigs", "bin", "binj", "binh", "bid", "bil", "bilg", "bilm", "bilb", "bils", "bilt", "bilp", "bilh", "bim", "bib", "bibs", "bis", "biss", "bing", "bij", "bic", "bik", "bit", "bip", "bih", "bba", "bbag", "bbagg", "bbags", "bban", "bbanj", "bbanh", "bbad", "bbal", "bbalg", "bbalm", "bbalb", "bbals", "bbalt", "bbalp", "bbalh", "bbam", "bbab", "bbabs", "bbas", "bbass", "bbang", "bbaj", "bbac", "bbak", "bbat", "bbap", "bbah", "bbae", "bbaeg", "bbaegg", "bbaegs", "bbaen", "bbaenj", "bbaenh", "bbaed", "bbael", "bbaelg", "bbaelm", "bbaelb", "bbaels", "bbaelt", "bbaelp", "bbaelh", "bbaem", "bbaeb", "bbaebs", "bbaes", "bbaess", "bbaeng", "bbaej", "bbaec", "bbaek", "bbaet", "bbaep", "bbaeh", "bbya", "bbyag", "bbyagg", "bbyags", "bbyan", "bbyanj", "bbyanh", "bbyad", "bbyal", "bbyalg", "bbyalm", "bbyalb", "bbyals", "bbyalt", "bbyalp", "bbyalh", "bbyam", "bbyab", "bbyabs", "bbyas", "bbyass", "bbyang", "bbyaj", "bbyac", "bbyak", "bbyat", "bbyap", "bbyah", "bbyae", "bbyaeg", "bbyaegg", "bbyaegs", "bbyaen", "bbyaenj", "bbyaenh", "bbyaed", "bbyael", "bbyaelg", "bbyaelm", "bbyaelb", "bbyaels", "bbyaelt", "bbyaelp", "bbyaelh", "bbyaem", "bbyaeb", "bbyaebs", "bbyaes", "bbyaess", "bbyaeng", "bbyaej", "bbyaec", "bbyaek", "bbyaet", "bbyaep", "bbyaeh", "bbeo", "bbeog", "bbeogg", "bbeogs", "bbeon", "bbeonj", "bbeonh", "bbeod", "bbeol", "bbeolg", "bbeolm", "bbeolb", "bbeols", "bbeolt", "bbeolp", "bbeolh", "bbeom", "bbeob", "bbeobs", "bbeos", "bbeoss", "bbeong", "bbeoj", "bbeoc", "bbeok", "bbeot", "bbeop", "bbeoh", "bbe", "bbeg", "bbegg", "bbegs", "bben", "bbenj", "bbenh", "bbed", "bbel", "bbelg", "bbelm", "bbelb", "bbels", "bbelt", "bbelp", "bbelh", "bbem", "bbeb", "bbebs", "bbes"];
  }
});

// node_modules/unidecode/data/xbf.js
var require_xbf = __commonJS({
  "node_modules/unidecode/data/xbf.js"(exports2, module2) {
    module2.exports = ["bbess", "bbeng", "bbej", "bbec", "bbek", "bbet", "bbep", "bbeh", "bbyeo", "bbyeog", "bbyeogg", "bbyeogs", "bbyeon", "bbyeonj", "bbyeonh", "bbyeod", "bbyeol", "bbyeolg", "bbyeolm", "bbyeolb", "bbyeols", "bbyeolt", "bbyeolp", "bbyeolh", "bbyeom", "bbyeob", "bbyeobs", "bbyeos", "bbyeoss", "bbyeong", "bbyeoj", "bbyeoc", "bbyeok", "bbyeot", "bbyeop", "bbyeoh", "bbye", "bbyeg", "bbyegg", "bbyegs", "bbyen", "bbyenj", "bbyenh", "bbyed", "bbyel", "bbyelg", "bbyelm", "bbyelb", "bbyels", "bbyelt", "bbyelp", "bbyelh", "bbyem", "bbyeb", "bbyebs", "bbyes", "bbyess", "bbyeng", "bbyej", "bbyec", "bbyek", "bbyet", "bbyep", "bbyeh", "bbo", "bbog", "bbogg", "bbogs", "bbon", "bbonj", "bbonh", "bbod", "bbol", "bbolg", "bbolm", "bbolb", "bbols", "bbolt", "bbolp", "bbolh", "bbom", "bbob", "bbobs", "bbos", "bboss", "bbong", "bboj", "bboc", "bbok", "bbot", "bbop", "bboh", "bbwa", "bbwag", "bbwagg", "bbwags", "bbwan", "bbwanj", "bbwanh", "bbwad", "bbwal", "bbwalg", "bbwalm", "bbwalb", "bbwals", "bbwalt", "bbwalp", "bbwalh", "bbwam", "bbwab", "bbwabs", "bbwas", "bbwass", "bbwang", "bbwaj", "bbwac", "bbwak", "bbwat", "bbwap", "bbwah", "bbwae", "bbwaeg", "bbwaegg", "bbwaegs", "bbwaen", "bbwaenj", "bbwaenh", "bbwaed", "bbwael", "bbwaelg", "bbwaelm", "bbwaelb", "bbwaels", "bbwaelt", "bbwaelp", "bbwaelh", "bbwaem", "bbwaeb", "bbwaebs", "bbwaes", "bbwaess", "bbwaeng", "bbwaej", "bbwaec", "bbwaek", "bbwaet", "bbwaep", "bbwaeh", "bboe", "bboeg", "bboegg", "bboegs", "bboen", "bboenj", "bboenh", "bboed", "bboel", "bboelg", "bboelm", "bboelb", "bboels", "bboelt", "bboelp", "bboelh", "bboem", "bboeb", "bboebs", "bboes", "bboess", "bboeng", "bboej", "bboec", "bboek", "bboet", "bboep", "bboeh", "bbyo", "bbyog", "bbyogg", "bbyogs", "bbyon", "bbyonj", "bbyonh", "bbyod", "bbyol", "bbyolg", "bbyolm", "bbyolb", "bbyols", "bbyolt", "bbyolp", "bbyolh", "bbyom", "bbyob", "bbyobs", "bbyos", "bbyoss", "bbyong", "bbyoj", "bbyoc", "bbyok", "bbyot", "bbyop", "bbyoh", "bbu", "bbug", "bbugg", "bbugs", "bbun", "bbunj", "bbunh", "bbud", "bbul", "bbulg", "bbulm", "bbulb", "bbuls", "bbult", "bbulp", "bbulh", "bbum", "bbub", "bbubs", "bbus", "bbuss", "bbung", "bbuj", "bbuc", "bbuk", "bbut", "bbup", "bbuh", "bbweo", "bbweog", "bbweogg", "bbweogs", "bbweon", "bbweonj", "bbweonh", "bbweod", "bbweol", "bbweolg", "bbweolm", "bbweolb", "bbweols", "bbweolt", "bbweolp", "bbweolh", "bbweom", "bbweob", "bbweobs", "bbweos", "bbweoss", "bbweong", "bbweoj", "bbweoc"];
  }
});

// node_modules/unidecode/data/xc0.js
var require_xc0 = __commonJS({
  "node_modules/unidecode/data/xc0.js"(exports2, module2) {
    module2.exports = ["bbweok", "bbweot", "bbweop", "bbweoh", "bbwe", "bbweg", "bbwegg", "bbwegs", "bbwen", "bbwenj", "bbwenh", "bbwed", "bbwel", "bbwelg", "bbwelm", "bbwelb", "bbwels", "bbwelt", "bbwelp", "bbwelh", "bbwem", "bbweb", "bbwebs", "bbwes", "bbwess", "bbweng", "bbwej", "bbwec", "bbwek", "bbwet", "bbwep", "bbweh", "bbwi", "bbwig", "bbwigg", "bbwigs", "bbwin", "bbwinj", "bbwinh", "bbwid", "bbwil", "bbwilg", "bbwilm", "bbwilb", "bbwils", "bbwilt", "bbwilp", "bbwilh", "bbwim", "bbwib", "bbwibs", "bbwis", "bbwiss", "bbwing", "bbwij", "bbwic", "bbwik", "bbwit", "bbwip", "bbwih", "bbyu", "bbyug", "bbyugg", "bbyugs", "bbyun", "bbyunj", "bbyunh", "bbyud", "bbyul", "bbyulg", "bbyulm", "bbyulb", "bbyuls", "bbyult", "bbyulp", "bbyulh", "bbyum", "bbyub", "bbyubs", "bbyus", "bbyuss", "bbyung", "bbyuj", "bbyuc", "bbyuk", "bbyut", "bbyup", "bbyuh", "bbeu", "bbeug", "bbeugg", "bbeugs", "bbeun", "bbeunj", "bbeunh", "bbeud", "bbeul", "bbeulg", "bbeulm", "bbeulb", "bbeuls", "bbeult", "bbeulp", "bbeulh", "bbeum", "bbeub", "bbeubs", "bbeus", "bbeuss", "bbeung", "bbeuj", "bbeuc", "bbeuk", "bbeut", "bbeup", "bbeuh", "bbyi", "bbyig", "bbyigg", "bbyigs", "bbyin", "bbyinj", "bbyinh", "bbyid", "bbyil", "bbyilg", "bbyilm", "bbyilb", "bbyils", "bbyilt", "bbyilp", "bbyilh", "bbyim", "bbyib", "bbyibs", "bbyis", "bbyiss", "bbying", "bbyij", "bbyic", "bbyik", "bbyit", "bbyip", "bbyih", "bbi", "bbig", "bbigg", "bbigs", "bbin", "bbinj", "bbinh", "bbid", "bbil", "bbilg", "bbilm", "bbilb", "bbils", "bbilt", "bbilp", "bbilh", "bbim", "bbib", "bbibs", "bbis", "bbiss", "bbing", "bbij", "bbic", "bbik", "bbit", "bbip", "bbih", "sa", "sag", "sagg", "sags", "san", "sanj", "sanh", "sad", "sal", "salg", "salm", "salb", "sals", "salt", "salp", "salh", "sam", "sab", "sabs", "sas", "sass", "sang", "saj", "sac", "sak", "sat", "sap", "sah", "sae", "saeg", "saegg", "saegs", "saen", "saenj", "saenh", "saed", "sael", "saelg", "saelm", "saelb", "saels", "saelt", "saelp", "saelh", "saem", "saeb", "saebs", "saes", "saess", "saeng", "saej", "saec", "saek", "saet", "saep", "saeh", "sya", "syag", "syagg", "syags", "syan", "syanj", "syanh", "syad", "syal", "syalg", "syalm", "syalb", "syals", "syalt", "syalp", "syalh", "syam", "syab", "syabs", "syas", "syass", "syang", "syaj", "syac", "syak", "syat", "syap", "syah"];
  }
});

// node_modules/unidecode/data/xc1.js
var require_xc1 = __commonJS({
  "node_modules/unidecode/data/xc1.js"(exports2, module2) {
    module2.exports = ["syae", "syaeg", "syaegg", "syaegs", "syaen", "syaenj", "syaenh", "syaed", "syael", "syaelg", "syaelm", "syaelb", "syaels", "syaelt", "syaelp", "syaelh", "syaem", "syaeb", "syaebs", "syaes", "syaess", "syaeng", "syaej", "syaec", "syaek", "syaet", "syaep", "syaeh", "seo", "seog", "seogg", "seogs", "seon", "seonj", "seonh", "seod", "seol", "seolg", "seolm", "seolb", "seols", "seolt", "seolp", "seolh", "seom", "seob", "seobs", "seos", "seoss", "seong", "seoj", "seoc", "seok", "seot", "seop", "seoh", "se", "seg", "segg", "segs", "sen", "senj", "senh", "sed", "sel", "selg", "selm", "selb", "sels", "selt", "selp", "selh", "sem", "seb", "sebs", "ses", "sess", "seng", "sej", "sec", "sek", "set", "sep", "seh", "syeo", "syeog", "syeogg", "syeogs", "syeon", "syeonj", "syeonh", "syeod", "syeol", "syeolg", "syeolm", "syeolb", "syeols", "syeolt", "syeolp", "syeolh", "syeom", "syeob", "syeobs", "syeos", "syeoss", "syeong", "syeoj", "syeoc", "syeok", "syeot", "syeop", "syeoh", "sye", "syeg", "syegg", "syegs", "syen", "syenj", "syenh", "syed", "syel", "syelg", "syelm", "syelb", "syels", "syelt", "syelp", "syelh", "syem", "syeb", "syebs", "syes", "syess", "syeng", "syej", "syec", "syek", "syet", "syep", "syeh", "so", "sog", "sogg", "sogs", "son", "sonj", "sonh", "sod", "sol", "solg", "solm", "solb", "sols", "solt", "solp", "solh", "som", "sob", "sobs", "sos", "soss", "song", "soj", "soc", "sok", "sot", "sop", "soh", "swa", "swag", "swagg", "swags", "swan", "swanj", "swanh", "swad", "swal", "swalg", "swalm", "swalb", "swals", "swalt", "swalp", "swalh", "swam", "swab", "swabs", "swas", "swass", "swang", "swaj", "swac", "swak", "swat", "swap", "swah", "swae", "swaeg", "swaegg", "swaegs", "swaen", "swaenj", "swaenh", "swaed", "swael", "swaelg", "swaelm", "swaelb", "swaels", "swaelt", "swaelp", "swaelh", "swaem", "swaeb", "swaebs", "swaes", "swaess", "swaeng", "swaej", "swaec", "swaek", "swaet", "swaep", "swaeh", "soe", "soeg", "soegg", "soegs", "soen", "soenj", "soenh", "soed", "soel", "soelg", "soelm", "soelb", "soels", "soelt", "soelp", "soelh", "soem", "soeb", "soebs", "soes", "soess", "soeng", "soej", "soec", "soek", "soet", "soep", "soeh", "syo", "syog", "syogg", "syogs"];
  }
});

// node_modules/unidecode/data/xc2.js
var require_xc2 = __commonJS({
  "node_modules/unidecode/data/xc2.js"(exports2, module2) {
    module2.exports = ["syon", "syonj", "syonh", "syod", "syol", "syolg", "syolm", "syolb", "syols", "syolt", "syolp", "syolh", "syom", "syob", "syobs", "syos", "syoss", "syong", "syoj", "syoc", "syok", "syot", "syop", "syoh", "su", "sug", "sugg", "sugs", "sun", "sunj", "sunh", "sud", "sul", "sulg", "sulm", "sulb", "suls", "sult", "sulp", "sulh", "sum", "sub", "subs", "sus", "suss", "sung", "suj", "suc", "suk", "sut", "sup", "suh", "sweo", "sweog", "sweogg", "sweogs", "sweon", "sweonj", "sweonh", "sweod", "sweol", "sweolg", "sweolm", "sweolb", "sweols", "sweolt", "sweolp", "sweolh", "sweom", "sweob", "sweobs", "sweos", "sweoss", "sweong", "sweoj", "sweoc", "sweok", "sweot", "sweop", "sweoh", "swe", "sweg", "swegg", "swegs", "swen", "swenj", "swenh", "swed", "swel", "swelg", "swelm", "swelb", "swels", "swelt", "swelp", "swelh", "swem", "sweb", "swebs", "swes", "swess", "sweng", "swej", "swec", "swek", "swet", "swep", "sweh", "swi", "swig", "swigg", "swigs", "swin", "swinj", "swinh", "swid", "swil", "swilg", "swilm", "swilb", "swils", "swilt", "swilp", "swilh", "swim", "swib", "swibs", "swis", "swiss", "swing", "swij", "swic", "swik", "swit", "swip", "swih", "syu", "syug", "syugg", "syugs", "syun", "syunj", "syunh", "syud", "syul", "syulg", "syulm", "syulb", "syuls", "syult", "syulp", "syulh", "syum", "syub", "syubs", "syus", "syuss", "syung", "syuj", "syuc", "syuk", "syut", "syup", "syuh", "seu", "seug", "seugg", "seugs", "seun", "seunj", "seunh", "seud", "seul", "seulg", "seulm", "seulb", "seuls", "seult", "seulp", "seulh", "seum", "seub", "seubs", "seus", "seuss", "seung", "seuj", "seuc", "seuk", "seut", "seup", "seuh", "syi", "syig", "syigg", "syigs", "syin", "syinj", "syinh", "syid", "syil", "syilg", "syilm", "syilb", "syils", "syilt", "syilp", "syilh", "syim", "syib", "syibs", "syis", "syiss", "sying", "syij", "syic", "syik", "syit", "syip", "syih", "si", "sig", "sigg", "sigs", "sin", "sinj", "sinh", "sid", "sil", "silg", "silm", "silb", "sils", "silt", "silp", "silh", "sim", "sib", "sibs", "sis", "siss", "sing", "sij", "sic", "sik", "sit", "sip", "sih", "ssa", "ssag", "ssagg", "ssags", "ssan", "ssanj", "ssanh", "ssad"];
  }
});

// node_modules/unidecode/data/xc3.js
var require_xc3 = __commonJS({
  "node_modules/unidecode/data/xc3.js"(exports2, module2) {
    module2.exports = ["ssal", "ssalg", "ssalm", "ssalb", "ssals", "ssalt", "ssalp", "ssalh", "ssam", "ssab", "ssabs", "ssas", "ssass", "ssang", "ssaj", "ssac", "ssak", "ssat", "ssap", "ssah", "ssae", "ssaeg", "ssaegg", "ssaegs", "ssaen", "ssaenj", "ssaenh", "ssaed", "ssael", "ssaelg", "ssaelm", "ssaelb", "ssaels", "ssaelt", "ssaelp", "ssaelh", "ssaem", "ssaeb", "ssaebs", "ssaes", "ssaess", "ssaeng", "ssaej", "ssaec", "ssaek", "ssaet", "ssaep", "ssaeh", "ssya", "ssyag", "ssyagg", "ssyags", "ssyan", "ssyanj", "ssyanh", "ssyad", "ssyal", "ssyalg", "ssyalm", "ssyalb", "ssyals", "ssyalt", "ssyalp", "ssyalh", "ssyam", "ssyab", "ssyabs", "ssyas", "ssyass", "ssyang", "ssyaj", "ssyac", "ssyak", "ssyat", "ssyap", "ssyah", "ssyae", "ssyaeg", "ssyaegg", "ssyaegs", "ssyaen", "ssyaenj", "ssyaenh", "ssyaed", "ssyael", "ssyaelg", "ssyaelm", "ssyaelb", "ssyaels", "ssyaelt", "ssyaelp", "ssyaelh", "ssyaem", "ssyaeb", "ssyaebs", "ssyaes", "ssyaess", "ssyaeng", "ssyaej", "ssyaec", "ssyaek", "ssyaet", "ssyaep", "ssyaeh", "sseo", "sseog", "sseogg", "sseogs", "sseon", "sseonj", "sseonh", "sseod", "sseol", "sseolg", "sseolm", "sseolb", "sseols", "sseolt", "sseolp", "sseolh", "sseom", "sseob", "sseobs", "sseos", "sseoss", "sseong", "sseoj", "sseoc", "sseok", "sseot", "sseop", "sseoh", "sse", "sseg", "ssegg", "ssegs", "ssen", "ssenj", "ssenh", "ssed", "ssel", "sselg", "sselm", "sselb", "ssels", "sselt", "sselp", "sselh", "ssem", "sseb", "ssebs", "sses", "ssess", "sseng", "ssej", "ssec", "ssek", "sset", "ssep", "sseh", "ssyeo", "ssyeog", "ssyeogg", "ssyeogs", "ssyeon", "ssyeonj", "ssyeonh", "ssyeod", "ssyeol", "ssyeolg", "ssyeolm", "ssyeolb", "ssyeols", "ssyeolt", "ssyeolp", "ssyeolh", "ssyeom", "ssyeob", "ssyeobs", "ssyeos", "ssyeoss", "ssyeong", "ssyeoj", "ssyeoc", "ssyeok", "ssyeot", "ssyeop", "ssyeoh", "ssye", "ssyeg", "ssyegg", "ssyegs", "ssyen", "ssyenj", "ssyenh", "ssyed", "ssyel", "ssyelg", "ssyelm", "ssyelb", "ssyels", "ssyelt", "ssyelp", "ssyelh", "ssyem", "ssyeb", "ssyebs", "ssyes", "ssyess", "ssyeng", "ssyej", "ssyec", "ssyek", "ssyet", "ssyep", "ssyeh", "sso", "ssog", "ssogg", "ssogs", "sson", "ssonj", "ssonh", "ssod", "ssol", "ssolg", "ssolm", "ssolb", "ssols", "ssolt", "ssolp", "ssolh", "ssom", "ssob", "ssobs", "ssos", "ssoss", "ssong", "ssoj", "ssoc", "ssok", "ssot", "ssop", "ssoh", "sswa", "sswag", "sswagg", "sswags", "sswan", "sswanj", "sswanh", "sswad", "sswal", "sswalg", "sswalm", "sswalb"];
  }
});

// node_modules/unidecode/data/xc4.js
var require_xc4 = __commonJS({
  "node_modules/unidecode/data/xc4.js"(exports2, module2) {
    module2.exports = ["sswals", "sswalt", "sswalp", "sswalh", "sswam", "sswab", "sswabs", "sswas", "sswass", "sswang", "sswaj", "sswac", "sswak", "sswat", "sswap", "sswah", "sswae", "sswaeg", "sswaegg", "sswaegs", "sswaen", "sswaenj", "sswaenh", "sswaed", "sswael", "sswaelg", "sswaelm", "sswaelb", "sswaels", "sswaelt", "sswaelp", "sswaelh", "sswaem", "sswaeb", "sswaebs", "sswaes", "sswaess", "sswaeng", "sswaej", "sswaec", "sswaek", "sswaet", "sswaep", "sswaeh", "ssoe", "ssoeg", "ssoegg", "ssoegs", "ssoen", "ssoenj", "ssoenh", "ssoed", "ssoel", "ssoelg", "ssoelm", "ssoelb", "ssoels", "ssoelt", "ssoelp", "ssoelh", "ssoem", "ssoeb", "ssoebs", "ssoes", "ssoess", "ssoeng", "ssoej", "ssoec", "ssoek", "ssoet", "ssoep", "ssoeh", "ssyo", "ssyog", "ssyogg", "ssyogs", "ssyon", "ssyonj", "ssyonh", "ssyod", "ssyol", "ssyolg", "ssyolm", "ssyolb", "ssyols", "ssyolt", "ssyolp", "ssyolh", "ssyom", "ssyob", "ssyobs", "ssyos", "ssyoss", "ssyong", "ssyoj", "ssyoc", "ssyok", "ssyot", "ssyop", "ssyoh", "ssu", "ssug", "ssugg", "ssugs", "ssun", "ssunj", "ssunh", "ssud", "ssul", "ssulg", "ssulm", "ssulb", "ssuls", "ssult", "ssulp", "ssulh", "ssum", "ssub", "ssubs", "ssus", "ssuss", "ssung", "ssuj", "ssuc", "ssuk", "ssut", "ssup", "ssuh", "ssweo", "ssweog", "ssweogg", "ssweogs", "ssweon", "ssweonj", "ssweonh", "ssweod", "ssweol", "ssweolg", "ssweolm", "ssweolb", "ssweols", "ssweolt", "ssweolp", "ssweolh", "ssweom", "ssweob", "ssweobs", "ssweos", "ssweoss", "ssweong", "ssweoj", "ssweoc", "ssweok", "ssweot", "ssweop", "ssweoh", "sswe", "ssweg", "sswegg", "sswegs", "sswen", "sswenj", "sswenh", "sswed", "sswel", "sswelg", "sswelm", "sswelb", "sswels", "sswelt", "sswelp", "sswelh", "sswem", "ssweb", "sswebs", "sswes", "sswess", "ssweng", "sswej", "sswec", "sswek", "sswet", "sswep", "ssweh", "sswi", "sswig", "sswigg", "sswigs", "sswin", "sswinj", "sswinh", "sswid", "sswil", "sswilg", "sswilm", "sswilb", "sswils", "sswilt", "sswilp", "sswilh", "sswim", "sswib", "sswibs", "sswis", "sswiss", "sswing", "sswij", "sswic", "sswik", "sswit", "sswip", "sswih", "ssyu", "ssyug", "ssyugg", "ssyugs", "ssyun", "ssyunj", "ssyunh", "ssyud", "ssyul", "ssyulg", "ssyulm", "ssyulb", "ssyuls", "ssyult", "ssyulp", "ssyulh", "ssyum", "ssyub", "ssyubs", "ssyus", "ssyuss", "ssyung", "ssyuj", "ssyuc", "ssyuk", "ssyut", "ssyup", "ssyuh", "sseu", "sseug", "sseugg", "sseugs", "sseun", "sseunj", "sseunh", "sseud", "sseul", "sseulg", "sseulm", "sseulb", "sseuls", "sseult", "sseulp", "sseulh"];
  }
});

// node_modules/unidecode/data/xc5.js
var require_xc5 = __commonJS({
  "node_modules/unidecode/data/xc5.js"(exports2, module2) {
    module2.exports = ["sseum", "sseub", "sseubs", "sseus", "sseuss", "sseung", "sseuj", "sseuc", "sseuk", "sseut", "sseup", "sseuh", "ssyi", "ssyig", "ssyigg", "ssyigs", "ssyin", "ssyinj", "ssyinh", "ssyid", "ssyil", "ssyilg", "ssyilm", "ssyilb", "ssyils", "ssyilt", "ssyilp", "ssyilh", "ssyim", "ssyib", "ssyibs", "ssyis", "ssyiss", "ssying", "ssyij", "ssyic", "ssyik", "ssyit", "ssyip", "ssyih", "ssi", "ssig", "ssigg", "ssigs", "ssin", "ssinj", "ssinh", "ssid", "ssil", "ssilg", "ssilm", "ssilb", "ssils", "ssilt", "ssilp", "ssilh", "ssim", "ssib", "ssibs", "ssis", "ssiss", "ssing", "ssij", "ssic", "ssik", "ssit", "ssip", "ssih", "a", "ag", "agg", "ags", "an", "anj", "anh", "ad", "al", "alg", "alm", "alb", "als", "alt", "alp", "alh", "am", "ab", "abs", "as", "ass", "ang", "aj", "ac", "ak", "at", "ap", "ah", "ae", "aeg", "aegg", "aegs", "aen", "aenj", "aenh", "aed", "ael", "aelg", "aelm", "aelb", "aels", "aelt", "aelp", "aelh", "aem", "aeb", "aebs", "aes", "aess", "aeng", "aej", "aec", "aek", "aet", "aep", "aeh", "ya", "yag", "yagg", "yags", "yan", "yanj", "yanh", "yad", "yal", "yalg", "yalm", "yalb", "yals", "yalt", "yalp", "yalh", "yam", "yab", "yabs", "yas", "yass", "yang", "yaj", "yac", "yak", "yat", "yap", "yah", "yae", "yaeg", "yaegg", "yaegs", "yaen", "yaenj", "yaenh", "yaed", "yael", "yaelg", "yaelm", "yaelb", "yaels", "yaelt", "yaelp", "yaelh", "yaem", "yaeb", "yaebs", "yaes", "yaess", "yaeng", "yaej", "yaec", "yaek", "yaet", "yaep", "yaeh", "eo", "eog", "eogg", "eogs", "eon", "eonj", "eonh", "eod", "eol", "eolg", "eolm", "eolb", "eols", "eolt", "eolp", "eolh", "eom", "eob", "eobs", "eos", "eoss", "eong", "eoj", "eoc", "eok", "eot", "eop", "eoh", "e", "eg", "egg", "egs", "en", "enj", "enh", "ed", "el", "elg", "elm", "elb", "els", "elt", "elp", "elh", "em", "eb", "ebs", "es", "ess", "eng", "ej", "ec", "ek", "et", "ep", "eh", "yeo", "yeog", "yeogg", "yeogs", "yeon", "yeonj", "yeonh", "yeod", "yeol", "yeolg", "yeolm", "yeolb", "yeols", "yeolt", "yeolp", "yeolh", "yeom", "yeob", "yeobs", "yeos"];
  }
});

// node_modules/unidecode/data/xc6.js
var require_xc6 = __commonJS({
  "node_modules/unidecode/data/xc6.js"(exports2, module2) {
    module2.exports = ["yeoss", "yeong", "yeoj", "yeoc", "yeok", "yeot", "yeop", "yeoh", "ye", "yeg", "yegg", "yegs", "yen", "yenj", "yenh", "yed", "yel", "yelg", "yelm", "yelb", "yels", "yelt", "yelp", "yelh", "yem", "yeb", "yebs", "yes", "yess", "yeng", "yej", "yec", "yek", "yet", "yep", "yeh", "o", "og", "ogg", "ogs", "on", "onj", "onh", "od", "ol", "olg", "olm", "olb", "ols", "olt", "olp", "olh", "om", "ob", "obs", "os", "oss", "ong", "oj", "oc", "ok", "ot", "op", "oh", "wa", "wag", "wagg", "wags", "wan", "wanj", "wanh", "wad", "wal", "walg", "walm", "walb", "wals", "walt", "walp", "walh", "wam", "wab", "wabs", "was", "wass", "wang", "waj", "wac", "wak", "wat", "wap", "wah", "wae", "waeg", "waegg", "waegs", "waen", "waenj", "waenh", "waed", "wael", "waelg", "waelm", "waelb", "waels", "waelt", "waelp", "waelh", "waem", "waeb", "waebs", "waes", "waess", "waeng", "waej", "waec", "waek", "waet", "waep", "waeh", "oe", "oeg", "oegg", "oegs", "oen", "oenj", "oenh", "oed", "oel", "oelg", "oelm", "oelb", "oels", "oelt", "oelp", "oelh", "oem", "oeb", "oebs", "oes", "oess", "oeng", "oej", "oec", "oek", "oet", "oep", "oeh", "yo", "yog", "yogg", "yogs", "yon", "yonj", "yonh", "yod", "yol", "yolg", "yolm", "yolb", "yols", "yolt", "yolp", "yolh", "yom", "yob", "yobs", "yos", "yoss", "yong", "yoj", "yoc", "yok", "yot", "yop", "yoh", "u", "ug", "ugg", "ugs", "un", "unj", "unh", "ud", "ul", "ulg", "ulm", "ulb", "uls", "ult", "ulp", "ulh", "um", "ub", "ubs", "us", "uss", "ung", "uj", "uc", "uk", "ut", "up", "uh", "weo", "weog", "weogg", "weogs", "weon", "weonj", "weonh", "weod", "weol", "weolg", "weolm", "weolb", "weols", "weolt", "weolp", "weolh", "weom", "weob", "weobs", "weos", "weoss", "weong", "weoj", "weoc", "weok", "weot", "weop", "weoh", "we", "weg", "wegg", "wegs", "wen", "wenj", "wenh", "wed", "wel", "welg", "welm", "welb", "wels", "welt", "welp", "welh", "wem", "web", "webs", "wes", "wess", "weng", "wej", "wec"];
  }
});

// node_modules/unidecode/data/xc7.js
var require_xc7 = __commonJS({
  "node_modules/unidecode/data/xc7.js"(exports2, module2) {
    module2.exports = ["wek", "wet", "wep", "weh", "wi", "wig", "wigg", "wigs", "win", "winj", "winh", "wid", "wil", "wilg", "wilm", "wilb", "wils", "wilt", "wilp", "wilh", "wim", "wib", "wibs", "wis", "wiss", "wing", "wij", "wic", "wik", "wit", "wip", "wih", "yu", "yug", "yugg", "yugs", "yun", "yunj", "yunh", "yud", "yul", "yulg", "yulm", "yulb", "yuls", "yult", "yulp", "yulh", "yum", "yub", "yubs", "yus", "yuss", "yung", "yuj", "yuc", "yuk", "yut", "yup", "yuh", "eu", "eug", "eugg", "eugs", "eun", "eunj", "eunh", "eud", "eul", "eulg", "eulm", "eulb", "euls", "eult", "eulp", "eulh", "eum", "eub", "eubs", "eus", "euss", "eung", "euj", "euc", "euk", "eut", "eup", "euh", "yi", "yig", "yigg", "yigs", "yin", "yinj", "yinh", "yid", "yil", "yilg", "yilm", "yilb", "yils", "yilt", "yilp", "yilh", "yim", "yib", "yibs", "yis", "yiss", "ying", "yij", "yic", "yik", "yit", "yip", "yih", "i", "ig", "igg", "igs", "in", "inj", "inh", "id", "il", "ilg", "ilm", "ilb", "ils", "ilt", "ilp", "ilh", "im", "ib", "ibs", "is", "iss", "ing", "ij", "ic", "ik", "it", "ip", "ih", "ja", "jag", "jagg", "jags", "jan", "janj", "janh", "jad", "jal", "jalg", "jalm", "jalb", "jals", "jalt", "jalp", "jalh", "jam", "jab", "jabs", "jas", "jass", "jang", "jaj", "jac", "jak", "jat", "jap", "jah", "jae", "jaeg", "jaegg", "jaegs", "jaen", "jaenj", "jaenh", "jaed", "jael", "jaelg", "jaelm", "jaelb", "jaels", "jaelt", "jaelp", "jaelh", "jaem", "jaeb", "jaebs", "jaes", "jaess", "jaeng", "jaej", "jaec", "jaek", "jaet", "jaep", "jaeh", "jya", "jyag", "jyagg", "jyags", "jyan", "jyanj", "jyanh", "jyad", "jyal", "jyalg", "jyalm", "jyalb", "jyals", "jyalt", "jyalp", "jyalh", "jyam", "jyab", "jyabs", "jyas", "jyass", "jyang", "jyaj", "jyac", "jyak", "jyat", "jyap", "jyah", "jyae", "jyaeg", "jyaegg", "jyaegs", "jyaen", "jyaenj", "jyaenh", "jyaed", "jyael", "jyaelg", "jyaelm", "jyaelb", "jyaels", "jyaelt", "jyaelp", "jyaelh", "jyaem", "jyaeb", "jyaebs", "jyaes", "jyaess", "jyaeng", "jyaej", "jyaec", "jyaek", "jyaet", "jyaep", "jyaeh"];
  }
});

// node_modules/unidecode/data/xc8.js
var require_xc8 = __commonJS({
  "node_modules/unidecode/data/xc8.js"(exports2, module2) {
    module2.exports = ["jeo", "jeog", "jeogg", "jeogs", "jeon", "jeonj", "jeonh", "jeod", "jeol", "jeolg", "jeolm", "jeolb", "jeols", "jeolt", "jeolp", "jeolh", "jeom", "jeob", "jeobs", "jeos", "jeoss", "jeong", "jeoj", "jeoc", "jeok", "jeot", "jeop", "jeoh", "je", "jeg", "jegg", "jegs", "jen", "jenj", "jenh", "jed", "jel", "jelg", "jelm", "jelb", "jels", "jelt", "jelp", "jelh", "jem", "jeb", "jebs", "jes", "jess", "jeng", "jej", "jec", "jek", "jet", "jep", "jeh", "jyeo", "jyeog", "jyeogg", "jyeogs", "jyeon", "jyeonj", "jyeonh", "jyeod", "jyeol", "jyeolg", "jyeolm", "jyeolb", "jyeols", "jyeolt", "jyeolp", "jyeolh", "jyeom", "jyeob", "jyeobs", "jyeos", "jyeoss", "jyeong", "jyeoj", "jyeoc", "jyeok", "jyeot", "jyeop", "jyeoh", "jye", "jyeg", "jyegg", "jyegs", "jyen", "jyenj", "jyenh", "jyed", "jyel", "jyelg", "jyelm", "jyelb", "jyels", "jyelt", "jyelp", "jyelh", "jyem", "jyeb", "jyebs", "jyes", "jyess", "jyeng", "jyej", "jyec", "jyek", "jyet", "jyep", "jyeh", "jo", "jog", "jogg", "jogs", "jon", "jonj", "jonh", "jod", "jol", "jolg", "jolm", "jolb", "jols", "jolt", "jolp", "jolh", "jom", "job", "jobs", "jos", "joss", "jong", "joj", "joc", "jok", "jot", "jop", "joh", "jwa", "jwag", "jwagg", "jwags", "jwan", "jwanj", "jwanh", "jwad", "jwal", "jwalg", "jwalm", "jwalb", "jwals", "jwalt", "jwalp", "jwalh", "jwam", "jwab", "jwabs", "jwas", "jwass", "jwang", "jwaj", "jwac", "jwak", "jwat", "jwap", "jwah", "jwae", "jwaeg", "jwaegg", "jwaegs", "jwaen", "jwaenj", "jwaenh", "jwaed", "jwael", "jwaelg", "jwaelm", "jwaelb", "jwaels", "jwaelt", "jwaelp", "jwaelh", "jwaem", "jwaeb", "jwaebs", "jwaes", "jwaess", "jwaeng", "jwaej", "jwaec", "jwaek", "jwaet", "jwaep", "jwaeh", "joe", "joeg", "joegg", "joegs", "joen", "joenj", "joenh", "joed", "joel", "joelg", "joelm", "joelb", "joels", "joelt", "joelp", "joelh", "joem", "joeb", "joebs", "joes", "joess", "joeng", "joej", "joec", "joek", "joet", "joep", "joeh", "jyo", "jyog", "jyogg", "jyogs", "jyon", "jyonj", "jyonh", "jyod", "jyol", "jyolg", "jyolm", "jyolb", "jyols", "jyolt", "jyolp", "jyolh", "jyom", "jyob", "jyobs", "jyos", "jyoss", "jyong", "jyoj", "jyoc", "jyok", "jyot", "jyop", "jyoh", "ju", "jug", "jugg", "jugs"];
  }
});

// node_modules/unidecode/data/xc9.js
var require_xc9 = __commonJS({
  "node_modules/unidecode/data/xc9.js"(exports2, module2) {
    module2.exports = ["jun", "junj", "junh", "jud", "jul", "julg", "julm", "julb", "juls", "jult", "julp", "julh", "jum", "jub", "jubs", "jus", "juss", "jung", "juj", "juc", "juk", "jut", "jup", "juh", "jweo", "jweog", "jweogg", "jweogs", "jweon", "jweonj", "jweonh", "jweod", "jweol", "jweolg", "jweolm", "jweolb", "jweols", "jweolt", "jweolp", "jweolh", "jweom", "jweob", "jweobs", "jweos", "jweoss", "jweong", "jweoj", "jweoc", "jweok", "jweot", "jweop", "jweoh", "jwe", "jweg", "jwegg", "jwegs", "jwen", "jwenj", "jwenh", "jwed", "jwel", "jwelg", "jwelm", "jwelb", "jwels", "jwelt", "jwelp", "jwelh", "jwem", "jweb", "jwebs", "jwes", "jwess", "jweng", "jwej", "jwec", "jwek", "jwet", "jwep", "jweh", "jwi", "jwig", "jwigg", "jwigs", "jwin", "jwinj", "jwinh", "jwid", "jwil", "jwilg", "jwilm", "jwilb", "jwils", "jwilt", "jwilp", "jwilh", "jwim", "jwib", "jwibs", "jwis", "jwiss", "jwing", "jwij", "jwic", "jwik", "jwit", "jwip", "jwih", "jyu", "jyug", "jyugg", "jyugs", "jyun", "jyunj", "jyunh", "jyud", "jyul", "jyulg", "jyulm", "jyulb", "jyuls", "jyult", "jyulp", "jyulh", "jyum", "jyub", "jyubs", "jyus", "jyuss", "jyung", "jyuj", "jyuc", "jyuk", "jyut", "jyup", "jyuh", "jeu", "jeug", "jeugg", "jeugs", "jeun", "jeunj", "jeunh", "jeud", "jeul", "jeulg", "jeulm", "jeulb", "jeuls", "jeult", "jeulp", "jeulh", "jeum", "jeub", "jeubs", "jeus", "jeuss", "jeung", "jeuj", "jeuc", "jeuk", "jeut", "jeup", "jeuh", "jyi", "jyig", "jyigg", "jyigs", "jyin", "jyinj", "jyinh", "jyid", "jyil", "jyilg", "jyilm", "jyilb", "jyils", "jyilt", "jyilp", "jyilh", "jyim", "jyib", "jyibs", "jyis", "jyiss", "jying", "jyij", "jyic", "jyik", "jyit", "jyip", "jyih", "ji", "jig", "jigg", "jigs", "jin", "jinj", "jinh", "jid", "jil", "jilg", "jilm", "jilb", "jils", "jilt", "jilp", "jilh", "jim", "jib", "jibs", "jis", "jiss", "jing", "jij", "jic", "jik", "jit", "jip", "jih", "jja", "jjag", "jjagg", "jjags", "jjan", "jjanj", "jjanh", "jjad", "jjal", "jjalg", "jjalm", "jjalb", "jjals", "jjalt", "jjalp", "jjalh", "jjam", "jjab", "jjabs", "jjas", "jjass", "jjang", "jjaj", "jjac", "jjak", "jjat", "jjap", "jjah", "jjae", "jjaeg", "jjaegg", "jjaegs", "jjaen", "jjaenj", "jjaenh", "jjaed"];
  }
});

// node_modules/unidecode/data/xca.js
var require_xca = __commonJS({
  "node_modules/unidecode/data/xca.js"(exports2, module2) {
    module2.exports = ["jjael", "jjaelg", "jjaelm", "jjaelb", "jjaels", "jjaelt", "jjaelp", "jjaelh", "jjaem", "jjaeb", "jjaebs", "jjaes", "jjaess", "jjaeng", "jjaej", "jjaec", "jjaek", "jjaet", "jjaep", "jjaeh", "jjya", "jjyag", "jjyagg", "jjyags", "jjyan", "jjyanj", "jjyanh", "jjyad", "jjyal", "jjyalg", "jjyalm", "jjyalb", "jjyals", "jjyalt", "jjyalp", "jjyalh", "jjyam", "jjyab", "jjyabs", "jjyas", "jjyass", "jjyang", "jjyaj", "jjyac", "jjyak", "jjyat", "jjyap", "jjyah", "jjyae", "jjyaeg", "jjyaegg", "jjyaegs", "jjyaen", "jjyaenj", "jjyaenh", "jjyaed", "jjyael", "jjyaelg", "jjyaelm", "jjyaelb", "jjyaels", "jjyaelt", "jjyaelp", "jjyaelh", "jjyaem", "jjyaeb", "jjyaebs", "jjyaes", "jjyaess", "jjyaeng", "jjyaej", "jjyaec", "jjyaek", "jjyaet", "jjyaep", "jjyaeh", "jjeo", "jjeog", "jjeogg", "jjeogs", "jjeon", "jjeonj", "jjeonh", "jjeod", "jjeol", "jjeolg", "jjeolm", "jjeolb", "jjeols", "jjeolt", "jjeolp", "jjeolh", "jjeom", "jjeob", "jjeobs", "jjeos", "jjeoss", "jjeong", "jjeoj", "jjeoc", "jjeok", "jjeot", "jjeop", "jjeoh", "jje", "jjeg", "jjegg", "jjegs", "jjen", "jjenj", "jjenh", "jjed", "jjel", "jjelg", "jjelm", "jjelb", "jjels", "jjelt", "jjelp", "jjelh", "jjem", "jjeb", "jjebs", "jjes", "jjess", "jjeng", "jjej", "jjec", "jjek", "jjet", "jjep", "jjeh", "jjyeo", "jjyeog", "jjyeogg", "jjyeogs", "jjyeon", "jjyeonj", "jjyeonh", "jjyeod", "jjyeol", "jjyeolg", "jjyeolm", "jjyeolb", "jjyeols", "jjyeolt", "jjyeolp", "jjyeolh", "jjyeom", "jjyeob", "jjyeobs", "jjyeos", "jjyeoss", "jjyeong", "jjyeoj", "jjyeoc", "jjyeok", "jjyeot", "jjyeop", "jjyeoh", "jjye", "jjyeg", "jjyegg", "jjyegs", "jjyen", "jjyenj", "jjyenh", "jjyed", "jjyel", "jjyelg", "jjyelm", "jjyelb", "jjyels", "jjyelt", "jjyelp", "jjyelh", "jjyem", "jjyeb", "jjyebs", "jjyes", "jjyess", "jjyeng", "jjyej", "jjyec", "jjyek", "jjyet", "jjyep", "jjyeh", "jjo", "jjog", "jjogg", "jjogs", "jjon", "jjonj", "jjonh", "jjod", "jjol", "jjolg", "jjolm", "jjolb", "jjols", "jjolt", "jjolp", "jjolh", "jjom", "jjob", "jjobs", "jjos", "jjoss", "jjong", "jjoj", "jjoc", "jjok", "jjot", "jjop", "jjoh", "jjwa", "jjwag", "jjwagg", "jjwags", "jjwan", "jjwanj", "jjwanh", "jjwad", "jjwal", "jjwalg", "jjwalm", "jjwalb", "jjwals", "jjwalt", "jjwalp", "jjwalh", "jjwam", "jjwab", "jjwabs", "jjwas", "jjwass", "jjwang", "jjwaj", "jjwac", "jjwak", "jjwat", "jjwap", "jjwah", "jjwae", "jjwaeg", "jjwaegg", "jjwaegs", "jjwaen", "jjwaenj", "jjwaenh", "jjwaed", "jjwael", "jjwaelg", "jjwaelm", "jjwaelb"];
  }
});

// node_modules/unidecode/data/xcb.js
var require_xcb = __commonJS({
  "node_modules/unidecode/data/xcb.js"(exports2, module2) {
    module2.exports = ["jjwaels", "jjwaelt", "jjwaelp", "jjwaelh", "jjwaem", "jjwaeb", "jjwaebs", "jjwaes", "jjwaess", "jjwaeng", "jjwaej", "jjwaec", "jjwaek", "jjwaet", "jjwaep", "jjwaeh", "jjoe", "jjoeg", "jjoegg", "jjoegs", "jjoen", "jjoenj", "jjoenh", "jjoed", "jjoel", "jjoelg", "jjoelm", "jjoelb", "jjoels", "jjoelt", "jjoelp", "jjoelh", "jjoem", "jjoeb", "jjoebs", "jjoes", "jjoess", "jjoeng", "jjoej", "jjoec", "jjoek", "jjoet", "jjoep", "jjoeh", "jjyo", "jjyog", "jjyogg", "jjyogs", "jjyon", "jjyonj", "jjyonh", "jjyod", "jjyol", "jjyolg", "jjyolm", "jjyolb", "jjyols", "jjyolt", "jjyolp", "jjyolh", "jjyom", "jjyob", "jjyobs", "jjyos", "jjyoss", "jjyong", "jjyoj", "jjyoc", "jjyok", "jjyot", "jjyop", "jjyoh", "jju", "jjug", "jjugg", "jjugs", "jjun", "jjunj", "jjunh", "jjud", "jjul", "jjulg", "jjulm", "jjulb", "jjuls", "jjult", "jjulp", "jjulh", "jjum", "jjub", "jjubs", "jjus", "jjuss", "jjung", "jjuj", "jjuc", "jjuk", "jjut", "jjup", "jjuh", "jjweo", "jjweog", "jjweogg", "jjweogs", "jjweon", "jjweonj", "jjweonh", "jjweod", "jjweol", "jjweolg", "jjweolm", "jjweolb", "jjweols", "jjweolt", "jjweolp", "jjweolh", "jjweom", "jjweob", "jjweobs", "jjweos", "jjweoss", "jjweong", "jjweoj", "jjweoc", "jjweok", "jjweot", "jjweop", "jjweoh", "jjwe", "jjweg", "jjwegg", "jjwegs", "jjwen", "jjwenj", "jjwenh", "jjwed", "jjwel", "jjwelg", "jjwelm", "jjwelb", "jjwels", "jjwelt", "jjwelp", "jjwelh", "jjwem", "jjweb", "jjwebs", "jjwes", "jjwess", "jjweng", "jjwej", "jjwec", "jjwek", "jjwet", "jjwep", "jjweh", "jjwi", "jjwig", "jjwigg", "jjwigs", "jjwin", "jjwinj", "jjwinh", "jjwid", "jjwil", "jjwilg", "jjwilm", "jjwilb", "jjwils", "jjwilt", "jjwilp", "jjwilh", "jjwim", "jjwib", "jjwibs", "jjwis", "jjwiss", "jjwing", "jjwij", "jjwic", "jjwik", "jjwit", "jjwip", "jjwih", "jjyu", "jjyug", "jjyugg", "jjyugs", "jjyun", "jjyunj", "jjyunh", "jjyud", "jjyul", "jjyulg", "jjyulm", "jjyulb", "jjyuls", "jjyult", "jjyulp", "jjyulh", "jjyum", "jjyub", "jjyubs", "jjyus", "jjyuss", "jjyung", "jjyuj", "jjyuc", "jjyuk", "jjyut", "jjyup", "jjyuh", "jjeu", "jjeug", "jjeugg", "jjeugs", "jjeun", "jjeunj", "jjeunh", "jjeud", "jjeul", "jjeulg", "jjeulm", "jjeulb", "jjeuls", "jjeult", "jjeulp", "jjeulh", "jjeum", "jjeub", "jjeubs", "jjeus", "jjeuss", "jjeung", "jjeuj", "jjeuc", "jjeuk", "jjeut", "jjeup", "jjeuh", "jjyi", "jjyig", "jjyigg", "jjyigs", "jjyin", "jjyinj", "jjyinh", "jjyid", "jjyil", "jjyilg", "jjyilm", "jjyilb", "jjyils", "jjyilt", "jjyilp", "jjyilh"];
  }
});

// node_modules/unidecode/data/xcc.js
var require_xcc = __commonJS({
  "node_modules/unidecode/data/xcc.js"(exports2, module2) {
    module2.exports = ["jjyim", "jjyib", "jjyibs", "jjyis", "jjyiss", "jjying", "jjyij", "jjyic", "jjyik", "jjyit", "jjyip", "jjyih", "jji", "jjig", "jjigg", "jjigs", "jjin", "jjinj", "jjinh", "jjid", "jjil", "jjilg", "jjilm", "jjilb", "jjils", "jjilt", "jjilp", "jjilh", "jjim", "jjib", "jjibs", "jjis", "jjiss", "jjing", "jjij", "jjic", "jjik", "jjit", "jjip", "jjih", "ca", "cag", "cagg", "cags", "can", "canj", "canh", "cad", "cal", "calg", "calm", "calb", "cals", "calt", "calp", "calh", "cam", "cab", "cabs", "cas", "cass", "cang", "caj", "cac", "cak", "cat", "cap", "cah", "cae", "caeg", "caegg", "caegs", "caen", "caenj", "caenh", "caed", "cael", "caelg", "caelm", "caelb", "caels", "caelt", "caelp", "caelh", "caem", "caeb", "caebs", "caes", "caess", "caeng", "caej", "caec", "caek", "caet", "caep", "caeh", "cya", "cyag", "cyagg", "cyags", "cyan", "cyanj", "cyanh", "cyad", "cyal", "cyalg", "cyalm", "cyalb", "cyals", "cyalt", "cyalp", "cyalh", "cyam", "cyab", "cyabs", "cyas", "cyass", "cyang", "cyaj", "cyac", "cyak", "cyat", "cyap", "cyah", "cyae", "cyaeg", "cyaegg", "cyaegs", "cyaen", "cyaenj", "cyaenh", "cyaed", "cyael", "cyaelg", "cyaelm", "cyaelb", "cyaels", "cyaelt", "cyaelp", "cyaelh", "cyaem", "cyaeb", "cyaebs", "cyaes", "cyaess", "cyaeng", "cyaej", "cyaec", "cyaek", "cyaet", "cyaep", "cyaeh", "ceo", "ceog", "ceogg", "ceogs", "ceon", "ceonj", "ceonh", "ceod", "ceol", "ceolg", "ceolm", "ceolb", "ceols", "ceolt", "ceolp", "ceolh", "ceom", "ceob", "ceobs", "ceos", "ceoss", "ceong", "ceoj", "ceoc", "ceok", "ceot", "ceop", "ceoh", "ce", "ceg", "cegg", "cegs", "cen", "cenj", "cenh", "ced", "cel", "celg", "celm", "celb", "cels", "celt", "celp", "celh", "cem", "ceb", "cebs", "ces", "cess", "ceng", "cej", "cec", "cek", "cet", "cep", "ceh", "cyeo", "cyeog", "cyeogg", "cyeogs", "cyeon", "cyeonj", "cyeonh", "cyeod", "cyeol", "cyeolg", "cyeolm", "cyeolb", "cyeols", "cyeolt", "cyeolp", "cyeolh", "cyeom", "cyeob", "cyeobs", "cyeos", "cyeoss", "cyeong", "cyeoj", "cyeoc", "cyeok", "cyeot", "cyeop", "cyeoh", "cye", "cyeg", "cyegg", "cyegs", "cyen", "cyenj", "cyenh", "cyed", "cyel", "cyelg", "cyelm", "cyelb", "cyels", "cyelt", "cyelp", "cyelh", "cyem", "cyeb", "cyebs", "cyes"];
  }
});

// node_modules/unidecode/data/xcd.js
var require_xcd = __commonJS({
  "node_modules/unidecode/data/xcd.js"(exports2, module2) {
    module2.exports = ["cyess", "cyeng", "cyej", "cyec", "cyek", "cyet", "cyep", "cyeh", "co", "cog", "cogg", "cogs", "con", "conj", "conh", "cod", "col", "colg", "colm", "colb", "cols", "colt", "colp", "colh", "com", "cob", "cobs", "cos", "coss", "cong", "coj", "coc", "cok", "cot", "cop", "coh", "cwa", "cwag", "cwagg", "cwags", "cwan", "cwanj", "cwanh", "cwad", "cwal", "cwalg", "cwalm", "cwalb", "cwals", "cwalt", "cwalp", "cwalh", "cwam", "cwab", "cwabs", "cwas", "cwass", "cwang", "cwaj", "cwac", "cwak", "cwat", "cwap", "cwah", "cwae", "cwaeg", "cwaegg", "cwaegs", "cwaen", "cwaenj", "cwaenh", "cwaed", "cwael", "cwaelg", "cwaelm", "cwaelb", "cwaels", "cwaelt", "cwaelp", "cwaelh", "cwaem", "cwaeb", "cwaebs", "cwaes", "cwaess", "cwaeng", "cwaej", "cwaec", "cwaek", "cwaet", "cwaep", "cwaeh", "coe", "coeg", "coegg", "coegs", "coen", "coenj", "coenh", "coed", "coel", "coelg", "coelm", "coelb", "coels", "coelt", "coelp", "coelh", "coem", "coeb", "coebs", "coes", "coess", "coeng", "coej", "coec", "coek", "coet", "coep", "coeh", "cyo", "cyog", "cyogg", "cyogs", "cyon", "cyonj", "cyonh", "cyod", "cyol", "cyolg", "cyolm", "cyolb", "cyols", "cyolt", "cyolp", "cyolh", "cyom", "cyob", "cyobs", "cyos", "cyoss", "cyong", "cyoj", "cyoc", "cyok", "cyot", "cyop", "cyoh", "cu", "cug", "cugg", "cugs", "cun", "cunj", "cunh", "cud", "cul", "culg", "culm", "culb", "culs", "cult", "culp", "culh", "cum", "cub", "cubs", "cus", "cuss", "cung", "cuj", "cuc", "cuk", "cut", "cup", "cuh", "cweo", "cweog", "cweogg", "cweogs", "cweon", "cweonj", "cweonh", "cweod", "cweol", "cweolg", "cweolm", "cweolb", "cweols", "cweolt", "cweolp", "cweolh", "cweom", "cweob", "cweobs", "cweos", "cweoss", "cweong", "cweoj", "cweoc", "cweok", "cweot", "cweop", "cweoh", "cwe", "cweg", "cwegg", "cwegs", "cwen", "cwenj", "cwenh", "cwed", "cwel", "cwelg", "cwelm", "cwelb", "cwels", "cwelt", "cwelp", "cwelh", "cwem", "cweb", "cwebs", "cwes", "cwess", "cweng", "cwej", "cwec", "cwek", "cwet", "cwep", "cweh", "cwi", "cwig", "cwigg", "cwigs", "cwin", "cwinj", "cwinh", "cwid", "cwil", "cwilg", "cwilm", "cwilb", "cwils", "cwilt", "cwilp", "cwilh", "cwim", "cwib", "cwibs", "cwis", "cwiss", "cwing", "cwij", "cwic"];
  }
});

// node_modules/unidecode/data/xce.js
var require_xce = __commonJS({
  "node_modules/unidecode/data/xce.js"(exports2, module2) {
    module2.exports = ["cwik", "cwit", "cwip", "cwih", "cyu", "cyug", "cyugg", "cyugs", "cyun", "cyunj", "cyunh", "cyud", "cyul", "cyulg", "cyulm", "cyulb", "cyuls", "cyult", "cyulp", "cyulh", "cyum", "cyub", "cyubs", "cyus", "cyuss", "cyung", "cyuj", "cyuc", "cyuk", "cyut", "cyup", "cyuh", "ceu", "ceug", "ceugg", "ceugs", "ceun", "ceunj", "ceunh", "ceud", "ceul", "ceulg", "ceulm", "ceulb", "ceuls", "ceult", "ceulp", "ceulh", "ceum", "ceub", "ceubs", "ceus", "ceuss", "ceung", "ceuj", "ceuc", "ceuk", "ceut", "ceup", "ceuh", "cyi", "cyig", "cyigg", "cyigs", "cyin", "cyinj", "cyinh", "cyid", "cyil", "cyilg", "cyilm", "cyilb", "cyils", "cyilt", "cyilp", "cyilh", "cyim", "cyib", "cyibs", "cyis", "cyiss", "cying", "cyij", "cyic", "cyik", "cyit", "cyip", "cyih", "ci", "cig", "cigg", "cigs", "cin", "cinj", "cinh", "cid", "cil", "cilg", "cilm", "cilb", "cils", "cilt", "cilp", "cilh", "cim", "cib", "cibs", "cis", "ciss", "cing", "cij", "cic", "cik", "cit", "cip", "cih", "ka", "kag", "kagg", "kags", "kan", "kanj", "kanh", "kad", "kal", "kalg", "kalm", "kalb", "kals", "kalt", "kalp", "kalh", "kam", "kab", "kabs", "kas", "kass", "kang", "kaj", "kac", "kak", "kat", "kap", "kah", "kae", "kaeg", "kaegg", "kaegs", "kaen", "kaenj", "kaenh", "kaed", "kael", "kaelg", "kaelm", "kaelb", "kaels", "kaelt", "kaelp", "kaelh", "kaem", "kaeb", "kaebs", "kaes", "kaess", "kaeng", "kaej", "kaec", "kaek", "kaet", "kaep", "kaeh", "kya", "kyag", "kyagg", "kyags", "kyan", "kyanj", "kyanh", "kyad", "kyal", "kyalg", "kyalm", "kyalb", "kyals", "kyalt", "kyalp", "kyalh", "kyam", "kyab", "kyabs", "kyas", "kyass", "kyang", "kyaj", "kyac", "kyak", "kyat", "kyap", "kyah", "kyae", "kyaeg", "kyaegg", "kyaegs", "kyaen", "kyaenj", "kyaenh", "kyaed", "kyael", "kyaelg", "kyaelm", "kyaelb", "kyaels", "kyaelt", "kyaelp", "kyaelh", "kyaem", "kyaeb", "kyaebs", "kyaes", "kyaess", "kyaeng", "kyaej", "kyaec", "kyaek", "kyaet", "kyaep", "kyaeh", "keo", "keog", "keogg", "keogs", "keon", "keonj", "keonh", "keod", "keol", "keolg", "keolm", "keolb", "keols", "keolt", "keolp", "keolh", "keom", "keob", "keobs", "keos", "keoss", "keong", "keoj", "keoc", "keok", "keot", "keop", "keoh"];
  }
});

// node_modules/unidecode/data/xcf.js
var require_xcf = __commonJS({
  "node_modules/unidecode/data/xcf.js"(exports2, module2) {
    module2.exports = ["ke", "keg", "kegg", "kegs", "ken", "kenj", "kenh", "ked", "kel", "kelg", "kelm", "kelb", "kels", "kelt", "kelp", "kelh", "kem", "keb", "kebs", "kes", "kess", "keng", "kej", "kec", "kek", "ket", "kep", "keh", "kyeo", "kyeog", "kyeogg", "kyeogs", "kyeon", "kyeonj", "kyeonh", "kyeod", "kyeol", "kyeolg", "kyeolm", "kyeolb", "kyeols", "kyeolt", "kyeolp", "kyeolh", "kyeom", "kyeob", "kyeobs", "kyeos", "kyeoss", "kyeong", "kyeoj", "kyeoc", "kyeok", "kyeot", "kyeop", "kyeoh", "kye", "kyeg", "kyegg", "kyegs", "kyen", "kyenj", "kyenh", "kyed", "kyel", "kyelg", "kyelm", "kyelb", "kyels", "kyelt", "kyelp", "kyelh", "kyem", "kyeb", "kyebs", "kyes", "kyess", "kyeng", "kyej", "kyec", "kyek", "kyet", "kyep", "kyeh", "ko", "kog", "kogg", "kogs", "kon", "konj", "konh", "kod", "kol", "kolg", "kolm", "kolb", "kols", "kolt", "kolp", "kolh", "kom", "kob", "kobs", "kos", "koss", "kong", "koj", "koc", "kok", "kot", "kop", "koh", "kwa", "kwag", "kwagg", "kwags", "kwan", "kwanj", "kwanh", "kwad", "kwal", "kwalg", "kwalm", "kwalb", "kwals", "kwalt", "kwalp", "kwalh", "kwam", "kwab", "kwabs", "kwas", "kwass", "kwang", "kwaj", "kwac", "kwak", "kwat", "kwap", "kwah", "kwae", "kwaeg", "kwaegg", "kwaegs", "kwaen", "kwaenj", "kwaenh", "kwaed", "kwael", "kwaelg", "kwaelm", "kwaelb", "kwaels", "kwaelt", "kwaelp", "kwaelh", "kwaem", "kwaeb", "kwaebs", "kwaes", "kwaess", "kwaeng", "kwaej", "kwaec", "kwaek", "kwaet", "kwaep", "kwaeh", "koe", "koeg", "koegg", "koegs", "koen", "koenj", "koenh", "koed", "koel", "koelg", "koelm", "koelb", "koels", "koelt", "koelp", "koelh", "koem", "koeb", "koebs", "koes", "koess", "koeng", "koej", "koec", "koek", "koet", "koep", "koeh", "kyo", "kyog", "kyogg", "kyogs", "kyon", "kyonj", "kyonh", "kyod", "kyol", "kyolg", "kyolm", "kyolb", "kyols", "kyolt", "kyolp", "kyolh", "kyom", "kyob", "kyobs", "kyos", "kyoss", "kyong", "kyoj", "kyoc", "kyok", "kyot", "kyop", "kyoh", "ku", "kug", "kugg", "kugs", "kun", "kunj", "kunh", "kud", "kul", "kulg", "kulm", "kulb", "kuls", "kult", "kulp", "kulh", "kum", "kub", "kubs", "kus", "kuss", "kung", "kuj", "kuc", "kuk", "kut", "kup", "kuh", "kweo", "kweog", "kweogg", "kweogs"];
  }
});

// node_modules/unidecode/data/xd0.js
var require_xd0 = __commonJS({
  "node_modules/unidecode/data/xd0.js"(exports2, module2) {
    module2.exports = ["kweon", "kweonj", "kweonh", "kweod", "kweol", "kweolg", "kweolm", "kweolb", "kweols", "kweolt", "kweolp", "kweolh", "kweom", "kweob", "kweobs", "kweos", "kweoss", "kweong", "kweoj", "kweoc", "kweok", "kweot", "kweop", "kweoh", "kwe", "kweg", "kwegg", "kwegs", "kwen", "kwenj", "kwenh", "kwed", "kwel", "kwelg", "kwelm", "kwelb", "kwels", "kwelt", "kwelp", "kwelh", "kwem", "kweb", "kwebs", "kwes", "kwess", "kweng", "kwej", "kwec", "kwek", "kwet", "kwep", "kweh", "kwi", "kwig", "kwigg", "kwigs", "kwin", "kwinj", "kwinh", "kwid", "kwil", "kwilg", "kwilm", "kwilb", "kwils", "kwilt", "kwilp", "kwilh", "kwim", "kwib", "kwibs", "kwis", "kwiss", "kwing", "kwij", "kwic", "kwik", "kwit", "kwip", "kwih", "kyu", "kyug", "kyugg", "kyugs", "kyun", "kyunj", "kyunh", "kyud", "kyul", "kyulg", "kyulm", "kyulb", "kyuls", "kyult", "kyulp", "kyulh", "kyum", "kyub", "kyubs", "kyus", "kyuss", "kyung", "kyuj", "kyuc", "kyuk", "kyut", "kyup", "kyuh", "keu", "keug", "keugg", "keugs", "keun", "keunj", "keunh", "keud", "keul", "keulg", "keulm", "keulb", "keuls", "keult", "keulp", "keulh", "keum", "keub", "keubs", "keus", "keuss", "keung", "keuj", "keuc", "keuk", "keut", "keup", "keuh", "kyi", "kyig", "kyigg", "kyigs", "kyin", "kyinj", "kyinh", "kyid", "kyil", "kyilg", "kyilm", "kyilb", "kyils", "kyilt", "kyilp", "kyilh", "kyim", "kyib", "kyibs", "kyis", "kyiss", "kying", "kyij", "kyic", "kyik", "kyit", "kyip", "kyih", "ki", "kig", "kigg", "kigs", "kin", "kinj", "kinh", "kid", "kil", "kilg", "kilm", "kilb", "kils", "kilt", "kilp", "kilh", "kim", "kib", "kibs", "kis", "kiss", "king", "kij", "kic", "kik", "kit", "kip", "kih", "ta", "tag", "tagg", "tags", "tan", "tanj", "tanh", "tad", "tal", "talg", "talm", "talb", "tals", "talt", "talp", "talh", "tam", "tab", "tabs", "tas", "tass", "tang", "taj", "tac", "tak", "tat", "tap", "tah", "tae", "taeg", "taegg", "taegs", "taen", "taenj", "taenh", "taed", "tael", "taelg", "taelm", "taelb", "taels", "taelt", "taelp", "taelh", "taem", "taeb", "taebs", "taes", "taess", "taeng", "taej", "taec", "taek", "taet", "taep", "taeh", "tya", "tyag", "tyagg", "tyags", "tyan", "tyanj", "tyanh", "tyad"];
  }
});

// node_modules/unidecode/data/xd1.js
var require_xd1 = __commonJS({
  "node_modules/unidecode/data/xd1.js"(exports2, module2) {
    module2.exports = ["tyal", "tyalg", "tyalm", "tyalb", "tyals", "tyalt", "tyalp", "tyalh", "tyam", "tyab", "tyabs", "tyas", "tyass", "tyang", "tyaj", "tyac", "tyak", "tyat", "tyap", "tyah", "tyae", "tyaeg", "tyaegg", "tyaegs", "tyaen", "tyaenj", "tyaenh", "tyaed", "tyael", "tyaelg", "tyaelm", "tyaelb", "tyaels", "tyaelt", "tyaelp", "tyaelh", "tyaem", "tyaeb", "tyaebs", "tyaes", "tyaess", "tyaeng", "tyaej", "tyaec", "tyaek", "tyaet", "tyaep", "tyaeh", "teo", "teog", "teogg", "teogs", "teon", "teonj", "teonh", "teod", "teol", "teolg", "teolm", "teolb", "teols", "teolt", "teolp", "teolh", "teom", "teob", "teobs", "teos", "teoss", "teong", "teoj", "teoc", "teok", "teot", "teop", "teoh", "te", "teg", "tegg", "tegs", "ten", "tenj", "tenh", "ted", "tel", "telg", "telm", "telb", "tels", "telt", "telp", "telh", "tem", "teb", "tebs", "tes", "tess", "teng", "tej", "tec", "tek", "tet", "tep", "teh", "tyeo", "tyeog", "tyeogg", "tyeogs", "tyeon", "tyeonj", "tyeonh", "tyeod", "tyeol", "tyeolg", "tyeolm", "tyeolb", "tyeols", "tyeolt", "tyeolp", "tyeolh", "tyeom", "tyeob", "tyeobs", "tyeos", "tyeoss", "tyeong", "tyeoj", "tyeoc", "tyeok", "tyeot", "tyeop", "tyeoh", "tye", "tyeg", "tyegg", "tyegs", "tyen", "tyenj", "tyenh", "tyed", "tyel", "tyelg", "tyelm", "tyelb", "tyels", "tyelt", "tyelp", "tyelh", "tyem", "tyeb", "tyebs", "tyes", "tyess", "tyeng", "tyej", "tyec", "tyek", "tyet", "tyep", "tyeh", "to", "tog", "togg", "togs", "ton", "tonj", "tonh", "tod", "tol", "tolg", "tolm", "tolb", "tols", "tolt", "tolp", "tolh", "tom", "tob", "tobs", "tos", "toss", "tong", "toj", "toc", "tok", "tot", "top", "toh", "twa", "twag", "twagg", "twags", "twan", "twanj", "twanh", "twad", "twal", "twalg", "twalm", "twalb", "twals", "twalt", "twalp", "twalh", "twam", "twab", "twabs", "twas", "twass", "twang", "twaj", "twac", "twak", "twat", "twap", "twah", "twae", "twaeg", "twaegg", "twaegs", "twaen", "twaenj", "twaenh", "twaed", "twael", "twaelg", "twaelm", "twaelb", "twaels", "twaelt", "twaelp", "twaelh", "twaem", "twaeb", "twaebs", "twaes", "twaess", "twaeng", "twaej", "twaec", "twaek", "twaet", "twaep", "twaeh", "toe", "toeg", "toegg", "toegs", "toen", "toenj", "toenh", "toed", "toel", "toelg", "toelm", "toelb"];
  }
});

// node_modules/unidecode/data/xd2.js
var require_xd2 = __commonJS({
  "node_modules/unidecode/data/xd2.js"(exports2, module2) {
    module2.exports = ["toels", "toelt", "toelp", "toelh", "toem", "toeb", "toebs", "toes", "toess", "toeng", "toej", "toec", "toek", "toet", "toep", "toeh", "tyo", "tyog", "tyogg", "tyogs", "tyon", "tyonj", "tyonh", "tyod", "tyol", "tyolg", "tyolm", "tyolb", "tyols", "tyolt", "tyolp", "tyolh", "tyom", "tyob", "tyobs", "tyos", "tyoss", "tyong", "tyoj", "tyoc", "tyok", "tyot", "tyop", "tyoh", "tu", "tug", "tugg", "tugs", "tun", "tunj", "tunh", "tud", "tul", "tulg", "tulm", "tulb", "tuls", "tult", "tulp", "tulh", "tum", "tub", "tubs", "tus", "tuss", "tung", "tuj", "tuc", "tuk", "tut", "tup", "tuh", "tweo", "tweog", "tweogg", "tweogs", "tweon", "tweonj", "tweonh", "tweod", "tweol", "tweolg", "tweolm", "tweolb", "tweols", "tweolt", "tweolp", "tweolh", "tweom", "tweob", "tweobs", "tweos", "tweoss", "tweong", "tweoj", "tweoc", "tweok", "tweot", "tweop", "tweoh", "twe", "tweg", "twegg", "twegs", "twen", "twenj", "twenh", "twed", "twel", "twelg", "twelm", "twelb", "twels", "twelt", "twelp", "twelh", "twem", "tweb", "twebs", "twes", "twess", "tweng", "twej", "twec", "twek", "twet", "twep", "tweh", "twi", "twig", "twigg", "twigs", "twin", "twinj", "twinh", "twid", "twil", "twilg", "twilm", "twilb", "twils", "twilt", "twilp", "twilh", "twim", "twib", "twibs", "twis", "twiss", "twing", "twij", "twic", "twik", "twit", "twip", "twih", "tyu", "tyug", "tyugg", "tyugs", "tyun", "tyunj", "tyunh", "tyud", "tyul", "tyulg", "tyulm", "tyulb", "tyuls", "tyult", "tyulp", "tyulh", "tyum", "tyub", "tyubs", "tyus", "tyuss", "tyung", "tyuj", "tyuc", "tyuk", "tyut", "tyup", "tyuh", "teu", "teug", "teugg", "teugs", "teun", "teunj", "teunh", "teud", "teul", "teulg", "teulm", "teulb", "teuls", "teult", "teulp", "teulh", "teum", "teub", "teubs", "teus", "teuss", "teung", "teuj", "teuc", "teuk", "teut", "teup", "teuh", "tyi", "tyig", "tyigg", "tyigs", "tyin", "tyinj", "tyinh", "tyid", "tyil", "tyilg", "tyilm", "tyilb", "tyils", "tyilt", "tyilp", "tyilh", "tyim", "tyib", "tyibs", "tyis", "tyiss", "tying", "tyij", "tyic", "tyik", "tyit", "tyip", "tyih", "ti", "tig", "tigg", "tigs", "tin", "tinj", "tinh", "tid", "til", "tilg", "tilm", "tilb", "tils", "tilt", "tilp", "tilh"];
  }
});

// node_modules/unidecode/data/xd3.js
var require_xd3 = __commonJS({
  "node_modules/unidecode/data/xd3.js"(exports2, module2) {
    module2.exports = ["tim", "tib", "tibs", "tis", "tiss", "ting", "tij", "tic", "tik", "tit", "tip", "tih", "pa", "pag", "pagg", "pags", "pan", "panj", "panh", "pad", "pal", "palg", "palm", "palb", "pals", "palt", "palp", "palh", "pam", "pab", "pabs", "pas", "pass", "pang", "paj", "pac", "pak", "pat", "pap", "pah", "pae", "paeg", "paegg", "paegs", "paen", "paenj", "paenh", "paed", "pael", "paelg", "paelm", "paelb", "paels", "paelt", "paelp", "paelh", "paem", "paeb", "paebs", "paes", "paess", "paeng", "paej", "paec", "paek", "paet", "paep", "paeh", "pya", "pyag", "pyagg", "pyags", "pyan", "pyanj", "pyanh", "pyad", "pyal", "pyalg", "pyalm", "pyalb", "pyals", "pyalt", "pyalp", "pyalh", "pyam", "pyab", "pyabs", "pyas", "pyass", "pyang", "pyaj", "pyac", "pyak", "pyat", "pyap", "pyah", "pyae", "pyaeg", "pyaegg", "pyaegs", "pyaen", "pyaenj", "pyaenh", "pyaed", "pyael", "pyaelg", "pyaelm", "pyaelb", "pyaels", "pyaelt", "pyaelp", "pyaelh", "pyaem", "pyaeb", "pyaebs", "pyaes", "pyaess", "pyaeng", "pyaej", "pyaec", "pyaek", "pyaet", "pyaep", "pyaeh", "peo", "peog", "peogg", "peogs", "peon", "peonj", "peonh", "peod", "peol", "peolg", "peolm", "peolb", "peols", "peolt", "peolp", "peolh", "peom", "peob", "peobs", "peos", "peoss", "peong", "peoj", "peoc", "peok", "peot", "peop", "peoh", "pe", "peg", "pegg", "pegs", "pen", "penj", "penh", "ped", "pel", "pelg", "pelm", "pelb", "pels", "pelt", "pelp", "pelh", "pem", "peb", "pebs", "pes", "pess", "peng", "pej", "pec", "pek", "pet", "pep", "peh", "pyeo", "pyeog", "pyeogg", "pyeogs", "pyeon", "pyeonj", "pyeonh", "pyeod", "pyeol", "pyeolg", "pyeolm", "pyeolb", "pyeols", "pyeolt", "pyeolp", "pyeolh", "pyeom", "pyeob", "pyeobs", "pyeos", "pyeoss", "pyeong", "pyeoj", "pyeoc", "pyeok", "pyeot", "pyeop", "pyeoh", "pye", "pyeg", "pyegg", "pyegs", "pyen", "pyenj", "pyenh", "pyed", "pyel", "pyelg", "pyelm", "pyelb", "pyels", "pyelt", "pyelp", "pyelh", "pyem", "pyeb", "pyebs", "pyes", "pyess", "pyeng", "pyej", "pyec", "pyek", "pyet", "pyep", "pyeh", "po", "pog", "pogg", "pogs", "pon", "ponj", "ponh", "pod", "pol", "polg", "polm", "polb", "pols", "polt", "polp", "polh", "pom", "pob", "pobs", "pos"];
  }
});

// node_modules/unidecode/data/xd4.js
var require_xd4 = __commonJS({
  "node_modules/unidecode/data/xd4.js"(exports2, module2) {
    module2.exports = ["poss", "pong", "poj", "poc", "pok", "pot", "pop", "poh", "pwa", "pwag", "pwagg", "pwags", "pwan", "pwanj", "pwanh", "pwad", "pwal", "pwalg", "pwalm", "pwalb", "pwals", "pwalt", "pwalp", "pwalh", "pwam", "pwab", "pwabs", "pwas", "pwass", "pwang", "pwaj", "pwac", "pwak", "pwat", "pwap", "pwah", "pwae", "pwaeg", "pwaegg", "pwaegs", "pwaen", "pwaenj", "pwaenh", "pwaed", "pwael", "pwaelg", "pwaelm", "pwaelb", "pwaels", "pwaelt", "pwaelp", "pwaelh", "pwaem", "pwaeb", "pwaebs", "pwaes", "pwaess", "pwaeng", "pwaej", "pwaec", "pwaek", "pwaet", "pwaep", "pwaeh", "poe", "poeg", "poegg", "poegs", "poen", "poenj", "poenh", "poed", "poel", "poelg", "poelm", "poelb", "poels", "poelt", "poelp", "poelh", "poem", "poeb", "poebs", "poes", "poess", "poeng", "poej", "poec", "poek", "poet", "poep", "poeh", "pyo", "pyog", "pyogg", "pyogs", "pyon", "pyonj", "pyonh", "pyod", "pyol", "pyolg", "pyolm", "pyolb", "pyols", "pyolt", "pyolp", "pyolh", "pyom", "pyob", "pyobs", "pyos", "pyoss", "pyong", "pyoj", "pyoc", "pyok", "pyot", "pyop", "pyoh", "pu", "pug", "pugg", "pugs", "pun", "punj", "punh", "pud", "pul", "pulg", "pulm", "pulb", "puls", "pult", "pulp", "pulh", "pum", "pub", "pubs", "pus", "puss", "pung", "puj", "puc", "puk", "put", "pup", "puh", "pweo", "pweog", "pweogg", "pweogs", "pweon", "pweonj", "pweonh", "pweod", "pweol", "pweolg", "pweolm", "pweolb", "pweols", "pweolt", "pweolp", "pweolh", "pweom", "pweob", "pweobs", "pweos", "pweoss", "pweong", "pweoj", "pweoc", "pweok", "pweot", "pweop", "pweoh", "pwe", "pweg", "pwegg", "pwegs", "pwen", "pwenj", "pwenh", "pwed", "pwel", "pwelg", "pwelm", "pwelb", "pwels", "pwelt", "pwelp", "pwelh", "pwem", "pweb", "pwebs", "pwes", "pwess", "pweng", "pwej", "pwec", "pwek", "pwet", "pwep", "pweh", "pwi", "pwig", "pwigg", "pwigs", "pwin", "pwinj", "pwinh", "pwid", "pwil", "pwilg", "pwilm", "pwilb", "pwils", "pwilt", "pwilp", "pwilh", "pwim", "pwib", "pwibs", "pwis", "pwiss", "pwing", "pwij", "pwic", "pwik", "pwit", "pwip", "pwih", "pyu", "pyug", "pyugg", "pyugs", "pyun", "pyunj", "pyunh", "pyud", "pyul", "pyulg", "pyulm", "pyulb", "pyuls", "pyult", "pyulp", "pyulh", "pyum", "pyub", "pyubs", "pyus", "pyuss", "pyung", "pyuj", "pyuc"];
  }
});

// node_modules/unidecode/data/xd5.js
var require_xd5 = __commonJS({
  "node_modules/unidecode/data/xd5.js"(exports2, module2) {
    module2.exports = ["pyuk", "pyut", "pyup", "pyuh", "peu", "peug", "peugg", "peugs", "peun", "peunj", "peunh", "peud", "peul", "peulg", "peulm", "peulb", "peuls", "peult", "peulp", "peulh", "peum", "peub", "peubs", "peus", "peuss", "peung", "peuj", "peuc", "peuk", "peut", "peup", "peuh", "pyi", "pyig", "pyigg", "pyigs", "pyin", "pyinj", "pyinh", "pyid", "pyil", "pyilg", "pyilm", "pyilb", "pyils", "pyilt", "pyilp", "pyilh", "pyim", "pyib", "pyibs", "pyis", "pyiss", "pying", "pyij", "pyic", "pyik", "pyit", "pyip", "pyih", "pi", "pig", "pigg", "pigs", "pin", "pinj", "pinh", "pid", "pil", "pilg", "pilm", "pilb", "pils", "pilt", "pilp", "pilh", "pim", "pib", "pibs", "pis", "piss", "ping", "pij", "pic", "pik", "pit", "pip", "pih", "ha", "hag", "hagg", "hags", "han", "hanj", "hanh", "had", "hal", "halg", "halm", "halb", "hals", "halt", "halp", "halh", "ham", "hab", "habs", "has", "hass", "hang", "haj", "hac", "hak", "hat", "hap", "hah", "hae", "haeg", "haegg", "haegs", "haen", "haenj", "haenh", "haed", "hael", "haelg", "haelm", "haelb", "haels", "haelt", "haelp", "haelh", "haem", "haeb", "haebs", "haes", "haess", "haeng", "haej", "haec", "haek", "haet", "haep", "haeh", "hya", "hyag", "hyagg", "hyags", "hyan", "hyanj", "hyanh", "hyad", "hyal", "hyalg", "hyalm", "hyalb", "hyals", "hyalt", "hyalp", "hyalh", "hyam", "hyab", "hyabs", "hyas", "hyass", "hyang", "hyaj", "hyac", "hyak", "hyat", "hyap", "hyah", "hyae", "hyaeg", "hyaegg", "hyaegs", "hyaen", "hyaenj", "hyaenh", "hyaed", "hyael", "hyaelg", "hyaelm", "hyaelb", "hyaels", "hyaelt", "hyaelp", "hyaelh", "hyaem", "hyaeb", "hyaebs", "hyaes", "hyaess", "hyaeng", "hyaej", "hyaec", "hyaek", "hyaet", "hyaep", "hyaeh", "heo", "heog", "heogg", "heogs", "heon", "heonj", "heonh", "heod", "heol", "heolg", "heolm", "heolb", "heols", "heolt", "heolp", "heolh", "heom", "heob", "heobs", "heos", "heoss", "heong", "heoj", "heoc", "heok", "heot", "heop", "heoh", "he", "heg", "hegg", "hegs", "hen", "henj", "henh", "hed", "hel", "helg", "helm", "helb", "hels", "helt", "help", "helh", "hem", "heb", "hebs", "hes", "hess", "heng", "hej", "hec", "hek", "het", "hep", "heh"];
  }
});

// node_modules/unidecode/data/xd6.js
var require_xd6 = __commonJS({
  "node_modules/unidecode/data/xd6.js"(exports2, module2) {
    module2.exports = ["hyeo", "hyeog", "hyeogg", "hyeogs", "hyeon", "hyeonj", "hyeonh", "hyeod", "hyeol", "hyeolg", "hyeolm", "hyeolb", "hyeols", "hyeolt", "hyeolp", "hyeolh", "hyeom", "hyeob", "hyeobs", "hyeos", "hyeoss", "hyeong", "hyeoj", "hyeoc", "hyeok", "hyeot", "hyeop", "hyeoh", "hye", "hyeg", "hyegg", "hyegs", "hyen", "hyenj", "hyenh", "hyed", "hyel", "hyelg", "hyelm", "hyelb", "hyels", "hyelt", "hyelp", "hyelh", "hyem", "hyeb", "hyebs", "hyes", "hyess", "hyeng", "hyej", "hyec", "hyek", "hyet", "hyep", "hyeh", "ho", "hog", "hogg", "hogs", "hon", "honj", "honh", "hod", "hol", "holg", "holm", "holb", "hols", "holt", "holp", "holh", "hom", "hob", "hobs", "hos", "hoss", "hong", "hoj", "hoc", "hok", "hot", "hop", "hoh", "hwa", "hwag", "hwagg", "hwags", "hwan", "hwanj", "hwanh", "hwad", "hwal", "hwalg", "hwalm", "hwalb", "hwals", "hwalt", "hwalp", "hwalh", "hwam", "hwab", "hwabs", "hwas", "hwass", "hwang", "hwaj", "hwac", "hwak", "hwat", "hwap", "hwah", "hwae", "hwaeg", "hwaegg", "hwaegs", "hwaen", "hwaenj", "hwaenh", "hwaed", "hwael", "hwaelg", "hwaelm", "hwaelb", "hwaels", "hwaelt", "hwaelp", "hwaelh", "hwaem", "hwaeb", "hwaebs", "hwaes", "hwaess", "hwaeng", "hwaej", "hwaec", "hwaek", "hwaet", "hwaep", "hwaeh", "hoe", "hoeg", "hoegg", "hoegs", "hoen", "hoenj", "hoenh", "hoed", "hoel", "hoelg", "hoelm", "hoelb", "hoels", "hoelt", "hoelp", "hoelh", "hoem", "hoeb", "hoebs", "hoes", "hoess", "hoeng", "hoej", "hoec", "hoek", "hoet", "hoep", "hoeh", "hyo", "hyog", "hyogg", "hyogs", "hyon", "hyonj", "hyonh", "hyod", "hyol", "hyolg", "hyolm", "hyolb", "hyols", "hyolt", "hyolp", "hyolh", "hyom", "hyob", "hyobs", "hyos", "hyoss", "hyong", "hyoj", "hyoc", "hyok", "hyot", "hyop", "hyoh", "hu", "hug", "hugg", "hugs", "hun", "hunj", "hunh", "hud", "hul", "hulg", "hulm", "hulb", "huls", "hult", "hulp", "hulh", "hum", "hub", "hubs", "hus", "huss", "hung", "huj", "huc", "huk", "hut", "hup", "huh", "hweo", "hweog", "hweogg", "hweogs", "hweon", "hweonj", "hweonh", "hweod", "hweol", "hweolg", "hweolm", "hweolb", "hweols", "hweolt", "hweolp", "hweolh", "hweom", "hweob", "hweobs", "hweos", "hweoss", "hweong", "hweoj", "hweoc", "hweok", "hweot", "hweop", "hweoh", "hwe", "hweg", "hwegg", "hwegs"];
  }
});

// node_modules/unidecode/data/xd7.js
var require_xd7 = __commonJS({
  "node_modules/unidecode/data/xd7.js"(exports2, module2) {
    module2.exports = ["hwen", "hwenj", "hwenh", "hwed", "hwel", "hwelg", "hwelm", "hwelb", "hwels", "hwelt", "hwelp", "hwelh", "hwem", "hweb", "hwebs", "hwes", "hwess", "hweng", "hwej", "hwec", "hwek", "hwet", "hwep", "hweh", "hwi", "hwig", "hwigg", "hwigs", "hwin", "hwinj", "hwinh", "hwid", "hwil", "hwilg", "hwilm", "hwilb", "hwils", "hwilt", "hwilp", "hwilh", "hwim", "hwib", "hwibs", "hwis", "hwiss", "hwing", "hwij", "hwic", "hwik", "hwit", "hwip", "hwih", "hyu", "hyug", "hyugg", "hyugs", "hyun", "hyunj", "hyunh", "hyud", "hyul", "hyulg", "hyulm", "hyulb", "hyuls", "hyult", "hyulp", "hyulh", "hyum", "hyub", "hyubs", "hyus", "hyuss", "hyung", "hyuj", "hyuc", "hyuk", "hyut", "hyup", "hyuh", "heu", "heug", "heugg", "heugs", "heun", "heunj", "heunh", "heud", "heul", "heulg", "heulm", "heulb", "heuls", "heult", "heulp", "heulh", "heum", "heub", "heubs", "heus", "heuss", "heung", "heuj", "heuc", "heuk", "heut", "heup", "heuh", "hyi", "hyig", "hyigg", "hyigs", "hyin", "hyinj", "hyinh", "hyid", "hyil", "hyilg", "hyilm", "hyilb", "hyils", "hyilt", "hyilp", "hyilh", "hyim", "hyib", "hyibs", "hyis", "hyiss", "hying", "hyij", "hyic", "hyik", "hyit", "hyip", "hyih", "hi", "hig", "higg", "higs", "hin", "hinj", "hinh", "hid", "hil", "hilg", "hilm", "hilb", "hils", "hilt", "hilp", "hilh", "him", "hib", "hibs", "his", "hiss", "hing", "hij", "hic", "hik", "hit", "hip", "hih", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xf9.js
var require_xf9 = __commonJS({
  "node_modules/unidecode/data/xf9.js"(exports2, module2) {
    module2.exports = ["Kay ", "Kayng ", "Ke ", "Ko ", "Kol ", "Koc ", "Kwi ", "Kwi ", "Kyun ", "Kul ", "Kum ", "Na ", "Na ", "Na ", "La ", "Na ", "Na ", "Na ", "Na ", "Na ", "Nak ", "Nak ", "Nak ", "Nak ", "Nak ", "Nak ", "Nak ", "Nan ", "Nan ", "Nan ", "Nan ", "Nan ", "Nan ", "Nam ", "Nam ", "Nam ", "Nam ", "Nap ", "Nap ", "Nap ", "Nang ", "Nang ", "Nang ", "Nang ", "Nang ", "Nay ", "Nayng ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "Nok ", "Nok ", "Nok ", "Nok ", "Nok ", "Nok ", "Non ", "Nong ", "Nong ", "Nong ", "Nong ", "Noy ", "Noy ", "Noy ", "Noy ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nuk ", "Nuk ", "Num ", "Nung ", "Nung ", "Nung ", "Nung ", "Nung ", "Twu ", "La ", "Lak ", "Lak ", "Lan ", "Lyeng ", "Lo ", "Lyul ", "Li ", "Pey ", "Pen ", "Pyen ", "Pwu ", "Pwul ", "Pi ", "Sak ", "Sak ", "Sam ", "Sayk ", "Sayng ", "Sep ", "Sey ", "Sway ", "Sin ", "Sim ", "Sip ", "Ya ", "Yak ", "Yak ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Yek ", "Yek ", "Yek ", "Yek ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yel ", "Yel ", "Yel ", "Yel ", "Yel ", "Yel ", "Yem ", "Yem ", "Yem ", "Yem ", "Yem ", "Yep ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yey ", "Yey ", "Yey ", "Yey ", "O ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yong ", "Wun ", "Wen ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yuk ", "Yuk ", "Yuk ", "Yun ", "Yun ", "Yun ", "Yun ", "Yul ", "Yul ", "Yul ", "Yul ", "Yung ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "Ik ", "Ik ", "In ", "In ", "In ", "In ", "In ", "In ", "In ", "Im ", "Im ", "Im ", "Ip ", "Ip ", "Ip ", "Cang ", "Cek ", "Ci ", "Cip ", "Cha ", "Chek "];
  }
});

// node_modules/unidecode/data/xfa.js
var require_xfa = __commonJS({
  "node_modules/unidecode/data/xfa.js"(exports2, module2) {
    module2.exports = ["Chey ", "Thak ", "Thak ", "Thang ", "Thayk ", "Thong ", "Pho ", "Phok ", "Hang ", "Hang ", "Hyen ", "Hwak ", "Wu ", "Huo ", "[?] ", "[?] ", "Zhong ", "[?] ", "Qing ", "[?] ", "[?] ", "Xi ", "Zhu ", "Yi ", "Li ", "Shen ", "Xiang ", "Fu ", "Jing ", "Jing ", "Yu ", "[?] ", "Hagi ", "[?] ", "Zhu ", "[?] ", "[?] ", "Yi ", "Du ", "[?] ", "[?] ", "[?] ", "Fan ", "Si ", "Guan ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xfb.js
var require_xfb = __commonJS({
  "node_modules/unidecode/data/xfb.js"(exports2, module2) {
    module2.exports = ["ff", "fi", "fl", "ffi", "ffl", "st", "st", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "mn", "me", "mi", "vn", "mkh", "[?]", "[?]", "[?]", "[?]", "[?]", "yi", "", "ay", "`", "", "d", "h", "k", "l", "m", "m", "t", "+", "sh", "s", "sh", "s", "a", "a", "", "b", "g", "d", "h", "v", "z", "[?]", "t", "y", "k", "k", "l", "[?]", "l", "[?]", "n", "n", "[?]", "p", "p", "[?]", "ts", "ts", "r", "sh", "t", "vo", "b", "k", "p", "l", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
  }
});

// node_modules/unidecode/data/xfc.js
var require_xfc = __commonJS({
  "node_modules/unidecode/data/xfc.js"(exports2, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
  }
});

// node_modules/unidecode/data/xfd.js
var require_xfd = __commonJS({
  "node_modules/unidecode/data/xfd.js"(exports2, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xfe.js
var require_xfe = __commonJS({
  "node_modules/unidecode/data/xfe.js"(exports2, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "~", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "..", "--", "-", "_", "_", "(", ") ", "{", "} ", "[", "] ", "[(", ")] ", "<<", ">> ", "<", "> ", "[", "] ", "{", "}", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", ",", ",", ".", "", ";", ":", "?", "!", "-", "(", ")", "{", "}", "{", "}", "#", "&", "*", "+", "-", "<", ">", "=", "", "\\", "$", "%", "@", "[?]", "[?]", "[?]", "[?]", "", "", "", "[?]", "", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", ""];
  }
});

// node_modules/unidecode/data/xff.js
var require_xff = __commonJS({
  "node_modules/unidecode/data/xff.js"(exports2, module2) {
    module2.exports = ["[?]", "!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~", "[?]", "[?]", ".", "[", "]", ",", "*", "wo", "a", "i", "u", "e", "o", "ya", "yu", "yo", "tu", "+", "a", "i", "u", "e", "o", "ka", "ki", "ku", "ke", "ko", "sa", "si", "su", "se", "so", "ta", "ti", "tu", "te", "to", "na", "ni", "nu", "ne", "no", "ha", "hi", "hu", "he", "ho", "ma", "mi", "mu", "me", "mo", "ya", "yu", "yo", "ra", "ri", "ru", "re", "ro", "wa", "n", ":", ";", "", "g", "gg", "gs", "n", "nj", "nh", "d", "dd", "r", "lg", "lm", "lb", "ls", "lt", "lp", "rh", "m", "b", "bb", "bs", "s", "ss", "", "j", "jj", "c", "k", "t", "p", "h", "[?]", "[?]", "[?]", "a", "ae", "ya", "yae", "eo", "e", "[?]", "[?]", "yeo", "ye", "o", "wa", "wae", "oe", "[?]", "[?]", "yo", "u", "weo", "we", "wi", "yu", "[?]", "[?]", "eu", "yi", "i", "[?]", "[?]", "[?]", "/C", "PS", "!", "-", "|", "Y=", "W=", "[?]", "|", "-", "|", "-", "|", "#", "O", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "{", "|", "}", "", "", "", ""];
  }
});

// node_modules/unidecode/unidecode.js
var require_unidecode = __commonJS({
  "node_modules/unidecode/unidecode.js"(exports2, module2) {
    "use strict";
    var tr = {};
    var utf8_rx = /(?![\x00-\x7F]|[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3})./g;
    module2.exports = function(str, sub) {
      return str.replace(utf8_rx, function(match) {
        return unidecode_internal_replace(match, sub);
      });
    };
    function unidecode_internal_replace(match, sub) {
      if (sub === null || sub === void 0) {
        sub = "";
      }
      var utf16 = utf8_to_utf16(match);
      if (utf16 > 65535) {
        return sub;
      } else {
        var h = utf16 >> 8;
        var l = utf16 & 255;
        if (h > 24 && h < 30) return sub;
        if (h > 215 && h < 249) return sub;
        if (!tr[h]) {
          switch (dec2hex(h)) {
            case "00":
              tr[h] = require_x00();
              break;
            case "01":
              tr[h] = require_x01();
              break;
            case "02":
              tr[h] = require_x02();
              break;
            case "03":
              tr[h] = require_x03();
              break;
            case "04":
              tr[h] = require_x04();
              break;
            case "05":
              tr[h] = require_x05();
              break;
            case "06":
              tr[h] = require_x06();
              break;
            case "07":
              tr[h] = require_x07();
              break;
            case "09":
              tr[h] = require_x09();
              break;
            case "0a":
              tr[h] = require_x0a();
              break;
            case "0b":
              tr[h] = require_x0b();
              break;
            case "0c":
              tr[h] = require_x0c();
              break;
            case "0d":
              tr[h] = require_x0d();
              break;
            case "0e":
              tr[h] = require_x0e();
              break;
            case "0f":
              tr[h] = require_x0f();
              break;
            case "10":
              tr[h] = require_x10();
              break;
            case "11":
              tr[h] = require_x11();
              break;
            case "12":
              tr[h] = require_x12();
              break;
            case "13":
              tr[h] = require_x13();
              break;
            case "14":
              tr[h] = require_x14();
              break;
            case "15":
              tr[h] = require_x15();
              break;
            case "16":
              tr[h] = require_x16();
              break;
            case "17":
              tr[h] = require_x17();
              break;
            case "18":
              tr[h] = require_x18();
              break;
            case "1e":
              tr[h] = require_x1e();
              break;
            case "1f":
              tr[h] = require_x1f();
              break;
            case "20":
              tr[h] = require_x20();
              break;
            case "21":
              tr[h] = require_x21();
              break;
            case "22":
              tr[h] = require_x22();
              break;
            case "23":
              tr[h] = require_x23();
              break;
            case "24":
              tr[h] = require_x24();
              break;
            case "25":
              tr[h] = require_x25();
              break;
            case "26":
              tr[h] = require_x26();
              break;
            case "27":
              tr[h] = require_x27();
              break;
            case "28":
              tr[h] = require_x28();
              break;
            case "2e":
              tr[h] = require_x2e();
              break;
            case "2f":
              tr[h] = require_x2f();
              break;
            case "30":
              tr[h] = require_x30();
              break;
            case "31":
              tr[h] = require_x31();
              break;
            case "32":
              tr[h] = require_x32();
              break;
            case "33":
              tr[h] = require_x33();
              break;
            case "4d":
              tr[h] = require_x4d();
              break;
            case "4e":
              tr[h] = require_x4e();
              break;
            case "4f":
              tr[h] = require_x4f();
              break;
            case "50":
              tr[h] = require_x50();
              break;
            case "51":
              tr[h] = require_x51();
              break;
            case "52":
              tr[h] = require_x52();
              break;
            case "53":
              tr[h] = require_x53();
              break;
            case "54":
              tr[h] = require_x54();
              break;
            case "55":
              tr[h] = require_x55();
              break;
            case "56":
              tr[h] = require_x56();
              break;
            case "57":
              tr[h] = require_x57();
              break;
            case "58":
              tr[h] = require_x58();
              break;
            case "59":
              tr[h] = require_x59();
              break;
            case "5a":
              tr[h] = require_x5a();
              break;
            case "5b":
              tr[h] = require_x5b();
              break;
            case "5c":
              tr[h] = require_x5c();
              break;
            case "5d":
              tr[h] = require_x5d();
              break;
            case "5e":
              tr[h] = require_x5e();
              break;
            case "5f":
              tr[h] = require_x5f();
              break;
            case "60":
              tr[h] = require_x60();
              break;
            case "61":
              tr[h] = require_x61();
              break;
            case "62":
              tr[h] = require_x62();
              break;
            case "63":
              tr[h] = require_x63();
              break;
            case "64":
              tr[h] = require_x64();
              break;
            case "65":
              tr[h] = require_x65();
              break;
            case "66":
              tr[h] = require_x66();
              break;
            case "67":
              tr[h] = require_x67();
              break;
            case "68":
              tr[h] = require_x68();
              break;
            case "69":
              tr[h] = require_x69();
              break;
            case "6a":
              tr[h] = require_x6a();
              break;
            case "6b":
              tr[h] = require_x6b();
              break;
            case "6c":
              tr[h] = require_x6c();
              break;
            case "6d":
              tr[h] = require_x6d();
              break;
            case "6e":
              tr[h] = require_x6e();
              break;
            case "6f":
              tr[h] = require_x6f();
              break;
            case "70":
              tr[h] = require_x70();
              break;
            case "71":
              tr[h] = require_x71();
              break;
            case "72":
              tr[h] = require_x72();
              break;
            case "73":
              tr[h] = require_x73();
              break;
            case "74":
              tr[h] = require_x74();
              break;
            case "75":
              tr[h] = require_x75();
              break;
            case "76":
              tr[h] = require_x76();
              break;
            case "77":
              tr[h] = require_x77();
              break;
            case "78":
              tr[h] = require_x78();
              break;
            case "79":
              tr[h] = require_x79();
              break;
            case "7a":
              tr[h] = require_x7a();
              break;
            case "7b":
              tr[h] = require_x7b();
              break;
            case "7c":
              tr[h] = require_x7c();
              break;
            case "7d":
              tr[h] = require_x7d();
              break;
            case "7e":
              tr[h] = require_x7e();
              break;
            case "7f":
              tr[h] = require_x7f();
              break;
            case "80":
              tr[h] = require_x80();
              break;
            case "81":
              tr[h] = require_x81();
              break;
            case "82":
              tr[h] = require_x82();
              break;
            case "83":
              tr[h] = require_x83();
              break;
            case "84":
              tr[h] = require_x84();
              break;
            case "85":
              tr[h] = require_x85();
              break;
            case "86":
              tr[h] = require_x86();
              break;
            case "87":
              tr[h] = require_x87();
              break;
            case "88":
              tr[h] = require_x88();
              break;
            case "89":
              tr[h] = require_x89();
              break;
            case "8a":
              tr[h] = require_x8a();
              break;
            case "8b":
              tr[h] = require_x8b();
              break;
            case "8c":
              tr[h] = require_x8c();
              break;
            case "8d":
              tr[h] = require_x8d();
              break;
            case "8e":
              tr[h] = require_x8e();
              break;
            case "8f":
              tr[h] = require_x8f();
              break;
            case "90":
              tr[h] = require_x90();
              break;
            case "91":
              tr[h] = require_x91();
              break;
            case "92":
              tr[h] = require_x92();
              break;
            case "93":
              tr[h] = require_x93();
              break;
            case "94":
              tr[h] = require_x94();
              break;
            case "95":
              tr[h] = require_x95();
              break;
            case "96":
              tr[h] = require_x96();
              break;
            case "97":
              tr[h] = require_x97();
              break;
            case "98":
              tr[h] = require_x98();
              break;
            case "99":
              tr[h] = require_x99();
              break;
            case "9a":
              tr[h] = require_x9a();
              break;
            case "9b":
              tr[h] = require_x9b();
              break;
            case "9c":
              tr[h] = require_x9c();
              break;
            case "9d":
              tr[h] = require_x9d();
              break;
            case "9e":
              tr[h] = require_x9e();
              break;
            case "9f":
              tr[h] = require_x9f();
              break;
            case "a0":
              tr[h] = require_xa0();
              break;
            case "a1":
              tr[h] = require_xa1();
              break;
            case "a2":
              tr[h] = require_xa2();
              break;
            case "a3":
              tr[h] = require_xa3();
              break;
            case "a4":
              tr[h] = require_xa4();
              break;
            case "ac":
              tr[h] = require_xac();
              break;
            case "ad":
              tr[h] = require_xad();
              break;
            case "ae":
              tr[h] = require_xae();
              break;
            case "af":
              tr[h] = require_xaf();
              break;
            case "b0":
              tr[h] = require_xb0();
              break;
            case "b1":
              tr[h] = require_xb1();
              break;
            case "b2":
              tr[h] = require_xb2();
              break;
            case "b3":
              tr[h] = require_xb3();
              break;
            case "b4":
              tr[h] = require_xb4();
              break;
            case "b5":
              tr[h] = require_xb5();
              break;
            case "b6":
              tr[h] = require_xb6();
              break;
            case "b7":
              tr[h] = require_xb7();
              break;
            case "b8":
              tr[h] = require_xb8();
              break;
            case "b9":
              tr[h] = require_xb9();
              break;
            case "ba":
              tr[h] = require_xba();
              break;
            case "bb":
              tr[h] = require_xbb();
              break;
            case "bc":
              tr[h] = require_xbc();
              break;
            case "bd":
              tr[h] = require_xbd();
              break;
            case "be":
              tr[h] = require_xbe();
              break;
            case "bf":
              tr[h] = require_xbf();
              break;
            case "c0":
              tr[h] = require_xc0();
              break;
            case "c1":
              tr[h] = require_xc1();
              break;
            case "c2":
              tr[h] = require_xc2();
              break;
            case "c3":
              tr[h] = require_xc3();
              break;
            case "c4":
              tr[h] = require_xc4();
              break;
            case "c5":
              tr[h] = require_xc5();
              break;
            case "c6":
              tr[h] = require_xc6();
              break;
            case "c7":
              tr[h] = require_xc7();
              break;
            case "c8":
              tr[h] = require_xc8();
              break;
            case "c9":
              tr[h] = require_xc9();
              break;
            case "ca":
              tr[h] = require_xca();
              break;
            case "cb":
              tr[h] = require_xcb();
              break;
            case "cc":
              tr[h] = require_xcc();
              break;
            case "cd":
              tr[h] = require_xcd();
              break;
            case "ce":
              tr[h] = require_xce();
              break;
            case "cf":
              tr[h] = require_xcf();
              break;
            case "d0":
              tr[h] = require_xd0();
              break;
            case "d1":
              tr[h] = require_xd1();
              break;
            case "d2":
              tr[h] = require_xd2();
              break;
            case "d3":
              tr[h] = require_xd3();
              break;
            case "d4":
              tr[h] = require_xd4();
              break;
            case "d5":
              tr[h] = require_xd5();
              break;
            case "d6":
              tr[h] = require_xd6();
              break;
            case "d7":
              tr[h] = require_xd7();
              break;
            case "f9":
              tr[h] = require_xf9();
              break;
            case "fa":
              tr[h] = require_xfa();
              break;
            case "fb":
              tr[h] = require_xfb();
              break;
            case "fc":
              tr[h] = require_xfc();
              break;
            case "fd":
              tr[h] = require_xfd();
              break;
            case "fe":
              tr[h] = require_xfe();
              break;
            case "ff":
              tr[h] = require_xff();
              break;
            default:
              return sub;
          }
        }
        if (tr[h][l]) {
          return tr[h][l];
        } else {
          return sub;
        }
      }
    }
    function dec2hex(i) {
      return (i + 256).toString(16).substr(-2);
    }
    function utf8_to_utf16(raw) {
      var b1, b2, b3, b4, x, y, z;
      while (Array.isArray(raw)) raw = raw[0];
      switch (raw.length) {
        case 1:
          return ord(raw);
        // http://en.wikipedia.org/wiki/UTF-8
        case 2:
          b1 = ord(raw.substr(0, 1));
          b2 = ord(raw.substr(1, 1));
          x = (b1 & 3) << 6 | b2 & 63;
          y = (b1 & 28) >> 2;
          return y << 8 | x;
        case 3:
          b1 = ord(raw.substr(0, 1));
          b2 = ord(raw.substr(1, 1));
          b3 = ord(raw.substr(2, 1));
          x = (b2 & 3) << 6 | b3 & 63;
          y = (b1 & 15) << 4 | (b2 & 60) >> 2;
          return y << 8 | x;
        default:
          b1 = ord(raw.substr(0, 1));
          b2 = ord(raw.substr(1, 1));
          b3 = ord(raw.substr(2, 1));
          b4 = ord(raw.substr(3, 1));
          x = (b3 & 3) << 6 | b4 & 63;
          y = (b2 & 15) << 4 | (b3 & 60) >> 2;
          z = (b1 & 7) << 5 | (b2 & 48) >> 4;
          return z << 16 | y << 8 | x;
      }
    }
    function ord(string2) {
      var str = string2 + "", code = str.charCodeAt(0);
      if (55296 <= code && code <= 56319) {
        var hi = code;
        if (str.length === 1) {
          return code;
        }
        var low = str.charCodeAt(1);
        return (hi - 55296) * 1024 + (low - 56320) + 65536;
      }
      if (56320 <= code && code <= 57343) {
        return code;
      }
      return code;
    }
  }
});

// src/util/node.ts
var import_util, fs, path, os, crypto, styles, debounce, readline, child_process, glob, minimatch, which, semver, vm, net, stripAnsi, fastDiff, unidecode;
var init_node = __esm({
  "src/util/node.ts"() {
    "use strict";
    import_util = require("util");
    fs = require("fs");
    path = require("path");
    os = require("os");
    crypto = require("crypto");
    styles = require_ansi_styles();
    debounce = require_debounce();
    readline = require("readline");
    child_process = require("child_process");
    glob = require_commonjs5();
    ({ minimatch } = require_commonjs());
    which = require_lib();
    semver = require_semver2();
    vm = require("vm");
    net = require("net");
    stripAnsi = require_strip_ansi();
    fastDiff = require_diff2();
    unidecode = require_unidecode();
  }
});

// src/logger/log.ts
function textToLogLevel(level2) {
  let str = level2.toLowerCase();
  switch (str) {
    case "trace":
      return 0 /* Trace */;
    case "debug":
      return 1 /* Debug */;
    case "info":
      return 2 /* Info */;
    case "error":
      return 4 /* Error */;
    case "warn":
    case "warning":
      return 3 /* Warning */;
    case "off":
      return 5 /* Off */;
    default:
      return 2 /* Info */;
  }
}
function format(args, depth = 2, color = false, hidden = false) {
  let result = "";
  for (let i = 0; i < args.length; i++) {
    let a = args[i];
    if (typeof a === "object") {
      try {
        a = (0, import_util.inspect)(a, hidden, depth, color);
      } catch (e) {
      }
    }
    if (color && (typeof a === "boolean" || typeof a === "number")) {
      a = `${yellowOpen}${a}${yellowClose}`;
    }
    result += (i > 0 ? " " : "") + a;
  }
  return result;
}
function stringifyLogLevel(level2) {
  switch (level2) {
    case 1 /* Debug */:
      return "DEBUG";
    case 4 /* Error */:
      return "ERROR";
    case 2 /* Info */:
      return "INFO";
    case 0 /* Trace */:
      return "TRACE";
    case 3 /* Warning */:
      return "WARN";
  }
  return "";
}
function getTimestamp(date) {
  return `${toTwoDigits(date.getHours())}:${toTwoDigits(date.getMinutes())}:${toTwoDigits(date.getSeconds())}.${toThreeDigits(date.getMilliseconds())}`;
}
var MAX_FILE_SIZE, yellowOpen, yellowClose, DEFAULT_LOG_LEVEL, toTwoDigits, toThreeDigits, AbstractLogger, FileLogger;
var init_log = __esm({
  "src/logger/log.ts"() {
    "use strict";
    init_node();
    MAX_FILE_SIZE = 5 * 1024 * 1024;
    yellowOpen = "\x1B[33m";
    yellowClose = "\x1B[39m";
    DEFAULT_LOG_LEVEL = 2 /* Info */;
    toTwoDigits = (v) => v < 10 ? `0${v}` : v.toString();
    toThreeDigits = (v) => v < 10 ? `00${v}` : v < 100 ? `0${v}` : v.toString();
    AbstractLogger = class {
      constructor() {
        this.level = DEFAULT_LOG_LEVEL;
      }
      setLevel(level2) {
        if (this.level !== level2) {
          this.level = level2;
        }
      }
      getLevel() {
        return this.level;
      }
    };
    FileLogger = class extends AbstractLogger {
      constructor(fsPath2, level2, config) {
        super();
        this.fsPath = fsPath2;
        this.backupIndex = 1;
        this.useConsole = false;
        this.loggers = /* @__PURE__ */ new Map();
        this.config = Object.assign({
          userFormatters: true,
          color: false,
          depth: 2,
          showHidden: false
        }, config);
        this.setLevel(level2);
        this.promise = this.initialize();
      }
      switchConsole() {
        this.useConsole = !this.useConsole;
      }
      format(args) {
        let { color, showHidden, depth } = this.config;
        return format(args, depth, color, showHidden);
      }
      createLogger(scope) {
        let logger60 = this.loggers.has(scope) ? this.loggers.get(scope) : {
          category: scope,
          mark: () => {
          },
          getLevel: () => {
            return this.getLevel();
          },
          trace: (...args) => {
            if (this.level <= 0 /* Trace */) {
              this._log(0 /* Trace */, scope, args, this.getCurrentTimestamp());
            }
          },
          debug: (...args) => {
            if (this.level <= 1 /* Debug */) {
              this._log(1 /* Debug */, scope, args, this.getCurrentTimestamp());
            }
          },
          log: (...args) => {
            if (this.level <= 2 /* Info */) {
              this._log(2 /* Info */, scope, args, this.getCurrentTimestamp());
            }
          },
          info: (...args) => {
            if (this.level <= 2 /* Info */) {
              this._log(2 /* Info */, scope, args, this.getCurrentTimestamp());
            }
          },
          warn: (...args) => {
            if (this.level <= 3 /* Warning */) {
              this._log(3 /* Warning */, scope, args, this.getCurrentTimestamp());
            }
          },
          error: (...args) => {
            if (this.level <= 4 /* Error */) {
              this._log(4 /* Error */, scope, args, this.getCurrentTimestamp());
            }
          },
          fatal: (...args) => {
            if (this.level <= 4 /* Error */) {
              this._log(4 /* Error */, scope, args, this.getCurrentTimestamp());
            }
          },
          /**
           * An operation to flush the contents. Can be synchronous.
           */
          flush: () => {
            return this.promise;
          }
        };
        this.loggers.set(scope, logger60);
        return logger60;
      }
      async initialize() {
        return Promise.resolve();
      }
      shouldBackup(size) {
        return size > MAX_FILE_SIZE;
      }
      _log(level2, scope, args, time) {
        if (this.useConsole) {
          let method = level2 === 4 /* Error */ ? "error" : "log";
          console[method](`${stringifyLogLevel(level2)} [${scope}]`, format(args, null, true));
        } else {
          let message = this.format(args);
          this.promise = this.promise.then(() => {
            let fn = async () => {
              let text;
              if (this.config.userFormatters !== false) {
                let parts = [time, stringifyLogLevel(level2), `(pid:${process.pid})`, `[${scope}]`];
                text = `${parts.join(" ")} - ${message}
`;
              } else {
                text = message;
              }
              await (0, import_util.promisify)(fs.appendFile)(this.fsPath, text, { encoding: "utf8", flag: "a+" });
              let stat = await (0, import_util.promisify)(fs.stat)(this.fsPath);
              if (this.shouldBackup(stat.size)) {
                let newFile = this.getBackupResource();
                await (0, import_util.promisify)(fs.rename)(this.fsPath, newFile);
              }
            };
            return fn();
          }).catch((err) => {
            if (!global.REVISION) {
              console.error(err);
            }
          });
        }
      }
      getCurrentTimestamp() {
        const currentTime = /* @__PURE__ */ new Date();
        return `${currentTime.getFullYear()}-${toTwoDigits(currentTime.getMonth() + 1)}-${toTwoDigits(currentTime.getDate())}T${getTimestamp(currentTime)}`;
      }
      getBackupResource() {
        this.backupIndex = this.backupIndex > 5 ? 1 : this.backupIndex;
        return path.join(path.dirname(this.fsPath), `${path.basename(this.fsPath)}_${this.backupIndex++}`);
      }
    };
  }
});

// src/util/index.ts
function sha256(data) {
  return crypto.createHash("sha256").update(data).digest("hex");
}
function getConditionValue(value, testValue) {
  return false ? testValue : value;
}
function defaultValue(val, defaultValue2) {
  return val == null ? defaultValue2 : val;
}
function wait(ms) {
  if (ms <= 0) return Promise.resolve(void 0);
  return new Promise((resolve) => {
    let timer = setTimeout(() => {
      resolve(void 0);
    }, ms);
    timer.unref();
  });
}
function waitWithToken(ms, token) {
  if (token.isCancellationRequested || !ms) return Promise.resolve(true);
  return new Promise((resolve) => {
    let disposable = token.onCancellationRequested(() => {
      disposable.dispose();
      clearTimeout(timer);
      resolve(true);
    });
    let timer = setTimeout(() => {
      disposable.dispose();
      resolve(false);
    }, ms);
    timer.unref();
  });
}
function waitNextTick() {
  return new Promise((resolve) => {
    process.nextTick(() => {
      resolve(void 0);
    });
  });
}
function waitImmediate() {
  return new Promise((resolve) => {
    setImmediate(() => {
      resolve(void 0);
    });
  });
}
function concurrent(arr, fn, limit = 3) {
  if (arr.length == 0) return Promise.resolve();
  let finished = 0;
  let total = arr.length;
  let remain = arr.slice();
  return new Promise((resolve) => {
    let run = (val) => {
      let cb = () => {
        finished = finished + 1;
        if (finished == total) {
          resolve();
        } else if (remain.length) {
          let next = remain.shift();
          run(next);
        }
      };
      fn(val).then(cb, cb);
    };
    for (let i = 0; i < Math.min(limit, remain.length); i++) {
      let val = remain.shift();
      run(val);
    }
  });
}
function disposeAll(disposables) {
  while (disposables.length) {
    const item = disposables.pop();
    item?.dispose();
  }
}
var pariedCharacters;
var init_util = __esm({
  "src/util/index.ts"() {
    "use strict";
    init_node();
    pariedCharacters = /* @__PURE__ */ new Map([
      ["<", ">"],
      [">", "<"],
      ["{", "}"],
      ["[", "]"],
      ["(", ")"]
    ]);
  }
});

// src/logger/index.ts
var logger_exports = {};
__export(logger_exports, {
  createLogger: () => createLogger,
  emptyFile: () => emptyFile,
  getLoggerFile: () => getLoggerFile,
  getTimestamp: () => getTimestamp,
  logger: () => logger,
  resolveLogFilepath: () => resolveLogFilepath
});
function resolveLogFilepath() {
  let file = process.env.NVIM_COC_LOG_FILE;
  if (file) return file;
  let dir = process.env.XDG_RUNTIME_DIR;
  if (dir) {
    try {
      fs.accessSync(dir, fs.constants.R_OK | fs.constants.W_OK);
      return path.join(dir, `coc-nvim-${process.pid}.log`);
    } catch (err) {
    }
  }
  let tmpdir = os.tmpdir();
  dir = path.join(tmpdir, `coc.nvim-${process.pid}`);
  fs.mkdirSync(dir, { recursive: true });
  return path.join(dir, `coc-nvim.log`);
}
function emptyFile(filepath) {
  if (fs.existsSync(filepath)) {
    try {
      fs.writeFileSync(filepath, "", { encoding: "utf8", mode: 438 });
    } catch (e) {
    }
  }
}
function getLoggerFile() {
  return logfile;
}
function createLogger(category = "coc.nvim") {
  return logger.createLogger(category);
}
var logfile, level, logger;
var init_logger = __esm({
  "src/logger/index.ts"() {
    "use strict";
    init_log();
    init_node();
    init_util();
    init_log();
    logfile = resolveLogFilepath();
    emptyFile(logfile);
    level = getConditionValue(process.env.NVIM_COC_LOG_LEVEL || "info", "off");
    logger = new FileLogger(logfile, textToLogLevel(level), {
      color: !global.REVISION && process.platform !== "win32",
      userFormatters: true
    });
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/buffer-global.js
var require_buffer_global = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/buffer-global.js"(exports2, module2) {
    module2.exports = c("undefined" !== typeof Buffer && Buffer) || c(exports2.Buffer) || c("undefined" !== typeof window && window.Buffer) || exports2.Buffer;
    function c(B) {
      return B && B.isBuffer && B;
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/bufferish-array.js
var require_bufferish_array = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/bufferish-array.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var exports2 = module2.exports = alloc(0);
    exports2.alloc = alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return new Array(size);
    }
    function from(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return Array.prototype.slice.call(value);
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/bufferish-buffer.js
var require_bufferish_buffer = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/bufferish-buffer.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var exports2 = module2.exports = Bufferish.hasBuffer ? alloc(0) : [];
    exports2.alloc = Bufferish.hasBuffer && Buffer3.alloc || alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return Buffer3.alloc(size);
    }
    function from(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (Buffer3.from && Buffer3.from.length !== 1) {
        return Buffer3.from(value);
      } else {
        return new Buffer3(value);
      }
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/bufferish-uint8array.js
var require_bufferish_uint8array = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/bufferish-uint8array.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var exports2 = module2.exports = Bufferish.hasArrayBuffer ? alloc(0) : [];
    exports2.alloc = alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return new Uint8Array(size);
    }
    function from(value) {
      if (Bufferish.isView(value)) {
        var byteOffset = value.byteOffset;
        var byteLength2 = value.byteLength;
        value = value.buffer;
        if (value.byteLength !== byteLength2) {
          if (value.slice) {
            value = value.slice(byteOffset, byteOffset + byteLength2);
          } else {
            value = new Uint8Array(value);
            if (value.byteLength !== byteLength2) {
              value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength2);
            }
          }
        }
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return new Uint8Array(value);
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/buffer-lite.js
var require_buffer_lite = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/buffer-lite.js"(exports2) {
    exports2.copy = copy;
    exports2.toString = toString;
    exports2.write = write;
    function write(string2, offset) {
      var buffer = this;
      var index = offset || (offset |= 0);
      var length = string2.length;
      var chr = 0;
      var i = 0;
      while (i < length) {
        chr = string2.charCodeAt(i++);
        if (chr < 128) {
          buffer[index++] = chr;
        } else if (chr < 2048) {
          buffer[index++] = 192 | chr >>> 6;
          buffer[index++] = 128 | chr & 63;
        } else if (chr < 55296 || chr > 57343) {
          buffer[index++] = 224 | chr >>> 12;
          buffer[index++] = 128 | chr >>> 6 & 63;
          buffer[index++] = 128 | chr & 63;
        } else {
          chr = (chr - 55296 << 10 | string2.charCodeAt(i++) - 56320) + 65536;
          buffer[index++] = 240 | chr >>> 18;
          buffer[index++] = 128 | chr >>> 12 & 63;
          buffer[index++] = 128 | chr >>> 6 & 63;
          buffer[index++] = 128 | chr & 63;
        }
      }
      return index - offset;
    }
    function toString(encoding2, start, end) {
      var buffer = this;
      var index = start | 0;
      if (!end) end = buffer.length;
      var string2 = "";
      var chr = 0;
      while (index < end) {
        chr = buffer[index++];
        if (chr < 128) {
          string2 += String.fromCharCode(chr);
          continue;
        }
        if ((chr & 224) === 192) {
          chr = (chr & 31) << 6 | buffer[index++] & 63;
        } else if ((chr & 240) === 224) {
          chr = (chr & 15) << 12 | (buffer[index++] & 63) << 6 | buffer[index++] & 63;
        } else if ((chr & 248) === 240) {
          chr = (chr & 7) << 18 | (buffer[index++] & 63) << 12 | (buffer[index++] & 63) << 6 | buffer[index++] & 63;
        }
        if (chr >= 65536) {
          chr -= 65536;
          string2 += String.fromCharCode((chr >>> 10) + 55296, (chr & 1023) + 56320);
        } else {
          string2 += String.fromCharCode(chr);
        }
      }
      return string2;
    }
    function copy(target, targetStart, start, end) {
      var i;
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (!targetStart) targetStart = 0;
      var len = end - start;
      if (target === this && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; i--) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        for (i = 0; i < len; i++) {
          target[i + targetStart] = this[i + start];
        }
      }
      return len;
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/bufferish-proto.js
var require_bufferish_proto = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/bufferish-proto.js"(exports2) {
    var BufferLite = require_buffer_lite();
    exports2.copy = copy;
    exports2.slice = slice;
    exports2.toString = toString;
    exports2.write = gen("write");
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var isBufferShim = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer3;
    var brokenTypedArray = isBufferShim && !Buffer3.TYPED_ARRAY_SUPPORT;
    function copy(target, targetStart, start, end) {
      var thisIsBuffer = Bufferish.isBuffer(this);
      var targetIsBuffer = Bufferish.isBuffer(target);
      if (thisIsBuffer && targetIsBuffer) {
        return this.copy(target, targetStart, start, end);
      } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish.isView(this) && Bufferish.isView(target)) {
        var buffer = start || end != null ? slice.call(this, start, end) : this;
        target.set(buffer, targetStart);
        return buffer.length;
      } else {
        return BufferLite.copy.call(this, target, targetStart, start, end);
      }
    }
    function slice(start, end) {
      var f = this.slice || !brokenTypedArray && this.subarray;
      if (f) return f.call(this, start, end);
      var target = Bufferish.alloc.call(this, end - start);
      copy.call(this, target, 0, start, end);
      return target;
    }
    function toString(encoding2, start, end) {
      var f = !isBufferShim && Bufferish.isBuffer(this) ? this.toString : BufferLite.toString;
      return f.apply(this, arguments);
    }
    function gen(method) {
      return wrap;
      function wrap() {
        var f = this[method] || BufferLite[method];
        return f.apply(this, arguments);
      }
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/bufferish.js
var require_bufferish = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/bufferish.js"(exports2) {
    var Buffer3 = exports2.global = require_buffer_global();
    var hasBuffer = exports2.hasBuffer = Buffer3 && !!Buffer3.isBuffer;
    var hasArrayBuffer = exports2.hasArrayBuffer = "undefined" !== typeof ArrayBuffer;
    exports2.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;
    var isBuffer = exports2.isBuffer = hasBuffer ? Buffer3.isBuffer : _false;
    var isView = exports2.isView = hasArrayBuffer ? ArrayBuffer.isView || _is("ArrayBuffer", "buffer") : _false;
    exports2.alloc = alloc;
    exports2.concat = concat;
    exports2.from = from;
    var BufferArray = exports2.Array = require_bufferish_array();
    var BufferBuffer = exports2.Buffer = require_bufferish_buffer();
    var BufferUint8Array = exports2.Uint8Array = require_bufferish_uint8array();
    var BufferProto = exports2.prototype = require_bufferish_proto();
    function from(value) {
      if (typeof value === "string") {
        return fromString.call(this, value);
      } else {
        return auto(this).from(value);
      }
    }
    function alloc(size) {
      return auto(this).alloc(size);
    }
    function concat(list2, length) {
      if (!length) {
        length = 0;
        Array.prototype.forEach.call(list2, dryrun);
      }
      var ref = this !== exports2 && this || list2[0];
      var result = alloc.call(ref, length);
      var offset = 0;
      Array.prototype.forEach.call(list2, append);
      return result;
      function dryrun(buffer) {
        length += buffer.length;
      }
      function append(buffer) {
        offset += BufferProto.copy.call(buffer, result, offset);
      }
    }
    var _isArrayBuffer = _is("ArrayBuffer");
    function isArrayBuffer(value) {
      return value instanceof ArrayBuffer || _isArrayBuffer(value);
    }
    function fromString(value) {
      var expected = value.length * 3;
      var that = alloc.call(this, expected);
      var actual = BufferProto.write.call(that, value);
      if (expected !== actual) {
        that = BufferProto.slice.call(that, 0, actual);
      }
      return that;
    }
    function auto(that) {
      return isBuffer(that) ? BufferBuffer : isView(that) ? BufferUint8Array : Array.isArray(that) ? BufferArray : hasBuffer ? BufferBuffer : hasArrayBuffer ? BufferUint8Array : BufferArray;
    }
    function _false() {
      return false;
    }
    function _is(name2, key) {
      name2 = "[object " + name2 + "]";
      return function(value) {
        return value != null && {}.toString.call(key ? value[key] : value) === name2;
      };
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/ext-buffer.js
var require_ext_buffer = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/ext-buffer.js"(exports2) {
    exports2.ExtBuffer = ExtBuffer;
    var Bufferish = require_bufferish();
    function ExtBuffer(buffer, type) {
      if (!(this instanceof ExtBuffer)) return new ExtBuffer(buffer, type);
      this.buffer = Bufferish.from(buffer);
      this.type = type;
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/ext-packer.js
var require_ext_packer = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/ext-packer.js"(exports2) {
    exports2.setExtPackers = setExtPackers;
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var packTypedArray = Bufferish.Uint8Array.from;
    var _encode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtPackers(codec) {
      codec.addExtPacker(14, Error, [packError, encode]);
      codec.addExtPacker(1, EvalError, [packError, encode]);
      codec.addExtPacker(2, RangeError, [packError, encode]);
      codec.addExtPacker(3, ReferenceError, [packError, encode]);
      codec.addExtPacker(4, SyntaxError, [packError, encode]);
      codec.addExtPacker(5, TypeError, [packError, encode]);
      codec.addExtPacker(6, URIError, [packError, encode]);
      codec.addExtPacker(10, RegExp, [packRegExp, encode]);
      codec.addExtPacker(11, Boolean, [packValueOf, encode]);
      codec.addExtPacker(12, String, [packValueOf, encode]);
      codec.addExtPacker(13, Date, [Number, encode]);
      codec.addExtPacker(15, Number, [packValueOf, encode]);
      if ("undefined" !== typeof Uint8Array) {
        codec.addExtPacker(17, Int8Array, packTypedArray);
        codec.addExtPacker(18, Uint8Array, packTypedArray);
        codec.addExtPacker(19, Int16Array, packTypedArray);
        codec.addExtPacker(20, Uint16Array, packTypedArray);
        codec.addExtPacker(21, Int32Array, packTypedArray);
        codec.addExtPacker(22, Uint32Array, packTypedArray);
        codec.addExtPacker(23, Float32Array, packTypedArray);
        if ("undefined" !== typeof Float64Array) {
          codec.addExtPacker(24, Float64Array, packTypedArray);
        }
        if ("undefined" !== typeof Uint8ClampedArray) {
          codec.addExtPacker(25, Uint8ClampedArray, packTypedArray);
        }
        codec.addExtPacker(26, ArrayBuffer, packTypedArray);
        codec.addExtPacker(29, DataView, packTypedArray);
      }
      if (Bufferish.hasBuffer) {
        codec.addExtPacker(27, Buffer3, Bufferish.from);
      }
    }
    function encode(input) {
      if (!_encode) _encode = require_encode().encode;
      return _encode(input);
    }
    function packValueOf(value) {
      return value.valueOf();
    }
    function packRegExp(value) {
      value = RegExp.prototype.toString.call(value).split("/");
      value.shift();
      var out = [value.pop()];
      out.unshift(value.join("/"));
      return out;
    }
    function packError(value) {
      var out = {};
      for (var key in ERROR_COLUMNS) {
        out[key] = value[key];
      }
      return out;
    }
  }
});

// node_modules/int64-buffer/int64-buffer.js
var require_int64_buffer = __commonJS({
  "node_modules/int64-buffer/int64-buffer.js"(exports2) {
    var Uint64BE;
    var Int64BE;
    var Uint64LE;
    var Int64LE;
    !function(exports3) {
      var UNDEFINED = "undefined";
      var BUFFER = UNDEFINED !== typeof Buffer && Buffer;
      var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
      var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
      var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
      var isArray = Array.isArray || _isArray;
      var BIT32 = 4294967296;
      var BIT24 = 16777216;
      var storage;
      Uint64BE = factory("Uint64BE", true, true);
      Int64BE = factory("Int64BE", true, false);
      Uint64LE = factory("Uint64LE", false, true);
      Int64LE = factory("Int64LE", false, false);
      function factory(name2, bigendian, unsigned) {
        var posH = bigendian ? 0 : 4;
        var posL = bigendian ? 4 : 0;
        var pos0 = bigendian ? 0 : 3;
        var pos1 = bigendian ? 1 : 2;
        var pos2 = bigendian ? 2 : 1;
        var pos3 = bigendian ? 3 : 0;
        var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
        var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
        var proto = Int64.prototype;
        var isName = "is" + name2;
        var _isInt64 = "_" + isName;
        proto.buffer = void 0;
        proto.offset = 0;
        proto[_isInt64] = true;
        proto.toNumber = toNumber2;
        proto.toString = toString;
        proto.toJSON = toNumber2;
        proto.toArray = toArray2;
        if (BUFFER) proto.toBuffer = toBuffer;
        if (UINT8ARRAY) proto.toArrayBuffer = toArrayBuffer;
        Int64[isName] = isInt64;
        exports3[name2] = Int64;
        return Int64;
        function Int64(buffer, offset, value, raddix) {
          if (!(this instanceof Int64)) return new Int64(buffer, offset, value, raddix);
          return init(this, buffer, offset, value, raddix);
        }
        function isInt64(b) {
          return !!(b && b[_isInt64]);
        }
        function init(that, buffer, offset, value, raddix) {
          if (UINT8ARRAY && ARRAYBUFFER) {
            if (buffer instanceof ARRAYBUFFER) buffer = new UINT8ARRAY(buffer);
            if (value instanceof ARRAYBUFFER) value = new UINT8ARRAY(value);
          }
          if (!buffer && !offset && !value && !storage) {
            that.buffer = newArray(ZERO, 0);
            return;
          }
          if (!isValidBuffer(buffer, offset)) {
            var _storage = storage || Array;
            raddix = offset;
            value = buffer;
            offset = 0;
            buffer = new _storage(8);
          }
          that.buffer = buffer;
          that.offset = offset |= 0;
          if (UNDEFINED === typeof value) return;
          if ("string" === typeof value) {
            fromString(buffer, offset, value, raddix || 10);
          } else if (isValidBuffer(value, raddix)) {
            fromArray(buffer, offset, value, raddix);
          } else if ("number" === typeof raddix) {
            writeInt32(buffer, offset + posH, value);
            writeInt32(buffer, offset + posL, raddix);
          } else if (value > 0) {
            fromPositive(buffer, offset, value);
          } else if (value < 0) {
            fromNegative(buffer, offset, value);
          } else {
            fromArray(buffer, offset, ZERO, 0);
          }
        }
        function fromString(buffer, offset, str, raddix) {
          var pos = 0;
          var len = str.length;
          var high = 0;
          var low = 0;
          if (str[0] === "-") pos++;
          var sign = pos;
          while (pos < len) {
            var chr = parseInt(str[pos++], raddix);
            if (!(chr >= 0)) break;
            low = low * raddix + chr;
            high = high * raddix + Math.floor(low / BIT32);
            low %= BIT32;
          }
          if (sign) {
            high = ~high;
            if (low) {
              low = BIT32 - low;
            } else {
              high++;
            }
          }
          writeInt32(buffer, offset + posH, high);
          writeInt32(buffer, offset + posL, low);
        }
        function toNumber2() {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          if (!unsigned) high |= 0;
          return high ? high * BIT32 + low : low;
        }
        function toString(radix) {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          var str = "";
          var sign = !unsigned && high & 2147483648;
          if (sign) {
            high = ~high;
            low = BIT32 - low;
          }
          radix = radix || 10;
          while (1) {
            var mod = high % radix * BIT32 + low;
            high = Math.floor(high / radix);
            low = Math.floor(mod / radix);
            str = (mod % radix).toString(radix) + str;
            if (!high && !low) break;
          }
          if (sign) {
            str = "-" + str;
          }
          return str;
        }
        function writeInt32(buffer, offset, value) {
          buffer[offset + pos3] = value & 255;
          value = value >> 8;
          buffer[offset + pos2] = value & 255;
          value = value >> 8;
          buffer[offset + pos1] = value & 255;
          value = value >> 8;
          buffer[offset + pos0] = value & 255;
        }
        function readInt32(buffer, offset) {
          return buffer[offset + pos0] * BIT24 + (buffer[offset + pos1] << 16) + (buffer[offset + pos2] << 8) + buffer[offset + pos3];
        }
      }
      function toArray2(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = null;
        if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer)) return buffer;
        return newArray(buffer, offset);
      }
      function toBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = BUFFER;
        if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer)) return buffer;
        var dest = new BUFFER(8);
        fromArray(dest, 0, buffer, offset);
        return dest;
      }
      function toArrayBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        var arrbuf = buffer.buffer;
        storage = UINT8ARRAY;
        if (raw !== false && offset === 0 && arrbuf instanceof ARRAYBUFFER && arrbuf.byteLength === 8) return arrbuf;
        var dest = new UINT8ARRAY(8);
        fromArray(dest, 0, buffer, offset);
        return dest.buffer;
      }
      function isValidBuffer(buffer, offset) {
        var len = buffer && buffer.length;
        offset |= 0;
        return len && offset + 8 <= len && "string" !== typeof buffer[offset];
      }
      function fromArray(destbuf, destoff, srcbuf, srcoff) {
        destoff |= 0;
        srcoff |= 0;
        for (var i = 0; i < 8; i++) {
          destbuf[destoff++] = srcbuf[srcoff++] & 255;
        }
      }
      function newArray(buffer, offset) {
        return Array.prototype.slice.call(buffer, offset, offset + 8);
      }
      function fromPositiveBE(buffer, offset, value) {
        var pos = offset + 8;
        while (pos > offset) {
          buffer[--pos] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeBE(buffer, offset, value) {
        var pos = offset + 8;
        value++;
        while (pos > offset) {
          buffer[--pos] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function fromPositiveLE(buffer, offset, value) {
        var end = offset + 8;
        while (offset < end) {
          buffer[offset++] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeLE(buffer, offset, value) {
        var end = offset + 8;
        value++;
        while (offset < end) {
          buffer[offset++] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function _isArray(val) {
        return !!val && "[object Array]" == Object.prototype.toString.call(val);
      }
    }(typeof exports2 === "object" && typeof exports2.nodeName !== "string" ? exports2 : exports2 || {});
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/write-uint8.js
var require_write_uint8 = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/write-uint8.js"(exports2) {
    var constant = exports2.uint8 = new Array(256);
    for (i = 0; i <= 255; i++) {
      constant[i] = write0(i);
    }
    var i;
    function write0(type) {
      return function(encoder) {
        var offset = encoder.reserve(1);
        encoder.buffer[offset] = type;
      };
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/write-token.js
var require_write_token = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/write-token.js"(exports2) {
    var ieee754 = require_ieee754();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    var uint8 = require_write_uint8().uint8;
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var IS_BUFFER_SHIM = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer3;
    var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer3.TYPED_ARRAY_SUPPORT;
    var Buffer_prototype = Bufferish.hasBuffer && Buffer3.prototype || {};
    exports2.getWriteToken = getWriteToken;
    function getWriteToken(options2) {
      if (options2 && options2.uint8array) {
        return init_uint8array();
      } else if (NO_TYPED_ARRAY || Bufferish.hasBuffer && options2 && options2.safe) {
        return init_safe();
      } else {
        return init_token();
      }
    }
    function init_uint8array() {
      var token = init_token();
      token[202] = writeN(202, 4, writeFloatBE);
      token[203] = writeN(203, 8, writeDoubleBE);
      return token;
    }
    function init_token() {
      var token = uint8.slice();
      token[196] = write1(196);
      token[197] = write2(197);
      token[198] = write4(198);
      token[199] = write1(199);
      token[200] = write2(200);
      token[201] = write4(201);
      token[202] = writeN(202, 4, Buffer_prototype.writeFloatBE || writeFloatBE, true);
      token[203] = writeN(203, 8, Buffer_prototype.writeDoubleBE || writeDoubleBE, true);
      token[204] = write1(204);
      token[205] = write2(205);
      token[206] = write4(206);
      token[207] = writeN(207, 8, writeUInt64BE);
      token[208] = write1(208);
      token[209] = write2(209);
      token[210] = write4(210);
      token[211] = writeN(211, 8, writeInt64BE);
      token[217] = write1(217);
      token[218] = write2(218);
      token[219] = write4(219);
      token[220] = write2(220);
      token[221] = write4(221);
      token[222] = write2(222);
      token[223] = write4(223);
      return token;
    }
    function init_safe() {
      var token = uint8.slice();
      token[196] = writeN(196, 1, Buffer3.prototype.writeUInt8);
      token[197] = writeN(197, 2, Buffer3.prototype.writeUInt16BE);
      token[198] = writeN(198, 4, Buffer3.prototype.writeUInt32BE);
      token[199] = writeN(199, 1, Buffer3.prototype.writeUInt8);
      token[200] = writeN(200, 2, Buffer3.prototype.writeUInt16BE);
      token[201] = writeN(201, 4, Buffer3.prototype.writeUInt32BE);
      token[202] = writeN(202, 4, Buffer3.prototype.writeFloatBE);
      token[203] = writeN(203, 8, Buffer3.prototype.writeDoubleBE);
      token[204] = writeN(204, 1, Buffer3.prototype.writeUInt8);
      token[205] = writeN(205, 2, Buffer3.prototype.writeUInt16BE);
      token[206] = writeN(206, 4, Buffer3.prototype.writeUInt32BE);
      token[207] = writeN(207, 8, writeUInt64BE);
      token[208] = writeN(208, 1, Buffer3.prototype.writeInt8);
      token[209] = writeN(209, 2, Buffer3.prototype.writeInt16BE);
      token[210] = writeN(210, 4, Buffer3.prototype.writeInt32BE);
      token[211] = writeN(211, 8, writeInt64BE);
      token[217] = writeN(217, 1, Buffer3.prototype.writeUInt8);
      token[218] = writeN(218, 2, Buffer3.prototype.writeUInt16BE);
      token[219] = writeN(219, 4, Buffer3.prototype.writeUInt32BE);
      token[220] = writeN(220, 2, Buffer3.prototype.writeUInt16BE);
      token[221] = writeN(221, 4, Buffer3.prototype.writeUInt32BE);
      token[222] = writeN(222, 2, Buffer3.prototype.writeUInt16BE);
      token[223] = writeN(223, 4, Buffer3.prototype.writeUInt32BE);
      return token;
    }
    function write1(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(2);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset] = value;
      };
    }
    function write2(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(3);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset++] = value >>> 8;
        buffer[offset] = value;
      };
    }
    function write4(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(5);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset++] = value >>> 24;
        buffer[offset++] = value >>> 16;
        buffer[offset++] = value >>> 8;
        buffer[offset] = value;
      };
    }
    function writeN(type, len, method, noAssert) {
      return function(encoder, value) {
        var offset = encoder.reserve(len + 1);
        encoder.buffer[offset++] = type;
        method.call(encoder.buffer, value, offset, noAssert);
      };
    }
    function writeUInt64BE(value, offset) {
      new Uint64BE(this, offset, value);
    }
    function writeInt64BE(value, offset) {
      new Int64BE(this, offset, value);
    }
    function writeFloatBE(value, offset) {
      ieee754.write(this, value, offset, false, 23, 4);
    }
    function writeDoubleBE(value, offset) {
      ieee754.write(this, value, offset, false, 52, 8);
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/write-type.js
var require_write_type = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/write-type.js"(exports2) {
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    var Bufferish = require_bufferish();
    var BufferProto = require_bufferish_proto();
    var WriteToken = require_write_token();
    var uint8 = require_write_uint8().uint8;
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var HAS_UINT8ARRAY = "undefined" !== typeof Uint8Array;
    var HAS_MAP = "undefined" !== typeof Map;
    var extmap = [];
    extmap[1] = 212;
    extmap[2] = 213;
    extmap[4] = 214;
    extmap[8] = 215;
    extmap[16] = 216;
    exports2.getWriteType = getWriteType;
    function getWriteType(options2) {
      var token = WriteToken.getWriteToken(options2);
      var useraw = options2 && options2.useraw;
      var binarraybuffer = HAS_UINT8ARRAY && options2 && options2.binarraybuffer;
      var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;
      var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;
      var usemap = HAS_MAP && options2 && options2.usemap;
      var map = usemap ? map_to_map : obj_to_map;
      var writeType = {
        "boolean": bool,
        "function": nil,
        "number": number2,
        "object": useraw ? object_raw : object,
        "string": _string(useraw ? raw_head_size : str_head_size),
        "symbol": nil,
        "undefined": nil
      };
      return writeType;
      function bool(encoder, value) {
        var type = value ? 195 : 194;
        token[type](encoder, value);
      }
      function number2(encoder, value) {
        var ivalue = value | 0;
        var type;
        if (value !== ivalue) {
          type = 203;
          token[type](encoder, value);
          return;
        } else if (-32 <= ivalue && ivalue <= 127) {
          type = ivalue & 255;
        } else if (0 <= ivalue) {
          type = ivalue <= 255 ? 204 : ivalue <= 65535 ? 205 : 206;
        } else {
          type = -128 <= ivalue ? 208 : -32768 <= ivalue ? 209 : 210;
        }
        token[type](encoder, ivalue);
      }
      function uint64(encoder, value) {
        var type = 207;
        token[type](encoder, value.toArray());
      }
      function int64(encoder, value) {
        var type = 211;
        token[type](encoder, value.toArray());
      }
      function str_head_size(length) {
        return length < 32 ? 1 : length <= 255 ? 2 : length <= 65535 ? 3 : 5;
      }
      function raw_head_size(length) {
        return length < 32 ? 1 : length <= 65535 ? 3 : 5;
      }
      function _string(head_size) {
        return string2;
        function string2(encoder, value) {
          var length = value.length;
          var maxsize = 5 + length * 3;
          encoder.offset = encoder.reserve(maxsize);
          var buffer = encoder.buffer;
          var expected = head_size(length);
          var start = encoder.offset + expected;
          length = BufferProto.write.call(buffer, value, start);
          var actual = head_size(length);
          if (expected !== actual) {
            var targetStart = start + actual - expected;
            var end = start + length;
            BufferProto.copy.call(buffer, buffer, targetStart, start, end);
          }
          var type = actual === 1 ? 160 + length : actual <= 3 ? 215 + actual : 219;
          token[type](encoder, length);
          encoder.offset += length;
        }
      }
      function object(encoder, value) {
        if (value === null) return nil(encoder, value);
        if (isBuffer(value)) return bin(encoder, value);
        if (Array.isArray(value)) return array(encoder, value);
        if (Uint64BE.isUint64BE(value)) return uint64(encoder, value);
        if (Int64BE.isInt64BE(value)) return int64(encoder, value);
        var packer = encoder.codec.getExtPacker(value);
        if (packer) value = packer(value);
        if (value instanceof ExtBuffer) return ext(encoder, value);
        map(encoder, value);
      }
      function object_raw(encoder, value) {
        if (isBuffer(value)) return raw(encoder, value);
        object(encoder, value);
      }
      function nil(encoder, value) {
        var type = 192;
        token[type](encoder, value);
      }
      function array(encoder, value) {
        var length = value.length;
        var type = length < 16 ? 144 + length : length <= 65535 ? 220 : 221;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        for (var i = 0; i < length; i++) {
          encode(encoder, value[i]);
        }
      }
      function bin_buffer(encoder, value) {
        var length = value.length;
        var type = length < 255 ? 196 : length <= 65535 ? 197 : 198;
        token[type](encoder, length);
        encoder.send(value);
      }
      function bin_arraybuffer(encoder, value) {
        bin_buffer(encoder, new Uint8Array(value));
      }
      function ext(encoder, value) {
        var buffer = value.buffer;
        var length = buffer.length;
        var type = extmap[length] || (length < 255 ? 199 : length <= 65535 ? 200 : 201);
        token[type](encoder, length);
        uint8[value.type](encoder);
        encoder.send(buffer);
      }
      function obj_to_map(encoder, value) {
        var keys = [];
        for (let [key, val] of Object.entries(value)) {
          if (val !== void 0) keys.push(key);
        }
        var length = keys.length;
        var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        keys.forEach(function(key) {
          encode(encoder, key);
          encode(encoder, value[key]);
        });
      }
      function map_to_map(encoder, value) {
        if (!(value instanceof Map)) return obj_to_map(encoder, value);
        var length = value.size;
        var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        value.forEach(function(val, key, m) {
          encode(encoder, key);
          encode(encoder, val);
        });
      }
      function raw(encoder, value) {
        var length = value.length;
        var type = length < 32 ? 160 + length : length <= 65535 ? 218 : 219;
        token[type](encoder, length);
        encoder.send(value);
      }
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/codec-base.js
var require_codec_base = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/codec-base.js"(exports2) {
    exports2.createCodec = createCodec;
    exports2.install = install;
    exports2.filter = filter2;
    var Bufferish = require_bufferish();
    function Codec(options2) {
      if (!(this instanceof Codec)) return new Codec(options2);
      this.options = options2;
      this.init();
    }
    Codec.prototype.init = function() {
      var options2 = this.options;
      if (options2 && options2.uint8array) {
        this.bufferish = Bufferish.Uint8Array;
      }
      return this;
    };
    function install(props) {
      for (var key in props) {
        Codec.prototype[key] = add(Codec.prototype[key], props[key]);
      }
    }
    function add(a, b) {
      return a && b ? ab : a || b;
      function ab() {
        a.apply(this, arguments);
        return b.apply(this, arguments);
      }
    }
    function join(filters) {
      filters = filters.slice();
      return function(value) {
        return filters.reduce(iterator, value);
      };
      function iterator(value, filter3) {
        return filter3(value);
      }
    }
    function filter2(filter3) {
      return Array.isArray(filter3) ? join(filter3) : filter3;
    }
    function createCodec(options2) {
      return new Codec(options2);
    }
    exports2.preset = createCodec({ preset: true });
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/write-core.js
var require_write_core = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/write-core.js"(exports2) {
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var ExtPacker = require_ext_packer();
    var WriteType = require_write_type();
    var CodecBase = require_codec_base();
    CodecBase.install({
      addExtPacker,
      getExtPacker,
      init
    });
    exports2.preset = init.call(CodecBase.preset);
    function getEncoder(options2) {
      var writeType = WriteType.getWriteType(options2);
      return encode;
      function encode(encoder, value) {
        var func2 = writeType[typeof value];
        if (!func2) throw new Error('Unsupported type "' + typeof value + '": ' + value);
        func2(encoder, value);
      }
    }
    function init() {
      var options2 = this.options;
      this.encode = getEncoder(options2);
      if (options2 && options2.preset) {
        ExtPacker.setExtPackers(this);
      }
      return this;
    }
    function addExtPacker(etype, Class, packer) {
      packer = CodecBase.filter(packer);
      var name2 = Class.name;
      if (name2 && name2 !== "Object") {
        var packers = this.extPackers || (this.extPackers = {});
        packers[name2] = extPacker;
      } else {
        var list2 = this.extEncoderList || (this.extEncoderList = []);
        list2.unshift([Class, extPacker]);
      }
      function extPacker(value) {
        if (packer) value = packer(value);
        return new ExtBuffer(value, etype);
      }
    }
    function getExtPacker(value) {
      var packers = this.extPackers || (this.extPackers = {});
      var c = value.constructor;
      var e = c && c.name && packers[c.name];
      if (e) return e;
      var list2 = this.extEncoderList || (this.extEncoderList = []);
      var len = list2.length;
      for (var i = 0; i < len; i++) {
        var pair = list2[i];
        if (c === pair[0]) return pair[1];
      }
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/flex-buffer.js
var require_flex_buffer = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/flex-buffer.js"(exports2) {
    exports2.FlexDecoder = FlexDecoder;
    exports2.FlexEncoder = FlexEncoder;
    var Bufferish = require_bufferish();
    var MIN_BUFFER_SIZE = 2048;
    var MAX_BUFFER_SIZE = 65536;
    var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";
    function FlexDecoder() {
      if (!(this instanceof FlexDecoder)) return new FlexDecoder();
    }
    function FlexEncoder() {
      if (!(this instanceof FlexEncoder)) return new FlexEncoder();
    }
    FlexDecoder.mixin = mixinFactory(getDecoderMethods());
    FlexDecoder.mixin(FlexDecoder.prototype);
    FlexEncoder.mixin = mixinFactory(getEncoderMethods());
    FlexEncoder.mixin(FlexEncoder.prototype);
    function getDecoderMethods() {
      return {
        bufferish: Bufferish,
        write: write2,
        fetch: fetch2,
        flush,
        push,
        pull,
        read,
        reserve,
        offset: 0
      };
      function write2(chunk) {
        var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;
        this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;
        this.offset = 0;
      }
      function flush() {
        while (this.offset < this.buffer.length) {
          var start = this.offset;
          var value;
          try {
            value = this.fetch();
          } catch (e) {
            if (e && e.message != BUFFER_SHORTAGE) throw e;
            this.offset = start;
            break;
          }
          this.push(value);
        }
      }
      function reserve(length) {
        var start = this.offset;
        var end = start + length;
        if (end > this.buffer.length) throw new Error(BUFFER_SHORTAGE);
        this.offset = end;
        return start;
      }
    }
    function getEncoderMethods() {
      return {
        bufferish: Bufferish,
        write,
        fetch: fetch3,
        flush,
        push,
        pull: pull2,
        read,
        reserve,
        send,
        maxBufferSize: MAX_BUFFER_SIZE,
        minBufferSize: MIN_BUFFER_SIZE,
        offset: 0,
        start: 0
      };
      function fetch3() {
        var start = this.start;
        if (start < this.offset) {
          var end = this.start = this.offset;
          return Bufferish.prototype.slice.call(this.buffer, start, end);
        }
      }
      function flush() {
        while (this.start < this.offset) {
          var value = this.fetch();
          if (value) this.push(value);
        }
      }
      function pull2() {
        var buffers = this.buffers || (this.buffers = []);
        var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
        buffers.length = 0;
        return chunk;
      }
      function reserve(length) {
        var req = length | 0;
        if (this.buffer) {
          var size = this.buffer.length;
          var start = this.offset | 0;
          var end = start + req;
          if (end < size) {
            this.offset = end;
            return start;
          }
          this.flush();
          length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
        }
        length = Math.max(length, this.minBufferSize);
        this.buffer = this.bufferish.alloc(length);
        this.start = 0;
        this.offset = req;
        return 0;
      }
      function send(buffer) {
        var length = buffer.length;
        if (length > this.minBufferSize) {
          this.flush();
          this.push(buffer);
        } else {
          var offset = this.reserve(length);
          Bufferish.prototype.copy.call(buffer, this.buffer, offset);
        }
      }
    }
    function write() {
      throw new Error("method not implemented: write()");
    }
    function fetch2() {
      throw new Error("method not implemented: fetch()");
    }
    function read() {
      var length = this.buffers && this.buffers.length;
      if (!length) return this.fetch();
      this.flush();
      return this.pull();
    }
    function push(chunk) {
      var buffers = this.buffers || (this.buffers = []);
      buffers.push(chunk);
    }
    function pull() {
      var buffers = this.buffers || (this.buffers = []);
      return buffers.shift();
    }
    function mixinFactory(source) {
      return mixin2;
      function mixin2(target) {
        for (var key in source) {
          target[key] = source[key];
        }
        return target;
      }
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/encode-buffer.js
var require_encode_buffer = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/encode-buffer.js"(exports2) {
    exports2.EncodeBuffer = EncodeBuffer;
    var preset = require_write_core().preset;
    var FlexEncoder = require_flex_buffer().FlexEncoder;
    FlexEncoder.mixin(EncodeBuffer.prototype);
    function EncodeBuffer(options2) {
      if (!(this instanceof EncodeBuffer)) return new EncodeBuffer(options2);
      if (options2) {
        this.options = options2;
        if (options2.codec) {
          var codec = this.codec = options2.codec;
          if (codec.bufferish) this.bufferish = codec.bufferish;
        }
      }
    }
    EncodeBuffer.prototype.codec = preset;
    EncodeBuffer.prototype.write = function(input) {
      this.codec.encode(this, input);
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/encode.js
var require_encode = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/encode.js"(exports2) {
    exports2.encode = encode;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    function encode(input, options2) {
      var encoder = new EncodeBuffer(options2);
      encoder.write(input);
      return encoder.read();
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/ext-unpacker.js
var require_ext_unpacker = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/ext-unpacker.js"(exports2) {
    exports2.setExtUnpackers = setExtUnpackers;
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var _decode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtUnpackers(codec) {
      codec.addExtUnpacker(14, [decode, unpackError(Error)]);
      codec.addExtUnpacker(1, [decode, unpackError(EvalError)]);
      codec.addExtUnpacker(2, [decode, unpackError(RangeError)]);
      codec.addExtUnpacker(3, [decode, unpackError(ReferenceError)]);
      codec.addExtUnpacker(4, [decode, unpackError(SyntaxError)]);
      codec.addExtUnpacker(5, [decode, unpackError(TypeError)]);
      codec.addExtUnpacker(6, [decode, unpackError(URIError)]);
      codec.addExtUnpacker(10, [decode, unpackRegExp]);
      codec.addExtUnpacker(11, [decode, unpackClass(Boolean)]);
      codec.addExtUnpacker(12, [decode, unpackClass(String)]);
      codec.addExtUnpacker(13, [decode, unpackClass(Date)]);
      codec.addExtUnpacker(15, [decode, unpackClass(Number)]);
      if ("undefined" !== typeof Uint8Array) {
        codec.addExtUnpacker(17, unpackClass(Int8Array));
        codec.addExtUnpacker(18, unpackClass(Uint8Array));
        codec.addExtUnpacker(19, [unpackArrayBuffer, unpackClass(Int16Array)]);
        codec.addExtUnpacker(20, [unpackArrayBuffer, unpackClass(Uint16Array)]);
        codec.addExtUnpacker(21, [unpackArrayBuffer, unpackClass(Int32Array)]);
        codec.addExtUnpacker(22, [unpackArrayBuffer, unpackClass(Uint32Array)]);
        codec.addExtUnpacker(23, [unpackArrayBuffer, unpackClass(Float32Array)]);
        if ("undefined" !== typeof Float64Array) {
          codec.addExtUnpacker(24, [unpackArrayBuffer, unpackClass(Float64Array)]);
        }
        if ("undefined" !== typeof Uint8ClampedArray) {
          codec.addExtUnpacker(25, unpackClass(Uint8ClampedArray));
        }
        codec.addExtUnpacker(26, unpackArrayBuffer);
        codec.addExtUnpacker(29, [unpackArrayBuffer, unpackClass(DataView)]);
      }
      if (Bufferish.hasBuffer) {
        codec.addExtUnpacker(27, unpackClass(Buffer3));
      }
    }
    function decode(input) {
      if (!_decode) _decode = require_decode().decode;
      return _decode(input);
    }
    function unpackRegExp(value) {
      return RegExp.apply(null, value);
    }
    function unpackError(Class) {
      return function(value) {
        var out = new Class();
        for (var key in ERROR_COLUMNS) {
          out[key] = value[key];
        }
        return out;
      };
    }
    function unpackClass(Class) {
      return function(value) {
        return new Class(value);
      };
    }
    function unpackArrayBuffer(value) {
      return new Uint8Array(value).buffer;
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/read-format.js
var require_read_format = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/read-format.js"(exports2) {
    var ieee754 = require_ieee754();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    exports2.getReadFormat = getReadFormat;
    exports2.readUint8 = uint8;
    var Bufferish = require_bufferish();
    var BufferProto = require_bufferish_proto();
    var HAS_MAP = "undefined" !== typeof Map;
    var NO_ASSERT = true;
    function getReadFormat(options2) {
      var binarraybuffer = Bufferish.hasArrayBuffer && options2 && options2.binarraybuffer;
      var int64 = options2 && options2.int64;
      var usemap = HAS_MAP && options2 && options2.usemap;
      var readFormat = {
        map: usemap ? map_to_map : map_to_obj,
        array,
        str,
        bin: binarraybuffer ? bin_arraybuffer : bin_buffer,
        ext,
        uint8,
        uint16,
        uint32,
        uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
        int8,
        int16,
        int32,
        int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
        float32: read(4, readFloatBE),
        float64: read(8, readDoubleBE)
      };
      return readFormat;
    }
    function map_to_obj(decoder, len) {
      var value = {};
      var i;
      var k = new Array(len);
      var v = new Array(len);
      var decode = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode(decoder);
        v[i] = decode(decoder);
      }
      for (i = 0; i < len; i++) {
        value[k[i]] = v[i];
      }
      return value;
    }
    function map_to_map(decoder, len) {
      var value = /* @__PURE__ */ new Map();
      var i;
      var k = new Array(len);
      var v = new Array(len);
      var decode = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode(decoder);
        v[i] = decode(decoder);
      }
      for (i = 0; i < len; i++) {
        value.set(k[i], v[i]);
      }
      return value;
    }
    function array(decoder, len) {
      var value = new Array(len);
      var decode = decoder.codec.decode;
      for (var i = 0; i < len; i++) {
        value[i] = decode(decoder);
      }
      return value;
    }
    function str(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      return BufferProto.toString.call(decoder.buffer, "utf-8", start, end);
    }
    function bin_buffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.from(buf);
    }
    function bin_arraybuffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.Uint8Array.from(buf).buffer;
    }
    function ext(decoder, len) {
      var start = decoder.reserve(len + 1);
      var type = decoder.buffer[start++];
      var end = start + len;
      var unpack = decoder.codec.getExtUnpacker(type);
      if (!unpack) throw new Error("Invalid ext type: " + (type ? "0x" + type.toString(16) : type));
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return unpack(buf);
    }
    function uint8(decoder) {
      var start = decoder.reserve(1);
      return decoder.buffer[start];
    }
    function int8(decoder) {
      var start = decoder.reserve(1);
      var value = decoder.buffer[start];
      return value & 128 ? value - 256 : value;
    }
    function uint16(decoder) {
      var start = decoder.reserve(2);
      var buffer = decoder.buffer;
      return buffer[start++] << 8 | buffer[start];
    }
    function int16(decoder) {
      var start = decoder.reserve(2);
      var buffer = decoder.buffer;
      var value = buffer[start++] << 8 | buffer[start];
      return value & 32768 ? value - 65536 : value;
    }
    function uint32(decoder) {
      var start = decoder.reserve(4);
      var buffer = decoder.buffer;
      return buffer[start++] * 16777216 + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];
    }
    function int32(decoder) {
      var start = decoder.reserve(4);
      var buffer = decoder.buffer;
      return buffer[start++] << 24 | buffer[start++] << 16 | buffer[start++] << 8 | buffer[start];
    }
    function read(len, method) {
      return function(decoder) {
        var start = decoder.reserve(len);
        return method.call(decoder.buffer, start, NO_ASSERT);
      };
    }
    function readUInt64BE(start) {
      return new Uint64BE(this, start).toNumber();
    }
    function readInt64BE(start) {
      return new Int64BE(this, start).toNumber();
    }
    function readUInt64BE_int64(start) {
      return new Uint64BE(this, start);
    }
    function readInt64BE_int64(start) {
      return new Int64BE(this, start);
    }
    function readFloatBE(start) {
      return ieee754.read(this, start, false, 23, 4);
    }
    function readDoubleBE(start) {
      return ieee754.read(this, start, false, 52, 8);
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/read-token.js
var require_read_token = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/read-token.js"(exports2) {
    var ReadFormat = require_read_format();
    exports2.getReadToken = getReadToken;
    function getReadToken(options2) {
      var format3 = ReadFormat.getReadFormat(options2);
      if (options2 && options2.useraw) {
        return init_useraw(format3);
      } else {
        return init_token(format3);
      }
    }
    function init_token(format3) {
      var i;
      var token = new Array(256);
      for (i = 0; i <= 127; i++) {
        token[i] = constant(i);
      }
      for (i = 128; i <= 143; i++) {
        token[i] = fix(i - 128, format3.map);
      }
      for (i = 144; i <= 159; i++) {
        token[i] = fix(i - 144, format3.array);
      }
      for (i = 160; i <= 191; i++) {
        token[i] = fix(i - 160, format3.str);
      }
      token[192] = constant(null);
      token[193] = null;
      token[194] = constant(false);
      token[195] = constant(true);
      token[196] = flex(format3.uint8, format3.bin);
      token[197] = flex(format3.uint16, format3.bin);
      token[198] = flex(format3.uint32, format3.bin);
      token[199] = flex(format3.uint8, format3.ext);
      token[200] = flex(format3.uint16, format3.ext);
      token[201] = flex(format3.uint32, format3.ext);
      token[202] = format3.float32;
      token[203] = format3.float64;
      token[204] = format3.uint8;
      token[205] = format3.uint16;
      token[206] = format3.uint32;
      token[207] = format3.uint64;
      token[208] = format3.int8;
      token[209] = format3.int16;
      token[210] = format3.int32;
      token[211] = format3.int64;
      token[212] = fix(1, format3.ext);
      token[213] = fix(2, format3.ext);
      token[214] = fix(4, format3.ext);
      token[215] = fix(8, format3.ext);
      token[216] = fix(16, format3.ext);
      token[217] = flex(format3.uint8, format3.str);
      token[218] = flex(format3.uint16, format3.str);
      token[219] = flex(format3.uint32, format3.str);
      token[220] = flex(format3.uint16, format3.array);
      token[221] = flex(format3.uint32, format3.array);
      token[222] = flex(format3.uint16, format3.map);
      token[223] = flex(format3.uint32, format3.map);
      for (i = 224; i <= 255; i++) {
        token[i] = constant(i - 256);
      }
      return token;
    }
    function init_useraw(format3) {
      var i;
      var token = init_token(format3).slice();
      token[217] = token[196];
      token[218] = token[197];
      token[219] = token[198];
      for (i = 160; i <= 191; i++) {
        token[i] = fix(i - 160, format3.bin);
      }
      return token;
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    function flex(lenFunc, decodeFunc) {
      return function(decoder) {
        var len = lenFunc(decoder);
        return decodeFunc(decoder, len);
      };
    }
    function fix(len, method) {
      return function(decoder) {
        return method(decoder, len);
      };
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/read-core.js
var require_read_core = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/read-core.js"(exports2) {
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var ExtUnpacker = require_ext_unpacker();
    var readUint8 = require_read_format().readUint8;
    var ReadToken = require_read_token();
    var CodecBase = require_codec_base();
    CodecBase.install({
      addExtUnpacker,
      getExtUnpacker,
      init
    });
    exports2.preset = init.call(CodecBase.preset);
    function getDecoder(options2) {
      var readToken = ReadToken.getReadToken(options2);
      return decode;
      function decode(decoder) {
        var type = readUint8(decoder);
        var func2 = readToken[type];
        if (!func2) throw new Error("Invalid type: " + (type ? "0x" + type.toString(16) : type));
        return func2(decoder);
      }
    }
    function init() {
      var options2 = this.options;
      this.decode = getDecoder(options2);
      if (options2 && options2.preset) {
        ExtUnpacker.setExtUnpackers(this);
      }
      return this;
    }
    function addExtUnpacker(etype, unpacker) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      unpackers[etype] = CodecBase.filter(unpacker);
    }
    function getExtUnpacker(type) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      return unpackers[type] || extUnpacker;
      function extUnpacker(buffer) {
        return new ExtBuffer(buffer, type);
      }
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/decode-buffer.js
var require_decode_buffer = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/decode-buffer.js"(exports2) {
    exports2.DecodeBuffer = DecodeBuffer;
    var preset = require_read_core().preset;
    var FlexDecoder = require_flex_buffer().FlexDecoder;
    FlexDecoder.mixin(DecodeBuffer.prototype);
    function DecodeBuffer(options2) {
      if (!(this instanceof DecodeBuffer)) return new DecodeBuffer(options2);
      if (options2) {
        this.options = options2;
        if (options2.codec) {
          var codec = this.codec = options2.codec;
          if (codec.bufferish) this.bufferish = codec.bufferish;
        }
      }
    }
    DecodeBuffer.prototype.codec = preset;
    DecodeBuffer.prototype.fetch = function() {
      return this.codec.decode(this);
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/decode.js
var require_decode = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/decode.js"(exports2) {
    exports2.decode = decode;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    function decode(input, options2) {
      var decoder = new DecodeBuffer(options2);
      decoder.write(input);
      return decoder.read();
    }
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/encoder.js"(exports2) {
    exports2.Encoder = Encoder;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    function Encoder(options2) {
      if (!(this instanceof Encoder)) return new Encoder(options2);
      EncodeBuffer.call(this, options2);
    }
    Encoder.prototype = new EncodeBuffer();
    Encoder.prototype.encode = function(chunk) {
      this.write(chunk);
    };
    Encoder.prototype.end = function(chunk) {
      if (arguments.length) this.encode(chunk);
      this.flush();
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/decoder.js"(exports2) {
    exports2.Decoder = Decoder;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    function Decoder(options2) {
      if (!(this instanceof Decoder)) return new Decoder(options2);
      DecodeBuffer.call(this, options2);
    }
    Decoder.prototype = new DecodeBuffer();
    Decoder.prototype.decode = function(chunk) {
      if (arguments.length) this.write(chunk);
      this.flush();
    };
    Decoder.prototype.end = function(chunk) {
      this.decode(chunk);
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/encode-stream.js
var require_encode_stream = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/encode-stream.js"(exports2) {
    exports2.createEncodeStream = EncodeStream;
    var util = require("util");
    var Transform2 = require("stream").Transform;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    util.inherits(EncodeStream, Transform2);
    var DEFAULT_OPTIONS = { objectMode: true };
    function EncodeStream(options2) {
      if (!(this instanceof EncodeStream)) return new EncodeStream(options2);
      if (options2) {
        options2.objectMode = true;
      } else {
        options2 = DEFAULT_OPTIONS;
      }
      Transform2.call(this, options2);
      var stream = this;
      var encoder = this.encoder = new EncodeBuffer(options2);
      encoder.push = function(chunk) {
        stream.push(chunk);
      };
    }
    EncodeStream.prototype._transform = function(chunk, encoding2, callback) {
      this.encoder.write(chunk);
      if (callback) callback();
    };
    EncodeStream.prototype._flush = function(callback) {
      this.encoder.flush();
      if (callback) callback();
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/decode-stream.js
var require_decode_stream = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/decode-stream.js"(exports2) {
    exports2.createDecodeStream = DecodeStream;
    var util = require("util");
    var Transform2 = require("stream").Transform;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    util.inherits(DecodeStream, Transform2);
    var DEFAULT_OPTIONS = { objectMode: true };
    function DecodeStream(options2) {
      if (!(this instanceof DecodeStream)) return new DecodeStream(options2);
      if (options2) {
        options2.objectMode = true;
      } else {
        options2 = DEFAULT_OPTIONS;
      }
      Transform2.call(this, options2);
      var stream = this;
      var decoder = this.decoder = new DecodeBuffer(options2);
      decoder.push = function(chunk) {
        stream.push(chunk);
      };
    }
    DecodeStream.prototype._transform = function(chunk, encoding2, callback) {
      this.decoder.write(chunk);
      this.decoder.flush();
      if (callback) callback();
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/ext.js
var require_ext = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/ext.js"(exports2) {
    require_read_core();
    require_write_core();
    exports2.createCodec = require_codec_base().createCodec;
  }
});

// node_modules/@chemzqm/msgpack-lite/lib/codec.js
var require_codec = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/lib/codec.js"(exports2) {
    require_read_core();
    require_write_core();
    exports2.codec = {
      preset: require_codec_base().preset
    };
  }
});

// node_modules/@chemzqm/msgpack-lite/index.js
var require_msgpack_lite = __commonJS({
  "node_modules/@chemzqm/msgpack-lite/index.js"(exports2) {
    exports2.encode = require_encode().encode;
    exports2.decode = require_decode().decode;
    exports2.Encoder = require_encoder().Encoder;
    exports2.Decoder = require_decoder().Decoder;
    exports2.createEncodeStream = require_encode_stream().createEncodeStream;
    exports2.createDecodeStream = require_decode_stream().createDecodeStream;
    exports2.createCodec = require_ext().createCodec;
    exports2.codec = require_codec().codec;
  }
});

// node_modules/@chemzqm/neovim/lib/utils/constants.js
var require_constants2 = __commonJS({
  "node_modules/@chemzqm/neovim/lib/utils/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isVim = exports2.isTester = exports2.isCocNvim = void 0;
    exports2.isCocNvim = true;
    exports2.isTester = process.env.COC_TESTER == "1";
    exports2.isVim = process.env.VIM_NODE_RPC == "1";
  }
});

// node_modules/@chemzqm/neovim/lib/api/Base.js
var require_Base = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseApi = void 0;
    var constants_1 = require_constants2();
    var BaseApi = class {
      constructor({ data, client }) {
        this.data = data;
        if (client) {
          this.client = client;
        } else {
          Object.defineProperty(this, "client", {
            value: this
          });
        }
      }
      get transport() {
        return this.client._transport;
      }
      equals(other) {
        try {
          return String(this.data) === String(other.data);
        } catch (e) {
          return false;
        }
      }
      async request(name2, args = [], skipConvert = false, skipErrorLog = false) {
        Error.captureStackTrace(args);
        const self = this;
        return new Promise((resolve, reject) => {
          let converted = skipConvert ? args : this.getArgsByPrefix(args);
          this.transport.request(name2, converted, (err, res) => {
            if (err) {
              let e = new Error(err[1]);
              if (!skipErrorLog) {
                e.stack = `Error: request error on "${name2}" - ${err[1]}
` + args["stack"].split(/\r?\n/).slice(3).join("\n");
                this.client.logError(`request error on "${name2}"`, converted.map((o) => o === self ? self.data : o), e);
              }
              reject(e);
            } else {
              resolve(res);
            }
          });
        });
      }
      getArgsByPrefix(args) {
        if (this.prefix !== "nvim_" && args[0] !== this) {
          let id2 = constants_1.isVim ? this.data : this;
          return [id2, ...args];
        }
        return args;
      }
      /** Retrieves a scoped variable depending on type (using `this.prefix`) */
      getVar(name2) {
        return this.request(`${this.prefix}get_var`, [name2], false, true).then((res) => res, (_err) => {
          return null;
        });
      }
      setVar(name2, value, isNotify = false) {
        if (isNotify) {
          this.notify(`${this.prefix}set_var`, [name2, value]);
          return;
        }
        return this.request(`${this.prefix}set_var`, [name2, value]);
      }
      /** Delete a scoped variable */
      deleteVar(name2) {
        this.notify(`${this.prefix}del_var`, [name2]);
      }
      /** Retrieves a scoped option depending on type of `this` */
      getOption(name2) {
        return this.request(`${this.prefix}get_option`, [name2]);
      }
      setOption(name2, value, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}set_option`, [name2, value]);
          return;
        }
        return this.request(`${this.prefix}set_option`, [name2, value]);
      }
      /** `request` is basically the same except you can choose to wait forpromise to be resolved */
      notify(name2, args = [], skipConvert = false) {
        this.transport.notify(name2, skipConvert ? args : this.getArgsByPrefix(args));
      }
      toJSON() {
        var _a2;
        return (_a2 = this.data) !== null && _a2 !== void 0 ? _a2 : 0;
      }
    };
    exports2.BaseApi = BaseApi;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Buffer.js
var require_Buffer = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Buffer = void 0;
    var constants_1 = require_constants2();
    var Base_1 = require_Base();
    var Buffer3 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_buf_";
      }
      /**
       * Attach to buffer to listen to buffer events
       * @param sendBuffer Set to true if the initial notification should contain
       *        the whole buffer. If so, the first notification will be a
       *        `nvim_buf_lines_event`. Otherwise, the first notification will be
       *        a `nvim_buf_changedtick_event`
       */
      async attach(sendBuffer = false, options2 = {}) {
        return await this.request(`${this.prefix}attach`, [sendBuffer, options2]);
      }
      /**
       * Detach from buffer to stop listening to buffer events
       */
      async detach() {
        return await this.request(`${this.prefix}detach`, []);
      }
      /** Retrieves a scoped option depending on type of `this` */
      getOption(name2) {
        if (constants_1.isCocNvim)
          return this.request(`nvim_get_option_value`, [name2, { buf: this.id }], true);
        return super.getOption(name2);
      }
      setOption(name2, value, isNotify) {
        if (constants_1.isCocNvim)
          return this[isNotify ? "notify" : "request"](`nvim_set_option_value`, [name2, value, { buf: this.id }], true);
        return this[isNotify ? "notify" : "request"](`${this.prefix}set_option`, [name2, value]);
      }
      /**
       * Get the bufnr of Buffer
       */
      get id() {
        return this.data;
      }
      /** Total number of lines in buffer */
      get length() {
        return this.request(`${this.prefix}line_count`, []);
      }
      /** Get lines in buffer */
      get lines() {
        return this.getLines();
      }
      /** Gets a changed tick of a buffer */
      get changedtick() {
        return this.request(`${this.prefix}get_changedtick`, []);
      }
      get commands() {
        return this.getCommands();
      }
      getCommands(options2 = {}) {
        return this.request(`${this.prefix}get_commands`, [options2]);
      }
      /** Get specific lines of buffer */
      getLines({ start, end, strictIndexing } = { start: 0, end: -1, strictIndexing: true }) {
        const indexing = typeof strictIndexing === "undefined" ? true : strictIndexing;
        return this.request(`${this.prefix}get_lines`, [
          start,
          end,
          indexing
        ]);
      }
      setLines(lines, opts, notify = false) {
        let { start, end, strictIndexing } = opts !== null && opts !== void 0 ? opts : {};
        start = start !== null && start !== void 0 ? start : 0;
        end = end !== null && end !== void 0 ? end : start + 1;
        const indexing = strictIndexing !== null && strictIndexing !== void 0 ? strictIndexing : true;
        const method = notify ? "notify" : "request";
        return this[method](`${this.prefix}set_lines`, [
          start,
          end,
          indexing,
          typeof lines === "string" ? [lines] : lines
        ]);
      }
      /**
       * Set virtual text for a line, works on nvim >= 0.5.0 and vim9
       *
       * @public
       * @param {number} src_id - Source group to use or 0 to use a new group, or -1
       * @param {number} line - Line to annotate with virtual text (zero-indexed)
       * @param {Chunk[]} chunks - List with [text, hl_group]
       * @param {{[index} opts
       * @returns {Promise<number>}
       */
      setVirtualText(src_id, line, chunks, opts = {}) {
        this.client.call("coc#vtext#add", [this.id, src_id, line, chunks, opts], true);
        return Promise.resolve(src_id);
      }
      /**
       * Removes an ext mark by notification.
       *
       * @public
       * @param {number} ns_id - Namespace id
       * @param {number} id - Extmark id
       */
      deleteExtMark(ns_id, id2) {
        this.notify(`${this.prefix}del_extmark`, [
          ns_id,
          id2
        ]);
      }
      /**
       * Gets the position (0-indexed) of an extmark.
       *
       * @param {number} ns_id - Namespace id
       * @param {number} id - Extmark id
       * @param {Object} opts - Optional parameters.
       * @returns {Promise<[] | [number, number] | [number, number, ExtmarkDetails]>}
       */
      async getExtMarkById(ns_id, id2, opts = {}) {
        return this.request(`${this.prefix}get_extmark_by_id`, [ns_id, id2, opts]);
      }
      /**
       * Gets extmarks in "traversal order" from a |charwise| region defined by
       * buffer positions (inclusive, 0-indexed |api-indexing|).
       *
       * Region can be given as (row,col) tuples, or valid extmark ids (whose
       * positions define the bounds). 0 and -1 are understood as (0,0) and (-1,-1)
       * respectively, thus the following are equivalent:
       *
       *     nvim_buf_get_extmarks(0, my_ns, 0, -1, {})
       *     nvim_buf_get_extmarks(0, my_ns, [0,0], [-1,-1], {})
       *
       * @param {number} ns_id - Namespace id
       * @param {[number, number] | number} start
       * @param {[number, number] | number} end
       * @param {Object} opts
       * @returns {Promise<[number, number, number, ExtmarkDetails?][]>}
       */
      async getExtMarks(ns_id, start, end, opts = {}) {
        return this.request(`${this.prefix}get_extmarks`, [ns_id, start, end, opts]);
      }
      /**
       * Creates or updates an extmark by notification, `:h nvim_buf_set_extmark`.
       *
       * @param {number} ns_id
       * @param {number} line
       * @param {number} col
       * @param {ExtmarkOptions} opts
       * @returns {void}
       */
      setExtMark(ns_id, line, col, opts = {}) {
        this.notify(`${this.prefix}set_extmark`, [
          ns_id,
          line,
          col,
          opts
        ]);
      }
      /** Insert lines at `start` index */
      insert(lines, start) {
        return this.setLines(lines, {
          start,
          end: start,
          strictIndexing: true
        });
      }
      /** Replace lines starting at `start` index */
      replace(_lines, start) {
        const lines = typeof _lines === "string" ? [_lines] : _lines;
        return this.setLines(lines, {
          start,
          end: start + lines.length,
          strictIndexing: false
        });
      }
      /** Remove lines at index */
      remove(start, end, strictIndexing = false) {
        return this.setLines([], { start, end, strictIndexing });
      }
      /** Append a string or list of lines to end of buffer */
      append(lines) {
        return this.setLines(lines, {
          start: -1,
          end: -1,
          strictIndexing: false
        });
      }
      /** Get buffer name */
      get name() {
        return this.request(`${this.prefix}get_name`, []);
      }
      /** Set current buffer name */
      setName(value) {
        return this.request(`${this.prefix}set_name`, [value]);
      }
      /** Is current buffer valid */
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      /** Get mark position given mark name */
      mark(name2) {
        return this.request(`${this.prefix}get_mark`, [name2]);
      }
      // range(start, end) {
      // """Return a `Range` object, which represents part of the Buffer."""
      // return Range(this, start, end)
      // }
      /** Gets keymap */
      getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
      }
      /**
       * Add buffer keymap by notification, replace keycodes for expr keymap enabled by default.
       */
      setKeymap(mode, lhs, rhs, opts = {}) {
        let option = opts.expr ? Object.assign({ replace_keycodes: true }, opts) : opts;
        this.notify(`${this.prefix}set_keymap`, [mode, lhs, rhs, option]);
      }
      deleteKeymap(mode, lhs) {
        this.notify(`${this.prefix}del_keymap`, [mode, lhs]);
      }
      /**
      * Checks if a buffer is valid and loaded. See |api-buffer| for
      * more info about unloaded buffers.
      */
      get loaded() {
        return this.request(`${this.prefix}is_loaded`, []);
      }
      /**
       * Returns the byte offset for a line.
       *
       * Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is
       * one byte. 'fileformat' and 'fileencoding' are ignored. The
       * line index just after the last line gives the total byte-count
       * of the buffer. A final EOL byte is counted if it would be
       * written, see 'eol'.
       *
       * Unlike |line2byte()|, throws error for out-of-bounds indexing.
       * Returns -1 for unloaded buffer.
       *
       * @return {Number} Integer byte offset, or -1 for unloaded buffer.
       */
      getOffset(index) {
        return this.request(`${this.prefix}get_offset`, [index]);
      }
      /**
          Adds a highlight to buffer.
      
          This can be used for plugins which dynamically generate
          highlights to a buffer (like a semantic highlighter or
          linter). The function adds a single highlight to a buffer.
          Unlike matchaddpos() highlights follow changes to line
          numbering (as lines are inserted/removed above the highlighted
          line), like signs and marks do.
      
          "src_id" is useful for batch deletion/updating of a set of
          highlights. When called with src_id = 0, an unique source id
          is generated and returned. Succesive calls can pass in it as
          "src_id" to add new highlights to the same source group. All
          highlights in the same group can then be cleared with
          nvim_buf_clear_namespace. If the highlight never will be
          manually deleted pass in -1 for "src_id".
      
          If "hl_group" is the empty string no highlight is added, but a
          new src_id is still returned. This is useful for an external
          plugin to synchrounously request an unique src_id at
          initialization, and later asynchronously add and clear
          highlights in response to buffer changes. */
      addHighlight({ hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId }) {
        if (!hlGroup)
          throw new Error("hlGroup should not empty");
        const colEnd = typeof _end !== "undefined" ? _end : -1;
        const colStart = typeof _start !== "undefined" ? _start : -0;
        const srcId4 = typeof _srcId !== "undefined" ? _srcId : -1;
        const method = srcId4 == 0 ? "request" : "notify";
        let res = this[method](`${this.prefix}add_highlight`, [
          srcId4,
          hlGroup,
          line,
          colStart,
          colEnd
        ]);
        return method === "request" ? res : Promise.resolve(null);
      }
      /**
       * Clear highlights of specified lins.
       *
       * @deprecated use clearNamespace() instead.
       */
      clearHighlight(args = {}) {
        const defaults = {
          srcId: -1,
          lineStart: 0,
          lineEnd: -1
        };
        const { srcId: srcId4, lineStart, lineEnd } = Object.assign({}, defaults, args);
        return this.notify(`${this.prefix}clear_highlight`, [
          srcId4,
          lineStart,
          lineEnd
        ]);
      }
      /**
       * Add highlight to ranges by notification.
       *
       * @param {string | number} srcId Unique key or namespace number.
       * @param {string} hlGroup Highlight group.
       * @param {Range[]} ranges List of highlight ranges
       */
      highlightRanges(srcId4, hlGroup, ranges, option) {
        this.client.call("coc#highlight#ranges", [this.id, srcId4, hlGroup, ranges, option !== null && option !== void 0 ? option : {}], true);
      }
      /**
       * Clear namespace by id or name.
       *
       * @param key Unique key or namespace number, use -1 for all namespaces
       * @param lineStart Start of line, 0 based, default to 0.
       * @param lineEnd End of line, 0 based, default to -1.
       */
      clearNamespace(key, lineStart = 0, lineEnd = -1) {
        this.client.call("coc#highlight#clear_highlight", [this.id, key, lineStart, lineEnd], true);
      }
      /**
       * Add sign to buffer by notification.
       *
       * @param {SignPlaceOption} sign
       * @returns {void}
       */
      placeSign(sign) {
        let opts = { lnum: sign.lnum };
        if (typeof sign.priority === "number")
          opts.priority = sign.priority;
        this.client.call("sign_place", [sign.id || 0, sign.group || "", sign.name, this.id, opts], true);
      }
      /**
       * Unplace signs by notification
       */
      unplaceSign(opts) {
        let details = { buffer: this.id };
        if (opts.id != null)
          details.id = opts.id;
        this.client.call("sign_unplace", [opts.group || "", details], true);
      }
      /**
       * Get signs by group name or id and lnum.
       *
       * @param {SignPlacedOption} opts
       * @returns {Promise<SignItem[]>}
       */
      async getSigns(opts) {
        let res = await this.client.call("sign_getplaced", [this.id, opts || {}]);
        return res[0].signs;
      }
      /**
       * Get highlight items by name space (end inclusive).
       *
       * @param {string} ns Namespace key.
       * @param {number} start 0 based line number.
       * @param {number} end 0 based line number.
       * @returns {Promise<HighlightItem[]>}
       */
      async getHighlights(ns, start = 0, end = -1) {
        let res = [];
        let arr = await this.client.call("coc#highlight#get_highlights", [this.id, ns, start, end]);
        for (let item of arr) {
          res.push({
            hlGroup: item[0],
            lnum: item[1],
            colStart: item[2],
            colEnd: item[3],
            id: item[4]
          });
        }
        return res;
      }
      /**
       * Update highlight items by notification.
       *
       * @param {string | number} ns Namespace key or id.
       * @param {HighlightItem[]} highlights Highlight items.
       * @param {HighlightOption} opts Optional options.
       * @returns {void}
       */
      updateHighlights(ns, highlights, opts = {}) {
        if (typeof opts === "number") {
          this.client.logError("Bad option for buffer.updateHighlights()", new Error());
          return;
        }
        let start = typeof opts.start === "number" ? opts.start : 0;
        let end = typeof opts.end === "number" ? opts.end : -1;
        let changedtick = typeof opts.changedtick === "number" ? opts.changedtick : null;
        let priority = typeof opts.priority === "number" ? opts.priority : null;
        let arr = highlights.map((o) => [o.hlGroup, o.lnum, o.colStart, o.colEnd, o.combine === false ? 0 : 1, o.start_incl ? 1 : 0, o.end_incl ? 1 : 0]);
        if (start == 0 && end == -1) {
          this.client.call("coc#highlight#buffer_update", [this.id, ns, arr, priority, changedtick], true);
          return;
        }
        this.client.call("coc#highlight#update_highlights", [this.id, ns, arr, start, end, priority, changedtick], true);
      }
      /**
       * Listens to buffer for events
       */
      listen(eventName, cb, disposables) {
        this.client.attachBufferEvent(this.id, eventName, cb);
        if (disposables) {
          disposables.push({
            dispose: () => {
              this.client.detachBufferEvent(this.id, eventName, cb);
            }
          });
        }
      }
    };
    exports2.Buffer = Buffer3;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Tabpage.js
var require_Tabpage = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Tabpage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tabpage = void 0;
    var Base_1 = require_Base();
    var Tabpage = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_tabpage_";
      }
      /**
       * The windowid that not change within a Vim session
       */
      get id() {
        return this.data;
      }
      /** Returns all windows of tabpage */
      get windows() {
        return this.request(`${this.prefix}list_wins`, []);
      }
      /** Gets the current window of tabpage */
      get window() {
        return this.request(`${this.prefix}get_win`, []);
      }
      /** Is current tabpage valid */
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      /** Tabpage number */
      get number() {
        return this.request(`${this.prefix}get_number`, []);
      }
      /** Invalid */
      getOption() {
        throw new Error("Tabpage does not have `getOption`");
      }
      /** Invalid */
      setOption() {
        throw new Error("Tabpage does not have `setOption`");
      }
    };
    exports2.Tabpage = Tabpage;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Window.js
var require_Window = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Window.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Window = void 0;
    var constants_1 = require_constants2();
    var Base_1 = require_Base();
    var Window2 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_win_";
      }
      /**
       * The windowid that not change within a Vim session
       */
      get id() {
        return this.data;
      }
      setBuffer(buffer) {
        return this.request(`${this.prefix}set_buf`, [buffer]);
      }
      /** Retrieves a scoped option depending on type of `this` */
      getOption(name2) {
        if (constants_1.isCocNvim)
          return this.request(`nvim_get_option_value`, [name2, { win: this.id }], true);
        return super.getOption(name2);
      }
      setOption(name2, value, isNotify) {
        if (constants_1.isCocNvim)
          return this[isNotify ? "notify" : "request"](`nvim_set_option_value`, [name2, value, { win: this.id }], true);
        return this[isNotify ? "notify" : "request"](`${this.prefix}set_option`, [name2, value]);
      }
      /** Get current buffer of window */
      get buffer() {
        return this.request(`${this.prefix}get_buf`, []);
      }
      /** Get the Tabpage that contains the window */
      get tabpage() {
        return this.request(`${this.prefix}get_tabpage`, []);
      }
      /** Get cursor position */
      get cursor() {
        return this.request(`${this.prefix}get_cursor`, []);
      }
      setCursor(pos, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_cursor`, [pos]);
      }
      /** Get window height by number of rows */
      get height() {
        return this.request(`${this.prefix}get_height`, []);
      }
      setHeight(height, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_height`, [height]);
      }
      /** Get window width by number of columns */
      get width() {
        return this.request(`${this.prefix}get_width`, []);
      }
      setWidth(width, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_width`, [width]);
      }
      /** Get window position */
      get position() {
        return this.request(`${this.prefix}get_position`, []);
      }
      /** 0-indexed, on-screen window position(row) in display cells. */
      get row() {
        return this.request(`${this.prefix}get_position`, []).then((position) => position[0]);
      }
      /** 0-indexed, on-screen window position(col) in display cells. */
      get col() {
        return this.request(`${this.prefix}get_position`, []).then((position) => position[1]);
      }
      /** Is window valid */
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      /** Get window number */
      get number() {
        return this.request(`${this.prefix}get_number`, []);
      }
      setConfig(options2, isNotify) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_config`, [options2]);
      }
      getConfig() {
        return this.request(`${this.prefix}get_config`, []);
      }
      close(force, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}close`, [force]);
          return null;
        }
        return this.request(`${this.prefix}close`, [force]);
      }
      highlightRanges(hlGroup, ranges, priority = 10, isNotify) {
        if (isNotify) {
          this.client.call("coc#highlight#match_ranges", [this.id, 0, ranges, hlGroup, priority], true);
          return void 0;
        }
        return this.client.call("coc#highlight#match_ranges", [this.id, 0, ranges, hlGroup, priority]);
      }
      /**
       * Clear match by highlight group.
       */
      clearMatchGroup(hlGroup) {
        this.client.call("coc#window#clear_match_group", [this.id, hlGroup], true);
      }
      /**
       * Clear match by match ids.
       */
      clearMatches(ids) {
        this.client.call("coc#window#clear_matches", [this.id, ids], true);
      }
    };
    exports2.Window = Window2;
  }
});

// node_modules/@chemzqm/neovim/lib/api/types.js
var require_types = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Metadata = exports2.ExtType = void 0;
    var Buffer_1 = require_Buffer();
    var Tabpage_1 = require_Tabpage();
    var Window_1 = require_Window();
    var ExtType;
    (function(ExtType2) {
      ExtType2[ExtType2["Buffer"] = 0] = "Buffer";
      ExtType2[ExtType2["Window"] = 1] = "Window";
      ExtType2[ExtType2["Tabpage"] = 2] = "Tabpage";
    })(ExtType || (exports2.ExtType = ExtType = {}));
    exports2.Metadata = [
      {
        constructor: Buffer_1.Buffer,
        name: "Buffer",
        prefix: "nvim_buf_"
      },
      {
        constructor: Window_1.Window,
        name: "Window",
        prefix: "nvim_win_"
      },
      {
        constructor: Tabpage_1.Tabpage,
        name: "Tabpage",
        prefix: "nvim_tabpage_"
      }
    ];
  }
});

// node_modules/@chemzqm/neovim/lib/utils/buffered.js
var require_buffered = __commonJS({
  "node_modules/@chemzqm/neovim/lib/utils/buffered.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var MIN_SIZE = Buffer.poolSize;
    var waterMark = 10 * 1024 * 1024;
    var Buffered = class extends stream_1.Transform {
      constructor() {
        super({
          readableHighWaterMark: waterMark,
          writableHighWaterMark: waterMark
        });
        this.chunks = null;
        this.timer = null;
      }
      sendData() {
        const { chunks } = this;
        if (chunks) {
          this.chunks = null;
          this.push(Buffer.concat(chunks));
        }
      }
      // eslint-disable-next-line consistent-return
      _transform(chunk, _encoding, callback) {
        const { chunks, timer } = this;
        if (timer)
          clearTimeout(timer);
        if (chunk.length < MIN_SIZE) {
          if (!chunks)
            return callback(null, chunk);
          chunks.push(chunk);
          this.sendData();
          callback();
        } else {
          if (!chunks) {
            this.chunks = [chunk];
          } else {
            chunks.push(chunk);
          }
          this.timer = setTimeout(this.sendData.bind(this), 20);
          callback();
        }
      }
      _flush(callback) {
        const { chunks } = this;
        if (chunks) {
          this.chunks = null;
          const buf = Buffer.concat(chunks);
          callback(null, buf);
        } else {
          callback();
        }
      }
    };
    exports2.default = Buffered;
  }
});

// node_modules/@chemzqm/neovim/lib/utils/logger.js
var require_logger = __commonJS({
  "node_modules/@chemzqm/neovim/lib/utils/logger.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.level = exports2.nullLogger = void 0;
    exports2.createLogger = createLogger2;
    var fs_1 = __importDefault(require("fs"));
    var os_1 = __importDefault(require("os"));
    var path_1 = __importDefault(require("path"));
    var util_1 = require("util");
    exports2.nullLogger = {
      debug: () => {
      },
      info: () => {
      },
      warn: () => {
      },
      error: () => {
      },
      trace: () => {
      }
    };
    function getLogFile() {
      let file = process.env.NODE_CLIENT_LOG_FILE;
      if (file)
        return file;
      let dir = process.env.XDG_RUNTIME_DIR;
      if (dir)
        return path_1.default.join(dir, "node-client.log");
      return path_1.default.join(os_1.default.tmpdir(), `node-client-${process.pid}.log`);
    }
    var debugging = process.env.COC_NODE_CLIENT_DEBUG == "1" && process.env.COC_TESTER == "1";
    var LOG_FILE_PATH = getLogFile();
    exports2.level = debugging ? "debug" : process.env.NODE_CLIENT_LOG_LEVEL || "info";
    var invalid = !debugging && process.getuid && process.getuid() == 0;
    if (!invalid && !debugging) {
      try {
        fs_1.default.mkdirSync(path_1.default.dirname(LOG_FILE_PATH), { recursive: true });
        fs_1.default.writeFileSync(LOG_FILE_PATH, "", { encoding: "utf8", mode: 438 });
      } catch (_e) {
        invalid = true;
      }
    }
    function toObject2(arg) {
      if (arg == null) {
        return arg;
      }
      if (Array.isArray(arg)) {
        return arg.map((o) => toObject2(o));
      }
      if (typeof arg == "object" && typeof arg.prefix == "string" && typeof arg.data == "number") {
        return "[" + arg.prefix + arg.data + "]";
      }
      return arg;
    }
    function toString(arg) {
      if (debugging)
        return (0, util_1.inspect)(arg, { depth: null, colors: true, compact: false });
      if (arg == null)
        return String(arg);
      if (arg instanceof Error)
        return arg.stack;
      if (typeof arg == "object")
        return JSON.stringify(arg, null, 2);
      return String(arg);
    }
    var toTwoDigits2 = (v) => v < 10 ? `0${v}` : v.toString();
    var toThreeDigits2 = (v) => v < 10 ? `00${v}` : v < 100 ? `0${v}` : v.toString();
    function toTimeString(currentTime) {
      return `${toTwoDigits2(currentTime.getHours())}:${toTwoDigits2(currentTime.getMinutes())}:${toTwoDigits2(currentTime.getSeconds())}.${toThreeDigits2(currentTime.getMilliseconds())}`;
    }
    var writableStream = void 0;
    var Logger = class {
      constructor(name2) {
        this.name = name2;
      }
      get stream() {
        if (writableStream)
          return writableStream;
        if (debugging) {
          writableStream = process.stdout;
        } else {
          writableStream = fs_1.default.createWriteStream(LOG_FILE_PATH, { encoding: "utf8" });
        }
        return writableStream;
      }
      getText(level2, data, meta) {
        let more = "";
        if (meta.length) {
          let arr = toObject2(meta);
          more = " " + arr.map((o) => toString(o)).join(", ");
        }
        return `${toTimeString(/* @__PURE__ */ new Date())} ${level2.toUpperCase()} [${this.name}] - ${data}${more}
`;
      }
      debug(data, ...meta) {
        if (exports2.level != "debug" || invalid)
          return;
        this.stream.write(this.getText("debug", data, meta));
      }
      info(data, ...meta) {
        if (invalid)
          return;
        this.stream.write(this.getText("info", data, meta));
      }
      warn(data, ...meta) {
        if (invalid)
          return;
        this.stream.write(this.getText("warn", data, meta));
      }
      error(data, ...meta) {
        if (invalid)
          return;
        let stream = debugging ? process.stderr : this.stream;
        stream.write(this.getText("error", data, meta));
      }
      trace(data, ...meta) {
        if (exports2.level != "trace" || invalid)
          return;
        this.stream.write(this.getText("trace", data, meta));
      }
    };
    function createLogger2(name2) {
      return new Logger(name2);
    }
  }
});

// node_modules/@chemzqm/neovim/lib/transport/base.js
var require_base = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require("events");
    var logger_1 = require_logger();
    var debug = logger_1.level === "debug";
    var logger60 = (0, logger_1.createLogger)("transport");
    var Transport3 = class extends events_1.EventEmitter {
      constructor(logger61, isVim2) {
        super();
        this.logger = logger61;
        this.isVim = isVim2;
        this.pauseLevel = 0;
        this.paused = /* @__PURE__ */ new Map();
      }
      debug(key, ...meta) {
        if (!debug)
          return;
        logger60.debug(key, ...meta);
      }
      info(key, ...meta) {
        logger60.info(key, ...meta);
      }
      debugMessage(msg) {
        if (!debug)
          return;
        const msgType = msg[0];
        if (msgType == 0) {
          logger60.debug("receive request:", msg.slice(1));
        } else if (msgType == 1) {
        } else if (msgType == 2) {
          logger60.debug("receive notification:", msg.slice(1));
        } else {
          logger60.debug("unknown message:", msg);
        }
      }
      pauseNotification() {
        this.pauseLevel = this.pauseLevel + 1;
        this.paused.set(this.pauseLevel, []);
      }
      cancelNotification() {
        let { pauseLevel } = this;
        if (pauseLevel > 0) {
          this.paused.delete(pauseLevel);
          this.pauseLevel = pauseLevel - 1;
        }
      }
      resumeNotification(isNotify = false) {
        let { pauseLevel } = this;
        if (pauseLevel == 0)
          return isNotify ? null : Promise.resolve([[], null]);
        let obj = {};
        Error.captureStackTrace(obj);
        this.pauseLevel = pauseLevel - 1;
        let list2 = this.paused.get(pauseLevel);
        this.paused.delete(pauseLevel);
        if (list2 && list2.length) {
          return new Promise((resolve, reject) => {
            if (!isNotify) {
              return this.request("nvim_call_atomic", [list2], (err, res) => {
                if (err) {
                  let e = new Error(`call_atomic error: ${err[1]}`);
                  e.stack = obj.stack.replace(/^Error/, `Error: ${e.message}`);
                  return reject(e);
                }
                if (Array.isArray(res) && res[1] != null) {
                  let [index, errType, message] = res[1];
                  let [fname, args] = list2[index];
                  let e = new Error(`call_atomic request error on "${fname}": ${message}`);
                  e.stack = obj.stack.replace(/^Error/, `Error: ${e.message}`);
                  this.logger.error(`call_atomic request error ${errType} on "${fname}"`, args, message, e);
                  return reject(e);
                }
                resolve(res);
              });
            }
            this.notify("nvim_call_atomic", [list2]);
            resolve(void 0);
          });
        }
        return isNotify ? null : Promise.resolve([[], void 0]);
      }
    };
    exports2.default = Transport3;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/nvim.js
var require_nvim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/nvim.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NvimTransport = void 0;
    var msgpack = __importStar(require_msgpack_lite());
    var types_1 = require_types();
    var buffered_1 = __importDefault(require_buffered());
    var base_1 = __importDefault(require_base());
    var NvimTransport = class extends base_1.default {
      constructor(logger60) {
        super(logger60, false);
        this.pending = /* @__PURE__ */ new Map();
        this.nextRequestId = 1;
        this.attached = false;
        const codec = this.setupCodec();
        this.encodeStream = msgpack.createEncodeStream({ codec });
        this.decodeStream = msgpack.createDecodeStream({ codec });
        this.decodeStream.on("data", (msg) => {
          this.parseMessage(msg);
        });
        this.decodeStream.on("end", () => {
          this.detach();
          this.emit("detach");
        });
      }
      parseMessage(msg) {
        const msgType = msg[0];
        this.debugMessage(msg);
        if (msgType === 0) {
          let method = msg[2].toString();
          this.emit("request", method, msg[3], this.createResponse(method, msg[1]));
        } else if (msgType === 1) {
          const id2 = msg[1];
          const handler = this.pending.get(id2);
          if (handler) {
            this.pending.delete(id2);
            let err = msg[2];
            if (err && err.length != 2) {
              err = [0, err.toString()];
            }
            handler(err, msg[3]);
          }
        } else if (msgType === 2) {
          this.emit("notification", msg[1].toString(), msg[2]);
        } else {
          console.error(`Invalid message type ${msgType}`);
        }
      }
      setupCodec() {
        const codec = msgpack.createCodec();
        types_1.Metadata.forEach(({ constructor }, id2) => {
          codec.addExtPacker(id2, constructor, (obj) => msgpack.encode(obj.data));
          codec.addExtUnpacker(id2, (data) => new constructor({
            client: this.client,
            data: msgpack.decode(data)
          }));
        });
        this.codec = codec;
        return this.codec;
      }
      attach(writer, reader, client) {
        this.encodeStream = this.encodeStream.pipe(writer);
        const buffered = new buffered_1.default();
        reader.pipe(buffered).pipe(this.decodeStream);
        this.writer = writer;
        this.reader = reader;
        this.client = client;
        this.attached = true;
      }
      detach() {
        if (!this.attached)
          return;
        this.attached = false;
        this.encodeStream.unpipe(this.writer);
        this.reader.unpipe(this.decodeStream);
        for (let handler of this.pending.values()) {
          handler([0, "transport disconnected"]);
        }
        this.pending.clear();
      }
      request(method, args, cb) {
        if (!this.attached)
          return cb([0, "transport disconnected"]);
        let id2 = this.nextRequestId;
        this.nextRequestId = this.nextRequestId + 1;
        let startTs = Date.now();
        this.debug("request to nvim:", id2, method, args);
        this.encodeStream.write(msgpack.encode([0, id2, method, args], {
          codec: this.codec
        }));
        this.pending.set(id2, (err, res) => {
          this.debug("response of nvim:", id2, Date.now() - startTs, res, err);
          cb(err, res);
        });
      }
      notify(method, args) {
        if (!this.attached)
          return;
        if (this.pauseLevel != 0) {
          let arr = this.paused.get(this.pauseLevel);
          if (arr) {
            arr.push([method, args]);
            return;
          }
        }
        this.debug("nvim notification:", method, args);
        this.encodeStream.write(msgpack.encode([2, method, args], {
          codec: this.codec
        }));
      }
      send(arr) {
        this.encodeStream.write(msgpack.encode(arr, {
          codec: this.codec
        }));
      }
      vimCommand(command, ..._args) {
        throw new Error(`Command "${command}"  not exists on nvim`);
      }
      vimRequest(command, _args) {
        throw new Error(`Command "${command}"  not exists on nvim`);
      }
      createResponse(_method, requestId) {
        let { encodeStream } = this;
        let startTs = Date.now();
        let called = false;
        return {
          send: (resp, isError) => {
            if (called || !this.attached)
              return;
            this.debug("response of client:", requestId, `${Date.now() - startTs}ms`, resp, isError == true);
            called = true;
            encodeStream.write(msgpack.encode([
              1,
              requestId,
              isError ? resp : null,
              !isError ? resp : null
            ]));
          }
        };
      }
    };
    exports2.NvimTransport = NvimTransport;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/connection.js
var require_connection = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/connection.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = __importDefault(require("events"));
    var logger_1 = require_logger();
    var logger60 = (0, logger_1.createLogger)("connection");
    var NR_CODE = 10;
    var Connection2 = class extends events_1.default {
      constructor(readable, writeable) {
        super();
        this.writeable = writeable;
        let cached = [];
        let hasCache = false;
        readable.once("data", (buf) => {
          if (!Buffer.isBuffer(buf))
            throw new Error(`Vim connection expect Buffer from readable stream.`);
        });
        let onData = (buf) => {
          let start = 0;
          let len = buf.byteLength;
          for (let i = 0; i < len; i++) {
            if (buf[i] === NR_CODE) {
              let b = buf.slice(start, i);
              if (hasCache) {
                cached.push(b);
                let concated = Buffer.concat(cached);
                hasCache = false;
                cached = [];
                this.parseData(concated.toString("utf8"));
              } else {
                this.parseData(b.toString("utf8"));
              }
              start = i + 1;
            }
          }
          if (start < len) {
            cached.push(start == 0 ? buf : buf.slice(start));
            hasCache = true;
          }
        };
        readable.on("data", onData);
        let onClose = () => {
          logger60.warn("readable stream closed.");
        };
        readable.on("close", onClose);
        this.clean = () => {
          readable.off("data", onData);
          readable.off("close", onClose);
        };
      }
      parseData(str) {
        if (str.length == 0)
          return;
        let arr;
        try {
          arr = JSON.parse(str);
        } catch (e) {
          logger60.error(`Invalid data from vim: ${str}`);
          return;
        }
        let [id2, obj] = arr;
        if (id2 > 0) {
          logger60.debug("received request:", id2, obj);
          this.emit("request", id2, obj);
        } else if (id2 == 0) {
          logger60.debug("received notification:", obj);
          this.emit("notification", obj);
        } else {
          logger60.debug("received response:", id2, obj);
          this.emit("response", id2, obj);
        }
      }
      response(requestId, data) {
        this.send([requestId, data || null]);
      }
      notify(event, data) {
        this.send([0, [event, data || null]]);
      }
      send(arr) {
        logger60.debug("send to vim:", arr);
        this.writeable.write(JSON.stringify(arr) + "\n");
      }
      redraw(force) {
        this.send(["redraw", force ? "force" : ""]);
      }
      ex(cmd) {
        this.send(["ex", cmd]);
      }
      expr(expr, requestId) {
        if (typeof requestId === "number") {
          this.send(["expr", expr, requestId]);
          return;
        }
        this.send(["expr", expr]);
      }
      call(func2, args, requestId) {
        if (typeof requestId === "number") {
          this.send(["call", func2, args, requestId]);
          return;
        }
        this.send(["call", func2, args]);
      }
      dispose() {
        if (typeof this.clean === "function") {
          this.clean();
          this.clean = void 0;
        }
        this.removeAllListeners();
      }
    };
    exports2.default = Connection2;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/request.js
var require_request = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/request.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var constants_1 = require_constants2();
    var func2 = constants_1.isCocNvim ? "coc#api#Call" : "nvim#api#Call";
    var Request = class {
      constructor(connection, cb, id2) {
        this.connection = connection;
        this.cb = cb;
        this.id = id2;
        this._direct = false;
      }
      get isDirect() {
        return this._direct;
      }
      request(method, args = []) {
        this.method = method;
        this.connection.call(func2, [method.slice(5), args], this.id);
      }
      call(method, args = []) {
        this._direct = true;
        this.method = "call";
        this.connection.call(method, args, this.id);
      }
      expr(expr) {
        this._direct = true;
        this.method = "expr";
        this.connection.expr(expr, this.id);
      }
      callback(client, err, result) {
        let { method, cb } = this;
        if (err)
          return cb([0, err.toString()]);
        switch (method) {
          case "nvim_list_wins":
          case "nvim_tabpage_list_wins":
            return cb(null, result.map((o) => client.createWindow(o)));
          case "nvim_tabpage_get_win":
          case "nvim_get_current_win":
          case "nvim_open_win":
            return cb(null, client.createWindow(result));
          case "nvim_list_bufs":
            return cb(null, result.map((o) => client.createBuffer(o)));
          case "nvim_win_get_buf":
          case "nvim_create_buf":
          case "nvim_get_current_buf":
            return cb(null, client.createBuffer(result));
          case "nvim_list_tabpages":
            return cb(null, result.map((o) => client.createTabpage(o)));
          case "nvim_win_get_tabpage":
          case "nvim_get_current_tabpage":
            return cb(null, client.createTabpage(result));
          default:
            return cb(null, result);
        }
      }
    };
    exports2.default = Request;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/vim.js
var require_vim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/vim.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VimTransport = void 0;
    var constants_1 = require_constants2();
    var base_1 = __importDefault(require_base());
    var connection_1 = __importDefault(require_connection());
    var request_1 = __importDefault(require_request());
    var notifyMethod = constants_1.isCocNvim ? "coc#api#Notify" : "nvim#api#Notify";
    var VimTransport = class extends base_1.default {
      constructor(logger60) {
        super(logger60, true);
        this.pending = /* @__PURE__ */ new Map();
        this.nextRequestId = -1;
        this.attached = false;
        this.errText = "";
        this.outText = "";
      }
      attach(writer, reader, client) {
        let connection = this.connection = new connection_1.default(reader, writer);
        this.attached = true;
        this.client = client;
        connection.on("request", (id2, obj) => {
          let [method, args] = obj;
          this.emit("request", method, args, this.createResponse(method, id2));
        });
        connection.on("notification", (obj) => {
          let [event, args] = obj;
          this.emit("notification", event.toString(), args);
        });
        connection.on("response", (id2, obj) => {
          let req = this.pending.get(id2);
          if (req) {
            this.pending.delete(id2);
            let err = null;
            let result = null;
            if (req.isDirect) {
              result = obj;
            } else {
              if (!Array.isArray(obj)) {
                err = obj;
              } else {
                err = obj[0];
                result = obj[1];
              }
            }
            req.callback(this.client, err, result);
          }
        });
      }
      send(arr) {
        this.connection.send(arr);
      }
      detach() {
        if (!this.attached)
          return;
        this.attached = false;
        this.connection.dispose();
        for (let req of this.pending.values()) {
          req.callback(this.client, "connection disconnected", null);
        }
        this.pending.clear();
      }
      vimCommand(command, ...args) {
        switch (command) {
          case "expr":
            this.connection.expr(args[0]);
            break;
          case "call":
            this.connection.call(args[0], args[1]);
            break;
          case "ex":
            this.connection.ex(args[0]);
            break;
          case "redraw":
            this.connection.redraw(args[0]);
            break;
          default:
            throw new Error(`command "${command}" not exists`);
        }
      }
      vimRequest(command, args) {
        if (!this.attached)
          return Promise.reject(new Error("transport disconnected"));
        Error.captureStackTrace(args);
        let id2 = this.nextRequestId;
        this.nextRequestId = this.nextRequestId - 1;
        return new Promise((resolve, reject) => {
          let req = new request_1.default(this.connection, (err, res) => {
            if (!err && res === "ERROR") {
              if (command === "eval") {
                err = new Error(`Invalid expression "${args[0]}", checkout v:errmsg`);
              } else {
                err = new Error(`Error on function "${args[0]}", checkout v:errmsg"`);
              }
            }
            if (err) {
              err.stack = `Error: vim "${command}" error - ${err}
` + args["stack"].split(/\r?\n/).slice(3).join("\n");
              this.client.logError(`Error on vim command "${command}"`, args, err);
              reject(err);
              return;
            }
            resolve(res);
          }, id2);
          this.pending.set(id2, req);
          if (command === "call") {
            req.call(args[0], args[1]);
          } else {
            req.expr(args[0]);
          }
        });
      }
      /**
       * Send request to vim
       */
      request(method, args, cb) {
        if (!this.attached)
          return cb([0, "transport disconnected"]);
        let id2 = this.nextRequestId;
        this.nextRequestId = this.nextRequestId - 1;
        let req = new request_1.default(this.connection, (err, res) => {
          cb(err, res);
        }, id2);
        this.pending.set(id2, req);
        req.request(method, args);
      }
      notify(method, args) {
        if (!this.attached)
          return;
        if (this.pauseLevel != 0) {
          let arr = this.paused.get(this.pauseLevel);
          if (arr) {
            arr.push([method, args]);
            return;
          }
        }
        let fname = method.slice(5);
        if (fname == "err_write") {
          this.errText = this.errText + args[0].toString();
          return;
        }
        if (fname == "out_write") {
          let msg = args[0].toString() || "";
          if (!msg.includes("\n")) {
            this.outText = this.outText + msg;
          } else {
            let text = this.outText + args[0].toString();
            this.outText = "";
            this.connection.call(notifyMethod, [fname, [text]]);
          }
          return;
        }
        if (fname == "err_writeln") {
          let text = this.errText + args[0].toString();
          this.errText = "";
          this.connection.call(notifyMethod, [fname, [text]]);
          return;
        }
        this.connection.call(notifyMethod, [fname, args]);
      }
      createResponse(_method, requestId) {
        let called = false;
        let { connection } = this;
        return {
          send: (resp, isError) => {
            if (called || !this.attached)
              return;
            called = true;
            let err = null;
            if (isError)
              err = typeof resp === "string" ? resp : resp.toString();
            connection.response(requestId, [err, isError ? null : resp]);
          }
        };
      }
    };
    exports2.VimTransport = VimTransport;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Neovim.js
var require_Neovim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Neovim.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Neovim = void 0;
    var constants_1 = require_constants2();
    var Base_1 = require_Base();
    function getArgs(args) {
      if (!args)
        return [];
      if (Array.isArray(args))
        return args;
      return [args];
    }
    var Neovim2 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_";
      }
      get apiInfo() {
        return this.request(`${this.prefix}get_api_info`);
      }
      /** Get list of all buffers */
      get buffers() {
        return this.request(`${this.prefix}list_bufs`);
      }
      /** Get current buffer */
      get buffer() {
        return this.request(`${this.prefix}get_current_buf`);
      }
      /** Retrieves a scoped option depending on type of `this` */
      getOption(name2) {
        if (constants_1.isCocNvim)
          return this.request(`${this.prefix}get_option_value`, [name2, {}]);
        return super.getOption(name2);
      }
      setOption(name2, value, isNotify) {
        if (constants_1.isCocNvim)
          return this[isNotify ? "notify" : "request"](`${this.prefix}set_option_value`, [name2, value, {}]);
        return this[isNotify ? "notify" : "request"](`${this.prefix}set_option`, [name2, value]);
      }
      /** Set current buffer */
      async setBuffer(buffer) {
        await this.request(`${this.prefix}set_current_buf`, [buffer]);
      }
      get chans() {
        return this.request(`${this.prefix}list_chans`);
      }
      getChanInfo(chan) {
        return this.request(`${this.prefix}get_chan_info`, [chan]);
      }
      createNamespace(name2 = "") {
        if (constants_1.isCocNvim)
          name2 = name2.startsWith("coc-") ? name2 : `coc-${name2}`;
        return this.request(`${this.prefix}create_namespace`, [name2]);
      }
      get namespaces() {
        return this.request(`${this.prefix}get_namespaces`, []);
      }
      get commands() {
        return this.getCommands();
      }
      getCommands(options2 = {}) {
        return this.request(`${this.prefix}get_commands`, [options2]);
      }
      /** Get list of all tabpages */
      get tabpages() {
        return this.request(`${this.prefix}list_tabpages`);
      }
      /** Get current tabpage */
      get tabpage() {
        return this.request(`${this.prefix}get_current_tabpage`);
      }
      /** Set current tabpage */
      async setTabpage(tabpage) {
        await this.request(`${this.prefix}set_current_tabpage`, [tabpage]);
      }
      /** Get list of all windows */
      get windows() {
        return this.getWindows();
      }
      /** Get current window */
      get window() {
        return this.request(`${this.prefix}get_current_win`);
      }
      /** Get list of all windows */
      getWindows() {
        return this.request(`${this.prefix}list_wins`);
      }
      async setWindow(win) {
        await this.request(`${this.prefix}set_current_win`, [win]);
      }
      /** Get list of all runtime paths */
      get runtimePaths() {
        return this.request(`${this.prefix}list_runtime_paths`);
      }
      /** Set current directory */
      setDirectory(dir) {
        return this.request(`${this.prefix}set_current_dir`, [dir]);
      }
      /** Get current line. Always returns a Promise. */
      get line() {
        return this.getLine();
      }
      createNewBuffer(listed = false, scratch = false) {
        return this.request(`${this.prefix}create_buf`, [listed, scratch]);
      }
      openFloatWindow(buffer, enter, options2) {
        return this.request(`${this.prefix}open_win`, [buffer, enter, options2]);
      }
      getLine() {
        return this.request(`${this.prefix}get_current_line`);
      }
      /** Set current line */
      setLine(line) {
        return this.request(`${this.prefix}set_current_line`, [line]);
      }
      /** Gets keymap */
      getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
      }
      /**
       * Add keymap by notification, replace keycodes for expr keymap enabled by default.
       */
      setKeymap(mode, lhs, rhs, opts = {}) {
        let option = opts.expr ? Object.assign({ replace_keycodes: true }, opts) : opts;
        this.notify(`${this.prefix}set_keymap`, [mode, lhs, rhs, option]);
      }
      deleteKeymap(mode, lhs) {
        this.notify(`${this.prefix}del_keymap`, [mode, lhs]);
      }
      /** Gets current mode */
      get mode() {
        return this.request(`${this.prefix}get_mode`);
      }
      /** Gets map of defined colors */
      get colorMap() {
        return this.request(`${this.prefix}get_color_map`);
      }
      /** Get color by name */
      getColorByName(name2) {
        return this.request(`${this.prefix}get_color_by_name`, [name2]);
      }
      /** Get highlight by name or id */
      getHighlight(nameOrId, isRgb = true) {
        const functionName = typeof nameOrId === "string" ? "by_name" : "by_id";
        return this.request(`${this.prefix}get_hl_${functionName}`, [
          nameOrId,
          isRgb
        ]);
      }
      getHighlightByName(name2, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_name`, [name2, isRgb]);
      }
      getHighlightById(id2, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_id`, [id2, isRgb]);
      }
      /** Delete current line in buffer */
      deleteCurrentLine() {
        return this.request(`${this.prefix}del_current_line`);
      }
      /**
       * Evaluates a VimL expression (:help expression). Dictionaries
       * and Lists are recursively expanded. On VimL error: Returns a
       * generic error; v:errmsg is not updated.
       *
       */
      eval(expr) {
        return this.request(`${this.prefix}eval`, [expr]);
      }
      /**
       * Executes lua, it's possible neovim client does not support this
       */
      lua(code, args = []) {
        return this.request(`${this.prefix}exec_lua`, [code, args]);
      }
      // Alias for `lua()` to be consistent with neovim API
      executeLua(code, args = []) {
        const _args = getArgs(args);
        return this.lua(code, _args);
      }
      callDictFunction(dict, fname, args = []) {
        const _args = getArgs(args);
        return this.request(`${this.prefix}call_dict_function`, [
          dict,
          fname,
          _args
        ]);
      }
      callVim(fname, args = [], isNotify) {
        if (!constants_1.isVim)
          return this.call(fname, args, isNotify);
        const _args = getArgs(args);
        if (isNotify)
          return this.transport.vimCommand("call", fname, _args);
        return this.transport.vimRequest("call", [fname, _args]);
      }
      /**
       * Use direct expr command on vim9
       */
      evalVim(expr) {
        if (!constants_1.isVim)
          return this.request(`${this.prefix}eval`, [expr]);
        return this.transport.vimRequest("eval", [expr]);
      }
      /**
       * Use direct ex on vim9
       */
      exVim(arg) {
        if (!constants_1.isVim)
          return this.notify(`${this.prefix}command`, [arg]);
        this.transport.vimCommand("ex", arg);
      }
      call(fname, args = [], isNotify) {
        const _args = getArgs(args);
        if (isNotify) {
          this.notify(`${this.prefix}call_function`, [fname, _args]);
          return null;
        }
        return this.request(`${this.prefix}call_function`, [fname, _args]);
      }
      callTimer(fname, args = [], isNotify) {
        const _args = getArgs(args);
        if (isNotify) {
          this.notify(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
          return null;
        }
        if (constants_1.isVim) {
          this.notify(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
          return new Promise((resolve) => {
            setTimeout(() => {
              resolve(null);
            }, 20);
          });
        }
        return this.request(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
      }
      callAsync(fname, args = []) {
        const _args = getArgs(args);
        return this.client.sendAsyncRequest(fname, _args);
      }
      /** Alias for `call` */
      callFunction(fname, args = []) {
        return this.call(fname, args);
      }
      /** Call Atomic calls */
      callAtomic(calls) {
        return this.request(`${this.prefix}call_atomic`, [calls]);
      }
      command(arg, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}command`, [arg]);
          return null;
        }
        return this.request(`${this.prefix}command`, [arg]);
      }
      /**
       * Runs a command and returns output.
       *
       * @deprecated Use exec instead.
       */
      commandOutput(arg) {
        return this.request(`${this.prefix}command_output`, [arg]);
      }
      /**
       * Executes Vimscript (multiline block of Ex-commands), like
       * anonymous |:source|
       */
      exec(src, output = false) {
        return this.request(`${this.prefix}exec`, [src, output]);
      }
      /** Gets a v: variable */
      getVvar(name2) {
        return this.request(`${this.prefix}get_vvar`, [name2]);
      }
      /** feedKeys */
      feedKeys(keys, mode, escapeCsi) {
        return this.request(`${this.prefix}feedkeys`, [keys, mode, escapeCsi]);
      }
      /** Sends input keys */
      input(keys) {
        return this.request(`${this.prefix}input`, [keys]);
      }
      /**
       * Send mouse event from GUI. Neovim only.
       *
       * @param {MouseButton} button Mouse button: one of "left", "right", "middle", "wheel", "move".
       * @param {ButtonAction} action For ordinary buttons, one of "press", "drag", "release".
       * @param {string} modifier String of modifiers each represented by a single char.
       * @param {number} row Mouse row-position (zero-based, like redraw events)
       * @param {number} col Mouse column-position (zero-based, like redraw events)
       * @param {number} grid Grid number if the client uses |ui-multigrid|, else 0.
       * @returns {Promise<null>}
       */
      inputMouse(button, action, modifier, row, col, grid = 0) {
        return this.request(`${this.prefix}input_mouse`, [button, action, modifier, grid, row, col]);
      }
      /**
       * Parse a VimL Expression
       *
       * TODO: return type, see :help
       */
      parseExpression(expr, flags, highlight) {
        return this.request(`${this.prefix}parse_expression`, [
          expr,
          flags,
          highlight
        ]);
      }
      getProc(pid) {
        return this.request(`${this.prefix}get_proc`, [pid]);
      }
      getProcChildren(pid) {
        return this.request(`${this.prefix}get_proc_children`, [pid]);
      }
      /** Replace term codes */
      replaceTermcodes(str, fromPart, doIt, special) {
        return this.request(`${this.prefix}replace_termcodes`, [
          str,
          fromPart,
          doIt,
          special
        ]);
      }
      /** Gets width of string */
      strWidth(str) {
        return this.request(`${this.prefix}strwidth`, [str]);
      }
      /** Write to output buffer */
      outWrite(str) {
        this.notify(`${this.prefix}out_write`, [str]);
      }
      outWriteLine(str) {
        this.outWrite(`${str}
`);
      }
      /** Write to error buffer */
      errWrite(str) {
        this.notify(`${this.prefix}err_write`, [str]);
      }
      /** Write to error buffer */
      errWriteLine(str) {
        this.notify(`${this.prefix}err_writeln`, [str]);
      }
      // TODO: add type
      get uis() {
        return this.request(`${this.prefix}list_uis`);
      }
      uiAttach(width, height, options2) {
        return this.request(`${this.prefix}ui_attach`, [width, height, options2]);
      }
      uiDetach() {
        return this.request(`${this.prefix}ui_detach`, []);
      }
      uiTryResize(width, height) {
        return this.request(`${this.prefix}ui_try_resize`, [width, height]);
      }
      /** Set UI Option */
      uiSetOption(name2, value) {
        return this.request(`${this.prefix}ui_set_option`, [name2, value]);
      }
      /** Subscribe to nvim event broadcasts */
      subscribe(event) {
        return this.request(`${this.prefix}subscribe`, [event]);
      }
      /** Unsubscribe to nvim event broadcasts */
      unsubscribe(event) {
        return this.request(`${this.prefix}unsubscribe`, [event]);
      }
      createAugroup(name2, option = {}, isNotify = false) {
        if (!isNotify)
          return this.request(`${this.prefix}create_augroup`, [name2, option]);
        this.notify(`${this.prefix}create_augroup`, [name2, option]);
      }
      createAutocmd(event, option = {}, isNotify = false) {
        if (!isNotify)
          return this.request(`${this.prefix}create_autocmd`, [event, option]);
        this.notify(`${this.prefix}create_autocmd`, [event, option]);
      }
      deleteAutocmd(id2) {
        this.notify(`${this.prefix}del_autocmd`, [id2]);
      }
      setClientInfo(name2, version2, type, methods2, attributes) {
        this.notify(`${this.prefix}set_client_info`, [
          name2,
          version2,
          type,
          methods2,
          attributes
        ]);
      }
      /** Quit nvim */
      async quit() {
        this.command("qa!", true);
        if (this.transport) {
          this.transport.detach();
        }
      }
    };
    exports2.Neovim = Neovim2;
  }
});

// node_modules/@chemzqm/neovim/lib/api/client.js
var require_client = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NeovimClient = exports2.AsyncResponse = void 0;
    var events_1 = require("events");
    var nvim_1 = require_nvim();
    var vim_1 = require_vim();
    var constants_1 = require_constants2();
    var Buffer_1 = require_Buffer();
    var Neovim_1 = require_Neovim();
    var Tabpage_1 = require_Tabpage();
    var Window_1 = require_Window();
    var functionsOnVim = [
      "nvim_buf_attach",
      "nvim_get_mode",
      "nvim_list_runtime_paths",
      "nvim_win_del_var",
      "nvim_create_buf",
      "nvim_exec",
      "nvim_tabpage_list_wins",
      "nvim_buf_del_var",
      "nvim_buf_get_mark",
      "nvim_tabpage_set_var",
      "nvim_create_namespace",
      "nvim_win_get_position",
      "nvim_win_set_height",
      "nvim_call_atomic",
      "nvim_buf_detach",
      "nvim_buf_line_count",
      "nvim_set_current_buf",
      "nvim_set_current_dir",
      "nvim_get_var",
      "nvim_del_current_line",
      "nvim_win_set_width",
      "nvim_out_write",
      "nvim_win_is_valid",
      "nvim_set_current_win",
      "nvim_get_current_tabpage",
      "nvim_tabpage_is_valid",
      "nvim_set_var",
      "nvim_win_get_height",
      "nvim_win_get_buf",
      "nvim_win_get_width",
      "nvim_buf_set_name",
      "nvim_subscribe",
      "nvim_get_current_win",
      "nvim_feedkeys",
      "nvim_get_vvar",
      "nvim_tabpage_get_number",
      "nvim_get_current_buf",
      "nvim_win_get_option",
      "nvim_win_get_cursor",
      "nvim_get_current_line",
      "nvim_win_get_var",
      "nvim_buf_get_var",
      "nvim_set_current_tabpage",
      "nvim_buf_clear_namespace",
      "nvim_err_write",
      "nvim_del_var",
      "nvim_call_dict_function",
      "nvim_set_current_line",
      "nvim_get_api_info",
      "nvim_unsubscribe",
      "nvim_get_option",
      "nvim_list_wins",
      "nvim_set_client_info",
      "nvim_win_set_cursor",
      "nvim_win_set_option",
      "nvim_eval",
      "nvim_tabpage_get_var",
      "nvim_buf_get_option",
      "nvim_tabpage_del_var",
      "nvim_buf_get_name",
      "nvim_list_bufs",
      "nvim_win_set_buf",
      "nvim_win_close",
      "nvim_command_output",
      "nvim_command",
      "nvim_tabpage_get_win",
      "nvim_win_set_var",
      "nvim_buf_add_highlight",
      "nvim_buf_set_var",
      "nvim_win_get_number",
      "nvim_strwidth",
      "nvim_buf_set_lines",
      "nvim_err_writeln",
      "nvim_buf_set_option",
      "nvim_list_tabpages",
      "nvim_set_option",
      "nvim_buf_get_lines",
      "nvim_buf_get_changedtick",
      "nvim_win_get_tabpage",
      "nvim_call_function",
      "nvim_buf_is_valid"
    ];
    var AsyncResponse = class {
      constructor(requestId, cb) {
        this.requestId = requestId;
        this.cb = cb;
        this.finished = false;
      }
      finish(err, res) {
        if (this.finished)
          return;
        this.finished = true;
        if (err) {
          this.cb(new Error(err));
          return;
        }
        this.cb(null, res);
      }
    };
    exports2.AsyncResponse = AsyncResponse;
    function applyMixins(derivedCtor, constructors) {
      constructors.forEach((baseCtor) => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach((name2) => {
          Object.defineProperty(derivedCtor.prototype, name2, Object.getOwnPropertyDescriptor(baseCtor.prototype, name2) || /* @__PURE__ */ Object.create(null));
        });
      });
    }
    var NeovimClient = class extends Neovim_1.Neovim {
      constructor(logger60, isVim2) {
        super({});
        this.logger = logger60;
        this.isVim = isVim2;
        this.requestId = 1;
        this.responses = /* @__PURE__ */ new Map();
        this.attachedBuffers = /* @__PURE__ */ new Map();
        this._transport = isVim2 ? new vim_1.VimTransport(logger60) : new nvim_1.NvimTransport(logger60);
        this.handleRequest = this.handleRequest.bind(this);
        this.handleNotification = this.handleNotification.bind(this);
      }
      get transport() {
        return this._transport;
      }
      echoError(msg) {
        let prefix = constants_1.isCocNvim ? "[coc.nvim] " : "";
        if (msg instanceof Error) {
          if (!constants_1.isTester)
            this.errWriteLine(prefix + msg.message + " use :CocOpenLog for details");
          this.logError(msg.message || "Unknown error", msg);
        } else {
          if (!constants_1.isTester)
            this.errWriteLine(prefix + msg);
          this.logError(msg.toString(), new Error());
        }
      }
      logError(msg, ...args) {
        if (constants_1.isTester)
          console.error(msg, ...args);
        if (!this.logger)
          return;
        this.logger.error(msg, ...args);
      }
      createBuffer(id2) {
        return new Buffer_1.Buffer({
          data: id2,
          client: this
        });
      }
      createWindow(id2) {
        return new Window_1.Window({
          data: id2,
          client: this
        });
      }
      createTabpage(id2) {
        return new Tabpage_1.Tabpage({
          data: id2,
          client: this
        });
      }
      /**
       * Invoke redraw on vim, must called when screen need update.
       */
      redrawVim(force) {
        if (!this.isVim)
          return;
        this.transport.notify("nvim_command", [`redraw${force ? "!" : ""}`]);
      }
      /** Attaches msgpack to read/write streams * */
      attach({ reader, writer }, requestApi = true) {
        this.transport.attach(writer, reader, this);
        this.transport.on("request", this.handleRequest);
        this.transport.on("notification", this.handleNotification);
        this.transport.on("detach", () => {
          this.emit("disconnect");
          this.transport.removeAllListeners("request");
          this.transport.removeAllListeners("notification");
          this.transport.removeAllListeners("detach");
        });
        if (requestApi) {
          this._isReady = this.generateApi().catch((err) => {
            this.logger.error(err);
            return false;
          });
        } else {
          this._channelId = -1;
          this._isReady = Promise.resolve(true);
        }
      }
      /* called when attach process disconnected*/
      detach() {
        this.attachedBuffers.clear();
        this.transport.detach();
        this.removeAllListeners();
      }
      get channelId() {
        return this._isReady.then(() => {
          return this._channelId;
        });
      }
      handleRequest(method, args, resp) {
        this.emit("request", method, args, resp);
      }
      sendAsyncRequest(method, args) {
        let id2 = this.requestId;
        this.requestId = id2 + 1;
        this.notify("nvim_call_function", ["coc#rpc#async_request", [id2, method, args || []]]);
        return new Promise((resolve, reject) => {
          let response = new AsyncResponse(id2, (err, res) => {
            if (err)
              return reject(err);
            resolve(res);
          });
          this.responses.set(id2, response);
        });
      }
      handleNotification(method, args) {
        if (method.endsWith("_event")) {
          if (method == "vim_buf_change_event") {
            const id2 = args[0];
            if (!this.attachedBuffers.has(id2))
              return;
            const bufferMap = this.attachedBuffers.get(id2);
            const cbs = bufferMap.get("vim_lines") || [];
            cbs.forEach((cb) => cb(...args));
            return;
          }
          if (method.startsWith("nvim_buf_")) {
            const shortName = method.replace(/nvim_buf_(.*)_event/, "$1");
            const { id: id2 } = args[0];
            if (!this.attachedBuffers.has(id2))
              return;
            const bufferMap = this.attachedBuffers.get(id2);
            const cbs = bufferMap.get(shortName) || [];
            cbs.forEach((cb) => cb(...args));
            if (shortName === "detach") {
              this.attachedBuffers.delete(id2);
            }
            return;
          }
          if (method == "nvim_async_request_event") {
            const [id2, method2, arr] = args;
            this.handleRequest(method2, arr, {
              send: (resp, isError) => {
                this.notify("nvim_call_function", ["coc#rpc#async_response", [id2, resp, isError]]);
              }
            });
            return;
          }
          if (method == "nvim_async_response_event") {
            const [id2, err, res] = args;
            const response = this.responses.get(id2);
            if (!response) {
              this.logError(`Response not found for request ${id2}`);
              return;
            }
            this.responses.delete(id2);
            response.finish(err, res);
            return;
          }
          if (method === "nvim_error_event") {
            this.logger.error(`Error event from nvim:`, args[0], args[1]);
            this.emit("vim_error", args[1]);
            return;
          }
          this.logger.warn(`Unhandled event: ${method}`, args);
        } else {
          this.emit("notification", method, args);
        }
      }
      requestApi() {
        return new Promise((resolve, reject) => {
          this.transport.request("nvim_get_api_info", [], (err, res) => {
            if (err) {
              reject(new Error(Array.isArray(err) ? err[1] : err.message || err.toString()));
            } else {
              resolve(res);
            }
          });
        });
      }
      async generateApi() {
        let results = await this.requestApi();
        const [channelId, metadata] = results;
        this._channelId = channelId;
        return true;
      }
      attachBufferEvent(bufnr, eventName, cb) {
        const bufferMap = this.attachedBuffers.get(bufnr) || /* @__PURE__ */ new Map();
        const cbs = bufferMap.get(eventName) || [];
        if (cbs.includes(cb))
          return;
        cbs.push(cb);
        bufferMap.set(eventName, cbs);
        this.attachedBuffers.set(bufnr, bufferMap);
        return;
      }
      /**
       * Returns `true` if buffer should be detached
       */
      detachBufferEvent(bufnr, eventName, cb) {
        const bufferMap = this.attachedBuffers.get(bufnr);
        if (!bufferMap || !bufferMap.has(eventName))
          return;
        const handlers = bufferMap.get(eventName).filter((handler) => handler !== cb);
        bufferMap.set(eventName, handlers);
      }
      pauseNotification() {
        let o = {};
        Error.captureStackTrace(o);
        if (this.transport.pauseLevel != 0) {
          this.logError(`Nested nvim.pauseNotification() detected, please avoid it:`, o.stack);
        }
        this.transport.pauseNotification();
        process.nextTick(() => {
          if (this.transport.pauseLevel > 0) {
            this.logError(`resumeNotification not called within same tick:`, o.stack);
          }
        });
      }
      resumeNotification(redrawVim, notify) {
        if (this.isVim && redrawVim) {
          this.transport.notify("nvim_command", ["redraw"]);
        }
        if (notify) {
          this.transport.resumeNotification(true);
          return Promise.resolve(null);
        }
        return this.transport.resumeNotification();
      }
      /**
       * @deprecated
       */
      hasFunction(name2) {
        if (!this.isVim)
          return true;
        return functionsOnVim.includes(name2);
      }
    };
    exports2.NeovimClient = NeovimClient;
    applyMixins(NeovimClient, [events_1.EventEmitter]);
  }
});

// node_modules/@chemzqm/neovim/lib/api/index.js
var require_api = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tabpage = exports2.Window = exports2.Buffer = exports2.NeovimClient = exports2.Neovim = void 0;
    var client_1 = require_client();
    Object.defineProperty(exports2, "Neovim", { enumerable: true, get: function() {
      return client_1.NeovimClient;
    } });
    var client_2 = require_client();
    Object.defineProperty(exports2, "NeovimClient", { enumerable: true, get: function() {
      return client_2.NeovimClient;
    } });
    var Buffer_1 = require_Buffer();
    Object.defineProperty(exports2, "Buffer", { enumerable: true, get: function() {
      return Buffer_1.Buffer;
    } });
    var Window_1 = require_Window();
    Object.defineProperty(exports2, "Window", { enumerable: true, get: function() {
      return Window_1.Window;
    } });
    var Tabpage_1 = require_Tabpage();
    Object.defineProperty(exports2, "Tabpage", { enumerable: true, get: function() {
      return Tabpage_1.Tabpage;
    } });
  }
});

// node_modules/@chemzqm/neovim/lib/attach/attach.js
var require_attach = __commonJS({
  "node_modules/@chemzqm/neovim/lib/attach/attach.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attach = attach2;
    var net_1 = require("net");
    var constants_1 = require_constants2();
    var logger_1 = require_logger();
    var client_1 = require_client();
    function attach2({ reader: _reader, writer: _writer, proc, socket }, logger60 = null, requestApi = true) {
      let writer;
      let reader;
      let neovim;
      if (!logger60)
        logger60 = logger_1.nullLogger;
      if (socket) {
        const client = (0, net_1.createConnection)(socket);
        writer = client;
        reader = client;
        client.once("close", () => {
          neovim.detach();
        });
      } else if (_reader && _writer) {
        writer = _writer;
        reader = _reader;
      } else if (proc) {
        writer = proc.stdin;
        reader = proc.stdout;
        proc.once("disconnect", () => {
          neovim.detach();
        });
      }
      writer.on("error", (err) => {
        if (err.code == "EPIPE") {
          neovim.detach();
        }
      });
      if (writer && reader) {
        neovim = new client_1.NeovimClient(logger60, constants_1.isVim);
        neovim.attach({
          writer,
          reader
        }, requestApi);
        return neovim;
      }
      throw new Error("Invalid arguments, could not attach");
    }
  }
});

// node_modules/@chemzqm/neovim/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@chemzqm/neovim/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attach = exports2.Window = exports2.Tabpage = exports2.Neovim = exports2.Buffer = void 0;
    var index_1 = require_api();
    Object.defineProperty(exports2, "Buffer", { enumerable: true, get: function() {
      return index_1.Buffer;
    } });
    Object.defineProperty(exports2, "Neovim", { enumerable: true, get: function() {
      return index_1.Neovim;
    } });
    Object.defineProperty(exports2, "Tabpage", { enumerable: true, get: function() {
      return index_1.Tabpage;
    } });
    Object.defineProperty(exports2, "Window", { enumerable: true, get: function() {
      return index_1.Window;
    } });
    var attach_1 = require_attach();
    Object.defineProperty(exports2, "attach", { enumerable: true, get: function() {
      return attach_1.attach;
    } });
  }
});

// src/util/errors.ts
function assert(condition) {
  if (!condition) {
    throw new BugIndicatingError("Assertion Failed");
  }
}
function isCancellationError(error) {
  if (error instanceof CancellationError) {
    return true;
  }
  return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
function shouldIgnore(err) {
  if (isCancellationError(err)) return true;
  if (err instanceof Error && err.message.includes("transport disconnected")) return true;
  return false;
}
function onUnexpectedError(e) {
  if (shouldIgnore(e)) return;
  if (e.stack) {
    throw new Error(e.message + "\n\n" + e.stack);
  }
  throw e;
}
function notLoaded(uri) {
  return new Error(`File ${uri} not loaded`);
}
function illegalArgument(name2) {
  if (name2) {
    return new Error(`Illegal argument: ${name2}`);
  } else {
    return new Error("Illegal argument");
  }
}
function directoryNotExists(dir) {
  return new Error(`Directory ${dir} not exists`);
}
function fileExists(filepath) {
  return new Error(`File ${filepath} already exists`);
}
function fileNotExists(filepath) {
  return new Error(`File ${filepath} not exists`);
}
function shouldNotAsync(method) {
  return new Error(`${method} should not be called in an asynchronize manner`);
}
function badScheme(uri) {
  return new Error(`Change of ${uri} not supported`);
}
var canceledName, CancellationError, BugIndicatingError;
var init_errors = __esm({
  "src/util/errors.ts"() {
    "use strict";
    canceledName = "Canceled";
    CancellationError = class extends Error {
      constructor() {
        super(canceledName);
        this.name = this.message;
      }
    };
    BugIndicatingError = class _BugIndicatingError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _BugIndicatingError.prototype);
        debugger;
      }
    };
  }
});

// node_modules/vscode-languageserver-types/lib/esm/main.js
var DocumentUri, URI, integer, uinteger, Position, Range, Location, LocationLink, Color, ColorInformation, ColorPresentation, FoldingRangeKind, FoldingRange, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, CodeDescription, Diagnostic, Command, TextEdit, ChangeAnnotation, ChangeAnnotationIdentifier, AnnotatedTextEdit, TextDocumentEdit, CreateFile, RenameFile, DeleteFile, WorkspaceEdit, TextEditChangeImpl, ChangeAnnotations, WorkspaceChange, TextDocumentIdentifier, VersionedTextDocumentIdentifier, OptionalVersionedTextDocumentIdentifier, TextDocumentItem, MarkupKind, MarkupContent, CompletionItemKind, InsertTextFormat, CompletionItemTag, InsertReplaceEdit, InsertTextMode, CompletionItemLabelDetails, CompletionItem, CompletionList, MarkedString, Hover, ParameterInformation, SignatureInformation, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolTag, SymbolInformation, WorkspaceSymbol, DocumentSymbol, CodeActionKind, CodeActionTriggerKind, CodeActionContext, CodeAction, CodeLens, FormattingOptions, DocumentLink, SelectionRange, SemanticTokenTypes, SemanticTokenModifiers, SemanticTokens, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, InlineValueContext, InlayHintKind, InlayHintLabelPart, InlayHint, StringValue, InlineCompletionItem, InlineCompletionList, InlineCompletionTriggerKind, SelectedCompletionInfo, InlineCompletionContext, WorkspaceFolder, TextDocument, FullTextDocument, Is;
var init_main = __esm({
  "node_modules/vscode-languageserver-types/lib/esm/main.js"() {
    "use strict";
    (function(DocumentUri2) {
      function is(value) {
        return typeof value === "string";
      }
      DocumentUri2.is = is;
    })(DocumentUri || (DocumentUri = {}));
    (function(URI3) {
      function is(value) {
        return typeof value === "string";
      }
      URI3.is = is;
    })(URI || (URI = {}));
    (function(integer2) {
      integer2.MIN_VALUE = -2147483648;
      integer2.MAX_VALUE = 2147483647;
      function is(value) {
        return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
      }
      integer2.is = is;
    })(integer || (integer = {}));
    (function(uinteger3) {
      uinteger3.MIN_VALUE = 0;
      uinteger3.MAX_VALUE = 2147483647;
      function is(value) {
        return typeof value === "number" && uinteger3.MIN_VALUE <= value && value <= uinteger3.MAX_VALUE;
      }
      uinteger3.is = is;
    })(uinteger || (uinteger = {}));
    (function(Position10) {
      function create(line, character) {
        if (line === Number.MAX_VALUE) {
          line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
          character = uinteger.MAX_VALUE;
        }
        return { line, character };
      }
      Position10.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
      }
      Position10.is = is;
    })(Position || (Position = {}));
    (function(Range11) {
      function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
          return { start: Position.create(one, two), end: Position.create(three, four) };
        } else if (Position.is(one) && Position.is(two)) {
          return { start: one, end: two };
        } else {
          throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
        }
      }
      Range11.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
      }
      Range11.is = is;
    })(Range || (Range = {}));
    (function(Location3) {
      function create(uri, range) {
        return { uri, range };
      }
      Location3.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
      }
      Location3.is = is;
    })(Location || (Location = {}));
    (function(LocationLink3) {
      function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
      }
      LocationLink3.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
      }
      LocationLink3.is = is;
    })(LocationLink || (LocationLink = {}));
    (function(Color2) {
      function create(red, green, blue2, alpha) {
        return {
          red,
          green,
          blue: blue2,
          alpha
        };
      }
      Color2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
      }
      Color2.is = is;
    })(Color || (Color = {}));
    (function(ColorInformation3) {
      function create(range, color) {
        return {
          range,
          color
        };
      }
      ColorInformation3.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
      }
      ColorInformation3.is = is;
    })(ColorInformation || (ColorInformation = {}));
    (function(ColorPresentation3) {
      function create(label, textEdit, additionalTextEdits) {
        return {
          label,
          textEdit,
          additionalTextEdits
        };
      }
      ColorPresentation3.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
      }
      ColorPresentation3.is = is;
    })(ColorPresentation || (ColorPresentation = {}));
    (function(FoldingRangeKind3) {
      FoldingRangeKind3.Comment = "comment";
      FoldingRangeKind3.Imports = "imports";
      FoldingRangeKind3.Region = "region";
    })(FoldingRangeKind || (FoldingRangeKind = {}));
    (function(FoldingRange3) {
      function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
        const result = {
          startLine,
          endLine
        };
        if (Is.defined(startCharacter)) {
          result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
          result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
          result.kind = kind;
        }
        if (Is.defined(collapsedText)) {
          result.collapsedText = collapsedText;
        }
        return result;
      }
      FoldingRange3.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
      }
      FoldingRange3.is = is;
    })(FoldingRange || (FoldingRange = {}));
    (function(DiagnosticRelatedInformation2) {
      function create(location, message) {
        return {
          location,
          message
        };
      }
      DiagnosticRelatedInformation2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
      }
      DiagnosticRelatedInformation2.is = is;
    })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
    (function(DiagnosticSeverity2) {
      DiagnosticSeverity2.Error = 1;
      DiagnosticSeverity2.Warning = 2;
      DiagnosticSeverity2.Information = 3;
      DiagnosticSeverity2.Hint = 4;
    })(DiagnosticSeverity || (DiagnosticSeverity = {}));
    (function(DiagnosticTag2) {
      DiagnosticTag2.Unnecessary = 1;
      DiagnosticTag2.Deprecated = 2;
    })(DiagnosticTag || (DiagnosticTag = {}));
    (function(CodeDescription2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.href);
      }
      CodeDescription2.is = is;
    })(CodeDescription || (CodeDescription = {}));
    (function(Diagnostic8) {
      function create(range, message, severity, code, source, relatedInformation) {
        let result = { range, message };
        if (Is.defined(severity)) {
          result.severity = severity;
        }
        if (Is.defined(code)) {
          result.code = code;
        }
        if (Is.defined(source)) {
          result.source = source;
        }
        if (Is.defined(relatedInformation)) {
          result.relatedInformation = relatedInformation;
        }
        return result;
      }
      Diagnostic8.create = create;
      function is(value) {
        var _a2;
        let candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a2 = candidate.codeDescription) === null || _a2 === void 0 ? void 0 : _a2.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
      }
      Diagnostic8.is = is;
    })(Diagnostic || (Diagnostic = {}));
    (function(Command3) {
      function create(title, command, ...args) {
        let result = { title, command };
        if (Is.defined(args) && args.length > 0) {
          result.arguments = args;
        }
        return result;
      }
      Command3.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
      }
      Command3.is = is;
    })(Command || (Command = {}));
    (function(TextEdit9) {
      function replace(range, newText) {
        return { range, newText };
      }
      TextEdit9.replace = replace;
      function insert(position, newText) {
        return { range: { start: position, end: position }, newText };
      }
      TextEdit9.insert = insert;
      function del(range) {
        return { range, newText: "" };
      }
      TextEdit9.del = del;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
      }
      TextEdit9.is = is;
    })(TextEdit || (TextEdit = {}));
    (function(ChangeAnnotation5) {
      function create(label, needsConfirmation, description) {
        const result = { label };
        if (needsConfirmation !== void 0) {
          result.needsConfirmation = needsConfirmation;
        }
        if (description !== void 0) {
          result.description = description;
        }
        return result;
      }
      ChangeAnnotation5.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      ChangeAnnotation5.is = is;
    })(ChangeAnnotation || (ChangeAnnotation = {}));
    (function(ChangeAnnotationIdentifier2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate);
      }
      ChangeAnnotationIdentifier2.is = is;
    })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
    (function(AnnotatedTextEdit2) {
      function replace(range, newText, annotation) {
        return { range, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.replace = replace;
      function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.insert = insert;
      function del(range, annotation) {
        return { range, newText: "", annotationId: annotation };
      }
      AnnotatedTextEdit2.del = del;
      function is(value) {
        const candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      AnnotatedTextEdit2.is = is;
    })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
    (function(TextDocumentEdit2) {
      function create(textDocument, edits) {
        return { textDocument, edits };
      }
      TextDocumentEdit2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
      }
      TextDocumentEdit2.is = is;
    })(TextDocumentEdit || (TextDocumentEdit = {}));
    (function(CreateFile2) {
      function create(uri, options2, annotation) {
        let result = {
          kind: "create",
          uri
        };
        if (options2 !== void 0 && (options2.overwrite !== void 0 || options2.ignoreIfExists !== void 0)) {
          result.options = options2;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      CreateFile2.create = create;
      function is(value) {
        let candidate = value;
        return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      CreateFile2.is = is;
    })(CreateFile || (CreateFile = {}));
    (function(RenameFile2) {
      function create(oldUri, newUri, options2, annotation) {
        let result = {
          kind: "rename",
          oldUri,
          newUri
        };
        if (options2 !== void 0 && (options2.overwrite !== void 0 || options2.ignoreIfExists !== void 0)) {
          result.options = options2;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      RenameFile2.create = create;
      function is(value) {
        let candidate = value;
        return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      RenameFile2.is = is;
    })(RenameFile || (RenameFile = {}));
    (function(DeleteFile2) {
      function create(uri, options2, annotation) {
        let result = {
          kind: "delete",
          uri
        };
        if (options2 !== void 0 && (options2.recursive !== void 0 || options2.ignoreIfNotExists !== void 0)) {
          result.options = options2;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      DeleteFile2.create = create;
      function is(value) {
        let candidate = value;
        return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      DeleteFile2.is = is;
    })(DeleteFile || (DeleteFile = {}));
    (function(WorkspaceEdit7) {
      function is(value) {
        let candidate = value;
        return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every((change) => {
          if (Is.string(change.kind)) {
            return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
          } else {
            return TextDocumentEdit.is(change);
          }
        }));
      }
      WorkspaceEdit7.is = is;
    })(WorkspaceEdit || (WorkspaceEdit = {}));
    TextEditChangeImpl = class {
      constructor(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
      }
      insert(position, newText, annotation) {
        let edit2;
        let id2;
        if (annotation === void 0) {
          edit2 = TextEdit.insert(position, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id2 = annotation;
          edit2 = AnnotatedTextEdit.insert(position, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id2 = this.changeAnnotations.manage(annotation);
          edit2 = AnnotatedTextEdit.insert(position, newText, id2);
        }
        this.edits.push(edit2);
        if (id2 !== void 0) {
          return id2;
        }
      }
      replace(range, newText, annotation) {
        let edit2;
        let id2;
        if (annotation === void 0) {
          edit2 = TextEdit.replace(range, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id2 = annotation;
          edit2 = AnnotatedTextEdit.replace(range, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id2 = this.changeAnnotations.manage(annotation);
          edit2 = AnnotatedTextEdit.replace(range, newText, id2);
        }
        this.edits.push(edit2);
        if (id2 !== void 0) {
          return id2;
        }
      }
      delete(range, annotation) {
        let edit2;
        let id2;
        if (annotation === void 0) {
          edit2 = TextEdit.del(range);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id2 = annotation;
          edit2 = AnnotatedTextEdit.del(range, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id2 = this.changeAnnotations.manage(annotation);
          edit2 = AnnotatedTextEdit.del(range, id2);
        }
        this.edits.push(edit2);
        if (id2 !== void 0) {
          return id2;
        }
      }
      add(edit2) {
        this.edits.push(edit2);
      }
      all() {
        return this.edits;
      }
      clear() {
        this.edits.splice(0, this.edits.length);
      }
      assertChangeAnnotations(value) {
        if (value === void 0) {
          throw new Error(`Text edit change is not configured to manage change annotations.`);
        }
      }
    };
    ChangeAnnotations = class {
      constructor(annotations) {
        this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
      }
      all() {
        return this._annotations;
      }
      get size() {
        return this._size;
      }
      manage(idOrAnnotation, annotation) {
        let id2;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
          id2 = idOrAnnotation;
        } else {
          id2 = this.nextId();
          annotation = idOrAnnotation;
        }
        if (this._annotations[id2] !== void 0) {
          throw new Error(`Id ${id2} is already in use.`);
        }
        if (annotation === void 0) {
          throw new Error(`No annotation provided for id ${id2}`);
        }
        this._annotations[id2] = annotation;
        this._size++;
        return id2;
      }
      nextId() {
        this._counter++;
        return this._counter.toString();
      }
    };
    WorkspaceChange = class {
      constructor(workspaceEdit) {
        this._textEditChanges = /* @__PURE__ */ Object.create(null);
        if (workspaceEdit !== void 0) {
          this._workspaceEdit = workspaceEdit;
          if (workspaceEdit.documentChanges) {
            this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
            workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            workspaceEdit.documentChanges.forEach((change) => {
              if (TextDocumentEdit.is(change)) {
                const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);
                this._textEditChanges[change.textDocument.uri] = textEditChange;
              }
            });
          } else if (workspaceEdit.changes) {
            Object.keys(workspaceEdit.changes).forEach((key) => {
              const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
              this._textEditChanges[key] = textEditChange;
            });
          }
        } else {
          this._workspaceEdit = {};
        }
      }
      /**
       * Returns the underlying {@link WorkspaceEdit} literal
       * use to be returned from a workspace edit operation like rename.
       */
      get edit() {
        this.initDocumentChanges();
        if (this._changeAnnotations !== void 0) {
          if (this._changeAnnotations.size === 0) {
            this._workspaceEdit.changeAnnotations = void 0;
          } else {
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          }
        }
        return this._workspaceEdit;
      }
      getTextEditChange(key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          const textDocument = { uri: key.uri, version: key.version };
          let result = this._textEditChanges[textDocument.uri];
          if (!result) {
            const edits = [];
            const textDocumentEdit = {
              textDocument,
              edits
            };
            this._workspaceEdit.documentChanges.push(textDocumentEdit);
            result = new TextEditChangeImpl(edits, this._changeAnnotations);
            this._textEditChanges[textDocument.uri] = result;
          }
          return result;
        } else {
          this.initChanges();
          if (this._workspaceEdit.changes === void 0) {
            throw new Error("Workspace edit is not configured for normal text edit changes.");
          }
          let result = this._textEditChanges[key];
          if (!result) {
            let edits = [];
            this._workspaceEdit.changes[key] = edits;
            result = new TextEditChangeImpl(edits);
            this._textEditChanges[key] = result;
          }
          return result;
        }
      }
      initDocumentChanges() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._changeAnnotations = new ChangeAnnotations();
          this._workspaceEdit.documentChanges = [];
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      }
      initChanges() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
        }
      }
      createFile(uri, optionsOrAnnotation, options2) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options2 = optionsOrAnnotation;
        }
        let operation;
        let id2;
        if (annotation === void 0) {
          operation = CreateFile.create(uri, options2);
        } else {
          id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = CreateFile.create(uri, options2, id2);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id2 !== void 0) {
          return id2;
        }
      }
      renameFile(oldUri, newUri, optionsOrAnnotation, options2) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options2 = optionsOrAnnotation;
        }
        let operation;
        let id2;
        if (annotation === void 0) {
          operation = RenameFile.create(oldUri, newUri, options2);
        } else {
          id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = RenameFile.create(oldUri, newUri, options2, id2);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id2 !== void 0) {
          return id2;
        }
      }
      deleteFile(uri, optionsOrAnnotation, options2) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options2 = optionsOrAnnotation;
        }
        let operation;
        let id2;
        if (annotation === void 0) {
          operation = DeleteFile.create(uri, options2);
        } else {
          id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = DeleteFile.create(uri, options2, id2);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id2 !== void 0) {
          return id2;
        }
      }
    };
    (function(TextDocumentIdentifier3) {
      function create(uri) {
        return { uri };
      }
      TextDocumentIdentifier3.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
      }
      TextDocumentIdentifier3.is = is;
    })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
    (function(VersionedTextDocumentIdentifier2) {
      function create(uri, version2) {
        return { uri, version: version2 };
      }
      VersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
      }
      VersionedTextDocumentIdentifier2.is = is;
    })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
    (function(OptionalVersionedTextDocumentIdentifier2) {
      function create(uri, version2) {
        return { uri, version: version2 };
      }
      OptionalVersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
      }
      OptionalVersionedTextDocumentIdentifier2.is = is;
    })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
    (function(TextDocumentItem2) {
      function create(uri, languageId, version2, text) {
        return { uri, languageId, version: version2, text };
      }
      TextDocumentItem2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
      }
      TextDocumentItem2.is = is;
    })(TextDocumentItem || (TextDocumentItem = {}));
    (function(MarkupKind2) {
      MarkupKind2.PlainText = "plaintext";
      MarkupKind2.Markdown = "markdown";
      function is(value) {
        const candidate = value;
        return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
      }
      MarkupKind2.is = is;
    })(MarkupKind || (MarkupKind = {}));
    (function(MarkupContent2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
      }
      MarkupContent2.is = is;
    })(MarkupContent || (MarkupContent = {}));
    (function(CompletionItemKind2) {
      CompletionItemKind2.Text = 1;
      CompletionItemKind2.Method = 2;
      CompletionItemKind2.Function = 3;
      CompletionItemKind2.Constructor = 4;
      CompletionItemKind2.Field = 5;
      CompletionItemKind2.Variable = 6;
      CompletionItemKind2.Class = 7;
      CompletionItemKind2.Interface = 8;
      CompletionItemKind2.Module = 9;
      CompletionItemKind2.Property = 10;
      CompletionItemKind2.Unit = 11;
      CompletionItemKind2.Value = 12;
      CompletionItemKind2.Enum = 13;
      CompletionItemKind2.Keyword = 14;
      CompletionItemKind2.Snippet = 15;
      CompletionItemKind2.Color = 16;
      CompletionItemKind2.File = 17;
      CompletionItemKind2.Reference = 18;
      CompletionItemKind2.Folder = 19;
      CompletionItemKind2.EnumMember = 20;
      CompletionItemKind2.Constant = 21;
      CompletionItemKind2.Struct = 22;
      CompletionItemKind2.Event = 23;
      CompletionItemKind2.Operator = 24;
      CompletionItemKind2.TypeParameter = 25;
    })(CompletionItemKind || (CompletionItemKind = {}));
    (function(InsertTextFormat2) {
      InsertTextFormat2.PlainText = 1;
      InsertTextFormat2.Snippet = 2;
    })(InsertTextFormat || (InsertTextFormat = {}));
    (function(CompletionItemTag2) {
      CompletionItemTag2.Deprecated = 1;
    })(CompletionItemTag || (CompletionItemTag = {}));
    (function(InsertReplaceEdit2) {
      function create(newText, insert, replace) {
        return { newText, insert, replace };
      }
      InsertReplaceEdit2.create = create;
      function is(value) {
        const candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
      }
      InsertReplaceEdit2.is = is;
    })(InsertReplaceEdit || (InsertReplaceEdit = {}));
    (function(InsertTextMode3) {
      InsertTextMode3.asIs = 1;
      InsertTextMode3.adjustIndentation = 2;
    })(InsertTextMode || (InsertTextMode = {}));
    (function(CompletionItemLabelDetails3) {
      function is(value) {
        const candidate = value;
        return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      CompletionItemLabelDetails3.is = is;
    })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
    (function(CompletionItem6) {
      function create(label) {
        return { label };
      }
      CompletionItem6.create = create;
    })(CompletionItem || (CompletionItem = {}));
    (function(CompletionList4) {
      function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
      }
      CompletionList4.create = create;
    })(CompletionList || (CompletionList = {}));
    (function(MarkedString2) {
      function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
      }
      MarkedString2.fromPlainText = fromPlainText;
      function is(value) {
        const candidate = value;
        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
      }
      MarkedString2.is = is;
    })(MarkedString || (MarkedString = {}));
    (function(Hover4) {
      function is(value) {
        let candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
      }
      Hover4.is = is;
    })(Hover || (Hover = {}));
    (function(ParameterInformation2) {
      function create(label, documentation) {
        return documentation ? { label, documentation } : { label };
      }
      ParameterInformation2.create = create;
    })(ParameterInformation || (ParameterInformation = {}));
    (function(SignatureInformation2) {
      function create(label, documentation, ...parameters) {
        let result = { label };
        if (Is.defined(documentation)) {
          result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
          result.parameters = parameters;
        } else {
          result.parameters = [];
        }
        return result;
      }
      SignatureInformation2.create = create;
    })(SignatureInformation || (SignatureInformation = {}));
    (function(DocumentHighlightKind2) {
      DocumentHighlightKind2.Text = 1;
      DocumentHighlightKind2.Read = 2;
      DocumentHighlightKind2.Write = 3;
    })(DocumentHighlightKind || (DocumentHighlightKind = {}));
    (function(DocumentHighlight4) {
      function create(range, kind) {
        let result = { range };
        if (Is.number(kind)) {
          result.kind = kind;
        }
        return result;
      }
      DocumentHighlight4.create = create;
    })(DocumentHighlight || (DocumentHighlight = {}));
    (function(SymbolKind5) {
      SymbolKind5.File = 1;
      SymbolKind5.Module = 2;
      SymbolKind5.Namespace = 3;
      SymbolKind5.Package = 4;
      SymbolKind5.Class = 5;
      SymbolKind5.Method = 6;
      SymbolKind5.Property = 7;
      SymbolKind5.Field = 8;
      SymbolKind5.Constructor = 9;
      SymbolKind5.Enum = 10;
      SymbolKind5.Interface = 11;
      SymbolKind5.Function = 12;
      SymbolKind5.Variable = 13;
      SymbolKind5.Constant = 14;
      SymbolKind5.String = 15;
      SymbolKind5.Number = 16;
      SymbolKind5.Boolean = 17;
      SymbolKind5.Array = 18;
      SymbolKind5.Object = 19;
      SymbolKind5.Key = 20;
      SymbolKind5.Null = 21;
      SymbolKind5.EnumMember = 22;
      SymbolKind5.Struct = 23;
      SymbolKind5.Event = 24;
      SymbolKind5.Operator = 25;
      SymbolKind5.TypeParameter = 26;
    })(SymbolKind || (SymbolKind = {}));
    (function(SymbolTag2) {
      SymbolTag2.Deprecated = 1;
    })(SymbolTag || (SymbolTag = {}));
    (function(SymbolInformation5) {
      function create(name2, kind, range, uri, containerName) {
        let result = {
          name: name2,
          kind,
          location: { uri, range }
        };
        if (containerName) {
          result.containerName = containerName;
        }
        return result;
      }
      SymbolInformation5.create = create;
    })(SymbolInformation || (SymbolInformation = {}));
    (function(WorkspaceSymbol6) {
      function create(name2, kind, uri, range) {
        return range !== void 0 ? { name: name2, kind, location: { uri, range } } : { name: name2, kind, location: { uri } };
      }
      WorkspaceSymbol6.create = create;
    })(WorkspaceSymbol || (WorkspaceSymbol = {}));
    (function(DocumentSymbol7) {
      function create(name2, detail, kind, range, selectionRange, children) {
        let result = {
          name: name2,
          detail,
          kind,
          range,
          selectionRange
        };
        if (children !== void 0) {
          result.children = children;
        }
        return result;
      }
      DocumentSymbol7.create = create;
      function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
      }
      DocumentSymbol7.is = is;
    })(DocumentSymbol || (DocumentSymbol = {}));
    (function(CodeActionKind6) {
      CodeActionKind6.Empty = "";
      CodeActionKind6.QuickFix = "quickfix";
      CodeActionKind6.Refactor = "refactor";
      CodeActionKind6.RefactorExtract = "refactor.extract";
      CodeActionKind6.RefactorInline = "refactor.inline";
      CodeActionKind6.RefactorRewrite = "refactor.rewrite";
      CodeActionKind6.Source = "source";
      CodeActionKind6.SourceOrganizeImports = "source.organizeImports";
      CodeActionKind6.SourceFixAll = "source.fixAll";
    })(CodeActionKind || (CodeActionKind = {}));
    (function(CodeActionTriggerKind2) {
      CodeActionTriggerKind2.Invoked = 1;
      CodeActionTriggerKind2.Automatic = 2;
    })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
    (function(CodeActionContext5) {
      function create(diagnostics, only, triggerKind) {
        let result = { diagnostics };
        if (only !== void 0 && only !== null) {
          result.only = only;
        }
        if (triggerKind !== void 0 && triggerKind !== null) {
          result.triggerKind = triggerKind;
        }
        return result;
      }
      CodeActionContext5.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
      }
      CodeActionContext5.is = is;
    })(CodeActionContext || (CodeActionContext = {}));
    (function(CodeAction7) {
      function create(title, kindOrCommandOrEdit, kind) {
        let result = { title };
        let checkKind = true;
        if (typeof kindOrCommandOrEdit === "string") {
          checkKind = false;
          result.kind = kindOrCommandOrEdit;
        } else if (Command.is(kindOrCommandOrEdit)) {
          result.command = kindOrCommandOrEdit;
        } else {
          result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      CodeAction7.create = create;
      function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
      }
      CodeAction7.is = is;
    })(CodeAction || (CodeAction = {}));
    (function(CodeLens3) {
      function create(range, data) {
        let result = { range };
        if (Is.defined(data)) {
          result.data = data;
        }
        return result;
      }
      CodeLens3.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
      }
      CodeLens3.is = is;
    })(CodeLens || (CodeLens = {}));
    (function(FormattingOptions6) {
      function create(tabSize, insertSpaces) {
        return { tabSize, insertSpaces };
      }
      FormattingOptions6.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
      }
      FormattingOptions6.is = is;
    })(FormattingOptions || (FormattingOptions = {}));
    (function(DocumentLink3) {
      function create(range, target, data) {
        return { range, target, data };
      }
      DocumentLink3.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
      }
      DocumentLink3.is = is;
    })(DocumentLink || (DocumentLink = {}));
    (function(SelectionRange5) {
      function create(range, parent) {
        return { range, parent };
      }
      SelectionRange5.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange5.is(candidate.parent));
      }
      SelectionRange5.is = is;
    })(SelectionRange || (SelectionRange = {}));
    (function(SemanticTokenTypes2) {
      SemanticTokenTypes2["namespace"] = "namespace";
      SemanticTokenTypes2["type"] = "type";
      SemanticTokenTypes2["class"] = "class";
      SemanticTokenTypes2["enum"] = "enum";
      SemanticTokenTypes2["interface"] = "interface";
      SemanticTokenTypes2["struct"] = "struct";
      SemanticTokenTypes2["typeParameter"] = "typeParameter";
      SemanticTokenTypes2["parameter"] = "parameter";
      SemanticTokenTypes2["variable"] = "variable";
      SemanticTokenTypes2["property"] = "property";
      SemanticTokenTypes2["enumMember"] = "enumMember";
      SemanticTokenTypes2["event"] = "event";
      SemanticTokenTypes2["function"] = "function";
      SemanticTokenTypes2["method"] = "method";
      SemanticTokenTypes2["macro"] = "macro";
      SemanticTokenTypes2["keyword"] = "keyword";
      SemanticTokenTypes2["modifier"] = "modifier";
      SemanticTokenTypes2["comment"] = "comment";
      SemanticTokenTypes2["string"] = "string";
      SemanticTokenTypes2["number"] = "number";
      SemanticTokenTypes2["regexp"] = "regexp";
      SemanticTokenTypes2["operator"] = "operator";
      SemanticTokenTypes2["decorator"] = "decorator";
    })(SemanticTokenTypes || (SemanticTokenTypes = {}));
    (function(SemanticTokenModifiers2) {
      SemanticTokenModifiers2["declaration"] = "declaration";
      SemanticTokenModifiers2["definition"] = "definition";
      SemanticTokenModifiers2["readonly"] = "readonly";
      SemanticTokenModifiers2["static"] = "static";
      SemanticTokenModifiers2["deprecated"] = "deprecated";
      SemanticTokenModifiers2["abstract"] = "abstract";
      SemanticTokenModifiers2["async"] = "async";
      SemanticTokenModifiers2["modification"] = "modification";
      SemanticTokenModifiers2["documentation"] = "documentation";
      SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
    })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
    (function(SemanticTokens6) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
      }
      SemanticTokens6.is = is;
    })(SemanticTokens || (SemanticTokens = {}));
    (function(InlineValueText2) {
      function create(range, text) {
        return { range, text };
      }
      InlineValueText2.create = create;
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
      }
      InlineValueText2.is = is;
    })(InlineValueText || (InlineValueText = {}));
    (function(InlineValueVariableLookup2) {
      function create(range, variableName, caseSensitiveLookup) {
        return { range, variableName, caseSensitiveLookup };
      }
      InlineValueVariableLookup2.create = create;
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
      }
      InlineValueVariableLookup2.is = is;
    })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
    (function(InlineValueEvaluatableExpression2) {
      function create(range, expression) {
        return { range, expression };
      }
      InlineValueEvaluatableExpression2.create = create;
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
      }
      InlineValueEvaluatableExpression2.is = is;
    })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
    (function(InlineValueContext3) {
      function create(frameId, stoppedLocation) {
        return { frameId, stoppedLocation };
      }
      InlineValueContext3.create = create;
      function is(value) {
        const candidate = value;
        return Is.defined(candidate) && Range.is(value.stoppedLocation);
      }
      InlineValueContext3.is = is;
    })(InlineValueContext || (InlineValueContext = {}));
    (function(InlayHintKind2) {
      InlayHintKind2.Type = 1;
      InlayHintKind2.Parameter = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      InlayHintKind2.is = is;
    })(InlayHintKind || (InlayHintKind = {}));
    (function(InlayHintLabelPart2) {
      function create(value) {
        return { value };
      }
      InlayHintLabelPart2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
      }
      InlayHintLabelPart2.is = is;
    })(InlayHintLabelPart || (InlayHintLabelPart = {}));
    (function(InlayHint3) {
      function create(position, label, kind) {
        const result = { position, label };
        if (kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      InlayHint3.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
      }
      InlayHint3.is = is;
    })(InlayHint || (InlayHint = {}));
    (function(StringValue2) {
      function createSnippet(value) {
        return { kind: "snippet", value };
      }
      StringValue2.createSnippet = createSnippet;
    })(StringValue || (StringValue = {}));
    (function(InlineCompletionItem2) {
      function create(insertText, filterText, range, command) {
        return { insertText, filterText, range, command };
      }
      InlineCompletionItem2.create = create;
    })(InlineCompletionItem || (InlineCompletionItem = {}));
    (function(InlineCompletionList2) {
      function create(items) {
        return { items };
      }
      InlineCompletionList2.create = create;
    })(InlineCompletionList || (InlineCompletionList = {}));
    (function(InlineCompletionTriggerKind2) {
      InlineCompletionTriggerKind2.Invoked = 0;
      InlineCompletionTriggerKind2.Automatic = 1;
    })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
    (function(SelectedCompletionInfo2) {
      function create(range, text) {
        return { range, text };
      }
      SelectedCompletionInfo2.create = create;
    })(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
    (function(InlineCompletionContext2) {
      function create(triggerKind, selectedCompletionInfo) {
        return { triggerKind, selectedCompletionInfo };
      }
      InlineCompletionContext2.create = create;
    })(InlineCompletionContext || (InlineCompletionContext = {}));
    (function(WorkspaceFolder2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
      }
      WorkspaceFolder2.is = is;
    })(WorkspaceFolder || (WorkspaceFolder = {}));
    (function(TextDocument3) {
      function create(uri, languageId, version2, content) {
        return new FullTextDocument(uri, languageId, version2, content);
      }
      TextDocument3.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
      }
      TextDocument3.is = is;
      function applyEdits3(document2, edits) {
        let text = document2.getText();
        let sortedEdits = mergeSort3(edits, (a, b) => {
          let diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        let lastModifiedOffset = text.length;
        for (let i = sortedEdits.length - 1; i >= 0; i--) {
          let e = sortedEdits[i];
          let startOffset = document2.offsetAt(e.range.start);
          let endOffset = document2.offsetAt(e.range.end);
          if (endOffset <= lastModifiedOffset) {
            text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
          } else {
            throw new Error("Overlapping edit");
          }
          lastModifiedOffset = startOffset;
        }
        return text;
      }
      TextDocument3.applyEdits = applyEdits3;
      function mergeSort3(data, compare2) {
        if (data.length <= 1) {
          return data;
        }
        const p = data.length / 2 | 0;
        const left = data.slice(0, p);
        const right = data.slice(p);
        mergeSort3(left, compare2);
        mergeSort3(right, compare2);
        let leftIdx = 0;
        let rightIdx = 0;
        let i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          let ret = compare2(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
    })(TextDocument || (TextDocument = {}));
    FullTextDocument = class {
      constructor(uri, languageId, version2, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version2;
        this._content = content;
        this._lineOffsets = void 0;
      }
      get uri() {
        return this._uri;
      }
      get languageId() {
        return this._languageId;
      }
      get version() {
        return this._version;
      }
      getText(range) {
        if (range) {
          let start = this.offsetAt(range.start);
          let end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      }
      update(event, version2) {
        this._content = event.text;
        this._version = version2;
        this._lineOffsets = void 0;
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          let lineOffsets = [];
          let text = this._content;
          let isLineStart = true;
          for (let i = 0; i < text.length; i++) {
            if (isLineStart) {
              lineOffsets.push(i);
              isLineStart = false;
            }
            let ch = text.charAt(i);
            isLineStart = ch === "\r" || ch === "\n";
            if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
              i++;
            }
          }
          if (isLineStart && text.length > 0) {
            lineOffsets.push(text.length);
          }
          this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
          return Position.create(0, offset);
        }
        while (low < high) {
          let mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        let line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
      }
      offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      }
      get lineCount() {
        return this.getLineOffsets().length;
      }
    };
    (function(Is2) {
      const toString = Object.prototype.toString;
      function defined(value) {
        return typeof value !== "undefined";
      }
      Is2.defined = defined;
      function undefined2(value) {
        return typeof value === "undefined";
      }
      Is2.undefined = undefined2;
      function boolean2(value) {
        return value === true || value === false;
      }
      Is2.boolean = boolean2;
      function string2(value) {
        return toString.call(value) === "[object String]";
      }
      Is2.string = string2;
      function number2(value) {
        return toString.call(value) === "[object Number]";
      }
      Is2.number = number2;
      function numberRange(value, min, max) {
        return toString.call(value) === "[object Number]" && min <= value && value <= max;
      }
      Is2.numberRange = numberRange;
      function integer2(value) {
        return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
      }
      Is2.integer = integer2;
      function uinteger3(value) {
        return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
      }
      Is2.uinteger = uinteger3;
      function func2(value) {
        return toString.call(value) === "[object Function]";
      }
      Is2.func = func2;
      function objectLiteral2(value) {
        return value !== null && typeof value === "object";
      }
      Is2.objectLiteral = objectLiteral2;
      function typedArray2(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      Is2.typedArray = typedArray2;
    })(Is || (Is = {}));
  }
});

// src/util/is.ts
function isUrl(url) {
  try {
    new import_url.URL(url);
    return true;
  } catch (e) {
    return false;
  }
}
function isHover(value) {
  let candidate = value;
  return !!candidate && objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || typedArray(candidate.contents, MarkedString.is)) && (value.range == null || Range.is(value.range));
}
function isEditRange(value) {
  if (!value) return false;
  if (Range.is(value)) return true;
  return Range.is(value.insert) && Range.is(value.replace);
}
function isCommand(obj) {
  if (!obj || !string(obj.title) || !string(obj.command) || obj.command.length == 0) return false;
  return true;
}
function isMarkdown(content) {
  if (content != null && content["kind"] == "markdown") {
    return true;
  }
  return false;
}
function isCompletionItem(obj) {
  return obj && typeof obj.label === "string";
}
function isCompletionList(obj) {
  return !Array.isArray(obj) && Array.isArray(obj.items);
}
function boolean(value) {
  return typeof value === "boolean";
}
function string(value) {
  return typeof value === "string";
}
function number(value) {
  return typeof value === "number";
}
function func(value) {
  return typeof value == "function";
}
function objectLiteral(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
}
function emptyObject(obj) {
  if (!objectLiteral(obj)) {
    return false;
  }
  for (let key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
function typedArray(value, check) {
  return Array.isArray(value) && value.every(check);
}
var import_url, hasOwnProperty;
var init_is = __esm({
  "src/util/is.ts"() {
    "use strict";
    import_url = require("url");
    init_main();
    hasOwnProperty = Object.prototype.hasOwnProperty;
  }
});

// src/util/object.ts
function isEmpty(obj) {
  if (!obj) return true;
  if (Array.isArray(obj)) return obj.length == 0;
  return Object.keys(obj).length == 0;
}
function toObject(obj) {
  return obj == null ? {} : obj;
}
function omitUndefined(obj) {
  const result = {};
  Object.entries(obj).forEach(([key, val]) => {
    if (val !== void 0) result[key] = val;
  });
  return result;
}
function deepIterate(obj, fn) {
  Object.entries(obj).forEach(([key, val]) => {
    fn(obj, key);
    if (Array.isArray(val)) {
      val.forEach((node) => {
        if (objectLiteral(node)) {
          deepIterate(node, fn);
        }
      });
    } else if (objectLiteral(val)) {
      deepIterate(val, fn);
    }
  });
  return obj;
}
function deepClone(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof RegExp) {
    return obj;
  }
  const result = Array.isArray(obj) ? [] : {};
  Object.keys(obj).forEach((key) => {
    if (obj[key] && typeof obj[key] === "object") {
      result[key] = deepClone(obj[key]);
    } else {
      result[key] = obj[key];
    }
  });
  return result;
}
function hasOwnProperty2(obj, key) {
  return _hasOwnProperty.call(obj, key);
}
function deepFreeze(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  const stack = [obj];
  while (stack.length > 0) {
    let obj2 = stack.shift();
    Object.freeze(obj2);
    for (const key of Object.keys(obj2)) {
      let prop = obj2[key];
      if (typeof prop === "object" && !Object.isFrozen(prop)) {
        stack.push(prop);
      }
    }
  }
  return obj;
}
function mixin(destination, source, overwrite = true) {
  if (!objectLiteral(destination)) {
    return source;
  }
  if (objectLiteral(source)) {
    Object.keys(source).forEach((key) => {
      if (key in destination) {
        if (overwrite) {
          if (objectLiteral(destination[key]) && objectLiteral(source[key])) {
            mixin(destination[key], source[key], overwrite);
          } else {
            destination[key] = source[key];
          }
        }
      } else {
        destination[key] = source[key];
      }
    });
  }
  return destination;
}
function equals(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  let i;
  let key;
  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }
    for (i = 0; i < one.length; i++) {
      if (!equals(one[i], other[i])) {
        return false;
      }
    }
  } else {
    const oneKeys = [];
    for (key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    const otherKeys = [];
    for (key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals(oneKeys, otherKeys)) {
      return false;
    }
    for (i = 0; i < oneKeys.length; i++) {
      if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }
  return true;
}
var _hasOwnProperty;
var init_object = __esm({
  "src/util/object.ts"() {
    "use strict";
    init_is();
    _hasOwnProperty = Object.prototype.hasOwnProperty;
  }
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean2(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean2;
    function string2(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string2;
    function number2(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number2;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func2(value) {
      return typeof value === "function";
    }
    exports2.func = func2;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string2(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is();
    var ErrorCodes2;
    (function(ErrorCodes3) {
      ErrorCodes3.ParseError = -32700;
      ErrorCodes3.InvalidRequest = -32600;
      ErrorCodes3.MethodNotFound = -32601;
      ErrorCodes3.InvalidParams = -32602;
      ErrorCodes3.InternalError = -32603;
      ErrorCodes3.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes3.serverErrorStart = -32099;
      ErrorCodes3.MessageWriteError = -32099;
      ErrorCodes3.MessageReadError = -32098;
      ErrorCodes3.PendingResponseRejected = -32097;
      ErrorCodes3.ConnectionInactive = -32096;
      ErrorCodes3.ServerNotInitialized = -32002;
      ErrorCodes3.UnknownErrorCode = -32001;
      ErrorCodes3.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes3.serverErrorEnd = -32e3;
    })(ErrorCodes2 || (exports2.ErrorCodes = ErrorCodes2 = {}));
    var ResponseError2 = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes2.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError2;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType02 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType02;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType2;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType22 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType22;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType2;
    var NotificationType02 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType02;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType22 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType22;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (exports2.Message = Message = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    var _a2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch2;
    (function(Touch3) {
      Touch3.None = 0;
      Touch3.First = 1;
      Touch3.AsOld = Touch3.First;
      Touch3.Last = 2;
      Touch3.AsNew = Touch3.Last;
    })(Touch2 || (exports2.Touch = Touch2 = {}));
    var LinkedMap2 = class {
      constructor() {
        this[_a2] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch2.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch2.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch2.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch2.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch2.None:
              this.addItemLast(item);
              break;
            case Touch2.First:
              this.addItemFirst(item);
              break;
            case Touch2.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a2 = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch2.First && touch !== Touch2.Last) {
          return;
        }
        if (touch === Touch2.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch2.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap2;
    var LRUCache2 = class extends LinkedMap2 {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch2.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch2.None);
      }
      set(key, value) {
        super.set(key, value, Touch2.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache2;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable36;
    (function(Disposable37) {
      function create(func2) {
        return {
          dispose: func2
        };
      }
      Disposable37.create = create;
    })(Disposable36 || (exports2.Disposable = Disposable36 = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL2() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL3) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL3.install = install;
    })(RAL2 || (RAL2 = {}));
    exports2.default = RAL2;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event45;
    (function(Event46) {
      const _disposable = { dispose() {
      } };
      Event46.None = function() {
        return _disposable;
      };
    })(Event45 || (exports2.Event = Event45 = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter2 = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter2;
    Emitter2._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var events_1 = require_events();
    var CancellationToken24;
    (function(CancellationToken25) {
      CancellationToken25.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken25.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken25.None || candidate === CancellationToken25.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken25.is = is;
    })(CancellationToken24 || (exports2.CancellationToken = CancellationToken24 = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource2 = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken24.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken24.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource2;
  }
});

// node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request2) {
        if (request2.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request2.id, buffer);
        request2.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id2) {
        const buffer = this.buffers.get(id2);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id2) {
        this.buffers.delete(id2);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports2.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request2) {
        const buffer = request2.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports2.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader2;
    (function(MessageReader3) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.listen) && Is2.func(candidate.dispose) && Is2.func(candidate.onError) && Is2.func(candidate.onClose) && Is2.func(candidate.onPartialMessage);
      }
      MessageReader3.is = is;
    })(MessageReader2 || (exports2.MessageReader = MessageReader2 = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options2) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options2 === void 0 || typeof options2 === "string") {
          charset = options2 ?? "utf-8";
        } else {
          charset = options2.charset ?? "utf-8";
          if (options2.contentDecoder !== void 0) {
            contentDecoder = options2.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options2.contentDecoders !== void 0) {
            for (const decoder of options2.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options2.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options2.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options2.contentTypeDecoders !== void 0) {
            for (const decoder of options2.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options2) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options2);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout2) {
        this._partialMessageTimeout = timeout2;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes2 = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes2, this.options);
              this.callback(message);
            }).catch((error) => {
              this.fireError(error);
            });
          }
        } catch (error) {
          this.fireError(error);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout2) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout2 });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter2;
    (function(MessageWriter3) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.dispose) && Is2.func(candidate.onClose) && Is2.func(candidate.onError) && Is2.func(candidate.write);
      }
      MessageWriter3.is = is;
    })(MessageWriter2 || (exports2.MessageWriter = MessageWriter2 = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options2) {
        if (options2 === void 0 || typeof options2 === "string") {
          return { charset: options2 ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options2.charset ?? "utf-8", contentEncoder: options2.contentEncoder, contentTypeEncoder: options2.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options2) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options2);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding2 = "utf-8") {
        this._encoding = encoding2;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
          const chunk = this._chunks[chunkIndex];
          offset = 0;
          column: while (offset < chunk.length) {
            const value = chunk[offset];
            switch (value) {
              case CR:
                switch (state) {
                  case 0:
                    state = 1;
                    break;
                  case 2:
                    state = 3;
                    break;
                  default:
                    state = 0;
                }
                break;
              case LF:
                switch (state) {
                  case 1:
                    state = 2;
                    break;
                  case 3:
                    state = 4;
                    offset++;
                    break row;
                  default:
                    state = 0;
                }
                break;
              default:
                state = 0;
            }
            offset++;
          }
          chunkBytesRead += chunk.byteLength;
          chunkIndex++;
        }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.RequestCancellationReceiverStrategy = exports2.IdCancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports2.ProgressToken = ProgressToken = {}));
    var ProgressNotification2;
    (function(ProgressNotification3) {
      ProgressNotification3.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification2 || (ProgressNotification2 = {}));
    var ProgressType2 = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType2;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is2.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace2;
    (function(Trace3) {
      Trace3[Trace3["Off"] = 0] = "Off";
      Trace3[Trace3["Messages"] = 1] = "Messages";
      Trace3[Trace3["Compact"] = 2] = "Compact";
      Trace3[Trace3["Verbose"] = 3] = "Verbose";
    })(Trace2 || (exports2.Trace = Trace2 = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports2.TraceValues = TraceValues = {}));
    (function(Trace3) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return Trace3.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace3.Off;
          case "messages":
            return Trace3.Messages;
          case "compact":
            return Trace3.Compact;
          case "verbose":
            return Trace3.Verbose;
          default:
            return Trace3.Off;
        }
      }
      Trace3.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace3.Off:
            return "off";
          case Trace3.Messages:
            return "messages";
          case Trace3.Compact:
            return "compact";
          case Trace3.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace3.toString = toString;
    })(Trace2 || (exports2.Trace = Trace2 = {}));
    var TraceFormat2;
    (function(TraceFormat3) {
      TraceFormat3["Text"] = "text";
      TraceFormat3["JSON"] = "json";
    })(TraceFormat2 || (exports2.TraceFormat = TraceFormat2 = {}));
    (function(TraceFormat3) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return TraceFormat3.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat3.JSON;
        } else {
          return TraceFormat3.Text;
        }
      }
      TraceFormat3.fromString = fromString;
    })(TraceFormat2 || (exports2.TraceFormat = TraceFormat2 = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports2.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports2.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports2.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports2.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is2.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is2.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports2.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is2.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is2.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports2.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id2) {
          return conn.sendNotification(CancelNotification.type, { id: id2 });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.sendCancellation) && Is2.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports2.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports2.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports2.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports2.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options2) {
      const logger60 = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version2 = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace2.Off;
      let traceFormat = TraceFormat2.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options2 && options2.cancellationStrategy ? options2.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id2) {
        if (id2 === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id2.toString();
      }
      function createResponseQueueKey(id2) {
        if (id2 === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id2.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options2?.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options2?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger60.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version2,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger60.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version2,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger60.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version2,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger60.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is2.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is2.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger60.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger60.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger60.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger60.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger60.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification2.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger60.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger60.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger60.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger60.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger60.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger60.error("Received empty message.");
          return;
        }
        logger60.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is2.string(responseMessage.id) || Is2.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace2.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace2.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if ((trace === Trace2.Verbose || trace === Trace2.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose || trace === Trace2.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose || trace === Trace2.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if ((trace === Trace2.Verbose || trace === Trace2.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace2.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose || trace === Trace2.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace2.Verbose || trace === Trace2.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace2.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is2.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version2,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch((error) => {
            logger60.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is2.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is2.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection.sendNotification(ProgressNotification2.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is2.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id2 = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection, id2);
              if (p === void 0) {
                logger60.log(`Received no promise from cancellation strategy when cancelling id ${id2}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger60.log(`Sending cancellation messages for id ${id2} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version2,
            id: id2,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve, reject) => {
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id2);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id2);
              disposable?.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter.write(requestMessage);
              responsePromises.set(id2, responsePromise);
            } catch (error) {
              logger60.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              throw error;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is2.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat2.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is2.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat2.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace2.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection.sendNotification(SetTraceNotification.type, { value: Trace2.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is2.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is2.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace2.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace2.Verbose || trace === Trace2.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification2.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.AbstractMessageBuffer = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports2, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports2, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports2, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports2, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require("util");
    var api_1 = require_api2();
    var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding2 = "utf-8") {
        super(encoding2);
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding2) {
        return Buffer.from(value, encoding2);
      }
      toString(value, encoding2) {
        if (value instanceof Buffer) {
          return value.toString(encoding2);
        } else {
          return new util_1.TextDecoder(encoding2).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return api_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding2) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding2, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding2) => new MessageBuffer(encoding2)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options2) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options2.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options2) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options2.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options2.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.PortMessageWriter = exports2.PortMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var path2 = require("path");
    var os2 = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var api_1 = require_api2();
    __exportStar(require_api2(), exports2);
    var IPCMessageReader2 = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader2;
    var IPCMessageWriter2 = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter2;
    var PortMessageReader = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this.onData = new api_1.Emitter();
        port.on("close", () => this.fireClose);
        port.on("error", (error) => this.fireError(error));
        port.on("message", (message) => {
          this.onData.fire(message);
        });
      }
      listen(callback) {
        return this.onData.event(callback);
      }
    };
    exports2.PortMessageReader = PortMessageReader;
    var PortMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on("close", () => this.fireClose());
        port.on("error", (error) => this.fireError(error));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.PortMessageWriter = PortMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding2 = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding2);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options2) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options2);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader2 = class extends api_1.ReadableStreamMessageReader {
      constructor(readable, encoding2) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding2);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader2;
    var StreamMessageWriter2 = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options2) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options2);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter2;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName2() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path2.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path2.join(os2.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName2;
    function createClientPipeTransport2(pipeName, encoding2 = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding2),
            new SocketMessageWriter(socket, encoding2)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport2;
    function createServerPipeTransport(pipeName, encoding2 = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding2),
        new SocketMessageWriter(socket, encoding2)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport2(port, encoding2 = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding2),
            new SocketMessageWriter(socket, encoding2)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport2;
    function createServerSocketTransport(port, encoding2 = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding2),
        new SocketMessageWriter(socket, encoding2)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger60, options2) {
      if (!logger60) {
        logger60 = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader2(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter2(output) : output;
      if (api_1.ConnectionStrategy.is(options2)) {
        options2 = { connectionStrategy: options2 };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger60, options2);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-types/lib/umd/main.js"(exports2, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0) module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = exports3.EOL = exports3.WorkspaceFolder = exports3.InlineCompletionContext = exports3.SelectedCompletionInfo = exports3.InlineCompletionTriggerKind = exports3.InlineCompletionList = exports3.InlineCompletionItem = exports3.StringValue = exports3.InlayHint = exports3.InlayHintLabelPart = exports3.InlayHintKind = exports3.InlineValueContext = exports3.InlineValueEvaluatableExpression = exports3.InlineValueVariableLookup = exports3.InlineValueText = exports3.SemanticTokens = exports3.SemanticTokenModifiers = exports3.SemanticTokenTypes = exports3.SelectionRange = exports3.DocumentLink = exports3.FormattingOptions = exports3.CodeLens = exports3.CodeAction = exports3.CodeActionContext = exports3.CodeActionTriggerKind = exports3.CodeActionKind = exports3.DocumentSymbol = exports3.WorkspaceSymbol = exports3.SymbolInformation = exports3.SymbolTag = exports3.SymbolKind = exports3.DocumentHighlight = exports3.DocumentHighlightKind = exports3.SignatureInformation = exports3.ParameterInformation = exports3.Hover = exports3.MarkedString = exports3.CompletionList = exports3.CompletionItem = exports3.CompletionItemLabelDetails = exports3.InsertTextMode = exports3.InsertReplaceEdit = exports3.CompletionItemTag = exports3.InsertTextFormat = exports3.CompletionItemKind = exports3.MarkupContent = exports3.MarkupKind = exports3.TextDocumentItem = exports3.OptionalVersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier = exports3.TextDocumentIdentifier = exports3.WorkspaceChange = exports3.WorkspaceEdit = exports3.DeleteFile = exports3.RenameFile = exports3.CreateFile = exports3.TextDocumentEdit = exports3.AnnotatedTextEdit = exports3.ChangeAnnotationIdentifier = exports3.ChangeAnnotation = exports3.TextEdit = exports3.Command = exports3.Diagnostic = exports3.CodeDescription = exports3.DiagnosticTag = exports3.DiagnosticSeverity = exports3.DiagnosticRelatedInformation = exports3.FoldingRange = exports3.FoldingRangeKind = exports3.ColorPresentation = exports3.ColorInformation = exports3.Color = exports3.LocationLink = exports3.Location = exports3.Range = exports3.Position = exports3.uinteger = exports3.integer = exports3.URI = exports3.DocumentUri = void 0;
      var DocumentUri2;
      (function(DocumentUri3) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri3.is = is;
      })(DocumentUri2 || (exports3.DocumentUri = DocumentUri2 = {}));
      var URI3;
      (function(URI4) {
        function is(value) {
          return typeof value === "string";
        }
        URI4.is = is;
      })(URI3 || (exports3.URI = URI3 = {}));
      var integer2;
      (function(integer3) {
        integer3.MIN_VALUE = -2147483648;
        integer3.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer3.MIN_VALUE <= value && value <= integer3.MAX_VALUE;
        }
        integer3.is = is;
      })(integer2 || (exports3.integer = integer2 = {}));
      var uinteger3;
      (function(uinteger4) {
        uinteger4.MIN_VALUE = 0;
        uinteger4.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger4.MIN_VALUE <= value && value <= uinteger4.MAX_VALUE;
        }
        uinteger4.is = is;
      })(uinteger3 || (exports3.uinteger = uinteger3 = {}));
      var Position10;
      (function(Position11) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger3.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger3.MAX_VALUE;
          }
          return { line, character };
        }
        Position11.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Is2.uinteger(candidate.line) && Is2.uinteger(candidate.character);
        }
        Position11.is = is;
      })(Position10 || (exports3.Position = Position10 = {}));
      var Range11;
      (function(Range12) {
        function create(one, two, three, four) {
          if (Is2.uinteger(one) && Is2.uinteger(two) && Is2.uinteger(three) && Is2.uinteger(four)) {
            return { start: Position10.create(one, two), end: Position10.create(three, four) };
          } else if (Position10.is(one) && Position10.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
          }
        }
        Range12.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Position10.is(candidate.start) && Position10.is(candidate.end);
        }
        Range12.is = is;
      })(Range11 || (exports3.Range = Range11 = {}));
      var Location3;
      (function(Location4) {
        function create(uri, range) {
          return { uri, range };
        }
        Location4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Range11.is(candidate.range) && (Is2.string(candidate.uri) || Is2.undefined(candidate.uri));
        }
        Location4.is = is;
      })(Location3 || (exports3.Location = Location3 = {}));
      var LocationLink3;
      (function(LocationLink4) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Range11.is(candidate.targetRange) && Is2.string(candidate.targetUri) && Range11.is(candidate.targetSelectionRange) && (Range11.is(candidate.originSelectionRange) || Is2.undefined(candidate.originSelectionRange));
        }
        LocationLink4.is = is;
      })(LocationLink3 || (exports3.LocationLink = LocationLink3 = {}));
      var Color2;
      (function(Color3) {
        function create(red, green, blue2, alpha) {
          return {
            red,
            green,
            blue: blue2,
            alpha
          };
        }
        Color3.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Is2.numberRange(candidate.red, 0, 1) && Is2.numberRange(candidate.green, 0, 1) && Is2.numberRange(candidate.blue, 0, 1) && Is2.numberRange(candidate.alpha, 0, 1);
        }
        Color3.is = is;
      })(Color2 || (exports3.Color = Color2 = {}));
      var ColorInformation3;
      (function(ColorInformation4) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Range11.is(candidate.range) && Color2.is(candidate.color);
        }
        ColorInformation4.is = is;
      })(ColorInformation3 || (exports3.ColorInformation = ColorInformation3 = {}));
      var ColorPresentation3;
      (function(ColorPresentation4) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Is2.string(candidate.label) && (Is2.undefined(candidate.textEdit) || TextEdit9.is(candidate)) && (Is2.undefined(candidate.additionalTextEdits) || Is2.typedArray(candidate.additionalTextEdits, TextEdit9.is));
        }
        ColorPresentation4.is = is;
      })(ColorPresentation3 || (exports3.ColorPresentation = ColorPresentation3 = {}));
      var FoldingRangeKind3;
      (function(FoldingRangeKind4) {
        FoldingRangeKind4.Comment = "comment";
        FoldingRangeKind4.Imports = "imports";
        FoldingRangeKind4.Region = "region";
      })(FoldingRangeKind3 || (exports3.FoldingRangeKind = FoldingRangeKind3 = {}));
      var FoldingRange3;
      (function(FoldingRange4) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          var result = {
            startLine,
            endLine
          };
          if (Is2.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is2.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is2.defined(kind)) {
            result.kind = kind;
          }
          if (Is2.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Is2.uinteger(candidate.startLine) && Is2.uinteger(candidate.startLine) && (Is2.undefined(candidate.startCharacter) || Is2.uinteger(candidate.startCharacter)) && (Is2.undefined(candidate.endCharacter) || Is2.uinteger(candidate.endCharacter)) && (Is2.undefined(candidate.kind) || Is2.string(candidate.kind));
        }
        FoldingRange4.is = is;
      })(FoldingRange3 || (exports3.FoldingRange = FoldingRange3 = {}));
      var DiagnosticRelatedInformation2;
      (function(DiagnosticRelatedInformation3) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation3.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Location3.is(candidate.location) && Is2.string(candidate.message);
        }
        DiagnosticRelatedInformation3.is = is;
      })(DiagnosticRelatedInformation2 || (exports3.DiagnosticRelatedInformation = DiagnosticRelatedInformation2 = {}));
      var DiagnosticSeverity2;
      (function(DiagnosticSeverity3) {
        DiagnosticSeverity3.Error = 1;
        DiagnosticSeverity3.Warning = 2;
        DiagnosticSeverity3.Information = 3;
        DiagnosticSeverity3.Hint = 4;
      })(DiagnosticSeverity2 || (exports3.DiagnosticSeverity = DiagnosticSeverity2 = {}));
      var DiagnosticTag2;
      (function(DiagnosticTag3) {
        DiagnosticTag3.Unnecessary = 1;
        DiagnosticTag3.Deprecated = 2;
      })(DiagnosticTag2 || (exports3.DiagnosticTag = DiagnosticTag2 = {}));
      var CodeDescription2;
      (function(CodeDescription3) {
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Is2.string(candidate.href);
        }
        CodeDescription3.is = is;
      })(CodeDescription2 || (exports3.CodeDescription = CodeDescription2 = {}));
      var Diagnostic8;
      (function(Diagnostic9) {
        function create(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is2.defined(severity)) {
            result.severity = severity;
          }
          if (Is2.defined(code)) {
            result.code = code;
          }
          if (Is2.defined(source)) {
            result.source = source;
          }
          if (Is2.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic9.create = create;
        function is(value) {
          var _a2;
          var candidate = value;
          return Is2.defined(candidate) && Range11.is(candidate.range) && Is2.string(candidate.message) && (Is2.number(candidate.severity) || Is2.undefined(candidate.severity)) && (Is2.integer(candidate.code) || Is2.string(candidate.code) || Is2.undefined(candidate.code)) && (Is2.undefined(candidate.codeDescription) || Is2.string((_a2 = candidate.codeDescription) === null || _a2 === void 0 ? void 0 : _a2.href)) && (Is2.string(candidate.source) || Is2.undefined(candidate.source)) && (Is2.undefined(candidate.relatedInformation) || Is2.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation2.is));
        }
        Diagnostic9.is = is;
      })(Diagnostic8 || (exports3.Diagnostic = Diagnostic8 = {}));
      var Command3;
      (function(Command4) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is2.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.title) && Is2.string(candidate.command);
        }
        Command4.is = is;
      })(Command3 || (exports3.Command = Command3 = {}));
      var TextEdit9;
      (function(TextEdit10) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit10.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit10.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit10.del = del;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Is2.string(candidate.newText) && Range11.is(candidate.range);
        }
        TextEdit10.is = is;
      })(TextEdit9 || (exports3.TextEdit = TextEdit9 = {}));
      var ChangeAnnotation5;
      (function(ChangeAnnotation6) {
        function create(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation6.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Is2.string(candidate.label) && (Is2.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is2.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation6.is = is;
      })(ChangeAnnotation5 || (exports3.ChangeAnnotation = ChangeAnnotation5 = {}));
      var ChangeAnnotationIdentifier2;
      (function(ChangeAnnotationIdentifier3) {
        function is(value) {
          var candidate = value;
          return Is2.string(candidate);
        }
        ChangeAnnotationIdentifier3.is = is;
      })(ChangeAnnotationIdentifier2 || (exports3.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier2 = {}));
      var AnnotatedTextEdit2;
      (function(AnnotatedTextEdit3) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit3.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit3.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit3.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit9.is(candidate) && (ChangeAnnotation5.is(candidate.annotationId) || ChangeAnnotationIdentifier2.is(candidate.annotationId));
        }
        AnnotatedTextEdit3.is = is;
      })(AnnotatedTextEdit2 || (exports3.AnnotatedTextEdit = AnnotatedTextEdit2 = {}));
      var TextDocumentEdit2;
      (function(TextDocumentEdit3) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit3.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && OptionalVersionedTextDocumentIdentifier2.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit3.is = is;
      })(TextDocumentEdit2 || (exports3.TextDocumentEdit = TextDocumentEdit2 = {}));
      var CreateFile2;
      (function(CreateFile3) {
        function create(uri, options2, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options2 !== void 0 && (options2.overwrite !== void 0 || options2.ignoreIfExists !== void 0)) {
            result.options = options2;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile3.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is2.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is2.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is2.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier2.is(candidate.annotationId));
        }
        CreateFile3.is = is;
      })(CreateFile2 || (exports3.CreateFile = CreateFile2 = {}));
      var RenameFile2;
      (function(RenameFile3) {
        function create(oldUri, newUri, options2, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options2 !== void 0 && (options2.overwrite !== void 0 || options2.ignoreIfExists !== void 0)) {
            result.options = options2;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile3.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is2.string(candidate.oldUri) && Is2.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is2.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is2.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier2.is(candidate.annotationId));
        }
        RenameFile3.is = is;
      })(RenameFile2 || (exports3.RenameFile = RenameFile2 = {}));
      var DeleteFile2;
      (function(DeleteFile3) {
        function create(uri, options2, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options2 !== void 0 && (options2.recursive !== void 0 || options2.ignoreIfNotExists !== void 0)) {
            result.options = options2;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile3.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is2.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is2.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is2.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier2.is(candidate.annotationId));
        }
        DeleteFile3.is = is;
      })(DeleteFile2 || (exports3.DeleteFile = DeleteFile2 = {}));
      var WorkspaceEdit7;
      (function(WorkspaceEdit8) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is2.string(change.kind)) {
              return CreateFile2.is(change) || RenameFile2.is(change) || DeleteFile2.is(change);
            } else {
              return TextDocumentEdit2.is(change);
            }
          }));
        }
        WorkspaceEdit8.is = is;
      })(WorkspaceEdit7 || (exports3.WorkspaceEdit = WorkspaceEdit7 = {}));
      var TextEditChangeImpl2 = (
        /** @class */
        function() {
          function TextEditChangeImpl3(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl3.prototype.insert = function(position, newText, annotation) {
            var edit2;
            var id2;
            if (annotation === void 0) {
              edit2 = TextEdit9.insert(position, newText);
            } else if (ChangeAnnotationIdentifier2.is(annotation)) {
              id2 = annotation;
              edit2 = AnnotatedTextEdit2.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id2 = this.changeAnnotations.manage(annotation);
              edit2 = AnnotatedTextEdit2.insert(position, newText, id2);
            }
            this.edits.push(edit2);
            if (id2 !== void 0) {
              return id2;
            }
          };
          TextEditChangeImpl3.prototype.replace = function(range, newText, annotation) {
            var edit2;
            var id2;
            if (annotation === void 0) {
              edit2 = TextEdit9.replace(range, newText);
            } else if (ChangeAnnotationIdentifier2.is(annotation)) {
              id2 = annotation;
              edit2 = AnnotatedTextEdit2.replace(range, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id2 = this.changeAnnotations.manage(annotation);
              edit2 = AnnotatedTextEdit2.replace(range, newText, id2);
            }
            this.edits.push(edit2);
            if (id2 !== void 0) {
              return id2;
            }
          };
          TextEditChangeImpl3.prototype.delete = function(range, annotation) {
            var edit2;
            var id2;
            if (annotation === void 0) {
              edit2 = TextEdit9.del(range);
            } else if (ChangeAnnotationIdentifier2.is(annotation)) {
              id2 = annotation;
              edit2 = AnnotatedTextEdit2.del(range, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id2 = this.changeAnnotations.manage(annotation);
              edit2 = AnnotatedTextEdit2.del(range, id2);
            }
            this.edits.push(edit2);
            if (id2 !== void 0) {
              return id2;
            }
          };
          TextEditChangeImpl3.prototype.add = function(edit2) {
            this.edits.push(edit2);
          };
          TextEditChangeImpl3.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl3.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl3.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl3;
        }()
      );
      var ChangeAnnotations2 = (
        /** @class */
        function() {
          function ChangeAnnotations3(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations3.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations3.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations3.prototype.manage = function(idOrAnnotation, annotation) {
            var id2;
            if (ChangeAnnotationIdentifier2.is(idOrAnnotation)) {
              id2 = idOrAnnotation;
            } else {
              id2 = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id2] !== void 0) {
              throw new Error("Id ".concat(id2, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id2));
            }
            this._annotations[id2] = annotation;
            this._size++;
            return id2;
          };
          ChangeAnnotations3.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations3;
        }()
      );
      var WorkspaceChange2 = (
        /** @class */
        function() {
          function WorkspaceChange3(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations2(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit2.is(change)) {
                    var textEditChange = new TextEditChangeImpl2(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl2(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange3.prototype, "edit", {
            /**
             * Returns the underlying {@link WorkspaceEdit} literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange3.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier2.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl2(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl2(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange3.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations2();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange3.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange3.prototype.createFile = function(uri, optionsOrAnnotation, options2) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation5.is(optionsOrAnnotation) || ChangeAnnotationIdentifier2.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options2 = optionsOrAnnotation;
            }
            var operation;
            var id2;
            if (annotation === void 0) {
              operation = CreateFile2.create(uri, options2);
            } else {
              id2 = ChangeAnnotationIdentifier2.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile2.create(uri, options2, id2);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id2 !== void 0) {
              return id2;
            }
          };
          WorkspaceChange3.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options2) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation5.is(optionsOrAnnotation) || ChangeAnnotationIdentifier2.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options2 = optionsOrAnnotation;
            }
            var operation;
            var id2;
            if (annotation === void 0) {
              operation = RenameFile2.create(oldUri, newUri, options2);
            } else {
              id2 = ChangeAnnotationIdentifier2.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile2.create(oldUri, newUri, options2, id2);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id2 !== void 0) {
              return id2;
            }
          };
          WorkspaceChange3.prototype.deleteFile = function(uri, optionsOrAnnotation, options2) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation5.is(optionsOrAnnotation) || ChangeAnnotationIdentifier2.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options2 = optionsOrAnnotation;
            }
            var operation;
            var id2;
            if (annotation === void 0) {
              operation = DeleteFile2.create(uri, options2);
            } else {
              id2 = ChangeAnnotationIdentifier2.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile2.create(uri, options2, id2);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id2 !== void 0) {
              return id2;
            }
          };
          return WorkspaceChange3;
        }()
      );
      exports3.WorkspaceChange = WorkspaceChange2;
      var TextDocumentIdentifier3;
      (function(TextDocumentIdentifier4) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri);
        }
        TextDocumentIdentifier4.is = is;
      })(TextDocumentIdentifier3 || (exports3.TextDocumentIdentifier = TextDocumentIdentifier3 = {}));
      var VersionedTextDocumentIdentifier2;
      (function(VersionedTextDocumentIdentifier3) {
        function create(uri, version2) {
          return { uri, version: version2 };
        }
        VersionedTextDocumentIdentifier3.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && Is2.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier3.is = is;
      })(VersionedTextDocumentIdentifier2 || (exports3.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier2 = {}));
      var OptionalVersionedTextDocumentIdentifier2;
      (function(OptionalVersionedTextDocumentIdentifier3) {
        function create(uri, version2) {
          return { uri, version: version2 };
        }
        OptionalVersionedTextDocumentIdentifier3.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && (candidate.version === null || Is2.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier3.is = is;
      })(OptionalVersionedTextDocumentIdentifier2 || (exports3.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier2 = {}));
      var TextDocumentItem2;
      (function(TextDocumentItem3) {
        function create(uri, languageId, version2, text) {
          return { uri, languageId, version: version2, text };
        }
        TextDocumentItem3.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && Is2.string(candidate.languageId) && Is2.integer(candidate.version) && Is2.string(candidate.text);
        }
        TextDocumentItem3.is = is;
      })(TextDocumentItem2 || (exports3.TextDocumentItem = TextDocumentItem2 = {}));
      var MarkupKind2;
      (function(MarkupKind3) {
        MarkupKind3.PlainText = "plaintext";
        MarkupKind3.Markdown = "markdown";
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind3.PlainText || candidate === MarkupKind3.Markdown;
        }
        MarkupKind3.is = is;
      })(MarkupKind2 || (exports3.MarkupKind = MarkupKind2 = {}));
      var MarkupContent2;
      (function(MarkupContent3) {
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(value) && MarkupKind2.is(candidate.kind) && Is2.string(candidate.value);
        }
        MarkupContent3.is = is;
      })(MarkupContent2 || (exports3.MarkupContent = MarkupContent2 = {}));
      var CompletionItemKind2;
      (function(CompletionItemKind3) {
        CompletionItemKind3.Text = 1;
        CompletionItemKind3.Method = 2;
        CompletionItemKind3.Function = 3;
        CompletionItemKind3.Constructor = 4;
        CompletionItemKind3.Field = 5;
        CompletionItemKind3.Variable = 6;
        CompletionItemKind3.Class = 7;
        CompletionItemKind3.Interface = 8;
        CompletionItemKind3.Module = 9;
        CompletionItemKind3.Property = 10;
        CompletionItemKind3.Unit = 11;
        CompletionItemKind3.Value = 12;
        CompletionItemKind3.Enum = 13;
        CompletionItemKind3.Keyword = 14;
        CompletionItemKind3.Snippet = 15;
        CompletionItemKind3.Color = 16;
        CompletionItemKind3.File = 17;
        CompletionItemKind3.Reference = 18;
        CompletionItemKind3.Folder = 19;
        CompletionItemKind3.EnumMember = 20;
        CompletionItemKind3.Constant = 21;
        CompletionItemKind3.Struct = 22;
        CompletionItemKind3.Event = 23;
        CompletionItemKind3.Operator = 24;
        CompletionItemKind3.TypeParameter = 25;
      })(CompletionItemKind2 || (exports3.CompletionItemKind = CompletionItemKind2 = {}));
      var InsertTextFormat2;
      (function(InsertTextFormat3) {
        InsertTextFormat3.PlainText = 1;
        InsertTextFormat3.Snippet = 2;
      })(InsertTextFormat2 || (exports3.InsertTextFormat = InsertTextFormat2 = {}));
      var CompletionItemTag2;
      (function(CompletionItemTag3) {
        CompletionItemTag3.Deprecated = 1;
      })(CompletionItemTag2 || (exports3.CompletionItemTag = CompletionItemTag2 = {}));
      var InsertReplaceEdit2;
      (function(InsertReplaceEdit3) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit3.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is2.string(candidate.newText) && Range11.is(candidate.insert) && Range11.is(candidate.replace);
        }
        InsertReplaceEdit3.is = is;
      })(InsertReplaceEdit2 || (exports3.InsertReplaceEdit = InsertReplaceEdit2 = {}));
      var InsertTextMode3;
      (function(InsertTextMode4) {
        InsertTextMode4.asIs = 1;
        InsertTextMode4.adjustIndentation = 2;
      })(InsertTextMode3 || (exports3.InsertTextMode = InsertTextMode3 = {}));
      var CompletionItemLabelDetails3;
      (function(CompletionItemLabelDetails4) {
        function is(value) {
          var candidate = value;
          return candidate && (Is2.string(candidate.detail) || candidate.detail === void 0) && (Is2.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails4.is = is;
      })(CompletionItemLabelDetails3 || (exports3.CompletionItemLabelDetails = CompletionItemLabelDetails3 = {}));
      var CompletionItem6;
      (function(CompletionItem7) {
        function create(label) {
          return { label };
        }
        CompletionItem7.create = create;
      })(CompletionItem6 || (exports3.CompletionItem = CompletionItem6 = {}));
      var CompletionList4;
      (function(CompletionList5) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList5.create = create;
      })(CompletionList4 || (exports3.CompletionList = CompletionList4 = {}));
      var MarkedString2;
      (function(MarkedString3) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString3.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is2.string(candidate) || Is2.objectLiteral(candidate) && Is2.string(candidate.language) && Is2.string(candidate.value);
        }
        MarkedString3.is = is;
      })(MarkedString2 || (exports3.MarkedString = MarkedString2 = {}));
      var Hover4;
      (function(Hover5) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is2.objectLiteral(candidate) && (MarkupContent2.is(candidate.contents) || MarkedString2.is(candidate.contents) || Is2.typedArray(candidate.contents, MarkedString2.is)) && (value.range === void 0 || Range11.is(value.range));
        }
        Hover5.is = is;
      })(Hover4 || (exports3.Hover = Hover4 = {}));
      var ParameterInformation2;
      (function(ParameterInformation3) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation3.create = create;
      })(ParameterInformation2 || (exports3.ParameterInformation = ParameterInformation2 = {}));
      var SignatureInformation2;
      (function(SignatureInformation3) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is2.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is2.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation3.create = create;
      })(SignatureInformation2 || (exports3.SignatureInformation = SignatureInformation2 = {}));
      var DocumentHighlightKind2;
      (function(DocumentHighlightKind3) {
        DocumentHighlightKind3.Text = 1;
        DocumentHighlightKind3.Read = 2;
        DocumentHighlightKind3.Write = 3;
      })(DocumentHighlightKind2 || (exports3.DocumentHighlightKind = DocumentHighlightKind2 = {}));
      var DocumentHighlight4;
      (function(DocumentHighlight5) {
        function create(range, kind) {
          var result = { range };
          if (Is2.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight5.create = create;
      })(DocumentHighlight4 || (exports3.DocumentHighlight = DocumentHighlight4 = {}));
      var SymbolKind5;
      (function(SymbolKind6) {
        SymbolKind6.File = 1;
        SymbolKind6.Module = 2;
        SymbolKind6.Namespace = 3;
        SymbolKind6.Package = 4;
        SymbolKind6.Class = 5;
        SymbolKind6.Method = 6;
        SymbolKind6.Property = 7;
        SymbolKind6.Field = 8;
        SymbolKind6.Constructor = 9;
        SymbolKind6.Enum = 10;
        SymbolKind6.Interface = 11;
        SymbolKind6.Function = 12;
        SymbolKind6.Variable = 13;
        SymbolKind6.Constant = 14;
        SymbolKind6.String = 15;
        SymbolKind6.Number = 16;
        SymbolKind6.Boolean = 17;
        SymbolKind6.Array = 18;
        SymbolKind6.Object = 19;
        SymbolKind6.Key = 20;
        SymbolKind6.Null = 21;
        SymbolKind6.EnumMember = 22;
        SymbolKind6.Struct = 23;
        SymbolKind6.Event = 24;
        SymbolKind6.Operator = 25;
        SymbolKind6.TypeParameter = 26;
      })(SymbolKind5 || (exports3.SymbolKind = SymbolKind5 = {}));
      var SymbolTag2;
      (function(SymbolTag3) {
        SymbolTag3.Deprecated = 1;
      })(SymbolTag2 || (exports3.SymbolTag = SymbolTag2 = {}));
      var SymbolInformation5;
      (function(SymbolInformation6) {
        function create(name2, kind, range, uri, containerName) {
          var result = {
            name: name2,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation6.create = create;
      })(SymbolInformation5 || (exports3.SymbolInformation = SymbolInformation5 = {}));
      var WorkspaceSymbol6;
      (function(WorkspaceSymbol7) {
        function create(name2, kind, uri, range) {
          return range !== void 0 ? { name: name2, kind, location: { uri, range } } : { name: name2, kind, location: { uri } };
        }
        WorkspaceSymbol7.create = create;
      })(WorkspaceSymbol6 || (exports3.WorkspaceSymbol = WorkspaceSymbol6 = {}));
      var DocumentSymbol7;
      (function(DocumentSymbol8) {
        function create(name2, detail, kind, range, selectionRange, children) {
          var result = {
            name: name2,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol8.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is2.string(candidate.name) && Is2.number(candidate.kind) && Range11.is(candidate.range) && Range11.is(candidate.selectionRange) && (candidate.detail === void 0 || Is2.string(candidate.detail)) && (candidate.deprecated === void 0 || Is2.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol8.is = is;
      })(DocumentSymbol7 || (exports3.DocumentSymbol = DocumentSymbol7 = {}));
      var CodeActionKind6;
      (function(CodeActionKind7) {
        CodeActionKind7.Empty = "";
        CodeActionKind7.QuickFix = "quickfix";
        CodeActionKind7.Refactor = "refactor";
        CodeActionKind7.RefactorExtract = "refactor.extract";
        CodeActionKind7.RefactorInline = "refactor.inline";
        CodeActionKind7.RefactorRewrite = "refactor.rewrite";
        CodeActionKind7.Source = "source";
        CodeActionKind7.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind7.SourceFixAll = "source.fixAll";
      })(CodeActionKind6 || (exports3.CodeActionKind = CodeActionKind6 = {}));
      var CodeActionTriggerKind2;
      (function(CodeActionTriggerKind3) {
        CodeActionTriggerKind3.Invoked = 1;
        CodeActionTriggerKind3.Automatic = 2;
      })(CodeActionTriggerKind2 || (exports3.CodeActionTriggerKind = CodeActionTriggerKind2 = {}));
      var CodeActionContext5;
      (function(CodeActionContext6) {
        function create(diagnostics, only, triggerKind) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext6.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.typedArray(candidate.diagnostics, Diagnostic8.is) && (candidate.only === void 0 || Is2.typedArray(candidate.only, Is2.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind2.Invoked || candidate.triggerKind === CodeActionTriggerKind2.Automatic);
        }
        CodeActionContext6.is = is;
      })(CodeActionContext5 || (exports3.CodeActionContext = CodeActionContext5 = {}));
      var CodeAction7;
      (function(CodeAction8) {
        function create(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command3.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction8.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is2.string(candidate.title) && (candidate.diagnostics === void 0 || Is2.typedArray(candidate.diagnostics, Diagnostic8.is)) && (candidate.kind === void 0 || Is2.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command3.is(candidate.command)) && (candidate.isPreferred === void 0 || Is2.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit7.is(candidate.edit));
        }
        CodeAction8.is = is;
      })(CodeAction7 || (exports3.CodeAction = CodeAction7 = {}));
      var CodeLens3;
      (function(CodeLens4) {
        function create(range, data) {
          var result = { range };
          if (Is2.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Range11.is(candidate.range) && (Is2.undefined(candidate.command) || Command3.is(candidate.command));
        }
        CodeLens4.is = is;
      })(CodeLens3 || (exports3.CodeLens = CodeLens3 = {}));
      var FormattingOptions6;
      (function(FormattingOptions7) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions7.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.uinteger(candidate.tabSize) && Is2.boolean(candidate.insertSpaces);
        }
        FormattingOptions7.is = is;
      })(FormattingOptions6 || (exports3.FormattingOptions = FormattingOptions6 = {}));
      var DocumentLink3;
      (function(DocumentLink4) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Range11.is(candidate.range) && (Is2.undefined(candidate.target) || Is2.string(candidate.target));
        }
        DocumentLink4.is = is;
      })(DocumentLink3 || (exports3.DocumentLink = DocumentLink3 = {}));
      var SelectionRange5;
      (function(SelectionRange6) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange6.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Range11.is(candidate.range) && (candidate.parent === void 0 || SelectionRange6.is(candidate.parent));
        }
        SelectionRange6.is = is;
      })(SelectionRange5 || (exports3.SelectionRange = SelectionRange5 = {}));
      var SemanticTokenTypes2;
      (function(SemanticTokenTypes3) {
        SemanticTokenTypes3["namespace"] = "namespace";
        SemanticTokenTypes3["type"] = "type";
        SemanticTokenTypes3["class"] = "class";
        SemanticTokenTypes3["enum"] = "enum";
        SemanticTokenTypes3["interface"] = "interface";
        SemanticTokenTypes3["struct"] = "struct";
        SemanticTokenTypes3["typeParameter"] = "typeParameter";
        SemanticTokenTypes3["parameter"] = "parameter";
        SemanticTokenTypes3["variable"] = "variable";
        SemanticTokenTypes3["property"] = "property";
        SemanticTokenTypes3["enumMember"] = "enumMember";
        SemanticTokenTypes3["event"] = "event";
        SemanticTokenTypes3["function"] = "function";
        SemanticTokenTypes3["method"] = "method";
        SemanticTokenTypes3["macro"] = "macro";
        SemanticTokenTypes3["keyword"] = "keyword";
        SemanticTokenTypes3["modifier"] = "modifier";
        SemanticTokenTypes3["comment"] = "comment";
        SemanticTokenTypes3["string"] = "string";
        SemanticTokenTypes3["number"] = "number";
        SemanticTokenTypes3["regexp"] = "regexp";
        SemanticTokenTypes3["operator"] = "operator";
        SemanticTokenTypes3["decorator"] = "decorator";
      })(SemanticTokenTypes2 || (exports3.SemanticTokenTypes = SemanticTokenTypes2 = {}));
      var SemanticTokenModifiers2;
      (function(SemanticTokenModifiers3) {
        SemanticTokenModifiers3["declaration"] = "declaration";
        SemanticTokenModifiers3["definition"] = "definition";
        SemanticTokenModifiers3["readonly"] = "readonly";
        SemanticTokenModifiers3["static"] = "static";
        SemanticTokenModifiers3["deprecated"] = "deprecated";
        SemanticTokenModifiers3["abstract"] = "abstract";
        SemanticTokenModifiers3["async"] = "async";
        SemanticTokenModifiers3["modification"] = "modification";
        SemanticTokenModifiers3["documentation"] = "documentation";
        SemanticTokenModifiers3["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers2 || (exports3.SemanticTokenModifiers = SemanticTokenModifiers2 = {}));
      var SemanticTokens6;
      (function(SemanticTokens7) {
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens7.is = is;
      })(SemanticTokens6 || (exports3.SemanticTokens = SemanticTokens6 = {}));
      var InlineValueText2;
      (function(InlineValueText3) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText3.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range11.is(candidate.range) && Is2.string(candidate.text);
        }
        InlineValueText3.is = is;
      })(InlineValueText2 || (exports3.InlineValueText = InlineValueText2 = {}));
      var InlineValueVariableLookup2;
      (function(InlineValueVariableLookup3) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup3.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range11.is(candidate.range) && Is2.boolean(candidate.caseSensitiveLookup) && (Is2.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup3.is = is;
      })(InlineValueVariableLookup2 || (exports3.InlineValueVariableLookup = InlineValueVariableLookup2 = {}));
      var InlineValueEvaluatableExpression2;
      (function(InlineValueEvaluatableExpression3) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression3.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range11.is(candidate.range) && (Is2.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression3.is = is;
      })(InlineValueEvaluatableExpression2 || (exports3.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression2 = {}));
      var InlineValueContext3;
      (function(InlineValueContext4) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Range11.is(value.stoppedLocation);
        }
        InlineValueContext4.is = is;
      })(InlineValueContext3 || (exports3.InlineValueContext = InlineValueContext3 = {}));
      var InlayHintKind2;
      (function(InlayHintKind3) {
        InlayHintKind3.Type = 1;
        InlayHintKind3.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind3.is = is;
      })(InlayHintKind2 || (exports3.InlayHintKind = InlayHintKind2 = {}));
      var InlayHintLabelPart2;
      (function(InlayHintLabelPart3) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart3.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is2.string(candidate.tooltip) || MarkupContent2.is(candidate.tooltip)) && (candidate.location === void 0 || Location3.is(candidate.location)) && (candidate.command === void 0 || Command3.is(candidate.command));
        }
        InlayHintLabelPart3.is = is;
      })(InlayHintLabelPart2 || (exports3.InlayHintLabelPart = InlayHintLabelPart2 = {}));
      var InlayHint3;
      (function(InlayHint4) {
        function create(position, label, kind) {
          var result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && Position10.is(candidate.position) && (Is2.string(candidate.label) || Is2.typedArray(candidate.label, InlayHintLabelPart2.is)) && (candidate.kind === void 0 || InlayHintKind2.is(candidate.kind)) && candidate.textEdits === void 0 || Is2.typedArray(candidate.textEdits, TextEdit9.is) && (candidate.tooltip === void 0 || Is2.string(candidate.tooltip) || MarkupContent2.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is2.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is2.boolean(candidate.paddingRight));
        }
        InlayHint4.is = is;
      })(InlayHint3 || (exports3.InlayHint = InlayHint3 = {}));
      var StringValue2;
      (function(StringValue3) {
        function createSnippet(value) {
          return { kind: "snippet", value };
        }
        StringValue3.createSnippet = createSnippet;
      })(StringValue2 || (exports3.StringValue = StringValue2 = {}));
      var InlineCompletionItem2;
      (function(InlineCompletionItem3) {
        function create(insertText, filterText, range, command) {
          return { insertText, filterText, range, command };
        }
        InlineCompletionItem3.create = create;
      })(InlineCompletionItem2 || (exports3.InlineCompletionItem = InlineCompletionItem2 = {}));
      var InlineCompletionList2;
      (function(InlineCompletionList3) {
        function create(items) {
          return { items };
        }
        InlineCompletionList3.create = create;
      })(InlineCompletionList2 || (exports3.InlineCompletionList = InlineCompletionList2 = {}));
      var InlineCompletionTriggerKind2;
      (function(InlineCompletionTriggerKind3) {
        InlineCompletionTriggerKind3.Invoked = 0;
        InlineCompletionTriggerKind3.Automatic = 1;
      })(InlineCompletionTriggerKind2 || (exports3.InlineCompletionTriggerKind = InlineCompletionTriggerKind2 = {}));
      var SelectedCompletionInfo2;
      (function(SelectedCompletionInfo3) {
        function create(range, text) {
          return { range, text };
        }
        SelectedCompletionInfo3.create = create;
      })(SelectedCompletionInfo2 || (exports3.SelectedCompletionInfo = SelectedCompletionInfo2 = {}));
      var InlineCompletionContext2;
      (function(InlineCompletionContext3) {
        function create(triggerKind, selectedCompletionInfo) {
          return { triggerKind, selectedCompletionInfo };
        }
        InlineCompletionContext3.create = create;
      })(InlineCompletionContext2 || (exports3.InlineCompletionContext = InlineCompletionContext2 = {}));
      var WorkspaceFolder2;
      (function(WorkspaceFolder3) {
        function is(value) {
          var candidate = value;
          return Is2.objectLiteral(candidate) && URI3.is(candidate.uri) && Is2.string(candidate.name);
        }
        WorkspaceFolder3.is = is;
      })(WorkspaceFolder2 || (exports3.WorkspaceFolder = WorkspaceFolder2 = {}));
      exports3.EOL = ["\n", "\r\n", "\r"];
      var TextDocument3;
      (function(TextDocument4) {
        function create(uri, languageId, version2, content) {
          return new FullTextDocument3(uri, languageId, version2, content);
        }
        TextDocument4.create = create;
        function is(value) {
          var candidate = value;
          return Is2.defined(candidate) && Is2.string(candidate.uri) && (Is2.undefined(candidate.languageId) || Is2.string(candidate.languageId)) && Is2.uinteger(candidate.lineCount) && Is2.func(candidate.getText) && Is2.func(candidate.positionAt) && Is2.func(candidate.offsetAt) ? true : false;
        }
        TextDocument4.is = is;
        function applyEdits3(document2, edits) {
          var text = document2.getText();
          var sortedEdits = mergeSort3(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document2.offsetAt(e.range.start);
            var endOffset = document2.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument4.applyEdits = applyEdits3;
        function mergeSort3(data, compare2) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort3(left, compare2);
          mergeSort3(right, compare2);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare2(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument3 || (exports3.TextDocument = TextDocument3 = {}));
      var FullTextDocument3 = (
        /** @class */
        function() {
          function FullTextDocument4(uri, languageId, version2, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version2;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument4.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument4.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument4.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument4.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument4.prototype.update = function(event, version2) {
            this._content = event.text;
            this._version = version2;
            this._lineOffsets = void 0;
          };
          FullTextDocument4.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text = this._content;
              var isLineStart = true;
              for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument4.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position10.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position10.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument4.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument4.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument4;
        }()
      );
      var Is2;
      (function(Is3) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is3.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is3.undefined = undefined2;
        function boolean2(value) {
          return value === true || value === false;
        }
        Is3.boolean = boolean2;
        function string2(value) {
          return toString.call(value) === "[object String]";
        }
        Is3.string = string2;
        function number2(value) {
          return toString.call(value) === "[object Number]";
        }
        Is3.number = number2;
        function numberRange(value, min, max) {
          return toString.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is3.numberRange = numberRange;
        function integer3(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is3.integer = integer3;
        function uinteger4(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is3.uinteger = uinteger4;
        function func2(value) {
          return toString.call(value) === "[object Function]";
        }
        Is3.func = func2;
        function objectLiteral2(value) {
          return value !== null && typeof value === "object";
        }
        Is3.objectLiteral = objectLiteral2;
        function typedArray2(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is3.typedArray = typedArray2;
      })(Is2 || (Is2 = {}));
    });
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection || (exports2.MessageDirection = MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType02 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType02;
    var ProtocolRequestType2 = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType2;
    var ProtocolNotificationType02 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType02;
    var ProtocolNotificationType2 = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType2;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean2(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean2;
    function string2(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string2;
    function number2(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number2;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func2(value) {
      return typeof value === "function";
    }
    exports2.func = func2;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string2(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray2(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray2;
    function objectLiteral2(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral2;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest2;
    (function(ImplementationRequest3) {
      ImplementationRequest3.method = "textDocument/implementation";
      ImplementationRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest3.type = new messages_1.ProtocolRequestType(ImplementationRequest3.method);
    })(ImplementationRequest2 || (exports2.ImplementationRequest = ImplementationRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest2;
    (function(TypeDefinitionRequest3) {
      TypeDefinitionRequest3.method = "textDocument/typeDefinition";
      TypeDefinitionRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest3.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest3.method);
    })(TypeDefinitionRequest2 || (exports2.TypeDefinitionRequest = TypeDefinitionRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest2;
    (function(WorkspaceFoldersRequest3) {
      WorkspaceFoldersRequest3.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest3.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest3.method);
    })(WorkspaceFoldersRequest2 || (exports2.WorkspaceFoldersRequest = WorkspaceFoldersRequest2 = {}));
    var DidChangeWorkspaceFoldersNotification2;
    (function(DidChangeWorkspaceFoldersNotification3) {
      DidChangeWorkspaceFoldersNotification3.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification3.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification3.method);
    })(DidChangeWorkspaceFoldersNotification2 || (exports2.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest2;
    (function(ConfigurationRequest3) {
      ConfigurationRequest3.method = "workspace/configuration";
      ConfigurationRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest3.type = new messages_1.ProtocolRequestType(ConfigurationRequest3.method);
    })(ConfigurationRequest2 || (exports2.ConfigurationRequest = ConfigurationRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest2;
    (function(DocumentColorRequest3) {
      DocumentColorRequest3.method = "textDocument/documentColor";
      DocumentColorRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest3.type = new messages_1.ProtocolRequestType(DocumentColorRequest3.method);
    })(DocumentColorRequest2 || (exports2.DocumentColorRequest = DocumentColorRequest2 = {}));
    var ColorPresentationRequest2;
    (function(ColorPresentationRequest3) {
      ColorPresentationRequest3.method = "textDocument/colorPresentation";
      ColorPresentationRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest3.type = new messages_1.ProtocolRequestType(ColorPresentationRequest3.method);
    })(ColorPresentationRequest2 || (exports2.ColorPresentationRequest = ColorPresentationRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest2;
    (function(FoldingRangeRequest3) {
      FoldingRangeRequest3.method = "textDocument/foldingRange";
      FoldingRangeRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest3.type = new messages_1.ProtocolRequestType(FoldingRangeRequest3.method);
    })(FoldingRangeRequest2 || (exports2.FoldingRangeRequest = FoldingRangeRequest2 = {}));
    var FoldingRangeRefreshRequest;
    (function(FoldingRangeRefreshRequest2) {
      FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
      FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
    })(FoldingRangeRefreshRequest || (exports2.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest2;
    (function(DeclarationRequest3) {
      DeclarationRequest3.method = "textDocument/declaration";
      DeclarationRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest3.type = new messages_1.ProtocolRequestType(DeclarationRequest3.method);
    })(DeclarationRequest2 || (exports2.DeclarationRequest = DeclarationRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest2;
    (function(SelectionRangeRequest3) {
      SelectionRangeRequest3.method = "textDocument/selectionRange";
      SelectionRangeRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest3.type = new messages_1.ProtocolRequestType(SelectionRangeRequest3.method);
    })(SelectionRangeRequest2 || (exports2.SelectionRangeRequest = SelectionRangeRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress2;
    (function(WorkDoneProgress3) {
      WorkDoneProgress3.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress3.type;
      }
      WorkDoneProgress3.is = is;
    })(WorkDoneProgress2 || (exports2.WorkDoneProgress = WorkDoneProgress2 = {}));
    var WorkDoneProgressCreateRequest2;
    (function(WorkDoneProgressCreateRequest3) {
      WorkDoneProgressCreateRequest3.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest3.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest3.method);
    })(WorkDoneProgressCreateRequest2 || (exports2.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest2 = {}));
    var WorkDoneProgressCancelNotification2;
    (function(WorkDoneProgressCancelNotification3) {
      WorkDoneProgressCancelNotification3.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification3.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification3.method);
    })(WorkDoneProgressCancelNotification2 || (exports2.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest2;
    (function(CallHierarchyPrepareRequest3) {
      CallHierarchyPrepareRequest3.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest3.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest3.method);
    })(CallHierarchyPrepareRequest2 || (exports2.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest2 = {}));
    var CallHierarchyIncomingCallsRequest2;
    (function(CallHierarchyIncomingCallsRequest3) {
      CallHierarchyIncomingCallsRequest3.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest3.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest3.method);
    })(CallHierarchyIncomingCallsRequest2 || (exports2.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest2 = {}));
    var CallHierarchyOutgoingCallsRequest2;
    (function(CallHierarchyOutgoingCallsRequest3) {
      CallHierarchyOutgoingCallsRequest3.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest3.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest3.method);
    })(CallHierarchyOutgoingCallsRequest2 || (exports2.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat2;
    (function(TokenFormat3) {
      TokenFormat3.Relative = "relative";
    })(TokenFormat2 || (exports2.TokenFormat = TokenFormat2 = {}));
    var SemanticTokensRegistrationType2;
    (function(SemanticTokensRegistrationType3) {
      SemanticTokensRegistrationType3.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType3.type = new messages_1.RegistrationType(SemanticTokensRegistrationType3.method);
    })(SemanticTokensRegistrationType2 || (exports2.SemanticTokensRegistrationType = SemanticTokensRegistrationType2 = {}));
    var SemanticTokensRequest2;
    (function(SemanticTokensRequest3) {
      SemanticTokensRequest3.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest3.type = new messages_1.ProtocolRequestType(SemanticTokensRequest3.method);
      SemanticTokensRequest3.registrationMethod = SemanticTokensRegistrationType2.method;
    })(SemanticTokensRequest2 || (exports2.SemanticTokensRequest = SemanticTokensRequest2 = {}));
    var SemanticTokensDeltaRequest2;
    (function(SemanticTokensDeltaRequest3) {
      SemanticTokensDeltaRequest3.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest3.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest3.method);
      SemanticTokensDeltaRequest3.registrationMethod = SemanticTokensRegistrationType2.method;
    })(SemanticTokensDeltaRequest2 || (exports2.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest2 = {}));
    var SemanticTokensRangeRequest2;
    (function(SemanticTokensRangeRequest3) {
      SemanticTokensRangeRequest3.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest3.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest3.method);
      SemanticTokensRangeRequest3.registrationMethod = SemanticTokensRegistrationType2.method;
    })(SemanticTokensRangeRequest2 || (exports2.SemanticTokensRangeRequest = SemanticTokensRangeRequest2 = {}));
    var SemanticTokensRefreshRequest2;
    (function(SemanticTokensRefreshRequest3) {
      SemanticTokensRefreshRequest3.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest3.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest3.method);
    })(SemanticTokensRefreshRequest2 || (exports2.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest2;
    (function(ShowDocumentRequest3) {
      ShowDocumentRequest3.method = "window/showDocument";
      ShowDocumentRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest3.type = new messages_1.ProtocolRequestType(ShowDocumentRequest3.method);
    })(ShowDocumentRequest2 || (exports2.ShowDocumentRequest = ShowDocumentRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest2;
    (function(LinkedEditingRangeRequest3) {
      LinkedEditingRangeRequest3.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest3.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest3.method);
    })(LinkedEditingRangeRequest2 || (exports2.LinkedEditingRangeRequest = LinkedEditingRangeRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind2;
    (function(FileOperationPatternKind3) {
      FileOperationPatternKind3.file = "file";
      FileOperationPatternKind3.folder = "folder";
    })(FileOperationPatternKind2 || (exports2.FileOperationPatternKind = FileOperationPatternKind2 = {}));
    var WillCreateFilesRequest2;
    (function(WillCreateFilesRequest3) {
      WillCreateFilesRequest3.method = "workspace/willCreateFiles";
      WillCreateFilesRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest3.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest3.method);
    })(WillCreateFilesRequest2 || (exports2.WillCreateFilesRequest = WillCreateFilesRequest2 = {}));
    var DidCreateFilesNotification2;
    (function(DidCreateFilesNotification3) {
      DidCreateFilesNotification3.method = "workspace/didCreateFiles";
      DidCreateFilesNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification3.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification3.method);
    })(DidCreateFilesNotification2 || (exports2.DidCreateFilesNotification = DidCreateFilesNotification2 = {}));
    var WillRenameFilesRequest2;
    (function(WillRenameFilesRequest3) {
      WillRenameFilesRequest3.method = "workspace/willRenameFiles";
      WillRenameFilesRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest3.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest3.method);
    })(WillRenameFilesRequest2 || (exports2.WillRenameFilesRequest = WillRenameFilesRequest2 = {}));
    var DidRenameFilesNotification2;
    (function(DidRenameFilesNotification3) {
      DidRenameFilesNotification3.method = "workspace/didRenameFiles";
      DidRenameFilesNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification3.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification3.method);
    })(DidRenameFilesNotification2 || (exports2.DidRenameFilesNotification = DidRenameFilesNotification2 = {}));
    var DidDeleteFilesNotification2;
    (function(DidDeleteFilesNotification3) {
      DidDeleteFilesNotification3.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification3.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification3.method);
    })(DidDeleteFilesNotification2 || (exports2.DidDeleteFilesNotification = DidDeleteFilesNotification2 = {}));
    var WillDeleteFilesRequest2;
    (function(WillDeleteFilesRequest3) {
      WillDeleteFilesRequest3.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest3.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest3.method);
    })(WillDeleteFilesRequest2 || (exports2.WillDeleteFilesRequest = WillDeleteFilesRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel2;
    (function(UniquenessLevel3) {
      UniquenessLevel3.document = "document";
      UniquenessLevel3.project = "project";
      UniquenessLevel3.group = "group";
      UniquenessLevel3.scheme = "scheme";
      UniquenessLevel3.global = "global";
    })(UniquenessLevel2 || (exports2.UniquenessLevel = UniquenessLevel2 = {}));
    var MonikerKind2;
    (function(MonikerKind3) {
      MonikerKind3.$import = "import";
      MonikerKind3.$export = "export";
      MonikerKind3.local = "local";
    })(MonikerKind2 || (exports2.MonikerKind = MonikerKind2 = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest || (exports2.MonikerRequest = MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest2;
    (function(TypeHierarchyPrepareRequest3) {
      TypeHierarchyPrepareRequest3.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest3.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest3.method);
    })(TypeHierarchyPrepareRequest2 || (exports2.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest2 = {}));
    var TypeHierarchySupertypesRequest2;
    (function(TypeHierarchySupertypesRequest3) {
      TypeHierarchySupertypesRequest3.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest3.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest3.method);
    })(TypeHierarchySupertypesRequest2 || (exports2.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest2 = {}));
    var TypeHierarchySubtypesRequest2;
    (function(TypeHierarchySubtypesRequest3) {
      TypeHierarchySubtypesRequest3.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest3.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest3.method);
    })(TypeHierarchySubtypesRequest2 || (exports2.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest2;
    (function(InlineValueRequest3) {
      InlineValueRequest3.method = "textDocument/inlineValue";
      InlineValueRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest3.type = new messages_1.ProtocolRequestType(InlineValueRequest3.method);
    })(InlineValueRequest2 || (exports2.InlineValueRequest = InlineValueRequest2 = {}));
    var InlineValueRefreshRequest2;
    (function(InlineValueRefreshRequest3) {
      InlineValueRefreshRequest3.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest3.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest3.method);
    })(InlineValueRefreshRequest2 || (exports2.InlineValueRefreshRequest = InlineValueRefreshRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest2;
    (function(InlayHintRequest3) {
      InlayHintRequest3.method = "textDocument/inlayHint";
      InlayHintRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest3.type = new messages_1.ProtocolRequestType(InlayHintRequest3.method);
    })(InlayHintRequest2 || (exports2.InlayHintRequest = InlayHintRequest2 = {}));
    var InlayHintResolveRequest2;
    (function(InlayHintResolveRequest3) {
      InlayHintResolveRequest3.method = "inlayHint/resolve";
      InlayHintResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest3.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest3.method);
    })(InlayHintResolveRequest2 || (exports2.InlayHintResolveRequest = InlayHintResolveRequest2 = {}));
    var InlayHintRefreshRequest2;
    (function(InlayHintRefreshRequest3) {
      InlayHintRefreshRequest3.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest3.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest3.method);
    })(InlayHintRefreshRequest2 || (exports2.InlayHintRefreshRequest = InlayHintRefreshRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is2 = require_is2();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData2;
    (function(DiagnosticServerCancellationData3) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData3.is = is;
    })(DiagnosticServerCancellationData2 || (exports2.DiagnosticServerCancellationData = DiagnosticServerCancellationData2 = {}));
    var DocumentDiagnosticReportKind2;
    (function(DocumentDiagnosticReportKind3) {
      DocumentDiagnosticReportKind3.Full = "full";
      DocumentDiagnosticReportKind3.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind2 || (exports2.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind2 = {}));
    var DocumentDiagnosticRequest2;
    (function(DocumentDiagnosticRequest3) {
      DocumentDiagnosticRequest3.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest3.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest3.method);
      DocumentDiagnosticRequest3.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest2 || (exports2.DocumentDiagnosticRequest = DocumentDiagnosticRequest2 = {}));
    var WorkspaceDiagnosticRequest2;
    (function(WorkspaceDiagnosticRequest3) {
      WorkspaceDiagnosticRequest3.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest3.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest3.method);
      WorkspaceDiagnosticRequest3.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest2 || (exports2.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest2 = {}));
    var DiagnosticRefreshRequest2;
    (function(DiagnosticRefreshRequest3) {
      DiagnosticRefreshRequest3.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest3.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest3.method);
    })(DiagnosticRefreshRequest2 || (exports2.DiagnosticRefreshRequest = DiagnosticRefreshRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var Is2 = require_is2();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind || (exports2.NotebookCellKind = NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is2.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals2(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals2;
    })(ExecutionSummary || (exports2.ExecutionSummary = ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document2) {
        return { kind, document: document2 };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is2.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is2.objectLiteral(one) && Is2.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell || (exports2.NotebookCell = NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version2, cells) {
        return { uri, notebookType, version: version2, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && Is2.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is2.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument || (exports2.NotebookDocument = NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is2.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange || (exports2.NotebookCellArrayChange = NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
var require_protocol_inlineCompletion = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionRequest = void 0;
    var messages_1 = require_messages2();
    var InlineCompletionRequest;
    (function(InlineCompletionRequest2) {
      InlineCompletionRequest2.method = "textDocument/inlineCompletion";
      InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
    })(InlineCompletionRequest || (exports2.InlineCompletionRequest = InlineCompletionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangesFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
    exports2.InlineCompletionRequest = exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = require_main2();
    var Is2 = require_is2();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    Object.defineProperty(exports2, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRefreshRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
    Object.defineProperty(exports2, "InlineCompletionRequest", { enumerable: true, get: function() {
      return protocol_inlineCompletion_1.InlineCompletionRequest;
    } });
    var TextDocumentFilter2;
    (function(TextDocumentFilter3) {
      function is(value) {
        const candidate = value;
        return Is2.string(candidate) || (Is2.string(candidate.language) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern));
      }
      TextDocumentFilter3.is = is;
    })(TextDocumentFilter2 || (exports2.TextDocumentFilter = TextDocumentFilter2 = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebookType) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter || (exports2.NotebookDocumentFilter = NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is2.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is2.string(elem) && !TextDocumentFilter2.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector || (exports2.DocumentSelector = DocumentSelector = {}));
    var RegistrationRequest2;
    (function(RegistrationRequest3) {
      RegistrationRequest3.method = "client/registerCapability";
      RegistrationRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest3.type = new messages_1.ProtocolRequestType(RegistrationRequest3.method);
    })(RegistrationRequest2 || (exports2.RegistrationRequest = RegistrationRequest2 = {}));
    var UnregistrationRequest2;
    (function(UnregistrationRequest3) {
      UnregistrationRequest3.method = "client/unregisterCapability";
      UnregistrationRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest3.type = new messages_1.ProtocolRequestType(UnregistrationRequest3.method);
    })(UnregistrationRequest2 || (exports2.UnregistrationRequest = UnregistrationRequest2 = {}));
    var ResourceOperationKind2;
    (function(ResourceOperationKind3) {
      ResourceOperationKind3.Create = "create";
      ResourceOperationKind3.Rename = "rename";
      ResourceOperationKind3.Delete = "delete";
    })(ResourceOperationKind2 || (exports2.ResourceOperationKind = ResourceOperationKind2 = {}));
    var FailureHandlingKind2;
    (function(FailureHandlingKind3) {
      FailureHandlingKind3.Abort = "abort";
      FailureHandlingKind3.Transactional = "transactional";
      FailureHandlingKind3.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind3.Undo = "undo";
    })(FailureHandlingKind2 || (exports2.FailureHandlingKind = FailureHandlingKind2 = {}));
    var PositionEncodingKind2;
    (function(PositionEncodingKind3) {
      PositionEncodingKind3.UTF8 = "utf-8";
      PositionEncodingKind3.UTF16 = "utf-16";
      PositionEncodingKind3.UTF32 = "utf-32";
    })(PositionEncodingKind2 || (exports2.PositionEncodingKind = PositionEncodingKind2 = {}));
    var StaticRegistrationOptions2;
    (function(StaticRegistrationOptions3) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is2.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions3.hasId = hasId;
    })(StaticRegistrationOptions2 || (exports2.StaticRegistrationOptions = StaticRegistrationOptions2 = {}));
    var TextDocumentRegistrationOptions2;
    (function(TextDocumentRegistrationOptions3) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions3.is = is;
    })(TextDocumentRegistrationOptions2 || (exports2.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions2 = {}));
    var WorkDoneProgressOptions2;
    (function(WorkDoneProgressOptions3) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is2.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions3.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions3.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions2 || (exports2.WorkDoneProgressOptions = WorkDoneProgressOptions2 = {}));
    var InitializeRequest2;
    (function(InitializeRequest3) {
      InitializeRequest3.method = "initialize";
      InitializeRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest3.type = new messages_1.ProtocolRequestType(InitializeRequest3.method);
    })(InitializeRequest2 || (exports2.InitializeRequest = InitializeRequest2 = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes || (exports2.InitializeErrorCodes = InitializeErrorCodes = {}));
    var InitializedNotification2;
    (function(InitializedNotification3) {
      InitializedNotification3.method = "initialized";
      InitializedNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification3.type = new messages_1.ProtocolNotificationType(InitializedNotification3.method);
    })(InitializedNotification2 || (exports2.InitializedNotification = InitializedNotification2 = {}));
    var ShutdownRequest2;
    (function(ShutdownRequest3) {
      ShutdownRequest3.method = "shutdown";
      ShutdownRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest3.type = new messages_1.ProtocolRequestType0(ShutdownRequest3.method);
    })(ShutdownRequest2 || (exports2.ShutdownRequest = ShutdownRequest2 = {}));
    var ExitNotification2;
    (function(ExitNotification3) {
      ExitNotification3.method = "exit";
      ExitNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification3.type = new messages_1.ProtocolNotificationType0(ExitNotification3.method);
    })(ExitNotification2 || (exports2.ExitNotification = ExitNotification2 = {}));
    var DidChangeConfigurationNotification2;
    (function(DidChangeConfigurationNotification3) {
      DidChangeConfigurationNotification3.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification3.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification3.method);
    })(DidChangeConfigurationNotification2 || (exports2.DidChangeConfigurationNotification = DidChangeConfigurationNotification2 = {}));
    var MessageType2;
    (function(MessageType3) {
      MessageType3.Error = 1;
      MessageType3.Warning = 2;
      MessageType3.Info = 3;
      MessageType3.Log = 4;
      MessageType3.Debug = 5;
    })(MessageType2 || (exports2.MessageType = MessageType2 = {}));
    var ShowMessageNotification2;
    (function(ShowMessageNotification3) {
      ShowMessageNotification3.method = "window/showMessage";
      ShowMessageNotification3.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification3.type = new messages_1.ProtocolNotificationType(ShowMessageNotification3.method);
    })(ShowMessageNotification2 || (exports2.ShowMessageNotification = ShowMessageNotification2 = {}));
    var ShowMessageRequest2;
    (function(ShowMessageRequest3) {
      ShowMessageRequest3.method = "window/showMessageRequest";
      ShowMessageRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest3.type = new messages_1.ProtocolRequestType(ShowMessageRequest3.method);
    })(ShowMessageRequest2 || (exports2.ShowMessageRequest = ShowMessageRequest2 = {}));
    var LogMessageNotification2;
    (function(LogMessageNotification3) {
      LogMessageNotification3.method = "window/logMessage";
      LogMessageNotification3.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification3.type = new messages_1.ProtocolNotificationType(LogMessageNotification3.method);
    })(LogMessageNotification2 || (exports2.LogMessageNotification = LogMessageNotification2 = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification || (exports2.TelemetryEventNotification = TelemetryEventNotification = {}));
    var TextDocumentSyncKind2;
    (function(TextDocumentSyncKind3) {
      TextDocumentSyncKind3.None = 0;
      TextDocumentSyncKind3.Full = 1;
      TextDocumentSyncKind3.Incremental = 2;
    })(TextDocumentSyncKind2 || (exports2.TextDocumentSyncKind = TextDocumentSyncKind2 = {}));
    var DidOpenTextDocumentNotification2;
    (function(DidOpenTextDocumentNotification3) {
      DidOpenTextDocumentNotification3.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification3.method);
    })(DidOpenTextDocumentNotification2 || (exports2.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification2 = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification2;
    (function(DidChangeTextDocumentNotification3) {
      DidChangeTextDocumentNotification3.method = "textDocument/didChange";
      DidChangeTextDocumentNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification3.method);
    })(DidChangeTextDocumentNotification2 || (exports2.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification2 = {}));
    var DidCloseTextDocumentNotification2;
    (function(DidCloseTextDocumentNotification3) {
      DidCloseTextDocumentNotification3.method = "textDocument/didClose";
      DidCloseTextDocumentNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification3.method);
    })(DidCloseTextDocumentNotification2 || (exports2.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification2 = {}));
    var DidSaveTextDocumentNotification2;
    (function(DidSaveTextDocumentNotification3) {
      DidSaveTextDocumentNotification3.method = "textDocument/didSave";
      DidSaveTextDocumentNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification3.method);
    })(DidSaveTextDocumentNotification2 || (exports2.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification2 = {}));
    var TextDocumentSaveReason3;
    (function(TextDocumentSaveReason4) {
      TextDocumentSaveReason4.Manual = 1;
      TextDocumentSaveReason4.AfterDelay = 2;
      TextDocumentSaveReason4.FocusOut = 3;
    })(TextDocumentSaveReason3 || (exports2.TextDocumentSaveReason = TextDocumentSaveReason3 = {}));
    var WillSaveTextDocumentNotification2;
    (function(WillSaveTextDocumentNotification3) {
      WillSaveTextDocumentNotification3.method = "textDocument/willSave";
      WillSaveTextDocumentNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification3.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification3.method);
    })(WillSaveTextDocumentNotification2 || (exports2.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification2 = {}));
    var WillSaveTextDocumentWaitUntilRequest2;
    (function(WillSaveTextDocumentWaitUntilRequest3) {
      WillSaveTextDocumentWaitUntilRequest3.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest3.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest3.method);
    })(WillSaveTextDocumentWaitUntilRequest2 || (exports2.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest2 = {}));
    var DidChangeWatchedFilesNotification2;
    (function(DidChangeWatchedFilesNotification3) {
      DidChangeWatchedFilesNotification3.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification3.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification3.method);
    })(DidChangeWatchedFilesNotification2 || (exports2.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification2 = {}));
    var FileChangeType2;
    (function(FileChangeType3) {
      FileChangeType3.Created = 1;
      FileChangeType3.Changed = 2;
      FileChangeType3.Deleted = 3;
    })(FileChangeType2 || (exports2.FileChangeType = FileChangeType2 = {}));
    var RelativePattern3;
    (function(RelativePattern4) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is2.string(candidate.pattern);
      }
      RelativePattern4.is = is;
    })(RelativePattern3 || (exports2.RelativePattern = RelativePattern3 = {}));
    var WatchKind2;
    (function(WatchKind3) {
      WatchKind3.Create = 1;
      WatchKind3.Change = 2;
      WatchKind3.Delete = 4;
    })(WatchKind2 || (exports2.WatchKind = WatchKind2 = {}));
    var PublishDiagnosticsNotification2;
    (function(PublishDiagnosticsNotification3) {
      PublishDiagnosticsNotification3.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification3.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification3.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification3.method);
    })(PublishDiagnosticsNotification2 || (exports2.PublishDiagnosticsNotification = PublishDiagnosticsNotification2 = {}));
    var CompletionTriggerKind2;
    (function(CompletionTriggerKind3) {
      CompletionTriggerKind3.Invoked = 1;
      CompletionTriggerKind3.TriggerCharacter = 2;
      CompletionTriggerKind3.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind2 || (exports2.CompletionTriggerKind = CompletionTriggerKind2 = {}));
    var CompletionRequest2;
    (function(CompletionRequest3) {
      CompletionRequest3.method = "textDocument/completion";
      CompletionRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest3.type = new messages_1.ProtocolRequestType(CompletionRequest3.method);
    })(CompletionRequest2 || (exports2.CompletionRequest = CompletionRequest2 = {}));
    var CompletionResolveRequest2;
    (function(CompletionResolveRequest3) {
      CompletionResolveRequest3.method = "completionItem/resolve";
      CompletionResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest3.type = new messages_1.ProtocolRequestType(CompletionResolveRequest3.method);
    })(CompletionResolveRequest2 || (exports2.CompletionResolveRequest = CompletionResolveRequest2 = {}));
    var HoverRequest2;
    (function(HoverRequest3) {
      HoverRequest3.method = "textDocument/hover";
      HoverRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest3.type = new messages_1.ProtocolRequestType(HoverRequest3.method);
    })(HoverRequest2 || (exports2.HoverRequest = HoverRequest2 = {}));
    var SignatureHelpTriggerKind2;
    (function(SignatureHelpTriggerKind3) {
      SignatureHelpTriggerKind3.Invoked = 1;
      SignatureHelpTriggerKind3.TriggerCharacter = 2;
      SignatureHelpTriggerKind3.ContentChange = 3;
    })(SignatureHelpTriggerKind2 || (exports2.SignatureHelpTriggerKind = SignatureHelpTriggerKind2 = {}));
    var SignatureHelpRequest2;
    (function(SignatureHelpRequest3) {
      SignatureHelpRequest3.method = "textDocument/signatureHelp";
      SignatureHelpRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest3.type = new messages_1.ProtocolRequestType(SignatureHelpRequest3.method);
    })(SignatureHelpRequest2 || (exports2.SignatureHelpRequest = SignatureHelpRequest2 = {}));
    var DefinitionRequest2;
    (function(DefinitionRequest3) {
      DefinitionRequest3.method = "textDocument/definition";
      DefinitionRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest3.type = new messages_1.ProtocolRequestType(DefinitionRequest3.method);
    })(DefinitionRequest2 || (exports2.DefinitionRequest = DefinitionRequest2 = {}));
    var ReferencesRequest2;
    (function(ReferencesRequest3) {
      ReferencesRequest3.method = "textDocument/references";
      ReferencesRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest3.type = new messages_1.ProtocolRequestType(ReferencesRequest3.method);
    })(ReferencesRequest2 || (exports2.ReferencesRequest = ReferencesRequest2 = {}));
    var DocumentHighlightRequest2;
    (function(DocumentHighlightRequest3) {
      DocumentHighlightRequest3.method = "textDocument/documentHighlight";
      DocumentHighlightRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest3.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest3.method);
    })(DocumentHighlightRequest2 || (exports2.DocumentHighlightRequest = DocumentHighlightRequest2 = {}));
    var DocumentSymbolRequest2;
    (function(DocumentSymbolRequest3) {
      DocumentSymbolRequest3.method = "textDocument/documentSymbol";
      DocumentSymbolRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest3.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest3.method);
    })(DocumentSymbolRequest2 || (exports2.DocumentSymbolRequest = DocumentSymbolRequest2 = {}));
    var CodeActionRequest2;
    (function(CodeActionRequest3) {
      CodeActionRequest3.method = "textDocument/codeAction";
      CodeActionRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest3.type = new messages_1.ProtocolRequestType(CodeActionRequest3.method);
    })(CodeActionRequest2 || (exports2.CodeActionRequest = CodeActionRequest2 = {}));
    var CodeActionResolveRequest2;
    (function(CodeActionResolveRequest3) {
      CodeActionResolveRequest3.method = "codeAction/resolve";
      CodeActionResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest3.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest3.method);
    })(CodeActionResolveRequest2 || (exports2.CodeActionResolveRequest = CodeActionResolveRequest2 = {}));
    var WorkspaceSymbolRequest2;
    (function(WorkspaceSymbolRequest3) {
      WorkspaceSymbolRequest3.method = "workspace/symbol";
      WorkspaceSymbolRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest3.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest3.method);
    })(WorkspaceSymbolRequest2 || (exports2.WorkspaceSymbolRequest = WorkspaceSymbolRequest2 = {}));
    var WorkspaceSymbolResolveRequest2;
    (function(WorkspaceSymbolResolveRequest3) {
      WorkspaceSymbolResolveRequest3.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest3.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest3.method);
    })(WorkspaceSymbolResolveRequest2 || (exports2.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest2 = {}));
    var CodeLensRequest2;
    (function(CodeLensRequest3) {
      CodeLensRequest3.method = "textDocument/codeLens";
      CodeLensRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest3.type = new messages_1.ProtocolRequestType(CodeLensRequest3.method);
    })(CodeLensRequest2 || (exports2.CodeLensRequest = CodeLensRequest2 = {}));
    var CodeLensResolveRequest2;
    (function(CodeLensResolveRequest3) {
      CodeLensResolveRequest3.method = "codeLens/resolve";
      CodeLensResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest3.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest3.method);
    })(CodeLensResolveRequest2 || (exports2.CodeLensResolveRequest = CodeLensResolveRequest2 = {}));
    var CodeLensRefreshRequest2;
    (function(CodeLensRefreshRequest3) {
      CodeLensRefreshRequest3.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest3.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest3.method);
    })(CodeLensRefreshRequest2 || (exports2.CodeLensRefreshRequest = CodeLensRefreshRequest2 = {}));
    var DocumentLinkRequest2;
    (function(DocumentLinkRequest3) {
      DocumentLinkRequest3.method = "textDocument/documentLink";
      DocumentLinkRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest3.type = new messages_1.ProtocolRequestType(DocumentLinkRequest3.method);
    })(DocumentLinkRequest2 || (exports2.DocumentLinkRequest = DocumentLinkRequest2 = {}));
    var DocumentLinkResolveRequest2;
    (function(DocumentLinkResolveRequest3) {
      DocumentLinkResolveRequest3.method = "documentLink/resolve";
      DocumentLinkResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest3.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest3.method);
    })(DocumentLinkResolveRequest2 || (exports2.DocumentLinkResolveRequest = DocumentLinkResolveRequest2 = {}));
    var DocumentFormattingRequest2;
    (function(DocumentFormattingRequest3) {
      DocumentFormattingRequest3.method = "textDocument/formatting";
      DocumentFormattingRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest3.method);
    })(DocumentFormattingRequest2 || (exports2.DocumentFormattingRequest = DocumentFormattingRequest2 = {}));
    var DocumentRangeFormattingRequest2;
    (function(DocumentRangeFormattingRequest3) {
      DocumentRangeFormattingRequest3.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest3.method);
    })(DocumentRangeFormattingRequest2 || (exports2.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest2 = {}));
    var DocumentRangesFormattingRequest;
    (function(DocumentRangesFormattingRequest2) {
      DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
      DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
    })(DocumentRangesFormattingRequest || (exports2.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest2;
    (function(DocumentOnTypeFormattingRequest3) {
      DocumentOnTypeFormattingRequest3.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest3.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest3.method);
    })(DocumentOnTypeFormattingRequest2 || (exports2.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest2 = {}));
    var PrepareSupportDefaultBehavior2;
    (function(PrepareSupportDefaultBehavior3) {
      PrepareSupportDefaultBehavior3.Identifier = 1;
    })(PrepareSupportDefaultBehavior2 || (exports2.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior2 = {}));
    var RenameRequest2;
    (function(RenameRequest3) {
      RenameRequest3.method = "textDocument/rename";
      RenameRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest3.type = new messages_1.ProtocolRequestType(RenameRequest3.method);
    })(RenameRequest2 || (exports2.RenameRequest = RenameRequest2 = {}));
    var PrepareRenameRequest2;
    (function(PrepareRenameRequest3) {
      PrepareRenameRequest3.method = "textDocument/prepareRename";
      PrepareRenameRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest3.type = new messages_1.ProtocolRequestType(PrepareRenameRequest3.method);
    })(PrepareRenameRequest2 || (exports2.PrepareRenameRequest = PrepareRenameRequest2 = {}));
    var ExecuteCommandRequest2;
    (function(ExecuteCommandRequest3) {
      ExecuteCommandRequest3.method = "workspace/executeCommand";
      ExecuteCommandRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest3.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest3.method);
    })(ExecuteCommandRequest2 || (exports2.ExecuteCommandRequest = ExecuteCommandRequest2 = {}));
    var ApplyWorkspaceEditRequest2;
    (function(ApplyWorkspaceEditRequest3) {
      ApplyWorkspaceEditRequest3.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest3.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest2 || (exports2.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection2(input, output, logger60, options2) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options2)) {
        options2 = { connectionStrategy: options2 };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger60, options2);
    }
    exports2.createProtocolConnection = createProtocolConnection2;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar(require_main2(), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection3();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes2;
    (function(LSPErrorCodes3) {
      LSPErrorCodes3.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes3.RequestFailed = -32803;
      LSPErrorCodes3.ServerCancelled = -32802;
      LSPErrorCodes3.ContentModified = -32801;
      LSPErrorCodes3.RequestCancelled = -32800;
      LSPErrorCodes3.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes2 || (exports2.LSPErrorCodes = LSPErrorCodes2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar(require_node(), exports2);
    __exportStar(require_api3(), exports2);
    function createProtocolConnection2(input, output, logger60, options2) {
      return (0, node_1.createMessageConnection)(input, output, logger60, options2);
    }
    exports2.createProtocolConnection = createProtocolConnection2;
  }
});

// node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// src/util/protocol.ts
var import_node4;
var init_protocol = __esm({
  "src/util/protocol.ts"() {
    "use strict";
    import_node4 = __toESM(require_node2());
  }
});

// src/util/array.ts
function toArray(item) {
  return Array.isArray(item) ? item : item == null ? [] : [item];
}
function isFalsyOrEmpty(obj) {
  return !Array.isArray(obj) || obj.length === 0;
}
function compareValue(n, r) {
  if (n < r[0]) return 1;
  if (n > r[1]) return -1;
  return 0;
}
function intable(n, table) {
  let low = 0;
  let high = table.length - 1;
  while (low <= high) {
    const mid = (low + high) / 2 | 0;
    const comp = compareValue(n, table[mid]);
    if (comp < 0) {
      low = mid + 1;
    } else if (comp > 0) {
      high = mid - 1;
    } else {
      return true;
    }
  }
  return false;
}
function binarySearch(array, key, comparator) {
  return binarySearch2(array.length, (i) => comparator(array[i], key));
}
function binarySearch2(length, compareToKey) {
  let low = 0;
  let high = length - 1;
  while (low <= high) {
    const mid = (low + high) / 2 | 0;
    const comp = compareToKey(mid);
    if (comp < 0) {
      low = mid + 1;
    } else if (comp > 0) {
      high = mid - 1;
    } else {
      return mid;
    }
  }
  return -(low + 1);
}
function intersect(array, other) {
  for (let item of other) {
    if (array.includes(item)) {
      return true;
    }
  }
  return false;
}
function splitArray(array, fn) {
  let res = [[], []];
  for (let item of array) {
    if (fn(item)) {
      res[0].push(item);
    } else {
      res[1].push(item);
    }
  }
  return res;
}
function groupBy(array, fn) {
  let res = [[], []];
  array.forEach((v) => {
    if (fn(v)) {
      res[0].push(v);
    } else {
      res[1].push(v);
    }
  });
  return res;
}
function distinct(array, keyFn) {
  if (!keyFn) {
    return array.filter((element, position) => array.indexOf(element) === position);
  }
  const seen = /* @__PURE__ */ Object.create(null);
  return array.filter((elem) => {
    const key = keyFn(elem);
    if (seen[key]) {
      return false;
    }
    seen[key] = true;
    return true;
  });
}
var init_array = __esm({
  "src/util/array.ts"() {
    "use strict";
  }
});

// src/util/charCode.ts
var init_charCode = __esm({
  "src/util/charCode.ts"() {
    "use strict";
  }
});

// src/util/string.ts
function toErrorText(error) {
  return error instanceof Error ? error.message : error.toString();
}
function toInteger(text) {
  let n = parseInt(text, 10);
  return isNaN(n) ? void 0 : n;
}
function toText(text) {
  if (typeof text === "number") return text.toString();
  return text ?? "";
}
function toBase64(text) {
  return global.Buffer.from(text).toString("base64");
}
function isHighlightGroupCharCode(code) {
  if (intable(code, asciiTable)) return true;
  return code === 95 /* Underline */ || code === 46 /* Period */ || code === 64 /* AtSign */;
}
function isEmojiImprecise(x) {
  return x >= 127462 && x <= 127487 || x === 8986 || x === 8987 || x === 9200 || x === 9203 || x >= 9728 && x <= 10175 || x === 11088 || x === 11093 || x >= 127744 && x <= 128591 || x >= 128640 && x <= 128764 || x >= 128992 && x <= 129008 || x >= 129280 && x <= 129535 || x >= 129648 && x <= 129782;
}
function* iterateCharacter(input, character) {
  for (let i = 0; i < input.length; i++) {
    if (input[i] == character) yield i;
  }
}
function isHighSurrogate(codePoint) {
  return codePoint >= 55296 && codePoint <= 56319;
}
function isLowSurrogate(codePoint) {
  return codePoint >= 56320 && codePoint <= 57343;
}
function byteLength(str, start = 0) {
  if (start === 0) return Buffer.byteLength(str, encoding);
  let len = 0;
  let unitIndex = 0;
  for (let codePoint of str) {
    let n = codePoint.codePointAt(0);
    if (unitIndex >= start) {
      len += utf8_code2len(n);
    }
    unitIndex += n >= UTF8_4BYTES_START ? 2 : 1;
  }
  return len;
}
function byteIndex(content, index) {
  let byteLength2 = 0;
  let codePoint;
  let prevCodePoint;
  let max = Math.min(index, content.length);
  for (let i = 0; i < max; i++) {
    codePoint = content.charCodeAt(i);
    if (isLowSurrogate(codePoint)) {
      if (prevCodePoint && isHighSurrogate(prevCodePoint)) {
        byteLength2 += 1;
      } else {
        byteLength2 += 3;
      }
    } else {
      byteLength2 += utf8_code2len(codePoint);
    }
    prevCodePoint = codePoint;
  }
  return byteLength2;
}
function upperFirst(str) {
  return str?.length > 0 ? str[0].toUpperCase() + str.slice(1) : "";
}
function characterIndex(content, byteIndex2) {
  if (byteIndex2 == 0) return 0;
  let characterIndex2 = 0;
  let total = 0;
  for (let codePoint of content) {
    let code = codePoint.codePointAt(0);
    if (code >= UTF8_4BYTES_START) {
      characterIndex2 += 2;
      total += 4;
    } else {
      characterIndex2 += 1;
      total += utf8_code2len(code);
    }
    if (total >= byteIndex2) break;
  }
  return characterIndex2;
}
function utf8_code2len(code) {
  if (code < UTF8_2BYTES_START) return 1;
  if (code < UTF8_3BYTES_START) return 2;
  if (code < UTF8_4BYTES_START) return 3;
  return 4;
}
function byteSlice(content, start, end) {
  let si = characterIndex(content, start);
  let ei = end === void 0 ? void 0 : characterIndex(content, end);
  return content.slice(si, ei);
}
function isAlphabet(code) {
  if (code >= 65 && code <= 90) return true;
  if (code >= 97 && code <= 122) return true;
  return false;
}
function contentToLines(content, eol) {
  if (eol && content.endsWith("\n")) {
    return content.slice(0, -1).split("\n");
  }
  return content.split("\n");
}
function hasUpperCase(str) {
  for (let i = 0, l = str.length; i < l; i++) {
    let code = str.charCodeAt(i);
    if (code >= 65 && code <= 90) {
      return true;
    }
  }
  return false;
}
function smartMatch(a, b) {
  if (a === b) return true;
  let c = b.charCodeAt(0);
  if (c >= 65 && c <= 90) {
    if (c + 32 === a.charCodeAt(0)) return true;
  }
  return false;
}
function smartcaseIndex(input, other) {
  if (input.length > other.length) return -1;
  if (input.length === 0) return 0;
  if (!hasUpperCase(input)) {
    return other.toLowerCase().indexOf(input);
  }
  let total = input.length;
  let checked = 0;
  for (let i = 0; i < other.length; i++) {
    let ch = other[i];
    if (smartMatch(input[checked], ch)) {
      checked++;
      if (checked === total) {
        return i - checked + 1;
      }
    } else if (checked > 0) {
      i = i - checked;
      checked = 0;
    }
  }
  return -1;
}
function bytes(text, max) {
  max = max ?? text.length;
  let lens = new Uint8Array(max);
  let ascii = true;
  let prevCodePoint;
  for (let i = 0; i < max; i++) {
    let code = text.charCodeAt(i);
    let len;
    if (isLowSurrogate(code)) {
      if (prevCodePoint && isHighSurrogate(prevCodePoint)) {
        len = 1;
      } else {
        len = 3;
      }
    } else {
      len = utf8_code2len(code);
    }
    if (ascii && len > 1) ascii = false;
    lens[i] = len;
    prevCodePoint = code;
  }
  return (characterIndex2) => {
    if (characterIndex2 === 0) return 0;
    if (ascii) return Math.min(characterIndex2, max);
    let res = 0;
    for (let i = 0; i < Math.min(characterIndex2, max); i++) {
      res += lens[i];
    }
    return res;
  };
}
function getUnicodeClass(char) {
  if (char == null || char.length === 0) return "other";
  const charCode = char.charCodeAt(0);
  if (charCode <= 127) {
    if (charCode === 0) return "other";
    if (/\s/.test(char)) return "space";
    if (/\w/.test(char)) return "word";
    return "punctuation";
  }
  for (const [start, end, category] of nonAsciiUnicodeClassRanges) {
    if (start <= charCode && charCode <= end) {
      return category;
    }
  }
  return "other";
}
var UTF8_2BYTES_START, UTF8_3BYTES_START, UTF8_4BYTES_START, encoding, asciiTable, nonAsciiUnicodeClassRanges;
var init_string = __esm({
  "src/util/string.ts"() {
    "use strict";
    init_array();
    init_charCode();
    UTF8_2BYTES_START = 128;
    UTF8_3BYTES_START = 2048;
    UTF8_4BYTES_START = 65536;
    encoding = "utf8";
    asciiTable = [
      [48, 57],
      [65, 90],
      [97, 122]
    ];
    nonAsciiUnicodeClassRanges = [
      [894, 894, "punctuation"],
      [903, 903, "punctuation"],
      [1370, 1375, "punctuation"],
      [1417, 1417, "punctuation"],
      [1470, 1470, "punctuation"],
      [1472, 1472, "punctuation"],
      [1475, 1475, "punctuation"],
      [1523, 1524, "punctuation"],
      [1548, 1548, "punctuation"],
      [1563, 1563, "punctuation"],
      [1567, 1567, "punctuation"],
      [1642, 1645, "punctuation"],
      [1748, 1748, "punctuation"],
      [1792, 1805, "punctuation"],
      [2404, 2405, "punctuation"],
      [2416, 2416, "punctuation"],
      [3572, 3572, "punctuation"],
      [3663, 3663, "punctuation"],
      [3674, 3675, "punctuation"],
      [3844, 3858, "punctuation"],
      [3898, 3901, "punctuation"],
      [3973, 3973, "punctuation"],
      [4170, 4175, "punctuation"],
      [4347, 4347, "punctuation"],
      [4961, 4968, "punctuation"],
      [5741, 5742, "punctuation"],
      [5760, 5760, "space"],
      [5787, 5788, "punctuation"],
      [5867, 5869, "punctuation"],
      [5941, 5942, "punctuation"],
      [6100, 6108, "punctuation"],
      [6144, 6154, "punctuation"],
      [8192, 8203, "space"],
      [8204, 8231, "punctuation"],
      [8232, 8233, "space"],
      [8234, 8238, "punctuation"],
      [8239, 8239, "space"],
      [8240, 8286, "punctuation"],
      [8287, 8287, "space"],
      [8288, 10239, "punctuation"],
      [8304, 8319, "superscript"],
      [8320, 8340, "subscript"],
      [8352, 10239, "punctuation"],
      [10240, 10495, "braille"],
      [10496, 10648, "punctuation"],
      [10712, 10715, "punctuation"],
      [10748, 10749, "punctuation"],
      [11776, 11903, "punctuation"],
      [12288, 12288, "space"],
      [12289, 12320, "punctuation"],
      [12336, 12336, "punctuation"],
      [12349, 12349, "punctuation"],
      [12352, 12447, "hiragana"],
      [12448, 12543, "katakana"],
      [13056, 40959, "cjkideograph"],
      [44032, 55203, "hangulsyllable"],
      [63744, 64255, "cjkideograph"],
      [64830, 64831, "punctuation"],
      [65072, 65131, "punctuation"],
      [65280, 65295, "punctuation"],
      [65306, 65312, "punctuation"],
      [65339, 65344, "punctuation"],
      [65371, 65381, "punctuation"],
      [118784, 119375, "other"],
      [119808, 120831, "other"],
      [126976, 127743, "other"],
      [127744, 129535, "other"],
      [131072, 173791, "cjkideograph"],
      [173824, 177983, "cjkideograph"],
      [177984, 178207, "cjkideograph"],
      [194560, 195103, "cjkideograph"]
    ];
  }
});

// src/events.ts
var logger2, debounceTime, Events, events_default;
var init_events = __esm({
  "src/events.ts"() {
    "use strict";
    init_logger();
    init_util();
    init_errors();
    init_is();
    init_object();
    init_protocol();
    init_string();
    logger2 = createLogger("events");
    debounceTime = getConditionValue(100, 10);
    Events = class {
      constructor() {
        this.handlers = /* @__PURE__ */ new Map();
        this._bufnr = 1;
        this.timeoutMap = /* @__PURE__ */ new Map();
        // bufnr & character
        this._recentInserts = [];
        this._lastChange = 0;
        this._insertMode = false;
        this._pumAlignTop = false;
        this._pumVisible = false;
        this._completing = false;
        this._requesting = false;
        this._ready = false;
        this.timeout = 1e3;
      }
      // public completing = false
      set requesting(val) {
        this._requesting = val;
      }
      get requesting() {
        return this._requesting;
      }
      get ready() {
        return this._ready;
      }
      fireVisibleEvent(ev) {
        let { winid } = ev;
        let timer = this.timeoutMap.get(winid);
        if (timer) clearTimeout(timer);
        timer = setTimeout(() => {
          this.fire("WindowVisible", [ev]).catch(onUnexpectedError);
        }, debounceTime);
        this.timeoutMap.set(winid, timer);
      }
      clearVisibleTimer(winid) {
        let timer = this.timeoutMap.get(winid);
        if (timer) {
          this.timeoutMap.delete(winid);
          clearTimeout(timer);
        }
      }
      set completing(completing) {
        this._completing = completing;
        this._pumVisible = completing;
      }
      get completing() {
        return this._completing;
      }
      get cursor() {
        return this._cursor ?? { bufnr: this._bufnr, col: 1, lnum: 1, insert: false };
      }
      get bufnr() {
        return this._bufnr;
      }
      get pumvisible() {
        return this._pumVisible;
      }
      get pumAlignTop() {
        return this._pumAlignTop;
      }
      get insertMode() {
        return this._insertMode;
      }
      get lastChangeTs() {
        return this._lastChange;
      }
      /**
       * Resolved when first event fired or timeout
       */
      race(events, token) {
        let disposables = [];
        return new Promise((resolve) => {
          if (number(token)) {
            let timer = setTimeout(() => {
              disposeAll(disposables);
              resolve(void 0);
            }, token);
            disposables.push(import_node4.Disposable.create(() => {
              clearTimeout(timer);
            }));
          } else if (import_node4.CancellationToken.is(token)) {
            token.onCancellationRequested(() => {
              disposeAll(disposables);
              resolve(void 0);
            }, null, disposables);
          }
          events.forEach((ev) => {
            this.on(ev, (...args) => {
              disposeAll(disposables);
              resolve({ name: ev, args });
            }, null, disposables);
          });
        });
      }
      async fire(event, args) {
        if (event === "ready" /* Ready */) {
          this._ready = true;
        } else if (event == "InsertEnter" /* InsertEnter */) {
          this._insertMode = true;
        } else if (event == "InsertLeave" /* InsertLeave */) {
          this._insertMode = false;
          this._pumVisible = false;
          this._recentInserts = [];
        } else if (event == "CursorHoldI" /* CursorHoldI */ || event == "CursorMovedI" /* CursorMovedI */) {
          this._bufnr = args[0];
          if (!this._insertMode) {
            this._insertMode = true;
            void this.fire("InsertEnter" /* InsertEnter */, [args[0]]);
          }
        } else if (event == "CursorHold" /* CursorHold */ || event == "CursorMoved" /* CursorMoved */) {
          this._bufnr = args[0];
          if (this._insertMode) {
            this._insertMode = false;
            void this.fire("InsertLeave" /* InsertLeave */, [args[0]]);
          }
        } else if (event == "MenuPopupChanged" /* MenuPopupChanged */) {
          this._pumVisible = true;
          this._pumAlignTop = args[1] > args[0].row;
        } else if (event == "InsertCharPre" /* InsertCharPre */) {
          this._recentInserts.push([args[1], args[0]]);
        } else if (event == "TextChanged" /* TextChanged */) {
          this._lastChange = Date.now();
        } else if (event == "BufEnter" /* BufEnter */) {
          this._bufnr = args[0];
        } else if (event == "TextChangedI" /* TextChangedI */ || event == "TextChangedP" /* TextChangedP */) {
          let info = args[1];
          let pre = byteSlice(info.line ?? "", 0, info.col - 1);
          let arr;
          arr = this._recentInserts.filter((o) => o[0] == args[0]);
          this._bufnr = args[0];
          this._recentInserts = [];
          this._lastChange = Date.now();
          info.pre = pre;
          info.insertChars = arr.map((o) => o[1]);
          this._cursor = Object.freeze({
            bufnr: args[0],
            lnum: info.lnum,
            col: info.col,
            insert: true
          });
          if (arr.length && pre.length) {
            let character = pre.slice(-1);
            if (arr.findIndex((o) => o[1] == character) !== -1) {
              info.insertChar = character;
              process.nextTick(() => {
                void this.fire("TextInsert" /* TextInsert */, [...args, character]);
              });
            }
          }
        } else if (event == "BufWinEnter" /* BufWinEnter */) {
          const [bufnr, winid, region] = args;
          this.fireVisibleEvent({ bufnr, winid, region });
        } else if (event == "WinScrolled" /* WinScrolled */) {
          const [winid, bufnr, region] = args;
          this.fireVisibleEvent({ bufnr, winid, region });
        } else if (event == "WinClosed" /* WinClosed */) {
          this.clearVisibleTimer(args[0]);
        } else if (event == "BufWinLeave" /* BufWinLeave */) {
          this.clearVisibleTimer(args[1]);
        }
        if (event == "CursorMoved" /* CursorMoved */ || event == "CursorMovedI" /* CursorMovedI */) {
          args.push(this._recentInserts.length > 0);
          let cursor = {
            bufnr: args[0],
            lnum: args[1][0],
            col: args[1][1],
            insert: event == "CursorMovedI" /* CursorMovedI */
          };
          if (this._cursor && equals(this._cursor, cursor)) return;
          this._cursor = cursor;
        }
        let cbs = this.handlers.get(event);
        if (cbs?.length) {
          let fns = cbs.slice();
          let traceSlow = this.requesting;
          await Promise.allSettled(fns.map((fn) => {
            let promiseFn = async () => {
              let timer;
              if (traceSlow) {
                timer = setTimeout(() => {
                  logger2.warn(`Slow "${event}" handler detected`, fn["stack"]);
                }, this.timeout);
              }
              try {
                await fn(args);
              } catch (e) {
                if (!shouldIgnore(e)) logger2.error(`Error on event: ${event}`, e, fn["stack"]);
              }
              clearTimeout(timer);
            };
            return promiseFn();
          }));
        }
      }
      on(event, handler, thisArg, disposables) {
        if (Array.isArray(event)) {
          let arr = [];
          for (let ev of event) {
            this.on(ev, handler, thisArg, arr);
          }
          let dis = import_node4.Disposable.create(() => {
            disposeAll(arr);
          });
          if (Array.isArray(disposables)) {
            disposables.push(dis);
          }
          return dis;
        } else {
          let arr = this.handlers.get(event) ?? [];
          let onFinish = () => {
            if (disposables === true && disposable) disposable.dispose();
          };
          let wrappedhandler = (args) => new Promise((resolve, reject) => {
            try {
              Promise.resolve(handler.apply(thisArg ?? null, args)).then(() => {
                onFinish();
                resolve(void 0);
              }, (e) => {
                onFinish();
                reject(e);
              });
            } catch (e) {
              onFinish();
              reject(e);
            }
          });
          Error.captureStackTrace(wrappedhandler);
          arr.push(wrappedhandler);
          this.handlers.set(event, arr);
          let disposable = import_node4.Disposable.create(() => {
            let idx = arr.indexOf(wrappedhandler);
            if (idx !== -1) {
              arr.splice(idx, 1);
            }
          });
          if (Array.isArray(disposables)) {
            disposables.push(disposable);
          }
          return disposable;
        }
      }
      once(event, handler, thisArg) {
        return this.on(event, handler, thisArg, true);
      }
    };
    events_default = new Events();
  }
});

// package.json
var version;
var init_package = __esm({
  "package.json"() {
    version = "0.0.82";
  }
});

// src/util/constants.ts
var ASCII_END, VERSION, isVim, APIVERSION, floatHighlightGroup, CONFIG_FILE_NAME, configHome, dataHome, userConfigFile, pluginRoot;
var init_constants = __esm({
  "src/util/constants.ts"() {
    "use strict";
    init_package();
    init_util();
    init_node();
    ASCII_END = 128;
    VERSION = version;
    isVim = process.env.VIM_NODE_RPC == "1";
    APIVERSION = 37;
    floatHighlightGroup = "CocFloating";
    CONFIG_FILE_NAME = "coc-settings.json";
    configHome = defaultValue(process.env.COC_VIMCONFIG, path.join(os.homedir(), ".vim"));
    dataHome = defaultValue(process.env.COC_DATA_HOME, path.join(os.homedir(), ".config/coc"));
    userConfigFile = path.join(path.normalize(configHome), CONFIG_FILE_NAME);
    pluginRoot = getConditionValue(path.dirname(__dirname), path.resolve(__dirname, "../.."));
  }
});

// node_modules/jsonc-parser/lib/esm/impl/scanner.js
function createScanner(text, ignoreTrivia = false) {
  const len = text.length;
  let pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
  function scanHexDigits(count, exact) {
    let digits = 0;
    let value2 = 0;
    while (digits < count || !exact) {
      let ch = text.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        value2 = value2 * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        value2 = value2 * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        value2 = value2 * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count) {
      value2 = -1;
    }
    return value2;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token = 16;
    scanError = 0;
  }
  function scanNumber() {
    let start = pos;
    if (text.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text.length && text.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text.substring(start, pos);
      }
    }
    let end = pos;
    if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
        end = pos;
      } else {
        scanError = 3;
      }
    }
    return text.substring(start, end);
  }
  function scanString() {
    let result = "", start = pos;
    while (true) {
      if (pos >= len) {
        result += text.substring(start, pos);
        scanError = 2;
        break;
      }
      const ch = text.charCodeAt(pos);
      if (ch === 34) {
        result += text.substring(start, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text.substring(start, pos);
        pos++;
        if (pos >= len) {
          scanError = 2;
          break;
        }
        const ch2 = text.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117:
            const ch3 = scanHexDigits(4, true);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          default:
            scanError = 5;
        }
        start = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text.substring(start, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    lineStartOffset = lineNumber;
    prevTokenLineStartOffset = tokenLineStartOffset;
    if (pos >= len) {
      tokenOffset = len;
      return token = 17;
    }
    let code = text.charCodeAt(pos);
    if (isWhiteSpace(code)) {
      do {
        pos++;
        value += String.fromCharCode(code);
        code = text.charCodeAt(pos);
      } while (isWhiteSpace(code));
      return token = 15;
    }
    if (isLineBreak(code)) {
      pos++;
      value += String.fromCharCode(code);
      if (code === 13 && text.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      lineNumber++;
      tokenLineStartOffset = pos;
      return token = 14;
    }
    switch (code) {
      // tokens: []{}:,
      case 123:
        pos++;
        return token = 1;
      case 125:
        pos++;
        return token = 2;
      case 91:
        pos++;
        return token = 3;
      case 93:
        pos++;
        return token = 4;
      case 58:
        pos++;
        return token = 6;
      case 44:
        pos++;
        return token = 5;
      // strings
      case 34:
        pos++;
        value = scanString();
        return token = 10;
      // comments
      case 47:
        const start = pos - 1;
        if (text.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len) {
            if (isLineBreak(text.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text.substring(start, pos);
          return token = 12;
        }
        if (text.charCodeAt(pos + 1) === 42) {
          pos += 2;
          const safeLength = len - 1;
          let commentClosed = false;
          while (pos < safeLength) {
            const ch = text.charCodeAt(pos);
            if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
            if (isLineBreak(ch)) {
              if (ch === 13 && text.charCodeAt(pos) === 10) {
                pos++;
              }
              lineNumber++;
              tokenLineStartOffset = pos;
            }
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text.substring(start, pos);
          return token = 13;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
      // numbers
      case 45:
        value += String.fromCharCode(code);
        pos++;
        if (pos === len || !isDigit(text.charCodeAt(pos))) {
          return token = 16;
        }
      // found a minus, followed by a number so
      // we fall through to proceed with scanning
      // numbers
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token = 11;
      // literals and unknown symbols
      default:
        while (pos < len && isUnknownContentCharacter(code)) {
          pos++;
          code = text.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token = 8;
            case "false":
              return token = 9;
            case "null":
              return token = 7;
          }
          return token = 16;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
    }
  }
  function isUnknownContentCharacter(code) {
    if (isWhiteSpace(code) || isLineBreak(code)) {
      return false;
    }
    switch (code) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    let result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: () => pos,
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: () => token,
    getTokenValue: () => value,
    getTokenOffset: () => tokenOffset,
    getTokenLength: () => pos - tokenOffset,
    getTokenStartLine: () => lineStartOffset,
    getTokenStartCharacter: () => tokenOffset - prevTokenLineStartOffset,
    getTokenError: () => scanError
  };
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
var CharacterCodes;
var init_scanner = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/scanner.js"() {
    "use strict";
    (function(CharacterCodes2) {
      CharacterCodes2[CharacterCodes2["lineFeed"] = 10] = "lineFeed";
      CharacterCodes2[CharacterCodes2["carriageReturn"] = 13] = "carriageReturn";
      CharacterCodes2[CharacterCodes2["space"] = 32] = "space";
      CharacterCodes2[CharacterCodes2["_0"] = 48] = "_0";
      CharacterCodes2[CharacterCodes2["_1"] = 49] = "_1";
      CharacterCodes2[CharacterCodes2["_2"] = 50] = "_2";
      CharacterCodes2[CharacterCodes2["_3"] = 51] = "_3";
      CharacterCodes2[CharacterCodes2["_4"] = 52] = "_4";
      CharacterCodes2[CharacterCodes2["_5"] = 53] = "_5";
      CharacterCodes2[CharacterCodes2["_6"] = 54] = "_6";
      CharacterCodes2[CharacterCodes2["_7"] = 55] = "_7";
      CharacterCodes2[CharacterCodes2["_8"] = 56] = "_8";
      CharacterCodes2[CharacterCodes2["_9"] = 57] = "_9";
      CharacterCodes2[CharacterCodes2["a"] = 97] = "a";
      CharacterCodes2[CharacterCodes2["b"] = 98] = "b";
      CharacterCodes2[CharacterCodes2["c"] = 99] = "c";
      CharacterCodes2[CharacterCodes2["d"] = 100] = "d";
      CharacterCodes2[CharacterCodes2["e"] = 101] = "e";
      CharacterCodes2[CharacterCodes2["f"] = 102] = "f";
      CharacterCodes2[CharacterCodes2["g"] = 103] = "g";
      CharacterCodes2[CharacterCodes2["h"] = 104] = "h";
      CharacterCodes2[CharacterCodes2["i"] = 105] = "i";
      CharacterCodes2[CharacterCodes2["j"] = 106] = "j";
      CharacterCodes2[CharacterCodes2["k"] = 107] = "k";
      CharacterCodes2[CharacterCodes2["l"] = 108] = "l";
      CharacterCodes2[CharacterCodes2["m"] = 109] = "m";
      CharacterCodes2[CharacterCodes2["n"] = 110] = "n";
      CharacterCodes2[CharacterCodes2["o"] = 111] = "o";
      CharacterCodes2[CharacterCodes2["p"] = 112] = "p";
      CharacterCodes2[CharacterCodes2["q"] = 113] = "q";
      CharacterCodes2[CharacterCodes2["r"] = 114] = "r";
      CharacterCodes2[CharacterCodes2["s"] = 115] = "s";
      CharacterCodes2[CharacterCodes2["t"] = 116] = "t";
      CharacterCodes2[CharacterCodes2["u"] = 117] = "u";
      CharacterCodes2[CharacterCodes2["v"] = 118] = "v";
      CharacterCodes2[CharacterCodes2["w"] = 119] = "w";
      CharacterCodes2[CharacterCodes2["x"] = 120] = "x";
      CharacterCodes2[CharacterCodes2["y"] = 121] = "y";
      CharacterCodes2[CharacterCodes2["z"] = 122] = "z";
      CharacterCodes2[CharacterCodes2["A"] = 65] = "A";
      CharacterCodes2[CharacterCodes2["B"] = 66] = "B";
      CharacterCodes2[CharacterCodes2["C"] = 67] = "C";
      CharacterCodes2[CharacterCodes2["D"] = 68] = "D";
      CharacterCodes2[CharacterCodes2["E"] = 69] = "E";
      CharacterCodes2[CharacterCodes2["F"] = 70] = "F";
      CharacterCodes2[CharacterCodes2["G"] = 71] = "G";
      CharacterCodes2[CharacterCodes2["H"] = 72] = "H";
      CharacterCodes2[CharacterCodes2["I"] = 73] = "I";
      CharacterCodes2[CharacterCodes2["J"] = 74] = "J";
      CharacterCodes2[CharacterCodes2["K"] = 75] = "K";
      CharacterCodes2[CharacterCodes2["L"] = 76] = "L";
      CharacterCodes2[CharacterCodes2["M"] = 77] = "M";
      CharacterCodes2[CharacterCodes2["N"] = 78] = "N";
      CharacterCodes2[CharacterCodes2["O"] = 79] = "O";
      CharacterCodes2[CharacterCodes2["P"] = 80] = "P";
      CharacterCodes2[CharacterCodes2["Q"] = 81] = "Q";
      CharacterCodes2[CharacterCodes2["R"] = 82] = "R";
      CharacterCodes2[CharacterCodes2["S"] = 83] = "S";
      CharacterCodes2[CharacterCodes2["T"] = 84] = "T";
      CharacterCodes2[CharacterCodes2["U"] = 85] = "U";
      CharacterCodes2[CharacterCodes2["V"] = 86] = "V";
      CharacterCodes2[CharacterCodes2["W"] = 87] = "W";
      CharacterCodes2[CharacterCodes2["X"] = 88] = "X";
      CharacterCodes2[CharacterCodes2["Y"] = 89] = "Y";
      CharacterCodes2[CharacterCodes2["Z"] = 90] = "Z";
      CharacterCodes2[CharacterCodes2["asterisk"] = 42] = "asterisk";
      CharacterCodes2[CharacterCodes2["backslash"] = 92] = "backslash";
      CharacterCodes2[CharacterCodes2["closeBrace"] = 125] = "closeBrace";
      CharacterCodes2[CharacterCodes2["closeBracket"] = 93] = "closeBracket";
      CharacterCodes2[CharacterCodes2["colon"] = 58] = "colon";
      CharacterCodes2[CharacterCodes2["comma"] = 44] = "comma";
      CharacterCodes2[CharacterCodes2["dot"] = 46] = "dot";
      CharacterCodes2[CharacterCodes2["doubleQuote"] = 34] = "doubleQuote";
      CharacterCodes2[CharacterCodes2["minus"] = 45] = "minus";
      CharacterCodes2[CharacterCodes2["openBrace"] = 123] = "openBrace";
      CharacterCodes2[CharacterCodes2["openBracket"] = 91] = "openBracket";
      CharacterCodes2[CharacterCodes2["plus"] = 43] = "plus";
      CharacterCodes2[CharacterCodes2["slash"] = 47] = "slash";
      CharacterCodes2[CharacterCodes2["formFeed"] = 12] = "formFeed";
      CharacterCodes2[CharacterCodes2["tab"] = 9] = "tab";
    })(CharacterCodes || (CharacterCodes = {}));
  }
});

// node_modules/jsonc-parser/lib/esm/impl/string-intern.js
var cachedSpaces, maxCachedValues, cachedBreakLinesWithSpaces, supportedEols;
var init_string_intern = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/string-intern.js"() {
    cachedSpaces = new Array(20).fill(0).map((_, index) => {
      return " ".repeat(index);
    });
    maxCachedValues = 200;
    cachedBreakLinesWithSpaces = {
      " ": {
        "\n": new Array(maxCachedValues).fill(0).map((_, index) => {
          return "\n" + " ".repeat(index);
        }),
        "\r": new Array(maxCachedValues).fill(0).map((_, index) => {
          return "\r" + " ".repeat(index);
        }),
        "\r\n": new Array(maxCachedValues).fill(0).map((_, index) => {
          return "\r\n" + " ".repeat(index);
        })
      },
      "	": {
        "\n": new Array(maxCachedValues).fill(0).map((_, index) => {
          return "\n" + "	".repeat(index);
        }),
        "\r": new Array(maxCachedValues).fill(0).map((_, index) => {
          return "\r" + "	".repeat(index);
        }),
        "\r\n": new Array(maxCachedValues).fill(0).map((_, index) => {
          return "\r\n" + "	".repeat(index);
        })
      }
    };
    supportedEols = ["\n", "\r", "\r\n"];
  }
});

// node_modules/jsonc-parser/lib/esm/impl/format.js
function format2(documentText, range, options2) {
  let initialIndentLevel;
  let formatText;
  let formatTextStart;
  let rangeStart;
  let rangeEnd;
  if (range) {
    rangeStart = range.offset;
    rangeEnd = rangeStart + range.length;
    formatTextStart = rangeStart;
    while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {
      formatTextStart--;
    }
    let endOffset = rangeEnd;
    while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {
      endOffset++;
    }
    formatText = documentText.substring(formatTextStart, endOffset);
    initialIndentLevel = computeIndentLevel(formatText, options2);
  } else {
    formatText = documentText;
    initialIndentLevel = 0;
    formatTextStart = 0;
    rangeStart = 0;
    rangeEnd = documentText.length;
  }
  const eol = getEOL(options2, documentText);
  const eolFastPathSupported = supportedEols.includes(eol);
  let numberLineBreaks = 0;
  let indentLevel = 0;
  let indentValue;
  if (options2.insertSpaces) {
    indentValue = cachedSpaces[options2.tabSize || 4] ?? repeat(cachedSpaces[1], options2.tabSize || 4);
  } else {
    indentValue = "	";
  }
  const indentType = indentValue === "	" ? "	" : " ";
  let scanner = createScanner(formatText, false);
  let hasError = false;
  function newLinesAndIndent() {
    if (numberLineBreaks > 1) {
      return repeat(eol, numberLineBreaks) + repeat(indentValue, initialIndentLevel + indentLevel);
    }
    const amountOfSpaces = indentValue.length * (initialIndentLevel + indentLevel);
    if (!eolFastPathSupported || amountOfSpaces > cachedBreakLinesWithSpaces[indentType][eol].length) {
      return eol + repeat(indentValue, initialIndentLevel + indentLevel);
    }
    if (amountOfSpaces <= 0) {
      return eol;
    }
    return cachedBreakLinesWithSpaces[indentType][eol][amountOfSpaces];
  }
  function scanNext() {
    let token = scanner.scan();
    numberLineBreaks = 0;
    while (token === 15 || token === 14) {
      if (token === 14 && options2.keepLines) {
        numberLineBreaks += 1;
      } else if (token === 14) {
        numberLineBreaks = 1;
      }
      token = scanner.scan();
    }
    hasError = token === 16 || scanner.getTokenError() !== 0;
    return token;
  }
  const editOperations = [];
  function addEdit(text, startOffset, endOffset) {
    if (!hasError && (!range || startOffset < rangeEnd && endOffset > rangeStart) && documentText.substring(startOffset, endOffset) !== text) {
      editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });
    }
  }
  let firstToken = scanNext();
  if (options2.keepLines && numberLineBreaks > 0) {
    addEdit(repeat(eol, numberLineBreaks), 0, 0);
  }
  if (firstToken !== 17) {
    let firstTokenStart = scanner.getTokenOffset() + formatTextStart;
    let initialIndent = indentValue.length * initialIndentLevel < 20 && options2.insertSpaces ? cachedSpaces[indentValue.length * initialIndentLevel] : repeat(indentValue, initialIndentLevel);
    addEdit(initialIndent, formatTextStart, firstTokenStart);
  }
  while (firstToken !== 17) {
    let firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
    let secondToken = scanNext();
    let replaceContent = "";
    let needsLineBreak = false;
    while (numberLineBreaks === 0 && (secondToken === 12 || secondToken === 13)) {
      let commentTokenStart = scanner.getTokenOffset() + formatTextStart;
      addEdit(cachedSpaces[1], firstTokenEnd, commentTokenStart);
      firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
      needsLineBreak = secondToken === 12;
      replaceContent = needsLineBreak ? newLinesAndIndent() : "";
      secondToken = scanNext();
    }
    if (secondToken === 2) {
      if (firstToken !== 1) {
        indentLevel--;
      }
      ;
      if (options2.keepLines && numberLineBreaks > 0 || !options2.keepLines && firstToken !== 1) {
        replaceContent = newLinesAndIndent();
      } else if (options2.keepLines) {
        replaceContent = cachedSpaces[1];
      }
    } else if (secondToken === 4) {
      if (firstToken !== 3) {
        indentLevel--;
      }
      ;
      if (options2.keepLines && numberLineBreaks > 0 || !options2.keepLines && firstToken !== 3) {
        replaceContent = newLinesAndIndent();
      } else if (options2.keepLines) {
        replaceContent = cachedSpaces[1];
      }
    } else {
      switch (firstToken) {
        case 3:
        case 1:
          indentLevel++;
          if (options2.keepLines && numberLineBreaks > 0 || !options2.keepLines) {
            replaceContent = newLinesAndIndent();
          } else {
            replaceContent = cachedSpaces[1];
          }
          break;
        case 5:
          if (options2.keepLines && numberLineBreaks > 0 || !options2.keepLines) {
            replaceContent = newLinesAndIndent();
          } else {
            replaceContent = cachedSpaces[1];
          }
          break;
        case 12:
          replaceContent = newLinesAndIndent();
          break;
        case 13:
          if (numberLineBreaks > 0) {
            replaceContent = newLinesAndIndent();
          } else if (!needsLineBreak) {
            replaceContent = cachedSpaces[1];
          }
          break;
        case 6:
          if (options2.keepLines && numberLineBreaks > 0) {
            replaceContent = newLinesAndIndent();
          } else if (!needsLineBreak) {
            replaceContent = cachedSpaces[1];
          }
          break;
        case 10:
          if (options2.keepLines && numberLineBreaks > 0) {
            replaceContent = newLinesAndIndent();
          } else if (secondToken === 6 && !needsLineBreak) {
            replaceContent = "";
          }
          break;
        case 7:
        case 8:
        case 9:
        case 11:
        case 2:
        case 4:
          if (options2.keepLines && numberLineBreaks > 0) {
            replaceContent = newLinesAndIndent();
          } else {
            if ((secondToken === 12 || secondToken === 13) && !needsLineBreak) {
              replaceContent = cachedSpaces[1];
            } else if (secondToken !== 5 && secondToken !== 17) {
              hasError = true;
            }
          }
          break;
        case 16:
          hasError = true;
          break;
      }
      if (numberLineBreaks > 0 && (secondToken === 12 || secondToken === 13)) {
        replaceContent = newLinesAndIndent();
      }
    }
    if (secondToken === 17) {
      if (options2.keepLines && numberLineBreaks > 0) {
        replaceContent = newLinesAndIndent();
      } else {
        replaceContent = options2.insertFinalNewline ? eol : "";
      }
    }
    const secondTokenStart = scanner.getTokenOffset() + formatTextStart;
    addEdit(replaceContent, firstTokenEnd, secondTokenStart);
    firstToken = secondToken;
  }
  return editOperations;
}
function repeat(s, count) {
  let result = "";
  for (let i = 0; i < count; i++) {
    result += s;
  }
  return result;
}
function computeIndentLevel(content, options2) {
  let i = 0;
  let nChars = 0;
  const tabSize = options2.tabSize || 4;
  while (i < content.length) {
    let ch = content.charAt(i);
    if (ch === cachedSpaces[1]) {
      nChars++;
    } else if (ch === "	") {
      nChars += tabSize;
    } else {
      break;
    }
    i++;
  }
  return Math.floor(nChars / tabSize);
}
function getEOL(options2, text) {
  for (let i = 0; i < text.length; i++) {
    const ch = text.charAt(i);
    if (ch === "\r") {
      if (i + 1 < text.length && text.charAt(i + 1) === "\n") {
        return "\r\n";
      }
      return "\r";
    } else if (ch === "\n") {
      return "\n";
    }
  }
  return options2 && options2.eol || "\n";
}
function isEOL(text, offset) {
  return "\r\n".indexOf(text.charAt(offset)) !== -1;
}
var init_format = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/format.js"() {
    "use strict";
    init_scanner();
    init_string_intern();
  }
});

// node_modules/jsonc-parser/lib/esm/impl/parser.js
function parse(text, errors = [], options2 = ParseOptions.DEFAULT) {
  let currentProperty = null;
  let currentParent = [];
  const previousParents = [];
  function onValue(value) {
    if (Array.isArray(currentParent)) {
      currentParent.push(value);
    } else if (currentProperty !== null) {
      currentParent[currentProperty] = value;
    }
  }
  const visitor = {
    onObjectBegin: () => {
      const object = {};
      onValue(object);
      previousParents.push(currentParent);
      currentParent = object;
      currentProperty = null;
    },
    onObjectProperty: (name2) => {
      currentProperty = name2;
    },
    onObjectEnd: () => {
      currentParent = previousParents.pop();
    },
    onArrayBegin: () => {
      const array = [];
      onValue(array);
      previousParents.push(currentParent);
      currentParent = array;
      currentProperty = null;
    },
    onArrayEnd: () => {
      currentParent = previousParents.pop();
    },
    onLiteralValue: onValue,
    onError: (error, offset, length) => {
      errors.push({ error, offset, length });
    }
  };
  visit(text, visitor, options2);
  return currentParent[0];
}
function parseTree(text, errors = [], options2 = ParseOptions.DEFAULT) {
  let currentParent = { type: "array", offset: -1, length: -1, children: [], parent: void 0 };
  function ensurePropertyComplete(endOffset) {
    if (currentParent.type === "property") {
      currentParent.length = endOffset - currentParent.offset;
      currentParent = currentParent.parent;
    }
  }
  function onValue(valueNode) {
    currentParent.children.push(valueNode);
    return valueNode;
  }
  const visitor = {
    onObjectBegin: (offset) => {
      currentParent = onValue({ type: "object", offset, length: -1, parent: currentParent, children: [] });
    },
    onObjectProperty: (name2, offset, length) => {
      currentParent = onValue({ type: "property", offset, length: -1, parent: currentParent, children: [] });
      currentParent.children.push({ type: "string", value: name2, offset, length, parent: currentParent });
    },
    onObjectEnd: (offset, length) => {
      ensurePropertyComplete(offset + length);
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onArrayBegin: (offset, length) => {
      currentParent = onValue({ type: "array", offset, length: -1, parent: currentParent, children: [] });
    },
    onArrayEnd: (offset, length) => {
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onLiteralValue: (value, offset, length) => {
      onValue({ type: getNodeType(value), offset, length, parent: currentParent, value });
      ensurePropertyComplete(offset + length);
    },
    onSeparator: (sep, offset, length) => {
      if (currentParent.type === "property") {
        if (sep === ":") {
          currentParent.colonOffset = offset;
        } else if (sep === ",") {
          ensurePropertyComplete(offset);
        }
      }
    },
    onError: (error, offset, length) => {
      errors.push({ error, offset, length });
    }
  };
  visit(text, visitor, options2);
  const result = currentParent.children[0];
  if (result) {
    delete result.parent;
  }
  return result;
}
function findNodeAtLocation(root, path2) {
  if (!root) {
    return void 0;
  }
  let node = root;
  for (let segment of path2) {
    if (typeof segment === "string") {
      if (node.type !== "object" || !Array.isArray(node.children)) {
        return void 0;
      }
      let found = false;
      for (const propertyNode of node.children) {
        if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {
          node = propertyNode.children[1];
          found = true;
          break;
        }
      }
      if (!found) {
        return void 0;
      }
    } else {
      const index = segment;
      if (node.type !== "array" || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
        return void 0;
      }
      node = node.children[index];
    }
  }
  return node;
}
function visit(text, visitor, options2 = ParseOptions.DEFAULT) {
  const _scanner = createScanner(text, false);
  const _jsonPath = [];
  let suppressedCallbacks = 0;
  function toNoArgVisit(visitFunction) {
    return visitFunction ? () => suppressedCallbacks === 0 && visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? (arg) => suppressedCallbacks === 0 && visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : () => true;
  }
  function toOneArgVisitWithPath(visitFunction) {
    return visitFunction ? (arg) => suppressedCallbacks === 0 && visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice()) : () => true;
  }
  function toBeginVisit(visitFunction) {
    return visitFunction ? () => {
      if (suppressedCallbacks > 0) {
        suppressedCallbacks++;
      } else {
        let cbReturn = visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), () => _jsonPath.slice());
        if (cbReturn === false) {
          suppressedCallbacks = 1;
        }
      }
    } : () => true;
  }
  function toEndVisit(visitFunction) {
    return visitFunction ? () => {
      if (suppressedCallbacks > 0) {
        suppressedCallbacks--;
      }
      if (suppressedCallbacks === 0) {
        visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
      }
    } : () => true;
  }
  const onObjectBegin = toBeginVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toEndVisit(visitor.onObjectEnd), onArrayBegin = toBeginVisit(visitor.onArrayBegin), onArrayEnd = toEndVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
  const disallowComments = options2 && options2.disallowComments;
  const allowTrailingComma = options2 && options2.allowTrailingComma;
  function scanNext() {
    while (true) {
      const token = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError(
            14
            /* ParseErrorCode.InvalidUnicode */
          );
          break;
        case 5:
          handleError(
            15
            /* ParseErrorCode.InvalidEscapeCharacter */
          );
          break;
        case 3:
          handleError(
            13
            /* ParseErrorCode.UnexpectedEndOfNumber */
          );
          break;
        case 1:
          if (!disallowComments) {
            handleError(
              11
              /* ParseErrorCode.UnexpectedEndOfComment */
            );
          }
          break;
        case 2:
          handleError(
            12
            /* ParseErrorCode.UnexpectedEndOfString */
          );
          break;
        case 6:
          handleError(
            16
            /* ParseErrorCode.InvalidCharacter */
          );
          break;
      }
      switch (token) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError(
              10
              /* ParseErrorCode.InvalidCommentToken */
            );
          } else {
            onComment();
          }
          break;
        case 16:
          handleError(
            1
            /* ParseErrorCode.InvalidSymbol */
          );
          break;
        case 15:
        case 14:
          break;
        default:
          return token;
      }
    }
  }
  function handleError(error, skipUntilAfter = [], skipUntil = []) {
    onError(error);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      let token = _scanner.getToken();
      while (token !== 17) {
        if (skipUntilAfter.indexOf(token) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token) !== -1) {
          break;
        }
        token = scanNext();
      }
    }
  }
  function parseString(isValue) {
    const value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
      _jsonPath.push(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11:
        const tokenValue = _scanner.getTokenValue();
        let value = Number(tokenValue);
        if (isNaN(value)) {
          handleError(
            2
            /* ParseErrorCode.InvalidNumberFormat */
          );
          value = 0;
        }
        onLiteralValue(value);
        break;
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError(3, [], [
        2,
        5
        /* SyntaxKind.CommaToken */
      ]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue()) {
        handleError(4, [], [
          2,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
    } else {
      handleError(5, [], [
        2,
        5
        /* SyntaxKind.CommaToken */
      ]);
    }
    _jsonPath.pop();
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    let needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseProperty()) {
        handleError(4, [], [
          2,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError(7, [
        2
        /* SyntaxKind.CloseBraceToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    let isFirstElement = true;
    let needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (isFirstElement) {
        _jsonPath.push(0);
        isFirstElement = false;
      } else {
        _jsonPath[_jsonPath.length - 1]++;
      }
      if (!parseValue()) {
        handleError(4, [], [
          4,
          5
          /* SyntaxKind.CommaToken */
        ]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (!isFirstElement) {
      _jsonPath.pop();
    }
    if (_scanner.getToken() !== 4) {
      handleError(8, [
        4
        /* SyntaxKind.CloseBracketToken */
      ], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options2.allowEmptyContent) {
      return true;
    }
    handleError(4, [], []);
    return false;
  }
  if (!parseValue()) {
    handleError(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError(9, [], []);
  }
  return true;
}
function getNodeType(value) {
  switch (typeof value) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
    case "object": {
      if (!value) {
        return "null";
      } else if (Array.isArray(value)) {
        return "array";
      }
      return "object";
    }
    default:
      return "null";
  }
}
var ParseOptions;
var init_parser = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/parser.js"() {
    "use strict";
    init_scanner();
    (function(ParseOptions2) {
      ParseOptions2.DEFAULT = {
        allowTrailingComma: false
      };
    })(ParseOptions || (ParseOptions = {}));
  }
});

// node_modules/jsonc-parser/lib/esm/impl/edit.js
function setProperty(text, originalPath, value, options2) {
  const path2 = originalPath.slice();
  const errors = [];
  const root = parseTree(text, errors);
  let parent = void 0;
  let lastSegment = void 0;
  while (path2.length > 0) {
    lastSegment = path2.pop();
    parent = findNodeAtLocation(root, path2);
    if (parent === void 0 && value !== void 0) {
      if (typeof lastSegment === "string") {
        value = { [lastSegment]: value };
      } else {
        value = [value];
      }
    } else {
      break;
    }
  }
  if (!parent) {
    if (value === void 0) {
      throw new Error("Can not delete in empty document");
    }
    return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options2);
  } else if (parent.type === "object" && typeof lastSegment === "string" && Array.isArray(parent.children)) {
    const existing = findNodeAtLocation(parent, [lastSegment]);
    if (existing !== void 0) {
      if (value === void 0) {
        if (!existing.parent) {
          throw new Error("Malformed AST");
        }
        const propertyIndex = parent.children.indexOf(existing.parent);
        let removeBegin;
        let removeEnd = existing.parent.offset + existing.parent.length;
        if (propertyIndex > 0) {
          let previous = parent.children[propertyIndex - 1];
          removeBegin = previous.offset + previous.length;
        } else {
          removeBegin = parent.offset + 1;
          if (parent.children.length > 1) {
            let next = parent.children[1];
            removeEnd = next.offset;
          }
        }
        return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: "" }, options2);
      } else {
        return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options2);
      }
    } else {
      if (value === void 0) {
        return [];
      }
      const newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;
      const index = options2.getInsertionIndex ? options2.getInsertionIndex(parent.children.map((p) => p.children[0].value)) : parent.children.length;
      let edit2;
      if (index > 0) {
        let previous = parent.children[index - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      } else if (parent.children.length === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty };
      } else {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty + "," };
      }
      return withFormatting(text, edit2, options2);
    }
  } else if (parent.type === "array" && typeof lastSegment === "number" && Array.isArray(parent.children)) {
    const insertIndex = lastSegment;
    if (insertIndex === -1) {
      const newProperty = `${JSON.stringify(value)}`;
      let edit2;
      if (parent.children.length === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty };
      } else {
        const previous = parent.children[parent.children.length - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      }
      return withFormatting(text, edit2, options2);
    } else if (value === void 0 && parent.children.length >= 0) {
      const removalIndex = lastSegment;
      const toRemove = parent.children[removalIndex];
      let edit2;
      if (parent.children.length === 1) {
        edit2 = { offset: parent.offset + 1, length: parent.length - 2, content: "" };
      } else if (parent.children.length - 1 === removalIndex) {
        let previous = parent.children[removalIndex - 1];
        let offset = previous.offset + previous.length;
        let parentEndOffset = parent.offset + parent.length;
        edit2 = { offset, length: parentEndOffset - 2 - offset, content: "" };
      } else {
        edit2 = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: "" };
      }
      return withFormatting(text, edit2, options2);
    } else if (value !== void 0) {
      let edit2;
      const newProperty = `${JSON.stringify(value)}`;
      if (!options2.isArrayInsertion && parent.children.length > lastSegment) {
        const toModify = parent.children[lastSegment];
        edit2 = { offset: toModify.offset, length: toModify.length, content: newProperty };
      } else if (parent.children.length === 0 || lastSegment === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + "," };
      } else {
        const index = lastSegment > parent.children.length ? parent.children.length : lastSegment;
        const previous = parent.children[index - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      }
      return withFormatting(text, edit2, options2);
    } else {
      throw new Error(`Can not ${value === void 0 ? "remove" : options2.isArrayInsertion ? "insert" : "modify"} Array index ${insertIndex} as length is not sufficient`);
    }
  } else {
    throw new Error(`Can not add ${typeof lastSegment !== "number" ? "index" : "property"} to parent of type ${parent.type}`);
  }
}
function withFormatting(text, edit2, options2) {
  if (!options2.formattingOptions) {
    return [edit2];
  }
  let newText = applyEdit(text, edit2);
  let begin = edit2.offset;
  let end = edit2.offset + edit2.content.length;
  if (edit2.length === 0 || edit2.content.length === 0) {
    while (begin > 0 && !isEOL(newText, begin - 1)) {
      begin--;
    }
    while (end < newText.length && !isEOL(newText, end)) {
      end++;
    }
  }
  const edits = format2(newText, { offset: begin, length: end - begin }, { ...options2.formattingOptions, keepLines: false });
  for (let i = edits.length - 1; i >= 0; i--) {
    const edit3 = edits[i];
    newText = applyEdit(newText, edit3);
    begin = Math.min(begin, edit3.offset);
    end = Math.max(end, edit3.offset + edit3.length);
    end += edit3.content.length - edit3.length;
  }
  const editLength = text.length - (newText.length - end) - begin;
  return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];
}
function applyEdit(text, edit2) {
  return text.substring(0, edit2.offset) + edit2.content + text.substring(edit2.offset + edit2.length);
}
var init_edit = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/edit.js"() {
    "use strict";
    init_format();
    init_parser();
  }
});

// node_modules/jsonc-parser/lib/esm/main.js
function printParseErrorCode(code) {
  switch (code) {
    case 1:
      return "InvalidSymbol";
    case 2:
      return "InvalidNumberFormat";
    case 3:
      return "PropertyNameExpected";
    case 4:
      return "ValueExpected";
    case 5:
      return "ColonExpected";
    case 6:
      return "CommaExpected";
    case 7:
      return "CloseBraceExpected";
    case 8:
      return "CloseBracketExpected";
    case 9:
      return "EndOfFileExpected";
    case 10:
      return "InvalidCommentToken";
    case 11:
      return "UnexpectedEndOfComment";
    case 12:
      return "UnexpectedEndOfString";
    case 13:
      return "UnexpectedEndOfNumber";
    case 14:
      return "InvalidUnicode";
    case 15:
      return "InvalidEscapeCharacter";
    case 16:
      return "InvalidCharacter";
  }
  return "<unknown ParseErrorCode>";
}
function modify(text, path2, value, options2) {
  return setProperty(text, path2, value, options2);
}
function applyEdits(text, edits) {
  let sortedEdits = edits.slice(0).sort((a, b) => {
    const diff = a.offset - b.offset;
    if (diff === 0) {
      return a.length - b.length;
    }
    return diff;
  });
  let lastModifiedOffset = text.length;
  for (let i = sortedEdits.length - 1; i >= 0; i--) {
    let e = sortedEdits[i];
    if (e.offset + e.length <= lastModifiedOffset) {
      text = applyEdit(text, e);
    } else {
      throw new Error("Overlapping edit");
    }
    lastModifiedOffset = e.offset;
  }
  return text;
}
var ScanError, SyntaxKind, parse2, visit2, ParseErrorCode;
var init_main2 = __esm({
  "node_modules/jsonc-parser/lib/esm/main.js"() {
    "use strict";
    init_format();
    init_edit();
    init_scanner();
    init_parser();
    (function(ScanError2) {
      ScanError2[ScanError2["None"] = 0] = "None";
      ScanError2[ScanError2["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
      ScanError2[ScanError2["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
      ScanError2[ScanError2["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
      ScanError2[ScanError2["InvalidUnicode"] = 4] = "InvalidUnicode";
      ScanError2[ScanError2["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
      ScanError2[ScanError2["InvalidCharacter"] = 6] = "InvalidCharacter";
    })(ScanError || (ScanError = {}));
    (function(SyntaxKind2) {
      SyntaxKind2[SyntaxKind2["OpenBraceToken"] = 1] = "OpenBraceToken";
      SyntaxKind2[SyntaxKind2["CloseBraceToken"] = 2] = "CloseBraceToken";
      SyntaxKind2[SyntaxKind2["OpenBracketToken"] = 3] = "OpenBracketToken";
      SyntaxKind2[SyntaxKind2["CloseBracketToken"] = 4] = "CloseBracketToken";
      SyntaxKind2[SyntaxKind2["CommaToken"] = 5] = "CommaToken";
      SyntaxKind2[SyntaxKind2["ColonToken"] = 6] = "ColonToken";
      SyntaxKind2[SyntaxKind2["NullKeyword"] = 7] = "NullKeyword";
      SyntaxKind2[SyntaxKind2["TrueKeyword"] = 8] = "TrueKeyword";
      SyntaxKind2[SyntaxKind2["FalseKeyword"] = 9] = "FalseKeyword";
      SyntaxKind2[SyntaxKind2["StringLiteral"] = 10] = "StringLiteral";
      SyntaxKind2[SyntaxKind2["NumericLiteral"] = 11] = "NumericLiteral";
      SyntaxKind2[SyntaxKind2["LineCommentTrivia"] = 12] = "LineCommentTrivia";
      SyntaxKind2[SyntaxKind2["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
      SyntaxKind2[SyntaxKind2["LineBreakTrivia"] = 14] = "LineBreakTrivia";
      SyntaxKind2[SyntaxKind2["Trivia"] = 15] = "Trivia";
      SyntaxKind2[SyntaxKind2["Unknown"] = 16] = "Unknown";
      SyntaxKind2[SyntaxKind2["EOF"] = 17] = "EOF";
    })(SyntaxKind || (SyntaxKind = {}));
    parse2 = parse;
    visit2 = visit;
    (function(ParseErrorCode3) {
      ParseErrorCode3[ParseErrorCode3["InvalidSymbol"] = 1] = "InvalidSymbol";
      ParseErrorCode3[ParseErrorCode3["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
      ParseErrorCode3[ParseErrorCode3["PropertyNameExpected"] = 3] = "PropertyNameExpected";
      ParseErrorCode3[ParseErrorCode3["ValueExpected"] = 4] = "ValueExpected";
      ParseErrorCode3[ParseErrorCode3["ColonExpected"] = 5] = "ColonExpected";
      ParseErrorCode3[ParseErrorCode3["CommaExpected"] = 6] = "CommaExpected";
      ParseErrorCode3[ParseErrorCode3["CloseBraceExpected"] = 7] = "CloseBraceExpected";
      ParseErrorCode3[ParseErrorCode3["CloseBracketExpected"] = 8] = "CloseBracketExpected";
      ParseErrorCode3[ParseErrorCode3["EndOfFileExpected"] = 9] = "EndOfFileExpected";
      ParseErrorCode3[ParseErrorCode3["InvalidCommentToken"] = 10] = "InvalidCommentToken";
      ParseErrorCode3[ParseErrorCode3["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
      ParseErrorCode3[ParseErrorCode3["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
      ParseErrorCode3[ParseErrorCode3["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
      ParseErrorCode3[ParseErrorCode3["InvalidUnicode"] = 14] = "InvalidUnicode";
      ParseErrorCode3[ParseErrorCode3["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
      ParseErrorCode3[ParseErrorCode3["InvalidCharacter"] = 16] = "InvalidCharacter";
    })(ParseErrorCode || (ParseErrorCode = {}));
  }
});

// node_modules/vscode-uri/lib/esm/index.mjs
var LIB, URI2, Utils;
var init_esm = __esm({
  "node_modules/vscode-uri/lib/esm/index.mjs"() {
    (() => {
      "use strict";
      var t = { 470: (t2) => {
        function e2(t3) {
          if ("string" != typeof t3) throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
        }
        function r2(t3, e3) {
          for (var r3, n3 = "", i = 0, o = -1, s = 0, h = 0; h <= t3.length; ++h) {
            if (h < t3.length) r3 = t3.charCodeAt(h);
            else {
              if (47 === r3) break;
              r3 = 47;
            }
            if (47 === r3) {
              if (o === h - 1 || 1 === s) ;
              else if (o !== h - 1 && 2 === s) {
                if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                  if (n3.length > 2) {
                    var a = n3.lastIndexOf("/");
                    if (a !== n3.length - 1) {
                      -1 === a ? (n3 = "", i = 0) : i = (n3 = n3.slice(0, a)).length - 1 - n3.lastIndexOf("/"), o = h, s = 0;
                      continue;
                    }
                  } else if (2 === n3.length || 1 === n3.length) {
                    n3 = "", i = 0, o = h, s = 0;
                    continue;
                  }
                }
                e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i = 2);
              } else n3.length > 0 ? n3 += "/" + t3.slice(o + 1, h) : n3 = t3.slice(o + 1, h), i = h - o - 1;
              o = h, s = 0;
            } else 46 === r3 && -1 !== s ? ++s : s = -1;
          }
          return n3;
        }
        var n2 = { resolve: function() {
          for (var t3, n3 = "", i = false, o = arguments.length - 1; o >= -1 && !i; o--) {
            var s;
            o >= 0 ? s = arguments[o] : (void 0 === t3 && (t3 = process.cwd()), s = t3), e2(s), 0 !== s.length && (n3 = s + "/" + n3, i = 47 === s.charCodeAt(0));
          }
          return n3 = r2(n3, !i), i ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
        }, normalize: function(t3) {
          if (e2(t3), 0 === t3.length) return ".";
          var n3 = 47 === t3.charCodeAt(0), i = 47 === t3.charCodeAt(t3.length - 1);
          return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i && (t3 += "/"), n3 ? "/" + t3 : t3;
        }, isAbsolute: function(t3) {
          return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
        }, join: function() {
          if (0 === arguments.length) return ".";
          for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
            var i = arguments[r3];
            e2(i), i.length > 0 && (void 0 === t3 ? t3 = i : t3 += "/" + i);
          }
          return void 0 === t3 ? "." : n2.normalize(t3);
        }, relative: function(t3, r3) {
          if (e2(t3), e2(r3), t3 === r3) return "";
          if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return "";
          for (var i = 1; i < t3.length && 47 === t3.charCodeAt(i); ++i) ;
          for (var o = t3.length, s = o - i, h = 1; h < r3.length && 47 === r3.charCodeAt(h); ++h) ;
          for (var a = r3.length - h, c = s < a ? s : a, f = -1, u = 0; u <= c; ++u) {
            if (u === c) {
              if (a > c) {
                if (47 === r3.charCodeAt(h + u)) return r3.slice(h + u + 1);
                if (0 === u) return r3.slice(h + u);
              } else s > c && (47 === t3.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));
              break;
            }
            var l = t3.charCodeAt(i + u);
            if (l !== r3.charCodeAt(h + u)) break;
            47 === l && (f = u);
          }
          var g = "";
          for (u = i + f + 1; u <= o; ++u) u !== o && 47 !== t3.charCodeAt(u) || (0 === g.length ? g += ".." : g += "/..");
          return g.length > 0 ? g + r3.slice(h + f) : (h += f, 47 === r3.charCodeAt(h) && ++h, r3.slice(h));
        }, _makeLong: function(t3) {
          return t3;
        }, dirname: function(t3) {
          if (e2(t3), 0 === t3.length) return ".";
          for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t3.length - 1; s >= 1; --s) if (47 === (r3 = t3.charCodeAt(s))) {
            if (!o) {
              i = s;
              break;
            }
          } else o = false;
          return -1 === i ? n3 ? "/" : "." : n3 && 1 === i ? "//" : t3.slice(0, i);
        }, basename: function(t3, r3) {
          if (void 0 !== r3 && "string" != typeof r3) throw new TypeError('"ext" argument must be a string');
          e2(t3);
          var n3, i = 0, o = -1, s = true;
          if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
            if (r3.length === t3.length && r3 === t3) return "";
            var h = r3.length - 1, a = -1;
            for (n3 = t3.length - 1; n3 >= 0; --n3) {
              var c = t3.charCodeAt(n3);
              if (47 === c) {
                if (!s) {
                  i = n3 + 1;
                  break;
                }
              } else -1 === a && (s = false, a = n3 + 1), h >= 0 && (c === r3.charCodeAt(h) ? -1 == --h && (o = n3) : (h = -1, o = a));
            }
            return i === o ? o = a : -1 === o && (o = t3.length), t3.slice(i, o);
          }
          for (n3 = t3.length - 1; n3 >= 0; --n3) if (47 === t3.charCodeAt(n3)) {
            if (!s) {
              i = n3 + 1;
              break;
            }
          } else -1 === o && (s = false, o = n3 + 1);
          return -1 === o ? "" : t3.slice(i, o);
        }, extname: function(t3) {
          e2(t3);
          for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, h = t3.length - 1; h >= 0; --h) {
            var a = t3.charCodeAt(h);
            if (47 !== a) -1 === i && (o = false, i = h + 1), 46 === a ? -1 === r3 ? r3 = h : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);
            else if (!o) {
              n3 = h + 1;
              break;
            }
          }
          return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i);
        }, format: function(t3) {
          if (null === t3 || "object" != typeof t3) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
          return function(t4, e3) {
            var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
            return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
          }(0, t3);
        }, parse: function(t3) {
          e2(t3);
          var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (0 === t3.length) return r3;
          var n3, i = t3.charCodeAt(0), o = 47 === i;
          o ? (r3.root = "/", n3 = 1) : n3 = 0;
          for (var s = -1, h = 0, a = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f) if (47 !== (i = t3.charCodeAt(f))) -1 === a && (c = false, a = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);
          else if (!c) {
            h = f + 1;
            break;
          }
          return -1 === s || -1 === a || 0 === u || 1 === u && s === a - 1 && s === h + 1 ? -1 !== a && (r3.base = r3.name = 0 === h && o ? t3.slice(1, a) : t3.slice(h, a)) : (0 === h && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, a)) : (r3.name = t3.slice(h, s), r3.base = t3.slice(h, a)), r3.ext = t3.slice(s, a)), h > 0 ? r3.dir = t3.slice(0, h - 1) : o && (r3.dir = "/"), r3;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        n2.posix = n2, t2.exports = n2;
      } }, e = {};
      function r(n2) {
        var i = e[n2];
        if (void 0 !== i) return i.exports;
        var o = e[n2] = { exports: {} };
        return t[n2](o, o.exports, r), o.exports;
      }
      r.d = (t2, e2) => {
        for (var n2 in e2) r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
      }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      };
      var n = {};
      (() => {
        let t2;
        if (r.r(n), r.d(n, { URI: () => f, Utils: () => P }), "object" == typeof process) t2 = "win32" === process.platform;
        else if ("object" == typeof navigator) {
          let e3 = navigator.userAgent;
          t2 = e3.indexOf("Windows") >= 0;
        }
        const e2 = /^\w[\w\d+.-]*$/, i = /^\//, o = /^\/\//;
        function s(t3, r2) {
          if (!t3.scheme && r2) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t3.authority}", path: "${t3.path}", query: "${t3.query}", fragment: "${t3.fragment}"}`);
          if (t3.scheme && !e2.test(t3.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
          if (t3.path) {
            if (t3.authority) {
              if (!i.test(t3.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            } else if (o.test(t3.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
          }
        }
        const h = "", a = "/", c = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
        class f {
          static isUri(t3) {
            return t3 instanceof f || !!t3 && "string" == typeof t3.authority && "string" == typeof t3.fragment && "string" == typeof t3.path && "string" == typeof t3.query && "string" == typeof t3.scheme && "string" == typeof t3.fsPath && "function" == typeof t3.with && "function" == typeof t3.toString;
          }
          scheme;
          authority;
          path;
          query;
          fragment;
          constructor(t3, e3, r2, n2, i2, o2 = false) {
            "object" == typeof t3 ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = /* @__PURE__ */ function(t4, e4) {
              return t4 || e4 ? t4 : "file";
            }(t3, o2), this.authority = e3 || h, this.path = function(t4, e4) {
              switch (t4) {
                case "https":
                case "http":
                case "file":
                  e4 ? e4[0] !== a && (e4 = a + e4) : e4 = a;
              }
              return e4;
            }(this.scheme, r2 || h), this.query = n2 || h, this.fragment = i2 || h, s(this, o2));
          }
          get fsPath() {
            return m(this, false);
          }
          with(t3) {
            if (!t3) return this;
            let { scheme: e3, authority: r2, path: n2, query: i2, fragment: o2 } = t3;
            return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = h), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new l(e3, r2, n2, i2, o2);
          }
          static parse(t3, e3 = false) {
            const r2 = c.exec(t3);
            return r2 ? new l(r2[2] || h, C(r2[4] || h), C(r2[5] || h), C(r2[7] || h), C(r2[9] || h), e3) : new l(h, h, h, h, h);
          }
          static file(e3) {
            let r2 = h;
            if (t2 && (e3 = e3.replace(/\\/g, a)), e3[0] === a && e3[1] === a) {
              const t3 = e3.indexOf(a, 2);
              -1 === t3 ? (r2 = e3.substring(2), e3 = a) : (r2 = e3.substring(2, t3), e3 = e3.substring(t3) || a);
            }
            return new l("file", r2, e3, h, h);
          }
          static from(t3) {
            const e3 = new l(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);
            return s(e3, true), e3;
          }
          toString(t3 = false) {
            return y(this, t3);
          }
          toJSON() {
            return this;
          }
          static revive(t3) {
            if (t3) {
              if (t3 instanceof f) return t3;
              {
                const e3 = new l(t3);
                return e3._formatted = t3.external, e3._fsPath = t3._sep === u ? t3.fsPath : null, e3;
              }
            }
            return t3;
          }
        }
        const u = t2 ? 1 : void 0;
        class l extends f {
          _formatted = null;
          _fsPath = null;
          get fsPath() {
            return this._fsPath || (this._fsPath = m(this, false)), this._fsPath;
          }
          toString(t3 = false) {
            return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);
          }
          toJSON() {
            const t3 = { $mid: 1 };
            return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = u), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;
          }
        }
        const g = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
        function d(t3, e3, r2) {
          let n2, i2 = -1;
          for (let o2 = 0; o2 < t3.length; o2++) {
            const s2 = t3.charCodeAt(o2);
            if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2) -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), void 0 !== n2 && (n2 += t3.charAt(o2));
            else {
              void 0 === n2 && (n2 = t3.substr(0, o2));
              const e4 = g[s2];
              void 0 !== e4 ? (-1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n2 += e4) : -1 === i2 && (i2 = o2);
            }
          }
          return -1 !== i2 && (n2 += encodeURIComponent(t3.substring(i2))), void 0 !== n2 ? n2 : t3;
        }
        function p(t3) {
          let e3;
          for (let r2 = 0; r2 < t3.length; r2++) {
            const n2 = t3.charCodeAt(r2);
            35 === n2 || 63 === n2 ? (void 0 === e3 && (e3 = t3.substr(0, r2)), e3 += g[n2]) : void 0 !== e3 && (e3 += t3[r2]);
          }
          return void 0 !== e3 ? e3 : t3;
        }
        function m(e3, r2) {
          let n2;
          return n2 = e3.authority && e3.path.length > 1 && "file" === e3.scheme ? `//${e3.authority}${e3.path}` : 47 === e3.path.charCodeAt(0) && (e3.path.charCodeAt(1) >= 65 && e3.path.charCodeAt(1) <= 90 || e3.path.charCodeAt(1) >= 97 && e3.path.charCodeAt(1) <= 122) && 58 === e3.path.charCodeAt(2) ? r2 ? e3.path.substr(1) : e3.path[1].toLowerCase() + e3.path.substr(2) : e3.path, t2 && (n2 = n2.replace(/\//g, "\\")), n2;
        }
        function y(t3, e3) {
          const r2 = e3 ? p : d;
          let n2 = "", { scheme: i2, authority: o2, path: s2, query: h2, fragment: c2 } = t3;
          if (i2 && (n2 += i2, n2 += ":"), (o2 || "file" === i2) && (n2 += a, n2 += a), o2) {
            let t4 = o2.indexOf("@");
            if (-1 !== t4) {
              const e4 = o2.substr(0, t4);
              o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(":"), -1 === t4 ? n2 += r2(e4, false, false) : (n2 += r2(e4.substr(0, t4), false, false), n2 += ":", n2 += r2(e4.substr(t4 + 1), false, true)), n2 += "@";
            }
            o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(":"), -1 === t4 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t4), false, true), n2 += o2.substr(t4));
          }
          if (s2) {
            if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
              const t4 = s2.charCodeAt(1);
              t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);
            } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
              const t4 = s2.charCodeAt(0);
              t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);
            }
            n2 += r2(s2, true, false);
          }
          return h2 && (n2 += "?", n2 += r2(h2, false, false)), c2 && (n2 += "#", n2 += e3 ? c2 : d(c2, false, false)), n2;
        }
        function v(t3) {
          try {
            return decodeURIComponent(t3);
          } catch {
            return t3.length > 3 ? t3.substr(0, 3) + v(t3.substr(3)) : t3;
          }
        }
        const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
        function C(t3) {
          return t3.match(b) ? t3.replace(b, (t4) => v(t4)) : t3;
        }
        var A = r(470);
        const w = A.posix || A, x = "/";
        var P;
        !function(t3) {
          t3.joinPath = function(t4, ...e3) {
            return t4.with({ path: w.join(t4.path, ...e3) });
          }, t3.resolvePath = function(t4, ...e3) {
            let r2 = t4.path, n2 = false;
            r2[0] !== x && (r2 = x + r2, n2 = true);
            let i2 = w.resolve(r2, ...e3);
            return n2 && i2[0] === x && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });
          }, t3.dirname = function(t4) {
            if (0 === t4.path.length || t4.path === x) return t4;
            let e3 = w.dirname(t4.path);
            return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t4.with({ path: e3 });
          }, t3.basename = function(t4) {
            return w.basename(t4.path);
          }, t3.extname = function(t4) {
            return w.extname(t4.path);
          };
        }(P || (P = {}));
      })(), LIB = n;
    })();
    ({ URI: URI2, Utils } = LIB);
  }
});

// src/util/platform.ts
function getPlatform(process2) {
  let { platform: platform2 } = process2;
  if (platform2 === "win32") return 3 /* Windows */;
  if (platform2 === "darwin") return 1 /* Mac */;
  if (platform2 === "linux") return 2 /* Linux */;
  return 4 /* Unknown */;
}
var _platform, platform, isWindows, isMacintosh;
var init_platform = __esm({
  "src/util/platform.ts"() {
    "use strict";
    _platform = getPlatform(process);
    platform = _platform;
    isWindows = _platform === 3 /* Windows */;
    isMacintosh = _platform === 1 /* Mac */;
  }
});

// src/util/fs.ts
function watchFile(filepath, onChange, immediate = false) {
  let callback = debounce(onChange, 100);
  try {
    let watcher = fs.watch(filepath, {
      persistent: true,
      recursive: false,
      encoding: "utf8"
    }, () => {
      callback();
    });
    if (immediate) {
      setTimeout(onChange, 10);
    }
    return import_node4.Disposable.create(() => {
      callback.clear();
      watcher.close();
    });
  } catch (e) {
    return import_node4.Disposable.create(() => {
      callback.clear();
    });
  }
}
function loadJson(filepath) {
  try {
    let errors = [];
    let text = fs.readFileSync(filepath, "utf8");
    let data = parse2(text, errors, { allowTrailingComma: true });
    if (errors.length > 0) {
      logger3.error(`Error on parse json file ${filepath}`, errors);
    }
    return data ?? {};
  } catch (e) {
    return {};
  }
}
function writeJson(filepath, obj) {
  let dir = path.dirname(filepath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    logger3.info(`Creating directory ${dir}`);
  }
  fs.writeFileSync(filepath, JSON.stringify(toObject(obj), null, 2), "utf8");
}
async function statAsync(filepath) {
  let stat = null;
  try {
    stat = await (0, import_util.promisify)(fs.stat)(filepath);
  } catch (e) {
  }
  return stat;
}
function isDirectory(filepath) {
  if (!filepath || !path.isAbsolute(filepath) || !fs.existsSync(filepath)) return false;
  let stat = fs.statSync(filepath);
  return stat.isDirectory();
}
async function remove(filepath) {
  if (!filepath) return;
  try {
    await (0, import_util.promisify)(fs.rm)(filepath, { force: true, recursive: true });
  } catch (e) {
    return;
  }
}
async function getFileType(filepath) {
  try {
    const stat = await (0, import_util.promisify)(fs.lstat)(filepath);
    if (stat.isFile()) {
      return 1 /* File */;
    }
    if (stat.isDirectory()) {
      return 2 /* Directory */;
    }
    if (stat.isSymbolicLink()) {
      return 64 /* SymbolicLink */;
    }
    return 0 /* Unknown */;
  } catch (e) {
    return void 0;
  }
}
async function isGitIgnored(fullpath) {
  if (!fullpath) return false;
  let stat = await statAsync(fullpath);
  if (!stat || !stat.isFile()) return false;
  let root = null;
  try {
    let { stdout } = await (0, import_util.promisify)(exec)("git rev-parse --show-toplevel", { cwd: path.dirname(fullpath) });
    root = stdout.trim();
  } catch (e) {
  }
  if (!root) return false;
  let file = path.relative(root, fullpath);
  try {
    let { stdout } = await (0, import_util.promisify)(exec)(`git check-ignore ${file}`, { cwd: root });
    return stdout.trim() == file;
  } catch (e) {
  }
  return false;
}
function isFolderIgnored(folder, ignored) {
  if (isFalsyOrEmpty(ignored)) return false;
  return ignored.some((p) => sameFile(p, folder) || minimatch(folder, p, { dot: true }));
}
function resolveRoot(folder, subs, cwd2, bottomup = false, checkCwd = true, ignored = []) {
  let dir = normalizeFilePath(folder);
  if (checkCwd && cwd2 && isParentFolder(cwd2, dir, true) && !isFolderIgnored(cwd2, ignored) && inDirectory(cwd2, subs)) return cwd2;
  let parts = dir.split(path.sep);
  if (bottomup) {
    while (parts.length > 0) {
      let dir2 = parts.join(path.sep);
      if (!isFolderIgnored(dir2, ignored) && inDirectory(dir2, subs)) {
        return dir2;
      }
      parts.pop();
    }
    return null;
  } else {
    let curr = [parts.shift()];
    for (let part of parts) {
      curr.push(part);
      let dir2 = curr.join(path.sep);
      if (!isFolderIgnored(dir2, ignored) && inDirectory(dir2, subs)) {
        return dir2;
      }
    }
    return null;
  }
}
function checkFolder(dir, patterns, token) {
  return new Promise(async (resolve, reject) => {
    if (isFalsyOrEmpty(patterns)) return resolve(false);
    let disposable;
    const ac = new AbortController();
    if (token) {
      disposable = token.onCancellationRequested(() => {
        ac.abort();
        reject(new CancellationError());
      });
    }
    let find = false;
    let pattern = patterns.length == 1 ? patterns[0] : `{${patterns.join(",")}}`;
    let gl = new glob.Glob(pattern, {
      nosort: true,
      signal: ac.signal,
      ignore: ["node_modules/**", ".git/**"],
      dot: true,
      cwd: dir,
      nodir: true,
      absolute: false
    });
    try {
      for await (const _file of gl) {
        find = true;
        break;
      }
    } catch (e) {
      logger3.error(`Error on glob "${pattern}"`, dir, e);
    }
    resolve(find);
  });
}
function inDirectory(dir, subs) {
  try {
    let files = fs.readdirSync(dir);
    for (let pattern of subs) {
      let is_wildcard = pattern.includes("*");
      let res = is_wildcard ? minimatch.match(files, pattern, { nobrace: true, noext: true, nocomment: true, nonegate: true, dot: true }).length !== 0 : files.includes(pattern);
      if (res) return true;
    }
  } catch (e) {
  }
  return false;
}
function findMatch(dir, subs) {
  try {
    let files = fs.readdirSync(dir);
    for (let pattern of subs) {
      let isWildcard = pattern.includes("*");
      if (isWildcard) {
        let filtered = files.filter(minimatch.filter(pattern, { nobrace: true, noext: true, nocomment: true, nonegate: true, dot: true }));
        if (filtered.length > 0) return filtered[0];
      } else {
        let file = files.find((s) => s === pattern);
        if (file) return file;
      }
    }
  } catch (e) {
  }
  return void 0;
}
function findUp(name2, cwd2) {
  let root = path.parse(cwd2).root;
  let subs = toArray(name2);
  while (cwd2 && cwd2 !== root) {
    let find = findMatch(cwd2, subs);
    if (find) return path.join(cwd2, find);
    cwd2 = path.dirname(cwd2);
  }
  return null;
}
function readFile(fullpath, encoding2) {
  return new Promise((resolve, reject) => {
    fs.readFile(fullpath, encoding2, (err, content) => {
      if (err) reject(err);
      resolve(content);
    });
  });
}
function getFileLineCount(filepath) {
  let i;
  let count = 0;
  return new Promise((resolve, reject) => {
    fs.createReadStream(filepath).on("error", (e) => reject(e)).on("data", (chunk) => {
      for (i = 0; i < chunk.length; ++i) if (chunk[i] == 10) count++;
    }).on("end", () => resolve(count));
  });
}
function readFileLines(fullpath, start, end) {
  if (!fs.existsSync(fullpath)) {
    return Promise.reject(new Error(`file does not exist: ${fullpath}`));
  }
  let res = [];
  const input = fs.createReadStream(fullpath, { encoding: "utf8" });
  const rl = readline.createInterface({
    input,
    crlfDelay: Infinity,
    terminal: false
  });
  let n = 0;
  return new Promise((resolve, reject) => {
    rl.on("line", (line) => {
      if (n >= start && n <= end) {
        res.push(line);
      }
      if (n == end) {
        rl.close();
      }
      n = n + 1;
    });
    rl.on("close", () => {
      resolve(res);
      input.close();
    });
    rl.on("error", reject);
  });
}
function readFileLine(fullpath, count) {
  if (!fs.existsSync(fullpath)) return Promise.reject(new Error(`file does not exist: ${fullpath}`));
  const input = fs.createReadStream(fullpath, { encoding: "utf8" });
  const rl = readline.createInterface({ input, crlfDelay: Infinity, terminal: false });
  let n = 0;
  let result = "";
  return new Promise((resolve, reject) => {
    rl.on("line", (line) => {
      if (n == count) {
        result = line;
        rl.close();
        input.close();
      }
      n = n + 1;
    });
    rl.on("close", () => {
      resolve(result);
    });
    rl.on("error", reject);
  });
}
async function lineToLocation(fsPath2, match, text) {
  let uri = URI2.file(fsPath2).toString();
  if (!fs.existsSync(fsPath2)) return Location.create(uri, Range.create(0, 0, 0, 0));
  const rl = readline.createInterface({
    input: fs.createReadStream(fsPath2, { encoding: "utf8" })
  });
  let n = 0;
  let line = await new Promise((resolve) => {
    let find = false;
    rl.on("line", (line2) => {
      if (line2.includes(match)) {
        find = true;
        rl.removeAllListeners();
        rl.close();
        resolve(line2);
        return;
      }
      n = n + 1;
    });
    rl.on("close", () => {
      if (!find) resolve(void 0);
    });
  });
  if (line != null) {
    let character = text == null ? 0 : line.indexOf(text);
    if (character == 0) character = line.match(/^\s*/)[0].length;
    let end = Position.create(n, character + (text ? text.length : 0));
    return Location.create(uri, Range.create(Position.create(n, character), end));
  }
  return Location.create(uri, Range.create(0, 0, 0, 0));
}
function sameFile(fullpath, other, caseInsensitive) {
  caseInsensitive = typeof caseInsensitive == "boolean" ? caseInsensitive : isWindows || isMacintosh;
  if (!fullpath || !other) return false;
  fullpath = normalizeFilePath(fullpath);
  other = normalizeFilePath(other);
  if (caseInsensitive) return fullpath.toLowerCase() === other.toLowerCase();
  return fullpath === other;
}
function fileStartsWith(dir, pdir, caseInsensitive = isWindows || isMacintosh) {
  if (caseInsensitive) return dir.toLowerCase().startsWith(pdir.toLowerCase());
  return dir.startsWith(pdir);
}
async function writeFile(fullpath, content) {
  await (0, import_util.promisify)(fs.writeFile)(fullpath, content, { encoding: "utf8" });
}
function isFile(uri) {
  return uri.startsWith("file:");
}
function normalizeFilePath(filepath) {
  return URI2.file(path.resolve(path.normalize(filepath))).fsPath;
}
function isParentFolder(folder, filepath, checkEqual = false) {
  let pdir = normalizeFilePath(folder);
  let dir = normalizeFilePath(filepath);
  if (sameFile(pdir, dir)) return checkEqual ? true : false;
  return fileStartsWith(dir, pdir) && dir[pdir.length] == path.sep;
}
var logger3, exec, FileType;
var init_fs = __esm({
  "src/util/fs.ts"() {
    "use strict";
    init_main2();
    init_main();
    init_esm();
    init_logger();
    init_node();
    init_protocol();
    init_array();
    init_errors();
    init_node();
    init_object();
    init_platform();
    logger3 = createLogger("util-fs");
    exec = child_process.exec;
    FileType = /* @__PURE__ */ ((FileType2) => {
      FileType2[FileType2["Unknown"] = 0] = "Unknown";
      FileType2[FileType2["File"] = 1] = "File";
      FileType2[FileType2["Directory"] = 2] = "Directory";
      FileType2[FileType2["SymbolicLink"] = 64] = "SymbolicLink";
      return FileType2;
    })(FileType || {});
  }
});

// src/model/mru.ts
var Mru;
var init_mru = __esm({
  "src/model/mru.ts"() {
    "use strict";
    init_array();
    init_constants();
    init_fs();
    init_node();
    Mru = class {
      /**
       * @param {string} name unique name
       * @param {string} base? optional directory name, default to data root of coc.nvim
       */
      constructor(name2, base, maximum = 5e3) {
        this.maximum = maximum;
        this.file = path.join(base || dataHome, name2);
        let dir = path.dirname(this.file);
        fs.mkdirSync(dir, { recursive: true });
      }
      /**
       * Load lines from mru file
       */
      async load() {
        try {
          let lines = await readFileLines(this.file, 0, this.maximum);
          if (lines.length > this.maximum) {
            let newLines = lines.slice(0, this.maximum);
            await writeFile(this.file, newLines.join("\n"));
            return distinct(newLines);
          }
          return distinct(lines);
        } catch (e) {
          return [];
        }
      }
      loadSync() {
        try {
          let content = fs.readFileSync(this.file, "utf8");
          content = content.trim();
          return content.length ? content.trim().split("\n") : [];
        } catch (e) {
          return [];
        }
      }
      /**
       * Add item to mru file.
       */
      async add(item) {
        let buf;
        try {
          buf = fs.readFileSync(this.file);
          if (buf[0] === 239 && buf[1] === 187 && buf[2] === 191) {
            buf = buf.slice(3);
          }
          buf = Buffer.concat([Buffer.from(item, "utf8"), new Uint8Array([10]), buf]);
        } catch (e) {
          buf = Buffer.concat([Buffer.from(item, "utf8"), new Uint8Array([10])]);
        }
        await (0, import_util.promisify)(fs.writeFile)(this.file, buf);
      }
      /**
       * Remove item from mru file.
       */
      async remove(item) {
        let items = await this.load();
        let len = items.length;
        items = items.filter((s) => s != item);
        if (items.length != len) {
          await writeFile(this.file, items.join("\n"));
        }
      }
      /**
       * Remove the data file.
       */
      async clean() {
        try {
          await (0, import_util.promisify)(fs.unlink)(this.file);
        } catch (e) {
        }
      }
    };
  }
});

// src/configuration/types.ts
var ConfigurationUpdateTarget;
var init_types = __esm({
  "src/configuration/types.ts"() {
    "use strict";
    ConfigurationUpdateTarget = /* @__PURE__ */ ((ConfigurationUpdateTarget3) => {
      ConfigurationUpdateTarget3[ConfigurationUpdateTarget3["Global"] = 1] = "Global";
      ConfigurationUpdateTarget3[ConfigurationUpdateTarget3["Workspace"] = 2] = "Workspace";
      ConfigurationUpdateTarget3[ConfigurationUpdateTarget3["WorkspaceFolder"] = 3] = "WorkspaceFolder";
      return ConfigurationUpdateTarget3;
    })(ConfigurationUpdateTarget || {});
  }
});

// src/util/registry.ts
function convertScope(key, scope, defaultScope) {
  if (sourcePrefixes.some((p) => key.startsWith(p))) return 1 /* APPLICATION */;
  if (scope === "application" /* Application */) return 1 /* APPLICATION */;
  if (scope === "window" /* Window */) return 2 /* WINDOW */;
  if (scope === "resource" /* Resource */ || scope === "machine-overridable" /* MachineOverridable */) return 3 /* RESOURCE */;
  if (scope === "language-overridable" /* LanguageOverridable */) return 4 /* LANGUAGE_OVERRIDABLE */;
  return defaultScope;
}
function convertProperties(properties, defaultScope = 2 /* WINDOW */) {
  let obj = {};
  for (let [key, def] of Object.entries(toObject(properties))) {
    let data = deepClone(def);
    data.scope = convertScope(key, def.scope, defaultScope);
    obj[key] = data;
  }
  return obj;
}
var RegistryImpl, Registry, sourcePrefixes;
var init_registry = __esm({
  "src/util/registry.ts"() {
    "use strict";
    init_types();
    init_errors();
    init_is();
    init_object();
    RegistryImpl = class {
      constructor() {
        this.data = /* @__PURE__ */ new Map();
      }
      add(id2, data) {
        assert(typeof id2 === "string");
        assert(objectLiteral(data));
        assert(!this.data.has(id2));
        this.data.set(id2, data);
      }
      knows(id2) {
        return this.data.has(id2);
      }
      as(id2) {
        return this.data.get(id2) || null;
      }
    };
    Registry = new RegistryImpl();
    sourcePrefixes = ["coc.source.", "list.source."];
  }
});

// src/util/extensionRegistry.ts
function getExtensionDefinitions() {
  let obj = {};
  for (let extensionInfo of extensionRegistry.getExtensions().extensions) {
    let definitions = extensionInfo.definitions;
    Object.entries(toObject(definitions)).forEach(([key, val]) => {
      obj[key] = val;
    });
  }
  return obj;
}
function validRootPattern(rootPattern) {
  return rootPattern && typeof rootPattern.filetype === "string" && !isFalsyOrEmpty(rootPattern.patterns);
}
function validCommandContribution(cmd) {
  return cmd && typeof cmd.command === "string" && typeof cmd.title === "string";
}
function getProperties(configuration2) {
  let obj = {};
  if (Array.isArray(configuration2)) {
    for (let item of configuration2) {
      Object.assign(obj, toObject(item["properties"]));
    }
  } else if (objectLiteral(configuration2["properties"])) {
    obj = configuration2["properties"];
  }
  return obj;
}
function parseExtensionName(stack, level2 = 2) {
  let lines = toText(stack).split(/\r?\n/).slice(level2);
  if (lines.length === 0) return void 0;
  for (let line of lines) {
    let filepath;
    line = line.replace(/^\s*at\s*/, "");
    if (line.endsWith(")")) {
      let ms = line.match(/(\((.*?):\d+:\d+\))$/);
      if (ms) filepath = ms[2];
    } else {
      let ms = line.match(/(.*?):\d+:\d+$/);
      if (ms) filepath = ms[1];
    }
    if (!filepath || isParentFolder(pluginRoot, filepath)) continue;
    let find = extensionRegistry.resolveExtension(filepath);
    if (find) return find.name;
  }
  return "coc.nvim";
}
var Extensions, ExtensionRegistry, extensionRegistry;
var init_extensionRegistry = __esm({
  "src/util/extensionRegistry.ts"() {
    "use strict";
    init_array();
    init_constants();
    init_fs();
    init_is();
    init_node();
    init_object();
    init_registry();
    init_string();
    Extensions = {
      ExtensionContribution: "base.contributions.extensions"
    };
    ExtensionRegistry = class {
      constructor() {
        this.extensionsById = /* @__PURE__ */ new Map();
      }
      resolveExtension(filepath) {
        for (let item of this.extensionsById.values()) {
          if (item.filepath && sameFile(item.filepath, filepath)) {
            return item;
          }
          if (!item.name.startsWith("single-") && fs.existsSync(item.directory) && isParentFolder(fs.realpathSync(item.directory), filepath, false)) {
            return item;
          }
        }
        return void 0;
      }
      get onCommands() {
        let res = [];
        for (let item of this.extensionsById.values()) {
          let { commands, onCommands } = item;
          for (let cmd of onCommands) {
            if (typeof cmd === "string") {
              let find = commands.find((o) => o.command === cmd);
              let title = find == null ? "" : find.title;
              res.push({ id: cmd, title });
            }
          }
        }
        return res;
      }
      getCommandTitle(id2) {
        for (let item of this.extensionsById.values()) {
          for (let cmd of toArray(item.commands)) {
            if (cmd.command === id2) return cmd.title;
          }
        }
        return void 0;
      }
      get commands() {
        let res = [];
        for (let item of this.extensionsById.values()) {
          res.push(...toArray(item.commands).filter(validCommandContribution));
        }
        return res;
      }
      getRootPatternsByFiletype(filetype) {
        let res = [];
        for (let item of this.extensionsById.values()) {
          for (let p of toArray(item.rootPatterns).filter(validRootPattern)) {
            if (p.filetype === filetype) res.push(...p.patterns.filter((s) => typeof s === "string"));
          }
        }
        return res;
      }
      unregistExtension(id2) {
        this.extensionsById.delete(id2);
      }
      registerExtension(id2, info) {
        this.extensionsById.set(id2, info);
      }
      getExtension(id2) {
        return this.extensionsById.get(id2);
      }
      getExtensions() {
        return { extensions: this.extensionsById.values() };
      }
    };
    extensionRegistry = new ExtensionRegistry();
    Registry.add(Extensions.ExtensionContribution, extensionRegistry);
  }
});

// src/commands.ts
var logger4, CommandItem, extensionRegistry2, CommandManager, commands_default;
var init_commands = __esm({
  "src/commands.ts"() {
    "use strict";
    init_events();
    init_logger();
    init_mru();
    init_array();
    init_extensionRegistry();
    init_protocol();
    init_registry();
    init_string();
    logger4 = createLogger("commands");
    CommandItem = class {
      constructor(id2, impl, thisArg, internal) {
        this.id = id2;
        this.impl = impl;
        this.thisArg = thisArg;
        this.internal = internal;
      }
      execute(...args) {
        let { impl, thisArg } = this;
        return impl.apply(thisArg, toArray(args));
      }
      dispose() {
        this.thisArg = null;
        this.impl = null;
      }
    };
    extensionRegistry2 = Registry.as(Extensions.ExtensionContribution);
    CommandManager = class {
      constructor() {
        this.commands = /* @__PURE__ */ new Map();
        this.titles = /* @__PURE__ */ new Map();
        this.mru = new Mru("commands");
      }
      get commandList() {
        let res = [];
        for (let item of this.commands.values()) {
          if (!item.internal) {
            let { id: id2 } = item;
            let title = this.titles.get(id2) ?? extensionRegistry2.getCommandTitle(id2);
            res.push({ id: id2, title: toText(title) });
          }
        }
        return res;
      }
      dispose() {
        for (const registration of this.commands.values()) {
          registration.dispose();
        }
        this.commands.clear();
      }
      execute(command) {
        return this.executeCommand(command.command, ...command.arguments ?? []);
      }
      register(command, internal, description) {
        for (const id2 of Array.isArray(command.id) ? command.id : [command.id]) {
          this.registerCommand(id2, command.execute, command, internal);
          if (description) this.titles.set(id2, description);
        }
        return command;
      }
      has(id2) {
        return this.commands.has(id2);
      }
      unregister(id2) {
        let item = this.commands.get(id2);
        if (!item) return;
        item.dispose();
        this.commands.delete(id2);
      }
      /**
       * Registers a command that can be invoked via a keyboard shortcut,
       * a menu item, an action, or directly.
       *
       * Registering a command with an existing command identifier twice
       * will cause an error.
       * @param command A unique identifier for the command.
       * @param impl A command handler function.
       * @param thisArg The `this` context used when invoking the handler function.
       * @return Disposable which unregisters this command on disposal.
       */
      registerCommand(id2, impl, thisArg, internal = false) {
        if (id2.startsWith("_")) internal = true;
        if (this.commands.has(id2)) logger4.warn(`Command ${id2} already registered`);
        this.commands.set(id2, new CommandItem(id2, impl, thisArg, internal));
        return import_node4.Disposable.create(() => {
          this.commands.delete(id2);
        });
      }
      /**
       * Executes the command denoted by the given command identifier.
       *
       * * *Note 1:* When executing an editor command not all types are allowed to
       * be passed as arguments. Allowed are the primitive types `string`, `boolean`,
       * `number`, `undefined`, and `null`, as well as [`Position`](#Position), [`Range`](#Range), [`URI`](#URI) and [`Location`](#Location).
       * * *Note 2:* There are no restrictions when executing commands that have been contributed
       * by extensions.
       * @param command Identifier of the command to execute.
       * @param rest Parameters passed to the command function.
       * @return A promise that resolves to the returned value of the given command. `undefined` when
       * the command handler function doesn't return anything.
       */
      executeCommand(command, ...rest) {
        let cmd = this.commands.get(command);
        if (!cmd) throw new Error(`Command: ${command} not found`);
        return Promise.resolve(cmd.execute.apply(cmd, rest));
      }
      /**
       * Used for user invoked command.
       */
      async fireCommand(id2, ...args) {
        await events_default.fire("Command", [id2]);
        let start = Date.now();
        let res = await this.executeCommand(id2, ...args);
        if (args.length == 0) {
          await this.addRecent(id2, events_default.lastChangeTs > start);
        }
        return res;
      }
      async addRecent(cmd, repeat2) {
        await this.mru.add(cmd);
        if (repeat2) this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`, true);
      }
      async repeatCommand() {
        let mruList = await this.mru.load();
        let first = mruList[0];
        if (first) {
          await this.executeCommand(first);
          await this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`);
        }
      }
    };
    commands_default = new CommandManager();
  }
});

// src/util/numbers.ts
function toNumber(n, defaultValue2 = 0) {
  return number(n) ? n : defaultValue2;
}
function boolToNumber(val) {
  return val ? 1 : 0;
}
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
var init_numbers = __esm({
  "src/util/numbers.ts"() {
    "use strict";
    init_is();
  }
});

// src/model/outputChannel.ts
function escapeQuote(input) {
  return input.replace(/'/g, "''");
}
var BufferChannel;
var init_outputChannel = __esm({
  "src/model/outputChannel.ts"() {
    "use strict";
    BufferChannel = class {
      constructor(name2, nvim, onDispose) {
        this.name = name2;
        this.nvim = nvim;
        this.onDispose = onDispose;
        this.lines = [""];
        this._disposed = false;
        this.created = false;
      }
      get content() {
        return this.lines.join("\n");
      }
      _append(value) {
        let { nvim } = this;
        if (!nvim) return;
        let idx = this.lines.length - 1;
        let newlines = value.split(/\r?\n/);
        let lastline = this.lines[idx] + newlines[0];
        this.lines[idx] = lastline;
        let append = newlines.slice(1);
        this.lines = this.lines.concat(append);
        if (!this.created) return;
        nvim.pauseNotification();
        nvim.call("setbufline", [this.bufname, "$", lastline], true);
        if (append.length) {
          nvim.call("appendbufline", [this.bufname, "$", append], true);
        }
        nvim.resumeNotification(false, true);
      }
      append(value) {
        if (!this.validate()) return;
        this._append(value);
      }
      appendLine(value) {
        if (!this.validate()) return;
        this._append(value + "\n");
      }
      clear(keep) {
        let { nvim } = this;
        if (!this.validate() || !nvim) return;
        this.lines = keep ? this.lines.slice(-keep) : [];
        if (!this.created) return;
        nvim.pauseNotification();
        nvim.call("deletebufline", [this.bufname, 1, "$"], true);
        if (this.lines.length) {
          nvim.call("appendbufline", [this.bufname, "$", this.lines], true);
        }
        nvim.resumeNotification(true, true);
      }
      hide() {
        this.created = false;
        let name2 = escapeQuote(this.bufname);
        if (this.nvim) this.nvim.command(`exe 'silent! bwipeout! '.fnameescape('${name2}')`, true);
      }
      get bufname() {
        return `output:///${encodeURI(this.name)}`;
      }
      show(preserveFocus, cmd = "vs") {
        let { nvim } = this;
        if (!nvim) return;
        let name2 = escapeQuote(this.bufname);
        nvim.pauseNotification();
        nvim.command(`exe '${cmd} '.fnameescape('${name2}')`, true);
        if (preserveFocus) {
          nvim.command("wincmd p", true);
        }
        nvim.resumeNotification(true, true);
        this.created = true;
      }
      validate() {
        return !this._disposed;
      }
      dispose() {
        if (this.onDispose) this.onDispose();
        this._disposed = true;
        this.hide();
        this.lines = [];
      }
    };
  }
});

// src/core/channels.ts
var Channels, channels_default;
var init_channels = __esm({
  "src/core/channels.ts"() {
    "use strict";
    init_events();
    init_outputChannel();
    Channels = class {
      constructor() {
        this.outputChannels = /* @__PURE__ */ new Map();
        this.bufnrs = /* @__PURE__ */ new Map();
        this.disposable = events_default.on("BufUnload", (bufnr) => {
          let name2 = this.bufnrs.get(bufnr);
          if (name2) {
            let channel = this.outputChannels.get(name2);
            if (channel) channel.created = false;
          }
        });
      }
      /**
       * Get text document provider
       */
      getProvider(nvim) {
        let provider = {
          onDidChange: null,
          provideTextDocumentContent: async (uri) => {
            let channel = this.get(uri.path.slice(1));
            if (!channel) return "";
            nvim.pauseNotification();
            nvim.call("bufnr", ["%"], true);
            nvim.command("setlocal nospell nofoldenable nowrap noswapfile", true);
            nvim.command("setlocal buftype=nofile bufhidden=hide", true);
            nvim.command("setfiletype log", true);
            let res = await nvim.resumeNotification();
            this.bufnrs.set(res[0][0], channel.name);
            channel.created = true;
            return channel.content;
          }
        };
        return provider;
      }
      get names() {
        return Array.from(this.outputChannels.keys());
      }
      get(channelName) {
        return this.outputChannels.get(channelName);
      }
      create(name2, nvim) {
        if (this.outputChannels.has(name2)) return this.outputChannels.get(name2);
        let channel = new BufferChannel(name2, nvim, () => {
          this.outputChannels.delete(name2);
        });
        this.outputChannels.set(name2, channel);
        return channel;
      }
      show(name2, cmd, preserveFocus) {
        let channel = this.outputChannels.get(name2);
        if (!channel) return;
        channel.show(preserveFocus, cmd);
      }
      dispose() {
        this.disposable.dispose();
        for (let channel of this.outputChannels.values()) {
          channel.dispose();
        }
        this.outputChannels.clear();
      }
    };
    channels_default = new Channels();
  }
});

// src/model/dialog.ts
var Dialog;
var init_dialog = __esm({
  "src/model/dialog.ts"() {
    "use strict";
    init_protocol();
    init_events();
    init_util();
    init_array();
    Dialog = class {
      constructor(nvim, config) {
        this.nvim = nvim;
        this.config = config;
        this.disposables = [];
        this._onDidClose = new import_node4.Emitter();
        this.onDidClose = this._onDidClose.event;
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this.dispose();
            if (config.callback) config.callback(-1);
          }
        }, null, this.disposables);
        let btns = toArray(config.buttons).filter((o) => o.disabled != true);
        events_default.on("FloatBtnClick", (bufnr, idx) => {
          if (bufnr == this.bufnr) {
            this.dispose();
            if (config.callback) config.callback(btns[idx].index);
          }
        }, null, this.disposables);
      }
      get lines() {
        return [...this.config.content.split(/\r?\n/)];
      }
      async show(preferences) {
        let { nvim } = this;
        let { title, close, highlights, buttons } = this.config;
        let borderhighlight = this.config.borderhighlight || preferences.floatBorderHighlight;
        let highlight = this.config.highlight || preferences.floatHighlight;
        let opts = { maxwidth: preferences.maxWidth || 80 };
        if (title) opts.title = title;
        opts.close = +(close ?? 1);
        if (preferences.maxHeight) opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth) opts.maxWidth = preferences.maxWidth;
        if (highlight) opts.highlight = highlight;
        if (highlights) opts.highlights = highlights;
        if (borderhighlight) opts.borderhighlight = [borderhighlight];
        if (buttons) opts.buttons = buttons.filter((o) => !o.disabled).map((o) => o.text);
        if (preferences.rounded) opts.rounded = 1;
        if (Array.isArray(opts.buttons)) opts.getchar = 1;
        let [_winid, bufnr] = await nvim.call("coc#dialog#create_dialog", [this.lines, opts]);
        this.bufnr = bufnr;
        nvim.command("redraw", true);
      }
      get winid() {
        if (!this.bufnr) return Promise.resolve(null);
        return this.nvim.call("bufwinid", [this.bufnr]);
      }
      dispose() {
        this._onDidClose.fire();
        this.bufnr = void 0;
        disposeAll(this.disposables);
        this.disposables = [];
      }
    };
  }
});

// src/model/input.ts
var InputBox;
var init_input = __esm({
  "src/model/input.ts"() {
    "use strict";
    init_events();
    init_util();
    init_object();
    init_protocol();
    init_string();
    InputBox = class {
      constructor(nvim, defaultValue2) {
        this.nvim = nvim;
        this.disposables = [];
        this.accepted = false;
        this._disposed = false;
        // width, height, row, col
        this._dimension = [0, 0, 0, 0];
        this._onDidFinish = new import_node4.Emitter();
        this._onDidChange = new import_node4.Emitter();
        this.clear = false;
        this.onDidFinish = this._onDidFinish.event;
        this.onDidChange = this._onDidChange.event;
        this._input = defaultValue2;
        this.disposables.push(this._onDidFinish);
        this.disposables.push(this._onDidChange);
        let _title;
        Object.defineProperty(this, "title", {
          set: (newTitle) => {
            _title = newTitle;
            if (this._winid) nvim.call("coc#dialog#change_title", [this._winid, newTitle], true);
          },
          get: () => {
            return _title;
          }
        });
        let _loading = false;
        Object.defineProperty(this, "loading", {
          set: (loading) => {
            _loading = loading;
            if (this._winid) nvim.call("coc#dialog#change_loading", [this._winid, loading], true);
          },
          get: () => {
            return _loading;
          }
        });
        let _borderhighlight;
        Object.defineProperty(this, "borderhighlight", {
          set: (borderhighlight) => {
            _borderhighlight = borderhighlight;
            if (this._winid) nvim.call("coc#dialog#change_border_hl", [this._winid, borderhighlight], true);
          },
          get: () => {
            return _borderhighlight;
          }
        });
        Object.defineProperty(this, "value", {
          set: (value) => {
            value = toText(value);
            if (value !== this._input) {
              this.clearVirtualText();
              this._input = value;
              this.nvim.call("coc#dialog#change_input_value", [this.winid, this.bufnr, value], true);
              this._onDidChange.fire(value);
            }
          },
          get: () => {
            return this._input;
          }
        });
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this._bufnr) {
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("PromptInsert", (value, bufnr) => {
          if (bufnr == this._bufnr) {
            this._input = value;
            this.accepted = true;
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("TextChangedI", (bufnr, info) => {
          if (bufnr == this._bufnr && this._input !== info.line) {
            this.clearVirtualText();
            this._input = info.line;
            this._onDidChange.fire(info.line);
          }
        }, null, this.disposables);
      }
      clearVirtualText() {
        if (this.clear && this.bufnr) {
          this.clear = false;
          let buf = this.nvim.createBuffer(this.bufnr);
          buf.clearNamespace("input-box");
        }
      }
      get dimension() {
        let { _dimension } = this;
        return { width: _dimension[0], height: _dimension[1], row: _dimension[2], col: _dimension[3] };
      }
      get bufnr() {
        return this._bufnr;
      }
      get winid() {
        return this._winid;
      }
      async show(title, preferences) {
        this.title = title;
        this.borderhighlight = preferences.borderhighlight ?? "CocFloatBorder";
        this.loading = false;
        if (preferences.placeHolder && !this._input && !this.nvim.isVim) {
          this.clear = true;
        }
        let res = await this.nvim.call("coc#dialog#create_prompt_win", [title, this._input, omitUndefined(preferences)]);
        if (!res) throw new Error("Unable to open input window");
        this._bufnr = res[0];
        this._winid = res[1];
        this._dimension = res[2];
        return true;
      }
      dispose() {
        if (this._disposed) return;
        this._disposed = true;
        this.nvim.call("coc#float#close", [this._winid ?? -1], true);
        if (this.nvim.isVim) this.nvim.command(`silent! bd! ${this._bufnr}`, true);
        this._onDidFinish.fire(this.accepted ? this._input : null);
        this._winid = void 0;
        this._bufnr = void 0;
        disposeAll(this.disposables);
      }
    };
  }
});

// src/model/popup.ts
var Popup;
var init_popup = __esm({
  "src/model/popup.ts"() {
    "use strict";
    init_constants();
    Popup = class {
      constructor(nvim, winid, bufnr, linecount, _currIndex = 0) {
        this.nvim = nvim;
        this.winid = winid;
        this.bufnr = bufnr;
        this.linecount = linecount;
        this._currIndex = _currIndex;
      }
      get currIndex() {
        return this._currIndex;
      }
      close() {
        this.nvim.call("coc#float#close", [this.winid], true);
      }
      refreshScrollbar() {
        if (!isVim) this.nvim.call("coc#float#nvim_scrollbar", [this.winid], true);
      }
      execute(cmd) {
        this.nvim.call("win_execute", [this.winid, cmd], true);
      }
      async getWininfo() {
        return await this.nvim.call("coc#float#get_wininfo", [this.winid]);
      }
      /**
       * Simple scroll method, not consider wrapped lines.
       */
      async scrollForward() {
        let { nvim, bufnr } = this;
        let buf = nvim.createBuffer(bufnr);
        let total = await buf.length;
        let { botline } = await this.getWininfo();
        if (botline >= total || botline == 0) return;
        nvim.pauseNotification();
        this.setCursor(botline - 1);
        this.execute(`silent! noa setl scrolloff=0`);
        this.execute(`normal! ${botline}Gzt`);
        this.refreshScrollbar();
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      /**
       * Simple scroll method, not consider wrapped lines.
       */
      async scrollBackward() {
        let { nvim } = this;
        let { topline } = await this.getWininfo();
        if (topline == 1) return;
        nvim.pauseNotification();
        this.setCursor(topline - 1);
        this.execute(`normal! ${topline}Gzb`);
        this.refreshScrollbar();
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      /**
       * Move cursor and highlight.
       */
      setCursor(index, redraw = false) {
        let { nvim, bufnr, winid, linecount } = this;
        if (index < 0) {
          index = 0;
        } else if (index > linecount - 1) {
          index = linecount - 1;
        }
        this._currIndex = index;
        nvim.call("coc#dialog#set_cursor", [winid, bufnr, index + 1], true);
        if (redraw) {
          this.refreshScrollbar();
          nvim.command("redraw", true);
        }
      }
    };
  }
});

// src/model/menu.ts
function isMenuItem(item) {
  if (!item) return false;
  return typeof item.text === "string";
}
function toIndexText(n) {
  return n < 99 ? `${n + 1}. ` : "  ";
}
var Menu;
var init_menu = __esm({
  "src/model/menu.ts"() {
    "use strict";
    init_protocol();
    init_events();
    init_util();
    init_string();
    init_popup();
    Menu = class {
      constructor(nvim, config, token) {
        this.nvim = nvim;
        this.config = config;
        this.currIndex = 0;
        this.contentHeight = 0;
        this.disposables = [];
        this.keyMappings = /* @__PURE__ */ new Map();
        this.shortcutIndexes = /* @__PURE__ */ new Set();
        this._disposed = false;
        this._onDidClose = new import_node4.Emitter();
        this.onDidClose = this._onDidClose.event;
        this.total = config.items.length;
        if (token) {
          token.onCancellationRequested(() => {
            this._onDidClose.fire(-1);
            this.dispose();
          });
        }
        this.disposables.push(this._onDidClose);
        this.addKeymappings();
      }
      attachEvents() {
        events_default.on("InputChar", this.onInputChar.bind(this), null, this.disposables);
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this._onDidClose.fire(-1);
            this.dispose();
          }
        }, null, this.disposables);
      }
      addKeymappings() {
        let { nvim } = this;
        this.addKeys(["<esc>", "<C-c>"], () => {
          this._onDidClose.fire(-1);
          this.dispose();
        });
        this.addKeys(["\r", "<cr>"], () => {
          this.selectCurrent();
        });
        let setCursorIndex = (idx) => {
          nvim.pauseNotification();
          this.setCursor(idx + this.contentHeight);
          this.win.refreshScrollbar();
          nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        };
        this.addKeys("<C-f>", async () => {
          await this.win.scrollForward();
        });
        this.addKeys("<C-b>", async () => {
          await this.win.scrollBackward();
        });
        this.addKeys(["j", "<C-j>", "<down>", "<tab>", "<C-n>"], () => {
          let idx = this.currIndex == this.total - 1 ? 0 : this.currIndex + 1;
          setCursorIndex(idx);
        });
        this.addKeys(["k", "<C-k>", "<up>", "<s-tab>", "<C-p>"], () => {
          let idx = this.currIndex == 0 ? this.total - 1 : this.currIndex - 1;
          setCursorIndex(idx);
        });
        this.addKeys(["g"], () => {
          setCursorIndex(0);
        });
        this.addKeys(["G"], () => {
          setCursorIndex(this.total - 1);
        });
        let timer;
        let firstNumber;
        const choose = (n) => {
          let disabled = this.isDisabled(n);
          if (disabled) return;
          this._onDidClose.fire(n);
          this.dispose();
        };
        this.addKeys(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], (character) => {
          if (timer) clearTimeout(timer);
          let n = parseInt(character, 10);
          if (isNaN(n) || n > this.total) return;
          if (firstNumber == null && n == 0) return;
          if (firstNumber) {
            let count = firstNumber * 10 + n;
            firstNumber = void 0;
            choose(count - 1);
            return;
          }
          if (this.total < 10 || n * 10 > this.total) {
            choose(n - 1);
            return;
          }
          timer = setTimeout(async () => {
            choose(n - 1);
          }, 200);
          firstNumber = n;
        });
        if (this.config.shortcuts) {
          this.addShortcuts(choose);
        }
      }
      addShortcuts(choose) {
        let { items } = this.config;
        let texts = items.map((o) => {
          return isMenuItem(o) ? o.text : o;
        });
        texts.forEach((text, idx) => {
          if (text.length) {
            let s = text[0];
            if (isAlphabet(s.charCodeAt(0)) && !this.keyMappings.has(s)) {
              this.shortcutIndexes.add(idx);
              this.addKeys(s, () => {
                choose(idx);
              });
            }
          }
        });
      }
      isDisabled(idx) {
        let { items } = this.config;
        let item = items[idx];
        if (isMenuItem(item) && item.disabled) {
          return true;
        }
        return false;
      }
      async show(preferences = {}) {
        let { nvim, shortcutIndexes } = this;
        let { title, items, borderhighlight, position, content } = this.config;
        let opts = {};
        if (title) opts.title = title;
        if (position === "center") opts.relative = "editor";
        if (preferences.maxHeight) opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth) opts.maxWidth = preferences.maxWidth;
        if (preferences.floatHighlight) opts.highlight = preferences.floatHighlight;
        if (borderhighlight) {
          opts.borderhighlight = borderhighlight;
        } else if (preferences.floatBorderHighlight) {
          opts.borderhighlight = preferences.floatBorderHighlight;
        }
        if (preferences.rounded) opts.rounded = 1;
        if (typeof content === "string") opts.content = content;
        if (preferences.confirmKey) {
          this.addKeys(preferences.confirmKey, () => {
            this.selectCurrent();
          });
        }
        let highlights = [];
        let lines = items.map((v, i) => {
          let text = isMenuItem(v) ? v.text : v;
          let pre = toIndexText(i);
          if (shortcutIndexes.has(i)) {
            highlights.push({
              lnum: i,
              hlGroup: preferences.shortcutHighlight || "MoreMsg",
              colStart: byteLength(pre),
              colEnd: byteLength(pre) + 1
            });
          }
          return pre + text.trim();
        });
        lines.forEach((line, i) => {
          let item = items[i];
          if (isMenuItem(item) && item.disabled) {
            highlights.push({
              hlGroup: "CocDisabled",
              lnum: i,
              colStart: 0,
              colEnd: byteLength(line)
            });
          }
        });
        if (highlights.length) opts.highlights = highlights;
        let [winid, bufnr, contentHeight] = await nvim.call("coc#dialog#create_menu", [lines, opts]);
        nvim.command("redraw", true);
        if (this._disposed) return;
        this.win = new Popup(nvim, winid, bufnr, lines.length + contentHeight, contentHeight);
        this.bufnr = bufnr;
        this.contentHeight = contentHeight;
        this.attachEvents();
        nvim.call("coc#prompt#start_prompt", ["menu"], true);
      }
      selectCurrent() {
        if (this.isDisabled(this.currIndex)) {
          let item = this.config.items[this.currIndex];
          if (item.disabled["reason"]) {
            this.nvim.outWriteLine(`Item disabled: ${item.disabled["reason"]}`);
          }
          return;
        }
        this._onDidClose.fire(this.currIndex);
        this.dispose();
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
      }
      dispose() {
        if (this._disposed) return;
        this._disposed = true;
        disposeAll(this.disposables);
        this.shortcutIndexes.clear();
        this.keyMappings.clear();
        this.nvim.call("coc#prompt#stop_prompt", ["menu"], true);
        this.win?.close();
        this.bufnr = void 0;
        this.win = void 0;
      }
      async onInputChar(session, character) {
        if (session != "menu" || !this.win) return;
        let fn = this.keyMappings.get(character);
        if (fn) await Promise.resolve(fn(character));
      }
      setCursor(index) {
        this.currIndex = index - this.contentHeight;
        this.win.setCursor(index);
      }
      addKeys(keys, fn) {
        if (Array.isArray(keys)) {
          for (let key of keys) {
            this.keyMappings.set(key, fn);
          }
        } else {
          this.keyMappings.set(keys, fn);
        }
      }
    };
  }
});

// src/model/picker.ts
function toPickerItems(items) {
  return items.map((item) => typeof item === "string" ? { label: item } : item);
}
var Picker;
var init_picker = __esm({
  "src/model/picker.ts"() {
    "use strict";
    init_events();
    init_util();
    init_protocol();
    init_string();
    init_popup();
    Picker = class {
      constructor(nvim, config, token) {
        this.nvim = nvim;
        this.config = config;
        this.picked = /* @__PURE__ */ new Set();
        this.disposables = [];
        this.keyMappings = /* @__PURE__ */ new Map();
        this._onDidClose = new import_node4.Emitter();
        this.onDidClose = this._onDidClose.event;
        for (let i = 0; i < config.items.length; i++) {
          let item = config.items[i];
          if (item.picked) this.picked.add(i);
        }
        this.total = config.items.length;
        if (token) {
          token.onCancellationRequested(() => {
            this.win?.close();
          });
        }
        this.disposables.push(this._onDidClose);
      }
      get currIndex() {
        return this.win ? this.win.currIndex : 0;
      }
      attachEvents() {
        events_default.on("InputChar", this.onInputChar.bind(this), null, this.disposables);
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this._onDidClose.fire(void 0);
            this.bufnr = void 0;
            this.win = void 0;
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("FloatBtnClick", (bufnr, idx) => {
          if (bufnr != this.bufnr) return;
          if (idx == 0) {
            let selected = Array.from(this.picked);
            this._onDidClose.fire(selected.length > 0 ? selected : void 0);
          } else {
            this._onDidClose.fire(void 0);
          }
          this.dispose();
        }, null, this.disposables);
        this.addKeymappings();
      }
      addKeymappings() {
        let { nvim } = this;
        const toggleSelect = (idx) => {
          if (this.picked.has(idx)) {
            this.picked.delete(idx);
          } else {
            this.picked.add(idx);
          }
        };
        this.addKeys("<LeftRelease>", async () => {
          let [winid, lnum, col] = await nvim.call("coc#ui#get_mouse");
          nvim.pauseNotification();
          if (winid == this.win.winid) {
            if (col <= 3) {
              toggleSelect(lnum - 1);
              this.changeLine(lnum - 1);
            } else {
              this.win.setCursor(lnum - 1);
            }
          }
          nvim.call("win_gotoid", [winid], true);
          nvim.call("cursor", [lnum, col], true);
          nvim.call("coc#float#nvim_float_click", [], true);
          nvim.command("redraw", true);
          await nvim.resumeNotification();
        });
        this.addKeys(["<esc>", "<C-c>"], () => {
          this._onDidClose.fire(void 0);
          this.dispose();
        });
        this.addKeys("<cr>", () => {
          if (this.picked.size == 0) {
            this._onDidClose.fire(void 0);
          } else {
            let selected = Array.from(this.picked);
            this._onDidClose.fire(selected);
          }
          this.dispose();
        });
        this.addKeys(["j", "<down>", "<tab>", "<C-n>"], () => {
          this.win.setCursor(this.currIndex + 1, true);
        });
        this.addKeys(["k", "<up>", "<s-tab>", "<C-p>"], () => {
          this.win.setCursor(this.currIndex - 1, true);
        });
        this.addKeys(["g"], () => {
          this.win.setCursor(0, true);
        });
        this.addKeys(["G"], () => {
          this.win.setCursor(this.total - 1, true);
        });
        this.addKeys(" ", async () => {
          let idx = this.currIndex;
          toggleSelect(idx);
          nvim.pauseNotification();
          this.changeLine(idx);
          this.win.setCursor(this.currIndex + 1);
          nvim.command("redraw", true);
          await nvim.resumeNotification();
        });
        this.addKeys("<C-f>", async () => {
          await this.win.scrollForward();
        });
        this.addKeys("<C-b>", async () => {
          await this.win.scrollBackward();
        });
      }
      async show(preferences = {}) {
        let { nvim } = this;
        let { title, items } = this.config;
        let opts = { close: 1, cursorline: 1 };
        if (preferences.maxHeight) opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth) opts.maxWidth = preferences.maxWidth;
        if (title) opts.title = title;
        if (preferences.floatHighlight) opts.highlight = preferences.floatHighlight;
        if (preferences.floatBorderHighlight) opts.borderhighlight = [preferences.floatBorderHighlight];
        if (preferences.pickerButtons) {
          let shortcut = preferences.pickerButtonShortcut;
          opts.buttons = ["Submit" + (shortcut ? " <cr>" : ""), "Cancel" + (shortcut ? " <esc>" : "")];
        }
        if (preferences.rounded) opts.rounded = 1;
        if (preferences.confirmKey && preferences.confirmKey != "<cr>") {
          this.addKeys(preferences.confirmKey, () => {
            this._onDidClose.fire(void 0);
            this.dispose();
          });
        }
        let lines = [];
        let highlights = [];
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          let line = `[${item.picked ? "x" : " "}] ${item.label}`;
          if (item.description) {
            let start = byteLength(line);
            line = line + ` ${item.description}`;
            highlights.push({ hlGroup: "Comment", lnum: i, colStart: start, colEnd: byteLength(line) });
          }
          lines.push(line);
        }
        if (highlights.length) opts.highlights = highlights;
        let res = await nvim.call("coc#dialog#create_dialog", [lines, opts]);
        this.win = new Popup(nvim, res[0], res[1], lines.length);
        this.bufnr = res[1];
        nvim.call("coc#prompt#start_prompt", ["picker"], true);
        this.attachEvents();
        this.win.setCursor(0, true);
        return res[0];
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
      }
      dispose() {
        this.picked.clear();
        this.keyMappings.clear();
        disposeAll(this.disposables);
        this.nvim.call("coc#prompt#stop_prompt", ["picker"], true);
        this.win?.close();
        this.win = void 0;
      }
      async onInputChar(session, character) {
        if (session != "picker" || !this.win) return;
        let fn = this.keyMappings.get(character);
        if (fn) await Promise.resolve(fn(character));
      }
      changeLine(index) {
        let { nvim } = this;
        let item = this.config.items[index];
        if (!item) return;
        let line = `[${this.picked.has(index) ? "x" : " "}] ${item.label}`;
        let col = byteLength(line);
        if (item.description) line = line + ` ${item.description}`;
        nvim.call("setbufline", [this.bufnr, index + 1, line], true);
        let buf = nvim.createBuffer(this.bufnr);
        buf.addHighlight({ hlGroup: "Comment", line: index, srcId: 1, colStart: col, colEnd: -1 });
      }
      addKeys(keys, fn) {
        if (Array.isArray(keys)) {
          for (let key of keys) {
            this.keyMappings.set(key, fn);
          }
        } else {
          this.keyMappings.set(keys, fn);
        }
      }
    };
  }
});

// src/util/filter.ts
function initTable() {
  const table = [];
  const row = [];
  for (let i = 0; i <= _maxLen; i++) {
    row[i] = 0;
  }
  for (let i = 0; i <= _maxLen; i++) {
    table.push(row.slice(0));
  }
  return table;
}
function initArr(maxLen) {
  const row = [];
  for (let i = 0; i <= maxLen; i++) {
    row[i] = 0;
  }
  return row;
}
function isUpperCaseAtPos(pos, word, wordLow) {
  return word[pos] !== wordLow[pos];
}
function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options2) {
  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options2);
}
function fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options2) {
  let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options2);
  if (top && !aggressive) {
    return top;
  }
  if (pattern.length >= 3) {
    const tries = Math.min(7, pattern.length - 1);
    for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {
      const newPattern = nextTypoPermutation(pattern, movingPatternPos);
      if (newPattern) {
        const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options2);
        if (candidate) {
          candidate[0] -= 3;
          if (!top || candidate[0] > top[0]) {
            top = candidate;
          }
        }
      }
    }
  }
  return top;
}
function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, options2 = { boostFullMatch: true, firstMatchCanBeWeak: false }) {
  const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;
  const wordLen = word.length > _maxLen ? _maxLen : word.length;
  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {
    return void 0;
  }
  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {
    return void 0;
  }
  _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);
  let row = 1;
  let column = 1;
  let patternPos = patternStart;
  let wordPos = wordStart;
  const hasStrongFirstMatch = [false];
  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {
    const minWordMatchPos = _minWordMatchPos[patternPos];
    const maxWordMatchPos = _maxWordMatchPos[patternPos];
    const nextMaxWordMatchPos = patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen;
    for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {
      let score3 = Number.MIN_SAFE_INTEGER;
      let canComeDiag = false;
      if (wordPos <= maxWordMatchPos) {
        score3 = _doScore(
          pattern,
          patternLow,
          patternPos,
          patternStart,
          word,
          wordLow,
          wordPos,
          wordLen,
          wordStart,
          _diag[row - 1][column - 1] === 0,
          hasStrongFirstMatch
        );
      }
      let diagScore = 0;
      canComeDiag = true;
      diagScore = score3 + _table[row - 1][column - 1];
      const canComeLeft = wordPos > minWordMatchPos;
      const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0;
      const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;
      const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0;
      if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {
        _table[row][column] = leftLeftScore;
        _arrows[row][column] = 3 /* LeftLeft */;
        _diag[row][column] = 0;
      } else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {
        _table[row][column] = leftScore;
        _arrows[row][column] = 2 /* Left */;
        _diag[row][column] = 0;
      } else {
        _table[row][column] = diagScore;
        _arrows[row][column] = 1 /* Diag */;
        _diag[row][column] = _diag[row - 1][column - 1] + 1;
      }
    }
  }
  if (!hasStrongFirstMatch[0] && !options2.firstMatchCanBeWeak) {
    return void 0;
  }
  row--;
  column--;
  const result = [_table[row][column], wordStart];
  let backwardsDiagLength = 0;
  let maxMatchColumn = 0;
  while (row >= 1) {
    let diagColumn = column;
    do {
      const arrow = _arrows[row][diagColumn];
      if (arrow === 3 /* LeftLeft */) {
        diagColumn = diagColumn - 2;
      } else if (arrow === 2 /* Left */) {
        diagColumn = diagColumn - 1;
      } else {
        break;
      }
    } while (diagColumn >= 1);
    if (backwardsDiagLength > 1 && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) && backwardsDiagLength + 1 > _diag[row][diagColumn]) {
      diagColumn = column;
    }
    if (diagColumn === column) {
      backwardsDiagLength++;
    } else {
      backwardsDiagLength = 1;
    }
    if (!maxMatchColumn) {
      maxMatchColumn = diagColumn;
    }
    row--;
    column = diagColumn - 1;
    result.push(column);
  }
  if (wordLen === patternLen && options2.boostFullMatch) {
    result[0] += 2;
  }
  const skippedCharsCount = maxMatchColumn - patternLen;
  result[0] -= skippedCharsCount;
  return result;
}
function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options2) {
  const max = Math.min(13, pattern.length);
  for (; patternPos < max; patternPos++) {
    const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options2);
    if (result) {
      return result;
    }
  }
  return [0, wordPos];
}
function _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {
  if (patternLow[patternPos] !== wordLow[wordPos]) {
    return Number.MIN_SAFE_INTEGER;
  }
  let score3 = 1;
  let isGapLocation = false;
  if (wordPos === patternPos - patternStart) {
    score3 = pattern[patternPos] === word[wordPos] ? 7 : 5;
  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {
    score3 = pattern[patternPos] === word[wordPos] ? 7 : 5;
    isGapLocation = true;
  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {
    score3 = 5;
  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {
    score3 = 5;
    isGapLocation = true;
  }
  if (score3 > 1 && patternPos === patternStart) {
    outFirstMatchStrong[0] = true;
  }
  if (!isGapLocation) {
    isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);
  }
  if (patternPos === patternStart) {
    if (wordPos > wordStart) {
      score3 -= isGapLocation ? 3 : 5;
    }
  } else {
    if (newMatchStart) {
      score3 += isGapLocation ? 2 : 0;
    } else {
      score3 += isGapLocation ? 0 : 1;
    }
  }
  if (wordPos + 1 === wordLen) {
    score3 -= isGapLocation ? 3 : 5;
  }
  return score3;
}
function isSeparatorAtPos(value, index) {
  const code = value.codePointAt(index);
  switch (code) {
    case 95 /* Underline */:
    case 45 /* Dash */:
    case 46 /* Period */:
    case 32 /* Space */:
    case 47 /* Slash */:
    case 92 /* Backslash */:
    case 39 /* SingleQuote */:
    case 34 /* DoubleQuote */:
    case 58 /* Colon */:
    case 36 /* DollarSign */:
    case 60 /* LessThan */:
    case 62 /* GreaterThan */:
    case 40 /* OpenParen */:
    case 41 /* CloseParen */:
    case 91 /* OpenSquareBracket */:
    case 93 /* CloseSquareBracket */:
    case 123 /* OpenCurlyBrace */:
    case 125 /* CloseCurlyBrace */:
      return true;
    case void 0:
      return false;
    default:
      if (isEmojiImprecise(code)) {
        return true;
      }
      return false;
  }
}
function isWhitespaceAtPos(value, index) {
  if (index < 0 || index >= value.length) {
    return false;
  }
  const code = value.charCodeAt(index);
  switch (code) {
    case 32 /* Space */:
    case 9 /* Tab */:
      return true;
    default:
      return false;
  }
}
function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {
  while (patternPos < patternLen && wordPos < wordLen) {
    if (patternLow[patternPos] === wordLow[wordPos]) {
      if (fillMinWordPosArr) {
        _minWordMatchPos[patternPos] = wordPos;
      }
      patternPos += 1;
    }
    wordPos += 1;
  }
  return patternPos === patternLen;
}
function _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {
  let patternPos = patternLen - 1;
  let wordPos = wordLen - 1;
  while (patternPos >= patternStart && wordPos >= wordStart) {
    if (patternLow[patternPos] === wordLow[wordPos]) {
      _maxWordMatchPos[patternPos] = wordPos;
      patternPos--;
    }
    wordPos--;
  }
}
function nextTypoPermutation(pattern, patternPos) {
  if (patternPos + 1 >= pattern.length) {
    return void 0;
  }
  const swap1 = pattern[patternPos];
  const swap2 = pattern[patternPos + 1];
  if (swap1 === swap2) {
    return void 0;
  }
  return pattern.slice(0, patternPos) + swap2 + swap1 + pattern.slice(patternPos + 2);
}
var _maxLen, _minWordMatchPos, _maxWordMatchPos, _diag, _table, _arrows;
var init_filter = __esm({
  "src/util/filter.ts"() {
    "use strict";
    init_charCode();
    init_string();
    _maxLen = 128;
    _minWordMatchPos = initArr(2 * _maxLen);
    _maxWordMatchPos = initArr(2 * _maxLen);
    _diag = initTable();
    _table = initTable();
    _arrows = initTable();
  }
});

// src/model/fuzzyMatch.ts
async function initFuzzyWasm() {
  const buffer = await (0, import_util.promisify)(fs.readFile)(wasmFile);
  const res = await global.WebAssembly.instantiate(buffer, { env: {} });
  return res.instance.exports;
}
function toSpans(label, score3) {
  let res = [];
  for (let span of matchSpansReverse(label, score3, 2)) {
    res.push(span);
  }
  return res;
}
function* matchSpansReverse(text, positions, endIndex = 0, max = Number.MAX_SAFE_INTEGER) {
  let len = positions.length;
  if (len <= endIndex) return;
  let byteIndex2 = bytes(text, Math.min(positions[endIndex] + 1, max));
  let start;
  let prev;
  for (let i = len - 1; i >= endIndex; i--) {
    let curr = positions[i];
    if (curr >= max) {
      if (start != null) yield [byteIndex2(start), byteIndex2(prev + 1)];
      break;
    }
    if (prev != void 0) {
      let d = curr - prev;
      if (d == 1) {
        prev = curr;
      } else if (d > 1) {
        yield [byteIndex2(start), byteIndex2(prev + 1)];
        start = curr;
      } else {
        yield [byteIndex2(start), byteIndex2(prev + 1)];
        break;
      }
    } else {
      start = curr;
    }
    prev = curr;
    if (i == endIndex) {
      yield [byteIndex2(start), byteIndex2(prev + 1)];
    }
  }
}
function* matchSpans(text, positions, max) {
  max = max ? Math.min(max, text.length) : text.length;
  let byteIndex2 = bytes(text, Math.min(text.length, 4096));
  let start;
  let prev;
  let len = positions.length;
  for (let i = 0; i < len; i++) {
    let curr = positions[i];
    if (curr >= max) {
      if (start != null) yield [byteIndex2(start), byteIndex2(prev + 1)];
      break;
    }
    if (prev != void 0) {
      let d = curr - prev;
      if (d == 1) {
        prev = curr;
      } else if (d > 1) {
        yield [byteIndex2(start), byteIndex2(prev + 1)];
        start = curr;
      } else {
        yield [byteIndex2(start), byteIndex2(prev + 1)];
        break;
      }
    } else {
      start = curr;
    }
    prev = curr;
    if (i == len - 1) {
      yield [byteIndex2(start), byteIndex2(prev + 1)];
    }
  }
}
var wasmFile, FuzzyMatch;
var init_fuzzyMatch = __esm({
  "src/model/fuzzyMatch.ts"() {
    "use strict";
    init_constants();
    init_filter();
    init_node();
    init_string();
    wasmFile = path.join(pluginRoot, "bin/fuzzy.wasm");
    FuzzyMatch = class {
      constructor(exports2) {
        this.exports = exports2;
        this.patternLength = 0;
        this.matchSeq = false;
        this.sizes = [2048, 1024, 1024];
      }
      /**
       * Match character positions to column spans.
       */
      matchSpans(text, positions, max) {
        return matchSpans(text, positions, max);
      }
      /**
       * Create 0 index byte spans from matched text and FuzzyScore for highlights
       */
      matchScoreSpans(text, score3) {
        return matchSpansReverse(text, score3, 2);
      }
      /**
       * Create a score function
       */
      createScoreFunction(pattern, patternPos, options2, kind) {
        let lowPattern = pattern.toLowerCase();
        let fn;
        if (kind === "any") {
          fn = anyScore;
        } else if (kind === "aggressive") {
          fn = fuzzyScoreGracefulAggressive;
        } else {
          fn = fuzzyScore;
        }
        return (word, wordPos = 0) => {
          return fn(pattern, lowPattern, patternPos, word, word.toLowerCase(), wordPos, options2);
        };
      }
      getSizes() {
        return this.sizes;
      }
      setPattern(pattern, matchSeq = false) {
        if (pattern.length > 256) pattern = pattern.slice(0, 256);
        this.matchSeq = matchSeq;
        this.patternLength = matchSeq ? pattern.length : pattern.replace(/(\s|\t)/g, "").length;
        if (this.patternPtr == null) {
          let { malloc } = this.exports;
          let { sizes } = this;
          this.contentPtr = malloc(sizes[0]);
          this.patternPtr = malloc(sizes[1]);
          this.resultPtr = malloc(sizes[2]);
        }
        let buf = Buffer.from(pattern, "utf8");
        let len = buf.length;
        let bytes2 = new Uint8Array(this.exports.memory.buffer, this.patternPtr, len + 1);
        bytes2.set(buf);
        bytes2[len] = 0;
      }
      changeContent(text) {
        let { sizes } = this;
        if (text.length > 4096) text = text.slice(0, 4096);
        let buf = Buffer.from(text, "utf8");
        let len = buf.length;
        if (len > sizes[0]) {
          let { malloc, free } = this.exports;
          free(this.contentPtr);
          let byteLength2 = len + 1;
          this.contentPtr = malloc(byteLength2);
          sizes[0] = byteLength2;
        }
        let bytes2 = new Uint8Array(this.exports.memory.buffer, this.contentPtr, len + 1);
        bytes2.set(buf);
        bytes2[len] = 0;
      }
      match(text) {
        if (this.patternPtr == null) throw new Error("setPattern not called before match");
        if (this.patternLength === 0) return { score: 100, positions: new Uint32Array() };
        this.changeContent(text);
        let { fuzzyMatch: fuzzyMatch2, memory } = this.exports;
        let { resultPtr } = this;
        let score3 = fuzzyMatch2(this.contentPtr, this.patternPtr, resultPtr, this.matchSeq ? 1 : 0);
        if (!score3) return void 0;
        const u32 = new Uint32Array(memory.buffer, resultPtr, this.patternLength);
        return { score: score3, positions: u32.slice() };
      }
      matchHighlights(text, hlGroup) {
        let res = this.match(text);
        if (!res) return void 0;
        let highlights = [];
        for (let span of this.matchSpans(text, res.positions)) {
          highlights.push({ span, hlGroup });
        }
        return { score: res.score, highlights };
      }
      free() {
        let ptrs = [this.contentPtr, this.patternPtr, this.resultPtr];
        let { free } = this.exports;
        ptrs.forEach((p) => {
          if (p != null) free(p);
        });
        this.contentPtr = this.patternPtr = this.resultPtr = void 0;
      }
    };
  }
});

// src/model/strwidth.ts
async function initStrWidthWasm() {
  const buffer = await (0, import_util.promisify)(fs.readFile)(wasmPath);
  const res = await global.WebAssembly.instantiate(buffer, { env: {} });
  return res.instance.exports;
}
var wasmPath, instance, StrWidth;
var init_strwidth = __esm({
  "src/model/strwidth.ts"() {
    "use strict";
    init_constants();
    init_node();
    wasmPath = path.join(pluginRoot, "bin/strwidth.wasm");
    StrWidth = class _StrWidth {
      constructor(exports2) {
        this.exports = exports2;
        this.cache = /* @__PURE__ */ new Map();
        this.bytes = new Uint8Array(exports2.memory.buffer);
        this.contentPtr = exports2.malloc(4096);
      }
      setAmbw(ambiguousAsDouble) {
        this.exports.setAmbw(ambiguousAsDouble ? 1 : 0);
        this.cache.clear();
      }
      getWidth(content, cache = false) {
        let l = content.length;
        if (l === 0) return 0;
        if (l > 4095) {
          content = content.slice(0, 4095);
        }
        if (cache && this.cache.has(content)) {
          return this.cache.get(content);
        }
        let { contentPtr } = this;
        let buf = Buffer.from(content, "utf8");
        let len = buf.length;
        this.bytes.set(buf, contentPtr);
        this.bytes[contentPtr + len] = 0;
        let res = this.exports.strWidth(contentPtr);
        if (cache) this.cache.set(content, res);
        return res;
      }
      static async create() {
        if (instance) return instance;
        let api = await initStrWidthWasm();
        instance = new _StrWidth(api);
        return instance;
      }
    };
  }
});

// src/model/quickpick.ts
var logger5, QuickPick;
var init_quickpick = __esm({
  "src/model/quickpick.ts"() {
    "use strict";
    init_events();
    init_logger();
    init_util();
    init_array();
    init_filter();
    init_protocol();
    init_string();
    init_fuzzyMatch();
    init_input();
    init_popup();
    init_strwidth();
    logger5 = createLogger("quickpick");
    QuickPick = class {
      constructor(nvim, preferences = {}) {
        this.nvim = nvim;
        this.preferences = preferences;
        this.canSelectMany = false;
        this.matchOnDescription = false;
        this.maxHeight = 30;
        this.filteredItems = [];
        this.disposables = [];
        this._changed = false;
        // emitted with selected items or undefined when cancelled.
        this._onDidFinish = new import_node4.Emitter();
        this._onDidChangeSelection = new import_node4.Emitter();
        this._onDidChangeValue = new import_node4.Emitter();
        this.onDidFinish = this._onDidFinish.event;
        this.onDidChangeSelection = this._onDidChangeSelection.event;
        this.onDidChangeValue = this._onDidChangeValue.event;
        let items = [];
        let input = this.input = new InputBox(this.nvim, "");
        if (preferences.maxHeight) this.maxHeight = preferences.maxHeight;
        Object.defineProperty(this, "items", {
          set: (list2) => {
            items = toArray(list2);
            this.selectedItems = items.filter((o) => o.picked);
            this.filterItems("");
          },
          get: () => items
        });
        Object.defineProperty(this, "activeItems", {
          set: (list2) => {
            items = toArray(list2);
            this.filteredItems = items;
            this.showFilteredItems();
          },
          get: () => this.filteredItems
        });
        Object.defineProperty(this, "value", {
          set: (value) => {
            this.input.value = value;
          },
          get: () => this.input.value
        });
        Object.defineProperty(this, "title", {
          set: (newTitle) => {
            input.title = toText(newTitle);
          },
          get: () => input.title ?? ""
        });
        Object.defineProperty(this, "loading", {
          set: (loading) => {
            input.loading = loading;
          },
          get: () => input.loading
        });
        input.onDidChange((value) => {
          this._changed = false;
          this._onDidChangeValue.fire(value);
          if (this._changed) {
            this._changed = false;
            return;
          }
          this.filterItems(value);
        }, this);
        input.onDidFinish(this.onFinish, this);
      }
      get maxWidth() {
        return this.preferences.maxWidth ?? 80;
      }
      get currIndex() {
        return this.win ? this.win.currIndex : 0;
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
      }
      get winid() {
        return this.win?.winid;
      }
      get inputBox() {
        return this.input;
      }
      setCursor(index) {
        this.win?.setCursor(index, true);
      }
      attachEvents(inputBufnr) {
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this.bufnr = void 0;
            this.win = void 0;
          }
        }, null, this.disposables);
        events_default.on("InputListSelect", (index) => {
          if (index >= 0) {
            this.setCursor(index);
          }
          this.onFinish(index < 0 ? void 0 : "");
        }, null, this.disposables);
        events_default.on("PromptKeyPress", async (bufnr, key) => {
          if (bufnr == inputBufnr) {
            if (key == "<C-f>") {
              await this.win.scrollForward();
            } else if (key == "<C-b>") {
              await this.win.scrollBackward();
            } else if (["<C-j>", "<C-n>", "<down>"].includes(key)) {
              this.setCursor(this.currIndex + 1);
            } else if (["<C-k>", "<C-p>", "<up>"].includes(key)) {
              this.setCursor(this.currIndex - 1);
            } else if (this.canSelectMany && ["<C-@>", "<C-t>"].includes(key)) {
              this.toggePicked(this.currIndex);
            }
          }
        }, null, this.disposables);
      }
      async show() {
        let { nvim, items, input, width, preferences, maxHeight } = this;
        let { lines, highlights } = this.buildList(items, input.value);
        let minWidth;
        let lincount = 0;
        const sw = await StrWidth.create();
        if (typeof width === "number") minWidth = Math.min(width, this.maxWidth);
        let max = 40;
        lines.forEach((line) => {
          let w = sw.getWidth(line);
          if (typeof minWidth === "number") {
            lincount += Math.ceil(w / minWidth);
          } else {
            if (w >= 80) {
              minWidth = 80;
              lincount += Math.ceil(w / minWidth);
            } else {
              max = Math.max(max, w);
              lincount += 1;
            }
          }
        });
        if (minWidth === void 0) minWidth = max;
        let rounded = !!preferences.rounded;
        await input.show(this.title, {
          quickpick: lines,
          position: "center",
          placeHolder: this.placeholder,
          marginTop: 10,
          border: [1, 1, 0, 1],
          list: true,
          rounded,
          minWidth,
          maxWidth: this.maxWidth,
          highlight: preferences.floatHighlight,
          borderhighlight: preferences.floatBorderHighlight
        });
        let opts = { lines, rounded, maxHeight, highlights, linecount: Math.max(1, lincount) };
        opts.highlight = defaultValue(preferences.floatHighlight, void 0);
        opts.borderhighlight = defaultValue(preferences.floatBorderHighlight, void 0);
        let res = await nvim.call("coc#dialog#create_list", [input.winid, input.dimension, opts]);
        if (!res) throw new Error("Unable to open list window.");
        this.win = new Popup(nvim, res[0], res[1], lines.length);
        this.win.refreshScrollbar();
        this.bufnr = res[1];
        this.setCursor(0);
        this.attachEvents(input.bufnr);
      }
      buildList(items, input, loose = false) {
        let { selectedItems, canSelectMany } = this;
        let filteredItems = [];
        let filtered = [];
        let emptyInput = input.length === 0;
        let lowInput = input.toLowerCase();
        const scoreFn = loose ? anyScore : fuzzyScoreGracefulAggressive;
        const wordPos = canSelectMany ? 4 : 0;
        for (let index = 0; index < items.length; index++) {
          const item = items[index];
          let filterText = this.toFilterText(item);
          let spans = [];
          let score3 = 0;
          let descriptionSpan;
          if (!emptyInput) {
            let res = scoreFn(input, lowInput, 0, filterText, filterText.toLowerCase(), wordPos, { boostFullMatch: false, firstMatchCanBeWeak: true });
            if (!res) continue;
            score3 = loose ? 0 : res[0];
            spans = toSpans(filterText, res);
          }
          let picked = selectedItems.includes(item);
          let line = canSelectMany ? `[${picked ? "x" : " "}] ${item.label}` : item.label;
          if (item.description) {
            let start = byteLength(line);
            line = line + ` ${item.description}`;
            descriptionSpan = [start, start + 1 + byteLength(item.description)];
          }
          let lineItem = { line, descriptionSpan, index, score: score3, spans };
          filtered.push(lineItem);
        }
        let lines = [];
        let highlights = [];
        filtered.sort((a, b) => {
          if (a.score != b.score) return b.score - a.score;
          return a.index - b.index;
        });
        const toHighlight = (lnum, span, hlGroup, pre) => {
          return { lnum, colStart: span[0] + pre, colEnd: span[1] + pre, hlGroup };
        };
        filtered.forEach((item, index) => {
          lines.push(item.line);
          item.spans.forEach((span) => {
            highlights.push(toHighlight(index, span, "CocSearch", wordPos));
          });
          if (item.descriptionSpan) {
            highlights.push(toHighlight(index, item.descriptionSpan, "Comment", 0));
          }
          filteredItems.push(items[item.index]);
        });
        this.filteredItems = filteredItems;
        return { lines, highlights };
      }
      /**
       * Filter items, does highlight only when loose is true
       */
      _filter(items, input, loose = false) {
        if (!this.win) return;
        this._changed = true;
        let { lines, highlights } = this.buildList(items, input, loose);
        this.nvim.call("coc#dialog#update_list", [this.win.winid, this.win.bufnr, lines, highlights], true);
        this.win.linecount = lines.length;
        this.setCursor(0);
      }
      /**
       * Filter items with input
       */
      filterItems(input) {
        this._filter(this.items, input);
      }
      showFilteredItems() {
        let { input, filteredItems } = this;
        this._filter(filteredItems, input.value, true);
      }
      onFinish(input) {
        let items = input == null ? null : this.getSelectedItems();
        if (!this.canSelectMany && input !== void 0 && Array.isArray(items)) {
          this._onDidChangeSelection.fire(items);
        }
        this.nvim.call("coc#float#close", [this.winid], true);
        setTimeout(() => {
          this._onDidFinish.fire(items);
          this.dispose();
        }, 30);
      }
      getSelectedItems() {
        let { canSelectMany } = this;
        if (canSelectMany) return this.selectedItems;
        return toArray(this.filteredItems[this.currIndex]);
      }
      toggePicked(index) {
        let { nvim, filteredItems, selectedItems } = this;
        let item = filteredItems[index];
        if (!item) return;
        let idx = selectedItems.indexOf(item);
        if (idx != -1) {
          selectedItems.splice(idx, 1);
        } else {
          selectedItems.push(item);
        }
        let text = idx == -1 ? "x" : " ";
        nvim.pauseNotification();
        this.win.execute(`normal! ^1lr${text}`);
        this.win.setCursor(this.win.currIndex + 1);
        nvim.resumeNotification(true, true);
        this._onDidChangeSelection.fire(selectedItems);
      }
      toFilterText(item) {
        let { label, description } = item;
        let { canSelectMany } = this;
        let line = `${canSelectMany ? "    " : ""}${label.replace(/\r?\n/, "")}`;
        return this.matchOnDescription ? line + " " + (description ?? "") : line;
      }
      dispose() {
        this.bufnr = void 0;
        this.input.dispose();
        this.win?.close();
        this._onDidFinish.dispose();
        this._onDidChangeSelection.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/util/mutex.ts
var Mutex;
var init_mutex = __esm({
  "src/util/mutex.ts"() {
    "use strict";
    Mutex = class {
      constructor() {
        this.tasks = [];
        this.count = 1;
      }
      sched() {
        if (this.count > 0 && this.tasks.length > 0) {
          this.count--;
          let next = this.tasks.shift();
          next();
        }
      }
      reset() {
        this.tasks = [];
        this.count = 1;
      }
      get busy() {
        return this.count == 0;
      }
      acquire() {
        return new Promise((res) => {
          let task = () => {
            let released = false;
            res(() => {
              if (!released) {
                released = true;
                this.count++;
                this.sched();
              }
            });
          };
          this.tasks.push(task);
          process.nextTick(this.sched.bind(this));
        });
      }
      use(f) {
        return this.acquire().then((release) => f().then((res) => {
          release();
          return res;
        }).catch((err) => {
          release();
          throw err;
        }));
      }
    };
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports2, module2) {
    "use strict";
    var buffer = require("buffer");
    var Buffer3 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key)) continue;
      if (key === "SlowBuffer" || key === "Buffer") continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer3) {
      if (!Buffer3.hasOwnProperty(key)) continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
      Safer[key] = Buffer3[key];
    }
    safer.Buffer.prototype = Buffer3.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer3(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding2) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer3(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding2 === "string") {
          buf.fill(fill, encoding2);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module2.exports = safer;
  }
});

// node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS({
  "node_modules/iconv-lite/lib/bom-handling.js"(exports2) {
    "use strict";
    var BOMChar = "\uFEFF";
    exports2.PrependBOM = PrependBOMWrapper;
    function PrependBOMWrapper(encoder, options2) {
      this.encoder = encoder;
      this.addBOM = true;
    }
    PrependBOMWrapper.prototype.write = function(str) {
      if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
      }
      return this.encoder.write(str);
    };
    PrependBOMWrapper.prototype.end = function() {
      return this.encoder.end();
    };
    exports2.StripBOM = StripBOMWrapper;
    function StripBOMWrapper(decoder, options2) {
      this.decoder = decoder;
      this.pass = false;
      this.options = options2 || {};
    }
    StripBOMWrapper.prototype.write = function(buf) {
      var res = this.decoder.write(buf);
      if (this.pass || !res)
        return res;
      if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === "function")
          this.options.stripBOM();
      }
      this.pass = true;
      return res;
    };
    StripBOMWrapper.prototype.end = function() {
      return this.decoder.end();
    };
  }
});

// node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS({
  "node_modules/iconv-lite/encodings/internal.js"(exports2, module2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    module2.exports = {
      // Encodings
      utf8: { type: "_internal", bomAware: true },
      cesu8: { type: "_internal", bomAware: true },
      unicode11utf8: "utf8",
      ucs2: { type: "_internal", bomAware: true },
      utf16le: "ucs2",
      binary: { type: "_internal" },
      base64: { type: "_internal" },
      hex: { type: "_internal" },
      // Codec.
      _internal: InternalCodec
    };
    function InternalCodec(codecOptions, iconv2) {
      this.enc = codecOptions.encodingName;
      this.bomAware = codecOptions.bomAware;
      if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
      else if (this.enc === "cesu8") {
        this.enc = "utf8";
        this.encoder = InternalEncoderCesu8;
        if (Buffer3.from("eda0bdedb2a9", "hex").toString() !== "\u{1F4A9}") {
          this.decoder = InternalDecoderCesu8;
          this.defaultCharUnicode = iconv2.defaultCharUnicode;
        }
      }
    }
    InternalCodec.prototype.encoder = InternalEncoder;
    InternalCodec.prototype.decoder = InternalDecoder;
    var StringDecoder = require("string_decoder").StringDecoder;
    if (!StringDecoder.prototype.end)
      StringDecoder.prototype.end = function() {
      };
    function InternalDecoder(options2, codec) {
      this.decoder = new StringDecoder(codec.enc);
    }
    InternalDecoder.prototype.write = function(buf) {
      if (!Buffer3.isBuffer(buf)) {
        buf = Buffer3.from(buf);
      }
      return this.decoder.write(buf);
    };
    InternalDecoder.prototype.end = function() {
      return this.decoder.end();
    };
    function InternalEncoder(options2, codec) {
      this.enc = codec.enc;
    }
    InternalEncoder.prototype.write = function(str) {
      return Buffer3.from(str, this.enc);
    };
    InternalEncoder.prototype.end = function() {
    };
    function InternalEncoderBase64(options2, codec) {
      this.prevStr = "";
    }
    InternalEncoderBase64.prototype.write = function(str) {
      str = this.prevStr + str;
      var completeQuads = str.length - str.length % 4;
      this.prevStr = str.slice(completeQuads);
      str = str.slice(0, completeQuads);
      return Buffer3.from(str, "base64");
    };
    InternalEncoderBase64.prototype.end = function() {
      return Buffer3.from(this.prevStr, "base64");
    };
    function InternalEncoderCesu8(options2, codec) {
    }
    InternalEncoderCesu8.prototype.write = function(str) {
      var buf = Buffer3.alloc(str.length * 3), bufIdx = 0;
      for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (charCode < 128)
          buf[bufIdx++] = charCode;
        else if (charCode < 2048) {
          buf[bufIdx++] = 192 + (charCode >>> 6);
          buf[bufIdx++] = 128 + (charCode & 63);
        } else {
          buf[bufIdx++] = 224 + (charCode >>> 12);
          buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
          buf[bufIdx++] = 128 + (charCode & 63);
        }
      }
      return buf.slice(0, bufIdx);
    };
    InternalEncoderCesu8.prototype.end = function() {
    };
    function InternalDecoderCesu8(options2, codec) {
      this.acc = 0;
      this.contBytes = 0;
      this.accBytes = 0;
      this.defaultCharUnicode = codec.defaultCharUnicode;
    }
    InternalDecoderCesu8.prototype.write = function(buf) {
      var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
      for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 192) !== 128) {
          if (contBytes > 0) {
            res += this.defaultCharUnicode;
            contBytes = 0;
          }
          if (curByte < 128) {
            res += String.fromCharCode(curByte);
          } else if (curByte < 224) {
            acc = curByte & 31;
            contBytes = 1;
            accBytes = 1;
          } else if (curByte < 240) {
            acc = curByte & 15;
            contBytes = 2;
            accBytes = 1;
          } else {
            res += this.defaultCharUnicode;
          }
        } else {
          if (contBytes > 0) {
            acc = acc << 6 | curByte & 63;
            contBytes--;
            accBytes++;
            if (contBytes === 0) {
              if (accBytes === 2 && acc < 128 && acc > 0)
                res += this.defaultCharUnicode;
              else if (accBytes === 3 && acc < 2048)
                res += this.defaultCharUnicode;
              else
                res += String.fromCharCode(acc);
            }
          } else {
            res += this.defaultCharUnicode;
          }
        }
      }
      this.acc = acc;
      this.contBytes = contBytes;
      this.accBytes = accBytes;
      return res;
    };
    InternalDecoderCesu8.prototype.end = function() {
      var res = 0;
      if (this.contBytes > 0)
        res += this.defaultCharUnicode;
      return res;
    };
  }
});

// node_modules/iconv-lite/encodings/utf32.js
var require_utf32 = __commonJS({
  "node_modules/iconv-lite/encodings/utf32.js"(exports2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    exports2._utf32 = Utf32Codec;
    function Utf32Codec(codecOptions, iconv2) {
      this.iconv = iconv2;
      this.bomAware = true;
      this.isLE = codecOptions.isLE;
    }
    exports2.utf32le = { type: "_utf32", isLE: true };
    exports2.utf32be = { type: "_utf32", isLE: false };
    exports2.ucs4le = "utf32le";
    exports2.ucs4be = "utf32be";
    Utf32Codec.prototype.encoder = Utf32Encoder;
    Utf32Codec.prototype.decoder = Utf32Decoder;
    function Utf32Encoder(options2, codec) {
      this.isLE = codec.isLE;
      this.highSurrogate = 0;
    }
    Utf32Encoder.prototype.write = function(str) {
      var src = Buffer3.from(str, "ucs2");
      var dst = Buffer3.alloc(src.length * 2);
      var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
      var offset = 0;
      for (var i = 0; i < src.length; i += 2) {
        var code = src.readUInt16LE(i);
        var isHighSurrogate2 = 55296 <= code && code < 56320;
        var isLowSurrogate2 = 56320 <= code && code < 57344;
        if (this.highSurrogate) {
          if (isHighSurrogate2 || !isLowSurrogate2) {
            write32.call(dst, this.highSurrogate, offset);
            offset += 4;
          } else {
            var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
            write32.call(dst, codepoint, offset);
            offset += 4;
            this.highSurrogate = 0;
            continue;
          }
        }
        if (isHighSurrogate2)
          this.highSurrogate = code;
        else {
          write32.call(dst, code, offset);
          offset += 4;
          this.highSurrogate = 0;
        }
      }
      if (offset < dst.length)
        dst = dst.slice(0, offset);
      return dst;
    };
    Utf32Encoder.prototype.end = function() {
      if (!this.highSurrogate)
        return;
      var buf = Buffer3.alloc(4);
      if (this.isLE)
        buf.writeUInt32LE(this.highSurrogate, 0);
      else
        buf.writeUInt32BE(this.highSurrogate, 0);
      this.highSurrogate = 0;
      return buf;
    };
    function Utf32Decoder(options2, codec) {
      this.isLE = codec.isLE;
      this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
      this.overflow = [];
    }
    Utf32Decoder.prototype.write = function(src) {
      if (src.length === 0)
        return "";
      var i = 0;
      var codepoint = 0;
      var dst = Buffer3.alloc(src.length + 4);
      var offset = 0;
      var isLE = this.isLE;
      var overflow = this.overflow;
      var badChar = this.badChar;
      if (overflow.length > 0) {
        for (; i < src.length && overflow.length < 4; i++)
          overflow.push(src[i]);
        if (overflow.length === 4) {
          if (isLE) {
            codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
          } else {
            codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
          }
          overflow.length = 0;
          offset = _writeCodepoint(dst, offset, codepoint, badChar);
        }
      }
      for (; i < src.length - 3; i += 4) {
        if (isLE) {
          codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
        } else {
          codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
        }
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
      for (; i < src.length; i++) {
        overflow.push(src[i]);
      }
      return dst.slice(0, offset).toString("ucs2");
    };
    function _writeCodepoint(dst, offset, codepoint, badChar) {
      if (codepoint < 0 || codepoint > 1114111) {
        codepoint = badChar;
      }
      if (codepoint >= 65536) {
        codepoint -= 65536;
        var high = 55296 | codepoint >> 10;
        dst[offset++] = high & 255;
        dst[offset++] = high >> 8;
        var codepoint = 56320 | codepoint & 1023;
      }
      dst[offset++] = codepoint & 255;
      dst[offset++] = codepoint >> 8;
      return offset;
    }
    Utf32Decoder.prototype.end = function() {
      this.overflow.length = 0;
    };
    exports2.utf32 = Utf32AutoCodec;
    exports2.ucs4 = "utf32";
    function Utf32AutoCodec(options2, iconv2) {
      this.iconv = iconv2;
    }
    Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
    Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
    function Utf32AutoEncoder(options2, codec) {
      options2 = options2 || {};
      if (options2.addBOM === void 0)
        options2.addBOM = true;
      this.encoder = codec.iconv.getEncoder(options2.defaultEncoding || "utf-32le", options2);
    }
    Utf32AutoEncoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf32AutoEncoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf32AutoDecoder(options2, codec) {
      this.decoder = null;
      this.initialBufs = [];
      this.initialBufsLen = 0;
      this.options = options2 || {};
      this.iconv = codec.iconv;
    }
    Utf32AutoDecoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 32)
          return "";
        var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding2, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.write(buf);
    };
    Utf32AutoDecoder.prototype.end = function() {
      if (!this.decoder) {
        var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding2, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        var trail = this.decoder.end();
        if (trail)
          resStr += trail;
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.end();
    };
    function detectEncoding(bufs, defaultEncoding) {
      var b = [];
      var charsProcessed = 0;
      var invalidLE = 0, invalidBE = 0;
      var bmpCharsLE = 0, bmpCharsBE = 0;
      outer_loop:
        for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 4) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                  return "utf-32le";
                }
                if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                  return "utf-32be";
                }
              }
              if (b[0] !== 0 || b[1] > 16) invalidBE++;
              if (b[3] !== 0 || b[2] > 16) invalidLE++;
              if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
              if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
      if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
      if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
      return defaultEncoding || "utf-32le";
    }
  }
});

// node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS({
  "node_modules/iconv-lite/encodings/utf16.js"(exports2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    exports2.utf16be = Utf16BECodec;
    function Utf16BECodec() {
    }
    Utf16BECodec.prototype.encoder = Utf16BEEncoder;
    Utf16BECodec.prototype.decoder = Utf16BEDecoder;
    Utf16BECodec.prototype.bomAware = true;
    function Utf16BEEncoder() {
    }
    Utf16BEEncoder.prototype.write = function(str) {
      var buf = Buffer3.from(str, "ucs2");
      for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i];
        buf[i] = buf[i + 1];
        buf[i + 1] = tmp;
      }
      return buf;
    };
    Utf16BEEncoder.prototype.end = function() {
    };
    function Utf16BEDecoder() {
      this.overflowByte = -1;
    }
    Utf16BEDecoder.prototype.write = function(buf) {
      if (buf.length == 0)
        return "";
      var buf2 = Buffer3.alloc(buf.length + 1), i = 0, j = 0;
      if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1;
        j = 2;
      }
      for (; i < buf.length - 1; i += 2, j += 2) {
        buf2[j] = buf[i + 1];
        buf2[j + 1] = buf[i];
      }
      this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
      return buf2.slice(0, j).toString("ucs2");
    };
    Utf16BEDecoder.prototype.end = function() {
      this.overflowByte = -1;
    };
    exports2.utf16 = Utf16Codec;
    function Utf16Codec(codecOptions, iconv2) {
      this.iconv = iconv2;
    }
    Utf16Codec.prototype.encoder = Utf16Encoder;
    Utf16Codec.prototype.decoder = Utf16Decoder;
    function Utf16Encoder(options2, codec) {
      options2 = options2 || {};
      if (options2.addBOM === void 0)
        options2.addBOM = true;
      this.encoder = codec.iconv.getEncoder("utf-16le", options2);
    }
    Utf16Encoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf16Encoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf16Decoder(options2, codec) {
      this.decoder = null;
      this.initialBufs = [];
      this.initialBufsLen = 0;
      this.options = options2 || {};
      this.iconv = codec.iconv;
    }
    Utf16Decoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 16)
          return "";
        var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding2, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.write(buf);
    };
    Utf16Decoder.prototype.end = function() {
      if (!this.decoder) {
        var encoding2 = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding2, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        var trail = this.decoder.end();
        if (trail)
          resStr += trail;
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.end();
    };
    function detectEncoding(bufs, defaultEncoding) {
      var b = [];
      var charsProcessed = 0;
      var asciiCharsLE = 0, asciiCharsBE = 0;
      outer_loop:
        for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 2) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254) return "utf-16le";
                if (b[0] === 254 && b[1] === 255) return "utf-16be";
              }
              if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
              if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
      if (asciiCharsBE > asciiCharsLE) return "utf-16be";
      if (asciiCharsBE < asciiCharsLE) return "utf-16le";
      return defaultEncoding || "utf-16le";
    }
  }
});

// node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS({
  "node_modules/iconv-lite/encodings/utf7.js"(exports2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    exports2.utf7 = Utf7Codec;
    exports2.unicode11utf7 = "utf7";
    function Utf7Codec(codecOptions, iconv2) {
      this.iconv = iconv2;
    }
    Utf7Codec.prototype.encoder = Utf7Encoder;
    Utf7Codec.prototype.decoder = Utf7Decoder;
    Utf7Codec.prototype.bomAware = true;
    var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
    function Utf7Encoder(options2, codec) {
      this.iconv = codec.iconv;
    }
    Utf7Encoder.prototype.write = function(str) {
      return Buffer3.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
      }.bind(this)));
    };
    Utf7Encoder.prototype.end = function() {
    };
    function Utf7Decoder(options2, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64Regex = /[A-Za-z0-9\/+]/;
    var base64Chars = [];
    for (i = 0; i < 256; i++)
      base64Chars[i] = base64Regex.test(String.fromCharCode(i));
    var i;
    var plusChar = "+".charCodeAt(0);
    var minusChar = "-".charCodeAt(0);
    var andChar = "&".charCodeAt(0);
    Utf7Decoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == plusChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64Chars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "+";
            } else {
              var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
              res += this.iconv.decode(Buffer3.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer3.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7Decoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer3.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
    exports2.utf7imap = Utf7IMAPCodec;
    function Utf7IMAPCodec(codecOptions, iconv2) {
      this.iconv = iconv2;
    }
    Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
    Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
    Utf7IMAPCodec.prototype.bomAware = true;
    function Utf7IMAPEncoder(options2, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = Buffer3.alloc(6);
      this.base64AccumIdx = 0;
    }
    Utf7IMAPEncoder.prototype.write = function(str) {
      var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer3.alloc(str.length * 5 + 10), bufIdx = 0;
      for (var i2 = 0; i2 < str.length; i2++) {
        var uChar = str.charCodeAt(i2);
        if (32 <= uChar && uChar <= 126) {
          if (inBase64) {
            if (base64AccumIdx > 0) {
              bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
              base64AccumIdx = 0;
            }
            buf[bufIdx++] = minusChar;
            inBase64 = false;
          }
          if (!inBase64) {
            buf[bufIdx++] = uChar;
            if (uChar === andChar)
              buf[bufIdx++] = minusChar;
          }
        } else {
          if (!inBase64) {
            buf[bufIdx++] = andChar;
            inBase64 = true;
          }
          if (inBase64) {
            base64Accum[base64AccumIdx++] = uChar >> 8;
            base64Accum[base64AccumIdx++] = uChar & 255;
            if (base64AccumIdx == base64Accum.length) {
              bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
              base64AccumIdx = 0;
            }
          }
        }
      }
      this.inBase64 = inBase64;
      this.base64AccumIdx = base64AccumIdx;
      return buf.slice(0, bufIdx);
    };
    Utf7IMAPEncoder.prototype.end = function() {
      var buf = Buffer3.alloc(10), bufIdx = 0;
      if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
          bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
          this.base64AccumIdx = 0;
        }
        buf[bufIdx++] = minusChar;
        this.inBase64 = false;
      }
      return buf.slice(0, bufIdx);
    };
    function Utf7IMAPDecoder(options2, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64IMAPChars = base64Chars.slice();
    base64IMAPChars[",".charCodeAt(0)] = true;
    Utf7IMAPDecoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == andChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64IMAPChars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "&";
            } else {
              var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
              res += this.iconv.decode(Buffer3.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer3.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7IMAPDecoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer3.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-codec.js"(exports2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    exports2._sbcs = SBCSCodec;
    function SBCSCodec(codecOptions, iconv2) {
      if (!codecOptions)
        throw new Error("SBCS codec is called without the data.");
      if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
        throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
      if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
          asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
      }
      this.decodeBuf = Buffer3.from(codecOptions.chars, "ucs2");
      var encodeBuf = Buffer3.alloc(65536, iconv2.defaultCharSingleByte.charCodeAt(0));
      for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
      this.encodeBuf = encodeBuf;
    }
    SBCSCodec.prototype.encoder = SBCSEncoder;
    SBCSCodec.prototype.decoder = SBCSDecoder;
    function SBCSEncoder(options2, codec) {
      this.encodeBuf = codec.encodeBuf;
    }
    SBCSEncoder.prototype.write = function(str) {
      var buf = Buffer3.alloc(str.length);
      for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
      return buf;
    };
    SBCSEncoder.prototype.end = function() {
    };
    function SBCSDecoder(options2, codec) {
      this.decodeBuf = codec.decodeBuf;
    }
    SBCSDecoder.prototype.write = function(buf) {
      var decodeBuf = this.decodeBuf;
      var newBuf = Buffer3.alloc(buf.length * 2);
      var idx1 = 0, idx2 = 0;
      for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i] * 2;
        idx2 = i * 2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
      }
      return newBuf.toString("ucs2");
    };
    SBCSDecoder.prototype.end = function() {
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-data.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // Not supported by iconv, not sure why.
      "10029": "maccenteuro",
      "maccenteuro": {
        "type": "_sbcs",
        "chars": "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7"
      },
      "808": "cp808",
      "ibm808": "cp808",
      "cp808": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\u20AC\u25A0\xA0"
      },
      "mik": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2514\u2534\u252C\u251C\u2500\u253C\u2563\u2551\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2510\u2591\u2592\u2593\u2502\u2524\u2116\xA7\u2557\u255D\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "cp720": {
        "type": "_sbcs",
        "chars": "\x80\x81\xE9\xE2\x84\xE0\x86\xE7\xEA\xEB\xE8\xEF\xEE\x8D\x8E\x8F\x90\u0651\u0652\xF4\xA4\u0640\xFB\xF9\u0621\u0622\u0623\u0624\xA3\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0636\u0637\u0638\u0639\u063A\u0641\xB5\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u2261\u064B\u064C\u064D\u064E\u064F\u0650\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      // Aliases of generated encodings.
      "ascii8bit": "ascii",
      "usascii": "ascii",
      "ansix34": "ascii",
      "ansix341968": "ascii",
      "ansix341986": "ascii",
      "csascii": "ascii",
      "cp367": "ascii",
      "ibm367": "ascii",
      "isoir6": "ascii",
      "iso646us": "ascii",
      "iso646irv": "ascii",
      "us": "ascii",
      "latin1": "iso88591",
      "latin2": "iso88592",
      "latin3": "iso88593",
      "latin4": "iso88594",
      "latin5": "iso88599",
      "latin6": "iso885910",
      "latin7": "iso885913",
      "latin8": "iso885914",
      "latin9": "iso885915",
      "latin10": "iso885916",
      "csisolatin1": "iso88591",
      "csisolatin2": "iso88592",
      "csisolatin3": "iso88593",
      "csisolatin4": "iso88594",
      "csisolatincyrillic": "iso88595",
      "csisolatinarabic": "iso88596",
      "csisolatingreek": "iso88597",
      "csisolatinhebrew": "iso88598",
      "csisolatin5": "iso88599",
      "csisolatin6": "iso885910",
      "l1": "iso88591",
      "l2": "iso88592",
      "l3": "iso88593",
      "l4": "iso88594",
      "l5": "iso88599",
      "l6": "iso885910",
      "l7": "iso885913",
      "l8": "iso885914",
      "l9": "iso885915",
      "l10": "iso885916",
      "isoir14": "iso646jp",
      "isoir57": "iso646cn",
      "isoir100": "iso88591",
      "isoir101": "iso88592",
      "isoir109": "iso88593",
      "isoir110": "iso88594",
      "isoir144": "iso88595",
      "isoir127": "iso88596",
      "isoir126": "iso88597",
      "isoir138": "iso88598",
      "isoir148": "iso88599",
      "isoir157": "iso885910",
      "isoir166": "tis620",
      "isoir179": "iso885913",
      "isoir199": "iso885914",
      "isoir203": "iso885915",
      "isoir226": "iso885916",
      "cp819": "iso88591",
      "ibm819": "iso88591",
      "cyrillic": "iso88595",
      "arabic": "iso88596",
      "arabic8": "iso88596",
      "ecma114": "iso88596",
      "asmo708": "iso88596",
      "greek": "iso88597",
      "greek8": "iso88597",
      "ecma118": "iso88597",
      "elot928": "iso88597",
      "hebrew": "iso88598",
      "hebrew8": "iso88598",
      "turkish": "iso88599",
      "turkish8": "iso88599",
      "thai": "iso885911",
      "thai8": "iso885911",
      "celtic": "iso885914",
      "celtic8": "iso885914",
      "isoceltic": "iso885914",
      "tis6200": "tis620",
      "tis62025291": "tis620",
      "tis62025330": "tis620",
      "10000": "macroman",
      "10006": "macgreek",
      "10007": "maccyrillic",
      "10079": "maciceland",
      "10081": "macturkish",
      "cspc8codepage437": "cp437",
      "cspc775baltic": "cp775",
      "cspc850multilingual": "cp850",
      "cspcp852": "cp852",
      "cspc862latinhebrew": "cp862",
      "cpgr": "cp869",
      "msee": "cp1250",
      "mscyrl": "cp1251",
      "msansi": "cp1252",
      "msgreek": "cp1253",
      "msturk": "cp1254",
      "mshebr": "cp1255",
      "msarab": "cp1256",
      "winbaltrim": "cp1257",
      "cp20866": "koi8r",
      "20866": "koi8r",
      "ibm878": "koi8r",
      "cskoi8r": "koi8r",
      "cp21866": "koi8u",
      "21866": "koi8u",
      "ibm1168": "koi8u",
      "strk10482002": "rk1048",
      "tcvn5712": "tcvn",
      "tcvn57121": "tcvn",
      "gb198880": "iso646cn",
      "cn": "iso646cn",
      "csiso14jisc6220ro": "iso646jp",
      "jisc62201969ro": "iso646jp",
      "jp": "iso646jp",
      "cshproman8": "hproman8",
      "r8": "hproman8",
      "roman8": "hproman8",
      "xroman8": "hproman8",
      "ibm1051": "hproman8",
      "mac": "macintosh",
      "csmacintosh": "macintosh"
    };
  }
});

// node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS({
  "node_modules/iconv-lite/encodings/sbcs-data-generated.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "437": "cp437",
      "737": "cp737",
      "775": "cp775",
      "850": "cp850",
      "852": "cp852",
      "855": "cp855",
      "856": "cp856",
      "857": "cp857",
      "858": "cp858",
      "860": "cp860",
      "861": "cp861",
      "862": "cp862",
      "863": "cp863",
      "864": "cp864",
      "865": "cp865",
      "866": "cp866",
      "869": "cp869",
      "874": "windows874",
      "922": "cp922",
      "1046": "cp1046",
      "1124": "cp1124",
      "1125": "cp1125",
      "1129": "cp1129",
      "1133": "cp1133",
      "1161": "cp1161",
      "1162": "cp1162",
      "1163": "cp1163",
      "1250": "windows1250",
      "1251": "windows1251",
      "1252": "windows1252",
      "1253": "windows1253",
      "1254": "windows1254",
      "1255": "windows1255",
      "1256": "windows1256",
      "1257": "windows1257",
      "1258": "windows1258",
      "28591": "iso88591",
      "28592": "iso88592",
      "28593": "iso88593",
      "28594": "iso88594",
      "28595": "iso88595",
      "28596": "iso88596",
      "28597": "iso88597",
      "28598": "iso88598",
      "28599": "iso88599",
      "28600": "iso885910",
      "28601": "iso885911",
      "28603": "iso885913",
      "28604": "iso885914",
      "28605": "iso885915",
      "28606": "iso885916",
      "windows874": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\uFFFD\uFFFD\uFFFD\u2026\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "win874": "windows874",
      "cp874": "windows874",
      "windows1250": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\u0160\u2039\u015A\u0164\u017D\u0179\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0161\u203A\u015B\u0165\u017E\u017A\xA0\u02C7\u02D8\u0141\xA4\u0104\xA6\xA7\xA8\xA9\u015E\xAB\xAC\xAD\xAE\u017B\xB0\xB1\u02DB\u0142\xB4\xB5\xB6\xB7\xB8\u0105\u015F\xBB\u013D\u02DD\u013E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
      },
      "win1250": "windows1250",
      "cp1250": "windows1250",
      "windows1251": {
        "type": "_sbcs",
        "chars": "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u040C\u040B\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u045C\u045B\u045F\xA0\u040E\u045E\u0408\xA4\u0490\xA6\xA7\u0401\xA9\u0404\xAB\xAC\xAD\xAE\u0407\xB0\xB1\u0406\u0456\u0491\xB5\xB6\xB7\u0451\u2116\u0454\xBB\u0458\u0405\u0455\u0457\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "win1251": "windows1251",
      "cp1251": "windows1251",
      "windows1252": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\u017D\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\u017E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "win1252": "windows1252",
      "cp1252": "windows1252",
      "windows1253": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\u0385\u0386\xA3\xA4\xA5\xA6\xA7\xA8\xA9\uFFFD\xAB\xAC\xAD\xAE\u2015\xB0\xB1\xB2\xB3\u0384\xB5\xB6\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
      },
      "win1253": "windows1253",
      "cp1253": "windows1253",
      "windows1254": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
      },
      "win1254": "windows1254",
      "cp1254": "windows1254",
      "windows1255": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\xA0\xA1\xA2\xA3\u20AA\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\xBF\u05B0\u05B1\u05B2\u05B3\u05B4\u05B5\u05B6\u05B7\u05B8\u05B9\u05BA\u05BB\u05BC\u05BD\u05BE\u05BF\u05C0\u05C1\u05C2\u05C3\u05F0\u05F1\u05F2\u05F3\u05F4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
      },
      "win1255": "windows1255",
      "cp1255": "windows1255",
      "windows1256": {
        "type": "_sbcs",
        "chars": "\u20AC\u067E\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0679\u2039\u0152\u0686\u0698\u0688\u06AF\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u06A9\u2122\u0691\u203A\u0153\u200C\u200D\u06BA\xA0\u060C\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\u06BE\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\u061B\xBB\xBC\xBD\xBE\u061F\u06C1\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\xD7\u0637\u0638\u0639\u063A\u0640\u0641\u0642\u0643\xE0\u0644\xE2\u0645\u0646\u0647\u0648\xE7\xE8\xE9\xEA\xEB\u0649\u064A\xEE\xEF\u064B\u064C\u064D\u064E\xF4\u064F\u0650\xF7\u0651\xF9\u0652\xFB\xFC\u200E\u200F\u06D2"
      },
      "win1256": "windows1256",
      "cp1256": "windows1256",
      "windows1257": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021\uFFFD\u2030\uFFFD\u2039\uFFFD\xA8\u02C7\xB8\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\xAF\u02DB\uFFFD\xA0\uFFFD\xA2\xA3\xA4\uFFFD\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u02D9"
      },
      "win1257": "windows1257",
      "cp1257": "windows1257",
      "windows1258": {
        "type": "_sbcs",
        "chars": "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\uFFFD\u2039\u0152\uFFFD\uFFFD\uFFFD\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\uFFFD\u203A\u0153\uFFFD\uFFFD\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "win1258": "windows1258",
      "cp1258": "windows1258",
      "iso88591": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "cp28591": "iso88591",
      "iso88592": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u02D8\u0141\xA4\u013D\u015A\xA7\xA8\u0160\u015E\u0164\u0179\xAD\u017D\u017B\xB0\u0105\u02DB\u0142\xB4\u013E\u015B\u02C7\xB8\u0161\u015F\u0165\u017A\u02DD\u017E\u017C\u0154\xC1\xC2\u0102\xC4\u0139\u0106\xC7\u010C\xC9\u0118\xCB\u011A\xCD\xCE\u010E\u0110\u0143\u0147\xD3\xD4\u0150\xD6\xD7\u0158\u016E\xDA\u0170\xDC\xDD\u0162\xDF\u0155\xE1\xE2\u0103\xE4\u013A\u0107\xE7\u010D\xE9\u0119\xEB\u011B\xED\xEE\u010F\u0111\u0144\u0148\xF3\xF4\u0151\xF6\xF7\u0159\u016F\xFA\u0171\xFC\xFD\u0163\u02D9"
      },
      "cp28592": "iso88592",
      "iso88593": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0126\u02D8\xA3\xA4\uFFFD\u0124\xA7\xA8\u0130\u015E\u011E\u0134\xAD\uFFFD\u017B\xB0\u0127\xB2\xB3\xB4\xB5\u0125\xB7\xB8\u0131\u015F\u011F\u0135\xBD\uFFFD\u017C\xC0\xC1\xC2\uFFFD\xC4\u010A\u0108\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\uFFFD\xD1\xD2\xD3\xD4\u0120\xD6\xD7\u011C\xD9\xDA\xDB\xDC\u016C\u015C\xDF\xE0\xE1\xE2\uFFFD\xE4\u010B\u0109\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\uFFFD\xF1\xF2\xF3\xF4\u0121\xF6\xF7\u011D\xF9\xFA\xFB\xFC\u016D\u015D\u02D9"
      },
      "cp28593": "iso88593",
      "iso88594": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0138\u0156\xA4\u0128\u013B\xA7\xA8\u0160\u0112\u0122\u0166\xAD\u017D\xAF\xB0\u0105\u02DB\u0157\xB4\u0129\u013C\u02C7\xB8\u0161\u0113\u0123\u0167\u014A\u017E\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\u012A\u0110\u0145\u014C\u0136\xD4\xD5\xD6\xD7\xD8\u0172\xDA\xDB\xDC\u0168\u016A\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\u012B\u0111\u0146\u014D\u0137\xF4\xF5\xF6\xF7\xF8\u0173\xFA\xFB\xFC\u0169\u016B\u02D9"
      },
      "cp28594": "iso88594",
      "iso88595": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0403\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0453\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
      },
      "cp28595": "iso88595",
      "iso88596": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\uFFFD\uFFFD\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u060C\xAD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u061B\uFFFD\uFFFD\uFFFD\u061F\uFFFD\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\u0638\u0639\u063A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "cp28596": "iso88596",
      "iso88597": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u2018\u2019\xA3\u20AC\u20AF\xA6\xA7\xA8\xA9\u037A\xAB\xAC\xAD\uFFFD\u2015\xB0\xB1\xB2\xB3\u0384\u0385\u0386\xB7\u0388\u0389\u038A\xBB\u038C\xBD\u038E\u038F\u0390\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\uFFFD\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03AA\u03AB\u03AC\u03AD\u03AE\u03AF\u03B0\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C2\u03C3\u03C4\u03C5\u03C6\u03C7\u03C8\u03C9\u03CA\u03CB\u03CC\u03CD\u03CE\uFFFD"
      },
      "cp28597": "iso88597",
      "iso88598": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xD7\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xF7\xBB\xBC\xBD\xBE\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2017\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\uFFFD\u200E\u200F\uFFFD"
      },
      "cp28598": "iso88598",
      "iso88599": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u011E\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u0130\u015E\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u011F\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u0131\u015F\xFF"
      },
      "cp28599": "iso88599",
      "iso885910": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0112\u0122\u012A\u0128\u0136\xA7\u013B\u0110\u0160\u0166\u017D\xAD\u016A\u014A\xB0\u0105\u0113\u0123\u012B\u0129\u0137\xB7\u013C\u0111\u0161\u0167\u017E\u2015\u016B\u014B\u0100\xC1\xC2\xC3\xC4\xC5\xC6\u012E\u010C\xC9\u0118\xCB\u0116\xCD\xCE\xCF\xD0\u0145\u014C\xD3\xD4\xD5\xD6\u0168\xD8\u0172\xDA\xDB\xDC\xDD\xDE\xDF\u0101\xE1\xE2\xE3\xE4\xE5\xE6\u012F\u010D\xE9\u0119\xEB\u0117\xED\xEE\xEF\xF0\u0146\u014D\xF3\xF4\xF5\xF6\u0169\xF8\u0173\xFA\xFB\xFC\xFD\xFE\u0138"
      },
      "cp28600": "iso885910",
      "iso885911": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "cp28601": "iso885911",
      "iso885913": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u201D\xA2\xA3\xA4\u201E\xA6\xA7\xD8\xA9\u0156\xAB\xAC\xAD\xAE\xC6\xB0\xB1\xB2\xB3\u201C\xB5\xB6\xB7\xF8\xB9\u0157\xBB\xBC\xBD\xBE\xE6\u0104\u012E\u0100\u0106\xC4\xC5\u0118\u0112\u010C\xC9\u0179\u0116\u0122\u0136\u012A\u013B\u0160\u0143\u0145\xD3\u014C\xD5\xD6\xD7\u0172\u0141\u015A\u016A\xDC\u017B\u017D\xDF\u0105\u012F\u0101\u0107\xE4\xE5\u0119\u0113\u010D\xE9\u017A\u0117\u0123\u0137\u012B\u013C\u0161\u0144\u0146\xF3\u014D\xF5\xF6\xF7\u0173\u0142\u015B\u016B\xFC\u017C\u017E\u2019"
      },
      "cp28603": "iso885913",
      "iso885914": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u1E02\u1E03\xA3\u010A\u010B\u1E0A\xA7\u1E80\xA9\u1E82\u1E0B\u1EF2\xAD\xAE\u0178\u1E1E\u1E1F\u0120\u0121\u1E40\u1E41\xB6\u1E56\u1E81\u1E57\u1E83\u1E60\u1EF3\u1E84\u1E85\u1E61\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0174\xD1\xD2\xD3\xD4\xD5\xD6\u1E6A\xD8\xD9\xDA\xDB\xDC\xDD\u0176\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0175\xF1\xF2\xF3\xF4\xF5\xF6\u1E6B\xF8\xF9\xFA\xFB\xFC\xFD\u0177\xFF"
      },
      "cp28604": "iso885914",
      "iso885915": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\u0160\xA7\u0161\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u017D\xB5\xB6\xB7\u017E\xB9\xBA\xBB\u0152\u0153\u0178\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "cp28605": "iso885915",
      "iso885916": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0104\u0105\u0141\u20AC\u201E\u0160\xA7\u0161\xA9\u0218\xAB\u0179\xAD\u017A\u017B\xB0\xB1\u010C\u0142\u017D\u201D\xB6\xB7\u017E\u010D\u0219\xBB\u0152\u0153\u0178\u017C\xC0\xC1\xC2\u0102\xC4\u0106\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0110\u0143\xD2\xD3\xD4\u0150\xD6\u015A\u0170\xD9\xDA\xDB\xDC\u0118\u021A\xDF\xE0\xE1\xE2\u0103\xE4\u0107\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0111\u0144\xF2\xF3\xF4\u0151\xF6\u015B\u0171\xF9\xFA\xFB\xFC\u0119\u021B\xFF"
      },
      "cp28606": "iso885916",
      "cp437": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm437": "cp437",
      "csibm437": "cp437",
      "cp737": {
        "type": "_sbcs",
        "chars": "\u0391\u0392\u0393\u0394\u0395\u0396\u0397\u0398\u0399\u039A\u039B\u039C\u039D\u039E\u039F\u03A0\u03A1\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u03B4\u03B5\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u03C5\u03C6\u03C7\u03C8\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03C9\u03AC\u03AD\u03AE\u03CA\u03AF\u03CC\u03CD\u03CB\u03CE\u0386\u0388\u0389\u038A\u038C\u038E\u038F\xB1\u2265\u2264\u03AA\u03AB\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm737": "cp737",
      "csibm737": "cp737",
      "cp775": {
        "type": "_sbcs",
        "chars": "\u0106\xFC\xE9\u0101\xE4\u0123\xE5\u0107\u0142\u0113\u0156\u0157\u012B\u0179\xC4\xC5\xC9\xE6\xC6\u014D\xF6\u0122\xA2\u015A\u015B\xD6\xDC\xF8\xA3\xD8\xD7\xA4\u0100\u012A\xF3\u017B\u017C\u017A\u201D\xA6\xA9\xAE\xAC\xBD\xBC\u0141\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0104\u010C\u0118\u0116\u2563\u2551\u2557\u255D\u012E\u0160\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0172\u016A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u017D\u0105\u010D\u0119\u0117\u012F\u0161\u0173\u016B\u017E\u2518\u250C\u2588\u2584\u258C\u2590\u2580\xD3\xDF\u014C\u0143\xF5\xD5\xB5\u0144\u0136\u0137\u013B\u013C\u0146\u0112\u0145\u2019\xAD\xB1\u201C\xBE\xB6\xA7\xF7\u201E\xB0\u2219\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm775": "cp775",
      "csibm775": "cp775",
      "cp850": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u0131\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm850": "cp850",
      "csibm850": "cp850",
      "cp852": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\u016F\u0107\xE7\u0142\xEB\u0150\u0151\xEE\u0179\xC4\u0106\xC9\u0139\u013A\xF4\xF6\u013D\u013E\u015A\u015B\xD6\xDC\u0164\u0165\u0141\xD7\u010D\xE1\xED\xF3\xFA\u0104\u0105\u017D\u017E\u0118\u0119\xAC\u017A\u010C\u015F\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\u011A\u015E\u2563\u2551\u2557\u255D\u017B\u017C\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u0102\u0103\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u0111\u0110\u010E\xCB\u010F\u0147\xCD\xCE\u011B\u2518\u250C\u2588\u2584\u0162\u016E\u2580\xD3\xDF\xD4\u0143\u0144\u0148\u0160\u0161\u0154\xDA\u0155\u0170\xFD\xDD\u0163\xB4\xAD\u02DD\u02DB\u02C7\u02D8\xA7\xF7\xB8\xB0\xA8\u02D9\u0171\u0158\u0159\u25A0\xA0"
      },
      "ibm852": "cp852",
      "csibm852": "cp852",
      "cp855": {
        "type": "_sbcs",
        "chars": "\u0452\u0402\u0453\u0403\u0451\u0401\u0454\u0404\u0455\u0405\u0456\u0406\u0457\u0407\u0458\u0408\u0459\u0409\u045A\u040A\u045B\u040B\u045C\u040C\u045E\u040E\u045F\u040F\u044E\u042E\u044A\u042A\u0430\u0410\u0431\u0411\u0446\u0426\u0434\u0414\u0435\u0415\u0444\u0424\u0433\u0413\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u0445\u0425\u0438\u0418\u2563\u2551\u2557\u255D\u0439\u0419\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u043A\u041A\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\u043B\u041B\u043C\u041C\u043D\u041D\u043E\u041E\u043F\u2518\u250C\u2588\u2584\u041F\u044F\u2580\u042F\u0440\u0420\u0441\u0421\u0442\u0422\u0443\u0423\u0436\u0416\u0432\u0412\u044C\u042C\u2116\xAD\u044B\u042B\u0437\u0417\u0448\u0428\u044D\u042D\u0449\u0429\u0447\u0427\xA7\u25A0\xA0"
      },
      "ibm855": "cp855",
      "csibm855": "cp855",
      "cp856": {
        "type": "_sbcs",
        "chars": "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\uFFFD\xA3\uFFFD\xD7\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAE\xAC\xBD\xBC\uFFFD\xAB\xBB\u2591\u2592\u2593\u2502\u2524\uFFFD\uFFFD\uFFFD\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\uFFFD\uFFFD\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u2518\u250C\u2588\u2584\xA6\uFFFD\u2580\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xB5\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm856": "cp856",
      "csibm856": "cp856",
      "cp857": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\u0131\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\u0130\xD6\xDC\xF8\xA3\xD8\u015E\u015F\xE1\xED\xF3\xFA\xF1\xD1\u011E\u011F\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xBA\xAA\xCA\xCB\xC8\uFFFD\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\uFFFD\xD7\xDA\xDB\xD9\xEC\xFF\xAF\xB4\xAD\xB1\uFFFD\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm857": "cp857",
      "csibm857": "cp857",
      "cp858": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\xD7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xAE\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\xC1\xC2\xC0\xA9\u2563\u2551\u2557\u255D\xA2\xA5\u2510\u2514\u2534\u252C\u251C\u2500\u253C\xE3\xC3\u255A\u2554\u2569\u2566\u2560\u2550\u256C\xA4\xF0\xD0\xCA\xCB\xC8\u20AC\xCD\xCE\xCF\u2518\u250C\u2588\u2584\xA6\xCC\u2580\xD3\xDF\xD4\xD2\xF5\xD5\xB5\xFE\xDE\xDA\xDB\xD9\xFD\xDD\xAF\xB4\xAD\xB1\u2017\xBE\xB6\xA7\xF7\xB8\xB0\xA8\xB7\xB9\xB3\xB2\u25A0\xA0"
      },
      "ibm858": "cp858",
      "csibm858": "cp858",
      "cp860": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE3\xE0\xC1\xE7\xEA\xCA\xE8\xCD\xD4\xEC\xC3\xC2\xC9\xC0\xC8\xF4\xF5\xF2\xDA\xF9\xCC\xD5\xDC\xA2\xA3\xD9\u20A7\xD3\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\xD2\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm860": "cp860",
      "csibm860": "cp860",
      "cp861": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xD0\xF0\xDE\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xFE\xFB\xDD\xFD\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xC1\xCD\xD3\xDA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm861": "cp861",
      "csibm861": "cp861",
      "cp862": {
        "type": "_sbcs",
        "chars": "\u05D0\u05D1\u05D2\u05D3\u05D4\u05D5\u05D6\u05D7\u05D8\u05D9\u05DA\u05DB\u05DC\u05DD\u05DE\u05DF\u05E0\u05E1\u05E2\u05E3\u05E4\u05E5\u05E6\u05E7\u05E8\u05E9\u05EA\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm862": "cp862",
      "csibm862": "cp862",
      "cp863": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xC2\xE0\xB6\xE7\xEA\xEB\xE8\xEF\xEE\u2017\xC0\xA7\xC9\xC8\xCA\xF4\xCB\xCF\xFB\xF9\xA4\xD4\xDC\xA2\xA3\xD9\xDB\u0192\xA6\xB4\xF3\xFA\xA8\xB8\xB3\xAF\xCE\u2310\xAC\xBD\xBC\xBE\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm863": "cp863",
      "csibm863": "cp863",
      "cp864": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$\u066A&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xB0\xB7\u2219\u221A\u2592\u2500\u2502\u253C\u2524\u252C\u251C\u2534\u2510\u250C\u2514\u2518\u03B2\u221E\u03C6\xB1\xBD\xBC\u2248\xAB\xBB\uFEF7\uFEF8\uFFFD\uFFFD\uFEFB\uFEFC\uFFFD\xA0\xAD\uFE82\xA3\xA4\uFE84\uFFFD\uFFFD\uFE8E\uFE8F\uFE95\uFE99\u060C\uFE9D\uFEA1\uFEA5\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFED1\u061B\uFEB1\uFEB5\uFEB9\u061F\xA2\uFE80\uFE81\uFE83\uFE85\uFECA\uFE8B\uFE8D\uFE91\uFE93\uFE97\uFE9B\uFE9F\uFEA3\uFEA7\uFEA9\uFEAB\uFEAD\uFEAF\uFEB3\uFEB7\uFEBB\uFEBF\uFEC1\uFEC5\uFECB\uFECF\xA6\xAC\xF7\xD7\uFEC9\u0640\uFED3\uFED7\uFEDB\uFEDF\uFEE3\uFEE7\uFEEB\uFEED\uFEEF\uFEF3\uFEBD\uFECC\uFECE\uFECD\uFEE1\uFE7D\u0651\uFEE5\uFEE9\uFEEC\uFEF0\uFEF2\uFED0\uFED5\uFEF5\uFEF6\uFEDD\uFED9\uFEF1\u25A0\uFFFD"
      },
      "ibm864": "cp864",
      "csibm864": "cp864",
      "cp865": {
        "type": "_sbcs",
        "chars": "\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xF8\xA3\xD8\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xA4\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0"
      },
      "ibm865": "cp865",
      "csibm865": "cp865",
      "cp866": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0404\u0454\u0407\u0457\u040E\u045E\xB0\u2219\xB7\u221A\u2116\xA4\u25A0\xA0"
      },
      "ibm866": "cp866",
      "csibm866": "cp866",
      "cp869": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0386\uFFFD\xB7\xAC\xA6\u2018\u2019\u0388\u2015\u0389\u038A\u03AA\u038C\uFFFD\uFFFD\u038E\u03AB\xA9\u038F\xB2\xB3\u03AC\xA3\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03CD\u0391\u0392\u0393\u0394\u0395\u0396\u0397\xBD\u0398\u0399\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u039A\u039B\u039C\u039D\u2563\u2551\u2557\u255D\u039E\u039F\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u03A0\u03A1\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u03A3\u03A4\u03A5\u03A6\u03A7\u03A8\u03A9\u03B1\u03B2\u03B3\u2518\u250C\u2588\u2584\u03B4\u03B5\u2580\u03B6\u03B7\u03B8\u03B9\u03BA\u03BB\u03BC\u03BD\u03BE\u03BF\u03C0\u03C1\u03C3\u03C2\u03C4\u0384\xAD\xB1\u03C5\u03C6\u03C7\xA7\u03C8\u0385\xB0\xA8\u03C9\u03CB\u03B0\u03CE\u25A0\xA0"
      },
      "ibm869": "cp869",
      "csibm869": "cp869",
      "cp922": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\u203E\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\u0160\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\u017D\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\u0161\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\u017E\xFF"
      },
      "ibm922": "cp922",
      "csibm922": "cp922",
      "cp1046": {
        "type": "_sbcs",
        "chars": "\uFE88\xD7\xF7\uF8F6\uF8F5\uF8F4\uF8F7\uFE71\x88\u25A0\u2502\u2500\u2510\u250C\u2514\u2518\uFE79\uFE7B\uFE7D\uFE7F\uFE77\uFE8A\uFEF0\uFEF3\uFEF2\uFECE\uFECF\uFED0\uFEF6\uFEF8\uFEFA\uFEFC\xA0\uF8FA\uF8F9\uF8F8\xA4\uF8FB\uFE8B\uFE91\uFE97\uFE9B\uFE9F\uFEA3\u060C\xAD\uFEA7\uFEB3\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669\uFEB7\u061B\uFEBB\uFEBF\uFECA\u061F\uFECB\u0621\u0622\u0623\u0624\u0625\u0626\u0627\u0628\u0629\u062A\u062B\u062C\u062D\u062E\u062F\u0630\u0631\u0632\u0633\u0634\u0635\u0636\u0637\uFEC7\u0639\u063A\uFECC\uFE82\uFE84\uFE8E\uFED3\u0640\u0641\u0642\u0643\u0644\u0645\u0646\u0647\u0648\u0649\u064A\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\uFED7\uFEDB\uFEDF\uF8FC\uFEF5\uFEF7\uFEF9\uFEFB\uFEE3\uFEE7\uFEEC\uFEE9\uFFFD"
      },
      "ibm1046": "cp1046",
      "csibm1046": "cp1046",
      "cp1124": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0401\u0402\u0490\u0404\u0405\u0406\u0407\u0408\u0409\u040A\u040B\u040C\xAD\u040E\u040F\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u2116\u0451\u0452\u0491\u0454\u0455\u0456\u0457\u0458\u0459\u045A\u045B\u045C\xA7\u045E\u045F"
      },
      "ibm1124": "cp1124",
      "csibm1124": "cp1124",
      "cp1125": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F\u0401\u0451\u0490\u0491\u0404\u0454\u0406\u0456\u0407\u0457\xB7\u221A\u2116\xA4\u25A0\xA0"
      },
      "ibm1125": "cp1125",
      "csibm1125": "cp1125",
      "cp1129": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "ibm1129": "cp1129",
      "csibm1129": "cp1129",
      "cp1133": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E81\u0E82\u0E84\u0E87\u0E88\u0EAA\u0E8A\u0E8D\u0E94\u0E95\u0E96\u0E97\u0E99\u0E9A\u0E9B\u0E9C\u0E9D\u0E9E\u0E9F\u0EA1\u0EA2\u0EA3\u0EA5\u0EA7\u0EAB\u0EAD\u0EAE\uFFFD\uFFFD\uFFFD\u0EAF\u0EB0\u0EB2\u0EB3\u0EB4\u0EB5\u0EB6\u0EB7\u0EB8\u0EB9\u0EBC\u0EB1\u0EBB\u0EBD\uFFFD\uFFFD\uFFFD\u0EC0\u0EC1\u0EC2\u0EC3\u0EC4\u0EC8\u0EC9\u0ECA\u0ECB\u0ECC\u0ECD\u0EC6\uFFFD\u0EDC\u0EDD\u20AD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0ED0\u0ED1\u0ED2\u0ED3\u0ED4\u0ED5\u0ED6\u0ED7\u0ED8\u0ED9\uFFFD\uFFFD\xA2\xAC\xA6\uFFFD"
      },
      "ibm1133": "cp1133",
      "csibm1133": "cp1133",
      "cp1161": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E48\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\u0E49\u0E4A\u0E4B\u20AC\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\xA2\xAC\xA6\xA0"
      },
      "ibm1161": "cp1161",
      "csibm1161": "cp1161",
      "cp1162": {
        "type": "_sbcs",
        "chars": "\u20AC\x81\x82\x83\x84\u2026\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "ibm1162": "cp1162",
      "csibm1162": "cp1162",
      "cp1163": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\u20AC\xA5\xA6\xA7\u0153\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\u0178\xB5\xB6\xB7\u0152\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\u0102\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\u0300\xCD\xCE\xCF\u0110\xD1\u0309\xD3\xD4\u01A0\xD6\xD7\xD8\xD9\xDA\xDB\xDC\u01AF\u0303\xDF\xE0\xE1\xE2\u0103\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\u0301\xED\xEE\xEF\u0111\xF1\u0323\xF3\xF4\u01A1\xF6\xF7\xF8\xF9\xFA\xFB\xFC\u01B0\u20AB\xFF"
      },
      "ibm1163": "cp1163",
      "csibm1163": "cp1163",
      "maccroatian": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u2126\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uFFFD\xA9\u2044\xA4\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7"
      },
      "maccyrillic": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\xA2\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u2202\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
      },
      "macgreek": {
        "type": "_sbcs",
        "chars": "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\xAD\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\u0387\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\uFFFD"
      },
      "maciceland": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macroman": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macromania": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u015E\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\u0103\u015F\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\u0162\u0163\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macthai": {
        "type": "_sbcs",
        "chars": "\xAB\xBB\u2026\uF88C\uF88F\uF892\uF895\uF898\uF88B\uF88E\uF891\uF894\uF897\u201C\u201D\uF899\uFFFD\u2022\uF884\uF889\uF885\uF886\uF887\uF888\uF88A\uF88D\uF890\uF893\uF896\u2018\u2019\uFFFD\xA0\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFEFF\u200B\u2013\u2014\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u2122\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\xAE\xA9\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "macturkish": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\uFFFD\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "macukraine": {
        "type": "_sbcs",
        "chars": "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\xA4"
      },
      "koi8r": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u2553\u2554\u2555\u2556\u2557\u2558\u2559\u255A\u255B\u255C\u255D\u255E\u255F\u2560\u2561\u0401\u2562\u2563\u2564\u2565\u2566\u2567\u2568\u2569\u256A\u256B\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8u": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u255D\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u256C\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8ru": {
        "type": "_sbcs",
        "chars": "\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2580\u2584\u2588\u258C\u2590\u2591\u2592\u2593\u2320\u25A0\u2219\u221A\u2248\u2264\u2265\xA0\u2321\xB0\xB2\xB7\xF7\u2550\u2551\u2552\u0451\u0454\u2554\u0456\u0457\u2557\u2558\u2559\u255A\u255B\u0491\u045E\u255E\u255F\u2560\u2561\u0401\u0404\u2563\u0406\u0407\u2566\u2567\u2568\u2569\u256A\u0490\u040E\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "koi8t": {
        "type": "_sbcs",
        "chars": "\u049B\u0493\u201A\u0492\u201E\u2026\u2020\u2021\uFFFD\u2030\u04B3\u2039\u04B2\u04B7\u04B6\uFFFD\u049A\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\uFFFD\u203A\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u04EF\u04EE\u0451\xA4\u04E3\xA6\xA7\uFFFD\uFFFD\uFFFD\xAB\xAC\xAD\xAE\uFFFD\xB0\xB1\xB2\u0401\uFFFD\u04E2\xB6\xB7\uFFFD\u2116\uFFFD\xBB\uFFFD\uFFFD\uFFFD\xA9\u044E\u0430\u0431\u0446\u0434\u0435\u0444\u0433\u0445\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u044F\u0440\u0441\u0442\u0443\u0436\u0432\u044C\u044B\u0437\u0448\u044D\u0449\u0447\u044A\u042E\u0410\u0411\u0426\u0414\u0415\u0424\u0413\u0425\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u042F\u0420\u0421\u0422\u0423\u0416\u0412\u042C\u042B\u0417\u0428\u042D\u0429\u0427\u042A"
      },
      "armscii8": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\uFFFD\u0587\u0589)(\xBB\xAB\u2014.\u055D,-\u058A\u2026\u055C\u055B\u055E\u0531\u0561\u0532\u0562\u0533\u0563\u0534\u0564\u0535\u0565\u0536\u0566\u0537\u0567\u0538\u0568\u0539\u0569\u053A\u056A\u053B\u056B\u053C\u056C\u053D\u056D\u053E\u056E\u053F\u056F\u0540\u0570\u0541\u0571\u0542\u0572\u0543\u0573\u0544\u0574\u0545\u0575\u0546\u0576\u0547\u0577\u0548\u0578\u0549\u0579\u054A\u057A\u054B\u057B\u054C\u057C\u054D\u057D\u054E\u057E\u054F\u057F\u0550\u0580\u0551\u0581\u0552\u0582\u0553\u0583\u0554\u0584\u0555\u0585\u0556\u0586\u055A\uFFFD"
      },
      "rk1048": {
        "type": "_sbcs",
        "chars": "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021\u20AC\u2030\u0409\u2039\u040A\u049A\u04BA\u040F\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014\uFFFD\u2122\u0459\u203A\u045A\u049B\u04BB\u045F\xA0\u04B0\u04B1\u04D8\xA4\u04E8\xA6\xA7\u0401\xA9\u0492\xAB\xAC\xAD\xAE\u04AE\xB0\xB1\u0406\u0456\u04E9\xB5\xB6\xB7\u0451\u2116\u0493\xBB\u04D9\u04A2\u04A3\u04AF\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "tcvn": {
        "type": "_sbcs",
        "chars": "\0\xDA\u1EE4\u1EEA\u1EEC\u1EEE\x07\b	\n\v\f\r\u1EE8\u1EF0\u1EF2\u1EF6\u1EF8\xDD\u1EF4\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\xC0\u1EA2\xC3\xC1\u1EA0\u1EB6\u1EAC\xC8\u1EBA\u1EBC\xC9\u1EB8\u1EC6\xCC\u1EC8\u0128\xCD\u1ECA\xD2\u1ECE\xD5\xD3\u1ECC\u1ED8\u1EDC\u1EDE\u1EE0\u1EDA\u1EE2\xD9\u1EE6\u0168\xA0\u0102\xC2\xCA\xD4\u01A0\u01AF\u0110\u0103\xE2\xEA\xF4\u01A1\u01B0\u0111\u1EB0\u0300\u0309\u0303\u0301\u0323\xE0\u1EA3\xE3\xE1\u1EA1\u1EB2\u1EB1\u1EB3\u1EB5\u1EAF\u1EB4\u1EAE\u1EA6\u1EA8\u1EAA\u1EA4\u1EC0\u1EB7\u1EA7\u1EA9\u1EAB\u1EA5\u1EAD\xE8\u1EC2\u1EBB\u1EBD\xE9\u1EB9\u1EC1\u1EC3\u1EC5\u1EBF\u1EC7\xEC\u1EC9\u1EC4\u1EBE\u1ED2\u0129\xED\u1ECB\xF2\u1ED4\u1ECF\xF5\xF3\u1ECD\u1ED3\u1ED5\u1ED7\u1ED1\u1ED9\u1EDD\u1EDF\u1EE1\u1EDB\u1EE3\xF9\u1ED6\u1EE7\u0169\xFA\u1EE5\u1EEB\u1EED\u1EEF\u1EE9\u1EF1\u1EF3\u1EF7\u1EF9\xFD\u1EF5\u1ED0"
      },
      "georgianacademy": {
        "type": "_sbcs",
        "chars": "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10EF\u10F0\u10F1\u10F2\u10F3\u10F4\u10F5\u10F6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "georgianps": {
        "type": "_sbcs",
        "chars": "\x80\x81\u201A\u0192\u201E\u2026\u2020\u2021\u02C6\u2030\u0160\u2039\u0152\x8D\x8E\x8F\x90\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u02DC\u2122\u0161\u203A\u0153\x9D\x9E\u0178\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\u10D0\u10D1\u10D2\u10D3\u10D4\u10D5\u10D6\u10F1\u10D7\u10D8\u10D9\u10DA\u10DB\u10DC\u10F2\u10DD\u10DE\u10DF\u10E0\u10E1\u10E2\u10F3\u10E3\u10E4\u10E5\u10E6\u10E7\u10E8\u10E9\u10EA\u10EB\u10EC\u10ED\u10EE\u10F4\u10EF\u10F0\u10F5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
      },
      "pt154": {
        "type": "_sbcs",
        "chars": "\u0496\u0492\u04EE\u0493\u201E\u2026\u04B6\u04AE\u04B2\u04AF\u04A0\u04E2\u04A2\u049A\u04BA\u04B8\u0497\u2018\u2019\u201C\u201D\u2022\u2013\u2014\u04B3\u04B7\u04A1\u04E3\u04A3\u049B\u04BB\u04B9\xA0\u040E\u045E\u0408\u04E8\u0498\u04B0\xA7\u0401\xA9\u04D8\xAB\xAC\u04EF\xAE\u049C\xB0\u04B1\u0406\u0456\u0499\u04E9\xB6\xB7\u0451\u2116\u04D9\xBB\u0458\u04AA\u04AB\u049D\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F"
      },
      "viscii": {
        "type": "_sbcs",
        "chars": "\0\u1EB2\u1EB4\u1EAA\x07\b	\n\v\f\r\u1EF6\u1EF8\x1B\u1EF4 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7F\u1EA0\u1EAE\u1EB0\u1EB6\u1EA4\u1EA6\u1EA8\u1EAC\u1EBC\u1EB8\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EE2\u1EDA\u1EDC\u1EDE\u1ECA\u1ECE\u1ECC\u1EC8\u1EE6\u0168\u1EE4\u1EF2\xD5\u1EAF\u1EB1\u1EB7\u1EA5\u1EA7\u1EA9\u1EAD\u1EBD\u1EB9\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1ED1\u1ED3\u1ED5\u1ED7\u1EE0\u01A0\u1ED9\u1EDD\u1EDF\u1ECB\u1EF0\u1EE8\u1EEA\u1EEC\u01A1\u1EDB\u01AF\xC0\xC1\xC2\xC3\u1EA2\u0102\u1EB3\u1EB5\xC8\xC9\xCA\u1EBA\xCC\xCD\u0128\u1EF3\u0110\u1EE9\xD2\xD3\xD4\u1EA1\u1EF7\u1EEB\u1EED\xD9\xDA\u1EF9\u1EF5\xDD\u1EE1\u01B0\xE0\xE1\xE2\xE3\u1EA3\u0103\u1EEF\u1EAB\xE8\xE9\xEA\u1EBB\xEC\xED\u0129\u1EC9\u0111\u1EF1\xF2\xF3\xF4\xF5\u1ECF\u1ECD\u1EE5\xF9\xFA\u0169\u1EE7\xFD\u1EE3\u1EEE"
      },
      "iso646cn": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#\xA5%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "iso646jp": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\xA5]^_`abcdefghijklmnopqrstuvwxyz{|}\u203E\x7F\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "hproman8": {
        "type": "_sbcs",
        "chars": "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xC0\xC2\xC8\xCA\xCB\xCE\xCF\xB4\u02CB\u02C6\xA8\u02DC\xD9\xDB\u20A4\xAF\xDD\xFD\xB0\xC7\xE7\xD1\xF1\xA1\xBF\xA4\xA3\xA5\xA7\u0192\xA2\xE2\xEA\xF4\xFB\xE1\xE9\xF3\xFA\xE0\xE8\xF2\xF9\xE4\xEB\xF6\xFC\xC5\xEE\xD8\xC6\xE5\xED\xF8\xE6\xC4\xEC\xD6\xDC\xC9\xEF\xDF\xD4\xC1\xC3\xE3\xD0\xF0\xCD\xCC\xD3\xD2\xD5\xF5\u0160\u0161\xDA\u0178\xFF\xDE\xFE\xB7\xB5\xB6\xBE\u2014\xBC\xBD\xAA\xBA\xAB\u25A0\xBB\xB1\uFFFD"
      },
      "macintosh": {
        "type": "_sbcs",
        "chars": "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u2126\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\xA4\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uFFFD\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
      },
      "ascii": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD"
      },
      "tis620": {
        "type": "_sbcs",
        "chars": "\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0E01\u0E02\u0E03\u0E04\u0E05\u0E06\u0E07\u0E08\u0E09\u0E0A\u0E0B\u0E0C\u0E0D\u0E0E\u0E0F\u0E10\u0E11\u0E12\u0E13\u0E14\u0E15\u0E16\u0E17\u0E18\u0E19\u0E1A\u0E1B\u0E1C\u0E1D\u0E1E\u0E1F\u0E20\u0E21\u0E22\u0E23\u0E24\u0E25\u0E26\u0E27\u0E28\u0E29\u0E2A\u0E2B\u0E2C\u0E2D\u0E2E\u0E2F\u0E30\u0E31\u0E32\u0E33\u0E34\u0E35\u0E36\u0E37\u0E38\u0E39\u0E3A\uFFFD\uFFFD\uFFFD\uFFFD\u0E3F\u0E40\u0E41\u0E42\u0E43\u0E44\u0E45\u0E46\u0E47\u0E48\u0E49\u0E4A\u0E4B\u0E4C\u0E4D\u0E4E\u0E4F\u0E50\u0E51\u0E52\u0E53\u0E54\u0E55\u0E56\u0E57\u0E58\u0E59\u0E5A\u0E5B\uFFFD\uFFFD\uFFFD\uFFFD"
      }
    };
  }
});

// node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS({
  "node_modules/iconv-lite/encodings/dbcs-codec.js"(exports2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    exports2._dbcs = DBCSCodec;
    var UNASSIGNED = -1;
    var GB18030_CODE = -2;
    var SEQ_START = -10;
    var NODE_START = -1e3;
    var UNASSIGNED_NODE = new Array(256);
    var DEF_CHAR = -1;
    for (i = 0; i < 256; i++)
      UNASSIGNED_NODE[i] = UNASSIGNED;
    var i;
    function DBCSCodec(codecOptions, iconv2) {
      this.encodingName = codecOptions.encodingName;
      if (!codecOptions)
        throw new Error("DBCS codec is called without the data.");
      if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");
      var mappingTable = codecOptions.table();
      this.decodeTables = [];
      this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
      this.decodeTableSeq = [];
      for (var i2 = 0; i2 < mappingTable.length; i2++)
        this._addDecodeChunk(mappingTable[i2]);
      if (typeof codecOptions.gb18030 === "function") {
        this.gb18030 = codecOptions.gb18030();
        var commonThirdByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));
        var commonFourthByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));
        var firstByteNode = this.decodeTables[0];
        for (var i2 = 129; i2 <= 254; i2++) {
          var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
          for (var j = 48; j <= 57; j++) {
            if (secondByteNode[j] === UNASSIGNED) {
              secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
            } else if (secondByteNode[j] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 2");
            }
            var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
            for (var k = 129; k <= 254; k++) {
              if (thirdByteNode[k] === UNASSIGNED) {
                thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
              } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
                continue;
              } else if (thirdByteNode[k] > NODE_START) {
                throw new Error("gb18030 decode tables conflict at byte 3");
              }
              var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
              for (var l = 48; l <= 57; l++) {
                if (fourthByteNode[l] === UNASSIGNED)
                  fourthByteNode[l] = GB18030_CODE;
              }
            }
          }
        }
      }
      this.defaultCharUnicode = iconv2.defaultCharUnicode;
      this.encodeTable = [];
      this.encodeTableSeq = [];
      var skipEncodeChars = {};
      if (codecOptions.encodeSkipVals)
        for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
          var val = codecOptions.encodeSkipVals[i2];
          if (typeof val === "number")
            skipEncodeChars[val] = true;
          else
            for (var j = val.from; j <= val.to; j++)
              skipEncodeChars[j] = true;
        }
      this._fillEncodeTable(0, 0, skipEncodeChars);
      if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
          if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
            this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
      }
      this.defCharSB = this.encodeTable[0][iconv2.defaultCharSingleByte.charCodeAt(0)];
      if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
      if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
    }
    DBCSCodec.prototype.encoder = DBCSEncoder;
    DBCSCodec.prototype.decoder = DBCSDecoder;
    DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
      var bytes2 = [];
      for (; addr > 0; addr >>>= 8)
        bytes2.push(addr & 255);
      if (bytes2.length == 0)
        bytes2.push(0);
      var node = this.decodeTables[0];
      for (var i2 = bytes2.length - 1; i2 > 0; i2--) {
        var val = node[bytes2[i2]];
        if (val == UNASSIGNED) {
          node[bytes2[i2]] = NODE_START - this.decodeTables.length;
          this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        } else if (val <= NODE_START) {
          node = this.decodeTables[NODE_START - val];
        } else
          throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
      }
      return node;
    };
    DBCSCodec.prototype._addDecodeChunk = function(chunk) {
      var curAddr = parseInt(chunk[0], 16);
      var writeTable = this._getDecodeTrieNode(curAddr);
      curAddr = curAddr & 255;
      for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") {
          for (var l = 0; l < part.length; ) {
            var code = part.charCodeAt(l++);
            if (55296 <= code && code < 56320) {
              var codeTrail = part.charCodeAt(l++);
              if (56320 <= codeTrail && codeTrail < 57344)
                writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
              else
                throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
            } else if (4080 < code && code <= 4095) {
              var len = 4095 - code + 2;
              var seq = [];
              for (var m = 0; m < len; m++)
                seq.push(part.charCodeAt(l++));
              writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
              this.decodeTableSeq.push(seq);
            } else
              writeTable[curAddr++] = code;
          }
        } else if (typeof part === "number") {
          var charCode = writeTable[curAddr - 1] + 1;
          for (var l = 0; l < part; l++)
            writeTable[curAddr++] = charCode++;
        } else
          throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
      }
      if (curAddr > 255)
        throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    };
    DBCSCodec.prototype._getEncodeBucket = function(uCode) {
      var high = uCode >> 8;
      if (this.encodeTable[high] === void 0)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
      return this.encodeTable[high];
    };
    DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
      else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
    };
    DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
      var uCode = seq[0];
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      var node;
      if (bucket[low] <= SEQ_START) {
        node = this.encodeTableSeq[SEQ_START - bucket[low]];
      } else {
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
      }
      for (var j = 1; j < seq.length - 1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === "object")
          node = oldVal;
        else {
          node = node[uCode] = {};
          if (oldVal !== void 0)
            node[DEF_CHAR] = oldVal;
        }
      }
      uCode = seq[seq.length - 1];
      node[uCode] = dbcsCode;
    };
    DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
      var node = this.decodeTables[nodeIdx];
      var hasValues = false;
      var subNodeEmpty = {};
      for (var i2 = 0; i2 < 256; i2++) {
        var uCode = node[i2];
        var mbCode = prefix + i2;
        if (skipEncodeChars[mbCode])
          continue;
        if (uCode >= 0) {
          this._setEncodeChar(uCode, mbCode);
          hasValues = true;
        } else if (uCode <= NODE_START) {
          var subNodeIdx = NODE_START - uCode;
          if (!subNodeEmpty[subNodeIdx]) {
            var newPrefix = mbCode << 8 >>> 0;
            if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
              hasValues = true;
            else
              subNodeEmpty[subNodeIdx] = true;
          }
        } else if (uCode <= SEQ_START) {
          this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
          hasValues = true;
        }
      }
      return hasValues;
    };
    function DBCSEncoder(options2, codec) {
      this.leadSurrogate = -1;
      this.seqObj = void 0;
      this.encodeTable = codec.encodeTable;
      this.encodeTableSeq = codec.encodeTableSeq;
      this.defaultCharSingleByte = codec.defCharSB;
      this.gb18030 = codec.gb18030;
    }
    DBCSEncoder.prototype.write = function(str) {
      var newBuf = Buffer3.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
      while (true) {
        if (nextChar === -1) {
          if (i2 == str.length) break;
          var uCode = str.charCodeAt(i2++);
        } else {
          var uCode = nextChar;
          nextChar = -1;
        }
        if (55296 <= uCode && uCode < 57344) {
          if (uCode < 56320) {
            if (leadSurrogate === -1) {
              leadSurrogate = uCode;
              continue;
            } else {
              leadSurrogate = uCode;
              uCode = UNASSIGNED;
            }
          } else {
            if (leadSurrogate !== -1) {
              uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
              leadSurrogate = -1;
            } else {
              uCode = UNASSIGNED;
            }
          }
        } else if (leadSurrogate !== -1) {
          nextChar = uCode;
          uCode = UNASSIGNED;
          leadSurrogate = -1;
        }
        var dbcsCode = UNASSIGNED;
        if (seqObj !== void 0 && uCode != UNASSIGNED) {
          var resCode = seqObj[uCode];
          if (typeof resCode === "object") {
            seqObj = resCode;
            continue;
          } else if (typeof resCode == "number") {
            dbcsCode = resCode;
          } else if (resCode == void 0) {
            resCode = seqObj[DEF_CHAR];
            if (resCode !== void 0) {
              dbcsCode = resCode;
              nextChar = uCode;
            } else {
            }
          }
          seqObj = void 0;
        } else if (uCode >= 0) {
          var subtable = this.encodeTable[uCode >> 8];
          if (subtable !== void 0)
            dbcsCode = subtable[uCode & 255];
          if (dbcsCode <= SEQ_START) {
            seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
            continue;
          }
          if (dbcsCode == UNASSIGNED && this.gb18030) {
            var idx = findIdx(this.gb18030.uChars, uCode);
            if (idx != -1) {
              var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
              newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
              dbcsCode = dbcsCode % 12600;
              newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
              dbcsCode = dbcsCode % 1260;
              newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
              dbcsCode = dbcsCode % 10;
              newBuf[j++] = 48 + dbcsCode;
              continue;
            }
          }
        }
        if (dbcsCode === UNASSIGNED)
          dbcsCode = this.defaultCharSingleByte;
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else if (dbcsCode < 65536) {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        } else if (dbcsCode < 16777216) {
          newBuf[j++] = dbcsCode >> 16;
          newBuf[j++] = dbcsCode >> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        } else {
          newBuf[j++] = dbcsCode >>> 24;
          newBuf[j++] = dbcsCode >>> 16 & 255;
          newBuf[j++] = dbcsCode >>> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = seqObj;
      this.leadSurrogate = leadSurrogate;
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.end = function() {
      if (this.leadSurrogate === -1 && this.seqObj === void 0)
        return;
      var newBuf = Buffer3.alloc(10), j = 0;
      if (this.seqObj) {
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== void 0) {
          if (dbcsCode < 256) {
            newBuf[j++] = dbcsCode;
          } else {
            newBuf[j++] = dbcsCode >> 8;
            newBuf[j++] = dbcsCode & 255;
          }
        } else {
        }
        this.seqObj = void 0;
      }
      if (this.leadSurrogate !== -1) {
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
      }
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.findIdx = findIdx;
    function DBCSDecoder(options2, codec) {
      this.nodeIdx = 0;
      this.prevBytes = [];
      this.decodeTables = codec.decodeTables;
      this.decodeTableSeq = codec.decodeTableSeq;
      this.defaultCharUnicode = codec.defaultCharUnicode;
      this.gb18030 = codec.gb18030;
    }
    DBCSDecoder.prototype.write = function(buf) {
      var newBuf = Buffer3.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
      for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
        var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
        var uCode = this.decodeTables[nodeIdx][curByte];
        if (uCode >= 0) {
        } else if (uCode === UNASSIGNED) {
          uCode = this.defaultCharUnicode.charCodeAt(0);
          i2 = seqStart;
        } else if (uCode === GB18030_CODE) {
          if (i2 >= 3) {
            var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
          } else {
            var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
          }
          var idx = findIdx(this.gb18030.gbChars, ptr);
          uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        } else if (uCode <= NODE_START) {
          nodeIdx = NODE_START - uCode;
          continue;
        } else if (uCode <= SEQ_START) {
          var seq = this.decodeTableSeq[SEQ_START - uCode];
          for (var k = 0; k < seq.length - 1; k++) {
            uCode = seq[k];
            newBuf[j++] = uCode & 255;
            newBuf[j++] = uCode >> 8;
          }
          uCode = seq[seq.length - 1];
        } else
          throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
        if (uCode >= 65536) {
          uCode -= 65536;
          var uCodeLead = 55296 | uCode >> 10;
          newBuf[j++] = uCodeLead & 255;
          newBuf[j++] = uCodeLead >> 8;
          uCode = 56320 | uCode & 1023;
        }
        newBuf[j++] = uCode & 255;
        newBuf[j++] = uCode >> 8;
        nodeIdx = 0;
        seqStart = i2 + 1;
      }
      this.nodeIdx = nodeIdx;
      this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
      return newBuf.slice(0, j).toString("ucs2");
    };
    DBCSDecoder.prototype.end = function() {
      var ret = "";
      while (this.prevBytes.length > 0) {
        ret += this.defaultCharUnicode;
        var bytesArr = this.prevBytes.slice(1);
        this.prevBytes = [];
        this.nodeIdx = 0;
        if (bytesArr.length > 0)
          ret += this.write(bytesArr);
      }
      this.prevBytes = [];
      this.nodeIdx = 0;
      return ret;
    };
    function findIdx(table, val) {
      if (table[0] > val)
        return -1;
      var l = 0, r = table.length;
      while (l < r - 1) {
        var mid = l + (r - l + 1 >> 1);
        if (table[mid] <= val)
          l = mid;
        else
          r = mid;
      }
      return l;
    }
  }
});

// node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS({
  "node_modules/iconv-lite/encodings/tables/shiftjis.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 128],
      ["a1", "\uFF61", 62],
      ["8140", "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008", 9, "\uFF0B\uFF0D\xB1\xD7"],
      ["8180", "\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"],
      ["81b8", "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"],
      ["81c8", "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"],
      ["81da", "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"],
      ["81f0", "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"],
      ["81fc", "\u25EF"],
      ["824f", "\uFF10", 9],
      ["8260", "\uFF21", 25],
      ["8281", "\uFF41", 25],
      ["829f", "\u3041", 82],
      ["8340", "\u30A1", 62],
      ["8380", "\u30E0", 22],
      ["839f", "\u0391", 16, "\u03A3", 6],
      ["83bf", "\u03B1", 16, "\u03C3", 6],
      ["8440", "\u0410", 5, "\u0401\u0416", 25],
      ["8470", "\u0430", 5, "\u0451\u0436", 7],
      ["8480", "\u043E", 17],
      ["849f", "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"],
      ["8740", "\u2460", 19, "\u2160", 9],
      ["875f", "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"],
      ["877e", "\u337B"],
      ["8780", "\u301D\u301F\u2116\u33CD\u2121\u32A4", 4, "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"],
      ["889f", "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"],
      ["8940", "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186"],
      ["8980", "\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"],
      ["8a40", "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B"],
      ["8a80", "\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"],
      ["8b40", "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551"],
      ["8b80", "\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"],
      ["8c40", "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8"],
      ["8c80", "\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"],
      ["8d40", "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D"],
      ["8d80", "\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"],
      ["8e40", "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62"],
      ["8e80", "\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"],
      ["8f40", "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3"],
      ["8f80", "\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"],
      ["9040", "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8"],
      ["9080", "\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"],
      ["9140", "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB"],
      ["9180", "\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"],
      ["9240", "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4"],
      ["9280", "\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"],
      ["9340", "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC"],
      ["9380", "\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"],
      ["9440", "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885"],
      ["9480", "\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"],
      ["9540", "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577"],
      ["9580", "\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"],
      ["9640", "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6"],
      ["9680", "\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"],
      ["9740", "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32"],
      ["9780", "\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"],
      ["9840", "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"],
      ["989f", "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"],
      ["9940", "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED"],
      ["9980", "\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"],
      ["9a40", "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638"],
      ["9a80", "\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"],
      ["9b40", "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80"],
      ["9b80", "\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"],
      ["9c40", "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060"],
      ["9c80", "\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"],
      ["9d40", "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B"],
      ["9d80", "\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"],
      ["9e40", "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E"],
      ["9e80", "\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"],
      ["9f40", "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF"],
      ["9f80", "\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"],
      ["e040", "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD"],
      ["e080", "\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"],
      ["e140", "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF"],
      ["e180", "\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"],
      ["e240", "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0"],
      ["e280", "\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"],
      ["e340", "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37"],
      ["e380", "\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"],
      ["e440", "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264"],
      ["e480", "\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"],
      ["e540", "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC"],
      ["e580", "\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"],
      ["e640", "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7"],
      ["e680", "\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"],
      ["e740", "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C"],
      ["e780", "\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"],
      ["e840", "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599"],
      ["e880", "\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"],
      ["e940", "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43"],
      ["e980", "\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"],
      ["ea40", "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF"],
      ["ea80", "\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0\u582F\u69C7\u9059\u7464\u51DC\u7199"],
      ["ed40", "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F"],
      ["ed80", "\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"],
      ["ee40", "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559"],
      ["ee80", "\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"],
      ["eeef", "\u2170", 9, "\uFFE2\uFFE4\uFF07\uFF02"],
      ["f040", "\uE000", 62],
      ["f080", "\uE03F", 124],
      ["f140", "\uE0BC", 62],
      ["f180", "\uE0FB", 124],
      ["f240", "\uE178", 62],
      ["f280", "\uE1B7", 124],
      ["f340", "\uE234", 62],
      ["f380", "\uE273", 124],
      ["f440", "\uE2F0", 62],
      ["f480", "\uE32F", 124],
      ["f540", "\uE3AC", 62],
      ["f580", "\uE3EB", 124],
      ["f640", "\uE468", 62],
      ["f680", "\uE4A7", 124],
      ["f740", "\uE524", 62],
      ["f780", "\uE563", 124],
      ["f840", "\uE5E0", 62],
      ["f880", "\uE61F", 124],
      ["f940", "\uE69C"],
      ["fa40", "\u2170", 9, "\u2160", 9, "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u2235\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A"],
      ["fa80", "\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F"],
      ["fb40", "\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19"],
      ["fb80", "\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9"],
      ["fc40", "\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS({
  "node_modules/iconv-lite/encodings/tables/eucjp.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["8ea1", "\uFF61", 62],
      ["a1a1", "\u3000\u3001\u3002\uFF0C\uFF0E\u30FB\uFF1A\uFF1B\uFF1F\uFF01\u309B\u309C\xB4\uFF40\xA8\uFF3E\uFFE3\uFF3F\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F\uFF3C\uFF5E\u2225\uFF5C\u2026\u2025\u2018\u2019\u201C\u201D\uFF08\uFF09\u3014\u3015\uFF3B\uFF3D\uFF5B\uFF5D\u3008", 9, "\uFF0B\uFF0D\xB1\xD7\xF7\uFF1D\u2260\uFF1C\uFF1E\u2266\u2267\u221E\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFFE5\uFF04\uFFE0\uFFE1\uFF05\uFF03\uFF06\uFF0A\uFF20\xA7\u2606\u2605\u25CB\u25CF\u25CE\u25C7"],
      ["a2a1", "\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u203B\u3012\u2192\u2190\u2191\u2193\u3013"],
      ["a2ba", "\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229"],
      ["a2ca", "\u2227\u2228\uFFE2\u21D2\u21D4\u2200\u2203"],
      ["a2dc", "\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C"],
      ["a2f2", "\u212B\u2030\u266F\u266D\u266A\u2020\u2021\xB6"],
      ["a2fe", "\u25EF"],
      ["a3b0", "\uFF10", 9],
      ["a3c1", "\uFF21", 25],
      ["a3e1", "\uFF41", 25],
      ["a4a1", "\u3041", 82],
      ["a5a1", "\u30A1", 85],
      ["a6a1", "\u0391", 16, "\u03A3", 6],
      ["a6c1", "\u03B1", 16, "\u03C3", 6],
      ["a7a1", "\u0410", 5, "\u0401\u0416", 25],
      ["a7d1", "\u0430", 5, "\u0451\u0436", 25],
      ["a8a1", "\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542"],
      ["ada1", "\u2460", 19, "\u2160", 9],
      ["adc0", "\u3349\u3314\u3322\u334D\u3318\u3327\u3303\u3336\u3351\u3357\u330D\u3326\u3323\u332B\u334A\u333B\u339C\u339D\u339E\u338E\u338F\u33C4\u33A1"],
      ["addf", "\u337B\u301D\u301F\u2116\u33CD\u2121\u32A4", 4, "\u3231\u3232\u3239\u337E\u337D\u337C\u2252\u2261\u222B\u222E\u2211\u221A\u22A5\u2220\u221F\u22BF\u2235\u2229\u222A"],
      ["b0a1", "\u4E9C\u5516\u5A03\u963F\u54C0\u611B\u6328\u59F6\u9022\u8475\u831C\u7A50\u60AA\u63E1\u6E25\u65ED\u8466\u82A6\u9BF5\u6893\u5727\u65A1\u6271\u5B9B\u59D0\u867B\u98F4\u7D62\u7DBE\u9B8E\u6216\u7C9F\u88B7\u5B89\u5EB5\u6309\u6697\u6848\u95C7\u978D\u674F\u4EE5\u4F0A\u4F4D\u4F9D\u5049\u56F2\u5937\u59D4\u5A01\u5C09\u60DF\u610F\u6170\u6613\u6905\u70BA\u754F\u7570\u79FB\u7DAD\u7DEF\u80C3\u840E\u8863\u8B02\u9055\u907A\u533B\u4E95\u4EA5\u57DF\u80B2\u90C1\u78EF\u4E00\u58F1\u6EA2\u9038\u7A32\u8328\u828B\u9C2F\u5141\u5370\u54BD\u54E1\u56E0\u59FB\u5F15\u98F2\u6DEB\u80E4\u852D"],
      ["b1a1", "\u9662\u9670\u96A0\u97FB\u540B\u53F3\u5B87\u70CF\u7FBD\u8FC2\u96E8\u536F\u9D5C\u7ABA\u4E11\u7893\u81FC\u6E26\u5618\u5504\u6B1D\u851A\u9C3B\u59E5\u53A9\u6D66\u74DC\u958F\u5642\u4E91\u904B\u96F2\u834F\u990C\u53E1\u55B6\u5B30\u5F71\u6620\u66F3\u6804\u6C38\u6CF3\u6D29\u745B\u76C8\u7A4E\u9834\u82F1\u885B\u8A60\u92ED\u6DB2\u75AB\u76CA\u99C5\u60A6\u8B01\u8D8A\u95B2\u698E\u53AD\u5186\u5712\u5830\u5944\u5BB4\u5EF6\u6028\u63A9\u63F4\u6CBF\u6F14\u708E\u7114\u7159\u71D5\u733F\u7E01\u8276\u82D1\u8597\u9060\u925B\u9D1B\u5869\u65BC\u6C5A\u7525\u51F9\u592E\u5965\u5F80\u5FDC"],
      ["b2a1", "\u62BC\u65FA\u6A2A\u6B27\u6BB4\u738B\u7FC1\u8956\u9D2C\u9D0E\u9EC4\u5CA1\u6C96\u837B\u5104\u5C4B\u61B6\u81C6\u6876\u7261\u4E59\u4FFA\u5378\u6069\u6E29\u7A4F\u97F3\u4E0B\u5316\u4EEE\u4F55\u4F3D\u4FA1\u4F73\u52A0\u53EF\u5609\u590F\u5AC1\u5BB6\u5BE1\u79D1\u6687\u679C\u67B6\u6B4C\u6CB3\u706B\u73C2\u798D\u79BE\u7A3C\u7B87\u82B1\u82DB\u8304\u8377\u83EF\u83D3\u8766\u8AB2\u5629\u8CA8\u8FE6\u904E\u971E\u868A\u4FC4\u5CE8\u6211\u7259\u753B\u81E5\u82BD\u86FE\u8CC0\u96C5\u9913\u99D5\u4ECB\u4F1A\u89E3\u56DE\u584A\u58CA\u5EFB\u5FEB\u602A\u6094\u6062\u61D0\u6212\u62D0\u6539"],
      ["b3a1", "\u9B41\u6666\u68B0\u6D77\u7070\u754C\u7686\u7D75\u82A5\u87F9\u958B\u968E\u8C9D\u51F1\u52BE\u5916\u54B3\u5BB3\u5D16\u6168\u6982\u6DAF\u788D\u84CB\u8857\u8A72\u93A7\u9AB8\u6D6C\u99A8\u86D9\u57A3\u67FF\u86CE\u920E\u5283\u5687\u5404\u5ED3\u62E1\u64B9\u683C\u6838\u6BBB\u7372\u78BA\u7A6B\u899A\u89D2\u8D6B\u8F03\u90ED\u95A3\u9694\u9769\u5B66\u5CB3\u697D\u984D\u984E\u639B\u7B20\u6A2B\u6A7F\u68B6\u9C0D\u6F5F\u5272\u559D\u6070\u62EC\u6D3B\u6E07\u6ED1\u845B\u8910\u8F44\u4E14\u9C39\u53F6\u691B\u6A3A\u9784\u682A\u515C\u7AC3\u84B2\u91DC\u938C\u565B\u9D28\u6822\u8305\u8431"],
      ["b4a1", "\u7CA5\u5208\u82C5\u74E6\u4E7E\u4F83\u51A0\u5BD2\u520A\u52D8\u52E7\u5DFB\u559A\u582A\u59E6\u5B8C\u5B98\u5BDB\u5E72\u5E79\u60A3\u611F\u6163\u61BE\u63DB\u6562\u67D1\u6853\u68FA\u6B3E\u6B53\u6C57\u6F22\u6F97\u6F45\u74B0\u7518\u76E3\u770B\u7AFF\u7BA1\u7C21\u7DE9\u7F36\u7FF0\u809D\u8266\u839E\u89B3\u8ACC\u8CAB\u9084\u9451\u9593\u9591\u95A2\u9665\u97D3\u9928\u8218\u4E38\u542B\u5CB8\u5DCC\u73A9\u764C\u773C\u5CA9\u7FEB\u8D0B\u96C1\u9811\u9854\u9858\u4F01\u4F0E\u5371\u559C\u5668\u57FA\u5947\u5B09\u5BC4\u5C90\u5E0C\u5E7E\u5FCC\u63EE\u673A\u65D7\u65E2\u671F\u68CB\u68C4"],
      ["b5a1", "\u6A5F\u5E30\u6BC5\u6C17\u6C7D\u757F\u7948\u5B63\u7A00\u7D00\u5FBD\u898F\u8A18\u8CB4\u8D77\u8ECC\u8F1D\u98E2\u9A0E\u9B3C\u4E80\u507D\u5100\u5993\u5B9C\u622F\u6280\u64EC\u6B3A\u72A0\u7591\u7947\u7FA9\u87FB\u8ABC\u8B70\u63AC\u83CA\u97A0\u5409\u5403\u55AB\u6854\u6A58\u8A70\u7827\u6775\u9ECD\u5374\u5BA2\u811A\u8650\u9006\u4E18\u4E45\u4EC7\u4F11\u53CA\u5438\u5BAE\u5F13\u6025\u6551\u673D\u6C42\u6C72\u6CE3\u7078\u7403\u7A76\u7AAE\u7B08\u7D1A\u7CFE\u7D66\u65E7\u725B\u53BB\u5C45\u5DE8\u62D2\u62E0\u6319\u6E20\u865A\u8A31\u8DDD\u92F8\u6F01\u79A6\u9B5A\u4EA8\u4EAB\u4EAC"],
      ["b6a1", "\u4F9B\u4FA0\u50D1\u5147\u7AF6\u5171\u51F6\u5354\u5321\u537F\u53EB\u55AC\u5883\u5CE1\u5F37\u5F4A\u602F\u6050\u606D\u631F\u6559\u6A4B\u6CC1\u72C2\u72ED\u77EF\u80F8\u8105\u8208\u854E\u90F7\u93E1\u97FF\u9957\u9A5A\u4EF0\u51DD\u5C2D\u6681\u696D\u5C40\u66F2\u6975\u7389\u6850\u7C81\u50C5\u52E4\u5747\u5DFE\u9326\u65A4\u6B23\u6B3D\u7434\u7981\u79BD\u7B4B\u7DCA\u82B9\u83CC\u887F\u895F\u8B39\u8FD1\u91D1\u541F\u9280\u4E5D\u5036\u53E5\u533A\u72D7\u7396\u77E9\u82E6\u8EAF\u99C6\u99C8\u99D2\u5177\u611A\u865E\u55B0\u7A7A\u5076\u5BD3\u9047\u9685\u4E32\u6ADB\u91E7\u5C51\u5C48"],
      ["b7a1", "\u6398\u7A9F\u6C93\u9774\u8F61\u7AAA\u718A\u9688\u7C82\u6817\u7E70\u6851\u936C\u52F2\u541B\u85AB\u8A13\u7FA4\u8ECD\u90E1\u5366\u8888\u7941\u4FC2\u50BE\u5211\u5144\u5553\u572D\u73EA\u578B\u5951\u5F62\u5F84\u6075\u6176\u6167\u61A9\u63B2\u643A\u656C\u666F\u6842\u6E13\u7566\u7A3D\u7CFB\u7D4C\u7D99\u7E4B\u7F6B\u830E\u834A\u86CD\u8A08\u8A63\u8B66\u8EFD\u981A\u9D8F\u82B8\u8FCE\u9BE8\u5287\u621F\u6483\u6FC0\u9699\u6841\u5091\u6B20\u6C7A\u6F54\u7A74\u7D50\u8840\u8A23\u6708\u4EF6\u5039\u5026\u5065\u517C\u5238\u5263\u55A7\u570F\u5805\u5ACC\u5EFA\u61B2\u61F8\u62F3\u6372"],
      ["b8a1", "\u691C\u6A29\u727D\u72AC\u732E\u7814\u786F\u7D79\u770C\u80A9\u898B\u8B19\u8CE2\u8ED2\u9063\u9375\u967A\u9855\u9A13\u9E78\u5143\u539F\u53B3\u5E7B\u5F26\u6E1B\u6E90\u7384\u73FE\u7D43\u8237\u8A00\u8AFA\u9650\u4E4E\u500B\u53E4\u547C\u56FA\u59D1\u5B64\u5DF1\u5EAB\u5F27\u6238\u6545\u67AF\u6E56\u72D0\u7CCA\u88B4\u80A1\u80E1\u83F0\u864E\u8A87\u8DE8\u9237\u96C7\u9867\u9F13\u4E94\u4E92\u4F0D\u5348\u5449\u543E\u5A2F\u5F8C\u5FA1\u609F\u68A7\u6A8E\u745A\u7881\u8A9E\u8AA4\u8B77\u9190\u4E5E\u9BC9\u4EA4\u4F7C\u4FAF\u5019\u5016\u5149\u516C\u529F\u52B9\u52FE\u539A\u53E3\u5411"],
      ["b9a1", "\u540E\u5589\u5751\u57A2\u597D\u5B54\u5B5D\u5B8F\u5DE5\u5DE7\u5DF7\u5E78\u5E83\u5E9A\u5EB7\u5F18\u6052\u614C\u6297\u62D8\u63A7\u653B\u6602\u6643\u66F4\u676D\u6821\u6897\u69CB\u6C5F\u6D2A\u6D69\u6E2F\u6E9D\u7532\u7687\u786C\u7A3F\u7CE0\u7D05\u7D18\u7D5E\u7DB1\u8015\u8003\u80AF\u80B1\u8154\u818F\u822A\u8352\u884C\u8861\u8B1B\u8CA2\u8CFC\u90CA\u9175\u9271\u783F\u92FC\u95A4\u964D\u9805\u9999\u9AD8\u9D3B\u525B\u52AB\u53F7\u5408\u58D5\u62F7\u6FE0\u8C6A\u8F5F\u9EB9\u514B\u523B\u544A\u56FD\u7A40\u9177\u9D60\u9ED2\u7344\u6F09\u8170\u7511\u5FFD\u60DA\u9AA8\u72DB\u8FBC"],
      ["baa1", "\u6B64\u9803\u4ECA\u56F0\u5764\u58BE\u5A5A\u6068\u61C7\u660F\u6606\u6839\u68B1\u6DF7\u75D5\u7D3A\u826E\u9B42\u4E9B\u4F50\u53C9\u5506\u5D6F\u5DE6\u5DEE\u67FB\u6C99\u7473\u7802\u8A50\u9396\u88DF\u5750\u5EA7\u632B\u50B5\u50AC\u518D\u6700\u54C9\u585E\u59BB\u5BB0\u5F69\u624D\u63A1\u683D\u6B73\u6E08\u707D\u91C7\u7280\u7815\u7826\u796D\u658E\u7D30\u83DC\u88C1\u8F09\u969B\u5264\u5728\u6750\u7F6A\u8CA1\u51B4\u5742\u962A\u583A\u698A\u80B4\u54B2\u5D0E\u57FC\u7895\u9DFA\u4F5C\u524A\u548B\u643E\u6628\u6714\u67F5\u7A84\u7B56\u7D22\u932F\u685C\u9BAD\u7B39\u5319\u518A\u5237"],
      ["bba1", "\u5BDF\u62F6\u64AE\u64E6\u672D\u6BBA\u85A9\u96D1\u7690\u9BD6\u634C\u9306\u9BAB\u76BF\u6652\u4E09\u5098\u53C2\u5C71\u60E8\u6492\u6563\u685F\u71E6\u73CA\u7523\u7B97\u7E82\u8695\u8B83\u8CDB\u9178\u9910\u65AC\u66AB\u6B8B\u4ED5\u4ED4\u4F3A\u4F7F\u523A\u53F8\u53F2\u55E3\u56DB\u58EB\u59CB\u59C9\u59FF\u5B50\u5C4D\u5E02\u5E2B\u5FD7\u601D\u6307\u652F\u5B5C\u65AF\u65BD\u65E8\u679D\u6B62\u6B7B\u6C0F\u7345\u7949\u79C1\u7CF8\u7D19\u7D2B\u80A2\u8102\u81F3\u8996\u8A5E\u8A69\u8A66\u8A8C\u8AEE\u8CC7\u8CDC\u96CC\u98FC\u6B6F\u4E8B\u4F3C\u4F8D\u5150\u5B57\u5BFA\u6148\u6301\u6642"],
      ["bca1", "\u6B21\u6ECB\u6CBB\u723E\u74BD\u75D4\u78C1\u793A\u800C\u8033\u81EA\u8494\u8F9E\u6C50\u9E7F\u5F0F\u8B58\u9D2B\u7AFA\u8EF8\u5B8D\u96EB\u4E03\u53F1\u57F7\u5931\u5AC9\u5BA4\u6089\u6E7F\u6F06\u75BE\u8CEA\u5B9F\u8500\u7BE0\u5072\u67F4\u829D\u5C61\u854A\u7E1E\u820E\u5199\u5C04\u6368\u8D66\u659C\u716E\u793E\u7D17\u8005\u8B1D\u8ECA\u906E\u86C7\u90AA\u501F\u52FA\u5C3A\u6753\u707C\u7235\u914C\u91C8\u932B\u82E5\u5BC2\u5F31\u60F9\u4E3B\u53D6\u5B88\u624B\u6731\u6B8A\u72E9\u73E0\u7A2E\u816B\u8DA3\u9152\u9996\u5112\u53D7\u546A\u5BFF\u6388\u6A39\u7DAC\u9700\u56DA\u53CE\u5468"],
      ["bda1", "\u5B97\u5C31\u5DDE\u4FEE\u6101\u62FE\u6D32\u79C0\u79CB\u7D42\u7E4D\u7FD2\u81ED\u821F\u8490\u8846\u8972\u8B90\u8E74\u8F2F\u9031\u914B\u916C\u96C6\u919C\u4EC0\u4F4F\u5145\u5341\u5F93\u620E\u67D4\u6C41\u6E0B\u7363\u7E26\u91CD\u9283\u53D4\u5919\u5BBF\u6DD1\u795D\u7E2E\u7C9B\u587E\u719F\u51FA\u8853\u8FF0\u4FCA\u5CFB\u6625\u77AC\u7AE3\u821C\u99FF\u51C6\u5FAA\u65EC\u696F\u6B89\u6DF3\u6E96\u6F64\u76FE\u7D14\u5DE1\u9075\u9187\u9806\u51E6\u521D\u6240\u6691\u66D9\u6E1A\u5EB6\u7DD2\u7F72\u66F8\u85AF\u85F7\u8AF8\u52A9\u53D9\u5973\u5E8F\u5F90\u6055\u92E4\u9664\u50B7\u511F"],
      ["bea1", "\u52DD\u5320\u5347\u53EC\u54E8\u5546\u5531\u5617\u5968\u59BE\u5A3C\u5BB5\u5C06\u5C0F\u5C11\u5C1A\u5E84\u5E8A\u5EE0\u5F70\u627F\u6284\u62DB\u638C\u6377\u6607\u660C\u662D\u6676\u677E\u68A2\u6A1F\u6A35\u6CBC\u6D88\u6E09\u6E58\u713C\u7126\u7167\u75C7\u7701\u785D\u7901\u7965\u79F0\u7AE0\u7B11\u7CA7\u7D39\u8096\u83D6\u848B\u8549\u885D\u88F3\u8A1F\u8A3C\u8A54\u8A73\u8C61\u8CDE\u91A4\u9266\u937E\u9418\u969C\u9798\u4E0A\u4E08\u4E1E\u4E57\u5197\u5270\u57CE\u5834\u58CC\u5B22\u5E38\u60C5\u64FE\u6761\u6756\u6D44\u72B6\u7573\u7A63\u84B8\u8B72\u91B8\u9320\u5631\u57F4\u98FE"],
      ["bfa1", "\u62ED\u690D\u6B96\u71ED\u7E54\u8077\u8272\u89E6\u98DF\u8755\u8FB1\u5C3B\u4F38\u4FE1\u4FB5\u5507\u5A20\u5BDD\u5BE9\u5FC3\u614E\u632F\u65B0\u664B\u68EE\u699B\u6D78\u6DF1\u7533\u75B9\u771F\u795E\u79E6\u7D33\u81E3\u82AF\u85AA\u89AA\u8A3A\u8EAB\u8F9B\u9032\u91DD\u9707\u4EBA\u4EC1\u5203\u5875\u58EC\u5C0B\u751A\u5C3D\u814E\u8A0A\u8FC5\u9663\u976D\u7B25\u8ACF\u9808\u9162\u56F3\u53A8\u9017\u5439\u5782\u5E25\u63A8\u6C34\u708A\u7761\u7C8B\u7FE0\u8870\u9042\u9154\u9310\u9318\u968F\u745E\u9AC4\u5D07\u5D69\u6570\u67A2\u8DA8\u96DB\u636E\u6749\u6919\u83C5\u9817\u96C0\u88FE"],
      ["c0a1", "\u6F84\u647A\u5BF8\u4E16\u702C\u755D\u662F\u51C4\u5236\u52E2\u59D3\u5F81\u6027\u6210\u653F\u6574\u661F\u6674\u68F2\u6816\u6B63\u6E05\u7272\u751F\u76DB\u7CBE\u8056\u58F0\u88FD\u897F\u8AA0\u8A93\u8ACB\u901D\u9192\u9752\u9759\u6589\u7A0E\u8106\u96BB\u5E2D\u60DC\u621A\u65A5\u6614\u6790\u77F3\u7A4D\u7C4D\u7E3E\u810A\u8CAC\u8D64\u8DE1\u8E5F\u78A9\u5207\u62D9\u63A5\u6442\u6298\u8A2D\u7A83\u7BC0\u8AAC\u96EA\u7D76\u820C\u8749\u4ED9\u5148\u5343\u5360\u5BA3\u5C02\u5C16\u5DDD\u6226\u6247\u64B0\u6813\u6834\u6CC9\u6D45\u6D17\u67D3\u6F5C\u714E\u717D\u65CB\u7A7F\u7BAD\u7DDA"],
      ["c1a1", "\u7E4A\u7FA8\u817A\u821B\u8239\u85A6\u8A6E\u8CCE\u8DF5\u9078\u9077\u92AD\u9291\u9583\u9BAE\u524D\u5584\u6F38\u7136\u5168\u7985\u7E55\u81B3\u7CCE\u564C\u5851\u5CA8\u63AA\u66FE\u66FD\u695A\u72D9\u758F\u758E\u790E\u7956\u79DF\u7C97\u7D20\u7D44\u8607\u8A34\u963B\u9061\u9F20\u50E7\u5275\u53CC\u53E2\u5009\u55AA\u58EE\u594F\u723D\u5B8B\u5C64\u531D\u60E3\u60F3\u635C\u6383\u633F\u63BB\u64CD\u65E9\u66F9\u5DE3\u69CD\u69FD\u6F15\u71E5\u4E89\u75E9\u76F8\u7A93\u7CDF\u7DCF\u7D9C\u8061\u8349\u8358\u846C\u84BC\u85FB\u88C5\u8D70\u9001\u906D\u9397\u971C\u9A12\u50CF\u5897\u618E"],
      ["c2a1", "\u81D3\u8535\u8D08\u9020\u4FC3\u5074\u5247\u5373\u606F\u6349\u675F\u6E2C\u8DB3\u901F\u4FD7\u5C5E\u8CCA\u65CF\u7D9A\u5352\u8896\u5176\u63C3\u5B58\u5B6B\u5C0A\u640D\u6751\u905C\u4ED6\u591A\u592A\u6C70\u8A51\u553E\u5815\u59A5\u60F0\u6253\u67C1\u8235\u6955\u9640\u99C4\u9A28\u4F53\u5806\u5BFE\u8010\u5CB1\u5E2F\u5F85\u6020\u614B\u6234\u66FF\u6CF0\u6EDE\u80CE\u817F\u82D4\u888B\u8CB8\u9000\u902E\u968A\u9EDB\u9BDB\u4EE3\u53F0\u5927\u7B2C\u918D\u984C\u9DF9\u6EDD\u7027\u5353\u5544\u5B85\u6258\u629E\u62D3\u6CA2\u6FEF\u7422\u8A17\u9438\u6FC1\u8AFE\u8338\u51E7\u86F8\u53EA"],
      ["c3a1", "\u53E9\u4F46\u9054\u8FB0\u596A\u8131\u5DFD\u7AEA\u8FBF\u68DA\u8C37\u72F8\u9C48\u6A3D\u8AB0\u4E39\u5358\u5606\u5766\u62C5\u63A2\u65E6\u6B4E\u6DE1\u6E5B\u70AD\u77ED\u7AEF\u7BAA\u7DBB\u803D\u80C6\u86CB\u8A95\u935B\u56E3\u58C7\u5F3E\u65AD\u6696\u6A80\u6BB5\u7537\u8AC7\u5024\u77E5\u5730\u5F1B\u6065\u667A\u6C60\u75F4\u7A1A\u7F6E\u81F4\u8718\u9045\u99B3\u7BC9\u755C\u7AF9\u7B51\u84C4\u9010\u79E9\u7A92\u8336\u5AE1\u7740\u4E2D\u4EF2\u5B99\u5FE0\u62BD\u663C\u67F1\u6CE8\u866B\u8877\u8A3B\u914E\u92F3\u99D0\u6A17\u7026\u732A\u82E7\u8457\u8CAF\u4E01\u5146\u51CB\u558B\u5BF5"],
      ["c4a1", "\u5E16\u5E33\u5E81\u5F14\u5F35\u5F6B\u5FB4\u61F2\u6311\u66A2\u671D\u6F6E\u7252\u753A\u773A\u8074\u8139\u8178\u8776\u8ABF\u8ADC\u8D85\u8DF3\u929A\u9577\u9802\u9CE5\u52C5\u6357\u76F4\u6715\u6C88\u73CD\u8CC3\u93AE\u9673\u6D25\u589C\u690E\u69CC\u8FFD\u939A\u75DB\u901A\u585A\u6802\u63B4\u69FB\u4F43\u6F2C\u67D8\u8FBB\u8526\u7DB4\u9354\u693F\u6F70\u576A\u58F7\u5B2C\u7D2C\u722A\u540A\u91E3\u9DB4\u4EAD\u4F4E\u505C\u5075\u5243\u8C9E\u5448\u5824\u5B9A\u5E1D\u5E95\u5EAD\u5EF7\u5F1F\u608C\u62B5\u633A\u63D0\u68AF\u6C40\u7887\u798E\u7A0B\u7DE0\u8247\u8A02\u8AE6\u8E44\u9013"],
      ["c5a1", "\u90B8\u912D\u91D8\u9F0E\u6CE5\u6458\u64E2\u6575\u6EF4\u7684\u7B1B\u9069\u93D1\u6EBA\u54F2\u5FB9\u64A4\u8F4D\u8FED\u9244\u5178\u586B\u5929\u5C55\u5E97\u6DFB\u7E8F\u751C\u8CBC\u8EE2\u985B\u70B9\u4F1D\u6BBF\u6FB1\u7530\u96FB\u514E\u5410\u5835\u5857\u59AC\u5C60\u5F92\u6597\u675C\u6E21\u767B\u83DF\u8CED\u9014\u90FD\u934D\u7825\u783A\u52AA\u5EA6\u571F\u5974\u6012\u5012\u515A\u51AC\u51CD\u5200\u5510\u5854\u5858\u5957\u5B95\u5CF6\u5D8B\u60BC\u6295\u642D\u6771\u6843\u68BC\u68DF\u76D7\u6DD8\u6E6F\u6D9B\u706F\u71C8\u5F53\u75D8\u7977\u7B49\u7B54\u7B52\u7CD6\u7D71\u5230"],
      ["c6a1", "\u8463\u8569\u85E4\u8A0E\u8B04\u8C46\u8E0F\u9003\u900F\u9419\u9676\u982D\u9A30\u95D8\u50CD\u52D5\u540C\u5802\u5C0E\u61A7\u649E\u6D1E\u77B3\u7AE5\u80F4\u8404\u9053\u9285\u5CE0\u9D07\u533F\u5F97\u5FB3\u6D9C\u7279\u7763\u79BF\u7BE4\u6BD2\u72EC\u8AAD\u6803\u6A61\u51F8\u7A81\u6934\u5C4A\u9CF6\u82EB\u5BC5\u9149\u701E\u5678\u5C6F\u60C7\u6566\u6C8C\u8C5A\u9041\u9813\u5451\u66C7\u920D\u5948\u90A3\u5185\u4E4D\u51EA\u8599\u8B0E\u7058\u637A\u934B\u6962\u99B4\u7E04\u7577\u5357\u6960\u8EDF\u96E3\u6C5D\u4E8C\u5C3C\u5F10\u8FE9\u5302\u8CD1\u8089\u8679\u5EFF\u65E5\u4E73\u5165"],
      ["c7a1", "\u5982\u5C3F\u97EE\u4EFB\u598A\u5FCD\u8A8D\u6FE1\u79B0\u7962\u5BE7\u8471\u732B\u71B1\u5E74\u5FF5\u637B\u649A\u71C3\u7C98\u4E43\u5EFC\u4E4B\u57DC\u56A2\u60A9\u6FC3\u7D0D\u80FD\u8133\u81BF\u8FB2\u8997\u86A4\u5DF4\u628A\u64AD\u8987\u6777\u6CE2\u6D3E\u7436\u7834\u5A46\u7F75\u82AD\u99AC\u4FF3\u5EC3\u62DD\u6392\u6557\u676F\u76C3\u724C\u80CC\u80BA\u8F29\u914D\u500D\u57F9\u5A92\u6885\u6973\u7164\u72FD\u8CB7\u58F2\u8CE0\u966A\u9019\u877F\u79E4\u77E7\u8429\u4F2F\u5265\u535A\u62CD\u67CF\u6CCA\u767D\u7B94\u7C95\u8236\u8584\u8FEB\u66DD\u6F20\u7206\u7E1B\u83AB\u99C1\u9EA6"],
      ["c8a1", "\u51FD\u7BB1\u7872\u7BB8\u8087\u7B48\u6AE8\u5E61\u808C\u7551\u7560\u516B\u9262\u6E8C\u767A\u9197\u9AEA\u4F10\u7F70\u629C\u7B4F\u95A5\u9CE9\u567A\u5859\u86E4\u96BC\u4F34\u5224\u534A\u53CD\u53DB\u5E06\u642C\u6591\u677F\u6C3E\u6C4E\u7248\u72AF\u73ED\u7554\u7E41\u822C\u85E9\u8CA9\u7BC4\u91C6\u7169\u9812\u98EF\u633D\u6669\u756A\u76E4\u78D0\u8543\u86EE\u532A\u5351\u5426\u5983\u5E87\u5F7C\u60B2\u6249\u6279\u62AB\u6590\u6BD4\u6CCC\u75B2\u76AE\u7891\u79D8\u7DCB\u7F77\u80A5\u88AB\u8AB9\u8CBB\u907F\u975E\u98DB\u6A0B\u7C38\u5099\u5C3E\u5FAE\u6787\u6BD8\u7435\u7709\u7F8E"],
      ["c9a1", "\u9F3B\u67CA\u7A17\u5339\u758B\u9AED\u5F66\u819D\u83F1\u8098\u5F3C\u5FC5\u7562\u7B46\u903C\u6867\u59EB\u5A9B\u7D10\u767E\u8B2C\u4FF5\u5F6A\u6A19\u6C37\u6F02\u74E2\u7968\u8868\u8A55\u8C79\u5EDF\u63CF\u75C5\u79D2\u82D7\u9328\u92F2\u849C\u86ED\u9C2D\u54C1\u5F6C\u658C\u6D5C\u7015\u8CA7\u8CD3\u983B\u654F\u74F6\u4E0D\u4ED8\u57E0\u592B\u5A66\u5BCC\u51A8\u5E03\u5E9C\u6016\u6276\u6577\u65A7\u666E\u6D6E\u7236\u7B26\u8150\u819A\u8299\u8B5C\u8CA0\u8CE6\u8D74\u961C\u9644\u4FAE\u64AB\u6B66\u821E\u8461\u856A\u90E8\u5C01\u6953\u98A8\u847A\u8557\u4F0F\u526F\u5FA9\u5E45\u670D"],
      ["caa1", "\u798F\u8179\u8907\u8986\u6DF5\u5F17\u6255\u6CB8\u4ECF\u7269\u9B92\u5206\u543B\u5674\u58B3\u61A4\u626E\u711A\u596E\u7C89\u7CDE\u7D1B\u96F0\u6587\u805E\u4E19\u4F75\u5175\u5840\u5E63\u5E73\u5F0A\u67C4\u4E26\u853D\u9589\u965B\u7C73\u9801\u50FB\u58C1\u7656\u78A7\u5225\u77A5\u8511\u7B86\u504F\u5909\u7247\u7BC7\u7DE8\u8FBA\u8FD4\u904D\u4FBF\u52C9\u5A29\u5F01\u97AD\u4FDD\u8217\u92EA\u5703\u6355\u6B69\u752B\u88DC\u8F14\u7A42\u52DF\u5893\u6155\u620A\u66AE\u6BCD\u7C3F\u83E9\u5023\u4FF8\u5305\u5446\u5831\u5949\u5B9D\u5CF0\u5CEF\u5D29\u5E96\u62B1\u6367\u653E\u65B9\u670B"],
      ["cba1", "\u6CD5\u6CE1\u70F9\u7832\u7E2B\u80DE\u82B3\u840C\u84EC\u8702\u8912\u8A2A\u8C4A\u90A6\u92D2\u98FD\u9CF3\u9D6C\u4E4F\u4EA1\u508D\u5256\u574A\u59A8\u5E3D\u5FD8\u5FD9\u623F\u66B4\u671B\u67D0\u68D2\u5192\u7D21\u80AA\u81A8\u8B00\u8C8C\u8CBF\u927E\u9632\u5420\u982C\u5317\u50D5\u535C\u58A8\u64B2\u6734\u7267\u7766\u7A46\u91E6\u52C3\u6CA1\u6B86\u5800\u5E4C\u5954\u672C\u7FFB\u51E1\u76C6\u6469\u78E8\u9B54\u9EBB\u57CB\u59B9\u6627\u679A\u6BCE\u54E9\u69D9\u5E55\u819C\u6795\u9BAA\u67FE\u9C52\u685D\u4EA6\u4FE3\u53C8\u62B9\u672B\u6CAB\u8FC4\u4FAD\u7E6D\u9EBF\u4E07\u6162\u6E80"],
      ["cca1", "\u6F2B\u8513\u5473\u672A\u9B45\u5DF3\u7B95\u5CAC\u5BC6\u871C\u6E4A\u84D1\u7A14\u8108\u5999\u7C8D\u6C11\u7720\u52D9\u5922\u7121\u725F\u77DB\u9727\u9D61\u690B\u5A7F\u5A18\u51A5\u540D\u547D\u660E\u76DF\u8FF7\u9298\u9CF4\u59EA\u725D\u6EC5\u514D\u68C9\u7DBF\u7DEC\u9762\u9EBA\u6478\u6A21\u8302\u5984\u5B5F\u6BDB\u731B\u76F2\u7DB2\u8017\u8499\u5132\u6728\u9ED9\u76EE\u6762\u52FF\u9905\u5C24\u623B\u7C7E\u8CB0\u554F\u60B6\u7D0B\u9580\u5301\u4E5F\u51B6\u591C\u723A\u8036\u91CE\u5F25\u77E2\u5384\u5F79\u7D04\u85AC\u8A33\u8E8D\u9756\u67F3\u85AE\u9453\u6109\u6108\u6CB9\u7652"],
      ["cda1", "\u8AED\u8F38\u552F\u4F51\u512A\u52C7\u53CB\u5BA5\u5E7D\u60A0\u6182\u63D6\u6709\u67DA\u6E67\u6D8C\u7336\u7337\u7531\u7950\u88D5\u8A98\u904A\u9091\u90F5\u96C4\u878D\u5915\u4E88\u4F59\u4E0E\u8A89\u8F3F\u9810\u50AD\u5E7C\u5996\u5BB9\u5EB8\u63DA\u63FA\u64C1\u66DC\u694A\u69D8\u6D0B\u6EB6\u7194\u7528\u7AAF\u7F8A\u8000\u8449\u84C9\u8981\u8B21\u8E0A\u9065\u967D\u990A\u617E\u6291\u6B32\u6C83\u6D74\u7FCC\u7FFC\u6DC0\u7F85\u87BA\u88F8\u6765\u83B1\u983C\u96F7\u6D1B\u7D61\u843D\u916A\u4E71\u5375\u5D50\u6B04\u6FEB\u85CD\u862D\u89A7\u5229\u540F\u5C65\u674E\u68A8\u7406\u7483"],
      ["cea1", "\u75E2\u88CF\u88E1\u91CC\u96E2\u9678\u5F8B\u7387\u7ACB\u844E\u63A0\u7565\u5289\u6D41\u6E9C\u7409\u7559\u786B\u7C92\u9686\u7ADC\u9F8D\u4FB6\u616E\u65C5\u865C\u4E86\u4EAE\u50DA\u4E21\u51CC\u5BEE\u6599\u6881\u6DBC\u731F\u7642\u77AD\u7A1C\u7CE7\u826F\u8AD2\u907C\u91CF\u9675\u9818\u529B\u7DD1\u502B\u5398\u6797\u6DCB\u71D0\u7433\u81E8\u8F2A\u96A3\u9C57\u9E9F\u7460\u5841\u6D99\u7D2F\u985E\u4EE4\u4F36\u4F8B\u51B7\u52B1\u5DBA\u601C\u73B2\u793C\u82D3\u9234\u96B7\u96F6\u970A\u9E97\u9F62\u66A6\u6B74\u5217\u52A3\u70C8\u88C2\u5EC9\u604B\u6190\u6F23\u7149\u7C3E\u7DF4\u806F"],
      ["cfa1", "\u84EE\u9023\u932C\u5442\u9B6F\u6AD3\u7089\u8CC2\u8DEF\u9732\u52B4\u5A41\u5ECA\u5F04\u6717\u697C\u6994\u6D6A\u6F0F\u7262\u72FC\u7BED\u8001\u807E\u874B\u90CE\u516D\u9E93\u7984\u808B\u9332\u8AD6\u502D\u548C\u8A71\u6B6A\u8CC4\u8107\u60D1\u67A0\u9DF2\u4E99\u4E98\u9C10\u8A6B\u85C1\u8568\u6900\u6E7E\u7897\u8155"],
      ["d0a1", "\u5F0C\u4E10\u4E15\u4E2A\u4E31\u4E36\u4E3C\u4E3F\u4E42\u4E56\u4E58\u4E82\u4E85\u8C6B\u4E8A\u8212\u5F0D\u4E8E\u4E9E\u4E9F\u4EA0\u4EA2\u4EB0\u4EB3\u4EB6\u4ECE\u4ECD\u4EC4\u4EC6\u4EC2\u4ED7\u4EDE\u4EED\u4EDF\u4EF7\u4F09\u4F5A\u4F30\u4F5B\u4F5D\u4F57\u4F47\u4F76\u4F88\u4F8F\u4F98\u4F7B\u4F69\u4F70\u4F91\u4F6F\u4F86\u4F96\u5118\u4FD4\u4FDF\u4FCE\u4FD8\u4FDB\u4FD1\u4FDA\u4FD0\u4FE4\u4FE5\u501A\u5028\u5014\u502A\u5025\u5005\u4F1C\u4FF6\u5021\u5029\u502C\u4FFE\u4FEF\u5011\u5006\u5043\u5047\u6703\u5055\u5050\u5048\u505A\u5056\u506C\u5078\u5080\u509A\u5085\u50B4\u50B2"],
      ["d1a1", "\u50C9\u50CA\u50B3\u50C2\u50D6\u50DE\u50E5\u50ED\u50E3\u50EE\u50F9\u50F5\u5109\u5101\u5102\u5116\u5115\u5114\u511A\u5121\u513A\u5137\u513C\u513B\u513F\u5140\u5152\u514C\u5154\u5162\u7AF8\u5169\u516A\u516E\u5180\u5182\u56D8\u518C\u5189\u518F\u5191\u5193\u5195\u5196\u51A4\u51A6\u51A2\u51A9\u51AA\u51AB\u51B3\u51B1\u51B2\u51B0\u51B5\u51BD\u51C5\u51C9\u51DB\u51E0\u8655\u51E9\u51ED\u51F0\u51F5\u51FE\u5204\u520B\u5214\u520E\u5227\u522A\u522E\u5233\u5239\u524F\u5244\u524B\u524C\u525E\u5254\u526A\u5274\u5269\u5273\u527F\u527D\u528D\u5294\u5292\u5271\u5288\u5291\u8FA8"],
      ["d2a1", "\u8FA7\u52AC\u52AD\u52BC\u52B5\u52C1\u52CD\u52D7\u52DE\u52E3\u52E6\u98ED\u52E0\u52F3\u52F5\u52F8\u52F9\u5306\u5308\u7538\u530D\u5310\u530F\u5315\u531A\u5323\u532F\u5331\u5333\u5338\u5340\u5346\u5345\u4E17\u5349\u534D\u51D6\u535E\u5369\u536E\u5918\u537B\u5377\u5382\u5396\u53A0\u53A6\u53A5\u53AE\u53B0\u53B6\u53C3\u7C12\u96D9\u53DF\u66FC\u71EE\u53EE\u53E8\u53ED\u53FA\u5401\u543D\u5440\u542C\u542D\u543C\u542E\u5436\u5429\u541D\u544E\u548F\u5475\u548E\u545F\u5471\u5477\u5470\u5492\u547B\u5480\u5476\u5484\u5490\u5486\u54C7\u54A2\u54B8\u54A5\u54AC\u54C4\u54C8\u54A8"],
      ["d3a1", "\u54AB\u54C2\u54A4\u54BE\u54BC\u54D8\u54E5\u54E6\u550F\u5514\u54FD\u54EE\u54ED\u54FA\u54E2\u5539\u5540\u5563\u554C\u552E\u555C\u5545\u5556\u5557\u5538\u5533\u555D\u5599\u5580\u54AF\u558A\u559F\u557B\u557E\u5598\u559E\u55AE\u557C\u5583\u55A9\u5587\u55A8\u55DA\u55C5\u55DF\u55C4\u55DC\u55E4\u55D4\u5614\u55F7\u5616\u55FE\u55FD\u561B\u55F9\u564E\u5650\u71DF\u5634\u5636\u5632\u5638\u566B\u5664\u562F\u566C\u566A\u5686\u5680\u568A\u56A0\u5694\u568F\u56A5\u56AE\u56B6\u56B4\u56C2\u56BC\u56C1\u56C3\u56C0\u56C8\u56CE\u56D1\u56D3\u56D7\u56EE\u56F9\u5700\u56FF\u5704\u5709"],
      ["d4a1", "\u5708\u570B\u570D\u5713\u5718\u5716\u55C7\u571C\u5726\u5737\u5738\u574E\u573B\u5740\u574F\u5769\u57C0\u5788\u5761\u577F\u5789\u5793\u57A0\u57B3\u57A4\u57AA\u57B0\u57C3\u57C6\u57D4\u57D2\u57D3\u580A\u57D6\u57E3\u580B\u5819\u581D\u5872\u5821\u5862\u584B\u5870\u6BC0\u5852\u583D\u5879\u5885\u58B9\u589F\u58AB\u58BA\u58DE\u58BB\u58B8\u58AE\u58C5\u58D3\u58D1\u58D7\u58D9\u58D8\u58E5\u58DC\u58E4\u58DF\u58EF\u58FA\u58F9\u58FB\u58FC\u58FD\u5902\u590A\u5910\u591B\u68A6\u5925\u592C\u592D\u5932\u5938\u593E\u7AD2\u5955\u5950\u594E\u595A\u5958\u5962\u5960\u5967\u596C\u5969"],
      ["d5a1", "\u5978\u5981\u599D\u4F5E\u4FAB\u59A3\u59B2\u59C6\u59E8\u59DC\u598D\u59D9\u59DA\u5A25\u5A1F\u5A11\u5A1C\u5A09\u5A1A\u5A40\u5A6C\u5A49\u5A35\u5A36\u5A62\u5A6A\u5A9A\u5ABC\u5ABE\u5ACB\u5AC2\u5ABD\u5AE3\u5AD7\u5AE6\u5AE9\u5AD6\u5AFA\u5AFB\u5B0C\u5B0B\u5B16\u5B32\u5AD0\u5B2A\u5B36\u5B3E\u5B43\u5B45\u5B40\u5B51\u5B55\u5B5A\u5B5B\u5B65\u5B69\u5B70\u5B73\u5B75\u5B78\u6588\u5B7A\u5B80\u5B83\u5BA6\u5BB8\u5BC3\u5BC7\u5BC9\u5BD4\u5BD0\u5BE4\u5BE6\u5BE2\u5BDE\u5BE5\u5BEB\u5BF0\u5BF6\u5BF3\u5C05\u5C07\u5C08\u5C0D\u5C13\u5C20\u5C22\u5C28\u5C38\u5C39\u5C41\u5C46\u5C4E\u5C53"],
      ["d6a1", "\u5C50\u5C4F\u5B71\u5C6C\u5C6E\u4E62\u5C76\u5C79\u5C8C\u5C91\u5C94\u599B\u5CAB\u5CBB\u5CB6\u5CBC\u5CB7\u5CC5\u5CBE\u5CC7\u5CD9\u5CE9\u5CFD\u5CFA\u5CED\u5D8C\u5CEA\u5D0B\u5D15\u5D17\u5D5C\u5D1F\u5D1B\u5D11\u5D14\u5D22\u5D1A\u5D19\u5D18\u5D4C\u5D52\u5D4E\u5D4B\u5D6C\u5D73\u5D76\u5D87\u5D84\u5D82\u5DA2\u5D9D\u5DAC\u5DAE\u5DBD\u5D90\u5DB7\u5DBC\u5DC9\u5DCD\u5DD3\u5DD2\u5DD6\u5DDB\u5DEB\u5DF2\u5DF5\u5E0B\u5E1A\u5E19\u5E11\u5E1B\u5E36\u5E37\u5E44\u5E43\u5E40\u5E4E\u5E57\u5E54\u5E5F\u5E62\u5E64\u5E47\u5E75\u5E76\u5E7A\u9EBC\u5E7F\u5EA0\u5EC1\u5EC2\u5EC8\u5ED0\u5ECF"],
      ["d7a1", "\u5ED6\u5EE3\u5EDD\u5EDA\u5EDB\u5EE2\u5EE1\u5EE8\u5EE9\u5EEC\u5EF1\u5EF3\u5EF0\u5EF4\u5EF8\u5EFE\u5F03\u5F09\u5F5D\u5F5C\u5F0B\u5F11\u5F16\u5F29\u5F2D\u5F38\u5F41\u5F48\u5F4C\u5F4E\u5F2F\u5F51\u5F56\u5F57\u5F59\u5F61\u5F6D\u5F73\u5F77\u5F83\u5F82\u5F7F\u5F8A\u5F88\u5F91\u5F87\u5F9E\u5F99\u5F98\u5FA0\u5FA8\u5FAD\u5FBC\u5FD6\u5FFB\u5FE4\u5FF8\u5FF1\u5FDD\u60B3\u5FFF\u6021\u6060\u6019\u6010\u6029\u600E\u6031\u601B\u6015\u602B\u6026\u600F\u603A\u605A\u6041\u606A\u6077\u605F\u604A\u6046\u604D\u6063\u6043\u6064\u6042\u606C\u606B\u6059\u6081\u608D\u60E7\u6083\u609A"],
      ["d8a1", "\u6084\u609B\u6096\u6097\u6092\u60A7\u608B\u60E1\u60B8\u60E0\u60D3\u60B4\u5FF0\u60BD\u60C6\u60B5\u60D8\u614D\u6115\u6106\u60F6\u60F7\u6100\u60F4\u60FA\u6103\u6121\u60FB\u60F1\u610D\u610E\u6147\u613E\u6128\u6127\u614A\u613F\u613C\u612C\u6134\u613D\u6142\u6144\u6173\u6177\u6158\u6159\u615A\u616B\u6174\u616F\u6165\u6171\u615F\u615D\u6153\u6175\u6199\u6196\u6187\u61AC\u6194\u619A\u618A\u6191\u61AB\u61AE\u61CC\u61CA\u61C9\u61F7\u61C8\u61C3\u61C6\u61BA\u61CB\u7F79\u61CD\u61E6\u61E3\u61F6\u61FA\u61F4\u61FF\u61FD\u61FC\u61FE\u6200\u6208\u6209\u620D\u620C\u6214\u621B"],
      ["d9a1", "\u621E\u6221\u622A\u622E\u6230\u6232\u6233\u6241\u624E\u625E\u6263\u625B\u6260\u6268\u627C\u6282\u6289\u627E\u6292\u6293\u6296\u62D4\u6283\u6294\u62D7\u62D1\u62BB\u62CF\u62FF\u62C6\u64D4\u62C8\u62DC\u62CC\u62CA\u62C2\u62C7\u629B\u62C9\u630C\u62EE\u62F1\u6327\u6302\u6308\u62EF\u62F5\u6350\u633E\u634D\u641C\u634F\u6396\u638E\u6380\u63AB\u6376\u63A3\u638F\u6389\u639F\u63B5\u636B\u6369\u63BE\u63E9\u63C0\u63C6\u63E3\u63C9\u63D2\u63F6\u63C4\u6416\u6434\u6406\u6413\u6426\u6436\u651D\u6417\u6428\u640F\u6467\u646F\u6476\u644E\u652A\u6495\u6493\u64A5\u64A9\u6488\u64BC"],
      ["daa1", "\u64DA\u64D2\u64C5\u64C7\u64BB\u64D8\u64C2\u64F1\u64E7\u8209\u64E0\u64E1\u62AC\u64E3\u64EF\u652C\u64F6\u64F4\u64F2\u64FA\u6500\u64FD\u6518\u651C\u6505\u6524\u6523\u652B\u6534\u6535\u6537\u6536\u6538\u754B\u6548\u6556\u6555\u654D\u6558\u655E\u655D\u6572\u6578\u6582\u6583\u8B8A\u659B\u659F\u65AB\u65B7\u65C3\u65C6\u65C1\u65C4\u65CC\u65D2\u65DB\u65D9\u65E0\u65E1\u65F1\u6772\u660A\u6603\u65FB\u6773\u6635\u6636\u6634\u661C\u664F\u6644\u6649\u6641\u665E\u665D\u6664\u6667\u6668\u665F\u6662\u6670\u6683\u6688\u668E\u6689\u6684\u6698\u669D\u66C1\u66B9\u66C9\u66BE\u66BC"],
      ["dba1", "\u66C4\u66B8\u66D6\u66DA\u66E0\u663F\u66E6\u66E9\u66F0\u66F5\u66F7\u670F\u6716\u671E\u6726\u6727\u9738\u672E\u673F\u6736\u6741\u6738\u6737\u6746\u675E\u6760\u6759\u6763\u6764\u6789\u6770\u67A9\u677C\u676A\u678C\u678B\u67A6\u67A1\u6785\u67B7\u67EF\u67B4\u67EC\u67B3\u67E9\u67B8\u67E4\u67DE\u67DD\u67E2\u67EE\u67B9\u67CE\u67C6\u67E7\u6A9C\u681E\u6846\u6829\u6840\u684D\u6832\u684E\u68B3\u682B\u6859\u6863\u6877\u687F\u689F\u688F\u68AD\u6894\u689D\u689B\u6883\u6AAE\u68B9\u6874\u68B5\u68A0\u68BA\u690F\u688D\u687E\u6901\u68CA\u6908\u68D8\u6922\u6926\u68E1\u690C\u68CD"],
      ["dca1", "\u68D4\u68E7\u68D5\u6936\u6912\u6904\u68D7\u68E3\u6925\u68F9\u68E0\u68EF\u6928\u692A\u691A\u6923\u6921\u68C6\u6979\u6977\u695C\u6978\u696B\u6954\u697E\u696E\u6939\u6974\u693D\u6959\u6930\u6961\u695E\u695D\u6981\u696A\u69B2\u69AE\u69D0\u69BF\u69C1\u69D3\u69BE\u69CE\u5BE8\u69CA\u69DD\u69BB\u69C3\u69A7\u6A2E\u6991\u69A0\u699C\u6995\u69B4\u69DE\u69E8\u6A02\u6A1B\u69FF\u6B0A\u69F9\u69F2\u69E7\u6A05\u69B1\u6A1E\u69ED\u6A14\u69EB\u6A0A\u6A12\u6AC1\u6A23\u6A13\u6A44\u6A0C\u6A72\u6A36\u6A78\u6A47\u6A62\u6A59\u6A66\u6A48\u6A38\u6A22\u6A90\u6A8D\u6AA0\u6A84\u6AA2\u6AA3"],
      ["dda1", "\u6A97\u8617\u6ABB\u6AC3\u6AC2\u6AB8\u6AB3\u6AAC\u6ADE\u6AD1\u6ADF\u6AAA\u6ADA\u6AEA\u6AFB\u6B05\u8616\u6AFA\u6B12\u6B16\u9B31\u6B1F\u6B38\u6B37\u76DC\u6B39\u98EE\u6B47\u6B43\u6B49\u6B50\u6B59\u6B54\u6B5B\u6B5F\u6B61\u6B78\u6B79\u6B7F\u6B80\u6B84\u6B83\u6B8D\u6B98\u6B95\u6B9E\u6BA4\u6BAA\u6BAB\u6BAF\u6BB2\u6BB1\u6BB3\u6BB7\u6BBC\u6BC6\u6BCB\u6BD3\u6BDF\u6BEC\u6BEB\u6BF3\u6BEF\u9EBE\u6C08\u6C13\u6C14\u6C1B\u6C24\u6C23\u6C5E\u6C55\u6C62\u6C6A\u6C82\u6C8D\u6C9A\u6C81\u6C9B\u6C7E\u6C68\u6C73\u6C92\u6C90\u6CC4\u6CF1\u6CD3\u6CBD\u6CD7\u6CC5\u6CDD\u6CAE\u6CB1\u6CBE"],
      ["dea1", "\u6CBA\u6CDB\u6CEF\u6CD9\u6CEA\u6D1F\u884D\u6D36\u6D2B\u6D3D\u6D38\u6D19\u6D35\u6D33\u6D12\u6D0C\u6D63\u6D93\u6D64\u6D5A\u6D79\u6D59\u6D8E\u6D95\u6FE4\u6D85\u6DF9\u6E15\u6E0A\u6DB5\u6DC7\u6DE6\u6DB8\u6DC6\u6DEC\u6DDE\u6DCC\u6DE8\u6DD2\u6DC5\u6DFA\u6DD9\u6DE4\u6DD5\u6DEA\u6DEE\u6E2D\u6E6E\u6E2E\u6E19\u6E72\u6E5F\u6E3E\u6E23\u6E6B\u6E2B\u6E76\u6E4D\u6E1F\u6E43\u6E3A\u6E4E\u6E24\u6EFF\u6E1D\u6E38\u6E82\u6EAA\u6E98\u6EC9\u6EB7\u6ED3\u6EBD\u6EAF\u6EC4\u6EB2\u6ED4\u6ED5\u6E8F\u6EA5\u6EC2\u6E9F\u6F41\u6F11\u704C\u6EEC\u6EF8\u6EFE\u6F3F\u6EF2\u6F31\u6EEF\u6F32\u6ECC"],
      ["dfa1", "\u6F3E\u6F13\u6EF7\u6F86\u6F7A\u6F78\u6F81\u6F80\u6F6F\u6F5B\u6FF3\u6F6D\u6F82\u6F7C\u6F58\u6F8E\u6F91\u6FC2\u6F66\u6FB3\u6FA3\u6FA1\u6FA4\u6FB9\u6FC6\u6FAA\u6FDF\u6FD5\u6FEC\u6FD4\u6FD8\u6FF1\u6FEE\u6FDB\u7009\u700B\u6FFA\u7011\u7001\u700F\u6FFE\u701B\u701A\u6F74\u701D\u7018\u701F\u7030\u703E\u7032\u7051\u7063\u7099\u7092\u70AF\u70F1\u70AC\u70B8\u70B3\u70AE\u70DF\u70CB\u70DD\u70D9\u7109\u70FD\u711C\u7119\u7165\u7155\u7188\u7166\u7162\u714C\u7156\u716C\u718F\u71FB\u7184\u7195\u71A8\u71AC\u71D7\u71B9\u71BE\u71D2\u71C9\u71D4\u71CE\u71E0\u71EC\u71E7\u71F5\u71FC"],
      ["e0a1", "\u71F9\u71FF\u720D\u7210\u721B\u7228\u722D\u722C\u7230\u7232\u723B\u723C\u723F\u7240\u7246\u724B\u7258\u7274\u727E\u7282\u7281\u7287\u7292\u7296\u72A2\u72A7\u72B9\u72B2\u72C3\u72C6\u72C4\u72CE\u72D2\u72E2\u72E0\u72E1\u72F9\u72F7\u500F\u7317\u730A\u731C\u7316\u731D\u7334\u732F\u7329\u7325\u733E\u734E\u734F\u9ED8\u7357\u736A\u7368\u7370\u7378\u7375\u737B\u737A\u73C8\u73B3\u73CE\u73BB\u73C0\u73E5\u73EE\u73DE\u74A2\u7405\u746F\u7425\u73F8\u7432\u743A\u7455\u743F\u745F\u7459\u7441\u745C\u7469\u7470\u7463\u746A\u7476\u747E\u748B\u749E\u74A7\u74CA\u74CF\u74D4\u73F1"],
      ["e1a1", "\u74E0\u74E3\u74E7\u74E9\u74EE\u74F2\u74F0\u74F1\u74F8\u74F7\u7504\u7503\u7505\u750C\u750E\u750D\u7515\u7513\u751E\u7526\u752C\u753C\u7544\u754D\u754A\u7549\u755B\u7546\u755A\u7569\u7564\u7567\u756B\u756D\u7578\u7576\u7586\u7587\u7574\u758A\u7589\u7582\u7594\u759A\u759D\u75A5\u75A3\u75C2\u75B3\u75C3\u75B5\u75BD\u75B8\u75BC\u75B1\u75CD\u75CA\u75D2\u75D9\u75E3\u75DE\u75FE\u75FF\u75FC\u7601\u75F0\u75FA\u75F2\u75F3\u760B\u760D\u7609\u761F\u7627\u7620\u7621\u7622\u7624\u7634\u7630\u763B\u7647\u7648\u7646\u765C\u7658\u7661\u7662\u7668\u7669\u766A\u7667\u766C\u7670"],
      ["e2a1", "\u7672\u7676\u7678\u767C\u7680\u7683\u7688\u768B\u768E\u7696\u7693\u7699\u769A\u76B0\u76B4\u76B8\u76B9\u76BA\u76C2\u76CD\u76D6\u76D2\u76DE\u76E1\u76E5\u76E7\u76EA\u862F\u76FB\u7708\u7707\u7704\u7729\u7724\u771E\u7725\u7726\u771B\u7737\u7738\u7747\u775A\u7768\u776B\u775B\u7765\u777F\u777E\u7779\u778E\u778B\u7791\u77A0\u779E\u77B0\u77B6\u77B9\u77BF\u77BC\u77BD\u77BB\u77C7\u77CD\u77D7\u77DA\u77DC\u77E3\u77EE\u77FC\u780C\u7812\u7926\u7820\u792A\u7845\u788E\u7874\u7886\u787C\u789A\u788C\u78A3\u78B5\u78AA\u78AF\u78D1\u78C6\u78CB\u78D4\u78BE\u78BC\u78C5\u78CA\u78EC"],
      ["e3a1", "\u78E7\u78DA\u78FD\u78F4\u7907\u7912\u7911\u7919\u792C\u792B\u7940\u7960\u7957\u795F\u795A\u7955\u7953\u797A\u797F\u798A\u799D\u79A7\u9F4B\u79AA\u79AE\u79B3\u79B9\u79BA\u79C9\u79D5\u79E7\u79EC\u79E1\u79E3\u7A08\u7A0D\u7A18\u7A19\u7A20\u7A1F\u7980\u7A31\u7A3B\u7A3E\u7A37\u7A43\u7A57\u7A49\u7A61\u7A62\u7A69\u9F9D\u7A70\u7A79\u7A7D\u7A88\u7A97\u7A95\u7A98\u7A96\u7AA9\u7AC8\u7AB0\u7AB6\u7AC5\u7AC4\u7ABF\u9083\u7AC7\u7ACA\u7ACD\u7ACF\u7AD5\u7AD3\u7AD9\u7ADA\u7ADD\u7AE1\u7AE2\u7AE6\u7AED\u7AF0\u7B02\u7B0F\u7B0A\u7B06\u7B33\u7B18\u7B19\u7B1E\u7B35\u7B28\u7B36\u7B50"],
      ["e4a1", "\u7B7A\u7B04\u7B4D\u7B0B\u7B4C\u7B45\u7B75\u7B65\u7B74\u7B67\u7B70\u7B71\u7B6C\u7B6E\u7B9D\u7B98\u7B9F\u7B8D\u7B9C\u7B9A\u7B8B\u7B92\u7B8F\u7B5D\u7B99\u7BCB\u7BC1\u7BCC\u7BCF\u7BB4\u7BC6\u7BDD\u7BE9\u7C11\u7C14\u7BE6\u7BE5\u7C60\u7C00\u7C07\u7C13\u7BF3\u7BF7\u7C17\u7C0D\u7BF6\u7C23\u7C27\u7C2A\u7C1F\u7C37\u7C2B\u7C3D\u7C4C\u7C43\u7C54\u7C4F\u7C40\u7C50\u7C58\u7C5F\u7C64\u7C56\u7C65\u7C6C\u7C75\u7C83\u7C90\u7CA4\u7CAD\u7CA2\u7CAB\u7CA1\u7CA8\u7CB3\u7CB2\u7CB1\u7CAE\u7CB9\u7CBD\u7CC0\u7CC5\u7CC2\u7CD8\u7CD2\u7CDC\u7CE2\u9B3B\u7CEF\u7CF2\u7CF4\u7CF6\u7CFA\u7D06"],
      ["e5a1", "\u7D02\u7D1C\u7D15\u7D0A\u7D45\u7D4B\u7D2E\u7D32\u7D3F\u7D35\u7D46\u7D73\u7D56\u7D4E\u7D72\u7D68\u7D6E\u7D4F\u7D63\u7D93\u7D89\u7D5B\u7D8F\u7D7D\u7D9B\u7DBA\u7DAE\u7DA3\u7DB5\u7DC7\u7DBD\u7DAB\u7E3D\u7DA2\u7DAF\u7DDC\u7DB8\u7D9F\u7DB0\u7DD8\u7DDD\u7DE4\u7DDE\u7DFB\u7DF2\u7DE1\u7E05\u7E0A\u7E23\u7E21\u7E12\u7E31\u7E1F\u7E09\u7E0B\u7E22\u7E46\u7E66\u7E3B\u7E35\u7E39\u7E43\u7E37\u7E32\u7E3A\u7E67\u7E5D\u7E56\u7E5E\u7E59\u7E5A\u7E79\u7E6A\u7E69\u7E7C\u7E7B\u7E83\u7DD5\u7E7D\u8FAE\u7E7F\u7E88\u7E89\u7E8C\u7E92\u7E90\u7E93\u7E94\u7E96\u7E8E\u7E9B\u7E9C\u7F38\u7F3A"],
      ["e6a1", "\u7F45\u7F4C\u7F4D\u7F4E\u7F50\u7F51\u7F55\u7F54\u7F58\u7F5F\u7F60\u7F68\u7F69\u7F67\u7F78\u7F82\u7F86\u7F83\u7F88\u7F87\u7F8C\u7F94\u7F9E\u7F9D\u7F9A\u7FA3\u7FAF\u7FB2\u7FB9\u7FAE\u7FB6\u7FB8\u8B71\u7FC5\u7FC6\u7FCA\u7FD5\u7FD4\u7FE1\u7FE6\u7FE9\u7FF3\u7FF9\u98DC\u8006\u8004\u800B\u8012\u8018\u8019\u801C\u8021\u8028\u803F\u803B\u804A\u8046\u8052\u8058\u805A\u805F\u8062\u8068\u8073\u8072\u8070\u8076\u8079\u807D\u807F\u8084\u8086\u8085\u809B\u8093\u809A\u80AD\u5190\u80AC\u80DB\u80E5\u80D9\u80DD\u80C4\u80DA\u80D6\u8109\u80EF\u80F1\u811B\u8129\u8123\u812F\u814B"],
      ["e7a1", "\u968B\u8146\u813E\u8153\u8151\u80FC\u8171\u816E\u8165\u8166\u8174\u8183\u8188\u818A\u8180\u8182\u81A0\u8195\u81A4\u81A3\u815F\u8193\u81A9\u81B0\u81B5\u81BE\u81B8\u81BD\u81C0\u81C2\u81BA\u81C9\u81CD\u81D1\u81D9\u81D8\u81C8\u81DA\u81DF\u81E0\u81E7\u81FA\u81FB\u81FE\u8201\u8202\u8205\u8207\u820A\u820D\u8210\u8216\u8229\u822B\u8238\u8233\u8240\u8259\u8258\u825D\u825A\u825F\u8264\u8262\u8268\u826A\u826B\u822E\u8271\u8277\u8278\u827E\u828D\u8292\u82AB\u829F\u82BB\u82AC\u82E1\u82E3\u82DF\u82D2\u82F4\u82F3\u82FA\u8393\u8303\u82FB\u82F9\u82DE\u8306\u82DC\u8309\u82D9"],
      ["e8a1", "\u8335\u8334\u8316\u8332\u8331\u8340\u8339\u8350\u8345\u832F\u832B\u8317\u8318\u8385\u839A\u83AA\u839F\u83A2\u8396\u8323\u838E\u8387\u838A\u837C\u83B5\u8373\u8375\u83A0\u8389\u83A8\u83F4\u8413\u83EB\u83CE\u83FD\u8403\u83D8\u840B\u83C1\u83F7\u8407\u83E0\u83F2\u840D\u8422\u8420\u83BD\u8438\u8506\u83FB\u846D\u842A\u843C\u855A\u8484\u8477\u846B\u84AD\u846E\u8482\u8469\u8446\u842C\u846F\u8479\u8435\u84CA\u8462\u84B9\u84BF\u849F\u84D9\u84CD\u84BB\u84DA\u84D0\u84C1\u84C6\u84D6\u84A1\u8521\u84FF\u84F4\u8517\u8518\u852C\u851F\u8515\u8514\u84FC\u8540\u8563\u8558\u8548"],
      ["e9a1", "\u8541\u8602\u854B\u8555\u8580\u85A4\u8588\u8591\u858A\u85A8\u856D\u8594\u859B\u85EA\u8587\u859C\u8577\u857E\u8590\u85C9\u85BA\u85CF\u85B9\u85D0\u85D5\u85DD\u85E5\u85DC\u85F9\u860A\u8613\u860B\u85FE\u85FA\u8606\u8622\u861A\u8630\u863F\u864D\u4E55\u8654\u865F\u8667\u8671\u8693\u86A3\u86A9\u86AA\u868B\u868C\u86B6\u86AF\u86C4\u86C6\u86B0\u86C9\u8823\u86AB\u86D4\u86DE\u86E9\u86EC\u86DF\u86DB\u86EF\u8712\u8706\u8708\u8700\u8703\u86FB\u8711\u8709\u870D\u86F9\u870A\u8734\u873F\u8737\u873B\u8725\u8729\u871A\u8760\u875F\u8778\u874C\u874E\u8774\u8757\u8768\u876E\u8759"],
      ["eaa1", "\u8753\u8763\u876A\u8805\u87A2\u879F\u8782\u87AF\u87CB\u87BD\u87C0\u87D0\u96D6\u87AB\u87C4\u87B3\u87C7\u87C6\u87BB\u87EF\u87F2\u87E0\u880F\u880D\u87FE\u87F6\u87F7\u880E\u87D2\u8811\u8816\u8815\u8822\u8821\u8831\u8836\u8839\u8827\u883B\u8844\u8842\u8852\u8859\u885E\u8862\u886B\u8881\u887E\u889E\u8875\u887D\u88B5\u8872\u8882\u8897\u8892\u88AE\u8899\u88A2\u888D\u88A4\u88B0\u88BF\u88B1\u88C3\u88C4\u88D4\u88D8\u88D9\u88DD\u88F9\u8902\u88FC\u88F4\u88E8\u88F2\u8904\u890C\u890A\u8913\u8943\u891E\u8925\u892A\u892B\u8941\u8944\u893B\u8936\u8938\u894C\u891D\u8960\u895E"],
      ["eba1", "\u8966\u8964\u896D\u896A\u896F\u8974\u8977\u897E\u8983\u8988\u898A\u8993\u8998\u89A1\u89A9\u89A6\u89AC\u89AF\u89B2\u89BA\u89BD\u89BF\u89C0\u89DA\u89DC\u89DD\u89E7\u89F4\u89F8\u8A03\u8A16\u8A10\u8A0C\u8A1B\u8A1D\u8A25\u8A36\u8A41\u8A5B\u8A52\u8A46\u8A48\u8A7C\u8A6D\u8A6C\u8A62\u8A85\u8A82\u8A84\u8AA8\u8AA1\u8A91\u8AA5\u8AA6\u8A9A\u8AA3\u8AC4\u8ACD\u8AC2\u8ADA\u8AEB\u8AF3\u8AE7\u8AE4\u8AF1\u8B14\u8AE0\u8AE2\u8AF7\u8ADE\u8ADB\u8B0C\u8B07\u8B1A\u8AE1\u8B16\u8B10\u8B17\u8B20\u8B33\u97AB\u8B26\u8B2B\u8B3E\u8B28\u8B41\u8B4C\u8B4F\u8B4E\u8B49\u8B56\u8B5B\u8B5A\u8B6B"],
      ["eca1", "\u8B5F\u8B6C\u8B6F\u8B74\u8B7D\u8B80\u8B8C\u8B8E\u8B92\u8B93\u8B96\u8B99\u8B9A\u8C3A\u8C41\u8C3F\u8C48\u8C4C\u8C4E\u8C50\u8C55\u8C62\u8C6C\u8C78\u8C7A\u8C82\u8C89\u8C85\u8C8A\u8C8D\u8C8E\u8C94\u8C7C\u8C98\u621D\u8CAD\u8CAA\u8CBD\u8CB2\u8CB3\u8CAE\u8CB6\u8CC8\u8CC1\u8CE4\u8CE3\u8CDA\u8CFD\u8CFA\u8CFB\u8D04\u8D05\u8D0A\u8D07\u8D0F\u8D0D\u8D10\u9F4E\u8D13\u8CCD\u8D14\u8D16\u8D67\u8D6D\u8D71\u8D73\u8D81\u8D99\u8DC2\u8DBE\u8DBA\u8DCF\u8DDA\u8DD6\u8DCC\u8DDB\u8DCB\u8DEA\u8DEB\u8DDF\u8DE3\u8DFC\u8E08\u8E09\u8DFF\u8E1D\u8E1E\u8E10\u8E1F\u8E42\u8E35\u8E30\u8E34\u8E4A"],
      ["eda1", "\u8E47\u8E49\u8E4C\u8E50\u8E48\u8E59\u8E64\u8E60\u8E2A\u8E63\u8E55\u8E76\u8E72\u8E7C\u8E81\u8E87\u8E85\u8E84\u8E8B\u8E8A\u8E93\u8E91\u8E94\u8E99\u8EAA\u8EA1\u8EAC\u8EB0\u8EC6\u8EB1\u8EBE\u8EC5\u8EC8\u8ECB\u8EDB\u8EE3\u8EFC\u8EFB\u8EEB\u8EFE\u8F0A\u8F05\u8F15\u8F12\u8F19\u8F13\u8F1C\u8F1F\u8F1B\u8F0C\u8F26\u8F33\u8F3B\u8F39\u8F45\u8F42\u8F3E\u8F4C\u8F49\u8F46\u8F4E\u8F57\u8F5C\u8F62\u8F63\u8F64\u8F9C\u8F9F\u8FA3\u8FAD\u8FAF\u8FB7\u8FDA\u8FE5\u8FE2\u8FEA\u8FEF\u9087\u8FF4\u9005\u8FF9\u8FFA\u9011\u9015\u9021\u900D\u901E\u9016\u900B\u9027\u9036\u9035\u9039\u8FF8"],
      ["eea1", "\u904F\u9050\u9051\u9052\u900E\u9049\u903E\u9056\u9058\u905E\u9068\u906F\u9076\u96A8\u9072\u9082\u907D\u9081\u9080\u908A\u9089\u908F\u90A8\u90AF\u90B1\u90B5\u90E2\u90E4\u6248\u90DB\u9102\u9112\u9119\u9132\u9130\u914A\u9156\u9158\u9163\u9165\u9169\u9173\u9172\u918B\u9189\u9182\u91A2\u91AB\u91AF\u91AA\u91B5\u91B4\u91BA\u91C0\u91C1\u91C9\u91CB\u91D0\u91D6\u91DF\u91E1\u91DB\u91FC\u91F5\u91F6\u921E\u91FF\u9214\u922C\u9215\u9211\u925E\u9257\u9245\u9249\u9264\u9248\u9295\u923F\u924B\u9250\u929C\u9296\u9293\u929B\u925A\u92CF\u92B9\u92B7\u92E9\u930F\u92FA\u9344\u932E"],
      ["efa1", "\u9319\u9322\u931A\u9323\u933A\u9335\u933B\u935C\u9360\u937C\u936E\u9356\u93B0\u93AC\u93AD\u9394\u93B9\u93D6\u93D7\u93E8\u93E5\u93D8\u93C3\u93DD\u93D0\u93C8\u93E4\u941A\u9414\u9413\u9403\u9407\u9410\u9436\u942B\u9435\u9421\u943A\u9441\u9452\u9444\u945B\u9460\u9462\u945E\u946A\u9229\u9470\u9475\u9477\u947D\u945A\u947C\u947E\u9481\u947F\u9582\u9587\u958A\u9594\u9596\u9598\u9599\u95A0\u95A8\u95A7\u95AD\u95BC\u95BB\u95B9\u95BE\u95CA\u6FF6\u95C3\u95CD\u95CC\u95D5\u95D4\u95D6\u95DC\u95E1\u95E5\u95E2\u9621\u9628\u962E\u962F\u9642\u964C\u964F\u964B\u9677\u965C\u965E"],
      ["f0a1", "\u965D\u965F\u9666\u9672\u966C\u968D\u9698\u9695\u9697\u96AA\u96A7\u96B1\u96B2\u96B0\u96B4\u96B6\u96B8\u96B9\u96CE\u96CB\u96C9\u96CD\u894D\u96DC\u970D\u96D5\u96F9\u9704\u9706\u9708\u9713\u970E\u9711\u970F\u9716\u9719\u9724\u972A\u9730\u9739\u973D\u973E\u9744\u9746\u9748\u9742\u9749\u975C\u9760\u9764\u9766\u9768\u52D2\u976B\u9771\u9779\u9785\u977C\u9781\u977A\u9786\u978B\u978F\u9790\u979C\u97A8\u97A6\u97A3\u97B3\u97B4\u97C3\u97C6\u97C8\u97CB\u97DC\u97ED\u9F4F\u97F2\u7ADF\u97F6\u97F5\u980F\u980C\u9838\u9824\u9821\u9837\u983D\u9846\u984F\u984B\u986B\u986F\u9870"],
      ["f1a1", "\u9871\u9874\u9873\u98AA\u98AF\u98B1\u98B6\u98C4\u98C3\u98C6\u98E9\u98EB\u9903\u9909\u9912\u9914\u9918\u9921\u991D\u991E\u9924\u9920\u992C\u992E\u993D\u993E\u9942\u9949\u9945\u9950\u994B\u9951\u9952\u994C\u9955\u9997\u9998\u99A5\u99AD\u99AE\u99BC\u99DF\u99DB\u99DD\u99D8\u99D1\u99ED\u99EE\u99F1\u99F2\u99FB\u99F8\u9A01\u9A0F\u9A05\u99E2\u9A19\u9A2B\u9A37\u9A45\u9A42\u9A40\u9A43\u9A3E\u9A55\u9A4D\u9A5B\u9A57\u9A5F\u9A62\u9A65\u9A64\u9A69\u9A6B\u9A6A\u9AAD\u9AB0\u9ABC\u9AC0\u9ACF\u9AD1\u9AD3\u9AD4\u9ADE\u9ADF\u9AE2\u9AE3\u9AE6\u9AEF\u9AEB\u9AEE\u9AF4\u9AF1\u9AF7"],
      ["f2a1", "\u9AFB\u9B06\u9B18\u9B1A\u9B1F\u9B22\u9B23\u9B25\u9B27\u9B28\u9B29\u9B2A\u9B2E\u9B2F\u9B32\u9B44\u9B43\u9B4F\u9B4D\u9B4E\u9B51\u9B58\u9B74\u9B93\u9B83\u9B91\u9B96\u9B97\u9B9F\u9BA0\u9BA8\u9BB4\u9BC0\u9BCA\u9BB9\u9BC6\u9BCF\u9BD1\u9BD2\u9BE3\u9BE2\u9BE4\u9BD4\u9BE1\u9C3A\u9BF2\u9BF1\u9BF0\u9C15\u9C14\u9C09\u9C13\u9C0C\u9C06\u9C08\u9C12\u9C0A\u9C04\u9C2E\u9C1B\u9C25\u9C24\u9C21\u9C30\u9C47\u9C32\u9C46\u9C3E\u9C5A\u9C60\u9C67\u9C76\u9C78\u9CE7\u9CEC\u9CF0\u9D09\u9D08\u9CEB\u9D03\u9D06\u9D2A\u9D26\u9DAF\u9D23\u9D1F\u9D44\u9D15\u9D12\u9D41\u9D3F\u9D3E\u9D46\u9D48"],
      ["f3a1", "\u9D5D\u9D5E\u9D64\u9D51\u9D50\u9D59\u9D72\u9D89\u9D87\u9DAB\u9D6F\u9D7A\u9D9A\u9DA4\u9DA9\u9DB2\u9DC4\u9DC1\u9DBB\u9DB8\u9DBA\u9DC6\u9DCF\u9DC2\u9DD9\u9DD3\u9DF8\u9DE6\u9DED\u9DEF\u9DFD\u9E1A\u9E1B\u9E1E\u9E75\u9E79\u9E7D\u9E81\u9E88\u9E8B\u9E8C\u9E92\u9E95\u9E91\u9E9D\u9EA5\u9EA9\u9EB8\u9EAA\u9EAD\u9761\u9ECC\u9ECE\u9ECF\u9ED0\u9ED4\u9EDC\u9EDE\u9EDD\u9EE0\u9EE5\u9EE8\u9EEF\u9EF4\u9EF6\u9EF7\u9EF9\u9EFB\u9EFC\u9EFD\u9F07\u9F08\u76B7\u9F15\u9F21\u9F2C\u9F3E\u9F4A\u9F52\u9F54\u9F63\u9F5F\u9F60\u9F61\u9F66\u9F67\u9F6C\u9F6A\u9F77\u9F72\u9F76\u9F95\u9F9C\u9FA0"],
      ["f4a1", "\u582F\u69C7\u9059\u7464\u51DC\u7199"],
      ["f9a1", "\u7E8A\u891C\u9348\u9288\u84DC\u4FC9\u70BB\u6631\u68C8\u92F9\u66FB\u5F45\u4E28\u4EE1\u4EFC\u4F00\u4F03\u4F39\u4F56\u4F92\u4F8A\u4F9A\u4F94\u4FCD\u5040\u5022\u4FFF\u501E\u5046\u5070\u5042\u5094\u50F4\u50D8\u514A\u5164\u519D\u51BE\u51EC\u5215\u529C\u52A6\u52C0\u52DB\u5300\u5307\u5324\u5372\u5393\u53B2\u53DD\uFA0E\u549C\u548A\u54A9\u54FF\u5586\u5759\u5765\u57AC\u57C8\u57C7\uFA0F\uFA10\u589E\u58B2\u590B\u5953\u595B\u595D\u5963\u59A4\u59BA\u5B56\u5BC0\u752F\u5BD8\u5BEC\u5C1E\u5CA6\u5CBA\u5CF5\u5D27\u5D53\uFA11\u5D42\u5D6D\u5DB8\u5DB9\u5DD0\u5F21\u5F34\u5F67\u5FB7"],
      ["faa1", "\u5FDE\u605D\u6085\u608A\u60DE\u60D5\u6120\u60F2\u6111\u6137\u6130\u6198\u6213\u62A6\u63F5\u6460\u649D\u64CE\u654E\u6600\u6615\u663B\u6609\u662E\u661E\u6624\u6665\u6657\u6659\uFA12\u6673\u6699\u66A0\u66B2\u66BF\u66FA\u670E\uF929\u6766\u67BB\u6852\u67C0\u6801\u6844\u68CF\uFA13\u6968\uFA14\u6998\u69E2\u6A30\u6A6B\u6A46\u6A73\u6A7E\u6AE2\u6AE4\u6BD6\u6C3F\u6C5C\u6C86\u6C6F\u6CDA\u6D04\u6D87\u6D6F\u6D96\u6DAC\u6DCF\u6DF8\u6DF2\u6DFC\u6E39\u6E5C\u6E27\u6E3C\u6EBF\u6F88\u6FB5\u6FF5\u7005\u7007\u7028\u7085\u70AB\u710F\u7104\u715C\u7146\u7147\uFA15\u71C1\u71FE\u72B1"],
      ["fba1", "\u72BE\u7324\uFA16\u7377\u73BD\u73C9\u73D6\u73E3\u73D2\u7407\u73F5\u7426\u742A\u7429\u742E\u7462\u7489\u749F\u7501\u756F\u7682\u769C\u769E\u769B\u76A6\uFA17\u7746\u52AF\u7821\u784E\u7864\u787A\u7930\uFA18\uFA19\uFA1A\u7994\uFA1B\u799B\u7AD1\u7AE7\uFA1C\u7AEB\u7B9E\uFA1D\u7D48\u7D5C\u7DB7\u7DA0\u7DD6\u7E52\u7F47\u7FA1\uFA1E\u8301\u8362\u837F\u83C7\u83F6\u8448\u84B4\u8553\u8559\u856B\uFA1F\u85B0\uFA20\uFA21\u8807\u88F5\u8A12\u8A37\u8A79\u8AA7\u8ABE\u8ADF\uFA22\u8AF6\u8B53\u8B7F\u8CF0\u8CF4\u8D12\u8D76\uFA23\u8ECF\uFA24\uFA25\u9067\u90DE\uFA26\u9115\u9127\u91DA"],
      ["fca1", "\u91D7\u91DE\u91ED\u91EE\u91E4\u91E5\u9206\u9210\u920A\u923A\u9240\u923C\u924E\u9259\u9251\u9239\u9267\u92A7\u9277\u9278\u92E7\u92D7\u92D9\u92D0\uFA27\u92D5\u92E0\u92D3\u9325\u9321\u92FB\uFA28\u931E\u92FF\u931D\u9302\u9370\u9357\u93A4\u93C6\u93DE\u93F8\u9431\u9445\u9448\u9592\uF9DC\uFA29\u969D\u96AF\u9733\u973B\u9743\u974D\u974F\u9751\u9755\u9857\u9865\uFA2A\uFA2B\u9927\uFA2C\u999E\u9A4E\u9AD9\u9ADC\u9B75\u9B72\u9B8F\u9BB1\u9BBB\u9C00\u9D70\u9D6B\uFA2D\u9E19\u9ED1"],
      ["fcf1", "\u2170", 9, "\uFFE2\uFFE4\uFF07\uFF02"],
      ["8fa2af", "\u02D8\u02C7\xB8\u02D9\u02DD\xAF\u02DB\u02DA\uFF5E\u0384\u0385"],
      ["8fa2c2", "\xA1\xA6\xBF"],
      ["8fa2eb", "\xBA\xAA\xA9\xAE\u2122\xA4\u2116"],
      ["8fa6e1", "\u0386\u0388\u0389\u038A\u03AA"],
      ["8fa6e7", "\u038C"],
      ["8fa6e9", "\u038E\u03AB"],
      ["8fa6ec", "\u038F"],
      ["8fa6f1", "\u03AC\u03AD\u03AE\u03AF\u03CA\u0390\u03CC\u03C2\u03CD\u03CB\u03B0\u03CE"],
      ["8fa7c2", "\u0402", 10, "\u040E\u040F"],
      ["8fa7f2", "\u0452", 10, "\u045E\u045F"],
      ["8fa9a1", "\xC6\u0110"],
      ["8fa9a4", "\u0126"],
      ["8fa9a6", "\u0132"],
      ["8fa9a8", "\u0141\u013F"],
      ["8fa9ab", "\u014A\xD8\u0152"],
      ["8fa9af", "\u0166\xDE"],
      ["8fa9c1", "\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0142\u0140\u0149\u014B\xF8\u0153\xDF\u0167\xFE"],
      ["8faaa1", "\xC1\xC0\xC4\xC2\u0102\u01CD\u0100\u0104\xC5\xC3\u0106\u0108\u010C\xC7\u010A\u010E\xC9\xC8\xCB\xCA\u011A\u0116\u0112\u0118"],
      ["8faaba", "\u011C\u011E\u0122\u0120\u0124\xCD\xCC\xCF\xCE\u01CF\u0130\u012A\u012E\u0128\u0134\u0136\u0139\u013D\u013B\u0143\u0147\u0145\xD1\xD3\xD2\xD6\xD4\u01D1\u0150\u014C\xD5\u0154\u0158\u0156\u015A\u015C\u0160\u015E\u0164\u0162\xDA\xD9\xDC\xDB\u016C\u01D3\u0170\u016A\u0172\u016E\u0168\u01D7\u01DB\u01D9\u01D5\u0174\xDD\u0178\u0176\u0179\u017D\u017B"],
      ["8faba1", "\xE1\xE0\xE4\xE2\u0103\u01CE\u0101\u0105\xE5\xE3\u0107\u0109\u010D\xE7\u010B\u010F\xE9\xE8\xEB\xEA\u011B\u0117\u0113\u0119\u01F5\u011D\u011F"],
      ["8fabbd", "\u0121\u0125\xED\xEC\xEF\xEE\u01D0"],
      ["8fabc5", "\u012B\u012F\u0129\u0135\u0137\u013A\u013E\u013C\u0144\u0148\u0146\xF1\xF3\xF2\xF6\xF4\u01D2\u0151\u014D\xF5\u0155\u0159\u0157\u015B\u015D\u0161\u015F\u0165\u0163\xFA\xF9\xFC\xFB\u016D\u01D4\u0171\u016B\u0173\u016F\u0169\u01D8\u01DC\u01DA\u01D6\u0175\xFD\xFF\u0177\u017A\u017E\u017C"],
      ["8fb0a1", "\u4E02\u4E04\u4E05\u4E0C\u4E12\u4E1F\u4E23\u4E24\u4E28\u4E2B\u4E2E\u4E2F\u4E30\u4E35\u4E40\u4E41\u4E44\u4E47\u4E51\u4E5A\u4E5C\u4E63\u4E68\u4E69\u4E74\u4E75\u4E79\u4E7F\u4E8D\u4E96\u4E97\u4E9D\u4EAF\u4EB9\u4EC3\u4ED0\u4EDA\u4EDB\u4EE0\u4EE1\u4EE2\u4EE8\u4EEF\u4EF1\u4EF3\u4EF5\u4EFD\u4EFE\u4EFF\u4F00\u4F02\u4F03\u4F08\u4F0B\u4F0C\u4F12\u4F15\u4F16\u4F17\u4F19\u4F2E\u4F31\u4F60\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E\u4F40\u4F42\u4F48\u4F49\u4F4B\u4F4C\u4F52\u4F54\u4F56\u4F58\u4F5F\u4F63\u4F6A\u4F6C\u4F6E\u4F71\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F7E\u4F81\u4F82\u4F84"],
      ["8fb1a1", "\u4F85\u4F89\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F94\u4F97\u4F99\u4F9A\u4F9E\u4F9F\u4FB2\u4FB7\u4FB9\u4FBB\u4FBC\u4FBD\u4FBE\u4FC0\u4FC1\u4FC5\u4FC6\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FCF\u4FD2\u4FDC\u4FE0\u4FE2\u4FF0\u4FF2\u4FFC\u4FFD\u4FFF\u5000\u5001\u5004\u5007\u500A\u500C\u500E\u5010\u5013\u5017\u5018\u501B\u501C\u501D\u501E\u5022\u5027\u502E\u5030\u5032\u5033\u5035\u5040\u5041\u5042\u5045\u5046\u504A\u504C\u504E\u5051\u5052\u5053\u5057\u5059\u505F\u5060\u5062\u5063\u5066\u5067\u506A\u506D\u5070\u5071\u503B\u5081\u5083\u5084\u5086\u508A\u508E\u508F\u5090"],
      ["8fb2a1", "\u5092\u5093\u5094\u5096\u509B\u509C\u509E", 4, "\u50AA\u50AF\u50B0\u50B9\u50BA\u50BD\u50C0\u50C3\u50C4\u50C7\u50CC\u50CE\u50D0\u50D3\u50D4\u50D8\u50DC\u50DD\u50DF\u50E2\u50E4\u50E6\u50E8\u50E9\u50EF\u50F1\u50F6\u50FA\u50FE\u5103\u5106\u5107\u5108\u510B\u510C\u510D\u510E\u50F2\u5110\u5117\u5119\u511B\u511C\u511D\u511E\u5123\u5127\u5128\u512C\u512D\u512F\u5131\u5133\u5134\u5135\u5138\u5139\u5142\u514A\u514F\u5153\u5155\u5157\u5158\u515F\u5164\u5166\u517E\u5183\u5184\u518B\u518E\u5198\u519D\u51A1\u51A3\u51AD\u51B8\u51BA\u51BC\u51BE\u51BF\u51C2"],
      ["8fb3a1", "\u51C8\u51CF\u51D1\u51D2\u51D3\u51D5\u51D8\u51DE\u51E2\u51E5\u51EE\u51F2\u51F3\u51F4\u51F7\u5201\u5202\u5205\u5212\u5213\u5215\u5216\u5218\u5222\u5228\u5231\u5232\u5235\u523C\u5245\u5249\u5255\u5257\u5258\u525A\u525C\u525F\u5260\u5261\u5266\u526E\u5277\u5278\u5279\u5280\u5282\u5285\u528A\u528C\u5293\u5295\u5296\u5297\u5298\u529A\u529C\u52A4\u52A5\u52A6\u52A7\u52AF\u52B0\u52B6\u52B7\u52B8\u52BA\u52BB\u52BD\u52C0\u52C4\u52C6\u52C8\u52CC\u52CF\u52D1\u52D4\u52D6\u52DB\u52DC\u52E1\u52E5\u52E8\u52E9\u52EA\u52EC\u52F0\u52F1\u52F4\u52F6\u52F7\u5300\u5303\u530A\u530B"],
      ["8fb4a1", "\u530C\u5311\u5313\u5318\u531B\u531C\u531E\u531F\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u5330\u5332\u5335\u533C\u533D\u533E\u5342\u534C\u534B\u5359\u535B\u5361\u5363\u5365\u536C\u536D\u5372\u5379\u537E\u5383\u5387\u5388\u538E\u5393\u5394\u5399\u539D\u53A1\u53A4\u53AA\u53AB\u53AF\u53B2\u53B4\u53B5\u53B7\u53B8\u53BA\u53BD\u53C0\u53C5\u53CF\u53D2\u53D3\u53D5\u53DA\u53DD\u53DE\u53E0\u53E6\u53E7\u53F5\u5402\u5413\u541A\u5421\u5427\u5428\u542A\u542F\u5431\u5434\u5435\u5443\u5444\u5447\u544D\u544F\u545E\u5462\u5464\u5466\u5467\u5469\u546B\u546D\u546E\u5474\u547F"],
      ["8fb5a1", "\u5481\u5483\u5485\u5488\u5489\u548D\u5491\u5495\u5496\u549C\u549F\u54A1\u54A6\u54A7\u54A9\u54AA\u54AD\u54AE\u54B1\u54B7\u54B9\u54BA\u54BB\u54BF\u54C6\u54CA\u54CD\u54CE\u54E0\u54EA\u54EC\u54EF\u54F6\u54FC\u54FE\u54FF\u5500\u5501\u5505\u5508\u5509\u550C\u550D\u550E\u5515\u552A\u552B\u5532\u5535\u5536\u553B\u553C\u553D\u5541\u5547\u5549\u554A\u554D\u5550\u5551\u5558\u555A\u555B\u555E\u5560\u5561\u5564\u5566\u557F\u5581\u5582\u5586\u5588\u558E\u558F\u5591\u5592\u5593\u5594\u5597\u55A3\u55A4\u55AD\u55B2\u55BF\u55C1\u55C3\u55C6\u55C9\u55CB\u55CC\u55CE\u55D1\u55D2"],
      ["8fb6a1", "\u55D3\u55D7\u55D8\u55DB\u55DE\u55E2\u55E9\u55F6\u55FF\u5605\u5608\u560A\u560D", 5, "\u5619\u562C\u5630\u5633\u5635\u5637\u5639\u563B\u563C\u563D\u563F\u5640\u5641\u5643\u5644\u5646\u5649\u564B\u564D\u564F\u5654\u565E\u5660\u5661\u5662\u5663\u5666\u5669\u566D\u566F\u5671\u5672\u5675\u5684\u5685\u5688\u568B\u568C\u5695\u5699\u569A\u569D\u569E\u569F\u56A6\u56A7\u56A8\u56A9\u56AB\u56AC\u56AD\u56B1\u56B3\u56B7\u56BE\u56C5\u56C9\u56CA\u56CB\u56CF\u56D0\u56CC\u56CD\u56D9\u56DC\u56DD\u56DF\u56E1\u56E4", 4, "\u56F1\u56EB\u56ED"],
      ["8fb7a1", "\u56F6\u56F7\u5701\u5702\u5707\u570A\u570C\u5711\u5715\u571A\u571B\u571D\u5720\u5722\u5723\u5724\u5725\u5729\u572A\u572C\u572E\u572F\u5733\u5734\u573D\u573E\u573F\u5745\u5746\u574C\u574D\u5752\u5762\u5765\u5767\u5768\u576B\u576D", 4, "\u5773\u5774\u5775\u5777\u5779\u577A\u577B\u577C\u577E\u5781\u5783\u578C\u5794\u5797\u5799\u579A\u579C\u579D\u579E\u579F\u57A1\u5795\u57A7\u57A8\u57A9\u57AC\u57B8\u57BD\u57C7\u57C8\u57CC\u57CF\u57D5\u57DD\u57DE\u57E4\u57E6\u57E7\u57E9\u57ED\u57F0\u57F5\u57F6\u57F8\u57FD\u57FE\u57FF\u5803\u5804\u5808\u5809\u57E1"],
      ["8fb8a1", "\u580C\u580D\u581B\u581E\u581F\u5820\u5826\u5827\u582D\u5832\u5839\u583F\u5849\u584C\u584D\u584F\u5850\u5855\u585F\u5861\u5864\u5867\u5868\u5878\u587C\u587F\u5880\u5881\u5887\u5888\u5889\u588A\u588C\u588D\u588F\u5890\u5894\u5896\u589D\u58A0\u58A1\u58A2\u58A6\u58A9\u58B1\u58B2\u58C4\u58BC\u58C2\u58C8\u58CD\u58CE\u58D0\u58D2\u58D4\u58D6\u58DA\u58DD\u58E1\u58E2\u58E9\u58F3\u5905\u5906\u590B\u590C\u5912\u5913\u5914\u8641\u591D\u5921\u5923\u5924\u5928\u592F\u5930\u5933\u5935\u5936\u593F\u5943\u5946\u5952\u5953\u5959\u595B\u595D\u595E\u595F\u5961\u5963\u596B\u596D"],
      ["8fb9a1", "\u596F\u5972\u5975\u5976\u5979\u597B\u597C\u598B\u598C\u598E\u5992\u5995\u5997\u599F\u59A4\u59A7\u59AD\u59AE\u59AF\u59B0\u59B3\u59B7\u59BA\u59BC\u59C1\u59C3\u59C4\u59C8\u59CA\u59CD\u59D2\u59DD\u59DE\u59DF\u59E3\u59E4\u59E7\u59EE\u59EF\u59F1\u59F2\u59F4\u59F7\u5A00\u5A04\u5A0C\u5A0D\u5A0E\u5A12\u5A13\u5A1E\u5A23\u5A24\u5A27\u5A28\u5A2A\u5A2D\u5A30\u5A44\u5A45\u5A47\u5A48\u5A4C\u5A50\u5A55\u5A5E\u5A63\u5A65\u5A67\u5A6D\u5A77\u5A7A\u5A7B\u5A7E\u5A8B\u5A90\u5A93\u5A96\u5A99\u5A9C\u5A9E\u5A9F\u5AA0\u5AA2\u5AA7\u5AAC\u5AB1\u5AB2\u5AB3\u5AB5\u5AB8\u5ABA\u5ABB\u5ABF"],
      ["8fbaa1", "\u5AC4\u5AC6\u5AC8\u5ACF\u5ADA\u5ADC\u5AE0\u5AE5\u5AEA\u5AEE\u5AF5\u5AF6\u5AFD\u5B00\u5B01\u5B08\u5B17\u5B34\u5B19\u5B1B\u5B1D\u5B21\u5B25\u5B2D\u5B38\u5B41\u5B4B\u5B4C\u5B52\u5B56\u5B5E\u5B68\u5B6E\u5B6F\u5B7C\u5B7D\u5B7E\u5B7F\u5B81\u5B84\u5B86\u5B8A\u5B8E\u5B90\u5B91\u5B93\u5B94\u5B96\u5BA8\u5BA9\u5BAC\u5BAD\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBC\u5BC0\u5BC1\u5BCD\u5BCF\u5BD6", 4, "\u5BE0\u5BEF\u5BF1\u5BF4\u5BFD\u5C0C\u5C17\u5C1E\u5C1F\u5C23\u5C26\u5C29\u5C2B\u5C2C\u5C2E\u5C30\u5C32\u5C35\u5C36\u5C59\u5C5A\u5C5C\u5C62\u5C63\u5C67\u5C68\u5C69"],
      ["8fbba1", "\u5C6D\u5C70\u5C74\u5C75\u5C7A\u5C7B\u5C7C\u5C7D\u5C87\u5C88\u5C8A\u5C8F\u5C92\u5C9D\u5C9F\u5CA0\u5CA2\u5CA3\u5CA6\u5CAA\u5CB2\u5CB4\u5CB5\u5CBA\u5CC9\u5CCB\u5CD2\u5CDD\u5CD7\u5CEE\u5CF1\u5CF2\u5CF4\u5D01\u5D06\u5D0D\u5D12\u5D2B\u5D23\u5D24\u5D26\u5D27\u5D31\u5D34\u5D39\u5D3D\u5D3F\u5D42\u5D43\u5D46\u5D48\u5D55\u5D51\u5D59\u5D4A\u5D5F\u5D60\u5D61\u5D62\u5D64\u5D6A\u5D6D\u5D70\u5D79\u5D7A\u5D7E\u5D7F\u5D81\u5D83\u5D88\u5D8A\u5D92\u5D93\u5D94\u5D95\u5D99\u5D9B\u5D9F\u5DA0\u5DA7\u5DAB\u5DB0\u5DB4\u5DB8\u5DB9\u5DC3\u5DC7\u5DCB\u5DD0\u5DCE\u5DD8\u5DD9\u5DE0\u5DE4"],
      ["8fbca1", "\u5DE9\u5DF8\u5DF9\u5E00\u5E07\u5E0D\u5E12\u5E14\u5E15\u5E18\u5E1F\u5E20\u5E2E\u5E28\u5E32\u5E35\u5E3E\u5E4B\u5E50\u5E49\u5E51\u5E56\u5E58\u5E5B\u5E5C\u5E5E\u5E68\u5E6A", 4, "\u5E70\u5E80\u5E8B\u5E8E\u5EA2\u5EA4\u5EA5\u5EA8\u5EAA\u5EAC\u5EB1\u5EB3\u5EBD\u5EBE\u5EBF\u5EC6\u5ECC\u5ECB\u5ECE\u5ED1\u5ED2\u5ED4\u5ED5\u5EDC\u5EDE\u5EE5\u5EEB\u5F02\u5F06\u5F07\u5F08\u5F0E\u5F19\u5F1C\u5F1D\u5F21\u5F22\u5F23\u5F24\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F34\u5F36\u5F3B\u5F3D\u5F3F\u5F40\u5F44\u5F45\u5F47\u5F4D\u5F50\u5F54\u5F58\u5F5B\u5F60\u5F63\u5F64\u5F67"],
      ["8fbda1", "\u5F6F\u5F72\u5F74\u5F75\u5F78\u5F7A\u5F7D\u5F7E\u5F89\u5F8D\u5F8F\u5F96\u5F9C\u5F9D\u5FA2\u5FA7\u5FAB\u5FA4\u5FAC\u5FAF\u5FB0\u5FB1\u5FB8\u5FC4\u5FC7\u5FC8\u5FC9\u5FCB\u5FD0", 4, "\u5FDE\u5FE1\u5FE2\u5FE8\u5FE9\u5FEA\u5FEC\u5FED\u5FEE\u5FEF\u5FF2\u5FF3\u5FF6\u5FFA\u5FFC\u6007\u600A\u600D\u6013\u6014\u6017\u6018\u601A\u601F\u6024\u602D\u6033\u6035\u6040\u6047\u6048\u6049\u604C\u6051\u6054\u6056\u6057\u605D\u6061\u6067\u6071\u607E\u607F\u6082\u6086\u6088\u608A\u608E\u6091\u6093\u6095\u6098\u609D\u609E\u60A2\u60A4\u60A5\u60A8\u60B0\u60B1\u60B7"],
      ["8fbea1", "\u60BB\u60BE\u60C2\u60C4\u60C8\u60C9\u60CA\u60CB\u60CE\u60CF\u60D4\u60D5\u60D9\u60DB\u60DD\u60DE\u60E2\u60E5\u60F2\u60F5\u60F8\u60FC\u60FD\u6102\u6107\u610A\u610C\u6110", 4, "\u6116\u6117\u6119\u611C\u611E\u6122\u612A\u612B\u6130\u6131\u6135\u6136\u6137\u6139\u6141\u6145\u6146\u6149\u615E\u6160\u616C\u6172\u6178\u617B\u617C\u617F\u6180\u6181\u6183\u6184\u618B\u618D\u6192\u6193\u6197\u6198\u619C\u619D\u619F\u61A0\u61A5\u61A8\u61AA\u61AD\u61B8\u61B9\u61BC\u61C0\u61C1\u61C2\u61CE\u61CF\u61D5\u61DC\u61DD\u61DE\u61DF\u61E1\u61E2\u61E7\u61E9\u61E5"],
      ["8fbfa1", "\u61EC\u61ED\u61EF\u6201\u6203\u6204\u6207\u6213\u6215\u621C\u6220\u6222\u6223\u6227\u6229\u622B\u6239\u623D\u6242\u6243\u6244\u6246\u624C\u6250\u6251\u6252\u6254\u6256\u625A\u625C\u6264\u626D\u626F\u6273\u627A\u627D\u628D\u628E\u628F\u6290\u62A6\u62A8\u62B3\u62B6\u62B7\u62BA\u62BE\u62BF\u62C4\u62CE\u62D5\u62D6\u62DA\u62EA\u62F2\u62F4\u62FC\u62FD\u6303\u6304\u630A\u630B\u630D\u6310\u6313\u6316\u6318\u6329\u632A\u632D\u6335\u6336\u6339\u633C\u6341\u6342\u6343\u6344\u6346\u634A\u634B\u634E\u6352\u6353\u6354\u6358\u635B\u6365\u6366\u636C\u636D\u6371\u6374\u6375"],
      ["8fc0a1", "\u6378\u637C\u637D\u637F\u6382\u6384\u6387\u638A\u6390\u6394\u6395\u6399\u639A\u639E\u63A4\u63A6\u63AD\u63AE\u63AF\u63BD\u63C1\u63C5\u63C8\u63CE\u63D1\u63D3\u63D4\u63D5\u63DC\u63E0\u63E5\u63EA\u63EC\u63F2\u63F3\u63F5\u63F8\u63F9\u6409\u640A\u6410\u6412\u6414\u6418\u641E\u6420\u6422\u6424\u6425\u6429\u642A\u642F\u6430\u6435\u643D\u643F\u644B\u644F\u6451\u6452\u6453\u6454\u645A\u645B\u645C\u645D\u645F\u6460\u6461\u6463\u646D\u6473\u6474\u647B\u647D\u6485\u6487\u648F\u6490\u6491\u6498\u6499\u649B\u649D\u649F\u64A1\u64A3\u64A6\u64A8\u64AC\u64B3\u64BD\u64BE\u64BF"],
      ["8fc1a1", "\u64C4\u64C9\u64CA\u64CB\u64CC\u64CE\u64D0\u64D1\u64D5\u64D7\u64E4\u64E5\u64E9\u64EA\u64ED\u64F0\u64F5\u64F7\u64FB\u64FF\u6501\u6504\u6508\u6509\u650A\u650F\u6513\u6514\u6516\u6519\u651B\u651E\u651F\u6522\u6526\u6529\u652E\u6531\u653A\u653C\u653D\u6543\u6547\u6549\u6550\u6552\u6554\u655F\u6560\u6567\u656B\u657A\u657D\u6581\u6585\u658A\u6592\u6595\u6598\u659D\u65A0\u65A3\u65A6\u65AE\u65B2\u65B3\u65B4\u65BF\u65C2\u65C8\u65C9\u65CE\u65D0\u65D4\u65D6\u65D8\u65DF\u65F0\u65F2\u65F4\u65F5\u65F9\u65FE\u65FF\u6600\u6604\u6608\u6609\u660D\u6611\u6612\u6615\u6616\u661D"],
      ["8fc2a1", "\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6631\u6633\u6639\u6637\u6640\u6645\u6646\u664A\u664C\u6651\u664E\u6657\u6658\u6659\u665B\u665C\u6660\u6661\u66FB\u666A\u666B\u666C\u667E\u6673\u6675\u667F\u6677\u6678\u6679\u667B\u6680\u667C\u668B\u668C\u668D\u6690\u6692\u6699\u669A\u669B\u669C\u669F\u66A0\u66A4\u66AD\u66B1\u66B2\u66B5\u66BB\u66BF\u66C0\u66C2\u66C3\u66C8\u66CC\u66CE\u66CF\u66D4\u66DB\u66DF\u66E8\u66EB\u66EC\u66EE\u66FA\u6705\u6707\u670E\u6713\u6719\u671C\u6720\u6722\u6733\u673E\u6745\u6747\u6748\u674C\u6754\u6755\u675D"],
      ["8fc3a1", "\u6766\u676C\u676E\u6774\u6776\u677B\u6781\u6784\u678E\u678F\u6791\u6793\u6796\u6798\u6799\u679B\u67B0\u67B1\u67B2\u67B5\u67BB\u67BC\u67BD\u67F9\u67C0\u67C2\u67C3\u67C5\u67C8\u67C9\u67D2\u67D7\u67D9\u67DC\u67E1\u67E6\u67F0\u67F2\u67F6\u67F7\u6852\u6814\u6819\u681D\u681F\u6828\u6827\u682C\u682D\u682F\u6830\u6831\u6833\u683B\u683F\u6844\u6845\u684A\u684C\u6855\u6857\u6858\u685B\u686B\u686E", 4, "\u6875\u6879\u687A\u687B\u687C\u6882\u6884\u6886\u6888\u6896\u6898\u689A\u689C\u68A1\u68A3\u68A5\u68A9\u68AA\u68AE\u68B2\u68BB\u68C5\u68C8\u68CC\u68CF"],
      ["8fc4a1", "\u68D0\u68D1\u68D3\u68D6\u68D9\u68DC\u68DD\u68E5\u68E8\u68EA\u68EB\u68EC\u68ED\u68F0\u68F1\u68F5\u68F6\u68FB\u68FC\u68FD\u6906\u6909\u690A\u6910\u6911\u6913\u6916\u6917\u6931\u6933\u6935\u6938\u693B\u6942\u6945\u6949\u694E\u6957\u695B\u6963\u6964\u6965\u6966\u6968\u6969\u696C\u6970\u6971\u6972\u697A\u697B\u697F\u6980\u698D\u6992\u6996\u6998\u69A1\u69A5\u69A6\u69A8\u69AB\u69AD\u69AF\u69B7\u69B8\u69BA\u69BC\u69C5\u69C8\u69D1\u69D6\u69D7\u69E2\u69E5\u69EE\u69EF\u69F1\u69F3\u69F5\u69FE\u6A00\u6A01\u6A03\u6A0F\u6A11\u6A15\u6A1A\u6A1D\u6A20\u6A24\u6A28\u6A30\u6A32"],
      ["8fc5a1", "\u6A34\u6A37\u6A3B\u6A3E\u6A3F\u6A45\u6A46\u6A49\u6A4A\u6A4E\u6A50\u6A51\u6A52\u6A55\u6A56\u6A5B\u6A64\u6A67\u6A6A\u6A71\u6A73\u6A7E\u6A81\u6A83\u6A86\u6A87\u6A89\u6A8B\u6A91\u6A9B\u6A9D\u6A9E\u6A9F\u6AA5\u6AAB\u6AAF\u6AB0\u6AB1\u6AB4\u6ABD\u6ABE\u6ABF\u6AC6\u6AC9\u6AC8\u6ACC\u6AD0\u6AD4\u6AD5\u6AD6\u6ADC\u6ADD\u6AE4\u6AE7\u6AEC\u6AF0\u6AF1\u6AF2\u6AFC\u6AFD\u6B02\u6B03\u6B06\u6B07\u6B09\u6B0F\u6B10\u6B11\u6B17\u6B1B\u6B1E\u6B24\u6B28\u6B2B\u6B2C\u6B2F\u6B35\u6B36\u6B3B\u6B3F\u6B46\u6B4A\u6B4D\u6B52\u6B56\u6B58\u6B5D\u6B60\u6B67\u6B6B\u6B6E\u6B70\u6B75\u6B7D"],
      ["8fc6a1", "\u6B7E\u6B82\u6B85\u6B97\u6B9B\u6B9F\u6BA0\u6BA2\u6BA3\u6BA8\u6BA9\u6BAC\u6BAD\u6BAE\u6BB0\u6BB8\u6BB9\u6BBD\u6BBE\u6BC3\u6BC4\u6BC9\u6BCC\u6BD6\u6BDA\u6BE1\u6BE3\u6BE6\u6BE7\u6BEE\u6BF1\u6BF7\u6BF9\u6BFF\u6C02\u6C04\u6C05\u6C09\u6C0D\u6C0E\u6C10\u6C12\u6C19\u6C1F\u6C26\u6C27\u6C28\u6C2C\u6C2E\u6C33\u6C35\u6C36\u6C3A\u6C3B\u6C3F\u6C4A\u6C4B\u6C4D\u6C4F\u6C52\u6C54\u6C59\u6C5B\u6C5C\u6C6B\u6C6D\u6C6F\u6C74\u6C76\u6C78\u6C79\u6C7B\u6C85\u6C86\u6C87\u6C89\u6C94\u6C95\u6C97\u6C98\u6C9C\u6C9F\u6CB0\u6CB2\u6CB4\u6CC2\u6CC6\u6CCD\u6CCF\u6CD0\u6CD1\u6CD2\u6CD4\u6CD6"],
      ["8fc7a1", "\u6CDA\u6CDC\u6CE0\u6CE7\u6CE9\u6CEB\u6CEC\u6CEE\u6CF2\u6CF4\u6D04\u6D07\u6D0A\u6D0E\u6D0F\u6D11\u6D13\u6D1A\u6D26\u6D27\u6D28\u6C67\u6D2E\u6D2F\u6D31\u6D39\u6D3C\u6D3F\u6D57\u6D5E\u6D5F\u6D61\u6D65\u6D67\u6D6F\u6D70\u6D7C\u6D82\u6D87\u6D91\u6D92\u6D94\u6D96\u6D97\u6D98\u6DAA\u6DAC\u6DB4\u6DB7\u6DB9\u6DBD\u6DBF\u6DC4\u6DC8\u6DCA\u6DCE\u6DCF\u6DD6\u6DDB\u6DDD\u6DDF\u6DE0\u6DE2\u6DE5\u6DE9\u6DEF\u6DF0\u6DF4\u6DF6\u6DFC\u6E00\u6E04\u6E1E\u6E22\u6E27\u6E32\u6E36\u6E39\u6E3B\u6E3C\u6E44\u6E45\u6E48\u6E49\u6E4B\u6E4F\u6E51\u6E52\u6E53\u6E54\u6E57\u6E5C\u6E5D\u6E5E"],
      ["8fc8a1", "\u6E62\u6E63\u6E68\u6E73\u6E7B\u6E7D\u6E8D\u6E93\u6E99\u6EA0\u6EA7\u6EAD\u6EAE\u6EB1\u6EB3\u6EBB\u6EBF\u6EC0\u6EC1\u6EC3\u6EC7\u6EC8\u6ECA\u6ECD\u6ECE\u6ECF\u6EEB\u6EED\u6EEE\u6EF9\u6EFB\u6EFD\u6F04\u6F08\u6F0A\u6F0C\u6F0D\u6F16\u6F18\u6F1A\u6F1B\u6F26\u6F29\u6F2A\u6F2F\u6F30\u6F33\u6F36\u6F3B\u6F3C\u6F2D\u6F4F\u6F51\u6F52\u6F53\u6F57\u6F59\u6F5A\u6F5D\u6F5E\u6F61\u6F62\u6F68\u6F6C\u6F7D\u6F7E\u6F83\u6F87\u6F88\u6F8B\u6F8C\u6F8D\u6F90\u6F92\u6F93\u6F94\u6F96\u6F9A\u6F9F\u6FA0\u6FA5\u6FA6\u6FA7\u6FA8\u6FAE\u6FAF\u6FB0\u6FB5\u6FB6\u6FBC\u6FC5\u6FC7\u6FC8\u6FCA"],
      ["8fc9a1", "\u6FDA\u6FDE\u6FE8\u6FE9\u6FF0\u6FF5\u6FF9\u6FFC\u6FFD\u7000\u7005\u7006\u7007\u700D\u7017\u7020\u7023\u702F\u7034\u7037\u7039\u703C\u7043\u7044\u7048\u7049\u704A\u704B\u7054\u7055\u705D\u705E\u704E\u7064\u7065\u706C\u706E\u7075\u7076\u707E\u7081\u7085\u7086\u7094", 4, "\u709B\u70A4\u70AB\u70B0\u70B1\u70B4\u70B7\u70CA\u70D1\u70D3\u70D4\u70D5\u70D6\u70D8\u70DC\u70E4\u70FA\u7103", 4, "\u710B\u710C\u710F\u711E\u7120\u712B\u712D\u712F\u7130\u7131\u7138\u7141\u7145\u7146\u7147\u714A\u714B\u7150\u7152\u7157\u715A\u715C\u715E\u7160"],
      ["8fcaa1", "\u7168\u7179\u7180\u7185\u7187\u718C\u7192\u719A\u719B\u71A0\u71A2\u71AF\u71B0\u71B2\u71B3\u71BA\u71BF\u71C0\u71C1\u71C4\u71CB\u71CC\u71D3\u71D6\u71D9\u71DA\u71DC\u71F8\u71FE\u7200\u7207\u7208\u7209\u7213\u7217\u721A\u721D\u721F\u7224\u722B\u722F\u7234\u7238\u7239\u7241\u7242\u7243\u7245\u724E\u724F\u7250\u7253\u7255\u7256\u725A\u725C\u725E\u7260\u7263\u7268\u726B\u726E\u726F\u7271\u7277\u7278\u727B\u727C\u727F\u7284\u7289\u728D\u728E\u7293\u729B\u72A8\u72AD\u72AE\u72B1\u72B4\u72BE\u72C1\u72C7\u72C9\u72CC\u72D5\u72D6\u72D8\u72DF\u72E5\u72F3\u72F4\u72FA\u72FB"],
      ["8fcba1", "\u72FE\u7302\u7304\u7305\u7307\u730B\u730D\u7312\u7313\u7318\u7319\u731E\u7322\u7324\u7327\u7328\u732C\u7331\u7332\u7335\u733A\u733B\u733D\u7343\u734D\u7350\u7352\u7356\u7358\u735D\u735E\u735F\u7360\u7366\u7367\u7369\u736B\u736C\u736E\u736F\u7371\u7377\u7379\u737C\u7380\u7381\u7383\u7385\u7386\u738E\u7390\u7393\u7395\u7397\u7398\u739C\u739E\u739F\u73A0\u73A2\u73A5\u73A6\u73AA\u73AB\u73AD\u73B5\u73B7\u73B9\u73BC\u73BD\u73BF\u73C5\u73C6\u73C9\u73CB\u73CC\u73CF\u73D2\u73D3\u73D6\u73D9\u73DD\u73E1\u73E3\u73E6\u73E7\u73E9\u73F4\u73F5\u73F7\u73F9\u73FA\u73FB\u73FD"],
      ["8fcca1", "\u73FF\u7400\u7401\u7404\u7407\u740A\u7411\u741A\u741B\u7424\u7426\u7428", 9, "\u7439\u7440\u7443\u7444\u7446\u7447\u744B\u744D\u7451\u7452\u7457\u745D\u7462\u7466\u7467\u7468\u746B\u746D\u746E\u7471\u7472\u7480\u7481\u7485\u7486\u7487\u7489\u748F\u7490\u7491\u7492\u7498\u7499\u749A\u749C\u749F\u74A0\u74A1\u74A3\u74A6\u74A8\u74A9\u74AA\u74AB\u74AE\u74AF\u74B1\u74B2\u74B5\u74B9\u74BB\u74BF\u74C8\u74C9\u74CC\u74D0\u74D3\u74D8\u74DA\u74DB\u74DE\u74DF\u74E4\u74E8\u74EA\u74EB\u74EF\u74F4\u74FA\u74FB\u74FC\u74FF\u7506"],
      ["8fcda1", "\u7512\u7516\u7517\u7520\u7521\u7524\u7527\u7529\u752A\u752F\u7536\u7539\u753D\u753E\u753F\u7540\u7543\u7547\u7548\u754E\u7550\u7552\u7557\u755E\u755F\u7561\u756F\u7571\u7579", 5, "\u7581\u7585\u7590\u7592\u7593\u7595\u7599\u759C\u75A2\u75A4\u75B4\u75BA\u75BF\u75C0\u75C1\u75C4\u75C6\u75CC\u75CE\u75CF\u75D7\u75DC\u75DF\u75E0\u75E1\u75E4\u75E7\u75EC\u75EE\u75EF\u75F1\u75F9\u7600\u7602\u7603\u7604\u7607\u7608\u760A\u760C\u760F\u7612\u7613\u7615\u7616\u7619\u761B\u761C\u761D\u761E\u7623\u7625\u7626\u7629\u762D\u7632\u7633\u7635\u7638\u7639"],
      ["8fcea1", "\u763A\u763C\u764A\u7640\u7641\u7643\u7644\u7645\u7649\u764B\u7655\u7659\u765F\u7664\u7665\u766D\u766E\u766F\u7671\u7674\u7681\u7685\u768C\u768D\u7695\u769B\u769C\u769D\u769F\u76A0\u76A2", 6, "\u76AA\u76AD\u76BD\u76C1\u76C5\u76C9\u76CB\u76CC\u76CE\u76D4\u76D9\u76E0\u76E6\u76E8\u76EC\u76F0\u76F1\u76F6\u76F9\u76FC\u7700\u7706\u770A\u770E\u7712\u7714\u7715\u7717\u7719\u771A\u771C\u7722\u7728\u772D\u772E\u772F\u7734\u7735\u7736\u7739\u773D\u773E\u7742\u7745\u7746\u774A\u774D\u774E\u774F\u7752\u7756\u7757\u775C\u775E\u775F\u7760\u7762"],
      ["8fcfa1", "\u7764\u7767\u776A\u776C\u7770\u7772\u7773\u7774\u777A\u777D\u7780\u7784\u778C\u778D\u7794\u7795\u7796\u779A\u779F\u77A2\u77A7\u77AA\u77AE\u77AF\u77B1\u77B5\u77BE\u77C3\u77C9\u77D1\u77D2\u77D5\u77D9\u77DE\u77DF\u77E0\u77E4\u77E6\u77EA\u77EC\u77F0\u77F1\u77F4\u77F8\u77FB\u7805\u7806\u7809\u780D\u780E\u7811\u781D\u7821\u7822\u7823\u782D\u782E\u7830\u7835\u7837\u7843\u7844\u7847\u7848\u784C\u784E\u7852\u785C\u785E\u7860\u7861\u7863\u7864\u7868\u786A\u786E\u787A\u787E\u788A\u788F\u7894\u7898\u78A1\u789D\u789E\u789F\u78A4\u78A8\u78AC\u78AD\u78B0\u78B1\u78B2\u78B3"],
      ["8fd0a1", "\u78BB\u78BD\u78BF\u78C7\u78C8\u78C9\u78CC\u78CE\u78D2\u78D3\u78D5\u78D6\u78E4\u78DB\u78DF\u78E0\u78E1\u78E6\u78EA\u78F2\u78F3\u7900\u78F6\u78F7\u78FA\u78FB\u78FF\u7906\u790C\u7910\u791A\u791C\u791E\u791F\u7920\u7925\u7927\u7929\u792D\u7931\u7934\u7935\u793B\u793D\u793F\u7944\u7945\u7946\u794A\u794B\u794F\u7951\u7954\u7958\u795B\u795C\u7967\u7969\u796B\u7972\u7979\u797B\u797C\u797E\u798B\u798C\u7991\u7993\u7994\u7995\u7996\u7998\u799B\u799C\u79A1\u79A8\u79A9\u79AB\u79AF\u79B1\u79B4\u79B8\u79BB\u79C2\u79C4\u79C7\u79C8\u79CA\u79CF\u79D4\u79D6\u79DA\u79DD\u79DE"],
      ["8fd1a1", "\u79E0\u79E2\u79E5\u79EA\u79EB\u79ED\u79F1\u79F8\u79FC\u7A02\u7A03\u7A07\u7A09\u7A0A\u7A0C\u7A11\u7A15\u7A1B\u7A1E\u7A21\u7A27\u7A2B\u7A2D\u7A2F\u7A30\u7A34\u7A35\u7A38\u7A39\u7A3A\u7A44\u7A45\u7A47\u7A48\u7A4C\u7A55\u7A56\u7A59\u7A5C\u7A5D\u7A5F\u7A60\u7A65\u7A67\u7A6A\u7A6D\u7A75\u7A78\u7A7E\u7A80\u7A82\u7A85\u7A86\u7A8A\u7A8B\u7A90\u7A91\u7A94\u7A9E\u7AA0\u7AA3\u7AAC\u7AB3\u7AB5\u7AB9\u7ABB\u7ABC\u7AC6\u7AC9\u7ACC\u7ACE\u7AD1\u7ADB\u7AE8\u7AE9\u7AEB\u7AEC\u7AF1\u7AF4\u7AFB\u7AFD\u7AFE\u7B07\u7B14\u7B1F\u7B23\u7B27\u7B29\u7B2A\u7B2B\u7B2D\u7B2E\u7B2F\u7B30"],
      ["8fd2a1", "\u7B31\u7B34\u7B3D\u7B3F\u7B40\u7B41\u7B47\u7B4E\u7B55\u7B60\u7B64\u7B66\u7B69\u7B6A\u7B6D\u7B6F\u7B72\u7B73\u7B77\u7B84\u7B89\u7B8E\u7B90\u7B91\u7B96\u7B9B\u7B9E\u7BA0\u7BA5\u7BAC\u7BAF\u7BB0\u7BB2\u7BB5\u7BB6\u7BBA\u7BBB\u7BBC\u7BBD\u7BC2\u7BC5\u7BC8\u7BCA\u7BD4\u7BD6\u7BD7\u7BD9\u7BDA\u7BDB\u7BE8\u7BEA\u7BF2\u7BF4\u7BF5\u7BF8\u7BF9\u7BFA\u7BFC\u7BFE\u7C01\u7C02\u7C03\u7C04\u7C06\u7C09\u7C0B\u7C0C\u7C0E\u7C0F\u7C19\u7C1B\u7C20\u7C25\u7C26\u7C28\u7C2C\u7C31\u7C33\u7C34\u7C36\u7C39\u7C3A\u7C46\u7C4A\u7C55\u7C51\u7C52\u7C53\u7C59", 5],
      ["8fd3a1", "\u7C61\u7C63\u7C67\u7C69\u7C6D\u7C6E\u7C70\u7C72\u7C79\u7C7C\u7C7D\u7C86\u7C87\u7C8F\u7C94\u7C9E\u7CA0\u7CA6\u7CB0\u7CB6\u7CB7\u7CBA\u7CBB\u7CBC\u7CBF\u7CC4\u7CC7\u7CC8\u7CC9\u7CCD\u7CCF\u7CD3\u7CD4\u7CD5\u7CD7\u7CD9\u7CDA\u7CDD\u7CE6\u7CE9\u7CEB\u7CF5\u7D03\u7D07\u7D08\u7D09\u7D0F\u7D11\u7D12\u7D13\u7D16\u7D1D\u7D1E\u7D23\u7D26\u7D2A\u7D2D\u7D31\u7D3C\u7D3D\u7D3E\u7D40\u7D41\u7D47\u7D48\u7D4D\u7D51\u7D53\u7D57\u7D59\u7D5A\u7D5C\u7D5D\u7D65\u7D67\u7D6A\u7D70\u7D78\u7D7A\u7D7B\u7D7F\u7D81\u7D82\u7D83\u7D85\u7D86\u7D88\u7D8B\u7D8C\u7D8D\u7D91\u7D96\u7D97\u7D9D"],
      ["8fd4a1", "\u7D9E\u7DA6\u7DA7\u7DAA\u7DB3\u7DB6\u7DB7\u7DB9\u7DC2", 4, "\u7DCC\u7DCD\u7DCE\u7DD7\u7DD9\u7E00\u7DE2\u7DE5\u7DE6\u7DEA\u7DEB\u7DED\u7DF1\u7DF5\u7DF6\u7DF9\u7DFA\u7E08\u7E10\u7E11\u7E15\u7E17\u7E1C\u7E1D\u7E20\u7E27\u7E28\u7E2C\u7E2D\u7E2F\u7E33\u7E36\u7E3F\u7E44\u7E45\u7E47\u7E4E\u7E50\u7E52\u7E58\u7E5F\u7E61\u7E62\u7E65\u7E6B\u7E6E\u7E6F\u7E73\u7E78\u7E7E\u7E81\u7E86\u7E87\u7E8A\u7E8D\u7E91\u7E95\u7E98\u7E9A\u7E9D\u7E9E\u7F3C\u7F3B\u7F3D\u7F3E\u7F3F\u7F43\u7F44\u7F47\u7F4F\u7F52\u7F53\u7F5B\u7F5C\u7F5D\u7F61\u7F63\u7F64\u7F65\u7F66\u7F6D"],
      ["8fd5a1", "\u7F71\u7F7D\u7F7E\u7F7F\u7F80\u7F8B\u7F8D\u7F8F\u7F90\u7F91\u7F96\u7F97\u7F9C\u7FA1\u7FA2\u7FA6\u7FAA\u7FAD\u7FB4\u7FBC\u7FBF\u7FC0\u7FC3\u7FC8\u7FCE\u7FCF\u7FDB\u7FDF\u7FE3\u7FE5\u7FE8\u7FEC\u7FEE\u7FEF\u7FF2\u7FFA\u7FFD\u7FFE\u7FFF\u8007\u8008\u800A\u800D\u800E\u800F\u8011\u8013\u8014\u8016\u801D\u801E\u801F\u8020\u8024\u8026\u802C\u802E\u8030\u8034\u8035\u8037\u8039\u803A\u803C\u803E\u8040\u8044\u8060\u8064\u8066\u806D\u8071\u8075\u8081\u8088\u808E\u809C\u809E\u80A6\u80A7\u80AB\u80B8\u80B9\u80C8\u80CD\u80CF\u80D2\u80D4\u80D5\u80D7\u80D8\u80E0\u80ED\u80EE"],
      ["8fd6a1", "\u80F0\u80F2\u80F3\u80F6\u80F9\u80FA\u80FE\u8103\u810B\u8116\u8117\u8118\u811C\u811E\u8120\u8124\u8127\u812C\u8130\u8135\u813A\u813C\u8145\u8147\u814A\u814C\u8152\u8157\u8160\u8161\u8167\u8168\u8169\u816D\u816F\u8177\u8181\u8190\u8184\u8185\u8186\u818B\u818E\u8196\u8198\u819B\u819E\u81A2\u81AE\u81B2\u81B4\u81BB\u81CB\u81C3\u81C5\u81CA\u81CE\u81CF\u81D5\u81D7\u81DB\u81DD\u81DE\u81E1\u81E4\u81EB\u81EC\u81F0\u81F1\u81F2\u81F5\u81F6\u81F8\u81F9\u81FD\u81FF\u8200\u8203\u820F\u8213\u8214\u8219\u821A\u821D\u8221\u8222\u8228\u8232\u8234\u823A\u8243\u8244\u8245\u8246"],
      ["8fd7a1", "\u824B\u824E\u824F\u8251\u8256\u825C\u8260\u8263\u8267\u826D\u8274\u827B\u827D\u827F\u8280\u8281\u8283\u8284\u8287\u8289\u828A\u828E\u8291\u8294\u8296\u8298\u829A\u829B\u82A0\u82A1\u82A3\u82A4\u82A7\u82A8\u82A9\u82AA\u82AE\u82B0\u82B2\u82B4\u82B7\u82BA\u82BC\u82BE\u82BF\u82C6\u82D0\u82D5\u82DA\u82E0\u82E2\u82E4\u82E8\u82EA\u82ED\u82EF\u82F6\u82F7\u82FD\u82FE\u8300\u8301\u8307\u8308\u830A\u830B\u8354\u831B\u831D\u831E\u831F\u8321\u8322\u832C\u832D\u832E\u8330\u8333\u8337\u833A\u833C\u833D\u8342\u8343\u8344\u8347\u834D\u834E\u8351\u8355\u8356\u8357\u8370\u8378"],
      ["8fd8a1", "\u837D\u837F\u8380\u8382\u8384\u8386\u838D\u8392\u8394\u8395\u8398\u8399\u839B\u839C\u839D\u83A6\u83A7\u83A9\u83AC\u83BE\u83BF\u83C0\u83C7\u83C9\u83CF\u83D0\u83D1\u83D4\u83DD\u8353\u83E8\u83EA\u83F6\u83F8\u83F9\u83FC\u8401\u8406\u840A\u840F\u8411\u8415\u8419\u83AD\u842F\u8439\u8445\u8447\u8448\u844A\u844D\u844F\u8451\u8452\u8456\u8458\u8459\u845A\u845C\u8460\u8464\u8465\u8467\u846A\u8470\u8473\u8474\u8476\u8478\u847C\u847D\u8481\u8485\u8492\u8493\u8495\u849E\u84A6\u84A8\u84A9\u84AA\u84AF\u84B1\u84B4\u84BA\u84BD\u84BE\u84C0\u84C2\u84C7\u84C8\u84CC\u84CF\u84D3"],
      ["8fd9a1", "\u84DC\u84E7\u84EA\u84EF\u84F0\u84F1\u84F2\u84F7\u8532\u84FA\u84FB\u84FD\u8502\u8503\u8507\u850C\u850E\u8510\u851C\u851E\u8522\u8523\u8524\u8525\u8527\u852A\u852B\u852F\u8533\u8534\u8536\u853F\u8546\u854F", 4, "\u8556\u8559\u855C", 6, "\u8564\u856B\u856F\u8579\u857A\u857B\u857D\u857F\u8581\u8585\u8586\u8589\u858B\u858C\u858F\u8593\u8598\u859D\u859F\u85A0\u85A2\u85A5\u85A7\u85B4\u85B6\u85B7\u85B8\u85BC\u85BD\u85BE\u85BF\u85C2\u85C7\u85CA\u85CB\u85CE\u85AD\u85D8\u85DA\u85DF\u85E0\u85E6\u85E8\u85ED\u85F3\u85F6\u85FC"],
      ["8fdaa1", "\u85FF\u8600\u8604\u8605\u860D\u860E\u8610\u8611\u8612\u8618\u8619\u861B\u861E\u8621\u8627\u8629\u8636\u8638\u863A\u863C\u863D\u8640\u8642\u8646\u8652\u8653\u8656\u8657\u8658\u8659\u865D\u8660", 4, "\u8669\u866C\u866F\u8675\u8676\u8677\u867A\u868D\u8691\u8696\u8698\u869A\u869C\u86A1\u86A6\u86A7\u86A8\u86AD\u86B1\u86B3\u86B4\u86B5\u86B7\u86B8\u86B9\u86BF\u86C0\u86C1\u86C3\u86C5\u86D1\u86D2\u86D5\u86D7\u86DA\u86DC\u86E0\u86E3\u86E5\u86E7\u8688\u86FA\u86FC\u86FD\u8704\u8705\u8707\u870B\u870E\u870F\u8710\u8713\u8714\u8719\u871E\u871F\u8721\u8723"],
      ["8fdba1", "\u8728\u872E\u872F\u8731\u8732\u8739\u873A\u873C\u873D\u873E\u8740\u8743\u8745\u874D\u8758\u875D\u8761\u8764\u8765\u876F\u8771\u8772\u877B\u8783", 6, "\u878B\u878C\u8790\u8793\u8795\u8797\u8798\u8799\u879E\u87A0\u87A3\u87A7\u87AC\u87AD\u87AE\u87B1\u87B5\u87BE\u87BF\u87C1\u87C8\u87C9\u87CA\u87CE\u87D5\u87D6\u87D9\u87DA\u87DC\u87DF\u87E2\u87E3\u87E4\u87EA\u87EB\u87ED\u87F1\u87F3\u87F8\u87FA\u87FF\u8801\u8803\u8806\u8809\u880A\u880B\u8810\u8819\u8812\u8813\u8814\u8818\u881A\u881B\u881C\u881E\u881F\u8828\u882D\u882E\u8830\u8832\u8835"],
      ["8fdca1", "\u883A\u883C\u8841\u8843\u8845\u8848\u8849\u884A\u884B\u884E\u8851\u8855\u8856\u8858\u885A\u885C\u885F\u8860\u8864\u8869\u8871\u8879\u887B\u8880\u8898\u889A\u889B\u889C\u889F\u88A0\u88A8\u88AA\u88BA\u88BD\u88BE\u88C0\u88CA", 4, "\u88D1\u88D2\u88D3\u88DB\u88DE\u88E7\u88EF\u88F0\u88F1\u88F5\u88F7\u8901\u8906\u890D\u890E\u890F\u8915\u8916\u8918\u8919\u891A\u891C\u8920\u8926\u8927\u8928\u8930\u8931\u8932\u8935\u8939\u893A\u893E\u8940\u8942\u8945\u8946\u8949\u894F\u8952\u8957\u895A\u895B\u895C\u8961\u8962\u8963\u896B\u896E\u8970\u8973\u8975\u897A"],
      ["8fdda1", "\u897B\u897C\u897D\u8989\u898D\u8990\u8994\u8995\u899B\u899C\u899F\u89A0\u89A5\u89B0\u89B4\u89B5\u89B6\u89B7\u89BC\u89D4", 4, "\u89E5\u89E9\u89EB\u89ED\u89F1\u89F3\u89F6\u89F9\u89FD\u89FF\u8A04\u8A05\u8A07\u8A0F\u8A11\u8A12\u8A14\u8A15\u8A1E\u8A20\u8A22\u8A24\u8A26\u8A2B\u8A2C\u8A2F\u8A35\u8A37\u8A3D\u8A3E\u8A40\u8A43\u8A45\u8A47\u8A49\u8A4D\u8A4E\u8A53\u8A56\u8A57\u8A58\u8A5C\u8A5D\u8A61\u8A65\u8A67\u8A75\u8A76\u8A77\u8A79\u8A7A\u8A7B\u8A7E\u8A7F\u8A80\u8A83\u8A86\u8A8B\u8A8F\u8A90\u8A92\u8A96\u8A97\u8A99\u8A9F\u8AA7\u8AA9\u8AAE\u8AAF\u8AB3"],
      ["8fdea1", "\u8AB6\u8AB7\u8ABB\u8ABE\u8AC3\u8AC6\u8AC8\u8AC9\u8ACA\u8AD1\u8AD3\u8AD4\u8AD5\u8AD7\u8ADD\u8ADF\u8AEC\u8AF0\u8AF4\u8AF5\u8AF6\u8AFC\u8AFF\u8B05\u8B06\u8B0B\u8B11\u8B1C\u8B1E\u8B1F\u8B0A\u8B2D\u8B30\u8B37\u8B3C\u8B42", 4, "\u8B48\u8B52\u8B53\u8B54\u8B59\u8B4D\u8B5E\u8B63\u8B6D\u8B76\u8B78\u8B79\u8B7C\u8B7E\u8B81\u8B84\u8B85\u8B8B\u8B8D\u8B8F\u8B94\u8B95\u8B9C\u8B9E\u8B9F\u8C38\u8C39\u8C3D\u8C3E\u8C45\u8C47\u8C49\u8C4B\u8C4F\u8C51\u8C53\u8C54\u8C57\u8C58\u8C5B\u8C5D\u8C59\u8C63\u8C64\u8C66\u8C68\u8C69\u8C6D\u8C73\u8C75\u8C76\u8C7B\u8C7E\u8C86"],
      ["8fdfa1", "\u8C87\u8C8B\u8C90\u8C92\u8C93\u8C99\u8C9B\u8C9C\u8CA4\u8CB9\u8CBA\u8CC5\u8CC6\u8CC9\u8CCB\u8CCF\u8CD6\u8CD5\u8CD9\u8CDD\u8CE1\u8CE8\u8CEC\u8CEF\u8CF0\u8CF2\u8CF5\u8CF7\u8CF8\u8CFE\u8CFF\u8D01\u8D03\u8D09\u8D12\u8D17\u8D1B\u8D65\u8D69\u8D6C\u8D6E\u8D7F\u8D82\u8D84\u8D88\u8D8D\u8D90\u8D91\u8D95\u8D9E\u8D9F\u8DA0\u8DA6\u8DAB\u8DAC\u8DAF\u8DB2\u8DB5\u8DB7\u8DB9\u8DBB\u8DC0\u8DC5\u8DC6\u8DC7\u8DC8\u8DCA\u8DCE\u8DD1\u8DD4\u8DD5\u8DD7\u8DD9\u8DE4\u8DE5\u8DE7\u8DEC\u8DF0\u8DBC\u8DF1\u8DF2\u8DF4\u8DFD\u8E01\u8E04\u8E05\u8E06\u8E0B\u8E11\u8E14\u8E16\u8E20\u8E21\u8E22"],
      ["8fe0a1", "\u8E23\u8E26\u8E27\u8E31\u8E33\u8E36\u8E37\u8E38\u8E39\u8E3D\u8E40\u8E41\u8E4B\u8E4D\u8E4E\u8E4F\u8E54\u8E5B\u8E5C\u8E5D\u8E5E\u8E61\u8E62\u8E69\u8E6C\u8E6D\u8E6F\u8E70\u8E71\u8E79\u8E7A\u8E7B\u8E82\u8E83\u8E89\u8E90\u8E92\u8E95\u8E9A\u8E9B\u8E9D\u8E9E\u8EA2\u8EA7\u8EA9\u8EAD\u8EAE\u8EB3\u8EB5\u8EBA\u8EBB\u8EC0\u8EC1\u8EC3\u8EC4\u8EC7\u8ECF\u8ED1\u8ED4\u8EDC\u8EE8\u8EEE\u8EF0\u8EF1\u8EF7\u8EF9\u8EFA\u8EED\u8F00\u8F02\u8F07\u8F08\u8F0F\u8F10\u8F16\u8F17\u8F18\u8F1E\u8F20\u8F21\u8F23\u8F25\u8F27\u8F28\u8F2C\u8F2D\u8F2E\u8F34\u8F35\u8F36\u8F37\u8F3A\u8F40\u8F41"],
      ["8fe1a1", "\u8F43\u8F47\u8F4F\u8F51", 4, "\u8F58\u8F5D\u8F5E\u8F65\u8F9D\u8FA0\u8FA1\u8FA4\u8FA5\u8FA6\u8FB5\u8FB6\u8FB8\u8FBE\u8FC0\u8FC1\u8FC6\u8FCA\u8FCB\u8FCD\u8FD0\u8FD2\u8FD3\u8FD5\u8FE0\u8FE3\u8FE4\u8FE8\u8FEE\u8FF1\u8FF5\u8FF6\u8FFB\u8FFE\u9002\u9004\u9008\u900C\u9018\u901B\u9028\u9029\u902F\u902A\u902C\u902D\u9033\u9034\u9037\u903F\u9043\u9044\u904C\u905B\u905D\u9062\u9066\u9067\u906C\u9070\u9074\u9079\u9085\u9088\u908B\u908C\u908E\u9090\u9095\u9097\u9098\u9099\u909B\u90A0\u90A1\u90A2\u90A5\u90B0\u90B2\u90B3\u90B4\u90B6\u90BD\u90CC\u90BE\u90C3"],
      ["8fe2a1", "\u90C4\u90C5\u90C7\u90C8\u90D5\u90D7\u90D8\u90D9\u90DC\u90DD\u90DF\u90E5\u90D2\u90F6\u90EB\u90EF\u90F0\u90F4\u90FE\u90FF\u9100\u9104\u9105\u9106\u9108\u910D\u9110\u9114\u9116\u9117\u9118\u911A\u911C\u911E\u9120\u9125\u9122\u9123\u9127\u9129\u912E\u912F\u9131\u9134\u9136\u9137\u9139\u913A\u913C\u913D\u9143\u9147\u9148\u914F\u9153\u9157\u9159\u915A\u915B\u9161\u9164\u9167\u916D\u9174\u9179\u917A\u917B\u9181\u9183\u9185\u9186\u918A\u918E\u9191\u9193\u9194\u9195\u9198\u919E\u91A1\u91A6\u91A8\u91AC\u91AD\u91AE\u91B0\u91B1\u91B2\u91B3\u91B6\u91BB\u91BC\u91BD\u91BF"],
      ["8fe3a1", "\u91C2\u91C3\u91C5\u91D3\u91D4\u91D7\u91D9\u91DA\u91DE\u91E4\u91E5\u91E9\u91EA\u91EC", 5, "\u91F7\u91F9\u91FB\u91FD\u9200\u9201\u9204\u9205\u9206\u9207\u9209\u920A\u920C\u9210\u9212\u9213\u9216\u9218\u921C\u921D\u9223\u9224\u9225\u9226\u9228\u922E\u922F\u9230\u9233\u9235\u9236\u9238\u9239\u923A\u923C\u923E\u9240\u9242\u9243\u9246\u9247\u924A\u924D\u924E\u924F\u9251\u9258\u9259\u925C\u925D\u9260\u9261\u9265\u9267\u9268\u9269\u926E\u926F\u9270\u9275", 4, "\u927B\u927C\u927D\u927F\u9288\u9289\u928A\u928D\u928E\u9292\u9297"],
      ["8fe4a1", "\u9299\u929F\u92A0\u92A4\u92A5\u92A7\u92A8\u92AB\u92AF\u92B2\u92B6\u92B8\u92BA\u92BB\u92BC\u92BD\u92BF", 4, "\u92C5\u92C6\u92C7\u92C8\u92CB\u92CC\u92CD\u92CE\u92D0\u92D3\u92D5\u92D7\u92D8\u92D9\u92DC\u92DD\u92DF\u92E0\u92E1\u92E3\u92E5\u92E7\u92E8\u92EC\u92EE\u92F0\u92F9\u92FB\u92FF\u9300\u9302\u9308\u930D\u9311\u9314\u9315\u931C\u931D\u931E\u931F\u9321\u9324\u9325\u9327\u9329\u932A\u9333\u9334\u9336\u9337\u9347\u9348\u9349\u9350\u9351\u9352\u9355\u9357\u9358\u935A\u935E\u9364\u9365\u9367\u9369\u936A\u936D\u936F\u9370\u9371\u9373\u9374\u9376"],
      ["8fe5a1", "\u937A\u937D\u937F\u9380\u9381\u9382\u9388\u938A\u938B\u938D\u938F\u9392\u9395\u9398\u939B\u939E\u93A1\u93A3\u93A4\u93A6\u93A8\u93AB\u93B4\u93B5\u93B6\u93BA\u93A9\u93C1\u93C4\u93C5\u93C6\u93C7\u93C9", 4, "\u93D3\u93D9\u93DC\u93DE\u93DF\u93E2\u93E6\u93E7\u93F9\u93F7\u93F8\u93FA\u93FB\u93FD\u9401\u9402\u9404\u9408\u9409\u940D\u940E\u940F\u9415\u9416\u9417\u941F\u942E\u942F\u9431\u9432\u9433\u9434\u943B\u943F\u943D\u9443\u9445\u9448\u944A\u944C\u9455\u9459\u945C\u945F\u9461\u9463\u9468\u946B\u946D\u946E\u946F\u9471\u9472\u9484\u9483\u9578\u9579"],
      ["8fe6a1", "\u957E\u9584\u9588\u958C\u958D\u958E\u959D\u959E\u959F\u95A1\u95A6\u95A9\u95AB\u95AC\u95B4\u95B6\u95BA\u95BD\u95BF\u95C6\u95C8\u95C9\u95CB\u95D0\u95D1\u95D2\u95D3\u95D9\u95DA\u95DD\u95DE\u95DF\u95E0\u95E4\u95E6\u961D\u961E\u9622\u9624\u9625\u9626\u962C\u9631\u9633\u9637\u9638\u9639\u963A\u963C\u963D\u9641\u9652\u9654\u9656\u9657\u9658\u9661\u966E\u9674\u967B\u967C\u967E\u967F\u9681\u9682\u9683\u9684\u9689\u9691\u9696\u969A\u969D\u969F\u96A4\u96A5\u96A6\u96A9\u96AE\u96AF\u96B3\u96BA\u96CA\u96D2\u5DB2\u96D8\u96DA\u96DD\u96DE\u96DF\u96E9\u96EF\u96F1\u96FA\u9702"],
      ["8fe7a1", "\u9703\u9705\u9709\u971A\u971B\u971D\u9721\u9722\u9723\u9728\u9731\u9733\u9741\u9743\u974A\u974E\u974F\u9755\u9757\u9758\u975A\u975B\u9763\u9767\u976A\u976E\u9773\u9776\u9777\u9778\u977B\u977D\u977F\u9780\u9789\u9795\u9796\u9797\u9799\u979A\u979E\u979F\u97A2\u97AC\u97AE\u97B1\u97B2\u97B5\u97B6\u97B8\u97B9\u97BA\u97BC\u97BE\u97BF\u97C1\u97C4\u97C5\u97C7\u97C9\u97CA\u97CC\u97CD\u97CE\u97D0\u97D1\u97D4\u97D7\u97D8\u97D9\u97DD\u97DE\u97E0\u97DB\u97E1\u97E4\u97EF\u97F1\u97F4\u97F7\u97F8\u97FA\u9807\u980A\u9819\u980D\u980E\u9814\u9816\u981C\u981E\u9820\u9823\u9826"],
      ["8fe8a1", "\u982B\u982E\u982F\u9830\u9832\u9833\u9835\u9825\u983E\u9844\u9847\u984A\u9851\u9852\u9853\u9856\u9857\u9859\u985A\u9862\u9863\u9865\u9866\u986A\u986C\u98AB\u98AD\u98AE\u98B0\u98B4\u98B7\u98B8\u98BA\u98BB\u98BF\u98C2\u98C5\u98C8\u98CC\u98E1\u98E3\u98E5\u98E6\u98E7\u98EA\u98F3\u98F6\u9902\u9907\u9908\u9911\u9915\u9916\u9917\u991A\u991B\u991C\u991F\u9922\u9926\u9927\u992B\u9931", 4, "\u9939\u993A\u993B\u993C\u9940\u9941\u9946\u9947\u9948\u994D\u994E\u9954\u9958\u9959\u995B\u995C\u995E\u995F\u9960\u999B\u999D\u999F\u99A6\u99B0\u99B1\u99B2\u99B5"],
      ["8fe9a1", "\u99B9\u99BA\u99BD\u99BF\u99C3\u99C9\u99D3\u99D4\u99D9\u99DA\u99DC\u99DE\u99E7\u99EA\u99EB\u99EC\u99F0\u99F4\u99F5\u99F9\u99FD\u99FE\u9A02\u9A03\u9A04\u9A0B\u9A0C\u9A10\u9A11\u9A16\u9A1E\u9A20\u9A22\u9A23\u9A24\u9A27\u9A2D\u9A2E\u9A33\u9A35\u9A36\u9A38\u9A47\u9A41\u9A44\u9A4A\u9A4B\u9A4C\u9A4E\u9A51\u9A54\u9A56\u9A5D\u9AAA\u9AAC\u9AAE\u9AAF\u9AB2\u9AB4\u9AB5\u9AB6\u9AB9\u9ABB\u9ABE\u9ABF\u9AC1\u9AC3\u9AC6\u9AC8\u9ACE\u9AD0\u9AD2\u9AD5\u9AD6\u9AD7\u9ADB\u9ADC\u9AE0\u9AE4\u9AE5\u9AE7\u9AE9\u9AEC\u9AF2\u9AF3\u9AF5\u9AF9\u9AFA\u9AFD\u9AFF", 4],
      ["8feaa1", "\u9B04\u9B05\u9B08\u9B09\u9B0B\u9B0C\u9B0D\u9B0E\u9B10\u9B12\u9B16\u9B19\u9B1B\u9B1C\u9B20\u9B26\u9B2B\u9B2D\u9B33\u9B34\u9B35\u9B37\u9B39\u9B3A\u9B3D\u9B48\u9B4B\u9B4C\u9B55\u9B56\u9B57\u9B5B\u9B5E\u9B61\u9B63\u9B65\u9B66\u9B68\u9B6A", 4, "\u9B73\u9B75\u9B77\u9B78\u9B79\u9B7F\u9B80\u9B84\u9B85\u9B86\u9B87\u9B89\u9B8A\u9B8B\u9B8D\u9B8F\u9B90\u9B94\u9B9A\u9B9D\u9B9E\u9BA6\u9BA7\u9BA9\u9BAC\u9BB0\u9BB1\u9BB2\u9BB7\u9BB8\u9BBB\u9BBC\u9BBE\u9BBF\u9BC1\u9BC7\u9BC8\u9BCE\u9BD0\u9BD7\u9BD8\u9BDD\u9BDF\u9BE5\u9BE7\u9BEA\u9BEB\u9BEF\u9BF3\u9BF7\u9BF8"],
      ["8feba1", "\u9BF9\u9BFA\u9BFD\u9BFF\u9C00\u9C02\u9C0B\u9C0F\u9C11\u9C16\u9C18\u9C19\u9C1A\u9C1C\u9C1E\u9C22\u9C23\u9C26", 4, "\u9C31\u9C35\u9C36\u9C37\u9C3D\u9C41\u9C43\u9C44\u9C45\u9C49\u9C4A\u9C4E\u9C4F\u9C50\u9C53\u9C54\u9C56\u9C58\u9C5B\u9C5D\u9C5E\u9C5F\u9C63\u9C69\u9C6A\u9C5C\u9C6B\u9C68\u9C6E\u9C70\u9C72\u9C75\u9C77\u9C7B\u9CE6\u9CF2\u9CF7\u9CF9\u9D0B\u9D02\u9D11\u9D17\u9D18\u9D1C\u9D1D\u9D1E\u9D2F\u9D30\u9D32\u9D33\u9D34\u9D3A\u9D3C\u9D45\u9D3D\u9D42\u9D43\u9D47\u9D4A\u9D53\u9D54\u9D5F\u9D63\u9D62\u9D65\u9D69\u9D6A\u9D6B\u9D70\u9D76\u9D77\u9D7B"],
      ["8feca1", "\u9D7C\u9D7E\u9D83\u9D84\u9D86\u9D8A\u9D8D\u9D8E\u9D92\u9D93\u9D95\u9D96\u9D97\u9D98\u9DA1\u9DAA\u9DAC\u9DAE\u9DB1\u9DB5\u9DB9\u9DBC\u9DBF\u9DC3\u9DC7\u9DC9\u9DCA\u9DD4\u9DD5\u9DD6\u9DD7\u9DDA\u9DDE\u9DDF\u9DE0\u9DE5\u9DE7\u9DE9\u9DEB\u9DEE\u9DF0\u9DF3\u9DF4\u9DFE\u9E0A\u9E02\u9E07\u9E0E\u9E10\u9E11\u9E12\u9E15\u9E16\u9E19\u9E1C\u9E1D\u9E7A\u9E7B\u9E7C\u9E80\u9E82\u9E83\u9E84\u9E85\u9E87\u9E8E\u9E8F\u9E96\u9E98\u9E9B\u9E9E\u9EA4\u9EA8\u9EAC\u9EAE\u9EAF\u9EB0\u9EB3\u9EB4\u9EB5\u9EC6\u9EC8\u9ECB\u9ED5\u9EDF\u9EE4\u9EE7\u9EEC\u9EED\u9EEE\u9EF0\u9EF1\u9EF2\u9EF5"],
      ["8feda1", "\u9EF8\u9EFF\u9F02\u9F03\u9F09\u9F0F\u9F10\u9F11\u9F12\u9F14\u9F16\u9F17\u9F19\u9F1A\u9F1B\u9F1F\u9F22\u9F26\u9F2A\u9F2B\u9F2F\u9F31\u9F32\u9F34\u9F37\u9F39\u9F3A\u9F3C\u9F3D\u9F3F\u9F41\u9F43", 4, "\u9F53\u9F55\u9F56\u9F57\u9F58\u9F5A\u9F5D\u9F5E\u9F68\u9F69\u9F6D", 4, "\u9F73\u9F75\u9F7A\u9F7D\u9F8F\u9F90\u9F91\u9F92\u9F94\u9F96\u9F97\u9F9E\u9FA1\u9FA2\u9FA3\u9FA5"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp936.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127, "\u20AC"],
      ["8140", "\u4E02\u4E04\u4E05\u4E06\u4E0F\u4E12\u4E17\u4E1F\u4E20\u4E21\u4E23\u4E26\u4E29\u4E2E\u4E2F\u4E31\u4E33\u4E35\u4E37\u4E3C\u4E40\u4E41\u4E42\u4E44\u4E46\u4E4A\u4E51\u4E55\u4E57\u4E5A\u4E5B\u4E62\u4E63\u4E64\u4E65\u4E67\u4E68\u4E6A", 5, "\u4E72\u4E74", 9, "\u4E7F", 6, "\u4E87\u4E8A"],
      ["8180", "\u4E90\u4E96\u4E97\u4E99\u4E9C\u4E9D\u4E9E\u4EA3\u4EAA\u4EAF\u4EB0\u4EB1\u4EB4\u4EB6\u4EB7\u4EB8\u4EB9\u4EBC\u4EBD\u4EBE\u4EC8\u4ECC\u4ECF\u4ED0\u4ED2\u4EDA\u4EDB\u4EDC\u4EE0\u4EE2\u4EE6\u4EE7\u4EE9\u4EED\u4EEE\u4EEF\u4EF1\u4EF4\u4EF8\u4EF9\u4EFA\u4EFC\u4EFE\u4F00\u4F02", 6, "\u4F0B\u4F0C\u4F12", 4, "\u4F1C\u4F1D\u4F21\u4F23\u4F28\u4F29\u4F2C\u4F2D\u4F2E\u4F31\u4F33\u4F35\u4F37\u4F39\u4F3B\u4F3E", 4, "\u4F44\u4F45\u4F47", 5, "\u4F52\u4F54\u4F56\u4F61\u4F62\u4F66\u4F68\u4F6A\u4F6B\u4F6D\u4F6E\u4F71\u4F72\u4F75\u4F77\u4F78\u4F79\u4F7A\u4F7D\u4F80\u4F81\u4F82\u4F85\u4F86\u4F87\u4F8A\u4F8C\u4F8E\u4F90\u4F92\u4F93\u4F95\u4F96\u4F98\u4F99\u4F9A\u4F9C\u4F9E\u4F9F\u4FA1\u4FA2"],
      ["8240", "\u4FA4\u4FAB\u4FAD\u4FB0", 4, "\u4FB6", 8, "\u4FC0\u4FC1\u4FC2\u4FC6\u4FC7\u4FC8\u4FC9\u4FCB\u4FCC\u4FCD\u4FD2", 4, "\u4FD9\u4FDB\u4FE0\u4FE2\u4FE4\u4FE5\u4FE7\u4FEB\u4FEC\u4FF0\u4FF2\u4FF4\u4FF5\u4FF6\u4FF7\u4FF9\u4FFB\u4FFC\u4FFD\u4FFF", 11],
      ["8280", "\u500B\u500E\u5010\u5011\u5013\u5015\u5016\u5017\u501B\u501D\u501E\u5020\u5022\u5023\u5024\u5027\u502B\u502F", 10, "\u503B\u503D\u503F\u5040\u5041\u5042\u5044\u5045\u5046\u5049\u504A\u504B\u504D\u5050", 4, "\u5056\u5057\u5058\u5059\u505B\u505D", 7, "\u5066", 5, "\u506D", 8, "\u5078\u5079\u507A\u507C\u507D\u5081\u5082\u5083\u5084\u5086\u5087\u5089\u508A\u508B\u508C\u508E", 20, "\u50A4\u50A6\u50AA\u50AB\u50AD", 4, "\u50B3", 6, "\u50BC"],
      ["8340", "\u50BD", 17, "\u50D0", 5, "\u50D7\u50D8\u50D9\u50DB", 10, "\u50E8\u50E9\u50EA\u50EB\u50EF\u50F0\u50F1\u50F2\u50F4\u50F6", 4, "\u50FC", 9, "\u5108"],
      ["8380", "\u5109\u510A\u510C", 5, "\u5113", 13, "\u5122", 28, "\u5142\u5147\u514A\u514C\u514E\u514F\u5150\u5152\u5153\u5157\u5158\u5159\u515B\u515D", 4, "\u5163\u5164\u5166\u5167\u5169\u516A\u516F\u5172\u517A\u517E\u517F\u5183\u5184\u5186\u5187\u518A\u518B\u518E\u518F\u5190\u5191\u5193\u5194\u5198\u519A\u519D\u519E\u519F\u51A1\u51A3\u51A6", 4, "\u51AD\u51AE\u51B4\u51B8\u51B9\u51BA\u51BE\u51BF\u51C1\u51C2\u51C3\u51C5\u51C8\u51CA\u51CD\u51CE\u51D0\u51D2", 5],
      ["8440", "\u51D8\u51D9\u51DA\u51DC\u51DE\u51DF\u51E2\u51E3\u51E5", 5, "\u51EC\u51EE\u51F1\u51F2\u51F4\u51F7\u51FE\u5204\u5205\u5209\u520B\u520C\u520F\u5210\u5213\u5214\u5215\u521C\u521E\u521F\u5221\u5222\u5223\u5225\u5226\u5227\u522A\u522C\u522F\u5231\u5232\u5234\u5235\u523C\u523E\u5244", 5, "\u524B\u524E\u524F\u5252\u5253\u5255\u5257\u5258"],
      ["8480", "\u5259\u525A\u525B\u525D\u525F\u5260\u5262\u5263\u5264\u5266\u5268\u526B\u526C\u526D\u526E\u5270\u5271\u5273", 9, "\u527E\u5280\u5283", 4, "\u5289", 6, "\u5291\u5292\u5294", 6, "\u529C\u52A4\u52A5\u52A6\u52A7\u52AE\u52AF\u52B0\u52B4", 9, "\u52C0\u52C1\u52C2\u52C4\u52C5\u52C6\u52C8\u52CA\u52CC\u52CD\u52CE\u52CF\u52D1\u52D3\u52D4\u52D5\u52D7\u52D9", 5, "\u52E0\u52E1\u52E2\u52E3\u52E5", 10, "\u52F1", 7, "\u52FB\u52FC\u52FD\u5301\u5302\u5303\u5304\u5307\u5309\u530A\u530B\u530C\u530E"],
      ["8540", "\u5311\u5312\u5313\u5314\u5318\u531B\u531C\u531E\u531F\u5322\u5324\u5325\u5327\u5328\u5329\u532B\u532C\u532D\u532F", 9, "\u533C\u533D\u5340\u5342\u5344\u5346\u534B\u534C\u534D\u5350\u5354\u5358\u5359\u535B\u535D\u5365\u5368\u536A\u536C\u536D\u5372\u5376\u5379\u537B\u537C\u537D\u537E\u5380\u5381\u5383\u5387\u5388\u538A\u538E\u538F"],
      ["8580", "\u5390", 4, "\u5396\u5397\u5399\u539B\u539C\u539E\u53A0\u53A1\u53A4\u53A7\u53AA\u53AB\u53AC\u53AD\u53AF", 6, "\u53B7\u53B8\u53B9\u53BA\u53BC\u53BD\u53BE\u53C0\u53C3", 4, "\u53CE\u53CF\u53D0\u53D2\u53D3\u53D5\u53DA\u53DC\u53DD\u53DE\u53E1\u53E2\u53E7\u53F4\u53FA\u53FE\u53FF\u5400\u5402\u5405\u5407\u540B\u5414\u5418\u5419\u541A\u541C\u5422\u5424\u5425\u542A\u5430\u5433\u5436\u5437\u543A\u543D\u543F\u5441\u5442\u5444\u5445\u5447\u5449\u544C\u544D\u544E\u544F\u5451\u545A\u545D", 4, "\u5463\u5465\u5467\u5469", 7, "\u5474\u5479\u547A\u547E\u547F\u5481\u5483\u5485\u5487\u5488\u5489\u548A\u548D\u5491\u5493\u5497\u5498\u549C\u549E\u549F\u54A0\u54A1"],
      ["8640", "\u54A2\u54A5\u54AE\u54B0\u54B2\u54B5\u54B6\u54B7\u54B9\u54BA\u54BC\u54BE\u54C3\u54C5\u54CA\u54CB\u54D6\u54D8\u54DB\u54E0", 4, "\u54EB\u54EC\u54EF\u54F0\u54F1\u54F4", 5, "\u54FB\u54FE\u5500\u5502\u5503\u5504\u5505\u5508\u550A", 4, "\u5512\u5513\u5515", 5, "\u551C\u551D\u551E\u551F\u5521\u5525\u5526"],
      ["8680", "\u5528\u5529\u552B\u552D\u5532\u5534\u5535\u5536\u5538\u5539\u553A\u553B\u553D\u5540\u5542\u5545\u5547\u5548\u554B", 4, "\u5551\u5552\u5553\u5554\u5557", 4, "\u555D\u555E\u555F\u5560\u5562\u5563\u5568\u5569\u556B\u556F", 5, "\u5579\u557A\u557D\u557F\u5585\u5586\u558C\u558D\u558E\u5590\u5592\u5593\u5595\u5596\u5597\u559A\u559B\u559E\u55A0", 6, "\u55A8", 8, "\u55B2\u55B4\u55B6\u55B8\u55BA\u55BC\u55BF", 4, "\u55C6\u55C7\u55C8\u55CA\u55CB\u55CE\u55CF\u55D0\u55D5\u55D7", 4, "\u55DE\u55E0\u55E2\u55E7\u55E9\u55ED\u55EE\u55F0\u55F1\u55F4\u55F6\u55F8", 4, "\u55FF\u5602\u5603\u5604\u5605"],
      ["8740", "\u5606\u5607\u560A\u560B\u560D\u5610", 7, "\u5619\u561A\u561C\u561D\u5620\u5621\u5622\u5625\u5626\u5628\u5629\u562A\u562B\u562E\u562F\u5630\u5633\u5635\u5637\u5638\u563A\u563C\u563D\u563E\u5640", 11, "\u564F", 4, "\u5655\u5656\u565A\u565B\u565D", 4],
      ["8780", "\u5663\u5665\u5666\u5667\u566D\u566E\u566F\u5670\u5672\u5673\u5674\u5675\u5677\u5678\u5679\u567A\u567D", 7, "\u5687", 6, "\u5690\u5691\u5692\u5694", 14, "\u56A4", 10, "\u56B0", 6, "\u56B8\u56B9\u56BA\u56BB\u56BD", 12, "\u56CB", 8, "\u56D5\u56D6\u56D8\u56D9\u56DC\u56E3\u56E5", 5, "\u56EC\u56EE\u56EF\u56F2\u56F3\u56F6\u56F7\u56F8\u56FB\u56FC\u5700\u5701\u5702\u5705\u5707\u570B", 6],
      ["8840", "\u5712", 9, "\u571D\u571E\u5720\u5721\u5722\u5724\u5725\u5726\u5727\u572B\u5731\u5732\u5734", 4, "\u573C\u573D\u573F\u5741\u5743\u5744\u5745\u5746\u5748\u5749\u574B\u5752", 4, "\u5758\u5759\u5762\u5763\u5765\u5767\u576C\u576E\u5770\u5771\u5772\u5774\u5775\u5778\u5779\u577A\u577D\u577E\u577F\u5780"],
      ["8880", "\u5781\u5787\u5788\u5789\u578A\u578D", 4, "\u5794", 6, "\u579C\u579D\u579E\u579F\u57A5\u57A8\u57AA\u57AC\u57AF\u57B0\u57B1\u57B3\u57B5\u57B6\u57B7\u57B9", 8, "\u57C4", 6, "\u57CC\u57CD\u57D0\u57D1\u57D3\u57D6\u57D7\u57DB\u57DC\u57DE\u57E1\u57E2\u57E3\u57E5", 7, "\u57EE\u57F0\u57F1\u57F2\u57F3\u57F5\u57F6\u57F7\u57FB\u57FC\u57FE\u57FF\u5801\u5803\u5804\u5805\u5808\u5809\u580A\u580C\u580E\u580F\u5810\u5812\u5813\u5814\u5816\u5817\u5818\u581A\u581B\u581C\u581D\u581F\u5822\u5823\u5825", 4, "\u582B", 4, "\u5831\u5832\u5833\u5834\u5836", 7],
      ["8940", "\u583E", 5, "\u5845", 6, "\u584E\u584F\u5850\u5852\u5853\u5855\u5856\u5857\u5859", 4, "\u585F", 5, "\u5866", 4, "\u586D", 16, "\u587F\u5882\u5884\u5886\u5887\u5888\u588A\u588B\u588C"],
      ["8980", "\u588D", 4, "\u5894", 4, "\u589B\u589C\u589D\u58A0", 7, "\u58AA", 17, "\u58BD\u58BE\u58BF\u58C0\u58C2\u58C3\u58C4\u58C6", 10, "\u58D2\u58D3\u58D4\u58D6", 13, "\u58E5", 5, "\u58ED\u58EF\u58F1\u58F2\u58F4\u58F5\u58F7\u58F8\u58FA", 7, "\u5903\u5905\u5906\u5908", 4, "\u590E\u5910\u5911\u5912\u5913\u5917\u5918\u591B\u591D\u591E\u5920\u5921\u5922\u5923\u5926\u5928\u592C\u5930\u5932\u5933\u5935\u5936\u593B"],
      ["8a40", "\u593D\u593E\u593F\u5940\u5943\u5945\u5946\u594A\u594C\u594D\u5950\u5952\u5953\u5959\u595B", 4, "\u5961\u5963\u5964\u5966", 12, "\u5975\u5977\u597A\u597B\u597C\u597E\u597F\u5980\u5985\u5989\u598B\u598C\u598E\u598F\u5990\u5991\u5994\u5995\u5998\u599A\u599B\u599C\u599D\u599F\u59A0\u59A1\u59A2\u59A6"],
      ["8a80", "\u59A7\u59AC\u59AD\u59B0\u59B1\u59B3", 5, "\u59BA\u59BC\u59BD\u59BF", 6, "\u59C7\u59C8\u59C9\u59CC\u59CD\u59CE\u59CF\u59D5\u59D6\u59D9\u59DB\u59DE", 4, "\u59E4\u59E6\u59E7\u59E9\u59EA\u59EB\u59ED", 11, "\u59FA\u59FC\u59FD\u59FE\u5A00\u5A02\u5A0A\u5A0B\u5A0D\u5A0E\u5A0F\u5A10\u5A12\u5A14\u5A15\u5A16\u5A17\u5A19\u5A1A\u5A1B\u5A1D\u5A1E\u5A21\u5A22\u5A24\u5A26\u5A27\u5A28\u5A2A", 6, "\u5A33\u5A35\u5A37", 4, "\u5A3D\u5A3E\u5A3F\u5A41", 4, "\u5A47\u5A48\u5A4B", 9, "\u5A56\u5A57\u5A58\u5A59\u5A5B", 5],
      ["8b40", "\u5A61\u5A63\u5A64\u5A65\u5A66\u5A68\u5A69\u5A6B", 8, "\u5A78\u5A79\u5A7B\u5A7C\u5A7D\u5A7E\u5A80", 17, "\u5A93", 6, "\u5A9C", 13, "\u5AAB\u5AAC"],
      ["8b80", "\u5AAD", 4, "\u5AB4\u5AB6\u5AB7\u5AB9", 4, "\u5ABF\u5AC0\u5AC3", 5, "\u5ACA\u5ACB\u5ACD", 4, "\u5AD3\u5AD5\u5AD7\u5AD9\u5ADA\u5ADB\u5ADD\u5ADE\u5ADF\u5AE2\u5AE4\u5AE5\u5AE7\u5AE8\u5AEA\u5AEC", 4, "\u5AF2", 22, "\u5B0A", 11, "\u5B18", 25, "\u5B33\u5B35\u5B36\u5B38", 7, "\u5B41", 6],
      ["8c40", "\u5B48", 7, "\u5B52\u5B56\u5B5E\u5B60\u5B61\u5B67\u5B68\u5B6B\u5B6D\u5B6E\u5B6F\u5B72\u5B74\u5B76\u5B77\u5B78\u5B79\u5B7B\u5B7C\u5B7E\u5B7F\u5B82\u5B86\u5B8A\u5B8D\u5B8E\u5B90\u5B91\u5B92\u5B94\u5B96\u5B9F\u5BA7\u5BA8\u5BA9\u5BAC\u5BAD\u5BAE\u5BAF\u5BB1\u5BB2\u5BB7\u5BBA\u5BBB\u5BBC\u5BC0\u5BC1\u5BC3\u5BC8\u5BC9\u5BCA\u5BCB\u5BCD\u5BCE\u5BCF"],
      ["8c80", "\u5BD1\u5BD4", 8, "\u5BE0\u5BE2\u5BE3\u5BE6\u5BE7\u5BE9", 4, "\u5BEF\u5BF1", 6, "\u5BFD\u5BFE\u5C00\u5C02\u5C03\u5C05\u5C07\u5C08\u5C0B\u5C0C\u5C0D\u5C0E\u5C10\u5C12\u5C13\u5C17\u5C19\u5C1B\u5C1E\u5C1F\u5C20\u5C21\u5C23\u5C26\u5C28\u5C29\u5C2A\u5C2B\u5C2D\u5C2E\u5C2F\u5C30\u5C32\u5C33\u5C35\u5C36\u5C37\u5C43\u5C44\u5C46\u5C47\u5C4C\u5C4D\u5C52\u5C53\u5C54\u5C56\u5C57\u5C58\u5C5A\u5C5B\u5C5C\u5C5D\u5C5F\u5C62\u5C64\u5C67", 6, "\u5C70\u5C72", 6, "\u5C7B\u5C7C\u5C7D\u5C7E\u5C80\u5C83", 4, "\u5C89\u5C8A\u5C8B\u5C8E\u5C8F\u5C92\u5C93\u5C95\u5C9D", 4, "\u5CA4", 4],
      ["8d40", "\u5CAA\u5CAE\u5CAF\u5CB0\u5CB2\u5CB4\u5CB6\u5CB9\u5CBA\u5CBB\u5CBC\u5CBE\u5CC0\u5CC2\u5CC3\u5CC5", 5, "\u5CCC", 5, "\u5CD3", 5, "\u5CDA", 6, "\u5CE2\u5CE3\u5CE7\u5CE9\u5CEB\u5CEC\u5CEE\u5CEF\u5CF1", 9, "\u5CFC", 4],
      ["8d80", "\u5D01\u5D04\u5D05\u5D08", 5, "\u5D0F", 4, "\u5D15\u5D17\u5D18\u5D19\u5D1A\u5D1C\u5D1D\u5D1F", 4, "\u5D25\u5D28\u5D2A\u5D2B\u5D2C\u5D2F", 4, "\u5D35", 7, "\u5D3F", 7, "\u5D48\u5D49\u5D4D", 10, "\u5D59\u5D5A\u5D5C\u5D5E", 10, "\u5D6A\u5D6D\u5D6E\u5D70\u5D71\u5D72\u5D73\u5D75", 12, "\u5D83", 21, "\u5D9A\u5D9B\u5D9C\u5D9E\u5D9F\u5DA0"],
      ["8e40", "\u5DA1", 21, "\u5DB8", 12, "\u5DC6", 6, "\u5DCE", 12, "\u5DDC\u5DDF\u5DE0\u5DE3\u5DE4\u5DEA\u5DEC\u5DED"],
      ["8e80", "\u5DF0\u5DF5\u5DF6\u5DF8", 4, "\u5DFF\u5E00\u5E04\u5E07\u5E09\u5E0A\u5E0B\u5E0D\u5E0E\u5E12\u5E13\u5E17\u5E1E", 7, "\u5E28", 4, "\u5E2F\u5E30\u5E32", 4, "\u5E39\u5E3A\u5E3E\u5E3F\u5E40\u5E41\u5E43\u5E46", 5, "\u5E4D", 6, "\u5E56", 4, "\u5E5C\u5E5D\u5E5F\u5E60\u5E63", 14, "\u5E75\u5E77\u5E79\u5E7E\u5E81\u5E82\u5E83\u5E85\u5E88\u5E89\u5E8C\u5E8D\u5E8E\u5E92\u5E98\u5E9B\u5E9D\u5EA1\u5EA2\u5EA3\u5EA4\u5EA8", 4, "\u5EAE", 4, "\u5EB4\u5EBA\u5EBB\u5EBC\u5EBD\u5EBF", 6],
      ["8f40", "\u5EC6\u5EC7\u5EC8\u5ECB", 5, "\u5ED4\u5ED5\u5ED7\u5ED8\u5ED9\u5EDA\u5EDC", 11, "\u5EE9\u5EEB", 8, "\u5EF5\u5EF8\u5EF9\u5EFB\u5EFC\u5EFD\u5F05\u5F06\u5F07\u5F09\u5F0C\u5F0D\u5F0E\u5F10\u5F12\u5F14\u5F16\u5F19\u5F1A\u5F1C\u5F1D\u5F1E\u5F21\u5F22\u5F23\u5F24"],
      ["8f80", "\u5F28\u5F2B\u5F2C\u5F2E\u5F30\u5F32", 6, "\u5F3B\u5F3D\u5F3E\u5F3F\u5F41", 14, "\u5F51\u5F54\u5F59\u5F5A\u5F5B\u5F5C\u5F5E\u5F5F\u5F60\u5F63\u5F65\u5F67\u5F68\u5F6B\u5F6E\u5F6F\u5F72\u5F74\u5F75\u5F76\u5F78\u5F7A\u5F7D\u5F7E\u5F7F\u5F83\u5F86\u5F8D\u5F8E\u5F8F\u5F91\u5F93\u5F94\u5F96\u5F9A\u5F9B\u5F9D\u5F9E\u5F9F\u5FA0\u5FA2", 5, "\u5FA9\u5FAB\u5FAC\u5FAF", 5, "\u5FB6\u5FB8\u5FB9\u5FBA\u5FBB\u5FBE", 4, "\u5FC7\u5FC8\u5FCA\u5FCB\u5FCE\u5FD3\u5FD4\u5FD5\u5FDA\u5FDB\u5FDC\u5FDE\u5FDF\u5FE2\u5FE3\u5FE5\u5FE6\u5FE8\u5FE9\u5FEC\u5FEF\u5FF0\u5FF2\u5FF3\u5FF4\u5FF6\u5FF7\u5FF9\u5FFA\u5FFC\u6007"],
      ["9040", "\u6008\u6009\u600B\u600C\u6010\u6011\u6013\u6017\u6018\u601A\u601E\u601F\u6022\u6023\u6024\u602C\u602D\u602E\u6030", 4, "\u6036", 4, "\u603D\u603E\u6040\u6044", 6, "\u604C\u604E\u604F\u6051\u6053\u6054\u6056\u6057\u6058\u605B\u605C\u605E\u605F\u6060\u6061\u6065\u6066\u606E\u6071\u6072\u6074\u6075\u6077\u607E\u6080"],
      ["9080", "\u6081\u6082\u6085\u6086\u6087\u6088\u608A\u608B\u608E\u608F\u6090\u6091\u6093\u6095\u6097\u6098\u6099\u609C\u609E\u60A1\u60A2\u60A4\u60A5\u60A7\u60A9\u60AA\u60AE\u60B0\u60B3\u60B5\u60B6\u60B7\u60B9\u60BA\u60BD", 7, "\u60C7\u60C8\u60C9\u60CC", 4, "\u60D2\u60D3\u60D4\u60D6\u60D7\u60D9\u60DB\u60DE\u60E1", 4, "\u60EA\u60F1\u60F2\u60F5\u60F7\u60F8\u60FB", 4, "\u6102\u6103\u6104\u6105\u6107\u610A\u610B\u610C\u6110", 4, "\u6116\u6117\u6118\u6119\u611B\u611C\u611D\u611E\u6121\u6122\u6125\u6128\u6129\u612A\u612C", 18, "\u6140", 6],
      ["9140", "\u6147\u6149\u614B\u614D\u614F\u6150\u6152\u6153\u6154\u6156", 6, "\u615E\u615F\u6160\u6161\u6163\u6164\u6165\u6166\u6169", 6, "\u6171\u6172\u6173\u6174\u6176\u6178", 18, "\u618C\u618D\u618F", 4, "\u6195"],
      ["9180", "\u6196", 6, "\u619E", 8, "\u61AA\u61AB\u61AD", 9, "\u61B8", 5, "\u61BF\u61C0\u61C1\u61C3", 4, "\u61C9\u61CC", 4, "\u61D3\u61D5", 16, "\u61E7", 13, "\u61F6", 8, "\u6200", 5, "\u6207\u6209\u6213\u6214\u6219\u621C\u621D\u621E\u6220\u6223\u6226\u6227\u6228\u6229\u622B\u622D\u622F\u6230\u6231\u6232\u6235\u6236\u6238", 4, "\u6242\u6244\u6245\u6246\u624A"],
      ["9240", "\u624F\u6250\u6255\u6256\u6257\u6259\u625A\u625C", 6, "\u6264\u6265\u6268\u6271\u6272\u6274\u6275\u6277\u6278\u627A\u627B\u627D\u6281\u6282\u6283\u6285\u6286\u6287\u6288\u628B", 5, "\u6294\u6299\u629C\u629D\u629E\u62A3\u62A6\u62A7\u62A9\u62AA\u62AD\u62AE\u62AF\u62B0\u62B2\u62B3\u62B4\u62B6\u62B7\u62B8\u62BA\u62BE\u62C0\u62C1"],
      ["9280", "\u62C3\u62CB\u62CF\u62D1\u62D5\u62DD\u62DE\u62E0\u62E1\u62E4\u62EA\u62EB\u62F0\u62F2\u62F5\u62F8\u62F9\u62FA\u62FB\u6300\u6303\u6304\u6305\u6306\u630A\u630B\u630C\u630D\u630F\u6310\u6312\u6313\u6314\u6315\u6317\u6318\u6319\u631C\u6326\u6327\u6329\u632C\u632D\u632E\u6330\u6331\u6333", 5, "\u633B\u633C\u633E\u633F\u6340\u6341\u6344\u6347\u6348\u634A\u6351\u6352\u6353\u6354\u6356", 7, "\u6360\u6364\u6365\u6366\u6368\u636A\u636B\u636C\u636F\u6370\u6372\u6373\u6374\u6375\u6378\u6379\u637C\u637D\u637E\u637F\u6381\u6383\u6384\u6385\u6386\u638B\u638D\u6391\u6393\u6394\u6395\u6397\u6399", 6, "\u63A1\u63A4\u63A6\u63AB\u63AF\u63B1\u63B2\u63B5\u63B6\u63B9\u63BB\u63BD\u63BF\u63C0"],
      ["9340", "\u63C1\u63C2\u63C3\u63C5\u63C7\u63C8\u63CA\u63CB\u63CC\u63D1\u63D3\u63D4\u63D5\u63D7", 6, "\u63DF\u63E2\u63E4", 4, "\u63EB\u63EC\u63EE\u63EF\u63F0\u63F1\u63F3\u63F5\u63F7\u63F9\u63FA\u63FB\u63FC\u63FE\u6403\u6404\u6406", 4, "\u640D\u640E\u6411\u6412\u6415", 5, "\u641D\u641F\u6422\u6423\u6424"],
      ["9380", "\u6425\u6427\u6428\u6429\u642B\u642E", 5, "\u6435", 4, "\u643B\u643C\u643E\u6440\u6442\u6443\u6449\u644B", 6, "\u6453\u6455\u6456\u6457\u6459", 4, "\u645F", 7, "\u6468\u646A\u646B\u646C\u646E", 9, "\u647B", 6, "\u6483\u6486\u6488", 8, "\u6493\u6494\u6497\u6498\u649A\u649B\u649C\u649D\u649F", 4, "\u64A5\u64A6\u64A7\u64A8\u64AA\u64AB\u64AF\u64B1\u64B2\u64B3\u64B4\u64B6\u64B9\u64BB\u64BD\u64BE\u64BF\u64C1\u64C3\u64C4\u64C6", 6, "\u64CF\u64D1\u64D3\u64D4\u64D5\u64D6\u64D9\u64DA"],
      ["9440", "\u64DB\u64DC\u64DD\u64DF\u64E0\u64E1\u64E3\u64E5\u64E7", 24, "\u6501", 7, "\u650A", 7, "\u6513", 4, "\u6519", 8],
      ["9480", "\u6522\u6523\u6524\u6526", 4, "\u652C\u652D\u6530\u6531\u6532\u6533\u6537\u653A\u653C\u653D\u6540", 4, "\u6546\u6547\u654A\u654B\u654D\u654E\u6550\u6552\u6553\u6554\u6557\u6558\u655A\u655C\u655F\u6560\u6561\u6564\u6565\u6567\u6568\u6569\u656A\u656D\u656E\u656F\u6571\u6573\u6575\u6576\u6578", 14, "\u6588\u6589\u658A\u658D\u658E\u658F\u6592\u6594\u6595\u6596\u6598\u659A\u659D\u659E\u65A0\u65A2\u65A3\u65A6\u65A8\u65AA\u65AC\u65AE\u65B1", 7, "\u65BA\u65BB\u65BE\u65BF\u65C0\u65C2\u65C7\u65C8\u65C9\u65CA\u65CD\u65D0\u65D1\u65D3\u65D4\u65D5\u65D8", 7, "\u65E1\u65E3\u65E4\u65EA\u65EB"],
      ["9540", "\u65F2\u65F3\u65F4\u65F5\u65F8\u65F9\u65FB", 4, "\u6601\u6604\u6605\u6607\u6608\u6609\u660B\u660D\u6610\u6611\u6612\u6616\u6617\u6618\u661A\u661B\u661C\u661E\u6621\u6622\u6623\u6624\u6626\u6629\u662A\u662B\u662C\u662E\u6630\u6632\u6633\u6637", 4, "\u663D\u663F\u6640\u6642\u6644", 6, "\u664D\u664E\u6650\u6651\u6658"],
      ["9580", "\u6659\u665B\u665C\u665D\u665E\u6660\u6662\u6663\u6665\u6667\u6669", 4, "\u6671\u6672\u6673\u6675\u6678\u6679\u667B\u667C\u667D\u667F\u6680\u6681\u6683\u6685\u6686\u6688\u6689\u668A\u668B\u668D\u668E\u668F\u6690\u6692\u6693\u6694\u6695\u6698", 4, "\u669E", 8, "\u66A9", 4, "\u66AF", 4, "\u66B5\u66B6\u66B7\u66B8\u66BA\u66BB\u66BC\u66BD\u66BF", 25, "\u66DA\u66DE", 7, "\u66E7\u66E8\u66EA", 5, "\u66F1\u66F5\u66F6\u66F8\u66FA\u66FB\u66FD\u6701\u6702\u6703"],
      ["9640", "\u6704\u6705\u6706\u6707\u670C\u670E\u670F\u6711\u6712\u6713\u6716\u6718\u6719\u671A\u671C\u671E\u6720", 5, "\u6727\u6729\u672E\u6730\u6732\u6733\u6736\u6737\u6738\u6739\u673B\u673C\u673E\u673F\u6741\u6744\u6745\u6747\u674A\u674B\u674D\u6752\u6754\u6755\u6757", 4, "\u675D\u6762\u6763\u6764\u6766\u6767\u676B\u676C\u676E\u6771\u6774\u6776"],
      ["9680", "\u6778\u6779\u677A\u677B\u677D\u6780\u6782\u6783\u6785\u6786\u6788\u678A\u678C\u678D\u678E\u678F\u6791\u6792\u6793\u6794\u6796\u6799\u679B\u679F\u67A0\u67A1\u67A4\u67A6\u67A9\u67AC\u67AE\u67B1\u67B2\u67B4\u67B9", 7, "\u67C2\u67C5", 9, "\u67D5\u67D6\u67D7\u67DB\u67DF\u67E1\u67E3\u67E4\u67E6\u67E7\u67E8\u67EA\u67EB\u67ED\u67EE\u67F2\u67F5", 7, "\u67FE\u6801\u6802\u6803\u6804\u6806\u680D\u6810\u6812\u6814\u6815\u6818", 4, "\u681E\u681F\u6820\u6822", 6, "\u682B", 6, "\u6834\u6835\u6836\u683A\u683B\u683F\u6847\u684B\u684D\u684F\u6852\u6856", 5],
      ["9740", "\u685C\u685D\u685E\u685F\u686A\u686C", 7, "\u6875\u6878", 8, "\u6882\u6884\u6887", 7, "\u6890\u6891\u6892\u6894\u6895\u6896\u6898", 9, "\u68A3\u68A4\u68A5\u68A9\u68AA\u68AB\u68AC\u68AE\u68B1\u68B2\u68B4\u68B6\u68B7\u68B8"],
      ["9780", "\u68B9", 6, "\u68C1\u68C3", 5, "\u68CA\u68CC\u68CE\u68CF\u68D0\u68D1\u68D3\u68D4\u68D6\u68D7\u68D9\u68DB", 4, "\u68E1\u68E2\u68E4", 9, "\u68EF\u68F2\u68F3\u68F4\u68F6\u68F7\u68F8\u68FB\u68FD\u68FE\u68FF\u6900\u6902\u6903\u6904\u6906", 4, "\u690C\u690F\u6911\u6913", 11, "\u6921\u6922\u6923\u6925", 7, "\u692E\u692F\u6931\u6932\u6933\u6935\u6936\u6937\u6938\u693A\u693B\u693C\u693E\u6940\u6941\u6943", 16, "\u6955\u6956\u6958\u6959\u695B\u695C\u695F"],
      ["9840", "\u6961\u6962\u6964\u6965\u6967\u6968\u6969\u696A\u696C\u696D\u696F\u6970\u6972", 4, "\u697A\u697B\u697D\u697E\u697F\u6981\u6983\u6985\u698A\u698B\u698C\u698E", 5, "\u6996\u6997\u6999\u699A\u699D", 9, "\u69A9\u69AA\u69AC\u69AE\u69AF\u69B0\u69B2\u69B3\u69B5\u69B6\u69B8\u69B9\u69BA\u69BC\u69BD"],
      ["9880", "\u69BE\u69BF\u69C0\u69C2", 7, "\u69CB\u69CD\u69CF\u69D1\u69D2\u69D3\u69D5", 5, "\u69DC\u69DD\u69DE\u69E1", 11, "\u69EE\u69EF\u69F0\u69F1\u69F3", 9, "\u69FE\u6A00", 9, "\u6A0B", 11, "\u6A19", 5, "\u6A20\u6A22", 5, "\u6A29\u6A2B\u6A2C\u6A2D\u6A2E\u6A30\u6A32\u6A33\u6A34\u6A36", 6, "\u6A3F", 4, "\u6A45\u6A46\u6A48", 7, "\u6A51", 6, "\u6A5A"],
      ["9940", "\u6A5C", 4, "\u6A62\u6A63\u6A64\u6A66", 10, "\u6A72", 6, "\u6A7A\u6A7B\u6A7D\u6A7E\u6A7F\u6A81\u6A82\u6A83\u6A85", 8, "\u6A8F\u6A92", 4, "\u6A98", 7, "\u6AA1", 5],
      ["9980", "\u6AA7\u6AA8\u6AAA\u6AAD", 114, "\u6B25\u6B26\u6B28", 6],
      ["9a40", "\u6B2F\u6B30\u6B31\u6B33\u6B34\u6B35\u6B36\u6B38\u6B3B\u6B3C\u6B3D\u6B3F\u6B40\u6B41\u6B42\u6B44\u6B45\u6B48\u6B4A\u6B4B\u6B4D", 11, "\u6B5A", 7, "\u6B68\u6B69\u6B6B", 13, "\u6B7A\u6B7D\u6B7E\u6B7F\u6B80\u6B85\u6B88"],
      ["9a80", "\u6B8C\u6B8E\u6B8F\u6B90\u6B91\u6B94\u6B95\u6B97\u6B98\u6B99\u6B9C", 4, "\u6BA2", 7, "\u6BAB", 7, "\u6BB6\u6BB8", 6, "\u6BC0\u6BC3\u6BC4\u6BC6", 4, "\u6BCC\u6BCE\u6BD0\u6BD1\u6BD8\u6BDA\u6BDC", 4, "\u6BE2", 7, "\u6BEC\u6BED\u6BEE\u6BF0\u6BF1\u6BF2\u6BF4\u6BF6\u6BF7\u6BF8\u6BFA\u6BFB\u6BFC\u6BFE", 6, "\u6C08", 4, "\u6C0E\u6C12\u6C17\u6C1C\u6C1D\u6C1E\u6C20\u6C23\u6C25\u6C2B\u6C2C\u6C2D\u6C31\u6C33\u6C36\u6C37\u6C39\u6C3A\u6C3B\u6C3C\u6C3E\u6C3F\u6C43\u6C44\u6C45\u6C48\u6C4B", 4, "\u6C51\u6C52\u6C53\u6C56\u6C58"],
      ["9b40", "\u6C59\u6C5A\u6C62\u6C63\u6C65\u6C66\u6C67\u6C6B", 4, "\u6C71\u6C73\u6C75\u6C77\u6C78\u6C7A\u6C7B\u6C7C\u6C7F\u6C80\u6C84\u6C87\u6C8A\u6C8B\u6C8D\u6C8E\u6C91\u6C92\u6C95\u6C96\u6C97\u6C98\u6C9A\u6C9C\u6C9D\u6C9E\u6CA0\u6CA2\u6CA8\u6CAC\u6CAF\u6CB0\u6CB4\u6CB5\u6CB6\u6CB7\u6CBA\u6CC0\u6CC1\u6CC2\u6CC3\u6CC6\u6CC7\u6CC8\u6CCB\u6CCD\u6CCE\u6CCF\u6CD1\u6CD2\u6CD8"],
      ["9b80", "\u6CD9\u6CDA\u6CDC\u6CDD\u6CDF\u6CE4\u6CE6\u6CE7\u6CE9\u6CEC\u6CED\u6CF2\u6CF4\u6CF9\u6CFF\u6D00\u6D02\u6D03\u6D05\u6D06\u6D08\u6D09\u6D0A\u6D0D\u6D0F\u6D10\u6D11\u6D13\u6D14\u6D15\u6D16\u6D18\u6D1C\u6D1D\u6D1F", 5, "\u6D26\u6D28\u6D29\u6D2C\u6D2D\u6D2F\u6D30\u6D34\u6D36\u6D37\u6D38\u6D3A\u6D3F\u6D40\u6D42\u6D44\u6D49\u6D4C\u6D50\u6D55\u6D56\u6D57\u6D58\u6D5B\u6D5D\u6D5F\u6D61\u6D62\u6D64\u6D65\u6D67\u6D68\u6D6B\u6D6C\u6D6D\u6D70\u6D71\u6D72\u6D73\u6D75\u6D76\u6D79\u6D7A\u6D7B\u6D7D", 4, "\u6D83\u6D84\u6D86\u6D87\u6D8A\u6D8B\u6D8D\u6D8F\u6D90\u6D92\u6D96", 4, "\u6D9C\u6DA2\u6DA5\u6DAC\u6DAD\u6DB0\u6DB1\u6DB3\u6DB4\u6DB6\u6DB7\u6DB9", 5, "\u6DC1\u6DC2\u6DC3\u6DC8\u6DC9\u6DCA"],
      ["9c40", "\u6DCD\u6DCE\u6DCF\u6DD0\u6DD2\u6DD3\u6DD4\u6DD5\u6DD7\u6DDA\u6DDB\u6DDC\u6DDF\u6DE2\u6DE3\u6DE5\u6DE7\u6DE8\u6DE9\u6DEA\u6DED\u6DEF\u6DF0\u6DF2\u6DF4\u6DF5\u6DF6\u6DF8\u6DFA\u6DFD", 7, "\u6E06\u6E07\u6E08\u6E09\u6E0B\u6E0F\u6E12\u6E13\u6E15\u6E18\u6E19\u6E1B\u6E1C\u6E1E\u6E1F\u6E22\u6E26\u6E27\u6E28\u6E2A\u6E2C\u6E2E\u6E30\u6E31\u6E33\u6E35"],
      ["9c80", "\u6E36\u6E37\u6E39\u6E3B", 7, "\u6E45", 7, "\u6E4F\u6E50\u6E51\u6E52\u6E55\u6E57\u6E59\u6E5A\u6E5C\u6E5D\u6E5E\u6E60", 10, "\u6E6C\u6E6D\u6E6F", 14, "\u6E80\u6E81\u6E82\u6E84\u6E87\u6E88\u6E8A", 4, "\u6E91", 6, "\u6E99\u6E9A\u6E9B\u6E9D\u6E9E\u6EA0\u6EA1\u6EA3\u6EA4\u6EA6\u6EA8\u6EA9\u6EAB\u6EAC\u6EAD\u6EAE\u6EB0\u6EB3\u6EB5\u6EB8\u6EB9\u6EBC\u6EBE\u6EBF\u6EC0\u6EC3\u6EC4\u6EC5\u6EC6\u6EC8\u6EC9\u6ECA\u6ECC\u6ECD\u6ECE\u6ED0\u6ED2\u6ED6\u6ED8\u6ED9\u6EDB\u6EDC\u6EDD\u6EE3\u6EE7\u6EEA", 5],
      ["9d40", "\u6EF0\u6EF1\u6EF2\u6EF3\u6EF5\u6EF6\u6EF7\u6EF8\u6EFA", 7, "\u6F03\u6F04\u6F05\u6F07\u6F08\u6F0A", 4, "\u6F10\u6F11\u6F12\u6F16", 9, "\u6F21\u6F22\u6F23\u6F25\u6F26\u6F27\u6F28\u6F2C\u6F2E\u6F30\u6F32\u6F34\u6F35\u6F37", 6, "\u6F3F\u6F40\u6F41\u6F42"],
      ["9d80", "\u6F43\u6F44\u6F45\u6F48\u6F49\u6F4A\u6F4C\u6F4E", 9, "\u6F59\u6F5A\u6F5B\u6F5D\u6F5F\u6F60\u6F61\u6F63\u6F64\u6F65\u6F67", 5, "\u6F6F\u6F70\u6F71\u6F73\u6F75\u6F76\u6F77\u6F79\u6F7B\u6F7D", 6, "\u6F85\u6F86\u6F87\u6F8A\u6F8B\u6F8F", 12, "\u6F9D\u6F9E\u6F9F\u6FA0\u6FA2", 4, "\u6FA8", 10, "\u6FB4\u6FB5\u6FB7\u6FB8\u6FBA", 5, "\u6FC1\u6FC3", 5, "\u6FCA", 6, "\u6FD3", 10, "\u6FDF\u6FE2\u6FE3\u6FE4\u6FE5"],
      ["9e40", "\u6FE6", 7, "\u6FF0", 32, "\u7012", 7, "\u701C", 6, "\u7024", 6],
      ["9e80", "\u702B", 9, "\u7036\u7037\u7038\u703A", 17, "\u704D\u704E\u7050", 13, "\u705F", 11, "\u706E\u7071\u7072\u7073\u7074\u7077\u7079\u707A\u707B\u707D\u7081\u7082\u7083\u7084\u7086\u7087\u7088\u708B\u708C\u708D\u708F\u7090\u7091\u7093\u7097\u7098\u709A\u709B\u709E", 12, "\u70B0\u70B2\u70B4\u70B5\u70B6\u70BA\u70BE\u70BF\u70C4\u70C5\u70C6\u70C7\u70C9\u70CB", 12, "\u70DA"],
      ["9f40", "\u70DC\u70DD\u70DE\u70E0\u70E1\u70E2\u70E3\u70E5\u70EA\u70EE\u70F0", 6, "\u70F8\u70FA\u70FB\u70FC\u70FE", 10, "\u710B", 4, "\u7111\u7112\u7114\u7117\u711B", 10, "\u7127", 7, "\u7132\u7133\u7134"],
      ["9f80", "\u7135\u7137", 13, "\u7146\u7147\u7148\u7149\u714B\u714D\u714F", 12, "\u715D\u715F", 4, "\u7165\u7169", 4, "\u716F\u7170\u7171\u7174\u7175\u7176\u7177\u7179\u717B\u717C\u717E", 5, "\u7185", 4, "\u718B\u718C\u718D\u718E\u7190\u7191\u7192\u7193\u7195\u7196\u7197\u719A", 4, "\u71A1", 6, "\u71A9\u71AA\u71AB\u71AD", 5, "\u71B4\u71B6\u71B7\u71B8\u71BA", 8, "\u71C4", 9, "\u71CF", 4],
      ["a040", "\u71D6", 9, "\u71E1\u71E2\u71E3\u71E4\u71E6\u71E8", 5, "\u71EF", 9, "\u71FA", 11, "\u7207", 19],
      ["a080", "\u721B\u721C\u721E", 9, "\u7229\u722B\u722D\u722E\u722F\u7232\u7233\u7234\u723A\u723C\u723E\u7240", 6, "\u7249\u724A\u724B\u724E\u724F\u7250\u7251\u7253\u7254\u7255\u7257\u7258\u725A\u725C\u725E\u7260\u7263\u7264\u7265\u7268\u726A\u726B\u726C\u726D\u7270\u7271\u7273\u7274\u7276\u7277\u7278\u727B\u727C\u727D\u7282\u7283\u7285", 4, "\u728C\u728E\u7290\u7291\u7293", 11, "\u72A0", 11, "\u72AE\u72B1\u72B2\u72B3\u72B5\u72BA", 6, "\u72C5\u72C6\u72C7\u72C9\u72CA\u72CB\u72CC\u72CF\u72D1\u72D3\u72D4\u72D5\u72D6\u72D8\u72DA\u72DB"],
      ["a1a1", "\u3000\u3001\u3002\xB7\u02C9\u02C7\xA8\u3003\u3005\u2014\uFF5E\u2016\u2026\u2018\u2019\u201C\u201D\u3014\u3015\u3008", 7, "\u3016\u3017\u3010\u3011\xB1\xD7\xF7\u2236\u2227\u2228\u2211\u220F\u222A\u2229\u2208\u2237\u221A\u22A5\u2225\u2220\u2312\u2299\u222B\u222E\u2261\u224C\u2248\u223D\u221D\u2260\u226E\u226F\u2264\u2265\u221E\u2235\u2234\u2642\u2640\xB0\u2032\u2033\u2103\uFF04\xA4\uFFE0\uFFE1\u2030\xA7\u2116\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u203B\u2192\u2190\u2191\u2193\u3013"],
      ["a2a1", "\u2170", 9],
      ["a2b1", "\u2488", 19, "\u2474", 19, "\u2460", 9],
      ["a2e5", "\u3220", 9],
      ["a2f1", "\u2160", 11],
      ["a3a1", "\uFF01\uFF02\uFF03\uFFE5\uFF05", 88, "\uFFE3"],
      ["a4a1", "\u3041", 82],
      ["a5a1", "\u30A1", 85],
      ["a6a1", "\u0391", 16, "\u03A3", 6],
      ["a6c1", "\u03B1", 16, "\u03C3", 6],
      ["a6e0", "\uFE35\uFE36\uFE39\uFE3A\uFE3F\uFE40\uFE3D\uFE3E\uFE41\uFE42\uFE43\uFE44"],
      ["a6ee", "\uFE3B\uFE3C\uFE37\uFE38\uFE31"],
      ["a6f4", "\uFE33\uFE34"],
      ["a7a1", "\u0410", 5, "\u0401\u0416", 25],
      ["a7d1", "\u0430", 5, "\u0451\u0436", 25],
      ["a840", "\u02CA\u02CB\u02D9\u2013\u2015\u2025\u2035\u2105\u2109\u2196\u2197\u2198\u2199\u2215\u221F\u2223\u2252\u2266\u2267\u22BF\u2550", 35, "\u2581", 6],
      ["a880", "\u2588", 7, "\u2593\u2594\u2595\u25BC\u25BD\u25E2\u25E3\u25E4\u25E5\u2609\u2295\u3012\u301D\u301E"],
      ["a8a1", "\u0101\xE1\u01CE\xE0\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA\u01DC\xFC\xEA\u0251"],
      ["a8bd", "\u0144\u0148"],
      ["a8c0", "\u0261"],
      ["a8c5", "\u3105", 36],
      ["a940", "\u3021", 8, "\u32A3\u338E\u338F\u339C\u339D\u339E\u33A1\u33C4\u33CE\u33D1\u33D2\u33D5\uFE30\uFFE2\uFFE4"],
      ["a959", "\u2121\u3231"],
      ["a95c", "\u2010"],
      ["a960", "\u30FC\u309B\u309C\u30FD\u30FE\u3006\u309D\u309E\uFE49", 9, "\uFE54\uFE55\uFE56\uFE57\uFE59", 8],
      ["a980", "\uFE62", 4, "\uFE68\uFE69\uFE6A\uFE6B"],
      ["a996", "\u3007"],
      ["a9a4", "\u2500", 75],
      ["aa40", "\u72DC\u72DD\u72DF\u72E2", 5, "\u72EA\u72EB\u72F5\u72F6\u72F9\u72FD\u72FE\u72FF\u7300\u7302\u7304", 5, "\u730B\u730C\u730D\u730F\u7310\u7311\u7312\u7314\u7318\u7319\u731A\u731F\u7320\u7323\u7324\u7326\u7327\u7328\u732D\u732F\u7330\u7332\u7333\u7335\u7336\u733A\u733B\u733C\u733D\u7340", 8],
      ["aa80", "\u7349\u734A\u734B\u734C\u734E\u734F\u7351\u7353\u7354\u7355\u7356\u7358", 7, "\u7361", 10, "\u736E\u7370\u7371"],
      ["ab40", "\u7372", 11, "\u737F", 4, "\u7385\u7386\u7388\u738A\u738C\u738D\u738F\u7390\u7392\u7393\u7394\u7395\u7397\u7398\u7399\u739A\u739C\u739D\u739E\u73A0\u73A1\u73A3", 5, "\u73AA\u73AC\u73AD\u73B1\u73B4\u73B5\u73B6\u73B8\u73B9\u73BC\u73BD\u73BE\u73BF\u73C1\u73C3", 4],
      ["ab80", "\u73CB\u73CC\u73CE\u73D2", 6, "\u73DA\u73DB\u73DC\u73DD\u73DF\u73E1\u73E2\u73E3\u73E4\u73E6\u73E8\u73EA\u73EB\u73EC\u73EE\u73EF\u73F0\u73F1\u73F3", 4],
      ["ac40", "\u73F8", 10, "\u7404\u7407\u7408\u740B\u740C\u740D\u740E\u7411", 8, "\u741C", 5, "\u7423\u7424\u7427\u7429\u742B\u742D\u742F\u7431\u7432\u7437", 4, "\u743D\u743E\u743F\u7440\u7442", 11],
      ["ac80", "\u744E", 6, "\u7456\u7458\u745D\u7460", 12, "\u746E\u746F\u7471", 4, "\u7478\u7479\u747A"],
      ["ad40", "\u747B\u747C\u747D\u747F\u7482\u7484\u7485\u7486\u7488\u7489\u748A\u748C\u748D\u748F\u7491", 10, "\u749D\u749F", 7, "\u74AA", 15, "\u74BB", 12],
      ["ad80", "\u74C8", 9, "\u74D3", 8, "\u74DD\u74DF\u74E1\u74E5\u74E7", 6, "\u74F0\u74F1\u74F2"],
      ["ae40", "\u74F3\u74F5\u74F8", 6, "\u7500\u7501\u7502\u7503\u7505", 7, "\u750E\u7510\u7512\u7514\u7515\u7516\u7517\u751B\u751D\u751E\u7520", 4, "\u7526\u7527\u752A\u752E\u7534\u7536\u7539\u753C\u753D\u753F\u7541\u7542\u7543\u7544\u7546\u7547\u7549\u754A\u754D\u7550\u7551\u7552\u7553\u7555\u7556\u7557\u7558"],
      ["ae80", "\u755D", 7, "\u7567\u7568\u7569\u756B", 6, "\u7573\u7575\u7576\u7577\u757A", 4, "\u7580\u7581\u7582\u7584\u7585\u7587"],
      ["af40", "\u7588\u7589\u758A\u758C\u758D\u758E\u7590\u7593\u7595\u7598\u759B\u759C\u759E\u75A2\u75A6", 4, "\u75AD\u75B6\u75B7\u75BA\u75BB\u75BF\u75C0\u75C1\u75C6\u75CB\u75CC\u75CE\u75CF\u75D0\u75D1\u75D3\u75D7\u75D9\u75DA\u75DC\u75DD\u75DF\u75E0\u75E1\u75E5\u75E9\u75EC\u75ED\u75EE\u75EF\u75F2\u75F3\u75F5\u75F6\u75F7\u75F8\u75FA\u75FB\u75FD\u75FE\u7602\u7604\u7606\u7607"],
      ["af80", "\u7608\u7609\u760B\u760D\u760E\u760F\u7611\u7612\u7613\u7614\u7616\u761A\u761C\u761D\u761E\u7621\u7623\u7627\u7628\u762C\u762E\u762F\u7631\u7632\u7636\u7637\u7639\u763A\u763B\u763D\u7641\u7642\u7644"],
      ["b040", "\u7645", 6, "\u764E", 5, "\u7655\u7657", 4, "\u765D\u765F\u7660\u7661\u7662\u7664", 6, "\u766C\u766D\u766E\u7670", 7, "\u7679\u767A\u767C\u767F\u7680\u7681\u7683\u7685\u7689\u768A\u768C\u768D\u768F\u7690\u7692\u7694\u7695\u7697\u7698\u769A\u769B"],
      ["b080", "\u769C", 7, "\u76A5", 8, "\u76AF\u76B0\u76B3\u76B5", 9, "\u76C0\u76C1\u76C3\u554A\u963F\u57C3\u6328\u54CE\u5509\u54C0\u7691\u764C\u853C\u77EE\u827E\u788D\u7231\u9698\u978D\u6C28\u5B89\u4FFA\u6309\u6697\u5CB8\u80FA\u6848\u80AE\u6602\u76CE\u51F9\u6556\u71AC\u7FF1\u8884\u50B2\u5965\u61CA\u6FB3\u82AD\u634C\u6252\u53ED\u5427\u7B06\u516B\u75A4\u5DF4\u62D4\u8DCB\u9776\u628A\u8019\u575D\u9738\u7F62\u7238\u767D\u67CF\u767E\u6446\u4F70\u8D25\u62DC\u7A17\u6591\u73ED\u642C\u6273\u822C\u9881\u677F\u7248\u626E\u62CC\u4F34\u74E3\u534A\u529E\u7ECA\u90A6\u5E2E\u6886\u699C\u8180\u7ED1\u68D2\u78C5\u868C\u9551\u508D\u8C24\u82DE\u80DE\u5305\u8912\u5265"],
      ["b140", "\u76C4\u76C7\u76C9\u76CB\u76CC\u76D3\u76D5\u76D9\u76DA\u76DC\u76DD\u76DE\u76E0", 4, "\u76E6", 7, "\u76F0\u76F3\u76F5\u76F6\u76F7\u76FA\u76FB\u76FD\u76FF\u7700\u7702\u7703\u7705\u7706\u770A\u770C\u770E", 10, "\u771B\u771C\u771D\u771E\u7721\u7723\u7724\u7725\u7727\u772A\u772B"],
      ["b180", "\u772C\u772E\u7730", 4, "\u7739\u773B\u773D\u773E\u773F\u7742\u7744\u7745\u7746\u7748", 7, "\u7752", 7, "\u775C\u8584\u96F9\u4FDD\u5821\u9971\u5B9D\u62B1\u62A5\u66B4\u8C79\u9C8D\u7206\u676F\u7891\u60B2\u5351\u5317\u8F88\u80CC\u8D1D\u94A1\u500D\u72C8\u5907\u60EB\u7119\u88AB\u5954\u82EF\u672C\u7B28\u5D29\u7EF7\u752D\u6CF5\u8E66\u8FF8\u903C\u9F3B\u6BD4\u9119\u7B14\u5F7C\u78A7\u84D6\u853D\u6BD5\u6BD9\u6BD6\u5E01\u5E87\u75F9\u95ED\u655D\u5F0A\u5FC5\u8F9F\u58C1\u81C2\u907F\u965B\u97AD\u8FB9\u7F16\u8D2C\u6241\u4FBF\u53D8\u535E\u8FA8\u8FA9\u8FAB\u904D\u6807\u5F6A\u8198\u8868\u9CD6\u618B\u522B\u762A\u5F6C\u658C\u6FD2\u6EE8\u5BBE\u6448\u5175\u51B0\u67C4\u4E19\u79C9\u997C\u70B3"],
      ["b240", "\u775D\u775E\u775F\u7760\u7764\u7767\u7769\u776A\u776D", 11, "\u777A\u777B\u777C\u7781\u7782\u7783\u7786", 5, "\u778F\u7790\u7793", 11, "\u77A1\u77A3\u77A4\u77A6\u77A8\u77AB\u77AD\u77AE\u77AF\u77B1\u77B2\u77B4\u77B6", 4],
      ["b280", "\u77BC\u77BE\u77C0", 12, "\u77CE", 8, "\u77D8\u77D9\u77DA\u77DD", 4, "\u77E4\u75C5\u5E76\u73BB\u83E0\u64AD\u62E8\u94B5\u6CE2\u535A\u52C3\u640F\u94C2\u7B94\u4F2F\u5E1B\u8236\u8116\u818A\u6E24\u6CCA\u9A73\u6355\u535C\u54FA\u8865\u57E0\u4E0D\u5E03\u6B65\u7C3F\u90E8\u6016\u64E6\u731C\u88C1\u6750\u624D\u8D22\u776C\u8E29\u91C7\u5F69\u83DC\u8521\u9910\u53C2\u8695\u6B8B\u60ED\u60E8\u707F\u82CD\u8231\u4ED3\u6CA7\u85CF\u64CD\u7CD9\u69FD\u66F9\u8349\u5395\u7B56\u4FA7\u518C\u6D4B\u5C42\u8E6D\u63D2\u53C9\u832C\u8336\u67E5\u78B4\u643D\u5BDF\u5C94\u5DEE\u8BE7\u62C6\u67F4\u8C7A\u6400\u63BA\u8749\u998B\u8C17\u7F20\u94F2\u4EA7\u9610\u98A4\u660C\u7316"],
      ["b340", "\u77E6\u77E8\u77EA\u77EF\u77F0\u77F1\u77F2\u77F4\u77F5\u77F7\u77F9\u77FA\u77FB\u77FC\u7803", 5, "\u780A\u780B\u780E\u780F\u7810\u7813\u7815\u7819\u781B\u781E\u7820\u7821\u7822\u7824\u7828\u782A\u782B\u782E\u782F\u7831\u7832\u7833\u7835\u7836\u783D\u783F\u7841\u7842\u7843\u7844\u7846\u7848\u7849\u784A\u784B\u784D\u784F\u7851\u7853\u7854\u7858\u7859\u785A"],
      ["b380", "\u785B\u785C\u785E", 11, "\u786F", 7, "\u7878\u7879\u787A\u787B\u787D", 6, "\u573A\u5C1D\u5E38\u957F\u507F\u80A0\u5382\u655E\u7545\u5531\u5021\u8D85\u6284\u949E\u671D\u5632\u6F6E\u5DE2\u5435\u7092\u8F66\u626F\u64A4\u63A3\u5F7B\u6F88\u90F4\u81E3\u8FB0\u5C18\u6668\u5FF1\u6C89\u9648\u8D81\u886C\u6491\u79F0\u57CE\u6A59\u6210\u5448\u4E58\u7A0B\u60E9\u6F84\u8BDA\u627F\u901E\u9A8B\u79E4\u5403\u75F4\u6301\u5319\u6C60\u8FDF\u5F1B\u9A70\u803B\u9F7F\u4F88\u5C3A\u8D64\u7FC5\u65A5\u70BD\u5145\u51B2\u866B\u5D07\u5BA0\u62BD\u916C\u7574\u8E0C\u7A20\u6101\u7B79\u4EC7\u7EF8\u7785\u4E11\u81ED\u521D\u51FA\u6A71\u53A8\u8E87\u9504\u96CF\u6EC1\u9664\u695A"],
      ["b440", "\u7884\u7885\u7886\u7888\u788A\u788B\u788F\u7890\u7892\u7894\u7895\u7896\u7899\u789D\u789E\u78A0\u78A2\u78A4\u78A6\u78A8", 7, "\u78B5\u78B6\u78B7\u78B8\u78BA\u78BB\u78BC\u78BD\u78BF\u78C0\u78C2\u78C3\u78C4\u78C6\u78C7\u78C8\u78CC\u78CD\u78CE\u78CF\u78D1\u78D2\u78D3\u78D6\u78D7\u78D8\u78DA", 9],
      ["b480", "\u78E4\u78E5\u78E6\u78E7\u78E9\u78EA\u78EB\u78ED", 4, "\u78F3\u78F5\u78F6\u78F8\u78F9\u78FB", 5, "\u7902\u7903\u7904\u7906", 6, "\u7840\u50A8\u77D7\u6410\u89E6\u5904\u63E3\u5DDD\u7A7F\u693D\u4F20\u8239\u5598\u4E32\u75AE\u7A97\u5E62\u5E8A\u95EF\u521B\u5439\u708A\u6376\u9524\u5782\u6625\u693F\u9187\u5507\u6DF3\u7EAF\u8822\u6233\u7EF0\u75B5\u8328\u78C1\u96CC\u8F9E\u6148\u74F7\u8BCD\u6B64\u523A\u8D50\u6B21\u806A\u8471\u56F1\u5306\u4ECE\u4E1B\u51D1\u7C97\u918B\u7C07\u4FC3\u8E7F\u7BE1\u7A9C\u6467\u5D14\u50AC\u8106\u7601\u7CB9\u6DEC\u7FE0\u6751\u5B58\u5BF8\u78CB\u64AE\u6413\u63AA\u632B\u9519\u642D\u8FBE\u7B54\u7629\u6253\u5927\u5446\u6B79\u50A3\u6234\u5E26\u6B86\u4EE3\u8D37\u888B\u5F85\u902E"],
      ["b540", "\u790D", 5, "\u7914", 9, "\u791F", 4, "\u7925", 14, "\u7935", 4, "\u793D\u793F\u7942\u7943\u7944\u7945\u7947\u794A", 8, "\u7954\u7955\u7958\u7959\u7961\u7963"],
      ["b580", "\u7964\u7966\u7969\u796A\u796B\u796C\u796E\u7970", 6, "\u7979\u797B", 4, "\u7982\u7983\u7986\u7987\u7988\u7989\u798B\u798C\u798D\u798E\u7990\u7991\u7992\u6020\u803D\u62C5\u4E39\u5355\u90F8\u63B8\u80C6\u65E6\u6C2E\u4F46\u60EE\u6DE1\u8BDE\u5F39\u86CB\u5F53\u6321\u515A\u8361\u6863\u5200\u6363\u8E48\u5012\u5C9B\u7977\u5BFC\u5230\u7A3B\u60BC\u9053\u76D7\u5FB7\u5F97\u7684\u8E6C\u706F\u767B\u7B49\u77AA\u51F3\u9093\u5824\u4F4E\u6EF4\u8FEA\u654C\u7B1B\u72C4\u6DA4\u7FDF\u5AE1\u62B5\u5E95\u5730\u8482\u7B2C\u5E1D\u5F1F\u9012\u7F14\u98A0\u6382\u6EC7\u7898\u70B9\u5178\u975B\u57AB\u7535\u4F43\u7538\u5E97\u60E6\u5960\u6DC0\u6BBF\u7889\u53FC\u96D5\u51CB\u5201\u6389\u540A\u9493\u8C03\u8DCC\u7239\u789F\u8776\u8FED\u8C0D\u53E0"],
      ["b640", "\u7993", 6, "\u799B", 11, "\u79A8", 10, "\u79B4", 4, "\u79BC\u79BF\u79C2\u79C4\u79C5\u79C7\u79C8\u79CA\u79CC\u79CE\u79CF\u79D0\u79D3\u79D4\u79D6\u79D7\u79D9", 5, "\u79E0\u79E1\u79E2\u79E5\u79E8\u79EA"],
      ["b680", "\u79EC\u79EE\u79F1", 6, "\u79F9\u79FA\u79FC\u79FE\u79FF\u7A01\u7A04\u7A05\u7A07\u7A08\u7A09\u7A0A\u7A0C\u7A0F", 4, "\u7A15\u7A16\u7A18\u7A19\u7A1B\u7A1C\u4E01\u76EF\u53EE\u9489\u9876\u9F0E\u952D\u5B9A\u8BA2\u4E22\u4E1C\u51AC\u8463\u61C2\u52A8\u680B\u4F97\u606B\u51BB\u6D1E\u515C\u6296\u6597\u9661\u8C46\u9017\u75D8\u90FD\u7763\u6BD2\u728A\u72EC\u8BFB\u5835\u7779\u8D4C\u675C\u9540\u809A\u5EA6\u6E21\u5992\u7AEF\u77ED\u953B\u6BB5\u65AD\u7F0E\u5806\u5151\u961F\u5BF9\u58A9\u5428\u8E72\u6566\u987F\u56E4\u949D\u76FE\u9041\u6387\u54C6\u591A\u593A\u579B\u8EB2\u6735\u8DFA\u8235\u5241\u60F0\u5815\u86FE\u5CE8\u9E45\u4FC4\u989D\u8BB9\u5A25\u6076\u5384\u627C\u904F\u9102\u997F\u6069\u800C\u513F\u8033\u5C14\u9975\u6D31\u4E8C"],
      ["b740", "\u7A1D\u7A1F\u7A21\u7A22\u7A24", 14, "\u7A34\u7A35\u7A36\u7A38\u7A3A\u7A3E\u7A40", 5, "\u7A47", 9, "\u7A52", 4, "\u7A58", 16],
      ["b780", "\u7A69", 6, "\u7A71\u7A72\u7A73\u7A75\u7A7B\u7A7C\u7A7D\u7A7E\u7A82\u7A85\u7A87\u7A89\u7A8A\u7A8B\u7A8C\u7A8E\u7A8F\u7A90\u7A93\u7A94\u7A99\u7A9A\u7A9B\u7A9E\u7AA1\u7AA2\u8D30\u53D1\u7F5A\u7B4F\u4F10\u4E4F\u9600\u6CD5\u73D0\u85E9\u5E06\u756A\u7FFB\u6A0A\u77FE\u9492\u7E41\u51E1\u70E6\u53CD\u8FD4\u8303\u8D29\u72AF\u996D\u6CDB\u574A\u82B3\u65B9\u80AA\u623F\u9632\u59A8\u4EFF\u8BBF\u7EBA\u653E\u83F2\u975E\u5561\u98DE\u80A5\u532A\u8BFD\u5420\u80BA\u5E9F\u6CB8\u8D39\u82AC\u915A\u5429\u6C1B\u5206\u7EB7\u575F\u711A\u6C7E\u7C89\u594B\u4EFD\u5FFF\u6124\u7CAA\u4E30\u5C01\u67AB\u8702\u5CF0\u950B\u98CE\u75AF\u70FD\u9022\u51AF\u7F1D\u8BBD\u5949\u51E4\u4F5B\u5426\u592B\u6577\u80A4\u5B75\u6276\u62C2\u8F90\u5E45\u6C1F\u7B26\u4F0F\u4FD8\u670D"],
      ["b840", "\u7AA3\u7AA4\u7AA7\u7AA9\u7AAA\u7AAB\u7AAE", 4, "\u7AB4", 10, "\u7AC0", 10, "\u7ACC", 9, "\u7AD7\u7AD8\u7ADA\u7ADB\u7ADC\u7ADD\u7AE1\u7AE2\u7AE4\u7AE7", 5, "\u7AEE\u7AF0\u7AF1\u7AF2\u7AF3"],
      ["b880", "\u7AF4", 4, "\u7AFB\u7AFC\u7AFE\u7B00\u7B01\u7B02\u7B05\u7B07\u7B09\u7B0C\u7B0D\u7B0E\u7B10\u7B12\u7B13\u7B16\u7B17\u7B18\u7B1A\u7B1C\u7B1D\u7B1F\u7B21\u7B22\u7B23\u7B27\u7B29\u7B2D\u6D6E\u6DAA\u798F\u88B1\u5F17\u752B\u629A\u8F85\u4FEF\u91DC\u65A7\u812F\u8151\u5E9C\u8150\u8D74\u526F\u8986\u8D4B\u590D\u5085\u4ED8\u961C\u7236\u8179\u8D1F\u5BCC\u8BA3\u9644\u5987\u7F1A\u5490\u5676\u560E\u8BE5\u6539\u6982\u9499\u76D6\u6E89\u5E72\u7518\u6746\u67D1\u7AFF\u809D\u8D76\u611F\u79C6\u6562\u8D63\u5188\u521A\u94A2\u7F38\u809B\u7EB2\u5C97\u6E2F\u6760\u7BD9\u768B\u9AD8\u818F\u7F94\u7CD5\u641E\u9550\u7A3F\u544A\u54E5\u6B4C\u6401\u6208\u9E3D\u80F3\u7599\u5272\u9769\u845B\u683C\u86E4\u9601\u9694\u94EC\u4E2A\u5404\u7ED9\u6839\u8DDF\u8015\u66F4\u5E9A\u7FB9"],
      ["b940", "\u7B2F\u7B30\u7B32\u7B34\u7B35\u7B36\u7B37\u7B39\u7B3B\u7B3D\u7B3F", 5, "\u7B46\u7B48\u7B4A\u7B4D\u7B4E\u7B53\u7B55\u7B57\u7B59\u7B5C\u7B5E\u7B5F\u7B61\u7B63", 10, "\u7B6F\u7B70\u7B73\u7B74\u7B76\u7B78\u7B7A\u7B7C\u7B7D\u7B7F\u7B81\u7B82\u7B83\u7B84\u7B86", 6, "\u7B8E\u7B8F"],
      ["b980", "\u7B91\u7B92\u7B93\u7B96\u7B98\u7B99\u7B9A\u7B9B\u7B9E\u7B9F\u7BA0\u7BA3\u7BA4\u7BA5\u7BAE\u7BAF\u7BB0\u7BB2\u7BB3\u7BB5\u7BB6\u7BB7\u7BB9", 7, "\u7BC2\u7BC3\u7BC4\u57C2\u803F\u6897\u5DE5\u653B\u529F\u606D\u9F9A\u4F9B\u8EAC\u516C\u5BAB\u5F13\u5DE9\u6C5E\u62F1\u8D21\u5171\u94A9\u52FE\u6C9F\u82DF\u72D7\u57A2\u6784\u8D2D\u591F\u8F9C\u83C7\u5495\u7B8D\u4F30\u6CBD\u5B64\u59D1\u9F13\u53E4\u86CA\u9AA8\u8C37\u80A1\u6545\u987E\u56FA\u96C7\u522E\u74DC\u5250\u5BE1\u6302\u8902\u4E56\u62D0\u602A\u68FA\u5173\u5B98\u51A0\u89C2\u7BA1\u9986\u7F50\u60EF\u704C\u8D2F\u5149\u5E7F\u901B\u7470\u89C4\u572D\u7845\u5F52\u9F9F\u95FA\u8F68\u9B3C\u8BE1\u7678\u6842\u67DC\u8DEA\u8D35\u523D\u8F8A\u6EDA\u68CD\u9505\u90ED\u56FD\u679C\u88F9\u8FC7\u54C8"],
      ["ba40", "\u7BC5\u7BC8\u7BC9\u7BCA\u7BCB\u7BCD\u7BCE\u7BCF\u7BD0\u7BD2\u7BD4", 4, "\u7BDB\u7BDC\u7BDE\u7BDF\u7BE0\u7BE2\u7BE3\u7BE4\u7BE7\u7BE8\u7BE9\u7BEB\u7BEC\u7BED\u7BEF\u7BF0\u7BF2", 4, "\u7BF8\u7BF9\u7BFA\u7BFB\u7BFD\u7BFF", 7, "\u7C08\u7C09\u7C0A\u7C0D\u7C0E\u7C10", 5, "\u7C17\u7C18\u7C19"],
      ["ba80", "\u7C1A", 4, "\u7C20", 5, "\u7C28\u7C29\u7C2B", 12, "\u7C39", 5, "\u7C42\u9AB8\u5B69\u6D77\u6C26\u4EA5\u5BB3\u9A87\u9163\u61A8\u90AF\u97E9\u542B\u6DB5\u5BD2\u51FD\u558A\u7F55\u7FF0\u64BC\u634D\u65F1\u61BE\u608D\u710A\u6C57\u6C49\u592F\u676D\u822A\u58D5\u568E\u8C6A\u6BEB\u90DD\u597D\u8017\u53F7\u6D69\u5475\u559D\u8377\u83CF\u6838\u79BE\u548C\u4F55\u5408\u76D2\u8C89\u9602\u6CB3\u6DB8\u8D6B\u8910\u9E64\u8D3A\u563F\u9ED1\u75D5\u5F88\u72E0\u6068\u54FC\u4EA8\u6A2A\u8861\u6052\u8F70\u54C4\u70D8\u8679\u9E3F\u6D2A\u5B8F\u5F18\u7EA2\u5589\u4FAF\u7334\u543C\u539A\u5019\u540E\u547C\u4E4E\u5FFD\u745A\u58F6\u846B\u80E1\u8774\u72D0\u7CCA\u6E56"],
      ["bb40", "\u7C43", 9, "\u7C4E", 36, "\u7C75", 5, "\u7C7E", 9],
      ["bb80", "\u7C88\u7C8A", 6, "\u7C93\u7C94\u7C96\u7C99\u7C9A\u7C9B\u7CA0\u7CA1\u7CA3\u7CA6\u7CA7\u7CA8\u7CA9\u7CAB\u7CAC\u7CAD\u7CAF\u7CB0\u7CB4", 4, "\u7CBA\u7CBB\u5F27\u864E\u552C\u62A4\u4E92\u6CAA\u6237\u82B1\u54D7\u534E\u733E\u6ED1\u753B\u5212\u5316\u8BDD\u69D0\u5F8A\u6000\u6DEE\u574F\u6B22\u73AF\u6853\u8FD8\u7F13\u6362\u60A3\u5524\u75EA\u8C62\u7115\u6DA3\u5BA6\u5E7B\u8352\u614C\u9EC4\u78FA\u8757\u7C27\u7687\u51F0\u60F6\u714C\u6643\u5E4C\u604D\u8C0E\u7070\u6325\u8F89\u5FBD\u6062\u86D4\u56DE\u6BC1\u6094\u6167\u5349\u60E0\u6666\u8D3F\u79FD\u4F1A\u70E9\u6C47\u8BB3\u8BF2\u7ED8\u8364\u660F\u5A5A\u9B42\u6D51\u6DF7\u8C41\u6D3B\u4F19\u706B\u83B7\u6216\u60D1\u970D\u8D27\u7978\u51FB\u573E\u57FA\u673A\u7578\u7A3D\u79EF\u7B95"],
      ["bc40", "\u7CBF\u7CC0\u7CC2\u7CC3\u7CC4\u7CC6\u7CC9\u7CCB\u7CCE", 6, "\u7CD8\u7CDA\u7CDB\u7CDD\u7CDE\u7CE1", 6, "\u7CE9", 5, "\u7CF0", 7, "\u7CF9\u7CFA\u7CFC", 13, "\u7D0B", 5],
      ["bc80", "\u7D11", 14, "\u7D21\u7D23\u7D24\u7D25\u7D26\u7D28\u7D29\u7D2A\u7D2C\u7D2D\u7D2E\u7D30", 6, "\u808C\u9965\u8FF9\u6FC0\u8BA5\u9E21\u59EC\u7EE9\u7F09\u5409\u6781\u68D8\u8F91\u7C4D\u96C6\u53CA\u6025\u75BE\u6C72\u5373\u5AC9\u7EA7\u6324\u51E0\u810A\u5DF1\u84DF\u6280\u5180\u5B63\u4F0E\u796D\u5242\u60B8\u6D4E\u5BC4\u5BC2\u8BA1\u8BB0\u65E2\u5FCC\u9645\u5993\u7EE7\u7EAA\u5609\u67B7\u5939\u4F73\u5BB6\u52A0\u835A\u988A\u8D3E\u7532\u94BE\u5047\u7A3C\u4EF7\u67B6\u9A7E\u5AC1\u6B7C\u76D1\u575A\u5C16\u7B3A\u95F4\u714E\u517C\u80A9\u8270\u5978\u7F04\u8327\u68C0\u67EC\u78B1\u7877\u62E3\u6361\u7B80\u4FED\u526A\u51CF\u8350\u69DB\u9274\u8DF5\u8D31\u89C1\u952E\u7BAD\u4EF6"],
      ["bd40", "\u7D37", 54, "\u7D6F", 7],
      ["bd80", "\u7D78", 32, "\u5065\u8230\u5251\u996F\u6E10\u6E85\u6DA7\u5EFA\u50F5\u59DC\u5C06\u6D46\u6C5F\u7586\u848B\u6868\u5956\u8BB2\u5320\u9171\u964D\u8549\u6912\u7901\u7126\u80F6\u4EA4\u90CA\u6D47\u9A84\u5A07\u56BC\u6405\u94F0\u77EB\u4FA5\u811A\u72E1\u89D2\u997A\u7F34\u7EDE\u527F\u6559\u9175\u8F7F\u8F83\u53EB\u7A96\u63ED\u63A5\u7686\u79F8\u8857\u9636\u622A\u52AB\u8282\u6854\u6770\u6377\u776B\u7AED\u6D01\u7ED3\u89E3\u59D0\u6212\u85C9\u82A5\u754C\u501F\u4ECB\u75A5\u8BEB\u5C4A\u5DFE\u7B4B\u65A4\u91D1\u4ECA\u6D25\u895F\u7D27\u9526\u4EC5\u8C28\u8FDB\u9773\u664B\u7981\u8FD1\u70EC\u6D78"],
      ["be40", "\u7D99", 12, "\u7DA7", 6, "\u7DAF", 42],
      ["be80", "\u7DDA", 32, "\u5C3D\u52B2\u8346\u5162\u830E\u775B\u6676\u9CB8\u4EAC\u60CA\u7CBE\u7CB3\u7ECF\u4E95\u8B66\u666F\u9888\u9759\u5883\u656C\u955C\u5F84\u75C9\u9756\u7ADF\u7ADE\u51C0\u70AF\u7A98\u63EA\u7A76\u7EA0\u7396\u97ED\u4E45\u7078\u4E5D\u9152\u53A9\u6551\u65E7\u81FC\u8205\u548E\u5C31\u759A\u97A0\u62D8\u72D9\u75BD\u5C45\u9A79\u83CA\u5C40\u5480\u77E9\u4E3E\u6CAE\u805A\u62D2\u636E\u5DE8\u5177\u8DDD\u8E1E\u952F\u4FF1\u53E5\u60E7\u70AC\u5267\u6350\u9E43\u5A1F\u5026\u7737\u5377\u7EE2\u6485\u652B\u6289\u6398\u5014\u7235\u89C9\u51B3\u8BC0\u7EDD\u5747\u83CC\u94A7\u519B\u541B\u5CFB"],
      ["bf40", "\u7DFB", 62],
      ["bf80", "\u7E3A\u7E3C", 4, "\u7E42", 4, "\u7E48", 21, "\u4FCA\u7AE3\u6D5A\u90E1\u9A8F\u5580\u5496\u5361\u54AF\u5F00\u63E9\u6977\u51EF\u6168\u520A\u582A\u52D8\u574E\u780D\u770B\u5EB7\u6177\u7CE0\u625B\u6297\u4EA2\u7095\u8003\u62F7\u70E4\u9760\u5777\u82DB\u67EF\u68F5\u78D5\u9897\u79D1\u58F3\u54B3\u53EF\u6E34\u514B\u523B\u5BA2\u8BFE\u80AF\u5543\u57A6\u6073\u5751\u542D\u7A7A\u6050\u5B54\u63A7\u62A0\u53E3\u6263\u5BC7\u67AF\u54ED\u7A9F\u82E6\u9177\u5E93\u88E4\u5938\u57AE\u630E\u8DE8\u80EF\u5757\u7B77\u4FA9\u5FEB\u5BBD\u6B3E\u5321\u7B50\u72C2\u6846\u77FF\u7736\u65F7\u51B5\u4E8F\u76D4\u5CBF\u7AA5\u8475\u594E\u9B41\u5080"],
      ["c040", "\u7E5E", 35, "\u7E83", 23, "\u7E9C\u7E9D\u7E9E"],
      ["c080", "\u7EAE\u7EB4\u7EBB\u7EBC\u7ED6\u7EE4\u7EEC\u7EF9\u7F0A\u7F10\u7F1E\u7F37\u7F39\u7F3B", 6, "\u7F43\u7F46", 9, "\u7F52\u7F53\u9988\u6127\u6E83\u5764\u6606\u6346\u56F0\u62EC\u6269\u5ED3\u9614\u5783\u62C9\u5587\u8721\u814A\u8FA3\u5566\u83B1\u6765\u8D56\u84DD\u5A6A\u680F\u62E6\u7BEE\u9611\u5170\u6F9C\u8C30\u63FD\u89C8\u61D2\u7F06\u70C2\u6EE5\u7405\u6994\u72FC\u5ECA\u90CE\u6717\u6D6A\u635E\u52B3\u7262\u8001\u4F6C\u59E5\u916A\u70D9\u6D9D\u52D2\u4E50\u96F7\u956D\u857E\u78CA\u7D2F\u5121\u5792\u64C2\u808B\u7C7B\u6CEA\u68F1\u695E\u51B7\u5398\u68A8\u7281\u9ECE\u7BF1\u72F8\u79BB\u6F13\u7406\u674E\u91CC\u9CA4\u793C\u8389\u8354\u540F\u6817\u4E3D\u5389\u52B1\u783E\u5386\u5229\u5088\u4F8B\u4FD0"],
      ["c140", "\u7F56\u7F59\u7F5B\u7F5C\u7F5D\u7F5E\u7F60\u7F63", 4, "\u7F6B\u7F6C\u7F6D\u7F6F\u7F70\u7F73\u7F75\u7F76\u7F77\u7F78\u7F7A\u7F7B\u7F7C\u7F7D\u7F7F\u7F80\u7F82", 7, "\u7F8B\u7F8D\u7F8F", 4, "\u7F95", 4, "\u7F9B\u7F9C\u7FA0\u7FA2\u7FA3\u7FA5\u7FA6\u7FA8", 6, "\u7FB1"],
      ["c180", "\u7FB3", 4, "\u7FBA\u7FBB\u7FBE\u7FC0\u7FC2\u7FC3\u7FC4\u7FC6\u7FC7\u7FC8\u7FC9\u7FCB\u7FCD\u7FCF", 4, "\u7FD6\u7FD7\u7FD9", 5, "\u7FE2\u7FE3\u75E2\u7ACB\u7C92\u6CA5\u96B6\u529B\u7483\u54E9\u4FE9\u8054\u83B2\u8FDE\u9570\u5EC9\u601C\u6D9F\u5E18\u655B\u8138\u94FE\u604B\u70BC\u7EC3\u7CAE\u51C9\u6881\u7CB1\u826F\u4E24\u8F86\u91CF\u667E\u4EAE\u8C05\u64A9\u804A\u50DA\u7597\u71CE\u5BE5\u8FBD\u6F66\u4E86\u6482\u9563\u5ED6\u6599\u5217\u88C2\u70C8\u52A3\u730E\u7433\u6797\u78F7\u9716\u4E34\u90BB\u9CDE\u6DCB\u51DB\u8D41\u541D\u62CE\u73B2\u83F1\u96F6\u9F84\u94C3\u4F36\u7F9A\u51CC\u7075\u9675\u5CAD\u9886\u53E6\u4EE4\u6E9C\u7409\u69B4\u786B\u998F\u7559\u5218\u7624\u6D41\u67F3\u516D\u9F99\u804B\u5499\u7B3C\u7ABF"],
      ["c240", "\u7FE4\u7FE7\u7FE8\u7FEA\u7FEB\u7FEC\u7FED\u7FEF\u7FF2\u7FF4", 6, "\u7FFD\u7FFE\u7FFF\u8002\u8007\u8008\u8009\u800A\u800E\u800F\u8011\u8013\u801A\u801B\u801D\u801E\u801F\u8021\u8023\u8024\u802B", 5, "\u8032\u8034\u8039\u803A\u803C\u803E\u8040\u8041\u8044\u8045\u8047\u8048\u8049\u804E\u804F\u8050\u8051\u8053\u8055\u8056\u8057"],
      ["c280", "\u8059\u805B", 13, "\u806B", 5, "\u8072", 11, "\u9686\u5784\u62E2\u9647\u697C\u5A04\u6402\u7BD3\u6F0F\u964B\u82A6\u5362\u9885\u5E90\u7089\u63B3\u5364\u864F\u9C81\u9E93\u788C\u9732\u8DEF\u8D42\u9E7F\u6F5E\u7984\u5F55\u9646\u622E\u9A74\u5415\u94DD\u4FA3\u65C5\u5C65\u5C61\u7F15\u8651\u6C2F\u5F8B\u7387\u6EE4\u7EFF\u5CE6\u631B\u5B6A\u6EE6\u5375\u4E71\u63A0\u7565\u62A1\u8F6E\u4F26\u4ED1\u6CA6\u7EB6\u8BBA\u841D\u87BA\u7F57\u903B\u9523\u7BA9\u9AA1\u88F8\u843D\u6D1B\u9A86\u7EDC\u5988\u9EBB\u739B\u7801\u8682\u9A6C\u9A82\u561B\u5417\u57CB\u4E70\u9EA6\u5356\u8FC8\u8109\u7792\u9992\u86EE\u6EE1\u8513\u66FC\u6162\u6F2B"],
      ["c340", "\u807E\u8081\u8082\u8085\u8088\u808A\u808D", 5, "\u8094\u8095\u8097\u8099\u809E\u80A3\u80A6\u80A7\u80A8\u80AC\u80B0\u80B3\u80B5\u80B6\u80B8\u80B9\u80BB\u80C5\u80C7", 4, "\u80CF", 6, "\u80D8\u80DF\u80E0\u80E2\u80E3\u80E6\u80EE\u80F5\u80F7\u80F9\u80FB\u80FE\u80FF\u8100\u8101\u8103\u8104\u8105\u8107\u8108\u810B"],
      ["c380", "\u810C\u8115\u8117\u8119\u811B\u811C\u811D\u811F", 12, "\u812D\u812E\u8130\u8133\u8134\u8135\u8137\u8139", 4, "\u813F\u8C29\u8292\u832B\u76F2\u6C13\u5FD9\u83BD\u732B\u8305\u951A\u6BDB\u77DB\u94C6\u536F\u8302\u5192\u5E3D\u8C8C\u8D38\u4E48\u73AB\u679A\u6885\u9176\u9709\u7164\u6CA1\u7709\u5A92\u9541\u6BCF\u7F8E\u6627\u5BD0\u59B9\u5A9A\u95E8\u95F7\u4EEC\u840C\u8499\u6AAC\u76DF\u9530\u731B\u68A6\u5B5F\u772F\u919A\u9761\u7CDC\u8FF7\u8C1C\u5F25\u7C73\u79D8\u89C5\u6CCC\u871C\u5BC6\u5E42\u68C9\u7720\u7EF5\u5195\u514D\u52C9\u5A29\u7F05\u9762\u82D7\u63CF\u7784\u85D0\u79D2\u6E3A\u5E99\u5999\u8511\u706D\u6C11\u62BF\u76BF\u654F\u60AF\u95FD\u660E\u879F\u9E23\u94ED\u540D\u547D\u8C2C\u6478"],
      ["c440", "\u8140", 5, "\u8147\u8149\u814D\u814E\u814F\u8152\u8156\u8157\u8158\u815B", 4, "\u8161\u8162\u8163\u8164\u8166\u8168\u816A\u816B\u816C\u816F\u8172\u8173\u8175\u8176\u8177\u8178\u8181\u8183", 4, "\u8189\u818B\u818C\u818D\u818E\u8190\u8192", 5, "\u8199\u819A\u819E", 4, "\u81A4\u81A5"],
      ["c480", "\u81A7\u81A9\u81AB", 7, "\u81B4", 5, "\u81BC\u81BD\u81BE\u81BF\u81C4\u81C5\u81C7\u81C8\u81C9\u81CB\u81CD", 6, "\u6479\u8611\u6A21\u819C\u78E8\u6469\u9B54\u62B9\u672B\u83AB\u58A8\u9ED8\u6CAB\u6F20\u5BDE\u964C\u8C0B\u725F\u67D0\u62C7\u7261\u4EA9\u59C6\u6BCD\u5893\u66AE\u5E55\u52DF\u6155\u6728\u76EE\u7766\u7267\u7A46\u62FF\u54EA\u5450\u94A0\u90A3\u5A1C\u7EB3\u6C16\u4E43\u5976\u8010\u5948\u5357\u7537\u96BE\u56CA\u6320\u8111\u607C\u95F9\u6DD6\u5462\u9981\u5185\u5AE9\u80FD\u59AE\u9713\u502A\u6CE5\u5C3C\u62DF\u4F60\u533F\u817B\u9006\u6EBA\u852B\u62C8\u5E74\u78BE\u64B5\u637B\u5FF5\u5A18\u917F\u9E1F\u5C3F\u634F\u8042\u5B7D\u556E\u954A\u954D\u6D85\u60A8\u67E0\u72DE\u51DD\u5B81"],
      ["c540", "\u81D4", 14, "\u81E4\u81E5\u81E6\u81E8\u81E9\u81EB\u81EE", 4, "\u81F5", 5, "\u81FD\u81FF\u8203\u8207", 4, "\u820E\u820F\u8211\u8213\u8215", 5, "\u821D\u8220\u8224\u8225\u8226\u8227\u8229\u822E\u8232\u823A\u823C\u823D\u823F"],
      ["c580", "\u8240\u8241\u8242\u8243\u8245\u8246\u8248\u824A\u824C\u824D\u824E\u8250", 7, "\u8259\u825B\u825C\u825D\u825E\u8260", 7, "\u8269\u62E7\u6CDE\u725B\u626D\u94AE\u7EBD\u8113\u6D53\u519C\u5F04\u5974\u52AA\u6012\u5973\u6696\u8650\u759F\u632A\u61E6\u7CEF\u8BFA\u54E6\u6B27\u9E25\u6BB4\u85D5\u5455\u5076\u6CA4\u556A\u8DB4\u722C\u5E15\u6015\u7436\u62CD\u6392\u724C\u5F98\u6E43\u6D3E\u6500\u6F58\u76D8\u78D0\u76FC\u7554\u5224\u53DB\u4E53\u5E9E\u65C1\u802A\u80D6\u629B\u5486\u5228\u70AE\u888D\u8DD1\u6CE1\u5478\u80DA\u57F9\u88F4\u8D54\u966A\u914D\u4F69\u6C9B\u55B7\u76C6\u7830\u62A8\u70F9\u6F8E\u5F6D\u84EC\u68DA\u787C\u7BF7\u81A8\u670B\u9E4F\u6367\u78B0\u576F\u7812\u9739\u6279\u62AB\u5288\u7435\u6BD7"],
      ["c640", "\u826A\u826B\u826C\u826D\u8271\u8275\u8276\u8277\u8278\u827B\u827C\u8280\u8281\u8283\u8285\u8286\u8287\u8289\u828C\u8290\u8293\u8294\u8295\u8296\u829A\u829B\u829E\u82A0\u82A2\u82A3\u82A7\u82B2\u82B5\u82B6\u82BA\u82BB\u82BC\u82BF\u82C0\u82C2\u82C3\u82C5\u82C6\u82C9\u82D0\u82D6\u82D9\u82DA\u82DD\u82E2\u82E7\u82E8\u82E9\u82EA\u82EC\u82ED\u82EE\u82F0\u82F2\u82F3\u82F5\u82F6\u82F8"],
      ["c680", "\u82FA\u82FC", 4, "\u830A\u830B\u830D\u8310\u8312\u8313\u8316\u8318\u8319\u831D", 9, "\u8329\u832A\u832E\u8330\u8332\u8337\u833B\u833D\u5564\u813E\u75B2\u76AE\u5339\u75DE\u50FB\u5C41\u8B6C\u7BC7\u504F\u7247\u9A97\u98D8\u6F02\u74E2\u7968\u6487\u77A5\u62FC\u9891\u8D2B\u54C1\u8058\u4E52\u576A\u82F9\u840D\u5E73\u51ED\u74F6\u8BC4\u5C4F\u5761\u6CFC\u9887\u5A46\u7834\u9B44\u8FEB\u7C95\u5256\u6251\u94FA\u4EC6\u8386\u8461\u83E9\u84B2\u57D4\u6734\u5703\u666E\u6D66\u8C31\u66DD\u7011\u671F\u6B3A\u6816\u621A\u59BB\u4E03\u51C4\u6F06\u67D2\u6C8F\u5176\u68CB\u5947\u6B67\u7566\u5D0E\u8110\u9F50\u65D7\u7948\u7941\u9A91\u8D77\u5C82\u4E5E\u4F01\u542F\u5951\u780C\u5668\u6C14\u8FC4\u5F03\u6C7D\u6CE3\u8BAB\u6390"],
      ["c740", "\u833E\u833F\u8341\u8342\u8344\u8345\u8348\u834A", 4, "\u8353\u8355", 4, "\u835D\u8362\u8370", 6, "\u8379\u837A\u837E", 6, "\u8387\u8388\u838A\u838B\u838C\u838D\u838F\u8390\u8391\u8394\u8395\u8396\u8397\u8399\u839A\u839D\u839F\u83A1", 6, "\u83AC\u83AD\u83AE"],
      ["c780", "\u83AF\u83B5\u83BB\u83BE\u83BF\u83C2\u83C3\u83C4\u83C6\u83C8\u83C9\u83CB\u83CD\u83CE\u83D0\u83D1\u83D2\u83D3\u83D5\u83D7\u83D9\u83DA\u83DB\u83DE\u83E2\u83E3\u83E4\u83E6\u83E7\u83E8\u83EB\u83EC\u83ED\u6070\u6D3D\u7275\u6266\u948E\u94C5\u5343\u8FC1\u7B7E\u4EDF\u8C26\u4E7E\u9ED4\u94B1\u94B3\u524D\u6F5C\u9063\u6D45\u8C34\u5811\u5D4C\u6B20\u6B49\u67AA\u545B\u8154\u7F8C\u5899\u8537\u5F3A\u62A2\u6A47\u9539\u6572\u6084\u6865\u77A7\u4E54\u4FA8\u5DE7\u9798\u64AC\u7FD8\u5CED\u4FCF\u7A8D\u5207\u8304\u4E14\u602F\u7A83\u94A6\u4FB5\u4EB2\u79E6\u7434\u52E4\u82B9\u64D2\u79BD\u5BDD\u6C81\u9752\u8F7B\u6C22\u503E\u537F\u6E05\u64CE\u6674\u6C30\u60C5\u9877\u8BF7\u5E86\u743C\u7A77\u79CB\u4E18\u90B1\u7403\u6C42\u56DA\u914B\u6CC5\u8D8B\u533A\u86C6\u66F2\u8EAF\u5C48\u9A71\u6E20"],
      ["c840", "\u83EE\u83EF\u83F3", 4, "\u83FA\u83FB\u83FC\u83FE\u83FF\u8400\u8402\u8405\u8407\u8408\u8409\u840A\u8410\u8412", 5, "\u8419\u841A\u841B\u841E", 5, "\u8429", 7, "\u8432", 5, "\u8439\u843A\u843B\u843E", 7, "\u8447\u8448\u8449"],
      ["c880", "\u844A", 6, "\u8452", 4, "\u8458\u845D\u845E\u845F\u8460\u8462\u8464", 4, "\u846A\u846E\u846F\u8470\u8472\u8474\u8477\u8479\u847B\u847C\u53D6\u5A36\u9F8B\u8DA3\u53BB\u5708\u98A7\u6743\u919B\u6CC9\u5168\u75CA\u62F3\u72AC\u5238\u529D\u7F3A\u7094\u7638\u5374\u9E4A\u69B7\u786E\u96C0\u88D9\u7FA4\u7136\u71C3\u5189\u67D3\u74E4\u58E4\u6518\u56B7\u8BA9\u9976\u6270\u7ED5\u60F9\u70ED\u58EC\u4EC1\u4EBA\u5FCD\u97E7\u4EFB\u8BA4\u5203\u598A\u7EAB\u6254\u4ECD\u65E5\u620E\u8338\u84C9\u8363\u878D\u7194\u6EB6\u5BB9\u7ED2\u5197\u63C9\u67D4\u8089\u8339\u8815\u5112\u5B7A\u5982\u8FB1\u4E73\u6C5D\u5165\u8925\u8F6F\u962E\u854A\u745E\u9510\u95F0\u6DA6\u82E5\u5F31\u6492\u6D12\u8428\u816E\u9CC3\u585E\u8D5B\u4E09\u53C1"],
      ["c940", "\u847D", 4, "\u8483\u8484\u8485\u8486\u848A\u848D\u848F", 7, "\u8498\u849A\u849B\u849D\u849E\u849F\u84A0\u84A2", 12, "\u84B0\u84B1\u84B3\u84B5\u84B6\u84B7\u84BB\u84BC\u84BE\u84C0\u84C2\u84C3\u84C5\u84C6\u84C7\u84C8\u84CB\u84CC\u84CE\u84CF\u84D2\u84D4\u84D5\u84D7"],
      ["c980", "\u84D8", 4, "\u84DE\u84E1\u84E2\u84E4\u84E7", 4, "\u84ED\u84EE\u84EF\u84F1", 10, "\u84FD\u84FE\u8500\u8501\u8502\u4F1E\u6563\u6851\u55D3\u4E27\u6414\u9A9A\u626B\u5AC2\u745F\u8272\u6DA9\u68EE\u50E7\u838E\u7802\u6740\u5239\u6C99\u7EB1\u50BB\u5565\u715E\u7B5B\u6652\u73CA\u82EB\u6749\u5C71\u5220\u717D\u886B\u95EA\u9655\u64C5\u8D61\u81B3\u5584\u6C55\u6247\u7F2E\u5892\u4F24\u5546\u8D4F\u664C\u4E0A\u5C1A\u88F3\u68A2\u634E\u7A0D\u70E7\u828D\u52FA\u97F6\u5C11\u54E8\u90B5\u7ECD\u5962\u8D4A\u86C7\u820C\u820D\u8D66\u6444\u5C04\u6151\u6D89\u793E\u8BBE\u7837\u7533\u547B\u4F38\u8EAB\u6DF1\u5A20\u7EC5\u795E\u6C88\u5BA1\u5A76\u751A\u80BE\u614E\u6E17\u58F0\u751F\u7525\u7272\u5347\u7EF3"],
      ["ca40", "\u8503", 8, "\u850D\u850E\u850F\u8510\u8512\u8514\u8515\u8516\u8518\u8519\u851B\u851C\u851D\u851E\u8520\u8522", 8, "\u852D", 9, "\u853E", 4, "\u8544\u8545\u8546\u8547\u854B", 10],
      ["ca80", "\u8557\u8558\u855A\u855B\u855C\u855D\u855F", 4, "\u8565\u8566\u8567\u8569", 8, "\u8573\u8575\u8576\u8577\u8578\u857C\u857D\u857F\u8580\u8581\u7701\u76DB\u5269\u80DC\u5723\u5E08\u5931\u72EE\u65BD\u6E7F\u8BD7\u5C38\u8671\u5341\u77F3\u62FE\u65F6\u4EC0\u98DF\u8680\u5B9E\u8BC6\u53F2\u77E2\u4F7F\u5C4E\u9A76\u59CB\u5F0F\u793A\u58EB\u4E16\u67FF\u4E8B\u62ED\u8A93\u901D\u52BF\u662F\u55DC\u566C\u9002\u4ED5\u4F8D\u91CA\u9970\u6C0F\u5E02\u6043\u5BA4\u89C6\u8BD5\u6536\u624B\u9996\u5B88\u5BFF\u6388\u552E\u53D7\u7626\u517D\u852C\u67A2\u68B3\u6B8A\u6292\u8F93\u53D4\u8212\u6DD1\u758F\u4E66\u8D4E\u5B70\u719F\u85AF\u6691\u66D9\u7F72\u8700\u9ECD\u9F20\u5C5E\u672F\u8FF0\u6811\u675F\u620D\u7AD6\u5885\u5EB6\u6570\u6F31"],
      ["cb40", "\u8582\u8583\u8586\u8588", 6, "\u8590", 10, "\u859D", 6, "\u85A5\u85A6\u85A7\u85A9\u85AB\u85AC\u85AD\u85B1", 5, "\u85B8\u85BA", 6, "\u85C2", 6, "\u85CA", 4, "\u85D1\u85D2"],
      ["cb80", "\u85D4\u85D6", 5, "\u85DD", 6, "\u85E5\u85E6\u85E7\u85E8\u85EA", 14, "\u6055\u5237\u800D\u6454\u8870\u7529\u5E05\u6813\u62F4\u971C\u53CC\u723D\u8C01\u6C34\u7761\u7A0E\u542E\u77AC\u987A\u821C\u8BF4\u7855\u6714\u70C1\u65AF\u6495\u5636\u601D\u79C1\u53F8\u4E1D\u6B7B\u8086\u5BFA\u55E3\u56DB\u4F3A\u4F3C\u9972\u5DF3\u677E\u8038\u6002\u9882\u9001\u5B8B\u8BBC\u8BF5\u641C\u8258\u64DE\u55FD\u82CF\u9165\u4FD7\u7D20\u901F\u7C9F\u50F3\u5851\u6EAF\u5BBF\u8BC9\u8083\u9178\u849C\u7B97\u867D\u968B\u968F\u7EE5\u9AD3\u788E\u5C81\u7A57\u9042\u96A7\u795F\u5B59\u635F\u7B0B\u84D1\u68AD\u5506\u7F29\u7410\u7D22\u9501\u6240\u584C\u4ED6\u5B83\u5979\u5854"],
      ["cc40", "\u85F9\u85FA\u85FC\u85FD\u85FE\u8600", 4, "\u8606", 10, "\u8612\u8613\u8614\u8615\u8617", 15, "\u8628\u862A", 13, "\u8639\u863A\u863B\u863D\u863E\u863F\u8640"],
      ["cc80", "\u8641", 11, "\u8652\u8653\u8655", 4, "\u865B\u865C\u865D\u865F\u8660\u8661\u8663", 7, "\u736D\u631E\u8E4B\u8E0F\u80CE\u82D4\u62AC\u53F0\u6CF0\u915E\u592A\u6001\u6C70\u574D\u644A\u8D2A\u762B\u6EE9\u575B\u6A80\u75F0\u6F6D\u8C2D\u8C08\u5766\u6BEF\u8892\u78B3\u63A2\u53F9\u70AD\u6C64\u5858\u642A\u5802\u68E0\u819B\u5510\u7CD6\u5018\u8EBA\u6DCC\u8D9F\u70EB\u638F\u6D9B\u6ED4\u7EE6\u8404\u6843\u9003\u6DD8\u9676\u8BA8\u5957\u7279\u85E4\u817E\u75BC\u8A8A\u68AF\u5254\u8E22\u9511\u63D0\u9898\u8E44\u557C\u4F53\u66FF\u568F\u60D5\u6D95\u5243\u5C49\u5929\u6DFB\u586B\u7530\u751C\u606C\u8214\u8146\u6311\u6761\u8FE2\u773A\u8DF3\u8D34\u94C1\u5E16\u5385\u542C\u70C3"],
      ["cd40", "\u866D\u866F\u8670\u8672", 6, "\u8683", 6, "\u868E", 4, "\u8694\u8696", 5, "\u869E", 4, "\u86A5\u86A6\u86AB\u86AD\u86AE\u86B2\u86B3\u86B7\u86B8\u86B9\u86BB", 4, "\u86C1\u86C2\u86C3\u86C5\u86C8\u86CC\u86CD\u86D2\u86D3\u86D5\u86D6\u86D7\u86DA\u86DC"],
      ["cd80", "\u86DD\u86E0\u86E1\u86E2\u86E3\u86E5\u86E6\u86E7\u86E8\u86EA\u86EB\u86EC\u86EF\u86F5\u86F6\u86F7\u86FA\u86FB\u86FC\u86FD\u86FF\u8701\u8704\u8705\u8706\u870B\u870C\u870E\u870F\u8710\u8711\u8714\u8716\u6C40\u5EF7\u505C\u4EAD\u5EAD\u633A\u8247\u901A\u6850\u916E\u77B3\u540C\u94DC\u5F64\u7AE5\u6876\u6345\u7B52\u7EDF\u75DB\u5077\u6295\u5934\u900F\u51F8\u79C3\u7A81\u56FE\u5F92\u9014\u6D82\u5C60\u571F\u5410\u5154\u6E4D\u56E2\u63A8\u9893\u817F\u8715\u892A\u9000\u541E\u5C6F\u81C0\u62D6\u6258\u8131\u9E35\u9640\u9A6E\u9A7C\u692D\u59A5\u62D3\u553E\u6316\u54C7\u86D9\u6D3C\u5A03\u74E6\u889C\u6B6A\u5916\u8C4C\u5F2F\u6E7E\u73A9\u987D\u4E38\u70F7\u5B8C\u7897\u633D\u665A\u7696\u60CB\u5B9B\u5A49\u4E07\u8155\u6C6A\u738B\u4EA1\u6789\u7F51\u5F80\u65FA\u671B\u5FD8\u5984\u5A01"],
      ["ce40", "\u8719\u871B\u871D\u871F\u8720\u8724\u8726\u8727\u8728\u872A\u872B\u872C\u872D\u872F\u8730\u8732\u8733\u8735\u8736\u8738\u8739\u873A\u873C\u873D\u8740", 6, "\u874A\u874B\u874D\u874F\u8750\u8751\u8752\u8754\u8755\u8756\u8758\u875A", 5, "\u8761\u8762\u8766", 7, "\u876F\u8771\u8772\u8773\u8775"],
      ["ce80", "\u8777\u8778\u8779\u877A\u877F\u8780\u8781\u8784\u8786\u8787\u8789\u878A\u878C\u878E", 4, "\u8794\u8795\u8796\u8798", 6, "\u87A0", 4, "\u5DCD\u5FAE\u5371\u97E6\u8FDD\u6845\u56F4\u552F\u60DF\u4E3A\u6F4D\u7EF4\u82C7\u840E\u59D4\u4F1F\u4F2A\u5C3E\u7EAC\u672A\u851A\u5473\u754F\u80C3\u5582\u9B4F\u4F4D\u6E2D\u8C13\u5C09\u6170\u536B\u761F\u6E29\u868A\u6587\u95FB\u7EB9\u543B\u7A33\u7D0A\u95EE\u55E1\u7FC1\u74EE\u631D\u8717\u6DA1\u7A9D\u6211\u65A1\u5367\u63E1\u6C83\u5DEB\u545C\u94A8\u4E4C\u6C61\u8BEC\u5C4B\u65E0\u829C\u68A7\u543E\u5434\u6BCB\u6B66\u4E94\u6342\u5348\u821E\u4F0D\u4FAE\u575E\u620A\u96FE\u6664\u7269\u52FF\u52A1\u609F\u8BEF\u6614\u7199\u6790\u897F\u7852\u77FD\u6670\u563B\u5438\u9521\u727A"],
      ["cf40", "\u87A5\u87A6\u87A7\u87A9\u87AA\u87AE\u87B0\u87B1\u87B2\u87B4\u87B6\u87B7\u87B8\u87B9\u87BB\u87BC\u87BE\u87BF\u87C1", 4, "\u87C7\u87C8\u87C9\u87CC", 4, "\u87D4", 6, "\u87DC\u87DD\u87DE\u87DF\u87E1\u87E2\u87E3\u87E4\u87E6\u87E7\u87E8\u87E9\u87EB\u87EC\u87ED\u87EF", 9],
      ["cf80", "\u87FA\u87FB\u87FC\u87FD\u87FF\u8800\u8801\u8802\u8804", 5, "\u880B", 7, "\u8814\u8817\u8818\u8819\u881A\u881C", 4, "\u8823\u7A00\u606F\u5E0C\u6089\u819D\u5915\u60DC\u7184\u70EF\u6EAA\u6C50\u7280\u6A84\u88AD\u5E2D\u4E60\u5AB3\u559C\u94E3\u6D17\u7CFB\u9699\u620F\u7EC6\u778E\u867E\u5323\u971E\u8F96\u6687\u5CE1\u4FA0\u72ED\u4E0B\u53A6\u590F\u5413\u6380\u9528\u5148\u4ED9\u9C9C\u7EA4\u54B8\u8D24\u8854\u8237\u95F2\u6D8E\u5F26\u5ACC\u663E\u9669\u73B0\u732E\u53BF\u817A\u9985\u7FA1\u5BAA\u9677\u9650\u7EBF\u76F8\u53A2\u9576\u9999\u7BB1\u8944\u6E58\u4E61\u7FD4\u7965\u8BE6\u60F3\u54CD\u4EAB\u9879\u5DF7\u6A61\u50CF\u5411\u8C61\u8427\u785D\u9704\u524A\u54EE\u56A3\u9500\u6D88\u5BB5\u6DC6\u6653"],
      ["d040", "\u8824", 13, "\u8833", 5, "\u883A\u883B\u883D\u883E\u883F\u8841\u8842\u8843\u8846", 5, "\u884E", 5, "\u8855\u8856\u8858\u885A", 6, "\u8866\u8867\u886A\u886D\u886F\u8871\u8873\u8874\u8875\u8876\u8878\u8879\u887A"],
      ["d080", "\u887B\u887C\u8880\u8883\u8886\u8887\u8889\u888A\u888C\u888E\u888F\u8890\u8891\u8893\u8894\u8895\u8897", 4, "\u889D", 4, "\u88A3\u88A5", 5, "\u5C0F\u5B5D\u6821\u8096\u5578\u7B11\u6548\u6954\u4E9B\u6B47\u874E\u978B\u534F\u631F\u643A\u90AA\u659C\u80C1\u8C10\u5199\u68B0\u5378\u87F9\u61C8\u6CC4\u6CFB\u8C22\u5C51\u85AA\u82AF\u950C\u6B23\u8F9B\u65B0\u5FFB\u5FC3\u4FE1\u8845\u661F\u8165\u7329\u60FA\u5174\u5211\u578B\u5F62\u90A2\u884C\u9192\u5E78\u674F\u6027\u59D3\u5144\u51F6\u80F8\u5308\u6C79\u96C4\u718A\u4F11\u4FEE\u7F9E\u673D\u55C5\u9508\u79C0\u8896\u7EE3\u589F\u620C\u9700\u865A\u5618\u987B\u5F90\u8BB8\u84C4\u9157\u53D9\u65ED\u5E8F\u755C\u6064\u7D6E\u5A7F\u7EEA\u7EED\u8F69\u55A7\u5BA3\u60AC\u65CB\u7384"],
      ["d140", "\u88AC\u88AE\u88AF\u88B0\u88B2", 4, "\u88B8\u88B9\u88BA\u88BB\u88BD\u88BE\u88BF\u88C0\u88C3\u88C4\u88C7\u88C8\u88CA\u88CB\u88CC\u88CD\u88CF\u88D0\u88D1\u88D3\u88D6\u88D7\u88DA", 4, "\u88E0\u88E1\u88E6\u88E7\u88E9", 6, "\u88F2\u88F5\u88F6\u88F7\u88FA\u88FB\u88FD\u88FF\u8900\u8901\u8903", 5],
      ["d180", "\u8909\u890B", 4, "\u8911\u8914", 4, "\u891C", 4, "\u8922\u8923\u8924\u8926\u8927\u8928\u8929\u892C\u892D\u892E\u892F\u8931\u8932\u8933\u8935\u8937\u9009\u7663\u7729\u7EDA\u9774\u859B\u5B66\u7A74\u96EA\u8840\u52CB\u718F\u5FAA\u65EC\u8BE2\u5BFB\u9A6F\u5DE1\u6B89\u6C5B\u8BAD\u8BAF\u900A\u8FC5\u538B\u62BC\u9E26\u9E2D\u5440\u4E2B\u82BD\u7259\u869C\u5D16\u8859\u6DAF\u96C5\u54D1\u4E9A\u8BB6\u7109\u54BD\u9609\u70DF\u6DF9\u76D0\u4E25\u7814\u8712\u5CA9\u5EF6\u8A00\u989C\u960E\u708E\u6CBF\u5944\u63A9\u773C\u884D\u6F14\u8273\u5830\u71D5\u538C\u781A\u96C1\u5501\u5F66\u7130\u5BB4\u8C1A\u9A8C\u6B83\u592E\u9E2F\u79E7\u6768\u626C\u4F6F\u75A1\u7F8A\u6D0B\u9633\u6C27\u4EF0\u75D2\u517B\u6837\u6F3E\u9080\u8170\u5996\u7476"],
      ["d240", "\u8938", 8, "\u8942\u8943\u8945", 24, "\u8960", 5, "\u8967", 19, "\u897C"],
      ["d280", "\u897D\u897E\u8980\u8982\u8984\u8985\u8987", 26, "\u6447\u5C27\u9065\u7A91\u8C23\u59DA\u54AC\u8200\u836F\u8981\u8000\u6930\u564E\u8036\u7237\u91CE\u51B6\u4E5F\u9875\u6396\u4E1A\u53F6\u66F3\u814B\u591C\u6DB2\u4E00\u58F9\u533B\u63D6\u94F1\u4F9D\u4F0A\u8863\u9890\u5937\u9057\u79FB\u4EEA\u80F0\u7591\u6C82\u5B9C\u59E8\u5F5D\u6905\u8681\u501A\u5DF2\u4E59\u77E3\u4EE5\u827A\u6291\u6613\u9091\u5C79\u4EBF\u5F79\u81C6\u9038\u8084\u75AB\u4EA6\u88D4\u610F\u6BC5\u5FC6\u4E49\u76CA\u6EA2\u8BE3\u8BAE\u8C0A\u8BD1\u5F02\u7FFC\u7FCC\u7ECE\u8335\u836B\u56E0\u6BB7\u97F3\u9634\u59FB\u541F\u94F6\u6DEB\u5BC5\u996E\u5C39\u5F15\u9690"],
      ["d340", "\u89A2", 30, "\u89C3\u89CD\u89D3\u89D4\u89D5\u89D7\u89D8\u89D9\u89DB\u89DD\u89DF\u89E0\u89E1\u89E2\u89E4\u89E7\u89E8\u89E9\u89EA\u89EC\u89ED\u89EE\u89F0\u89F1\u89F2\u89F4", 6],
      ["d380", "\u89FB", 4, "\u8A01", 5, "\u8A08", 21, "\u5370\u82F1\u6A31\u5A74\u9E70\u5E94\u7F28\u83B9\u8424\u8425\u8367\u8747\u8FCE\u8D62\u76C8\u5F71\u9896\u786C\u6620\u54DF\u62E5\u4F63\u81C3\u75C8\u5EB8\u96CD\u8E0A\u86F9\u548F\u6CF3\u6D8C\u6C38\u607F\u52C7\u7528\u5E7D\u4F18\u60A0\u5FE7\u5C24\u7531\u90AE\u94C0\u72B9\u6CB9\u6E38\u9149\u6709\u53CB\u53F3\u4F51\u91C9\u8BF1\u53C8\u5E7C\u8FC2\u6DE4\u4E8E\u76C2\u6986\u865E\u611A\u8206\u4F59\u4FDE\u903E\u9C7C\u6109\u6E1D\u6E14\u9685\u4E88\u5A31\u96E8\u4E0E\u5C7F\u79B9\u5B87\u8BED\u7FBD\u7389\u57DF\u828B\u90C1\u5401\u9047\u55BB\u5CEA\u5FA1\u6108\u6B32\u72F1\u80B2\u8A89"],
      ["d440", "\u8A1E", 31, "\u8A3F", 8, "\u8A49", 21],
      ["d480", "\u8A5F", 25, "\u8A7A", 6, "\u6D74\u5BD3\u88D5\u9884\u8C6B\u9A6D\u9E33\u6E0A\u51A4\u5143\u57A3\u8881\u539F\u63F4\u8F95\u56ED\u5458\u5706\u733F\u6E90\u7F18\u8FDC\u82D1\u613F\u6028\u9662\u66F0\u7EA6\u8D8A\u8DC3\u94A5\u5CB3\u7CA4\u6708\u60A6\u9605\u8018\u4E91\u90E7\u5300\u9668\u5141\u8FD0\u8574\u915D\u6655\u97F5\u5B55\u531D\u7838\u6742\u683D\u54C9\u707E\u5BB0\u8F7D\u518D\u5728\u54B1\u6512\u6682\u8D5E\u8D43\u810F\u846C\u906D\u7CDF\u51FF\u85FB\u67A3\u65E9\u6FA1\u86A4\u8E81\u566A\u9020\u7682\u7076\u71E5\u8D23\u62E9\u5219\u6CFD\u8D3C\u600E\u589E\u618E\u66FE\u8D60\u624E\u55B3\u6E23\u672D\u8F67"],
      ["d540", "\u8A81", 7, "\u8A8B", 7, "\u8A94", 46],
      ["d580", "\u8AC3", 32, "\u94E1\u95F8\u7728\u6805\u69A8\u548B\u4E4D\u70B8\u8BC8\u6458\u658B\u5B85\u7A84\u503A\u5BE8\u77BB\u6BE1\u8A79\u7C98\u6CBE\u76CF\u65A9\u8F97\u5D2D\u5C55\u8638\u6808\u5360\u6218\u7AD9\u6E5B\u7EFD\u6A1F\u7AE0\u5F70\u6F33\u5F20\u638C\u6DA8\u6756\u4E08\u5E10\u8D26\u4ED7\u80C0\u7634\u969C\u62DB\u662D\u627E\u6CBC\u8D75\u7167\u7F69\u5146\u8087\u53EC\u906E\u6298\u54F2\u86F0\u8F99\u8005\u9517\u8517\u8FD9\u6D59\u73CD\u659F\u771F\u7504\u7827\u81FB\u8D1E\u9488\u4FA6\u6795\u75B9\u8BCA\u9707\u632F\u9547\u9635\u84B8\u6323\u7741\u5F81\u72F0\u4E89\u6014\u6574\u62EF\u6B63\u653F"],
      ["d640", "\u8AE4", 34, "\u8B08", 27],
      ["d680", "\u8B24\u8B25\u8B27", 30, "\u5E27\u75C7\u90D1\u8BC1\u829D\u679D\u652F\u5431\u8718\u77E5\u80A2\u8102\u6C41\u4E4B\u7EC7\u804C\u76F4\u690D\u6B96\u6267\u503C\u4F84\u5740\u6307\u6B62\u8DBE\u53EA\u65E8\u7EB8\u5FD7\u631A\u63B7\u81F3\u81F4\u7F6E\u5E1C\u5CD9\u5236\u667A\u79E9\u7A1A\u8D28\u7099\u75D4\u6EDE\u6CBB\u7A92\u4E2D\u76C5\u5FE0\u949F\u8877\u7EC8\u79CD\u80BF\u91CD\u4EF2\u4F17\u821F\u5468\u5DDE\u6D32\u8BCC\u7CA5\u8F74\u8098\u5E1A\u5492\u76B1\u5B99\u663C\u9AA4\u73E0\u682A\u86DB\u6731\u732A\u8BF8\u8BDB\u9010\u7AF9\u70DB\u716E\u62C4\u77A9\u5631\u4E3B\u8457\u67F1\u52A9\u86C0\u8D2E\u94F8\u7B51"],
      ["d740", "\u8B46", 31, "\u8B67", 4, "\u8B6D", 25],
      ["d780", "\u8B87", 24, "\u8BAC\u8BB1\u8BBB\u8BC7\u8BD0\u8BEA\u8C09\u8C1E\u4F4F\u6CE8\u795D\u9A7B\u6293\u722A\u62FD\u4E13\u7816\u8F6C\u64B0\u8D5A\u7BC6\u6869\u5E84\u88C5\u5986\u649E\u58EE\u72B6\u690E\u9525\u8FFD\u8D58\u5760\u7F00\u8C06\u51C6\u6349\u62D9\u5353\u684C\u7422\u8301\u914C\u5544\u7740\u707C\u6D4A\u5179\u54A8\u8D44\u59FF\u6ECB\u6DC4\u5B5C\u7D2B\u4ED4\u7C7D\u6ED3\u5B50\u81EA\u6E0D\u5B57\u9B03\u68D5\u8E2A\u5B97\u7EFC\u603B\u7EB5\u90B9\u8D70\u594F\u63CD\u79DF\u8DB3\u5352\u65CF\u7956\u8BC5\u963B\u7EC4\u94BB\u7E82\u5634\u9189\u6700\u7F6A\u5C0A\u9075\u6628\u5DE6\u4F50\u67DE\u505A\u4F5C\u5750\u5EA7"],
      ["d840", "\u8C38", 8, "\u8C42\u8C43\u8C44\u8C45\u8C48\u8C4A\u8C4B\u8C4D", 7, "\u8C56\u8C57\u8C58\u8C59\u8C5B", 5, "\u8C63", 6, "\u8C6C", 6, "\u8C74\u8C75\u8C76\u8C77\u8C7B", 6, "\u8C83\u8C84\u8C86\u8C87"],
      ["d880", "\u8C88\u8C8B\u8C8D", 6, "\u8C95\u8C96\u8C97\u8C99", 20, "\u4E8D\u4E0C\u5140\u4E10\u5EFF\u5345\u4E15\u4E98\u4E1E\u9B32\u5B6C\u5669\u4E28\u79BA\u4E3F\u5315\u4E47\u592D\u723B\u536E\u6C10\u56DF\u80E4\u9997\u6BD3\u777E\u9F17\u4E36\u4E9F\u9F10\u4E5C\u4E69\u4E93\u8288\u5B5B\u556C\u560F\u4EC4\u538D\u539D\u53A3\u53A5\u53AE\u9765\u8D5D\u531A\u53F5\u5326\u532E\u533E\u8D5C\u5366\u5363\u5202\u5208\u520E\u522D\u5233\u523F\u5240\u524C\u525E\u5261\u525C\u84AF\u527D\u5282\u5281\u5290\u5293\u5182\u7F54\u4EBB\u4EC3\u4EC9\u4EC2\u4EE8\u4EE1\u4EEB\u4EDE\u4F1B\u4EF3\u4F22\u4F64\u4EF5\u4F25\u4F27\u4F09\u4F2B\u4F5E\u4F67\u6538\u4F5A\u4F5D"],
      ["d940", "\u8CAE", 62],
      ["d980", "\u8CED", 32, "\u4F5F\u4F57\u4F32\u4F3D\u4F76\u4F74\u4F91\u4F89\u4F83\u4F8F\u4F7E\u4F7B\u4FAA\u4F7C\u4FAC\u4F94\u4FE6\u4FE8\u4FEA\u4FC5\u4FDA\u4FE3\u4FDC\u4FD1\u4FDF\u4FF8\u5029\u504C\u4FF3\u502C\u500F\u502E\u502D\u4FFE\u501C\u500C\u5025\u5028\u507E\u5043\u5055\u5048\u504E\u506C\u507B\u50A5\u50A7\u50A9\u50BA\u50D6\u5106\u50ED\u50EC\u50E6\u50EE\u5107\u510B\u4EDD\u6C3D\u4F58\u4F65\u4FCE\u9FA0\u6C46\u7C74\u516E\u5DFD\u9EC9\u9998\u5181\u5914\u52F9\u530D\u8A07\u5310\u51EB\u5919\u5155\u4EA0\u5156\u4EB3\u886E\u88A4\u4EB5\u8114\u88D2\u7980\u5B34\u8803\u7FB8\u51AB\u51B1\u51BD\u51BC"],
      ["da40", "\u8D0E", 14, "\u8D20\u8D51\u8D52\u8D57\u8D5F\u8D65\u8D68\u8D69\u8D6A\u8D6C\u8D6E\u8D6F\u8D71\u8D72\u8D78", 8, "\u8D82\u8D83\u8D86\u8D87\u8D88\u8D89\u8D8C", 4, "\u8D92\u8D93\u8D95", 9, "\u8DA0\u8DA1"],
      ["da80", "\u8DA2\u8DA4", 12, "\u8DB2\u8DB6\u8DB7\u8DB9\u8DBB\u8DBD\u8DC0\u8DC1\u8DC2\u8DC5\u8DC7\u8DC8\u8DC9\u8DCA\u8DCD\u8DD0\u8DD2\u8DD3\u8DD4\u51C7\u5196\u51A2\u51A5\u8BA0\u8BA6\u8BA7\u8BAA\u8BB4\u8BB5\u8BB7\u8BC2\u8BC3\u8BCB\u8BCF\u8BCE\u8BD2\u8BD3\u8BD4\u8BD6\u8BD8\u8BD9\u8BDC\u8BDF\u8BE0\u8BE4\u8BE8\u8BE9\u8BEE\u8BF0\u8BF3\u8BF6\u8BF9\u8BFC\u8BFF\u8C00\u8C02\u8C04\u8C07\u8C0C\u8C0F\u8C11\u8C12\u8C14\u8C15\u8C16\u8C19\u8C1B\u8C18\u8C1D\u8C1F\u8C20\u8C21\u8C25\u8C27\u8C2A\u8C2B\u8C2E\u8C2F\u8C32\u8C33\u8C35\u8C36\u5369\u537A\u961D\u9622\u9621\u9631\u962A\u963D\u963C\u9642\u9649\u9654\u965F\u9667\u966C\u9672\u9674\u9688\u968D\u9697\u96B0\u9097\u909B\u909D\u9099\u90AC\u90A1\u90B4\u90B3\u90B6\u90BA"],
      ["db40", "\u8DD5\u8DD8\u8DD9\u8DDC\u8DE0\u8DE1\u8DE2\u8DE5\u8DE6\u8DE7\u8DE9\u8DED\u8DEE\u8DF0\u8DF1\u8DF2\u8DF4\u8DF6\u8DFC\u8DFE", 6, "\u8E06\u8E07\u8E08\u8E0B\u8E0D\u8E0E\u8E10\u8E11\u8E12\u8E13\u8E15", 7, "\u8E20\u8E21\u8E24", 4, "\u8E2B\u8E2D\u8E30\u8E32\u8E33\u8E34\u8E36\u8E37\u8E38\u8E3B\u8E3C\u8E3E"],
      ["db80", "\u8E3F\u8E43\u8E45\u8E46\u8E4C", 4, "\u8E53", 5, "\u8E5A", 11, "\u8E67\u8E68\u8E6A\u8E6B\u8E6E\u8E71\u90B8\u90B0\u90CF\u90C5\u90BE\u90D0\u90C4\u90C7\u90D3\u90E6\u90E2\u90DC\u90D7\u90DB\u90EB\u90EF\u90FE\u9104\u9122\u911E\u9123\u9131\u912F\u9139\u9143\u9146\u520D\u5942\u52A2\u52AC\u52AD\u52BE\u54FF\u52D0\u52D6\u52F0\u53DF\u71EE\u77CD\u5EF4\u51F5\u51FC\u9B2F\u53B6\u5F01\u755A\u5DEF\u574C\u57A9\u57A1\u587E\u58BC\u58C5\u58D1\u5729\u572C\u572A\u5733\u5739\u572E\u572F\u575C\u573B\u5742\u5769\u5785\u576B\u5786\u577C\u577B\u5768\u576D\u5776\u5773\u57AD\u57A4\u578C\u57B2\u57CF\u57A7\u57B4\u5793\u57A0\u57D5\u57D8\u57DA\u57D9\u57D2\u57B8\u57F4\u57EF\u57F8\u57E4\u57DD"],
      ["dc40", "\u8E73\u8E75\u8E77", 4, "\u8E7D\u8E7E\u8E80\u8E82\u8E83\u8E84\u8E86\u8E88", 6, "\u8E91\u8E92\u8E93\u8E95", 6, "\u8E9D\u8E9F", 11, "\u8EAD\u8EAE\u8EB0\u8EB1\u8EB3", 6, "\u8EBB", 7],
      ["dc80", "\u8EC3", 10, "\u8ECF", 21, "\u580B\u580D\u57FD\u57ED\u5800\u581E\u5819\u5844\u5820\u5865\u586C\u5881\u5889\u589A\u5880\u99A8\u9F19\u61FF\u8279\u827D\u827F\u828F\u828A\u82A8\u8284\u828E\u8291\u8297\u8299\u82AB\u82B8\u82BE\u82B0\u82C8\u82CA\u82E3\u8298\u82B7\u82AE\u82CB\u82CC\u82C1\u82A9\u82B4\u82A1\u82AA\u829F\u82C4\u82CE\u82A4\u82E1\u8309\u82F7\u82E4\u830F\u8307\u82DC\u82F4\u82D2\u82D8\u830C\u82FB\u82D3\u8311\u831A\u8306\u8314\u8315\u82E0\u82D5\u831C\u8351\u835B\u835C\u8308\u8392\u833C\u8334\u8331\u839B\u835E\u832F\u834F\u8347\u8343\u835F\u8340\u8317\u8360\u832D\u833A\u8333\u8366\u8365"],
      ["dd40", "\u8EE5", 62],
      ["dd80", "\u8F24", 32, "\u8368\u831B\u8369\u836C\u836A\u836D\u836E\u83B0\u8378\u83B3\u83B4\u83A0\u83AA\u8393\u839C\u8385\u837C\u83B6\u83A9\u837D\u83B8\u837B\u8398\u839E\u83A8\u83BA\u83BC\u83C1\u8401\u83E5\u83D8\u5807\u8418\u840B\u83DD\u83FD\u83D6\u841C\u8438\u8411\u8406\u83D4\u83DF\u840F\u8403\u83F8\u83F9\u83EA\u83C5\u83C0\u8426\u83F0\u83E1\u845C\u8451\u845A\u8459\u8473\u8487\u8488\u847A\u8489\u8478\u843C\u8446\u8469\u8476\u848C\u848E\u8431\u846D\u84C1\u84CD\u84D0\u84E6\u84BD\u84D3\u84CA\u84BF\u84BA\u84E0\u84A1\u84B9\u84B4\u8497\u84E5\u84E3\u850C\u750D\u8538\u84F0\u8539\u851F\u853A"],
      ["de40", "\u8F45", 32, "\u8F6A\u8F80\u8F8C\u8F92\u8F9D\u8FA0\u8FA1\u8FA2\u8FA4\u8FA5\u8FA6\u8FA7\u8FAA\u8FAC\u8FAD\u8FAE\u8FAF\u8FB2\u8FB3\u8FB4\u8FB5\u8FB7\u8FB8\u8FBA\u8FBB\u8FBC\u8FBF\u8FC0\u8FC3\u8FC6"],
      ["de80", "\u8FC9", 4, "\u8FCF\u8FD2\u8FD6\u8FD7\u8FDA\u8FE0\u8FE1\u8FE3\u8FE7\u8FEC\u8FEF\u8FF1\u8FF2\u8FF4\u8FF5\u8FF6\u8FFA\u8FFB\u8FFC\u8FFE\u8FFF\u9007\u9008\u900C\u900E\u9013\u9015\u9018\u8556\u853B\u84FF\u84FC\u8559\u8548\u8568\u8564\u855E\u857A\u77A2\u8543\u8572\u857B\u85A4\u85A8\u8587\u858F\u8579\u85AE\u859C\u8585\u85B9\u85B7\u85B0\u85D3\u85C1\u85DC\u85FF\u8627\u8605\u8629\u8616\u863C\u5EFE\u5F08\u593C\u5941\u8037\u5955\u595A\u5958\u530F\u5C22\u5C25\u5C2C\u5C34\u624C\u626A\u629F\u62BB\u62CA\u62DA\u62D7\u62EE\u6322\u62F6\u6339\u634B\u6343\u63AD\u63F6\u6371\u637A\u638E\u63B4\u636D\u63AC\u638A\u6369\u63AE\u63BC\u63F2\u63F8\u63E0\u63FF\u63C4\u63DE\u63CE\u6452\u63C6\u63BE\u6445\u6441\u640B\u641B\u6420\u640C\u6426\u6421\u645E\u6484\u646D\u6496"],
      ["df40", "\u9019\u901C\u9023\u9024\u9025\u9027", 5, "\u9030", 4, "\u9037\u9039\u903A\u903D\u903F\u9040\u9043\u9045\u9046\u9048", 4, "\u904E\u9054\u9055\u9056\u9059\u905A\u905C", 5, "\u9064\u9066\u9067\u9069\u906A\u906B\u906C\u906F", 4, "\u9076", 6, "\u907E\u9081"],
      ["df80", "\u9084\u9085\u9086\u9087\u9089\u908A\u908C", 4, "\u9092\u9094\u9096\u9098\u909A\u909C\u909E\u909F\u90A0\u90A4\u90A5\u90A7\u90A8\u90A9\u90AB\u90AD\u90B2\u90B7\u90BC\u90BD\u90BF\u90C0\u647A\u64B7\u64B8\u6499\u64BA\u64C0\u64D0\u64D7\u64E4\u64E2\u6509\u6525\u652E\u5F0B\u5FD2\u7519\u5F11\u535F\u53F1\u53FD\u53E9\u53E8\u53FB\u5412\u5416\u5406\u544B\u5452\u5453\u5454\u5456\u5443\u5421\u5457\u5459\u5423\u5432\u5482\u5494\u5477\u5471\u5464\u549A\u549B\u5484\u5476\u5466\u549D\u54D0\u54AD\u54C2\u54B4\u54D2\u54A7\u54A6\u54D3\u54D4\u5472\u54A3\u54D5\u54BB\u54BF\u54CC\u54D9\u54DA\u54DC\u54A9\u54AA\u54A4\u54DD\u54CF\u54DE\u551B\u54E7\u5520\u54FD\u5514\u54F3\u5522\u5523\u550F\u5511\u5527\u552A\u5567\u558F\u55B5\u5549\u556D\u5541\u5555\u553F\u5550\u553C"],
      ["e040", "\u90C2\u90C3\u90C6\u90C8\u90C9\u90CB\u90CC\u90CD\u90D2\u90D4\u90D5\u90D6\u90D8\u90D9\u90DA\u90DE\u90DF\u90E0\u90E3\u90E4\u90E5\u90E9\u90EA\u90EC\u90EE\u90F0\u90F1\u90F2\u90F3\u90F5\u90F6\u90F7\u90F9\u90FA\u90FB\u90FC\u90FF\u9100\u9101\u9103\u9105", 19, "\u911A\u911B\u911C"],
      ["e080", "\u911D\u911F\u9120\u9121\u9124", 10, "\u9130\u9132", 6, "\u913A", 8, "\u9144\u5537\u5556\u5575\u5576\u5577\u5533\u5530\u555C\u558B\u55D2\u5583\u55B1\u55B9\u5588\u5581\u559F\u557E\u55D6\u5591\u557B\u55DF\u55BD\u55BE\u5594\u5599\u55EA\u55F7\u55C9\u561F\u55D1\u55EB\u55EC\u55D4\u55E6\u55DD\u55C4\u55EF\u55E5\u55F2\u55F3\u55CC\u55CD\u55E8\u55F5\u55E4\u8F94\u561E\u5608\u560C\u5601\u5624\u5623\u55FE\u5600\u5627\u562D\u5658\u5639\u5657\u562C\u564D\u5662\u5659\u565C\u564C\u5654\u5686\u5664\u5671\u566B\u567B\u567C\u5685\u5693\u56AF\u56D4\u56D7\u56DD\u56E1\u56F5\u56EB\u56F9\u56FF\u5704\u570A\u5709\u571C\u5E0F\u5E19\u5E14\u5E11\u5E31\u5E3B\u5E3C"],
      ["e140", "\u9145\u9147\u9148\u9151\u9153\u9154\u9155\u9156\u9158\u9159\u915B\u915C\u915F\u9160\u9166\u9167\u9168\u916B\u916D\u9173\u917A\u917B\u917C\u9180", 4, "\u9186\u9188\u918A\u918E\u918F\u9193", 6, "\u919C", 5, "\u91A4", 5, "\u91AB\u91AC\u91B0\u91B1\u91B2\u91B3\u91B6\u91B7\u91B8\u91B9\u91BB"],
      ["e180", "\u91BC", 10, "\u91C8\u91CB\u91D0\u91D2", 9, "\u91DD", 8, "\u5E37\u5E44\u5E54\u5E5B\u5E5E\u5E61\u5C8C\u5C7A\u5C8D\u5C90\u5C96\u5C88\u5C98\u5C99\u5C91\u5C9A\u5C9C\u5CB5\u5CA2\u5CBD\u5CAC\u5CAB\u5CB1\u5CA3\u5CC1\u5CB7\u5CC4\u5CD2\u5CE4\u5CCB\u5CE5\u5D02\u5D03\u5D27\u5D26\u5D2E\u5D24\u5D1E\u5D06\u5D1B\u5D58\u5D3E\u5D34\u5D3D\u5D6C\u5D5B\u5D6F\u5D5D\u5D6B\u5D4B\u5D4A\u5D69\u5D74\u5D82\u5D99\u5D9D\u8C73\u5DB7\u5DC5\u5F73\u5F77\u5F82\u5F87\u5F89\u5F8C\u5F95\u5F99\u5F9C\u5FA8\u5FAD\u5FB5\u5FBC\u8862\u5F61\u72AD\u72B0\u72B4\u72B7\u72B8\u72C3\u72C1\u72CE\u72CD\u72D2\u72E8\u72EF\u72E9\u72F2\u72F4\u72F7\u7301\u72F3\u7303\u72FA"],
      ["e240", "\u91E6", 62],
      ["e280", "\u9225", 32, "\u72FB\u7317\u7313\u7321\u730A\u731E\u731D\u7315\u7322\u7339\u7325\u732C\u7338\u7331\u7350\u734D\u7357\u7360\u736C\u736F\u737E\u821B\u5925\u98E7\u5924\u5902\u9963\u9967", 5, "\u9974\u9977\u997D\u9980\u9984\u9987\u998A\u998D\u9990\u9991\u9993\u9994\u9995\u5E80\u5E91\u5E8B\u5E96\u5EA5\u5EA0\u5EB9\u5EB5\u5EBE\u5EB3\u8D53\u5ED2\u5ED1\u5EDB\u5EE8\u5EEA\u81BA\u5FC4\u5FC9\u5FD6\u5FCF\u6003\u5FEE\u6004\u5FE1\u5FE4\u5FFE\u6005\u6006\u5FEA\u5FED\u5FF8\u6019\u6035\u6026\u601B\u600F\u600D\u6029\u602B\u600A\u603F\u6021\u6078\u6079\u607B\u607A\u6042"],
      ["e340", "\u9246", 45, "\u9275", 16],
      ["e380", "\u9286", 7, "\u928F", 24, "\u606A\u607D\u6096\u609A\u60AD\u609D\u6083\u6092\u608C\u609B\u60EC\u60BB\u60B1\u60DD\u60D8\u60C6\u60DA\u60B4\u6120\u6126\u6115\u6123\u60F4\u6100\u610E\u612B\u614A\u6175\u61AC\u6194\u61A7\u61B7\u61D4\u61F5\u5FDD\u96B3\u95E9\u95EB\u95F1\u95F3\u95F5\u95F6\u95FC\u95FE\u9603\u9604\u9606\u9608\u960A\u960B\u960C\u960D\u960F\u9612\u9615\u9616\u9617\u9619\u961A\u4E2C\u723F\u6215\u6C35\u6C54\u6C5C\u6C4A\u6CA3\u6C85\u6C90\u6C94\u6C8C\u6C68\u6C69\u6C74\u6C76\u6C86\u6CA9\u6CD0\u6CD4\u6CAD\u6CF7\u6CF8\u6CF1\u6CD7\u6CB2\u6CE0\u6CD6\u6CFA\u6CEB\u6CEE\u6CB1\u6CD3\u6CEF\u6CFE"],
      ["e440", "\u92A8", 5, "\u92AF", 24, "\u92C9", 31],
      ["e480", "\u92E9", 32, "\u6D39\u6D27\u6D0C\u6D43\u6D48\u6D07\u6D04\u6D19\u6D0E\u6D2B\u6D4D\u6D2E\u6D35\u6D1A\u6D4F\u6D52\u6D54\u6D33\u6D91\u6D6F\u6D9E\u6DA0\u6D5E\u6D93\u6D94\u6D5C\u6D60\u6D7C\u6D63\u6E1A\u6DC7\u6DC5\u6DDE\u6E0E\u6DBF\u6DE0\u6E11\u6DE6\u6DDD\u6DD9\u6E16\u6DAB\u6E0C\u6DAE\u6E2B\u6E6E\u6E4E\u6E6B\u6EB2\u6E5F\u6E86\u6E53\u6E54\u6E32\u6E25\u6E44\u6EDF\u6EB1\u6E98\u6EE0\u6F2D\u6EE2\u6EA5\u6EA7\u6EBD\u6EBB\u6EB7\u6ED7\u6EB4\u6ECF\u6E8F\u6EC2\u6E9F\u6F62\u6F46\u6F47\u6F24\u6F15\u6EF9\u6F2F\u6F36\u6F4B\u6F74\u6F2A\u6F09\u6F29\u6F89\u6F8D\u6F8C\u6F78\u6F72\u6F7C\u6F7A\u6FD1"],
      ["e540", "\u930A", 51, "\u933F", 10],
      ["e580", "\u934A", 31, "\u936B\u6FC9\u6FA7\u6FB9\u6FB6\u6FC2\u6FE1\u6FEE\u6FDE\u6FE0\u6FEF\u701A\u7023\u701B\u7039\u7035\u704F\u705E\u5B80\u5B84\u5B95\u5B93\u5BA5\u5BB8\u752F\u9A9E\u6434\u5BE4\u5BEE\u8930\u5BF0\u8E47\u8B07\u8FB6\u8FD3\u8FD5\u8FE5\u8FEE\u8FE4\u8FE9\u8FE6\u8FF3\u8FE8\u9005\u9004\u900B\u9026\u9011\u900D\u9016\u9021\u9035\u9036\u902D\u902F\u9044\u9051\u9052\u9050\u9068\u9058\u9062\u905B\u66B9\u9074\u907D\u9082\u9088\u9083\u908B\u5F50\u5F57\u5F56\u5F58\u5C3B\u54AB\u5C50\u5C59\u5B71\u5C63\u5C66\u7FBC\u5F2A\u5F29\u5F2D\u8274\u5F3C\u9B3B\u5C6E\u5981\u5983\u598D\u59A9\u59AA\u59A3"],
      ["e640", "\u936C", 34, "\u9390", 27],
      ["e680", "\u93AC", 29, "\u93CB\u93CC\u93CD\u5997\u59CA\u59AB\u599E\u59A4\u59D2\u59B2\u59AF\u59D7\u59BE\u5A05\u5A06\u59DD\u5A08\u59E3\u59D8\u59F9\u5A0C\u5A09\u5A32\u5A34\u5A11\u5A23\u5A13\u5A40\u5A67\u5A4A\u5A55\u5A3C\u5A62\u5A75\u80EC\u5AAA\u5A9B\u5A77\u5A7A\u5ABE\u5AEB\u5AB2\u5AD2\u5AD4\u5AB8\u5AE0\u5AE3\u5AF1\u5AD6\u5AE6\u5AD8\u5ADC\u5B09\u5B17\u5B16\u5B32\u5B37\u5B40\u5C15\u5C1C\u5B5A\u5B65\u5B73\u5B51\u5B53\u5B62\u9A75\u9A77\u9A78\u9A7A\u9A7F\u9A7D\u9A80\u9A81\u9A85\u9A88\u9A8A\u9A90\u9A92\u9A93\u9A96\u9A98\u9A9B\u9A9C\u9A9D\u9A9F\u9AA0\u9AA2\u9AA3\u9AA5\u9AA7\u7E9F\u7EA1\u7EA3\u7EA5\u7EA8\u7EA9"],
      ["e740", "\u93CE", 7, "\u93D7", 54],
      ["e780", "\u940E", 32, "\u7EAD\u7EB0\u7EBE\u7EC0\u7EC1\u7EC2\u7EC9\u7ECB\u7ECC\u7ED0\u7ED4\u7ED7\u7EDB\u7EE0\u7EE1\u7EE8\u7EEB\u7EEE\u7EEF\u7EF1\u7EF2\u7F0D\u7EF6\u7EFA\u7EFB\u7EFE\u7F01\u7F02\u7F03\u7F07\u7F08\u7F0B\u7F0C\u7F0F\u7F11\u7F12\u7F17\u7F19\u7F1C\u7F1B\u7F1F\u7F21", 6, "\u7F2A\u7F2B\u7F2C\u7F2D\u7F2F", 4, "\u7F35\u5E7A\u757F\u5DDB\u753E\u9095\u738E\u7391\u73AE\u73A2\u739F\u73CF\u73C2\u73D1\u73B7\u73B3\u73C0\u73C9\u73C8\u73E5\u73D9\u987C\u740A\u73E9\u73E7\u73DE\u73BA\u73F2\u740F\u742A\u745B\u7426\u7425\u7428\u7430\u742E\u742C"],
      ["e840", "\u942F", 14, "\u943F", 43, "\u946C\u946D\u946E\u946F"],
      ["e880", "\u9470", 20, "\u9491\u9496\u9498\u94C7\u94CF\u94D3\u94D4\u94DA\u94E6\u94FB\u951C\u9520\u741B\u741A\u7441\u745C\u7457\u7455\u7459\u7477\u746D\u747E\u749C\u748E\u7480\u7481\u7487\u748B\u749E\u74A8\u74A9\u7490\u74A7\u74D2\u74BA\u97EA\u97EB\u97EC\u674C\u6753\u675E\u6748\u6769\u67A5\u6787\u676A\u6773\u6798\u67A7\u6775\u67A8\u679E\u67AD\u678B\u6777\u677C\u67F0\u6809\u67D8\u680A\u67E9\u67B0\u680C\u67D9\u67B5\u67DA\u67B3\u67DD\u6800\u67C3\u67B8\u67E2\u680E\u67C1\u67FD\u6832\u6833\u6860\u6861\u684E\u6862\u6844\u6864\u6883\u681D\u6855\u6866\u6841\u6867\u6840\u683E\u684A\u6849\u6829\u68B5\u688F\u6874\u6877\u6893\u686B\u68C2\u696E\u68FC\u691F\u6920\u68F9"],
      ["e940", "\u9527\u9533\u953D\u9543\u9548\u954B\u9555\u955A\u9560\u956E\u9574\u9575\u9577", 7, "\u9580", 42],
      ["e980", "\u95AB", 32, "\u6924\u68F0\u690B\u6901\u6957\u68E3\u6910\u6971\u6939\u6960\u6942\u695D\u6984\u696B\u6980\u6998\u6978\u6934\u69CC\u6987\u6988\u69CE\u6989\u6966\u6963\u6979\u699B\u69A7\u69BB\u69AB\u69AD\u69D4\u69B1\u69C1\u69CA\u69DF\u6995\u69E0\u698D\u69FF\u6A2F\u69ED\u6A17\u6A18\u6A65\u69F2\u6A44\u6A3E\u6AA0\u6A50\u6A5B\u6A35\u6A8E\u6A79\u6A3D\u6A28\u6A58\u6A7C\u6A91\u6A90\u6AA9\u6A97\u6AAB\u7337\u7352\u6B81\u6B82\u6B87\u6B84\u6B92\u6B93\u6B8D\u6B9A\u6B9B\u6BA1\u6BAA\u8F6B\u8F6D\u8F71\u8F72\u8F73\u8F75\u8F76\u8F78\u8F77\u8F79\u8F7A\u8F7C\u8F7E\u8F81\u8F82\u8F84\u8F87\u8F8B"],
      ["ea40", "\u95CC", 27, "\u95EC\u95FF\u9607\u9613\u9618\u961B\u961E\u9620\u9623", 6, "\u962B\u962C\u962D\u962F\u9630\u9637\u9638\u9639\u963A\u963E\u9641\u9643\u964A\u964E\u964F\u9651\u9652\u9653\u9656\u9657"],
      ["ea80", "\u9658\u9659\u965A\u965C\u965D\u965E\u9660\u9663\u9665\u9666\u966B\u966D", 4, "\u9673\u9678", 12, "\u9687\u9689\u968A\u8F8D\u8F8E\u8F8F\u8F98\u8F9A\u8ECE\u620B\u6217\u621B\u621F\u6222\u6221\u6225\u6224\u622C\u81E7\u74EF\u74F4\u74FF\u750F\u7511\u7513\u6534\u65EE\u65EF\u65F0\u660A\u6619\u6772\u6603\u6615\u6600\u7085\u66F7\u661D\u6634\u6631\u6636\u6635\u8006\u665F\u6654\u6641\u664F\u6656\u6661\u6657\u6677\u6684\u668C\u66A7\u669D\u66BE\u66DB\u66DC\u66E6\u66E9\u8D32\u8D33\u8D36\u8D3B\u8D3D\u8D40\u8D45\u8D46\u8D48\u8D49\u8D47\u8D4D\u8D55\u8D59\u89C7\u89CA\u89CB\u89CC\u89CE\u89CF\u89D0\u89D1\u726E\u729F\u725D\u7266\u726F\u727E\u727F\u7284\u728B\u728D\u728F\u7292\u6308\u6332\u63B0"],
      ["eb40", "\u968C\u968E\u9691\u9692\u9693\u9695\u9696\u969A\u969B\u969D", 9, "\u96A8", 7, "\u96B1\u96B2\u96B4\u96B5\u96B7\u96B8\u96BA\u96BB\u96BF\u96C2\u96C3\u96C8\u96CA\u96CB\u96D0\u96D1\u96D3\u96D4\u96D6", 9, "\u96E1", 6, "\u96EB"],
      ["eb80", "\u96EC\u96ED\u96EE\u96F0\u96F1\u96F2\u96F4\u96F5\u96F8\u96FA\u96FB\u96FC\u96FD\u96FF\u9702\u9703\u9705\u970A\u970B\u970C\u9710\u9711\u9712\u9714\u9715\u9717", 4, "\u971D\u971F\u9720\u643F\u64D8\u8004\u6BEA\u6BF3\u6BFD\u6BF5\u6BF9\u6C05\u6C07\u6C06\u6C0D\u6C15\u6C18\u6C19\u6C1A\u6C21\u6C29\u6C24\u6C2A\u6C32\u6535\u6555\u656B\u724D\u7252\u7256\u7230\u8662\u5216\u809F\u809C\u8093\u80BC\u670A\u80BD\u80B1\u80AB\u80AD\u80B4\u80B7\u80E7\u80E8\u80E9\u80EA\u80DB\u80C2\u80C4\u80D9\u80CD\u80D7\u6710\u80DD\u80EB\u80F1\u80F4\u80ED\u810D\u810E\u80F2\u80FC\u6715\u8112\u8C5A\u8136\u811E\u812C\u8118\u8132\u8148\u814C\u8153\u8174\u8159\u815A\u8171\u8160\u8169\u817C\u817D\u816D\u8167\u584D\u5AB5\u8188\u8182\u8191\u6ED5\u81A3\u81AA\u81CC\u6726\u81CA\u81BB"],
      ["ec40", "\u9721", 8, "\u972B\u972C\u972E\u972F\u9731\u9733", 4, "\u973A\u973B\u973C\u973D\u973F", 18, "\u9754\u9755\u9757\u9758\u975A\u975C\u975D\u975F\u9763\u9764\u9766\u9767\u9768\u976A", 7],
      ["ec80", "\u9772\u9775\u9777", 4, "\u977D", 7, "\u9786", 4, "\u978C\u978E\u978F\u9790\u9793\u9795\u9796\u9797\u9799", 4, "\u81C1\u81A6\u6B24\u6B37\u6B39\u6B43\u6B46\u6B59\u98D1\u98D2\u98D3\u98D5\u98D9\u98DA\u6BB3\u5F40\u6BC2\u89F3\u6590\u9F51\u6593\u65BC\u65C6\u65C4\u65C3\u65CC\u65CE\u65D2\u65D6\u7080\u709C\u7096\u709D\u70BB\u70C0\u70B7\u70AB\u70B1\u70E8\u70CA\u7110\u7113\u7116\u712F\u7131\u7173\u715C\u7168\u7145\u7172\u714A\u7178\u717A\u7198\u71B3\u71B5\u71A8\u71A0\u71E0\u71D4\u71E7\u71F9\u721D\u7228\u706C\u7118\u7166\u71B9\u623E\u623D\u6243\u6248\u6249\u793B\u7940\u7946\u7949\u795B\u795C\u7953\u795A\u7962\u7957\u7960\u796F\u7967\u797A\u7985\u798A\u799A\u79A7\u79B3\u5FD1\u5FD0"],
      ["ed40", "\u979E\u979F\u97A1\u97A2\u97A4", 6, "\u97AC\u97AE\u97B0\u97B1\u97B3\u97B5", 46],
      ["ed80", "\u97E4\u97E5\u97E8\u97EE", 4, "\u97F4\u97F7", 23, "\u603C\u605D\u605A\u6067\u6041\u6059\u6063\u60AB\u6106\u610D\u615D\u61A9\u619D\u61CB\u61D1\u6206\u8080\u807F\u6C93\u6CF6\u6DFC\u77F6\u77F8\u7800\u7809\u7817\u7818\u7811\u65AB\u782D\u781C\u781D\u7839\u783A\u783B\u781F\u783C\u7825\u782C\u7823\u7829\u784E\u786D\u7856\u7857\u7826\u7850\u7847\u784C\u786A\u789B\u7893\u789A\u7887\u789C\u78A1\u78A3\u78B2\u78B9\u78A5\u78D4\u78D9\u78C9\u78EC\u78F2\u7905\u78F4\u7913\u7924\u791E\u7934\u9F9B\u9EF9\u9EFB\u9EFC\u76F1\u7704\u770D\u76F9\u7707\u7708\u771A\u7722\u7719\u772D\u7726\u7735\u7738\u7750\u7751\u7747\u7743\u775A\u7768"],
      ["ee40", "\u980F", 62],
      ["ee80", "\u984E", 32, "\u7762\u7765\u777F\u778D\u777D\u7780\u778C\u7791\u779F\u77A0\u77B0\u77B5\u77BD\u753A\u7540\u754E\u754B\u7548\u755B\u7572\u7579\u7583\u7F58\u7F61\u7F5F\u8A48\u7F68\u7F74\u7F71\u7F79\u7F81\u7F7E\u76CD\u76E5\u8832\u9485\u9486\u9487\u948B\u948A\u948C\u948D\u948F\u9490\u9494\u9497\u9495\u949A\u949B\u949C\u94A3\u94A4\u94AB\u94AA\u94AD\u94AC\u94AF\u94B0\u94B2\u94B4\u94B6", 4, "\u94BC\u94BD\u94BF\u94C4\u94C8", 6, "\u94D0\u94D1\u94D2\u94D5\u94D6\u94D7\u94D9\u94D8\u94DB\u94DE\u94DF\u94E0\u94E2\u94E4\u94E5\u94E7\u94E8\u94EA"],
      ["ef40", "\u986F", 5, "\u988B\u988E\u9892\u9895\u9899\u98A3\u98A8", 37, "\u98CF\u98D0\u98D4\u98D6\u98D7\u98DB\u98DC\u98DD\u98E0", 4],
      ["ef80", "\u98E5\u98E6\u98E9", 30, "\u94E9\u94EB\u94EE\u94EF\u94F3\u94F4\u94F5\u94F7\u94F9\u94FC\u94FD\u94FF\u9503\u9502\u9506\u9507\u9509\u950A\u950D\u950E\u950F\u9512", 4, "\u9518\u951B\u951D\u951E\u951F\u9522\u952A\u952B\u9529\u952C\u9531\u9532\u9534\u9536\u9537\u9538\u953C\u953E\u953F\u9542\u9535\u9544\u9545\u9546\u9549\u954C\u954E\u954F\u9552\u9553\u9554\u9556\u9557\u9558\u9559\u955B\u955E\u955F\u955D\u9561\u9562\u9564", 8, "\u956F\u9571\u9572\u9573\u953A\u77E7\u77EC\u96C9\u79D5\u79ED\u79E3\u79EB\u7A06\u5D47\u7A03\u7A02\u7A1E\u7A14"],
      ["f040", "\u9908", 4, "\u990E\u990F\u9911", 28, "\u992F", 26],
      ["f080", "\u994A", 9, "\u9956", 12, "\u9964\u9966\u9973\u9978\u9979\u997B\u997E\u9982\u9983\u9989\u7A39\u7A37\u7A51\u9ECF\u99A5\u7A70\u7688\u768E\u7693\u7699\u76A4\u74DE\u74E0\u752C\u9E20\u9E22\u9E28", 4, "\u9E32\u9E31\u9E36\u9E38\u9E37\u9E39\u9E3A\u9E3E\u9E41\u9E42\u9E44\u9E46\u9E47\u9E48\u9E49\u9E4B\u9E4C\u9E4E\u9E51\u9E55\u9E57\u9E5A\u9E5B\u9E5C\u9E5E\u9E63\u9E66", 6, "\u9E71\u9E6D\u9E73\u7592\u7594\u7596\u75A0\u759D\u75AC\u75A3\u75B3\u75B4\u75B8\u75C4\u75B1\u75B0\u75C3\u75C2\u75D6\u75CD\u75E3\u75E8\u75E6\u75E4\u75EB\u75E7\u7603\u75F1\u75FC\u75FF\u7610\u7600\u7605\u760C\u7617\u760A\u7625\u7618\u7615\u7619"],
      ["f140", "\u998C\u998E\u999A", 10, "\u99A6\u99A7\u99A9", 47],
      ["f180", "\u99D9", 32, "\u761B\u763C\u7622\u7620\u7640\u762D\u7630\u763F\u7635\u7643\u763E\u7633\u764D\u765E\u7654\u765C\u7656\u766B\u766F\u7FCA\u7AE6\u7A78\u7A79\u7A80\u7A86\u7A88\u7A95\u7AA6\u7AA0\u7AAC\u7AA8\u7AAD\u7AB3\u8864\u8869\u8872\u887D\u887F\u8882\u88A2\u88C6\u88B7\u88BC\u88C9\u88E2\u88CE\u88E3\u88E5\u88F1\u891A\u88FC\u88E8\u88FE\u88F0\u8921\u8919\u8913\u891B\u890A\u8934\u892B\u8936\u8941\u8966\u897B\u758B\u80E5\u76B2\u76B4\u77DC\u8012\u8014\u8016\u801C\u8020\u8022\u8025\u8026\u8027\u8029\u8028\u8031\u800B\u8035\u8043\u8046\u804D\u8052\u8069\u8071\u8983\u9878\u9880\u9883"],
      ["f240", "\u99FA", 62],
      ["f280", "\u9A39", 32, "\u9889\u988C\u988D\u988F\u9894\u989A\u989B\u989E\u989F\u98A1\u98A2\u98A5\u98A6\u864D\u8654\u866C\u866E\u867F\u867A\u867C\u867B\u86A8\u868D\u868B\u86AC\u869D\u86A7\u86A3\u86AA\u8693\u86A9\u86B6\u86C4\u86B5\u86CE\u86B0\u86BA\u86B1\u86AF\u86C9\u86CF\u86B4\u86E9\u86F1\u86F2\u86ED\u86F3\u86D0\u8713\u86DE\u86F4\u86DF\u86D8\u86D1\u8703\u8707\u86F8\u8708\u870A\u870D\u8709\u8723\u873B\u871E\u8725\u872E\u871A\u873E\u8748\u8734\u8731\u8729\u8737\u873F\u8782\u8722\u877D\u877E\u877B\u8760\u8770\u874C\u876E\u878B\u8753\u8763\u877C\u8764\u8759\u8765\u8793\u87AF\u87A8\u87D2"],
      ["f340", "\u9A5A", 17, "\u9A72\u9A83\u9A89\u9A8D\u9A8E\u9A94\u9A95\u9A99\u9AA6\u9AA9", 6, "\u9AB2\u9AB3\u9AB4\u9AB5\u9AB9\u9ABB\u9ABD\u9ABE\u9ABF\u9AC3\u9AC4\u9AC6", 4, "\u9ACD\u9ACE\u9ACF\u9AD0\u9AD2\u9AD4\u9AD5\u9AD6\u9AD7\u9AD9\u9ADA\u9ADB\u9ADC"],
      ["f380", "\u9ADD\u9ADE\u9AE0\u9AE2\u9AE3\u9AE4\u9AE5\u9AE7\u9AE8\u9AE9\u9AEA\u9AEC\u9AEE\u9AF0", 8, "\u9AFA\u9AFC", 6, "\u9B04\u9B05\u9B06\u87C6\u8788\u8785\u87AD\u8797\u8783\u87AB\u87E5\u87AC\u87B5\u87B3\u87CB\u87D3\u87BD\u87D1\u87C0\u87CA\u87DB\u87EA\u87E0\u87EE\u8816\u8813\u87FE\u880A\u881B\u8821\u8839\u883C\u7F36\u7F42\u7F44\u7F45\u8210\u7AFA\u7AFD\u7B08\u7B03\u7B04\u7B15\u7B0A\u7B2B\u7B0F\u7B47\u7B38\u7B2A\u7B19\u7B2E\u7B31\u7B20\u7B25\u7B24\u7B33\u7B3E\u7B1E\u7B58\u7B5A\u7B45\u7B75\u7B4C\u7B5D\u7B60\u7B6E\u7B7B\u7B62\u7B72\u7B71\u7B90\u7BA6\u7BA7\u7BB8\u7BAC\u7B9D\u7BA8\u7B85\u7BAA\u7B9C\u7BA2\u7BAB\u7BB4\u7BD1\u7BC1\u7BCC\u7BDD\u7BDA\u7BE5\u7BE6\u7BEA\u7C0C\u7BFE\u7BFC\u7C0F\u7C16\u7C0B"],
      ["f440", "\u9B07\u9B09", 5, "\u9B10\u9B11\u9B12\u9B14", 10, "\u9B20\u9B21\u9B22\u9B24", 10, "\u9B30\u9B31\u9B33", 7, "\u9B3D\u9B3E\u9B3F\u9B40\u9B46\u9B4A\u9B4B\u9B4C\u9B4E\u9B50\u9B52\u9B53\u9B55", 5],
      ["f480", "\u9B5B", 32, "\u7C1F\u7C2A\u7C26\u7C38\u7C41\u7C40\u81FE\u8201\u8202\u8204\u81EC\u8844\u8221\u8222\u8223\u822D\u822F\u8228\u822B\u8238\u823B\u8233\u8234\u823E\u8244\u8249\u824B\u824F\u825A\u825F\u8268\u887E\u8885\u8888\u88D8\u88DF\u895E\u7F9D\u7F9F\u7FA7\u7FAF\u7FB0\u7FB2\u7C7C\u6549\u7C91\u7C9D\u7C9C\u7C9E\u7CA2\u7CB2\u7CBC\u7CBD\u7CC1\u7CC7\u7CCC\u7CCD\u7CC8\u7CC5\u7CD7\u7CE8\u826E\u66A8\u7FBF\u7FCE\u7FD5\u7FE5\u7FE1\u7FE6\u7FE9\u7FEE\u7FF3\u7CF8\u7D77\u7DA6\u7DAE\u7E47\u7E9B\u9EB8\u9EB4\u8D73\u8D84\u8D94\u8D91\u8DB1\u8D67\u8D6D\u8C47\u8C49\u914A\u9150\u914E\u914F\u9164"],
      ["f540", "\u9B7C", 62],
      ["f580", "\u9BBB", 32, "\u9162\u9161\u9170\u9169\u916F\u917D\u917E\u9172\u9174\u9179\u918C\u9185\u9190\u918D\u9191\u91A2\u91A3\u91AA\u91AD\u91AE\u91AF\u91B5\u91B4\u91BA\u8C55\u9E7E\u8DB8\u8DEB\u8E05\u8E59\u8E69\u8DB5\u8DBF\u8DBC\u8DBA\u8DC4\u8DD6\u8DD7\u8DDA\u8DDE\u8DCE\u8DCF\u8DDB\u8DC6\u8DEC\u8DF7\u8DF8\u8DE3\u8DF9\u8DFB\u8DE4\u8E09\u8DFD\u8E14\u8E1D\u8E1F\u8E2C\u8E2E\u8E23\u8E2F\u8E3A\u8E40\u8E39\u8E35\u8E3D\u8E31\u8E49\u8E41\u8E42\u8E51\u8E52\u8E4A\u8E70\u8E76\u8E7C\u8E6F\u8E74\u8E85\u8E8F\u8E94\u8E90\u8E9C\u8E9E\u8C78\u8C82\u8C8A\u8C85\u8C98\u8C94\u659B\u89D6\u89DE\u89DA\u89DC"],
      ["f640", "\u9BDC", 62],
      ["f680", "\u9C1B", 32, "\u89E5\u89EB\u89EF\u8A3E\u8B26\u9753\u96E9\u96F3\u96EF\u9706\u9701\u9708\u970F\u970E\u972A\u972D\u9730\u973E\u9F80\u9F83\u9F85", 5, "\u9F8C\u9EFE\u9F0B\u9F0D\u96B9\u96BC\u96BD\u96CE\u96D2\u77BF\u96E0\u928E\u92AE\u92C8\u933E\u936A\u93CA\u938F\u943E\u946B\u9C7F\u9C82\u9C85\u9C86\u9C87\u9C88\u7A23\u9C8B\u9C8E\u9C90\u9C91\u9C92\u9C94\u9C95\u9C9A\u9C9B\u9C9E", 5, "\u9CA5", 4, "\u9CAB\u9CAD\u9CAE\u9CB0", 7, "\u9CBA\u9CBB\u9CBC\u9CBD\u9CC4\u9CC5\u9CC6\u9CC7\u9CCA\u9CCB"],
      ["f740", "\u9C3C", 62],
      ["f780", "\u9C7B\u9C7D\u9C7E\u9C80\u9C83\u9C84\u9C89\u9C8A\u9C8C\u9C8F\u9C93\u9C96\u9C97\u9C98\u9C99\u9C9D\u9CAA\u9CAC\u9CAF\u9CB9\u9CBE", 4, "\u9CC8\u9CC9\u9CD1\u9CD2\u9CDA\u9CDB\u9CE0\u9CE1\u9CCC", 4, "\u9CD3\u9CD4\u9CD5\u9CD7\u9CD8\u9CD9\u9CDC\u9CDD\u9CDF\u9CE2\u977C\u9785\u9791\u9792\u9794\u97AF\u97AB\u97A3\u97B2\u97B4\u9AB1\u9AB0\u9AB7\u9E58\u9AB6\u9ABA\u9ABC\u9AC1\u9AC0\u9AC5\u9AC2\u9ACB\u9ACC\u9AD1\u9B45\u9B43\u9B47\u9B49\u9B48\u9B4D\u9B51\u98E8\u990D\u992E\u9955\u9954\u9ADF\u9AE1\u9AE6\u9AEF\u9AEB\u9AFB\u9AED\u9AF9\u9B08\u9B0F\u9B13\u9B1F\u9B23\u9EBD\u9EBE\u7E3B\u9E82\u9E87\u9E88\u9E8B\u9E92\u93D6\u9E9D\u9E9F\u9EDB\u9EDC\u9EDD\u9EE0\u9EDF\u9EE2\u9EE9\u9EE7\u9EE5\u9EEA\u9EEF\u9F22\u9F2C\u9F2F\u9F39\u9F37\u9F3D\u9F3E\u9F44"],
      ["f840", "\u9CE3", 62],
      ["f880", "\u9D22", 32],
      ["f940", "\u9D43", 62],
      ["f980", "\u9D82", 32],
      ["fa40", "\u9DA3", 62],
      ["fa80", "\u9DE2", 32],
      ["fb40", "\u9E03", 27, "\u9E24\u9E27\u9E2E\u9E30\u9E34\u9E3B\u9E3C\u9E40\u9E4D\u9E50\u9E52\u9E53\u9E54\u9E56\u9E59\u9E5D\u9E5F\u9E60\u9E61\u9E62\u9E65\u9E6E\u9E6F\u9E72\u9E74", 9, "\u9E80"],
      ["fb80", "\u9E81\u9E83\u9E84\u9E85\u9E86\u9E89\u9E8A\u9E8C", 5, "\u9E94", 8, "\u9E9E\u9EA0", 5, "\u9EA7\u9EA8\u9EA9\u9EAA"],
      ["fc40", "\u9EAB", 8, "\u9EB5\u9EB6\u9EB7\u9EB9\u9EBA\u9EBC\u9EBF", 4, "\u9EC5\u9EC6\u9EC7\u9EC8\u9ECA\u9ECB\u9ECC\u9ED0\u9ED2\u9ED3\u9ED5\u9ED6\u9ED7\u9ED9\u9EDA\u9EDE\u9EE1\u9EE3\u9EE4\u9EE6\u9EE8\u9EEB\u9EEC\u9EED\u9EEE\u9EF0", 8, "\u9EFA\u9EFD\u9EFF", 6],
      ["fc80", "\u9F06", 4, "\u9F0C\u9F0F\u9F11\u9F12\u9F14\u9F15\u9F16\u9F18\u9F1A", 5, "\u9F21\u9F23", 8, "\u9F2D\u9F2E\u9F30\u9F31"],
      ["fd40", "\u9F32", 4, "\u9F38\u9F3A\u9F3C\u9F3F", 4, "\u9F45", 10, "\u9F52", 38],
      ["fd80", "\u9F79", 5, "\u9F81\u9F82\u9F8D", 11, "\u9F9C\u9F9D\u9F9E\u9FA1", 4, "\uF92C\uF979\uF995\uF9E7\uF9F1"],
      ["fe40", "\uFA0C\uFA0D\uFA0E\uFA0F\uFA11\uFA13\uFA14\uFA18\uFA1F\uFA20\uFA21\uFA23\uFA24\uFA27\uFA28\uFA29"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS({
  "node_modules/iconv-lite/encodings/tables/gbk-added.json"(exports2, module2) {
    module2.exports = [
      ["a140", "\uE4C6", 62],
      ["a180", "\uE505", 32],
      ["a240", "\uE526", 62],
      ["a280", "\uE565", 32],
      ["a2ab", "\uE766", 5],
      ["a2e3", "\u20AC\uE76D"],
      ["a2ef", "\uE76E\uE76F"],
      ["a2fd", "\uE770\uE771"],
      ["a340", "\uE586", 62],
      ["a380", "\uE5C5", 31, "\u3000"],
      ["a440", "\uE5E6", 62],
      ["a480", "\uE625", 32],
      ["a4f4", "\uE772", 10],
      ["a540", "\uE646", 62],
      ["a580", "\uE685", 32],
      ["a5f7", "\uE77D", 7],
      ["a640", "\uE6A6", 62],
      ["a680", "\uE6E5", 32],
      ["a6b9", "\uE785", 7],
      ["a6d9", "\uE78D", 6],
      ["a6ec", "\uE794\uE795"],
      ["a6f3", "\uE796"],
      ["a6f6", "\uE797", 8],
      ["a740", "\uE706", 62],
      ["a780", "\uE745", 32],
      ["a7c2", "\uE7A0", 14],
      ["a7f2", "\uE7AF", 12],
      ["a896", "\uE7BC", 10],
      ["a8bc", "\u1E3F"],
      ["a8bf", "\u01F9"],
      ["a8c1", "\uE7C9\uE7CA\uE7CB\uE7CC"],
      ["a8ea", "\uE7CD", 20],
      ["a958", "\uE7E2"],
      ["a95b", "\uE7E3"],
      ["a95d", "\uE7E4\uE7E5\uE7E6"],
      ["a989", "\u303E\u2FF0", 11],
      ["a997", "\uE7F4", 12],
      ["a9f0", "\uE801", 14],
      ["aaa1", "\uE000", 93],
      ["aba1", "\uE05E", 93],
      ["aca1", "\uE0BC", 93],
      ["ada1", "\uE11A", 93],
      ["aea1", "\uE178", 93],
      ["afa1", "\uE1D6", 93],
      ["d7fa", "\uE810", 4],
      ["f8a1", "\uE234", 93],
      ["f9a1", "\uE292", 93],
      ["faa1", "\uE2F0", 93],
      ["fba1", "\uE34E", 93],
      ["fca1", "\uE3AC", 93],
      ["fda1", "\uE40A", 93],
      ["fe50", "\u2E81\uE816\uE817\uE818\u2E84\u3473\u3447\u2E88\u2E8B\uE81E\u359E\u361A\u360E\u2E8C\u2E97\u396E\u3918\uE826\u39CF\u39DF\u3A73\u39D0\uE82B\uE82C\u3B4E\u3C6E\u3CE0\u2EA7\uE831\uE832\u2EAA\u4056\u415F\u2EAE\u4337\u2EB3\u2EB6\u2EB7\uE83B\u43B1\u43AC\u2EBB\u43DD\u44D6\u4661\u464C\uE843"],
      ["fe80", "\u4723\u4729\u477C\u478D\u2ECA\u4947\u497A\u497D\u4982\u4983\u4985\u4986\u499F\u499B\u49B7\u49B6\uE854\uE855\u4CA3\u4C9F\u4CA0\u4CA1\u4C77\u4CA2\u4D13", 6, "\u4DAE\uE864\uE468", 93],
      ["8135f437", "\uE7C7"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS({
  "node_modules/iconv-lite/encodings/tables/gb18030-ranges.json"(exports2, module2) {
    module2.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3] };
  }
});

// node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp949.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["8141", "\uAC02\uAC03\uAC05\uAC06\uAC0B", 4, "\uAC18\uAC1E\uAC1F\uAC21\uAC22\uAC23\uAC25", 6, "\uAC2E\uAC32\uAC33\uAC34"],
      ["8161", "\uAC35\uAC36\uAC37\uAC3A\uAC3B\uAC3D\uAC3E\uAC3F\uAC41", 9, "\uAC4C\uAC4E", 5, "\uAC55"],
      ["8181", "\uAC56\uAC57\uAC59\uAC5A\uAC5B\uAC5D", 18, "\uAC72\uAC73\uAC75\uAC76\uAC79\uAC7B", 4, "\uAC82\uAC87\uAC88\uAC8D\uAC8E\uAC8F\uAC91\uAC92\uAC93\uAC95", 6, "\uAC9E\uACA2", 5, "\uACAB\uACAD\uACAE\uACB1", 6, "\uACBA\uACBE\uACBF\uACC0\uACC2\uACC3\uACC5\uACC6\uACC7\uACC9\uACCA\uACCB\uACCD", 7, "\uACD6\uACD8", 7, "\uACE2\uACE3\uACE5\uACE6\uACE9\uACEB\uACED\uACEE\uACF2\uACF4\uACF7", 4, "\uACFE\uACFF\uAD01\uAD02\uAD03\uAD05\uAD07", 4, "\uAD0E\uAD10\uAD12\uAD13"],
      ["8241", "\uAD14\uAD15\uAD16\uAD17\uAD19\uAD1A\uAD1B\uAD1D\uAD1E\uAD1F\uAD21", 7, "\uAD2A\uAD2B\uAD2E", 5],
      ["8261", "\uAD36\uAD37\uAD39\uAD3A\uAD3B\uAD3D", 6, "\uAD46\uAD48\uAD4A", 5, "\uAD51\uAD52\uAD53\uAD55\uAD56\uAD57"],
      ["8281", "\uAD59", 7, "\uAD62\uAD64", 7, "\uAD6E\uAD6F\uAD71\uAD72\uAD77\uAD78\uAD79\uAD7A\uAD7E\uAD80\uAD83", 4, "\uAD8A\uAD8B\uAD8D\uAD8E\uAD8F\uAD91", 10, "\uAD9E", 5, "\uADA5", 17, "\uADB8", 7, "\uADC2\uADC3\uADC5\uADC6\uADC7\uADC9", 6, "\uADD2\uADD4", 7, "\uADDD\uADDE\uADDF\uADE1\uADE2\uADE3\uADE5", 18],
      ["8341", "\uADFA\uADFB\uADFD\uADFE\uAE02", 5, "\uAE0A\uAE0C\uAE0E", 5, "\uAE15", 7],
      ["8361", "\uAE1D", 18, "\uAE32\uAE33\uAE35\uAE36\uAE39\uAE3B\uAE3C"],
      ["8381", "\uAE3D\uAE3E\uAE3F\uAE42\uAE44\uAE47\uAE48\uAE49\uAE4B\uAE4F\uAE51\uAE52\uAE53\uAE55\uAE57", 4, "\uAE5E\uAE62\uAE63\uAE64\uAE66\uAE67\uAE6A\uAE6B\uAE6D\uAE6E\uAE6F\uAE71", 6, "\uAE7A\uAE7E", 5, "\uAE86", 5, "\uAE8D", 46, "\uAEBF\uAEC1\uAEC2\uAEC3\uAEC5", 6, "\uAECE\uAED2", 5, "\uAEDA\uAEDB\uAEDD", 8],
      ["8441", "\uAEE6\uAEE7\uAEE9\uAEEA\uAEEC\uAEEE", 5, "\uAEF5\uAEF6\uAEF7\uAEF9\uAEFA\uAEFB\uAEFD", 8],
      ["8461", "\uAF06\uAF09\uAF0A\uAF0B\uAF0C\uAF0E\uAF0F\uAF11", 18],
      ["8481", "\uAF24", 7, "\uAF2E\uAF2F\uAF31\uAF33\uAF35", 6, "\uAF3E\uAF40\uAF44\uAF45\uAF46\uAF47\uAF4A", 5, "\uAF51", 10, "\uAF5E", 5, "\uAF66", 18, "\uAF7A", 5, "\uAF81\uAF82\uAF83\uAF85\uAF86\uAF87\uAF89", 6, "\uAF92\uAF93\uAF94\uAF96", 5, "\uAF9D", 26, "\uAFBA\uAFBB\uAFBD\uAFBE"],
      ["8541", "\uAFBF\uAFC1", 5, "\uAFCA\uAFCC\uAFCF", 4, "\uAFD5", 6, "\uAFDD", 4],
      ["8561", "\uAFE2", 5, "\uAFEA", 5, "\uAFF2\uAFF3\uAFF5\uAFF6\uAFF7\uAFF9", 6, "\uB002\uB003"],
      ["8581", "\uB005", 6, "\uB00D\uB00E\uB00F\uB011\uB012\uB013\uB015", 6, "\uB01E", 9, "\uB029", 26, "\uB046\uB047\uB049\uB04B\uB04D\uB04F\uB050\uB051\uB052\uB056\uB058\uB05A\uB05B\uB05C\uB05E", 29, "\uB07E\uB07F\uB081\uB082\uB083\uB085", 6, "\uB08E\uB090\uB092", 5, "\uB09B\uB09D\uB09E\uB0A3\uB0A4"],
      ["8641", "\uB0A5\uB0A6\uB0A7\uB0AA\uB0B0\uB0B2\uB0B6\uB0B7\uB0B9\uB0BA\uB0BB\uB0BD", 6, "\uB0C6\uB0CA", 5, "\uB0D2"],
      ["8661", "\uB0D3\uB0D5\uB0D6\uB0D7\uB0D9", 6, "\uB0E1\uB0E2\uB0E3\uB0E4\uB0E6", 10],
      ["8681", "\uB0F1", 22, "\uB10A\uB10D\uB10E\uB10F\uB111\uB114\uB115\uB116\uB117\uB11A\uB11E", 4, "\uB126\uB127\uB129\uB12A\uB12B\uB12D", 6, "\uB136\uB13A", 5, "\uB142\uB143\uB145\uB146\uB147\uB149", 6, "\uB152\uB153\uB156\uB157\uB159\uB15A\uB15B\uB15D\uB15E\uB15F\uB161", 22, "\uB17A\uB17B\uB17D\uB17E\uB17F\uB181\uB183", 4, "\uB18A\uB18C\uB18E\uB18F\uB190\uB191\uB195\uB196\uB197\uB199\uB19A\uB19B\uB19D"],
      ["8741", "\uB19E", 9, "\uB1A9", 15],
      ["8761", "\uB1B9", 18, "\uB1CD\uB1CE\uB1CF\uB1D1\uB1D2\uB1D3\uB1D5"],
      ["8781", "\uB1D6", 5, "\uB1DE\uB1E0", 7, "\uB1EA\uB1EB\uB1ED\uB1EE\uB1EF\uB1F1", 7, "\uB1FA\uB1FC\uB1FE", 5, "\uB206\uB207\uB209\uB20A\uB20D", 6, "\uB216\uB218\uB21A", 5, "\uB221", 18, "\uB235", 6, "\uB23D", 26, "\uB259\uB25A\uB25B\uB25D\uB25E\uB25F\uB261", 6, "\uB26A", 4],
      ["8841", "\uB26F", 4, "\uB276", 5, "\uB27D", 6, "\uB286\uB287\uB288\uB28A", 4],
      ["8861", "\uB28F\uB292\uB293\uB295\uB296\uB297\uB29B", 4, "\uB2A2\uB2A4\uB2A7\uB2A8\uB2A9\uB2AB\uB2AD\uB2AE\uB2AF\uB2B1\uB2B2\uB2B3\uB2B5\uB2B6\uB2B7"],
      ["8881", "\uB2B8", 15, "\uB2CA\uB2CB\uB2CD\uB2CE\uB2CF\uB2D1\uB2D3", 4, "\uB2DA\uB2DC\uB2DE\uB2DF\uB2E0\uB2E1\uB2E3\uB2E7\uB2E9\uB2EA\uB2F0\uB2F1\uB2F2\uB2F6\uB2FC\uB2FD\uB2FE\uB302\uB303\uB305\uB306\uB307\uB309", 6, "\uB312\uB316", 5, "\uB31D", 54, "\uB357\uB359\uB35A\uB35D\uB360\uB361\uB362\uB363"],
      ["8941", "\uB366\uB368\uB36A\uB36C\uB36D\uB36F\uB372\uB373\uB375\uB376\uB377\uB379", 6, "\uB382\uB386", 5, "\uB38D"],
      ["8961", "\uB38E\uB38F\uB391\uB392\uB393\uB395", 10, "\uB3A2", 5, "\uB3A9\uB3AA\uB3AB\uB3AD"],
      ["8981", "\uB3AE", 21, "\uB3C6\uB3C7\uB3C9\uB3CA\uB3CD\uB3CF\uB3D1\uB3D2\uB3D3\uB3D6\uB3D8\uB3DA\uB3DC\uB3DE\uB3DF\uB3E1\uB3E2\uB3E3\uB3E5\uB3E6\uB3E7\uB3E9", 18, "\uB3FD", 18, "\uB411", 6, "\uB419\uB41A\uB41B\uB41D\uB41E\uB41F\uB421", 6, "\uB42A\uB42C", 7, "\uB435", 15],
      ["8a41", "\uB445", 10, "\uB452\uB453\uB455\uB456\uB457\uB459", 6, "\uB462\uB464\uB466"],
      ["8a61", "\uB467", 4, "\uB46D", 18, "\uB481\uB482"],
      ["8a81", "\uB483", 4, "\uB489", 19, "\uB49E", 5, "\uB4A5\uB4A6\uB4A7\uB4A9\uB4AA\uB4AB\uB4AD", 7, "\uB4B6\uB4B8\uB4BA", 5, "\uB4C1\uB4C2\uB4C3\uB4C5\uB4C6\uB4C7\uB4C9", 6, "\uB4D1\uB4D2\uB4D3\uB4D4\uB4D6", 5, "\uB4DE\uB4DF\uB4E1\uB4E2\uB4E5\uB4E7", 4, "\uB4EE\uB4F0\uB4F2", 5, "\uB4F9", 26, "\uB516\uB517\uB519\uB51A\uB51D"],
      ["8b41", "\uB51E", 5, "\uB526\uB52B", 4, "\uB532\uB533\uB535\uB536\uB537\uB539", 6, "\uB542\uB546"],
      ["8b61", "\uB547\uB548\uB549\uB54A\uB54E\uB54F\uB551\uB552\uB553\uB555", 6, "\uB55E\uB562", 8],
      ["8b81", "\uB56B", 52, "\uB5A2\uB5A3\uB5A5\uB5A6\uB5A7\uB5A9\uB5AC\uB5AD\uB5AE\uB5AF\uB5B2\uB5B6", 4, "\uB5BE\uB5BF\uB5C1\uB5C2\uB5C3\uB5C5", 6, "\uB5CE\uB5D2", 5, "\uB5D9", 18, "\uB5ED", 18],
      ["8c41", "\uB600", 15, "\uB612\uB613\uB615\uB616\uB617\uB619", 4],
      ["8c61", "\uB61E", 6, "\uB626", 5, "\uB62D", 6, "\uB635", 5],
      ["8c81", "\uB63B", 12, "\uB649", 26, "\uB665\uB666\uB667\uB669", 50, "\uB69E\uB69F\uB6A1\uB6A2\uB6A3\uB6A5", 5, "\uB6AD\uB6AE\uB6AF\uB6B0\uB6B2", 16],
      ["8d41", "\uB6C3", 16, "\uB6D5", 8],
      ["8d61", "\uB6DE", 17, "\uB6F1\uB6F2\uB6F3\uB6F5\uB6F6\uB6F7\uB6F9\uB6FA"],
      ["8d81", "\uB6FB", 4, "\uB702\uB703\uB704\uB706", 33, "\uB72A\uB72B\uB72D\uB72E\uB731", 6, "\uB73A\uB73C", 7, "\uB745\uB746\uB747\uB749\uB74A\uB74B\uB74D", 6, "\uB756", 9, "\uB761\uB762\uB763\uB765\uB766\uB767\uB769", 6, "\uB772\uB774\uB776", 5, "\uB77E\uB77F\uB781\uB782\uB783\uB785", 6, "\uB78E\uB793\uB794\uB795\uB79A\uB79B\uB79D\uB79E"],
      ["8e41", "\uB79F\uB7A1", 6, "\uB7AA\uB7AE", 5, "\uB7B6\uB7B7\uB7B9", 8],
      ["8e61", "\uB7C2", 4, "\uB7C8\uB7CA", 19],
      ["8e81", "\uB7DE", 13, "\uB7EE\uB7EF\uB7F1\uB7F2\uB7F3\uB7F5", 6, "\uB7FE\uB802", 4, "\uB80A\uB80B\uB80D\uB80E\uB80F\uB811", 6, "\uB81A\uB81C\uB81E", 5, "\uB826\uB827\uB829\uB82A\uB82B\uB82D", 6, "\uB836\uB83A", 5, "\uB841\uB842\uB843\uB845", 11, "\uB852\uB854", 7, "\uB85E\uB85F\uB861\uB862\uB863\uB865", 6, "\uB86E\uB870\uB872", 5, "\uB879\uB87A\uB87B\uB87D", 7],
      ["8f41", "\uB885", 7, "\uB88E", 17],
      ["8f61", "\uB8A0", 7, "\uB8A9", 6, "\uB8B1\uB8B2\uB8B3\uB8B5\uB8B6\uB8B7\uB8B9", 4],
      ["8f81", "\uB8BE\uB8BF\uB8C2\uB8C4\uB8C6", 5, "\uB8CD\uB8CE\uB8CF\uB8D1\uB8D2\uB8D3\uB8D5", 7, "\uB8DE\uB8E0\uB8E2", 5, "\uB8EA\uB8EB\uB8ED\uB8EE\uB8EF\uB8F1", 6, "\uB8FA\uB8FC\uB8FE", 5, "\uB905", 18, "\uB919", 6, "\uB921", 26, "\uB93E\uB93F\uB941\uB942\uB943\uB945", 6, "\uB94D\uB94E\uB950\uB952", 5],
      ["9041", "\uB95A\uB95B\uB95D\uB95E\uB95F\uB961", 6, "\uB96A\uB96C\uB96E", 5, "\uB976\uB977\uB979\uB97A\uB97B\uB97D"],
      ["9061", "\uB97E", 5, "\uB986\uB988\uB98B\uB98C\uB98F", 15],
      ["9081", "\uB99F", 12, "\uB9AE\uB9AF\uB9B1\uB9B2\uB9B3\uB9B5", 6, "\uB9BE\uB9C0\uB9C2", 5, "\uB9CA\uB9CB\uB9CD\uB9D3", 4, "\uB9DA\uB9DC\uB9DF\uB9E0\uB9E2\uB9E6\uB9E7\uB9E9\uB9EA\uB9EB\uB9ED", 6, "\uB9F6\uB9FB", 4, "\uBA02", 5, "\uBA09", 11, "\uBA16", 33, "\uBA3A\uBA3B\uBA3D\uBA3E\uBA3F\uBA41\uBA43\uBA44\uBA45\uBA46"],
      ["9141", "\uBA47\uBA4A\uBA4C\uBA4F\uBA50\uBA51\uBA52\uBA56\uBA57\uBA59\uBA5A\uBA5B\uBA5D", 6, "\uBA66\uBA6A", 5],
      ["9161", "\uBA72\uBA73\uBA75\uBA76\uBA77\uBA79", 9, "\uBA86\uBA88\uBA89\uBA8A\uBA8B\uBA8D", 5],
      ["9181", "\uBA93", 20, "\uBAAA\uBAAD\uBAAE\uBAAF\uBAB1\uBAB3", 4, "\uBABA\uBABC\uBABE", 5, "\uBAC5\uBAC6\uBAC7\uBAC9", 14, "\uBADA", 33, "\uBAFD\uBAFE\uBAFF\uBB01\uBB02\uBB03\uBB05", 7, "\uBB0E\uBB10\uBB12", 5, "\uBB19\uBB1A\uBB1B\uBB1D\uBB1E\uBB1F\uBB21", 6],
      ["9241", "\uBB28\uBB2A\uBB2C", 7, "\uBB37\uBB39\uBB3A\uBB3F", 4, "\uBB46\uBB48\uBB4A\uBB4B\uBB4C\uBB4E\uBB51\uBB52"],
      ["9261", "\uBB53\uBB55\uBB56\uBB57\uBB59", 7, "\uBB62\uBB64", 7, "\uBB6D", 4],
      ["9281", "\uBB72", 21, "\uBB89\uBB8A\uBB8B\uBB8D\uBB8E\uBB8F\uBB91", 18, "\uBBA5\uBBA6\uBBA7\uBBA9\uBBAA\uBBAB\uBBAD", 6, "\uBBB5\uBBB6\uBBB8", 7, "\uBBC1\uBBC2\uBBC3\uBBC5\uBBC6\uBBC7\uBBC9", 6, "\uBBD1\uBBD2\uBBD4", 35, "\uBBFA\uBBFB\uBBFD\uBBFE\uBC01"],
      ["9341", "\uBC03", 4, "\uBC0A\uBC0E\uBC10\uBC12\uBC13\uBC19\uBC1A\uBC20\uBC21\uBC22\uBC23\uBC26\uBC28\uBC2A\uBC2B\uBC2C\uBC2E\uBC2F\uBC32\uBC33\uBC35"],
      ["9361", "\uBC36\uBC37\uBC39", 6, "\uBC42\uBC46\uBC47\uBC48\uBC4A\uBC4B\uBC4E\uBC4F\uBC51", 8],
      ["9381", "\uBC5A\uBC5B\uBC5C\uBC5E", 37, "\uBC86\uBC87\uBC89\uBC8A\uBC8D\uBC8F", 4, "\uBC96\uBC98\uBC9B", 4, "\uBCA2\uBCA3\uBCA5\uBCA6\uBCA9", 6, "\uBCB2\uBCB6", 5, "\uBCBE\uBCBF\uBCC1\uBCC2\uBCC3\uBCC5", 7, "\uBCCE\uBCD2\uBCD3\uBCD4\uBCD6\uBCD7\uBCD9\uBCDA\uBCDB\uBCDD", 22, "\uBCF7\uBCF9\uBCFA\uBCFB\uBCFD"],
      ["9441", "\uBCFE", 5, "\uBD06\uBD08\uBD0A", 5, "\uBD11\uBD12\uBD13\uBD15", 8],
      ["9461", "\uBD1E", 5, "\uBD25", 6, "\uBD2D", 12],
      ["9481", "\uBD3A", 5, "\uBD41", 6, "\uBD4A\uBD4B\uBD4D\uBD4E\uBD4F\uBD51", 6, "\uBD5A", 9, "\uBD65\uBD66\uBD67\uBD69", 22, "\uBD82\uBD83\uBD85\uBD86\uBD8B", 4, "\uBD92\uBD94\uBD96\uBD97\uBD98\uBD9B\uBD9D", 6, "\uBDA5", 10, "\uBDB1", 6, "\uBDB9", 24],
      ["9541", "\uBDD2\uBDD3\uBDD6\uBDD7\uBDD9\uBDDA\uBDDB\uBDDD", 11, "\uBDEA", 5, "\uBDF1"],
      ["9561", "\uBDF2\uBDF3\uBDF5\uBDF6\uBDF7\uBDF9", 6, "\uBE01\uBE02\uBE04\uBE06", 5, "\uBE0E\uBE0F\uBE11\uBE12\uBE13"],
      ["9581", "\uBE15", 6, "\uBE1E\uBE20", 35, "\uBE46\uBE47\uBE49\uBE4A\uBE4B\uBE4D\uBE4F", 4, "\uBE56\uBE58\uBE5C\uBE5D\uBE5E\uBE5F\uBE62\uBE63\uBE65\uBE66\uBE67\uBE69\uBE6B", 4, "\uBE72\uBE76", 4, "\uBE7E\uBE7F\uBE81\uBE82\uBE83\uBE85", 6, "\uBE8E\uBE92", 5, "\uBE9A", 13, "\uBEA9", 14],
      ["9641", "\uBEB8", 23, "\uBED2\uBED3"],
      ["9661", "\uBED5\uBED6\uBED9", 6, "\uBEE1\uBEE2\uBEE6", 5, "\uBEED", 8],
      ["9681", "\uBEF6", 10, "\uBF02", 5, "\uBF0A", 13, "\uBF1A\uBF1E", 33, "\uBF42\uBF43\uBF45\uBF46\uBF47\uBF49", 6, "\uBF52\uBF53\uBF54\uBF56", 44],
      ["9741", "\uBF83", 16, "\uBF95", 8],
      ["9761", "\uBF9E", 17, "\uBFB1", 7],
      ["9781", "\uBFB9", 11, "\uBFC6", 5, "\uBFCE\uBFCF\uBFD1\uBFD2\uBFD3\uBFD5", 6, "\uBFDD\uBFDE\uBFE0\uBFE2", 89, "\uC03D\uC03E\uC03F"],
      ["9841", "\uC040", 16, "\uC052", 5, "\uC059\uC05A\uC05B"],
      ["9861", "\uC05D\uC05E\uC05F\uC061", 6, "\uC06A", 15],
      ["9881", "\uC07A", 21, "\uC092\uC093\uC095\uC096\uC097\uC099", 6, "\uC0A2\uC0A4\uC0A6", 5, "\uC0AE\uC0B1\uC0B2\uC0B7", 4, "\uC0BE\uC0C2\uC0C3\uC0C4\uC0C6\uC0C7\uC0CA\uC0CB\uC0CD\uC0CE\uC0CF\uC0D1", 6, "\uC0DA\uC0DE", 5, "\uC0E6\uC0E7\uC0E9\uC0EA\uC0EB\uC0ED", 6, "\uC0F6\uC0F8\uC0FA", 5, "\uC101\uC102\uC103\uC105\uC106\uC107\uC109", 6, "\uC111\uC112\uC113\uC114\uC116", 5, "\uC121\uC122\uC125\uC128\uC129\uC12A\uC12B\uC12E"],
      ["9941", "\uC132\uC133\uC134\uC135\uC137\uC13A\uC13B\uC13D\uC13E\uC13F\uC141", 6, "\uC14A\uC14E", 5, "\uC156\uC157"],
      ["9961", "\uC159\uC15A\uC15B\uC15D", 6, "\uC166\uC16A", 5, "\uC171\uC172\uC173\uC175\uC176\uC177\uC179\uC17A\uC17B"],
      ["9981", "\uC17C", 8, "\uC186", 5, "\uC18F\uC191\uC192\uC193\uC195\uC197", 4, "\uC19E\uC1A0\uC1A2\uC1A3\uC1A4\uC1A6\uC1A7\uC1AA\uC1AB\uC1AD\uC1AE\uC1AF\uC1B1", 11, "\uC1BE", 5, "\uC1C5\uC1C6\uC1C7\uC1C9\uC1CA\uC1CB\uC1CD", 6, "\uC1D5\uC1D6\uC1D9", 6, "\uC1E1\uC1E2\uC1E3\uC1E5\uC1E6\uC1E7\uC1E9", 6, "\uC1F2\uC1F4", 7, "\uC1FE\uC1FF\uC201\uC202\uC203\uC205", 6, "\uC20E\uC210\uC212", 5, "\uC21A\uC21B\uC21D\uC21E\uC221\uC222\uC223"],
      ["9a41", "\uC224\uC225\uC226\uC227\uC22A\uC22C\uC22E\uC230\uC233\uC235", 16],
      ["9a61", "\uC246\uC247\uC249", 6, "\uC252\uC253\uC255\uC256\uC257\uC259", 6, "\uC261\uC262\uC263\uC264\uC266"],
      ["9a81", "\uC267", 4, "\uC26E\uC26F\uC271\uC272\uC273\uC275", 6, "\uC27E\uC280\uC282", 5, "\uC28A", 5, "\uC291", 6, "\uC299\uC29A\uC29C\uC29E", 5, "\uC2A6\uC2A7\uC2A9\uC2AA\uC2AB\uC2AE", 5, "\uC2B6\uC2B8\uC2BA", 33, "\uC2DE\uC2DF\uC2E1\uC2E2\uC2E5", 5, "\uC2EE\uC2F0\uC2F2\uC2F3\uC2F4\uC2F5\uC2F7\uC2FA\uC2FD\uC2FE\uC2FF\uC301", 6, "\uC30A\uC30B\uC30E\uC30F"],
      ["9b41", "\uC310\uC311\uC312\uC316\uC317\uC319\uC31A\uC31B\uC31D", 6, "\uC326\uC327\uC32A", 8],
      ["9b61", "\uC333", 17, "\uC346", 7],
      ["9b81", "\uC34E", 25, "\uC36A\uC36B\uC36D\uC36E\uC36F\uC371\uC373", 4, "\uC37A\uC37B\uC37E", 5, "\uC385\uC386\uC387\uC389\uC38A\uC38B\uC38D", 50, "\uC3C1", 22, "\uC3DA"],
      ["9c41", "\uC3DB\uC3DD\uC3DE\uC3E1\uC3E3", 4, "\uC3EA\uC3EB\uC3EC\uC3EE", 5, "\uC3F6\uC3F7\uC3F9", 5],
      ["9c61", "\uC3FF", 8, "\uC409", 6, "\uC411", 9],
      ["9c81", "\uC41B", 8, "\uC425", 6, "\uC42D\uC42E\uC42F\uC431\uC432\uC433\uC435", 6, "\uC43E", 9, "\uC449", 26, "\uC466\uC467\uC469\uC46A\uC46B\uC46D", 6, "\uC476\uC477\uC478\uC47A", 5, "\uC481", 18, "\uC495", 6, "\uC49D", 12],
      ["9d41", "\uC4AA", 13, "\uC4B9\uC4BA\uC4BB\uC4BD", 8],
      ["9d61", "\uC4C6", 25],
      ["9d81", "\uC4E0", 8, "\uC4EA", 5, "\uC4F2\uC4F3\uC4F5\uC4F6\uC4F7\uC4F9\uC4FB\uC4FC\uC4FD\uC4FE\uC502", 9, "\uC50D\uC50E\uC50F\uC511\uC512\uC513\uC515", 6, "\uC51D", 10, "\uC52A\uC52B\uC52D\uC52E\uC52F\uC531", 6, "\uC53A\uC53C\uC53E", 5, "\uC546\uC547\uC54B\uC54F\uC550\uC551\uC552\uC556\uC55A\uC55B\uC55C\uC55F\uC562\uC563\uC565\uC566\uC567\uC569", 6, "\uC572\uC576", 5, "\uC57E\uC57F\uC581\uC582\uC583\uC585\uC586\uC588\uC589\uC58A\uC58B\uC58E\uC590\uC592\uC593\uC594"],
      ["9e41", "\uC596\uC599\uC59A\uC59B\uC59D\uC59E\uC59F\uC5A1", 7, "\uC5AA", 9, "\uC5B6"],
      ["9e61", "\uC5B7\uC5BA\uC5BF", 4, "\uC5CB\uC5CD\uC5CF\uC5D2\uC5D3\uC5D5\uC5D6\uC5D7\uC5D9", 6, "\uC5E2\uC5E4\uC5E6\uC5E7"],
      ["9e81", "\uC5E8\uC5E9\uC5EA\uC5EB\uC5EF\uC5F1\uC5F2\uC5F3\uC5F5\uC5F8\uC5F9\uC5FA\uC5FB\uC602\uC603\uC604\uC609\uC60A\uC60B\uC60D\uC60E\uC60F\uC611", 6, "\uC61A\uC61D", 6, "\uC626\uC627\uC629\uC62A\uC62B\uC62F\uC631\uC632\uC636\uC638\uC63A\uC63C\uC63D\uC63E\uC63F\uC642\uC643\uC645\uC646\uC647\uC649", 6, "\uC652\uC656", 5, "\uC65E\uC65F\uC661", 10, "\uC66D\uC66E\uC670\uC672", 5, "\uC67A\uC67B\uC67D\uC67E\uC67F\uC681", 6, "\uC68A\uC68C\uC68E", 5, "\uC696\uC697\uC699\uC69A\uC69B\uC69D", 6, "\uC6A6"],
      ["9f41", "\uC6A8\uC6AA", 5, "\uC6B2\uC6B3\uC6B5\uC6B6\uC6B7\uC6BB", 4, "\uC6C2\uC6C4\uC6C6", 5, "\uC6CE"],
      ["9f61", "\uC6CF\uC6D1\uC6D2\uC6D3\uC6D5", 6, "\uC6DE\uC6DF\uC6E2", 5, "\uC6EA\uC6EB\uC6ED\uC6EE\uC6EF\uC6F1\uC6F2"],
      ["9f81", "\uC6F3", 4, "\uC6FA\uC6FB\uC6FC\uC6FE", 5, "\uC706\uC707\uC709\uC70A\uC70B\uC70D", 6, "\uC716\uC718\uC71A", 5, "\uC722\uC723\uC725\uC726\uC727\uC729", 6, "\uC732\uC734\uC736\uC738\uC739\uC73A\uC73B\uC73E\uC73F\uC741\uC742\uC743\uC745", 4, "\uC74B\uC74E\uC750\uC759\uC75A\uC75B\uC75D\uC75E\uC75F\uC761", 6, "\uC769\uC76A\uC76C", 7, "\uC776\uC777\uC779\uC77A\uC77B\uC77F\uC780\uC781\uC782\uC786\uC78B\uC78C\uC78D\uC78F\uC792\uC793\uC795\uC799\uC79B", 4, "\uC7A2\uC7A7", 4, "\uC7AE\uC7AF\uC7B1\uC7B2\uC7B3\uC7B5\uC7B6\uC7B7"],
      ["a041", "\uC7B8\uC7B9\uC7BA\uC7BB\uC7BE\uC7C2", 5, "\uC7CA\uC7CB\uC7CD\uC7CF\uC7D1", 6, "\uC7D9\uC7DA\uC7DB\uC7DC"],
      ["a061", "\uC7DE", 5, "\uC7E5\uC7E6\uC7E7\uC7E9\uC7EA\uC7EB\uC7ED", 13],
      ["a081", "\uC7FB", 4, "\uC802\uC803\uC805\uC806\uC807\uC809\uC80B", 4, "\uC812\uC814\uC817", 4, "\uC81E\uC81F\uC821\uC822\uC823\uC825", 6, "\uC82E\uC830\uC832", 5, "\uC839\uC83A\uC83B\uC83D\uC83E\uC83F\uC841", 6, "\uC84A\uC84B\uC84E", 5, "\uC855", 26, "\uC872\uC873\uC875\uC876\uC877\uC879\uC87B", 4, "\uC882\uC884\uC888\uC889\uC88A\uC88E", 5, "\uC895", 7, "\uC89E\uC8A0\uC8A2\uC8A3\uC8A4"],
      ["a141", "\uC8A5\uC8A6\uC8A7\uC8A9", 18, "\uC8BE\uC8BF\uC8C0\uC8C1"],
      ["a161", "\uC8C2\uC8C3\uC8C5\uC8C6\uC8C7\uC8C9\uC8CA\uC8CB\uC8CD", 6, "\uC8D6\uC8D8\uC8DA", 5, "\uC8E2\uC8E3\uC8E5"],
      ["a181", "\uC8E6", 14, "\uC8F6", 5, "\uC8FE\uC8FF\uC901\uC902\uC903\uC907", 4, "\uC90E\u3000\u3001\u3002\xB7\u2025\u2026\xA8\u3003\xAD\u2015\u2225\uFF3C\u223C\u2018\u2019\u201C\u201D\u3014\u3015\u3008", 9, "\xB1\xD7\xF7\u2260\u2264\u2265\u221E\u2234\xB0\u2032\u2033\u2103\u212B\uFFE0\uFFE1\uFFE5\u2642\u2640\u2220\u22A5\u2312\u2202\u2207\u2261\u2252\xA7\u203B\u2606\u2605\u25CB\u25CF\u25CE\u25C7\u25C6\u25A1\u25A0\u25B3\u25B2\u25BD\u25BC\u2192\u2190\u2191\u2193\u2194\u3013\u226A\u226B\u221A\u223D\u221D\u2235\u222B\u222C\u2208\u220B\u2286\u2287\u2282\u2283\u222A\u2229\u2227\u2228\uFFE2"],
      ["a241", "\uC910\uC912", 5, "\uC919", 18],
      ["a261", "\uC92D", 6, "\uC935", 18],
      ["a281", "\uC948", 7, "\uC952\uC953\uC955\uC956\uC957\uC959", 6, "\uC962\uC964", 7, "\uC96D\uC96E\uC96F\u21D2\u21D4\u2200\u2203\xB4\uFF5E\u02C7\u02D8\u02DD\u02DA\u02D9\xB8\u02DB\xA1\xBF\u02D0\u222E\u2211\u220F\xA4\u2109\u2030\u25C1\u25C0\u25B7\u25B6\u2664\u2660\u2661\u2665\u2667\u2663\u2299\u25C8\u25A3\u25D0\u25D1\u2592\u25A4\u25A5\u25A8\u25A7\u25A6\u25A9\u2668\u260F\u260E\u261C\u261E\xB6\u2020\u2021\u2195\u2197\u2199\u2196\u2198\u266D\u2669\u266A\u266C\u327F\u321C\u2116\u33C7\u2122\u33C2\u33D8\u2121\u20AC\xAE"],
      ["a341", "\uC971\uC972\uC973\uC975", 6, "\uC97D", 10, "\uC98A\uC98B\uC98D\uC98E\uC98F"],
      ["a361", "\uC991", 6, "\uC99A\uC99C\uC99E", 16],
      ["a381", "\uC9AF", 16, "\uC9C2\uC9C3\uC9C5\uC9C6\uC9C9\uC9CB", 4, "\uC9D2\uC9D4\uC9D7\uC9D8\uC9DB\uFF01", 58, "\uFFE6\uFF3D", 32, "\uFFE3"],
      ["a441", "\uC9DE\uC9DF\uC9E1\uC9E3\uC9E5\uC9E6\uC9E8\uC9E9\uC9EA\uC9EB\uC9EE\uC9F2", 5, "\uC9FA\uC9FB\uC9FD\uC9FE\uC9FF\uCA01\uCA02\uCA03\uCA04"],
      ["a461", "\uCA05\uCA06\uCA07\uCA0A\uCA0E", 5, "\uCA15\uCA16\uCA17\uCA19", 12],
      ["a481", "\uCA26\uCA27\uCA28\uCA2A", 28, "\u3131", 93],
      ["a541", "\uCA47", 4, "\uCA4E\uCA4F\uCA51\uCA52\uCA53\uCA55", 6, "\uCA5E\uCA62", 5, "\uCA69\uCA6A"],
      ["a561", "\uCA6B", 17, "\uCA7E", 5, "\uCA85\uCA86"],
      ["a581", "\uCA87", 16, "\uCA99", 14, "\u2170", 9],
      ["a5b0", "\u2160", 9],
      ["a5c1", "\u0391", 16, "\u03A3", 6],
      ["a5e1", "\u03B1", 16, "\u03C3", 6],
      ["a641", "\uCAA8", 19, "\uCABE\uCABF\uCAC1\uCAC2\uCAC3\uCAC5"],
      ["a661", "\uCAC6", 5, "\uCACE\uCAD0\uCAD2\uCAD4\uCAD5\uCAD6\uCAD7\uCADA", 5, "\uCAE1", 6],
      ["a681", "\uCAE8\uCAE9\uCAEA\uCAEB\uCAED", 6, "\uCAF5", 18, "\uCB09\uCB0A\u2500\u2502\u250C\u2510\u2518\u2514\u251C\u252C\u2524\u2534\u253C\u2501\u2503\u250F\u2513\u251B\u2517\u2523\u2533\u252B\u253B\u254B\u2520\u252F\u2528\u2537\u253F\u251D\u2530\u2525\u2538\u2542\u2512\u2511\u251A\u2519\u2516\u2515\u250E\u250D\u251E\u251F\u2521\u2522\u2526\u2527\u2529\u252A\u252D\u252E\u2531\u2532\u2535\u2536\u2539\u253A\u253D\u253E\u2540\u2541\u2543", 7],
      ["a741", "\uCB0B", 4, "\uCB11\uCB12\uCB13\uCB15\uCB16\uCB17\uCB19", 6, "\uCB22", 7],
      ["a761", "\uCB2A", 22, "\uCB42\uCB43\uCB44"],
      ["a781", "\uCB45\uCB46\uCB47\uCB4A\uCB4B\uCB4D\uCB4E\uCB4F\uCB51", 6, "\uCB5A\uCB5B\uCB5C\uCB5E", 5, "\uCB65", 7, "\u3395\u3396\u3397\u2113\u3398\u33C4\u33A3\u33A4\u33A5\u33A6\u3399", 9, "\u33CA\u338D\u338E\u338F\u33CF\u3388\u3389\u33C8\u33A7\u33A8\u33B0", 9, "\u3380", 4, "\u33BA", 5, "\u3390", 4, "\u2126\u33C0\u33C1\u338A\u338B\u338C\u33D6\u33C5\u33AD\u33AE\u33AF\u33DB\u33A9\u33AA\u33AB\u33AC\u33DD\u33D0\u33D3\u33C3\u33C9\u33DC\u33C6"],
      ["a841", "\uCB6D", 10, "\uCB7A", 14],
      ["a861", "\uCB89", 18, "\uCB9D", 6],
      ["a881", "\uCBA4", 19, "\uCBB9", 11, "\xC6\xD0\xAA\u0126"],
      ["a8a6", "\u0132"],
      ["a8a8", "\u013F\u0141\xD8\u0152\xBA\xDE\u0166\u014A"],
      ["a8b1", "\u3260", 27, "\u24D0", 25, "\u2460", 14, "\xBD\u2153\u2154\xBC\xBE\u215B\u215C\u215D\u215E"],
      ["a941", "\uCBC5", 14, "\uCBD5", 10],
      ["a961", "\uCBE0\uCBE1\uCBE2\uCBE3\uCBE5\uCBE6\uCBE8\uCBEA", 18],
      ["a981", "\uCBFD", 14, "\uCC0E\uCC0F\uCC11\uCC12\uCC13\uCC15", 6, "\uCC1E\uCC1F\uCC20\uCC23\uCC24\xE6\u0111\xF0\u0127\u0131\u0133\u0138\u0140\u0142\xF8\u0153\xDF\xFE\u0167\u014B\u0149\u3200", 27, "\u249C", 25, "\u2474", 14, "\xB9\xB2\xB3\u2074\u207F\u2081\u2082\u2083\u2084"],
      ["aa41", "\uCC25\uCC26\uCC2A\uCC2B\uCC2D\uCC2F\uCC31", 6, "\uCC3A\uCC3F", 4, "\uCC46\uCC47\uCC49\uCC4A\uCC4B\uCC4D\uCC4E"],
      ["aa61", "\uCC4F", 4, "\uCC56\uCC5A", 5, "\uCC61\uCC62\uCC63\uCC65\uCC67\uCC69", 6, "\uCC71\uCC72"],
      ["aa81", "\uCC73\uCC74\uCC76", 29, "\u3041", 82],
      ["ab41", "\uCC94\uCC95\uCC96\uCC97\uCC9A\uCC9B\uCC9D\uCC9E\uCC9F\uCCA1", 6, "\uCCAA\uCCAE", 5, "\uCCB6\uCCB7\uCCB9"],
      ["ab61", "\uCCBA\uCCBB\uCCBD", 6, "\uCCC6\uCCC8\uCCCA", 5, "\uCCD1\uCCD2\uCCD3\uCCD5", 5],
      ["ab81", "\uCCDB", 8, "\uCCE5", 6, "\uCCED\uCCEE\uCCEF\uCCF1", 12, "\u30A1", 85],
      ["ac41", "\uCCFE\uCCFF\uCD00\uCD02", 5, "\uCD0A\uCD0B\uCD0D\uCD0E\uCD0F\uCD11", 6, "\uCD1A\uCD1C\uCD1E\uCD1F\uCD20"],
      ["ac61", "\uCD21\uCD22\uCD23\uCD25\uCD26\uCD27\uCD29\uCD2A\uCD2B\uCD2D", 11, "\uCD3A", 4],
      ["ac81", "\uCD3F", 28, "\uCD5D\uCD5E\uCD5F\u0410", 5, "\u0401\u0416", 25],
      ["acd1", "\u0430", 5, "\u0451\u0436", 25],
      ["ad41", "\uCD61\uCD62\uCD63\uCD65", 6, "\uCD6E\uCD70\uCD72", 5, "\uCD79", 7],
      ["ad61", "\uCD81", 6, "\uCD89", 10, "\uCD96\uCD97\uCD99\uCD9A\uCD9B\uCD9D\uCD9E\uCD9F"],
      ["ad81", "\uCDA0\uCDA1\uCDA2\uCDA3\uCDA6\uCDA8\uCDAA", 5, "\uCDB1", 18, "\uCDC5"],
      ["ae41", "\uCDC6", 5, "\uCDCD\uCDCE\uCDCF\uCDD1", 16],
      ["ae61", "\uCDE2", 5, "\uCDE9\uCDEA\uCDEB\uCDED\uCDEE\uCDEF\uCDF1", 6, "\uCDFA\uCDFC\uCDFE", 4],
      ["ae81", "\uCE03\uCE05\uCE06\uCE07\uCE09\uCE0A\uCE0B\uCE0D", 6, "\uCE15\uCE16\uCE17\uCE18\uCE1A", 5, "\uCE22\uCE23\uCE25\uCE26\uCE27\uCE29\uCE2A\uCE2B"],
      ["af41", "\uCE2C\uCE2D\uCE2E\uCE2F\uCE32\uCE34\uCE36", 19],
      ["af61", "\uCE4A", 13, "\uCE5A\uCE5B\uCE5D\uCE5E\uCE62", 5, "\uCE6A\uCE6C"],
      ["af81", "\uCE6E", 5, "\uCE76\uCE77\uCE79\uCE7A\uCE7B\uCE7D", 6, "\uCE86\uCE88\uCE8A", 5, "\uCE92\uCE93\uCE95\uCE96\uCE97\uCE99"],
      ["b041", "\uCE9A", 5, "\uCEA2\uCEA6", 5, "\uCEAE", 12],
      ["b061", "\uCEBB", 5, "\uCEC2", 19],
      ["b081", "\uCED6", 13, "\uCEE6\uCEE7\uCEE9\uCEEA\uCEED", 6, "\uCEF6\uCEFA", 5, "\uAC00\uAC01\uAC04\uAC07\uAC08\uAC09\uAC0A\uAC10", 7, "\uAC19", 4, "\uAC20\uAC24\uAC2C\uAC2D\uAC2F\uAC30\uAC31\uAC38\uAC39\uAC3C\uAC40\uAC4B\uAC4D\uAC54\uAC58\uAC5C\uAC70\uAC71\uAC74\uAC77\uAC78\uAC7A\uAC80\uAC81\uAC83\uAC84\uAC85\uAC86\uAC89\uAC8A\uAC8B\uAC8C\uAC90\uAC94\uAC9C\uAC9D\uAC9F\uACA0\uACA1\uACA8\uACA9\uACAA\uACAC\uACAF\uACB0\uACB8\uACB9\uACBB\uACBC\uACBD\uACC1\uACC4\uACC8\uACCC\uACD5\uACD7\uACE0\uACE1\uACE4\uACE7\uACE8\uACEA\uACEC\uACEF\uACF0\uACF1\uACF3\uACF5\uACF6\uACFC\uACFD\uAD00\uAD04\uAD06"],
      ["b141", "\uCF02\uCF03\uCF05\uCF06\uCF07\uCF09", 6, "\uCF12\uCF14\uCF16", 5, "\uCF1D\uCF1E\uCF1F\uCF21\uCF22\uCF23"],
      ["b161", "\uCF25", 6, "\uCF2E\uCF32", 5, "\uCF39", 11],
      ["b181", "\uCF45", 14, "\uCF56\uCF57\uCF59\uCF5A\uCF5B\uCF5D", 6, "\uCF66\uCF68\uCF6A\uCF6B\uCF6C\uAD0C\uAD0D\uAD0F\uAD11\uAD18\uAD1C\uAD20\uAD29\uAD2C\uAD2D\uAD34\uAD35\uAD38\uAD3C\uAD44\uAD45\uAD47\uAD49\uAD50\uAD54\uAD58\uAD61\uAD63\uAD6C\uAD6D\uAD70\uAD73\uAD74\uAD75\uAD76\uAD7B\uAD7C\uAD7D\uAD7F\uAD81\uAD82\uAD88\uAD89\uAD8C\uAD90\uAD9C\uAD9D\uADA4\uADB7\uADC0\uADC1\uADC4\uADC8\uADD0\uADD1\uADD3\uADDC\uADE0\uADE4\uADF8\uADF9\uADFC\uADFF\uAE00\uAE01\uAE08\uAE09\uAE0B\uAE0D\uAE14\uAE30\uAE31\uAE34\uAE37\uAE38\uAE3A\uAE40\uAE41\uAE43\uAE45\uAE46\uAE4A\uAE4C\uAE4D\uAE4E\uAE50\uAE54\uAE56\uAE5C\uAE5D\uAE5F\uAE60\uAE61\uAE65\uAE68\uAE69\uAE6C\uAE70\uAE78"],
      ["b241", "\uCF6D\uCF6E\uCF6F\uCF72\uCF73\uCF75\uCF76\uCF77\uCF79", 6, "\uCF81\uCF82\uCF83\uCF84\uCF86", 5, "\uCF8D"],
      ["b261", "\uCF8E", 18, "\uCFA2", 5, "\uCFA9"],
      ["b281", "\uCFAA", 5, "\uCFB1", 18, "\uCFC5", 6, "\uAE79\uAE7B\uAE7C\uAE7D\uAE84\uAE85\uAE8C\uAEBC\uAEBD\uAEBE\uAEC0\uAEC4\uAECC\uAECD\uAECF\uAED0\uAED1\uAED8\uAED9\uAEDC\uAEE8\uAEEB\uAEED\uAEF4\uAEF8\uAEFC\uAF07\uAF08\uAF0D\uAF10\uAF2C\uAF2D\uAF30\uAF32\uAF34\uAF3C\uAF3D\uAF3F\uAF41\uAF42\uAF43\uAF48\uAF49\uAF50\uAF5C\uAF5D\uAF64\uAF65\uAF79\uAF80\uAF84\uAF88\uAF90\uAF91\uAF95\uAF9C\uAFB8\uAFB9\uAFBC\uAFC0\uAFC7\uAFC8\uAFC9\uAFCB\uAFCD\uAFCE\uAFD4\uAFDC\uAFE8\uAFE9\uAFF0\uAFF1\uAFF4\uAFF8\uB000\uB001\uB004\uB00C\uB010\uB014\uB01C\uB01D\uB028\uB044\uB045\uB048\uB04A\uB04C\uB04E\uB053\uB054\uB055\uB057\uB059"],
      ["b341", "\uCFCC", 19, "\uCFE2\uCFE3\uCFE5\uCFE6\uCFE7\uCFE9"],
      ["b361", "\uCFEA", 5, "\uCFF2\uCFF4\uCFF6", 5, "\uCFFD\uCFFE\uCFFF\uD001\uD002\uD003\uD005", 5],
      ["b381", "\uD00B", 5, "\uD012", 5, "\uD019", 19, "\uB05D\uB07C\uB07D\uB080\uB084\uB08C\uB08D\uB08F\uB091\uB098\uB099\uB09A\uB09C\uB09F\uB0A0\uB0A1\uB0A2\uB0A8\uB0A9\uB0AB", 4, "\uB0B1\uB0B3\uB0B4\uB0B5\uB0B8\uB0BC\uB0C4\uB0C5\uB0C7\uB0C8\uB0C9\uB0D0\uB0D1\uB0D4\uB0D8\uB0E0\uB0E5\uB108\uB109\uB10B\uB10C\uB110\uB112\uB113\uB118\uB119\uB11B\uB11C\uB11D\uB123\uB124\uB125\uB128\uB12C\uB134\uB135\uB137\uB138\uB139\uB140\uB141\uB144\uB148\uB150\uB151\uB154\uB155\uB158\uB15C\uB160\uB178\uB179\uB17C\uB180\uB182\uB188\uB189\uB18B\uB18D\uB192\uB193\uB194\uB198\uB19C\uB1A8\uB1CC\uB1D0\uB1D4\uB1DC\uB1DD"],
      ["b441", "\uD02E", 5, "\uD036\uD037\uD039\uD03A\uD03B\uD03D", 6, "\uD046\uD048\uD04A", 5],
      ["b461", "\uD051\uD052\uD053\uD055\uD056\uD057\uD059", 6, "\uD061", 10, "\uD06E\uD06F"],
      ["b481", "\uD071\uD072\uD073\uD075", 6, "\uD07E\uD07F\uD080\uD082", 18, "\uB1DF\uB1E8\uB1E9\uB1EC\uB1F0\uB1F9\uB1FB\uB1FD\uB204\uB205\uB208\uB20B\uB20C\uB214\uB215\uB217\uB219\uB220\uB234\uB23C\uB258\uB25C\uB260\uB268\uB269\uB274\uB275\uB27C\uB284\uB285\uB289\uB290\uB291\uB294\uB298\uB299\uB29A\uB2A0\uB2A1\uB2A3\uB2A5\uB2A6\uB2AA\uB2AC\uB2B0\uB2B4\uB2C8\uB2C9\uB2CC\uB2D0\uB2D2\uB2D8\uB2D9\uB2DB\uB2DD\uB2E2\uB2E4\uB2E5\uB2E6\uB2E8\uB2EB", 4, "\uB2F3\uB2F4\uB2F5\uB2F7", 4, "\uB2FF\uB300\uB301\uB304\uB308\uB310\uB311\uB313\uB314\uB315\uB31C\uB354\uB355\uB356\uB358\uB35B\uB35C\uB35E\uB35F\uB364\uB365"],
      ["b541", "\uD095", 14, "\uD0A6\uD0A7\uD0A9\uD0AA\uD0AB\uD0AD", 5],
      ["b561", "\uD0B3\uD0B6\uD0B8\uD0BA", 5, "\uD0C2\uD0C3\uD0C5\uD0C6\uD0C7\uD0CA", 5, "\uD0D2\uD0D6", 4],
      ["b581", "\uD0DB\uD0DE\uD0DF\uD0E1\uD0E2\uD0E3\uD0E5", 6, "\uD0EE\uD0F2", 5, "\uD0F9", 11, "\uB367\uB369\uB36B\uB36E\uB370\uB371\uB374\uB378\uB380\uB381\uB383\uB384\uB385\uB38C\uB390\uB394\uB3A0\uB3A1\uB3A8\uB3AC\uB3C4\uB3C5\uB3C8\uB3CB\uB3CC\uB3CE\uB3D0\uB3D4\uB3D5\uB3D7\uB3D9\uB3DB\uB3DD\uB3E0\uB3E4\uB3E8\uB3FC\uB410\uB418\uB41C\uB420\uB428\uB429\uB42B\uB434\uB450\uB451\uB454\uB458\uB460\uB461\uB463\uB465\uB46C\uB480\uB488\uB49D\uB4A4\uB4A8\uB4AC\uB4B5\uB4B7\uB4B9\uB4C0\uB4C4\uB4C8\uB4D0\uB4D5\uB4DC\uB4DD\uB4E0\uB4E3\uB4E4\uB4E6\uB4EC\uB4ED\uB4EF\uB4F1\uB4F8\uB514\uB515\uB518\uB51B\uB51C\uB524\uB525\uB527\uB528\uB529\uB52A\uB530\uB531\uB534\uB538"],
      ["b641", "\uD105", 7, "\uD10E", 17],
      ["b661", "\uD120", 15, "\uD132\uD133\uD135\uD136\uD137\uD139\uD13B\uD13C\uD13D\uD13E"],
      ["b681", "\uD13F\uD142\uD146", 5, "\uD14E\uD14F\uD151\uD152\uD153\uD155", 6, "\uD15E\uD160\uD162", 5, "\uD169\uD16A\uD16B\uD16D\uB540\uB541\uB543\uB544\uB545\uB54B\uB54C\uB54D\uB550\uB554\uB55C\uB55D\uB55F\uB560\uB561\uB5A0\uB5A1\uB5A4\uB5A8\uB5AA\uB5AB\uB5B0\uB5B1\uB5B3\uB5B4\uB5B5\uB5BB\uB5BC\uB5BD\uB5C0\uB5C4\uB5CC\uB5CD\uB5CF\uB5D0\uB5D1\uB5D8\uB5EC\uB610\uB611\uB614\uB618\uB625\uB62C\uB634\uB648\uB664\uB668\uB69C\uB69D\uB6A0\uB6A4\uB6AB\uB6AC\uB6B1\uB6D4\uB6F0\uB6F4\uB6F8\uB700\uB701\uB705\uB728\uB729\uB72C\uB72F\uB730\uB738\uB739\uB73B\uB744\uB748\uB74C\uB754\uB755\uB760\uB764\uB768\uB770\uB771\uB773\uB775\uB77C\uB77D\uB780\uB784\uB78C\uB78D\uB78F\uB790\uB791\uB792\uB796\uB797"],
      ["b741", "\uD16E", 13, "\uD17D", 6, "\uD185\uD186\uD187\uD189\uD18A"],
      ["b761", "\uD18B", 20, "\uD1A2\uD1A3\uD1A5\uD1A6\uD1A7"],
      ["b781", "\uD1A9", 6, "\uD1B2\uD1B4\uD1B6\uD1B7\uD1B8\uD1B9\uD1BB\uD1BD\uD1BE\uD1BF\uD1C1", 14, "\uB798\uB799\uB79C\uB7A0\uB7A8\uB7A9\uB7AB\uB7AC\uB7AD\uB7B4\uB7B5\uB7B8\uB7C7\uB7C9\uB7EC\uB7ED\uB7F0\uB7F4\uB7FC\uB7FD\uB7FF\uB800\uB801\uB807\uB808\uB809\uB80C\uB810\uB818\uB819\uB81B\uB81D\uB824\uB825\uB828\uB82C\uB834\uB835\uB837\uB838\uB839\uB840\uB844\uB851\uB853\uB85C\uB85D\uB860\uB864\uB86C\uB86D\uB86F\uB871\uB878\uB87C\uB88D\uB8A8\uB8B0\uB8B4\uB8B8\uB8C0\uB8C1\uB8C3\uB8C5\uB8CC\uB8D0\uB8D4\uB8DD\uB8DF\uB8E1\uB8E8\uB8E9\uB8EC\uB8F0\uB8F8\uB8F9\uB8FB\uB8FD\uB904\uB918\uB920\uB93C\uB93D\uB940\uB944\uB94C\uB94F\uB951\uB958\uB959\uB95C\uB960\uB968\uB969"],
      ["b841", "\uD1D0", 7, "\uD1D9", 17],
      ["b861", "\uD1EB", 8, "\uD1F5\uD1F6\uD1F7\uD1F9", 13],
      ["b881", "\uD208\uD20A", 5, "\uD211", 24, "\uB96B\uB96D\uB974\uB975\uB978\uB97C\uB984\uB985\uB987\uB989\uB98A\uB98D\uB98E\uB9AC\uB9AD\uB9B0\uB9B4\uB9BC\uB9BD\uB9BF\uB9C1\uB9C8\uB9C9\uB9CC\uB9CE", 4, "\uB9D8\uB9D9\uB9DB\uB9DD\uB9DE\uB9E1\uB9E3\uB9E4\uB9E5\uB9E8\uB9EC\uB9F4\uB9F5\uB9F7\uB9F8\uB9F9\uB9FA\uBA00\uBA01\uBA08\uBA15\uBA38\uBA39\uBA3C\uBA40\uBA42\uBA48\uBA49\uBA4B\uBA4D\uBA4E\uBA53\uBA54\uBA55\uBA58\uBA5C\uBA64\uBA65\uBA67\uBA68\uBA69\uBA70\uBA71\uBA74\uBA78\uBA83\uBA84\uBA85\uBA87\uBA8C\uBAA8\uBAA9\uBAAB\uBAAC\uBAB0\uBAB2\uBAB8\uBAB9\uBABB\uBABD\uBAC4\uBAC8\uBAD8\uBAD9\uBAFC"],
      ["b941", "\uD22A\uD22B\uD22E\uD22F\uD231\uD232\uD233\uD235", 6, "\uD23E\uD240\uD242", 5, "\uD249\uD24A\uD24B\uD24C"],
      ["b961", "\uD24D", 14, "\uD25D", 6, "\uD265\uD266\uD267\uD268"],
      ["b981", "\uD269", 22, "\uD282\uD283\uD285\uD286\uD287\uD289\uD28A\uD28B\uD28C\uBB00\uBB04\uBB0D\uBB0F\uBB11\uBB18\uBB1C\uBB20\uBB29\uBB2B\uBB34\uBB35\uBB36\uBB38\uBB3B\uBB3C\uBB3D\uBB3E\uBB44\uBB45\uBB47\uBB49\uBB4D\uBB4F\uBB50\uBB54\uBB58\uBB61\uBB63\uBB6C\uBB88\uBB8C\uBB90\uBBA4\uBBA8\uBBAC\uBBB4\uBBB7\uBBC0\uBBC4\uBBC8\uBBD0\uBBD3\uBBF8\uBBF9\uBBFC\uBBFF\uBC00\uBC02\uBC08\uBC09\uBC0B\uBC0C\uBC0D\uBC0F\uBC11\uBC14", 4, "\uBC1B", 4, "\uBC24\uBC25\uBC27\uBC29\uBC2D\uBC30\uBC31\uBC34\uBC38\uBC40\uBC41\uBC43\uBC44\uBC45\uBC49\uBC4C\uBC4D\uBC50\uBC5D\uBC84\uBC85\uBC88\uBC8B\uBC8C\uBC8E\uBC94\uBC95\uBC97"],
      ["ba41", "\uD28D\uD28E\uD28F\uD292\uD293\uD294\uD296", 5, "\uD29D\uD29E\uD29F\uD2A1\uD2A2\uD2A3\uD2A5", 6, "\uD2AD"],
      ["ba61", "\uD2AE\uD2AF\uD2B0\uD2B2", 5, "\uD2BA\uD2BB\uD2BD\uD2BE\uD2C1\uD2C3", 4, "\uD2CA\uD2CC", 5],
      ["ba81", "\uD2D2\uD2D3\uD2D5\uD2D6\uD2D7\uD2D9\uD2DA\uD2DB\uD2DD", 6, "\uD2E6", 9, "\uD2F2\uD2F3\uD2F5\uD2F6\uD2F7\uD2F9\uD2FA\uBC99\uBC9A\uBCA0\uBCA1\uBCA4\uBCA7\uBCA8\uBCB0\uBCB1\uBCB3\uBCB4\uBCB5\uBCBC\uBCBD\uBCC0\uBCC4\uBCCD\uBCCF\uBCD0\uBCD1\uBCD5\uBCD8\uBCDC\uBCF4\uBCF5\uBCF6\uBCF8\uBCFC\uBD04\uBD05\uBD07\uBD09\uBD10\uBD14\uBD24\uBD2C\uBD40\uBD48\uBD49\uBD4C\uBD50\uBD58\uBD59\uBD64\uBD68\uBD80\uBD81\uBD84\uBD87\uBD88\uBD89\uBD8A\uBD90\uBD91\uBD93\uBD95\uBD99\uBD9A\uBD9C\uBDA4\uBDB0\uBDB8\uBDD4\uBDD5\uBDD8\uBDDC\uBDE9\uBDF0\uBDF4\uBDF8\uBE00\uBE03\uBE05\uBE0C\uBE0D\uBE10\uBE14\uBE1C\uBE1D\uBE1F\uBE44\uBE45\uBE48\uBE4C\uBE4E\uBE54\uBE55\uBE57\uBE59\uBE5A\uBE5B\uBE60\uBE61\uBE64"],
      ["bb41", "\uD2FB", 4, "\uD302\uD304\uD306", 5, "\uD30F\uD311\uD312\uD313\uD315\uD317", 4, "\uD31E\uD322\uD323"],
      ["bb61", "\uD324\uD326\uD327\uD32A\uD32B\uD32D\uD32E\uD32F\uD331", 6, "\uD33A\uD33E", 5, "\uD346\uD347\uD348\uD349"],
      ["bb81", "\uD34A", 31, "\uBE68\uBE6A\uBE70\uBE71\uBE73\uBE74\uBE75\uBE7B\uBE7C\uBE7D\uBE80\uBE84\uBE8C\uBE8D\uBE8F\uBE90\uBE91\uBE98\uBE99\uBEA8\uBED0\uBED1\uBED4\uBED7\uBED8\uBEE0\uBEE3\uBEE4\uBEE5\uBEEC\uBF01\uBF08\uBF09\uBF18\uBF19\uBF1B\uBF1C\uBF1D\uBF40\uBF41\uBF44\uBF48\uBF50\uBF51\uBF55\uBF94\uBFB0\uBFC5\uBFCC\uBFCD\uBFD0\uBFD4\uBFDC\uBFDF\uBFE1\uC03C\uC051\uC058\uC05C\uC060\uC068\uC069\uC090\uC091\uC094\uC098\uC0A0\uC0A1\uC0A3\uC0A5\uC0AC\uC0AD\uC0AF\uC0B0\uC0B3\uC0B4\uC0B5\uC0B6\uC0BC\uC0BD\uC0BF\uC0C0\uC0C1\uC0C5\uC0C8\uC0C9\uC0CC\uC0D0\uC0D8\uC0D9\uC0DB\uC0DC\uC0DD\uC0E4"],
      ["bc41", "\uD36A", 17, "\uD37E\uD37F\uD381\uD382\uD383\uD385\uD386\uD387"],
      ["bc61", "\uD388\uD389\uD38A\uD38B\uD38E\uD392", 5, "\uD39A\uD39B\uD39D\uD39E\uD39F\uD3A1", 6, "\uD3AA\uD3AC\uD3AE"],
      ["bc81", "\uD3AF", 4, "\uD3B5\uD3B6\uD3B7\uD3B9\uD3BA\uD3BB\uD3BD", 6, "\uD3C6\uD3C7\uD3CA", 5, "\uD3D1", 5, "\uC0E5\uC0E8\uC0EC\uC0F4\uC0F5\uC0F7\uC0F9\uC100\uC104\uC108\uC110\uC115\uC11C", 4, "\uC123\uC124\uC126\uC127\uC12C\uC12D\uC12F\uC130\uC131\uC136\uC138\uC139\uC13C\uC140\uC148\uC149\uC14B\uC14C\uC14D\uC154\uC155\uC158\uC15C\uC164\uC165\uC167\uC168\uC169\uC170\uC174\uC178\uC185\uC18C\uC18D\uC18E\uC190\uC194\uC196\uC19C\uC19D\uC19F\uC1A1\uC1A5\uC1A8\uC1A9\uC1AC\uC1B0\uC1BD\uC1C4\uC1C8\uC1CC\uC1D4\uC1D7\uC1D8\uC1E0\uC1E4\uC1E8\uC1F0\uC1F1\uC1F3\uC1FC\uC1FD\uC200\uC204\uC20C\uC20D\uC20F\uC211\uC218\uC219\uC21C\uC21F\uC220\uC228\uC229\uC22B\uC22D"],
      ["bd41", "\uD3D7\uD3D9", 7, "\uD3E2\uD3E4", 7, "\uD3EE\uD3EF\uD3F1\uD3F2\uD3F3\uD3F5\uD3F6\uD3F7"],
      ["bd61", "\uD3F8\uD3F9\uD3FA\uD3FB\uD3FE\uD400\uD402", 5, "\uD409", 13],
      ["bd81", "\uD417", 5, "\uD41E", 25, "\uC22F\uC231\uC232\uC234\uC248\uC250\uC251\uC254\uC258\uC260\uC265\uC26C\uC26D\uC270\uC274\uC27C\uC27D\uC27F\uC281\uC288\uC289\uC290\uC298\uC29B\uC29D\uC2A4\uC2A5\uC2A8\uC2AC\uC2AD\uC2B4\uC2B5\uC2B7\uC2B9\uC2DC\uC2DD\uC2E0\uC2E3\uC2E4\uC2EB\uC2EC\uC2ED\uC2EF\uC2F1\uC2F6\uC2F8\uC2F9\uC2FB\uC2FC\uC300\uC308\uC309\uC30C\uC30D\uC313\uC314\uC315\uC318\uC31C\uC324\uC325\uC328\uC329\uC345\uC368\uC369\uC36C\uC370\uC372\uC378\uC379\uC37C\uC37D\uC384\uC388\uC38C\uC3C0\uC3D8\uC3D9\uC3DC\uC3DF\uC3E0\uC3E2\uC3E8\uC3E9\uC3ED\uC3F4\uC3F5\uC3F8\uC408\uC410\uC424\uC42C\uC430"],
      ["be41", "\uD438", 7, "\uD441\uD442\uD443\uD445", 14],
      ["be61", "\uD454", 7, "\uD45D\uD45E\uD45F\uD461\uD462\uD463\uD465", 7, "\uD46E\uD470\uD471\uD472"],
      ["be81", "\uD473", 4, "\uD47A\uD47B\uD47D\uD47E\uD481\uD483", 4, "\uD48A\uD48C\uD48E", 5, "\uD495", 8, "\uC434\uC43C\uC43D\uC448\uC464\uC465\uC468\uC46C\uC474\uC475\uC479\uC480\uC494\uC49C\uC4B8\uC4BC\uC4E9\uC4F0\uC4F1\uC4F4\uC4F8\uC4FA\uC4FF\uC500\uC501\uC50C\uC510\uC514\uC51C\uC528\uC529\uC52C\uC530\uC538\uC539\uC53B\uC53D\uC544\uC545\uC548\uC549\uC54A\uC54C\uC54D\uC54E\uC553\uC554\uC555\uC557\uC558\uC559\uC55D\uC55E\uC560\uC561\uC564\uC568\uC570\uC571\uC573\uC574\uC575\uC57C\uC57D\uC580\uC584\uC587\uC58C\uC58D\uC58F\uC591\uC595\uC597\uC598\uC59C\uC5A0\uC5A9\uC5B4\uC5B5\uC5B8\uC5B9\uC5BB\uC5BC\uC5BD\uC5BE\uC5C4", 6, "\uC5CC\uC5CE"],
      ["bf41", "\uD49E", 10, "\uD4AA", 14],
      ["bf61", "\uD4B9", 18, "\uD4CD\uD4CE\uD4CF\uD4D1\uD4D2\uD4D3\uD4D5"],
      ["bf81", "\uD4D6", 5, "\uD4DD\uD4DE\uD4E0", 7, "\uD4E9\uD4EA\uD4EB\uD4ED\uD4EE\uD4EF\uD4F1", 6, "\uD4F9\uD4FA\uD4FC\uC5D0\uC5D1\uC5D4\uC5D8\uC5E0\uC5E1\uC5E3\uC5E5\uC5EC\uC5ED\uC5EE\uC5F0\uC5F4\uC5F6\uC5F7\uC5FC", 5, "\uC605\uC606\uC607\uC608\uC60C\uC610\uC618\uC619\uC61B\uC61C\uC624\uC625\uC628\uC62C\uC62D\uC62E\uC630\uC633\uC634\uC635\uC637\uC639\uC63B\uC640\uC641\uC644\uC648\uC650\uC651\uC653\uC654\uC655\uC65C\uC65D\uC660\uC66C\uC66F\uC671\uC678\uC679\uC67C\uC680\uC688\uC689\uC68B\uC68D\uC694\uC695\uC698\uC69C\uC6A4\uC6A5\uC6A7\uC6A9\uC6B0\uC6B1\uC6B4\uC6B8\uC6B9\uC6BA\uC6C0\uC6C1\uC6C3\uC6C5\uC6CC\uC6CD\uC6D0\uC6D4\uC6DC\uC6DD\uC6E0\uC6E1\uC6E8"],
      ["c041", "\uD4FE", 5, "\uD505\uD506\uD507\uD509\uD50A\uD50B\uD50D", 6, "\uD516\uD518", 5],
      ["c061", "\uD51E", 25],
      ["c081", "\uD538\uD539\uD53A\uD53B\uD53E\uD53F\uD541\uD542\uD543\uD545", 6, "\uD54E\uD550\uD552", 5, "\uD55A\uD55B\uD55D\uD55E\uD55F\uD561\uD562\uD563\uC6E9\uC6EC\uC6F0\uC6F8\uC6F9\uC6FD\uC704\uC705\uC708\uC70C\uC714\uC715\uC717\uC719\uC720\uC721\uC724\uC728\uC730\uC731\uC733\uC735\uC737\uC73C\uC73D\uC740\uC744\uC74A\uC74C\uC74D\uC74F\uC751", 7, "\uC75C\uC760\uC768\uC76B\uC774\uC775\uC778\uC77C\uC77D\uC77E\uC783\uC784\uC785\uC787\uC788\uC789\uC78A\uC78E\uC790\uC791\uC794\uC796\uC797\uC798\uC79A\uC7A0\uC7A1\uC7A3\uC7A4\uC7A5\uC7A6\uC7AC\uC7AD\uC7B0\uC7B4\uC7BC\uC7BD\uC7BF\uC7C0\uC7C1\uC7C8\uC7C9\uC7CC\uC7CE\uC7D0\uC7D8\uC7DD\uC7E4\uC7E8\uC7EC\uC800\uC801\uC804\uC808\uC80A"],
      ["c141", "\uD564\uD566\uD567\uD56A\uD56C\uD56E", 5, "\uD576\uD577\uD579\uD57A\uD57B\uD57D", 6, "\uD586\uD58A\uD58B"],
      ["c161", "\uD58C\uD58D\uD58E\uD58F\uD591", 19, "\uD5A6\uD5A7"],
      ["c181", "\uD5A8", 31, "\uC810\uC811\uC813\uC815\uC816\uC81C\uC81D\uC820\uC824\uC82C\uC82D\uC82F\uC831\uC838\uC83C\uC840\uC848\uC849\uC84C\uC84D\uC854\uC870\uC871\uC874\uC878\uC87A\uC880\uC881\uC883\uC885\uC886\uC887\uC88B\uC88C\uC88D\uC894\uC89D\uC89F\uC8A1\uC8A8\uC8BC\uC8BD\uC8C4\uC8C8\uC8CC\uC8D4\uC8D5\uC8D7\uC8D9\uC8E0\uC8E1\uC8E4\uC8F5\uC8FC\uC8FD\uC900\uC904\uC905\uC906\uC90C\uC90D\uC90F\uC911\uC918\uC92C\uC934\uC950\uC951\uC954\uC958\uC960\uC961\uC963\uC96C\uC970\uC974\uC97C\uC988\uC989\uC98C\uC990\uC998\uC999\uC99B\uC99D\uC9C0\uC9C1\uC9C4\uC9C7\uC9C8\uC9CA\uC9D0\uC9D1\uC9D3"],
      ["c241", "\uD5CA\uD5CB\uD5CD\uD5CE\uD5CF\uD5D1\uD5D3", 4, "\uD5DA\uD5DC\uD5DE", 5, "\uD5E6\uD5E7\uD5E9\uD5EA\uD5EB\uD5ED\uD5EE"],
      ["c261", "\uD5EF", 4, "\uD5F6\uD5F8\uD5FA", 5, "\uD602\uD603\uD605\uD606\uD607\uD609", 6, "\uD612"],
      ["c281", "\uD616", 5, "\uD61D\uD61E\uD61F\uD621\uD622\uD623\uD625", 7, "\uD62E", 9, "\uD63A\uD63B\uC9D5\uC9D6\uC9D9\uC9DA\uC9DC\uC9DD\uC9E0\uC9E2\uC9E4\uC9E7\uC9EC\uC9ED\uC9EF\uC9F0\uC9F1\uC9F8\uC9F9\uC9FC\uCA00\uCA08\uCA09\uCA0B\uCA0C\uCA0D\uCA14\uCA18\uCA29\uCA4C\uCA4D\uCA50\uCA54\uCA5C\uCA5D\uCA5F\uCA60\uCA61\uCA68\uCA7D\uCA84\uCA98\uCABC\uCABD\uCAC0\uCAC4\uCACC\uCACD\uCACF\uCAD1\uCAD3\uCAD8\uCAD9\uCAE0\uCAEC\uCAF4\uCB08\uCB10\uCB14\uCB18\uCB20\uCB21\uCB41\uCB48\uCB49\uCB4C\uCB50\uCB58\uCB59\uCB5D\uCB64\uCB78\uCB79\uCB9C\uCBB8\uCBD4\uCBE4\uCBE7\uCBE9\uCC0C\uCC0D\uCC10\uCC14\uCC1C\uCC1D\uCC21\uCC22\uCC27\uCC28\uCC29\uCC2C\uCC2E\uCC30\uCC38\uCC39\uCC3B"],
      ["c341", "\uD63D\uD63E\uD63F\uD641\uD642\uD643\uD644\uD646\uD647\uD64A\uD64C\uD64E\uD64F\uD650\uD652\uD653\uD656\uD657\uD659\uD65A\uD65B\uD65D", 4],
      ["c361", "\uD662", 4, "\uD668\uD66A", 5, "\uD672\uD673\uD675", 11],
      ["c381", "\uD681\uD682\uD684\uD686", 5, "\uD68E\uD68F\uD691\uD692\uD693\uD695", 7, "\uD69E\uD6A0\uD6A2", 5, "\uD6A9\uD6AA\uCC3C\uCC3D\uCC3E\uCC44\uCC45\uCC48\uCC4C\uCC54\uCC55\uCC57\uCC58\uCC59\uCC60\uCC64\uCC66\uCC68\uCC70\uCC75\uCC98\uCC99\uCC9C\uCCA0\uCCA8\uCCA9\uCCAB\uCCAC\uCCAD\uCCB4\uCCB5\uCCB8\uCCBC\uCCC4\uCCC5\uCCC7\uCCC9\uCCD0\uCCD4\uCCE4\uCCEC\uCCF0\uCD01\uCD08\uCD09\uCD0C\uCD10\uCD18\uCD19\uCD1B\uCD1D\uCD24\uCD28\uCD2C\uCD39\uCD5C\uCD60\uCD64\uCD6C\uCD6D\uCD6F\uCD71\uCD78\uCD88\uCD94\uCD95\uCD98\uCD9C\uCDA4\uCDA5\uCDA7\uCDA9\uCDB0\uCDC4\uCDCC\uCDD0\uCDE8\uCDEC\uCDF0\uCDF8\uCDF9\uCDFB\uCDFD\uCE04\uCE08\uCE0C\uCE14\uCE19\uCE20\uCE21\uCE24\uCE28\uCE30\uCE31\uCE33\uCE35"],
      ["c441", "\uD6AB\uD6AD\uD6AE\uD6AF\uD6B1", 7, "\uD6BA\uD6BC", 7, "\uD6C6\uD6C7\uD6C9\uD6CA\uD6CB"],
      ["c461", "\uD6CD\uD6CE\uD6CF\uD6D0\uD6D2\uD6D3\uD6D5\uD6D6\uD6D8\uD6DA", 5, "\uD6E1\uD6E2\uD6E3\uD6E5\uD6E6\uD6E7\uD6E9", 4],
      ["c481", "\uD6EE\uD6EF\uD6F1\uD6F2\uD6F3\uD6F4\uD6F6", 5, "\uD6FE\uD6FF\uD701\uD702\uD703\uD705", 11, "\uD712\uD713\uD714\uCE58\uCE59\uCE5C\uCE5F\uCE60\uCE61\uCE68\uCE69\uCE6B\uCE6D\uCE74\uCE75\uCE78\uCE7C\uCE84\uCE85\uCE87\uCE89\uCE90\uCE91\uCE94\uCE98\uCEA0\uCEA1\uCEA3\uCEA4\uCEA5\uCEAC\uCEAD\uCEC1\uCEE4\uCEE5\uCEE8\uCEEB\uCEEC\uCEF4\uCEF5\uCEF7\uCEF8\uCEF9\uCF00\uCF01\uCF04\uCF08\uCF10\uCF11\uCF13\uCF15\uCF1C\uCF20\uCF24\uCF2C\uCF2D\uCF2F\uCF30\uCF31\uCF38\uCF54\uCF55\uCF58\uCF5C\uCF64\uCF65\uCF67\uCF69\uCF70\uCF71\uCF74\uCF78\uCF80\uCF85\uCF8C\uCFA1\uCFA8\uCFB0\uCFC4\uCFE0\uCFE1\uCFE4\uCFE8\uCFF0\uCFF1\uCFF3\uCFF5\uCFFC\uD000\uD004\uD011\uD018\uD02D\uD034\uD035\uD038\uD03C"],
      ["c541", "\uD715\uD716\uD717\uD71A\uD71B\uD71D\uD71E\uD71F\uD721", 6, "\uD72A\uD72C\uD72E", 5, "\uD736\uD737\uD739"],
      ["c561", "\uD73A\uD73B\uD73D", 6, "\uD745\uD746\uD748\uD74A", 5, "\uD752\uD753\uD755\uD75A", 4],
      ["c581", "\uD75F\uD762\uD764\uD766\uD767\uD768\uD76A\uD76B\uD76D\uD76E\uD76F\uD771\uD772\uD773\uD775", 6, "\uD77E\uD77F\uD780\uD782", 5, "\uD78A\uD78B\uD044\uD045\uD047\uD049\uD050\uD054\uD058\uD060\uD06C\uD06D\uD070\uD074\uD07C\uD07D\uD081\uD0A4\uD0A5\uD0A8\uD0AC\uD0B4\uD0B5\uD0B7\uD0B9\uD0C0\uD0C1\uD0C4\uD0C8\uD0C9\uD0D0\uD0D1\uD0D3\uD0D4\uD0D5\uD0DC\uD0DD\uD0E0\uD0E4\uD0EC\uD0ED\uD0EF\uD0F0\uD0F1\uD0F8\uD10D\uD130\uD131\uD134\uD138\uD13A\uD140\uD141\uD143\uD144\uD145\uD14C\uD14D\uD150\uD154\uD15C\uD15D\uD15F\uD161\uD168\uD16C\uD17C\uD184\uD188\uD1A0\uD1A1\uD1A4\uD1A8\uD1B0\uD1B1\uD1B3\uD1B5\uD1BA\uD1BC\uD1C0\uD1D8\uD1F4\uD1F8\uD207\uD209\uD210\uD22C\uD22D\uD230\uD234\uD23C\uD23D\uD23F\uD241\uD248\uD25C"],
      ["c641", "\uD78D\uD78E\uD78F\uD791", 6, "\uD79A\uD79C\uD79E", 5],
      ["c6a1", "\uD264\uD280\uD281\uD284\uD288\uD290\uD291\uD295\uD29C\uD2A0\uD2A4\uD2AC\uD2B1\uD2B8\uD2B9\uD2BC\uD2BF\uD2C0\uD2C2\uD2C8\uD2C9\uD2CB\uD2D4\uD2D8\uD2DC\uD2E4\uD2E5\uD2F0\uD2F1\uD2F4\uD2F8\uD300\uD301\uD303\uD305\uD30C\uD30D\uD30E\uD310\uD314\uD316\uD31C\uD31D\uD31F\uD320\uD321\uD325\uD328\uD329\uD32C\uD330\uD338\uD339\uD33B\uD33C\uD33D\uD344\uD345\uD37C\uD37D\uD380\uD384\uD38C\uD38D\uD38F\uD390\uD391\uD398\uD399\uD39C\uD3A0\uD3A8\uD3A9\uD3AB\uD3AD\uD3B4\uD3B8\uD3BC\uD3C4\uD3C5\uD3C8\uD3C9\uD3D0\uD3D8\uD3E1\uD3E3\uD3EC\uD3ED\uD3F0\uD3F4\uD3FC\uD3FD\uD3FF\uD401"],
      ["c7a1", "\uD408\uD41D\uD440\uD444\uD45C\uD460\uD464\uD46D\uD46F\uD478\uD479\uD47C\uD47F\uD480\uD482\uD488\uD489\uD48B\uD48D\uD494\uD4A9\uD4CC\uD4D0\uD4D4\uD4DC\uD4DF\uD4E8\uD4EC\uD4F0\uD4F8\uD4FB\uD4FD\uD504\uD508\uD50C\uD514\uD515\uD517\uD53C\uD53D\uD540\uD544\uD54C\uD54D\uD54F\uD551\uD558\uD559\uD55C\uD560\uD565\uD568\uD569\uD56B\uD56D\uD574\uD575\uD578\uD57C\uD584\uD585\uD587\uD588\uD589\uD590\uD5A5\uD5C8\uD5C9\uD5CC\uD5D0\uD5D2\uD5D8\uD5D9\uD5DB\uD5DD\uD5E4\uD5E5\uD5E8\uD5EC\uD5F4\uD5F5\uD5F7\uD5F9\uD600\uD601\uD604\uD608\uD610\uD611\uD613\uD614\uD615\uD61C\uD620"],
      ["c8a1", "\uD624\uD62D\uD638\uD639\uD63C\uD640\uD645\uD648\uD649\uD64B\uD64D\uD651\uD654\uD655\uD658\uD65C\uD667\uD669\uD670\uD671\uD674\uD683\uD685\uD68C\uD68D\uD690\uD694\uD69D\uD69F\uD6A1\uD6A8\uD6AC\uD6B0\uD6B9\uD6BB\uD6C4\uD6C5\uD6C8\uD6CC\uD6D1\uD6D4\uD6D7\uD6D9\uD6E0\uD6E4\uD6E8\uD6F0\uD6F5\uD6FC\uD6FD\uD700\uD704\uD711\uD718\uD719\uD71C\uD720\uD728\uD729\uD72B\uD72D\uD734\uD735\uD738\uD73C\uD744\uD747\uD749\uD750\uD751\uD754\uD756\uD757\uD758\uD759\uD760\uD761\uD763\uD765\uD769\uD76C\uD770\uD774\uD77C\uD77D\uD781\uD788\uD789\uD78C\uD790\uD798\uD799\uD79B\uD79D"],
      ["caa1", "\u4F3D\u4F73\u5047\u50F9\u52A0\u53EF\u5475\u54E5\u5609\u5AC1\u5BB6\u6687\u67B6\u67B7\u67EF\u6B4C\u73C2\u75C2\u7A3C\u82DB\u8304\u8857\u8888\u8A36\u8CC8\u8DCF\u8EFB\u8FE6\u99D5\u523B\u5374\u5404\u606A\u6164\u6BBC\u73CF\u811A\u89BA\u89D2\u95A3\u4F83\u520A\u58BE\u5978\u59E6\u5E72\u5E79\u61C7\u63C0\u6746\u67EC\u687F\u6F97\u764E\u770B\u78F5\u7A08\u7AFF\u7C21\u809D\u826E\u8271\u8AEB\u9593\u4E6B\u559D\u66F7\u6E34\u78A3\u7AED\u845B\u8910\u874E\u97A8\u52D8\u574E\u582A\u5D4C\u611F\u61BE\u6221\u6562\u67D1\u6A44\u6E1B\u7518\u75B3\u76E3\u77B0\u7D3A\u90AF\u9451\u9452\u9F95"],
      ["cba1", "\u5323\u5CAC\u7532\u80DB\u9240\u9598\u525B\u5808\u59DC\u5CA1\u5D17\u5EB7\u5F3A\u5F4A\u6177\u6C5F\u757A\u7586\u7CE0\u7D73\u7DB1\u7F8C\u8154\u8221\u8591\u8941\u8B1B\u92FC\u964D\u9C47\u4ECB\u4EF7\u500B\u51F1\u584F\u6137\u613E\u6168\u6539\u69EA\u6F11\u75A5\u7686\u76D6\u7B87\u82A5\u84CB\uF900\u93A7\u958B\u5580\u5BA2\u5751\uF901\u7CB3\u7FB9\u91B5\u5028\u53BB\u5C45\u5DE8\u62D2\u636E\u64DA\u64E7\u6E20\u70AC\u795B\u8DDD\u8E1E\uF902\u907D\u9245\u92F8\u4E7E\u4EF6\u5065\u5DFE\u5EFA\u6106\u6957\u8171\u8654\u8E47\u9375\u9A2B\u4E5E\u5091\u6770\u6840\u5109\u528D\u5292\u6AA2"],
      ["cca1", "\u77BC\u9210\u9ED4\u52AB\u602F\u8FF2\u5048\u61A9\u63ED\u64CA\u683C\u6A84\u6FC0\u8188\u89A1\u9694\u5805\u727D\u72AC\u7504\u7D79\u7E6D\u80A9\u898B\u8B74\u9063\u9D51\u6289\u6C7A\u6F54\u7D50\u7F3A\u8A23\u517C\u614A\u7B9D\u8B19\u9257\u938C\u4EAC\u4FD3\u501E\u50BE\u5106\u52C1\u52CD\u537F\u5770\u5883\u5E9A\u5F91\u6176\u61AC\u64CE\u656C\u666F\u66BB\u66F4\u6897\u6D87\u7085\u70F1\u749F\u74A5\u74CA\u75D9\u786C\u78EC\u7ADF\u7AF6\u7D45\u7D93\u8015\u803F\u811B\u8396\u8B66\u8F15\u9015\u93E1\u9803\u9838\u9A5A\u9BE8\u4FC2\u5553\u583A\u5951\u5B63\u5C46\u60B8\u6212\u6842\u68B0"],
      ["cda1", "\u68E8\u6EAA\u754C\u7678\u78CE\u7A3D\u7CFB\u7E6B\u7E7C\u8A08\u8AA1\u8C3F\u968E\u9DC4\u53E4\u53E9\u544A\u5471\u56FA\u59D1\u5B64\u5C3B\u5EAB\u62F7\u6537\u6545\u6572\u66A0\u67AF\u69C1\u6CBD\u75FC\u7690\u777E\u7A3F\u7F94\u8003\u80A1\u818F\u82E6\u82FD\u83F0\u85C1\u8831\u88B4\u8AA5\uF903\u8F9C\u932E\u96C7\u9867\u9AD8\u9F13\u54ED\u659B\u66F2\u688F\u7A40\u8C37\u9D60\u56F0\u5764\u5D11\u6606\u68B1\u68CD\u6EFE\u7428\u889E\u9BE4\u6C68\uF904\u9AA8\u4F9B\u516C\u5171\u529F\u5B54\u5DE5\u6050\u606D\u62F1\u63A7\u653B\u73D9\u7A7A\u86A3\u8CA2\u978F\u4E32\u5BE1\u6208\u679C\u74DC"],
      ["cea1", "\u79D1\u83D3\u8A87\u8AB2\u8DE8\u904E\u934B\u9846\u5ED3\u69E8\u85FF\u90ED\uF905\u51A0\u5B98\u5BEC\u6163\u68FA\u6B3E\u704C\u742F\u74D8\u7BA1\u7F50\u83C5\u89C0\u8CAB\u95DC\u9928\u522E\u605D\u62EC\u9002\u4F8A\u5149\u5321\u58D9\u5EE3\u66E0\u6D38\u709A\u72C2\u73D6\u7B50\u80F1\u945B\u5366\u639B\u7F6B\u4E56\u5080\u584A\u58DE\u602A\u6127\u62D0\u69D0\u9B41\u5B8F\u7D18\u80B1\u8F5F\u4EA4\u50D1\u54AC\u55AC\u5B0C\u5DA0\u5DE7\u652A\u654E\u6821\u6A4B\u72E1\u768E\u77EF\u7D5E\u7FF9\u81A0\u854E\u86DF\u8F03\u8F4E\u90CA\u9903\u9A55\u9BAB\u4E18\u4E45\u4E5D\u4EC7\u4FF1\u5177\u52FE"],
      ["cfa1", "\u5340\u53E3\u53E5\u548E\u5614\u5775\u57A2\u5BC7\u5D87\u5ED0\u61FC\u62D8\u6551\u67B8\u67E9\u69CB\u6B50\u6BC6\u6BEC\u6C42\u6E9D\u7078\u72D7\u7396\u7403\u77BF\u77E9\u7A76\u7D7F\u8009\u81FC\u8205\u820A\u82DF\u8862\u8B33\u8CFC\u8EC0\u9011\u90B1\u9264\u92B6\u99D2\u9A45\u9CE9\u9DD7\u9F9C\u570B\u5C40\u83CA\u97A0\u97AB\u9EB4\u541B\u7A98\u7FA4\u88D9\u8ECD\u90E1\u5800\u5C48\u6398\u7A9F\u5BAE\u5F13\u7A79\u7AAE\u828E\u8EAC\u5026\u5238\u52F8\u5377\u5708\u62F3\u6372\u6B0A\u6DC3\u7737\u53A5\u7357\u8568\u8E76\u95D5\u673A\u6AC3\u6F70\u8A6D\u8ECC\u994B\uF906\u6677\u6B78\u8CB4"],
      ["d0a1", "\u9B3C\uF907\u53EB\u572D\u594E\u63C6\u69FB\u73EA\u7845\u7ABA\u7AC5\u7CFE\u8475\u898F\u8D73\u9035\u95A8\u52FB\u5747\u7547\u7B60\u83CC\u921E\uF908\u6A58\u514B\u524B\u5287\u621F\u68D8\u6975\u9699\u50C5\u52A4\u52E4\u61C3\u65A4\u6839\u69FF\u747E\u7B4B\u82B9\u83EB\u89B2\u8B39\u8FD1\u9949\uF909\u4ECA\u5997\u64D2\u6611\u6A8E\u7434\u7981\u79BD\u82A9\u887E\u887F\u895F\uF90A\u9326\u4F0B\u53CA\u6025\u6271\u6C72\u7D1A\u7D66\u4E98\u5162\u77DC\u80AF\u4F01\u4F0E\u5176\u5180\u55DC\u5668\u573B\u57FA\u57FC\u5914\u5947\u5993\u5BC4\u5C90\u5D0E\u5DF1\u5E7E\u5FCC\u6280\u65D7\u65E3"],
      ["d1a1", "\u671E\u671F\u675E\u68CB\u68C4\u6A5F\u6B3A\u6C23\u6C7D\u6C82\u6DC7\u7398\u7426\u742A\u7482\u74A3\u7578\u757F\u7881\u78EF\u7941\u7947\u7948\u797A\u7B95\u7D00\u7DBA\u7F88\u8006\u802D\u808C\u8A18\u8B4F\u8C48\u8D77\u9321\u9324\u98E2\u9951\u9A0E\u9A0F\u9A65\u9E92\u7DCA\u4F76\u5409\u62EE\u6854\u91D1\u55AB\u513A\uF90B\uF90C\u5A1C\u61E6\uF90D\u62CF\u62FF\uF90E", 5, "\u90A3\uF914", 4, "\u8AFE\uF919\uF91A\uF91B\uF91C\u6696\uF91D\u7156\uF91E\uF91F\u96E3\uF920\u634F\u637A\u5357\uF921\u678F\u6960\u6E73\uF922\u7537\uF923\uF924\uF925"],
      ["d2a1", "\u7D0D\uF926\uF927\u8872\u56CA\u5A18\uF928", 4, "\u4E43\uF92D\u5167\u5948\u67F0\u8010\uF92E\u5973\u5E74\u649A\u79CA\u5FF5\u606C\u62C8\u637B\u5BE7\u5BD7\u52AA\uF92F\u5974\u5F29\u6012\uF930\uF931\uF932\u7459\uF933", 5, "\u99D1\uF939", 10, "\u6FC3\uF944\uF945\u81BF\u8FB2\u60F1\uF946\uF947\u8166\uF948\uF949\u5C3F\uF94A", 7, "\u5AE9\u8A25\u677B\u7D10\uF952", 5, "\u80FD\uF958\uF959\u5C3C\u6CE5\u533F\u6EBA\u591A\u8336"],
      ["d3a1", "\u4E39\u4EB6\u4F46\u55AE\u5718\u58C7\u5F56\u65B7\u65E6\u6A80\u6BB5\u6E4D\u77ED\u7AEF\u7C1E\u7DDE\u86CB\u8892\u9132\u935B\u64BB\u6FBE\u737A\u75B8\u9054\u5556\u574D\u61BA\u64D4\u66C7\u6DE1\u6E5B\u6F6D\u6FB9\u75F0\u8043\u81BD\u8541\u8983\u8AC7\u8B5A\u931F\u6C93\u7553\u7B54\u8E0F\u905D\u5510\u5802\u5858\u5E62\u6207\u649E\u68E0\u7576\u7CD6\u87B3\u9EE8\u4EE3\u5788\u576E\u5927\u5C0D\u5CB1\u5E36\u5F85\u6234\u64E1\u73B3\u81FA\u888B\u8CB8\u968A\u9EDB\u5B85\u5FB7\u60B3\u5012\u5200\u5230\u5716\u5835\u5857\u5C0E\u5C60\u5CF6\u5D8B\u5EA6\u5F92\u60BC\u6311\u6389\u6417\u6843"],
      ["d4a1", "\u68F9\u6AC2\u6DD8\u6E21\u6ED4\u6FE4\u71FE\u76DC\u7779\u79B1\u7A3B\u8404\u89A9\u8CED\u8DF3\u8E48\u9003\u9014\u9053\u90FD\u934D\u9676\u97DC\u6BD2\u7006\u7258\u72A2\u7368\u7763\u79BF\u7BE4\u7E9B\u8B80\u58A9\u60C7\u6566\u65FD\u66BE\u6C8C\u711E\u71C9\u8C5A\u9813\u4E6D\u7A81\u4EDD\u51AC\u51CD\u52D5\u540C\u61A7\u6771\u6850\u68DF\u6D1E\u6F7C\u75BC\u77B3\u7AE5\u80F4\u8463\u9285\u515C\u6597\u675C\u6793\u75D8\u7AC7\u8373\uF95A\u8C46\u9017\u982D\u5C6F\u81C0\u829A\u9041\u906F\u920D\u5F97\u5D9D\u6A59\u71C8\u767B\u7B49\u85E4\u8B04\u9127\u9A30\u5587\u61F6\uF95B\u7669\u7F85"],
      ["d5a1", "\u863F\u87BA\u88F8\u908F\uF95C\u6D1B\u70D9\u73DE\u7D61\u843D\uF95D\u916A\u99F1\uF95E\u4E82\u5375\u6B04\u6B12\u703E\u721B\u862D\u9E1E\u524C\u8FA3\u5D50\u64E5\u652C\u6B16\u6FEB\u7C43\u7E9C\u85CD\u8964\u89BD\u62C9\u81D8\u881F\u5ECA\u6717\u6D6A\u72FC\u7405\u746F\u8782\u90DE\u4F86\u5D0D\u5FA0\u840A\u51B7\u63A0\u7565\u4EAE\u5006\u5169\u51C9\u6881\u6A11\u7CAE\u7CB1\u7CE7\u826F\u8AD2\u8F1B\u91CF\u4FB6\u5137\u52F5\u5442\u5EEC\u616E\u623E\u65C5\u6ADA\u6FFE\u792A\u85DC\u8823\u95AD\u9A62\u9A6A\u9E97\u9ECE\u529B\u66C6\u6B77\u701D\u792B\u8F62\u9742\u6190\u6200\u6523\u6F23"],
      ["d6a1", "\u7149\u7489\u7DF4\u806F\u84EE\u8F26\u9023\u934A\u51BD\u5217\u52A3\u6D0C\u70C8\u88C2\u5EC9\u6582\u6BAE\u6FC2\u7C3E\u7375\u4EE4\u4F36\u56F9\uF95F\u5CBA\u5DBA\u601C\u73B2\u7B2D\u7F9A\u7FCE\u8046\u901E\u9234\u96F6\u9748\u9818\u9F61\u4F8B\u6FA7\u79AE\u91B4\u96B7\u52DE\uF960\u6488\u64C4\u6AD3\u6F5E\u7018\u7210\u76E7\u8001\u8606\u865C\u8DEF\u8F05\u9732\u9B6F\u9DFA\u9E75\u788C\u797F\u7DA0\u83C9\u9304\u9E7F\u9E93\u8AD6\u58DF\u5F04\u6727\u7027\u74CF\u7C60\u807E\u5121\u7028\u7262\u78CA\u8CC2\u8CDA\u8CF4\u96F7\u4E86\u50DA\u5BEE\u5ED6\u6599\u71CE\u7642\u77AD\u804A\u84FC"],
      ["d7a1", "\u907C\u9B27\u9F8D\u58D8\u5A41\u5C62\u6A13\u6DDA\u6F0F\u763B\u7D2F\u7E37\u851E\u8938\u93E4\u964B\u5289\u65D2\u67F3\u69B4\u6D41\u6E9C\u700F\u7409\u7460\u7559\u7624\u786B\u8B2C\u985E\u516D\u622E\u9678\u4F96\u502B\u5D19\u6DEA\u7DB8\u8F2A\u5F8B\u6144\u6817\uF961\u9686\u52D2\u808B\u51DC\u51CC\u695E\u7A1C\u7DBE\u83F1\u9675\u4FDA\u5229\u5398\u540F\u550E\u5C65\u60A7\u674E\u68A8\u6D6C\u7281\u72F8\u7406\u7483\uF962\u75E2\u7C6C\u7F79\u7FB8\u8389\u88CF\u88E1\u91CC\u91D0\u96E2\u9BC9\u541D\u6F7E\u71D0\u7498\u85FA\u8EAA\u96A3\u9C57\u9E9F\u6797\u6DCB\u7433\u81E8\u9716\u782C"],
      ["d8a1", "\u7ACB\u7B20\u7C92\u6469\u746A\u75F2\u78BC\u78E8\u99AC\u9B54\u9EBB\u5BDE\u5E55\u6F20\u819C\u83AB\u9088\u4E07\u534D\u5A29\u5DD2\u5F4E\u6162\u633D\u6669\u66FC\u6EFF\u6F2B\u7063\u779E\u842C\u8513\u883B\u8F13\u9945\u9C3B\u551C\u62B9\u672B\u6CAB\u8309\u896A\u977A\u4EA1\u5984\u5FD8\u5FD9\u671B\u7DB2\u7F54\u8292\u832B\u83BD\u8F1E\u9099\u57CB\u59B9\u5A92\u5BD0\u6627\u679A\u6885\u6BCF\u7164\u7F75\u8CB7\u8CE3\u9081\u9B45\u8108\u8C8A\u964C\u9A40\u9EA5\u5B5F\u6C13\u731B\u76F2\u76DF\u840C\u51AA\u8993\u514D\u5195\u52C9\u68C9\u6C94\u7704\u7720\u7DBF\u7DEC\u9762\u9EB5\u6EC5"],
      ["d9a1", "\u8511\u51A5\u540D\u547D\u660E\u669D\u6927\u6E9F\u76BF\u7791\u8317\u84C2\u879F\u9169\u9298\u9CF4\u8882\u4FAE\u5192\u52DF\u59C6\u5E3D\u6155\u6478\u6479\u66AE\u67D0\u6A21\u6BCD\u6BDB\u725F\u7261\u7441\u7738\u77DB\u8017\u82BC\u8305\u8B00\u8B28\u8C8C\u6728\u6C90\u7267\u76EE\u7766\u7A46\u9DA9\u6B7F\u6C92\u5922\u6726\u8499\u536F\u5893\u5999\u5EDF\u63CF\u6634\u6773\u6E3A\u732B\u7AD7\u82D7\u9328\u52D9\u5DEB\u61AE\u61CB\u620A\u62C7\u64AB\u65E0\u6959\u6B66\u6BCB\u7121\u73F7\u755D\u7E46\u821E\u8302\u856A\u8AA3\u8CBF\u9727\u9D61\u58A8\u9ED8\u5011\u520E\u543B\u554F\u6587"],
      ["daa1", "\u6C76\u7D0A\u7D0B\u805E\u868A\u9580\u96EF\u52FF\u6C95\u7269\u5473\u5A9A\u5C3E\u5D4B\u5F4C\u5FAE\u672A\u68B6\u6963\u6E3C\u6E44\u7709\u7C73\u7F8E\u8587\u8B0E\u8FF7\u9761\u9EF4\u5CB7\u60B6\u610D\u61AB\u654F\u65FB\u65FC\u6C11\u6CEF\u739F\u73C9\u7DE1\u9594\u5BC6\u871C\u8B10\u525D\u535A\u62CD\u640F\u64B2\u6734\u6A38\u6CCA\u73C0\u749E\u7B94\u7C95\u7E1B\u818A\u8236\u8584\u8FEB\u96F9\u99C1\u4F34\u534A\u53CD\u53DB\u62CC\u642C\u6500\u6591\u69C3\u6CEE\u6F58\u73ED\u7554\u7622\u76E4\u76FC\u78D0\u78FB\u792C\u7D46\u822C\u87E0\u8FD4\u9812\u98EF\u52C3\u62D4\u64A5\u6E24\u6F51"],
      ["dba1", "\u767C\u8DCB\u91B1\u9262\u9AEE\u9B43\u5023\u508D\u574A\u59A8\u5C28\u5E47\u5F77\u623F\u653E\u65B9\u65C1\u6609\u678B\u699C\u6EC2\u78C5\u7D21\u80AA\u8180\u822B\u82B3\u84A1\u868C\u8A2A\u8B17\u90A6\u9632\u9F90\u500D\u4FF3\uF963\u57F9\u5F98\u62DC\u6392\u676F\u6E43\u7119\u76C3\u80CC\u80DA\u88F4\u88F5\u8919\u8CE0\u8F29\u914D\u966A\u4F2F\u4F70\u5E1B\u67CF\u6822\u767D\u767E\u9B44\u5E61\u6A0A\u7169\u71D4\u756A\uF964\u7E41\u8543\u85E9\u98DC\u4F10\u7B4F\u7F70\u95A5\u51E1\u5E06\u68B5\u6C3E\u6C4E\u6CDB\u72AF\u7BC4\u8303\u6CD5\u743A\u50FB\u5288\u58C1\u64D8\u6A97\u74A7\u7656"],
      ["dca1", "\u78A7\u8617\u95E2\u9739\uF965\u535E\u5F01\u8B8A\u8FA8\u8FAF\u908A\u5225\u77A5\u9C49\u9F08\u4E19\u5002\u5175\u5C5B\u5E77\u661E\u663A\u67C4\u68C5\u70B3\u7501\u75C5\u79C9\u7ADD\u8F27\u9920\u9A08\u4FDD\u5821\u5831\u5BF6\u666E\u6B65\u6D11\u6E7A\u6F7D\u73E4\u752B\u83E9\u88DC\u8913\u8B5C\u8F14\u4F0F\u50D5\u5310\u535C\u5B93\u5FA9\u670D\u798F\u8179\u832F\u8514\u8907\u8986\u8F39\u8F3B\u99A5\u9C12\u672C\u4E76\u4FF8\u5949\u5C01\u5CEF\u5CF0\u6367\u68D2\u70FD\u71A2\u742B\u7E2B\u84EC\u8702\u9022\u92D2\u9CF3\u4E0D\u4ED8\u4FEF\u5085\u5256\u526F\u5426\u5490\u57E0\u592B\u5A66"],
      ["dda1", "\u5B5A\u5B75\u5BCC\u5E9C\uF966\u6276\u6577\u65A7\u6D6E\u6EA5\u7236\u7B26\u7C3F\u7F36\u8150\u8151\u819A\u8240\u8299\u83A9\u8A03\u8CA0\u8CE6\u8CFB\u8D74\u8DBA\u90E8\u91DC\u961C\u9644\u99D9\u9CE7\u5317\u5206\u5429\u5674\u58B3\u5954\u596E\u5FFF\u61A4\u626E\u6610\u6C7E\u711A\u76C6\u7C89\u7CDE\u7D1B\u82AC\u8CC1\u96F0\uF967\u4F5B\u5F17\u5F7F\u62C2\u5D29\u670B\u68DA\u787C\u7E43\u9D6C\u4E15\u5099\u5315\u532A\u5351\u5983\u5A62\u5E87\u60B2\u618A\u6249\u6279\u6590\u6787\u69A7\u6BD4\u6BD6\u6BD7\u6BD8\u6CB8\uF968\u7435\u75FA\u7812\u7891\u79D5\u79D8\u7C83\u7DCB\u7FE1\u80A5"],
      ["dea1", "\u813E\u81C2\u83F2\u871A\u88E8\u8AB9\u8B6C\u8CBB\u9119\u975E\u98DB\u9F3B\u56AC\u5B2A\u5F6C\u658C\u6AB3\u6BAF\u6D5C\u6FF1\u7015\u725D\u73AD\u8CA7\u8CD3\u983B\u6191\u6C37\u8058\u9A01\u4E4D\u4E8B\u4E9B\u4ED5\u4F3A\u4F3C\u4F7F\u4FDF\u50FF\u53F2\u53F8\u5506\u55E3\u56DB\u58EB\u5962\u5A11\u5BEB\u5BFA\u5C04\u5DF3\u5E2B\u5F99\u601D\u6368\u659C\u65AF\u67F6\u67FB\u68AD\u6B7B\u6C99\u6CD7\u6E23\u7009\u7345\u7802\u793E\u7940\u7960\u79C1\u7BE9\u7D17\u7D72\u8086\u820D\u838E\u84D1\u86C7\u88DF\u8A50\u8A5E\u8B1D\u8CDC\u8D66\u8FAD\u90AA\u98FC\u99DF\u9E9D\u524A\uF969\u6714\uF96A"],
      ["dfa1", "\u5098\u522A\u5C71\u6563\u6C55\u73CA\u7523\u759D\u7B97\u849C\u9178\u9730\u4E77\u6492\u6BBA\u715E\u85A9\u4E09\uF96B\u6749\u68EE\u6E17\u829F\u8518\u886B\u63F7\u6F81\u9212\u98AF\u4E0A\u50B7\u50CF\u511F\u5546\u55AA\u5617\u5B40\u5C19\u5CE0\u5E38\u5E8A\u5EA0\u5EC2\u60F3\u6851\u6A61\u6E58\u723D\u7240\u72C0\u76F8\u7965\u7BB1\u7FD4\u88F3\u89F4\u8A73\u8C61\u8CDE\u971C\u585E\u74BD\u8CFD\u55C7\uF96C\u7A61\u7D22\u8272\u7272\u751F\u7525\uF96D\u7B19\u5885\u58FB\u5DBC\u5E8F\u5EB6\u5F90\u6055\u6292\u637F\u654D\u6691\u66D9\u66F8\u6816\u68F2\u7280\u745E\u7B6E\u7D6E\u7DD6\u7F72"],
      ["e0a1", "\u80E5\u8212\u85AF\u897F\u8A93\u901D\u92E4\u9ECD\u9F20\u5915\u596D\u5E2D\u60DC\u6614\u6673\u6790\u6C50\u6DC5\u6F5F\u77F3\u78A9\u84C6\u91CB\u932B\u4ED9\u50CA\u5148\u5584\u5B0B\u5BA3\u6247\u657E\u65CB\u6E32\u717D\u7401\u7444\u7487\u74BF\u766C\u79AA\u7DDA\u7E55\u7FA8\u817A\u81B3\u8239\u861A\u87EC\u8A75\u8DE3\u9078\u9291\u9425\u994D\u9BAE\u5368\u5C51\u6954\u6CC4\u6D29\u6E2B\u820C\u859B\u893B\u8A2D\u8AAA\u96EA\u9F67\u5261\u66B9\u6BB2\u7E96\u87FE\u8D0D\u9583\u965D\u651D\u6D89\u71EE\uF96E\u57CE\u59D3\u5BAC\u6027\u60FA\u6210\u661F\u665F\u7329\u73F9\u76DB\u7701\u7B6C"],
      ["e1a1", "\u8056\u8072\u8165\u8AA0\u9192\u4E16\u52E2\u6B72\u6D17\u7A05\u7B39\u7D30\uF96F\u8CB0\u53EC\u562F\u5851\u5BB5\u5C0F\u5C11\u5DE2\u6240\u6383\u6414\u662D\u68B3\u6CBC\u6D88\u6EAF\u701F\u70A4\u71D2\u7526\u758F\u758E\u7619\u7B11\u7BE0\u7C2B\u7D20\u7D39\u852C\u856D\u8607\u8A34\u900D\u9061\u90B5\u92B7\u97F6\u9A37\u4FD7\u5C6C\u675F\u6D91\u7C9F\u7E8C\u8B16\u8D16\u901F\u5B6B\u5DFD\u640D\u84C0\u905C\u98E1\u7387\u5B8B\u609A\u677E\u6DDE\u8A1F\u8AA6\u9001\u980C\u5237\uF970\u7051\u788E\u9396\u8870\u91D7\u4FEE\u53D7\u55FD\u56DA\u5782\u58FD\u5AC2\u5B88\u5CAB\u5CC0\u5E25\u6101"],
      ["e2a1", "\u620D\u624B\u6388\u641C\u6536\u6578\u6A39\u6B8A\u6C34\u6D19\u6F31\u71E7\u72E9\u7378\u7407\u74B2\u7626\u7761\u79C0\u7A57\u7AEA\u7CB9\u7D8F\u7DAC\u7E61\u7F9E\u8129\u8331\u8490\u84DA\u85EA\u8896\u8AB0\u8B90\u8F38\u9042\u9083\u916C\u9296\u92B9\u968B\u96A7\u96A8\u96D6\u9700\u9808\u9996\u9AD3\u9B1A\u53D4\u587E\u5919\u5B70\u5BBF\u6DD1\u6F5A\u719F\u7421\u74B9\u8085\u83FD\u5DE1\u5F87\u5FAA\u6042\u65EC\u6812\u696F\u6A53\u6B89\u6D35\u6DF3\u73E3\u76FE\u77AC\u7B4D\u7D14\u8123\u821C\u8340\u84F4\u8563\u8A62\u8AC4\u9187\u931E\u9806\u99B4\u620C\u8853\u8FF0\u9265\u5D07\u5D27"],
      ["e3a1", "\u5D69\u745F\u819D\u8768\u6FD5\u62FE\u7FD2\u8936\u8972\u4E1E\u4E58\u50E7\u52DD\u5347\u627F\u6607\u7E69\u8805\u965E\u4F8D\u5319\u5636\u59CB\u5AA4\u5C38\u5C4E\u5C4D\u5E02\u5F11\u6043\u65BD\u662F\u6642\u67BE\u67F4\u731C\u77E2\u793A\u7FC5\u8494\u84CD\u8996\u8A66\u8A69\u8AE1\u8C55\u8C7A\u57F4\u5BD4\u5F0F\u606F\u62ED\u690D\u6B96\u6E5C\u7184\u7BD2\u8755\u8B58\u8EFE\u98DF\u98FE\u4F38\u4F81\u4FE1\u547B\u5A20\u5BB8\u613C\u65B0\u6668\u71FC\u7533\u795E\u7D33\u814E\u81E3\u8398\u85AA\u85CE\u8703\u8A0A\u8EAB\u8F9B\uF971\u8FC5\u5931\u5BA4\u5BE6\u6089\u5BE9\u5C0B\u5FC3\u6C81"],
      ["e4a1", "\uF972\u6DF1\u700B\u751A\u82AF\u8AF6\u4EC0\u5341\uF973\u96D9\u6C0F\u4E9E\u4FC4\u5152\u555E\u5A25\u5CE8\u6211\u7259\u82BD\u83AA\u86FE\u8859\u8A1D\u963F\u96C5\u9913\u9D09\u9D5D\u580A\u5CB3\u5DBD\u5E44\u60E1\u6115\u63E1\u6A02\u6E25\u9102\u9354\u984E\u9C10\u9F77\u5B89\u5CB8\u6309\u664F\u6848\u773C\u96C1\u978D\u9854\u9B9F\u65A1\u8B01\u8ECB\u95BC\u5535\u5CA9\u5DD6\u5EB5\u6697\u764C\u83F4\u95C7\u58D3\u62BC\u72CE\u9D28\u4EF0\u592E\u600F\u663B\u6B83\u79E7\u9D26\u5393\u54C0\u57C3\u5D16\u611B\u66D6\u6DAF\u788D\u827E\u9698\u9744\u5384\u627C\u6396\u6DB2\u7E0A\u814B\u984D"],
      ["e5a1", "\u6AFB\u7F4C\u9DAF\u9E1A\u4E5F\u503B\u51B6\u591C\u60F9\u63F6\u6930\u723A\u8036\uF974\u91CE\u5F31\uF975\uF976\u7D04\u82E5\u846F\u84BB\u85E5\u8E8D\uF977\u4F6F\uF978\uF979\u58E4\u5B43\u6059\u63DA\u6518\u656D\u6698\uF97A\u694A\u6A23\u6D0B\u7001\u716C\u75D2\u760D\u79B3\u7A70\uF97B\u7F8A\uF97C\u8944\uF97D\u8B93\u91C0\u967D\uF97E\u990A\u5704\u5FA1\u65BC\u6F01\u7600\u79A6\u8A9E\u99AD\u9B5A\u9F6C\u5104\u61B6\u6291\u6A8D\u81C6\u5043\u5830\u5F66\u7109\u8A00\u8AFA\u5B7C\u8616\u4FFA\u513C\u56B4\u5944\u63A9\u6DF9\u5DAA\u696D\u5186\u4E88\u4F59\uF97F\uF980\uF981\u5982\uF982"],
      ["e6a1", "\uF983\u6B5F\u6C5D\uF984\u74B5\u7916\uF985\u8207\u8245\u8339\u8F3F\u8F5D\uF986\u9918\uF987\uF988\uF989\u4EA6\uF98A\u57DF\u5F79\u6613\uF98B\uF98C\u75AB\u7E79\u8B6F\uF98D\u9006\u9A5B\u56A5\u5827\u59F8\u5A1F\u5BB4\uF98E\u5EF6\uF98F\uF990\u6350\u633B\uF991\u693D\u6C87\u6CBF\u6D8E\u6D93\u6DF5\u6F14\uF992\u70DF\u7136\u7159\uF993\u71C3\u71D5\uF994\u784F\u786F\uF995\u7B75\u7DE3\uF996\u7E2F\uF997\u884D\u8EDF\uF998\uF999\uF99A\u925B\uF99B\u9CF6\uF99C\uF99D\uF99E\u6085\u6D85\uF99F\u71B1\uF9A0\uF9A1\u95B1\u53AD\uF9A2\uF9A3\uF9A4\u67D3\uF9A5\u708E\u7130\u7430\u8276\u82D2"],
      ["e7a1", "\uF9A6\u95BB\u9AE5\u9E7D\u66C4\uF9A7\u71C1\u8449\uF9A8\uF9A9\u584B\uF9AA\uF9AB\u5DB8\u5F71\uF9AC\u6620\u668E\u6979\u69AE\u6C38\u6CF3\u6E36\u6F41\u6FDA\u701B\u702F\u7150\u71DF\u7370\uF9AD\u745B\uF9AE\u74D4\u76C8\u7A4E\u7E93\uF9AF\uF9B0\u82F1\u8A60\u8FCE\uF9B1\u9348\uF9B2\u9719\uF9B3\uF9B4\u4E42\u502A\uF9B5\u5208\u53E1\u66F3\u6C6D\u6FCA\u730A\u777F\u7A62\u82AE\u85DD\u8602\uF9B6\u88D4\u8A63\u8B7D\u8C6B\uF9B7\u92B3\uF9B8\u9713\u9810\u4E94\u4F0D\u4FC9\u50B2\u5348\u543E\u5433\u55DA\u5862\u58BA\u5967\u5A1B\u5BE4\u609F\uF9B9\u61CA\u6556\u65FF\u6664\u68A7\u6C5A\u6FB3"],
      ["e8a1", "\u70CF\u71AC\u7352\u7B7D\u8708\u8AA4\u9C32\u9F07\u5C4B\u6C83\u7344\u7389\u923A\u6EAB\u7465\u761F\u7A69\u7E15\u860A\u5140\u58C5\u64C1\u74EE\u7515\u7670\u7FC1\u9095\u96CD\u9954\u6E26\u74E6\u7AA9\u7AAA\u81E5\u86D9\u8778\u8A1B\u5A49\u5B8C\u5B9B\u68A1\u6900\u6D63\u73A9\u7413\u742C\u7897\u7DE9\u7FEB\u8118\u8155\u839E\u8C4C\u962E\u9811\u66F0\u5F80\u65FA\u6789\u6C6A\u738B\u502D\u5A03\u6B6A\u77EE\u5916\u5D6C\u5DCD\u7325\u754F\uF9BA\uF9BB\u50E5\u51F9\u582F\u592D\u5996\u59DA\u5BE5\uF9BC\uF9BD\u5DA2\u62D7\u6416\u6493\u64FE\uF9BE\u66DC\uF9BF\u6A48\uF9C0\u71FF\u7464\uF9C1"],
      ["e9a1", "\u7A88\u7AAF\u7E47\u7E5E\u8000\u8170\uF9C2\u87EF\u8981\u8B20\u9059\uF9C3\u9080\u9952\u617E\u6B32\u6D74\u7E1F\u8925\u8FB1\u4FD1\u50AD\u5197\u52C7\u57C7\u5889\u5BB9\u5EB8\u6142\u6995\u6D8C\u6E67\u6EB6\u7194\u7462\u7528\u752C\u8073\u8338\u84C9\u8E0A\u9394\u93DE\uF9C4\u4E8E\u4F51\u5076\u512A\u53C8\u53CB\u53F3\u5B87\u5BD3\u5C24\u611A\u6182\u65F4\u725B\u7397\u7440\u76C2\u7950\u7991\u79B9\u7D06\u7FBD\u828B\u85D5\u865E\u8FC2\u9047\u90F5\u91EA\u9685\u96E8\u96E9\u52D6\u5F67\u65ED\u6631\u682F\u715C\u7A36\u90C1\u980A\u4E91\uF9C5\u6A52\u6B9E\u6F90\u7189\u8018\u82B8\u8553"],
      ["eaa1", "\u904B\u9695\u96F2\u97FB\u851A\u9B31\u4E90\u718A\u96C4\u5143\u539F\u54E1\u5713\u5712\u57A3\u5A9B\u5AC4\u5BC3\u6028\u613F\u63F4\u6C85\u6D39\u6E72\u6E90\u7230\u733F\u7457\u82D1\u8881\u8F45\u9060\uF9C6\u9662\u9858\u9D1B\u6708\u8D8A\u925E\u4F4D\u5049\u50DE\u5371\u570D\u59D4\u5A01\u5C09\u6170\u6690\u6E2D\u7232\u744B\u7DEF\u80C3\u840E\u8466\u853F\u875F\u885B\u8918\u8B02\u9055\u97CB\u9B4F\u4E73\u4F91\u5112\u516A\uF9C7\u552F\u55A9\u5B7A\u5BA5\u5E7C\u5E7D\u5EBE\u60A0\u60DF\u6108\u6109\u63C4\u6538\u6709\uF9C8\u67D4\u67DA\uF9C9\u6961\u6962\u6CB9\u6D27\uF9CA\u6E38\uF9CB"],
      ["eba1", "\u6FE1\u7336\u7337\uF9CC\u745C\u7531\uF9CD\u7652\uF9CE\uF9CF\u7DAD\u81FE\u8438\u88D5\u8A98\u8ADB\u8AED\u8E30\u8E42\u904A\u903E\u907A\u9149\u91C9\u936E\uF9D0\uF9D1\u5809\uF9D2\u6BD3\u8089\u80B2\uF9D3\uF9D4\u5141\u596B\u5C39\uF9D5\uF9D6\u6F64\u73A7\u80E4\u8D07\uF9D7\u9217\u958F\uF9D8\uF9D9\uF9DA\uF9DB\u807F\u620E\u701C\u7D68\u878D\uF9DC\u57A0\u6069\u6147\u6BB7\u8ABE\u9280\u96B1\u4E59\u541F\u6DEB\u852D\u9670\u97F3\u98EE\u63D6\u6CE3\u9091\u51DD\u61C9\u81BA\u9DF9\u4F9D\u501A\u5100\u5B9C\u610F\u61FF\u64EC\u6905\u6BC5\u7591\u77E3\u7FA9\u8264\u858F\u87FB\u8863\u8ABC"],
      ["eca1", "\u8B70\u91AB\u4E8C\u4EE5\u4F0A\uF9DD\uF9DE\u5937\u59E8\uF9DF\u5DF2\u5F1B\u5F5B\u6021\uF9E0\uF9E1\uF9E2\uF9E3\u723E\u73E5\uF9E4\u7570\u75CD\uF9E5\u79FB\uF9E6\u800C\u8033\u8084\u82E1\u8351\uF9E7\uF9E8\u8CBD\u8CB3\u9087\uF9E9\uF9EA\u98F4\u990C\uF9EB\uF9EC\u7037\u76CA\u7FCA\u7FCC\u7FFC\u8B1A\u4EBA\u4EC1\u5203\u5370\uF9ED\u54BD\u56E0\u59FB\u5BC5\u5F15\u5FCD\u6E6E\uF9EE\uF9EF\u7D6A\u8335\uF9F0\u8693\u8A8D\uF9F1\u976D\u9777\uF9F2\uF9F3\u4E00\u4F5A\u4F7E\u58F9\u65E5\u6EA2\u9038\u93B0\u99B9\u4EFB\u58EC\u598A\u59D9\u6041\uF9F4\uF9F5\u7A14\uF9F6\u834F\u8CC3\u5165\u5344"],
      ["eda1", "\uF9F7\uF9F8\uF9F9\u4ECD\u5269\u5B55\u82BF\u4ED4\u523A\u54A8\u59C9\u59FF\u5B50\u5B57\u5B5C\u6063\u6148\u6ECB\u7099\u716E\u7386\u74F7\u75B5\u78C1\u7D2B\u8005\u81EA\u8328\u8517\u85C9\u8AEE\u8CC7\u96CC\u4F5C\u52FA\u56BC\u65AB\u6628\u707C\u70B8\u7235\u7DBD\u828D\u914C\u96C0\u9D72\u5B71\u68E7\u6B98\u6F7A\u76DE\u5C91\u66AB\u6F5B\u7BB4\u7C2A\u8836\u96DC\u4E08\u4ED7\u5320\u5834\u58BB\u58EF\u596C\u5C07\u5E33\u5E84\u5F35\u638C\u66B2\u6756\u6A1F\u6AA3\u6B0C\u6F3F\u7246\uF9FA\u7350\u748B\u7AE0\u7CA7\u8178\u81DF\u81E7\u838A\u846C\u8523\u8594\u85CF\u88DD\u8D13\u91AC\u9577"],
      ["eea1", "\u969C\u518D\u54C9\u5728\u5BB0\u624D\u6750\u683D\u6893\u6E3D\u6ED3\u707D\u7E21\u88C1\u8CA1\u8F09\u9F4B\u9F4E\u722D\u7B8F\u8ACD\u931A\u4F47\u4F4E\u5132\u5480\u59D0\u5E95\u62B5\u6775\u696E\u6A17\u6CAE\u6E1A\u72D9\u732A\u75BD\u7BB8\u7D35\u82E7\u83F9\u8457\u85F7\u8A5B\u8CAF\u8E87\u9019\u90B8\u96CE\u9F5F\u52E3\u540A\u5AE1\u5BC2\u6458\u6575\u6EF4\u72C4\uF9FB\u7684\u7A4D\u7B1B\u7C4D\u7E3E\u7FDF\u837B\u8B2B\u8CCA\u8D64\u8DE1\u8E5F\u8FEA\u8FF9\u9069\u93D1\u4F43\u4F7A\u50B3\u5168\u5178\u524D\u526A\u5861\u587C\u5960\u5C08\u5C55\u5EDB\u609B\u6230\u6813\u6BBF\u6C08\u6FB1"],
      ["efa1", "\u714E\u7420\u7530\u7538\u7551\u7672\u7B4C\u7B8B\u7BAD\u7BC6\u7E8F\u8A6E\u8F3E\u8F49\u923F\u9293\u9322\u942B\u96FB\u985A\u986B\u991E\u5207\u622A\u6298\u6D59\u7664\u7ACA\u7BC0\u7D76\u5360\u5CBE\u5E97\u6F38\u70B9\u7C98\u9711\u9B8E\u9EDE\u63A5\u647A\u8776\u4E01\u4E95\u4EAD\u505C\u5075\u5448\u59C3\u5B9A\u5E40\u5EAD\u5EF7\u5F81\u60C5\u633A\u653F\u6574\u65CC\u6676\u6678\u67FE\u6968\u6A89\u6B63\u6C40\u6DC0\u6DE8\u6E1F\u6E5E\u701E\u70A1\u738E\u73FD\u753A\u775B\u7887\u798E\u7A0B\u7A7D\u7CBE\u7D8E\u8247\u8A02\u8AEA\u8C9E\u912D\u914A\u91D8\u9266\u92CC\u9320\u9706\u9756"],
      ["f0a1", "\u975C\u9802\u9F0E\u5236\u5291\u557C\u5824\u5E1D\u5F1F\u608C\u63D0\u68AF\u6FDF\u796D\u7B2C\u81CD\u85BA\u88FD\u8AF8\u8E44\u918D\u9664\u969B\u973D\u984C\u9F4A\u4FCE\u5146\u51CB\u52A9\u5632\u5F14\u5F6B\u63AA\u64CD\u65E9\u6641\u66FA\u66F9\u671D\u689D\u68D7\u69FD\u6F15\u6F6E\u7167\u71E5\u722A\u74AA\u773A\u7956\u795A\u79DF\u7A20\u7A95\u7C97\u7CDF\u7D44\u7E70\u8087\u85FB\u86A4\u8A54\u8ABF\u8D99\u8E81\u9020\u906D\u91E3\u963B\u96D5\u9CE5\u65CF\u7C07\u8DB3\u93C3\u5B58\u5C0A\u5352\u62D9\u731D\u5027\u5B97\u5F9E\u60B0\u616B\u68D5\u6DD9\u742E\u7A2E\u7D42\u7D9C\u7E31\u816B"],
      ["f1a1", "\u8E2A\u8E35\u937E\u9418\u4F50\u5750\u5DE6\u5EA7\u632B\u7F6A\u4E3B\u4F4F\u4F8F\u505A\u59DD\u80C4\u546A\u5468\u55FE\u594F\u5B99\u5DDE\u5EDA\u665D\u6731\u67F1\u682A\u6CE8\u6D32\u6E4A\u6F8D\u70B7\u73E0\u7587\u7C4C\u7D02\u7D2C\u7DA2\u821F\u86DB\u8A3B\u8A85\u8D70\u8E8A\u8F33\u9031\u914E\u9152\u9444\u99D0\u7AF9\u7CA5\u4FCA\u5101\u51C6\u57C8\u5BEF\u5CFB\u6659\u6A3D\u6D5A\u6E96\u6FEC\u710C\u756F\u7AE3\u8822\u9021\u9075\u96CB\u99FF\u8301\u4E2D\u4EF2\u8846\u91CD\u537D\u6ADB\u696B\u6C41\u847A\u589E\u618E\u66FE\u62EF\u70DD\u7511\u75C7\u7E52\u84B8\u8B49\u8D08\u4E4B\u53EA"],
      ["f2a1", "\u54AB\u5730\u5740\u5FD7\u6301\u6307\u646F\u652F\u65E8\u667A\u679D\u67B3\u6B62\u6C60\u6C9A\u6F2C\u77E5\u7825\u7949\u7957\u7D19\u80A2\u8102\u81F3\u829D\u82B7\u8718\u8A8C\uF9FC\u8D04\u8DBE\u9072\u76F4\u7A19\u7A37\u7E54\u8077\u5507\u55D4\u5875\u632F\u6422\u6649\u664B\u686D\u699B\u6B84\u6D25\u6EB1\u73CD\u7468\u74A1\u755B\u75B9\u76E1\u771E\u778B\u79E6\u7E09\u7E1D\u81FB\u852F\u8897\u8A3A\u8CD1\u8EEB\u8FB0\u9032\u93AD\u9663\u9673\u9707\u4F84\u53F1\u59EA\u5AC9\u5E19\u684E\u74C6\u75BE\u79E9\u7A92\u81A3\u86ED\u8CEA\u8DCC\u8FED\u659F\u6715\uF9FD\u57F7\u6F57\u7DDD\u8F2F"],
      ["f3a1", "\u93F6\u96C6\u5FB5\u61F2\u6F84\u4E14\u4F98\u501F\u53C9\u55DF\u5D6F\u5DEE\u6B21\u6B64\u78CB\u7B9A\uF9FE\u8E49\u8ECA\u906E\u6349\u643E\u7740\u7A84\u932F\u947F\u9F6A\u64B0\u6FAF\u71E6\u74A8\u74DA\u7AC4\u7C12\u7E82\u7CB2\u7E98\u8B9A\u8D0A\u947D\u9910\u994C\u5239\u5BDF\u64E6\u672D\u7D2E\u50ED\u53C3\u5879\u6158\u6159\u61FA\u65AC\u7AD9\u8B92\u8B96\u5009\u5021\u5275\u5531\u5A3C\u5EE0\u5F70\u6134\u655E\u660C\u6636\u66A2\u69CD\u6EC4\u6F32\u7316\u7621\u7A93\u8139\u8259\u83D6\u84BC\u50B5\u57F0\u5BC0\u5BE8\u5F69\u63A1\u7826\u7DB5\u83DC\u8521\u91C7\u91F5\u518A\u67F5\u7B56"],
      ["f4a1", "\u8CAC\u51C4\u59BB\u60BD\u8655\u501C\uF9FF\u5254\u5C3A\u617D\u621A\u62D3\u64F2\u65A5\u6ECC\u7620\u810A\u8E60\u965F\u96BB\u4EDF\u5343\u5598\u5929\u5DDD\u64C5\u6CC9\u6DFA\u7394\u7A7F\u821B\u85A6\u8CE4\u8E10\u9077\u91E7\u95E1\u9621\u97C6\u51F8\u54F2\u5586\u5FB9\u64A4\u6F88\u7DB4\u8F1F\u8F4D\u9435\u50C9\u5C16\u6CBE\u6DFB\u751B\u77BB\u7C3D\u7C64\u8A79\u8AC2\u581E\u59BE\u5E16\u6377\u7252\u758A\u776B\u8ADC\u8CBC\u8F12\u5EF3\u6674\u6DF8\u807D\u83C1\u8ACB\u9751\u9BD6\uFA00\u5243\u66FF\u6D95\u6EEF\u7DE0\u8AE6\u902E\u905E\u9AD4\u521D\u527F\u54E8\u6194\u6284\u62DB\u68A2"],
      ["f5a1", "\u6912\u695A\u6A35\u7092\u7126\u785D\u7901\u790E\u79D2\u7A0D\u8096\u8278\u82D5\u8349\u8549\u8C82\u8D85\u9162\u918B\u91AE\u4FC3\u56D1\u71ED\u77D7\u8700\u89F8\u5BF8\u5FD6\u6751\u90A8\u53E2\u585A\u5BF5\u60A4\u6181\u6460\u7E3D\u8070\u8525\u9283\u64AE\u50AC\u5D14\u6700\u589C\u62BD\u63A8\u690E\u6978\u6A1E\u6E6B\u76BA\u79CB\u82BB\u8429\u8ACF\u8DA8\u8FFD\u9112\u914B\u919C\u9310\u9318\u939A\u96DB\u9A36\u9C0D\u4E11\u755C\u795D\u7AFA\u7B51\u7BC9\u7E2E\u84C4\u8E59\u8E74\u8EF8\u9010\u6625\u693F\u7443\u51FA\u672E\u9EDC\u5145\u5FE0\u6C96\u87F2\u885D\u8877\u60B4\u81B5\u8403"],
      ["f6a1", "\u8D05\u53D6\u5439\u5634\u5A36\u5C31\u708A\u7FE0\u805A\u8106\u81ED\u8DA3\u9189\u9A5F\u9DF2\u5074\u4EC4\u53A0\u60FB\u6E2C\u5C64\u4F88\u5024\u55E4\u5CD9\u5E5F\u6065\u6894\u6CBB\u6DC4\u71BE\u75D4\u75F4\u7661\u7A1A\u7A49\u7DC7\u7DFB\u7F6E\u81F4\u86A9\u8F1C\u96C9\u99B3\u9F52\u5247\u52C5\u98ED\u89AA\u4E03\u67D2\u6F06\u4FB5\u5BE2\u6795\u6C88\u6D78\u741B\u7827\u91DD\u937C\u87C4\u79E4\u7A31\u5FEB\u4ED6\u54A4\u553E\u58AE\u59A5\u60F0\u6253\u62D6\u6736\u6955\u8235\u9640\u99B1\u99DD\u502C\u5353\u5544\u577C\uFA01\u6258\uFA02\u64E2\u666B\u67DD\u6FC1\u6FEF\u7422\u7438\u8A17"],
      ["f7a1", "\u9438\u5451\u5606\u5766\u5F48\u619A\u6B4E\u7058\u70AD\u7DBB\u8A95\u596A\u812B\u63A2\u7708\u803D\u8CAA\u5854\u642D\u69BB\u5B95\u5E11\u6E6F\uFA03\u8569\u514C\u53F0\u592A\u6020\u614B\u6B86\u6C70\u6CF0\u7B1E\u80CE\u82D4\u8DC6\u90B0\u98B1\uFA04\u64C7\u6FA4\u6491\u6504\u514E\u5410\u571F\u8A0E\u615F\u6876\uFA05\u75DB\u7B52\u7D71\u901A\u5806\u69CC\u817F\u892A\u9000\u9839\u5078\u5957\u59AC\u6295\u900F\u9B2A\u615D\u7279\u95D6\u5761\u5A46\u5DF4\u628A\u64AD\u64FA\u6777\u6CE2\u6D3E\u722C\u7436\u7834\u7F77\u82AD\u8DDB\u9817\u5224\u5742\u677F\u7248\u74E3\u8CA9\u8FA6\u9211"],
      ["f8a1", "\u962A\u516B\u53ED\u634C\u4F69\u5504\u6096\u6557\u6C9B\u6D7F\u724C\u72FD\u7A17\u8987\u8C9D\u5F6D\u6F8E\u70F9\u81A8\u610E\u4FBF\u504F\u6241\u7247\u7BC7\u7DE8\u7FE9\u904D\u97AD\u9A19\u8CB6\u576A\u5E73\u67B0\u840D\u8A55\u5420\u5B16\u5E63\u5EE2\u5F0A\u6583\u80BA\u853D\u9589\u965B\u4F48\u5305\u530D\u530F\u5486\u54FA\u5703\u5E03\u6016\u629B\u62B1\u6355\uFA06\u6CE1\u6D66\u75B1\u7832\u80DE\u812F\u82DE\u8461\u84B2\u888D\u8912\u900B\u92EA\u98FD\u9B91\u5E45\u66B4\u66DD\u7011\u7206\uFA07\u4FF5\u527D\u5F6A\u6153\u6753\u6A19\u6F02\u74E2\u7968\u8868\u8C79\u98C7\u98C4\u9A43"],
      ["f9a1", "\u54C1\u7A1F\u6953\u8AF7\u8C4A\u98A8\u99AE\u5F7C\u62AB\u75B2\u76AE\u88AB\u907F\u9642\u5339\u5F3C\u5FC5\u6CCC\u73CC\u7562\u758B\u7B46\u82FE\u999D\u4E4F\u903C\u4E0B\u4F55\u53A6\u590F\u5EC8\u6630\u6CB3\u7455\u8377\u8766\u8CC0\u9050\u971E\u9C15\u58D1\u5B78\u8650\u8B14\u9DB4\u5BD2\u6068\u608D\u65F1\u6C57\u6F22\u6FA3\u701A\u7F55\u7FF0\u9591\u9592\u9650\u97D3\u5272\u8F44\u51FD\u542B\u54B8\u5563\u558A\u6ABB\u6DB5\u7DD8\u8266\u929C\u9677\u9E79\u5408\u54C8\u76D2\u86E4\u95A4\u95D4\u965C\u4EA2\u4F09\u59EE\u5AE6\u5DF7\u6052\u6297\u676D\u6841\u6C86\u6E2F\u7F38\u809B\u822A"],
      ["faa1", "\uFA08\uFA09\u9805\u4EA5\u5055\u54B3\u5793\u595A\u5B69\u5BB3\u61C8\u6977\u6D77\u7023\u87F9\u89E3\u8A72\u8AE7\u9082\u99ED\u9AB8\u52BE\u6838\u5016\u5E78\u674F\u8347\u884C\u4EAB\u5411\u56AE\u73E6\u9115\u97FF\u9909\u9957\u9999\u5653\u589F\u865B\u8A31\u61B2\u6AF6\u737B\u8ED2\u6B47\u96AA\u9A57\u5955\u7200\u8D6B\u9769\u4FD4\u5CF4\u5F26\u61F8\u665B\u6CEB\u70AB\u7384\u73B9\u73FE\u7729\u774D\u7D43\u7D62\u7E23\u8237\u8852\uFA0A\u8CE2\u9249\u986F\u5B51\u7A74\u8840\u9801\u5ACC\u4FE0\u5354\u593E\u5CFD\u633E\u6D79\u72F9\u8105\u8107\u83A2\u92CF\u9830\u4EA8\u5144\u5211\u578B"],
      ["fba1", "\u5F62\u6CC2\u6ECE\u7005\u7050\u70AF\u7192\u73E9\u7469\u834A\u87A2\u8861\u9008\u90A2\u93A3\u99A8\u516E\u5F57\u60E0\u6167\u66B3\u8559\u8E4A\u91AF\u978B\u4E4E\u4E92\u547C\u58D5\u58FA\u597D\u5CB5\u5F27\u6236\u6248\u660A\u6667\u6BEB\u6D69\u6DCF\u6E56\u6EF8\u6F94\u6FE0\u6FE9\u705D\u72D0\u7425\u745A\u74E0\u7693\u795C\u7CCA\u7E1E\u80E1\u82A6\u846B\u84BF\u864E\u865F\u8774\u8B77\u8C6A\u93AC\u9800\u9865\u60D1\u6216\u9177\u5A5A\u660F\u6DF7\u6E3E\u743F\u9B42\u5FFD\u60DA\u7B0F\u54C4\u5F18\u6C5E\u6CD3\u6D2A\u70D8\u7D05\u8679\u8A0C\u9D3B\u5316\u548C\u5B05\u6A3A\u706B\u7575"],
      ["fca1", "\u798D\u79BE\u82B1\u83EF\u8A71\u8B41\u8CA8\u9774\uFA0B\u64F4\u652B\u78BA\u78BB\u7A6B\u4E38\u559A\u5950\u5BA6\u5E7B\u60A3\u63DB\u6B61\u6665\u6853\u6E19\u7165\u74B0\u7D08\u9084\u9A69\u9C25\u6D3B\u6ED1\u733E\u8C41\u95CA\u51F0\u5E4C\u5FA8\u604D\u60F6\u6130\u614C\u6643\u6644\u69A5\u6CC1\u6E5F\u6EC9\u6F62\u714C\u749C\u7687\u7BC1\u7C27\u8352\u8757\u9051\u968D\u9EC3\u532F\u56DE\u5EFB\u5F8A\u6062\u6094\u61F7\u6666\u6703\u6A9C\u6DEE\u6FAE\u7070\u736A\u7E6A\u81BE\u8334\u86D4\u8AA8\u8CC4\u5283\u7372\u5B96\u6A6B\u9404\u54EE\u5686\u5B5D\u6548\u6585\u66C9\u689F\u6D8D\u6DC6"],
      ["fda1", "\u723B\u80B4\u9175\u9A4D\u4FAF\u5019\u539A\u540E\u543C\u5589\u55C5\u5E3F\u5F8C\u673D\u7166\u73DD\u9005\u52DB\u52F3\u5864\u58CE\u7104\u718F\u71FB\u85B0\u8A13\u6688\u85A8\u55A7\u6684\u714A\u8431\u5349\u5599\u6BC1\u5F59\u5FBD\u63EE\u6689\u7147\u8AF1\u8F1D\u9EBE\u4F11\u643A\u70CB\u7566\u8667\u6064\u8B4E\u9DF8\u5147\u51F6\u5308\u6D36\u80F8\u9ED1\u6615\u6B23\u7098\u75D5\u5403\u5C79\u7D07\u8A16\u6B20\u6B3D\u6B46\u5438\u6070\u6D3D\u7FD5\u8208\u50D6\u51DE\u559C\u566B\u56CD\u59EC\u5B09\u5E0C\u6199\u6198\u6231\u665E\u66E6\u7199\u71B9\u71BA\u72A7\u79A7\u7A00\u7FB2\u8A70"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS({
  "node_modules/iconv-lite/encodings/tables/cp950.json"(exports2, module2) {
    module2.exports = [
      ["0", "\0", 127],
      ["a140", "\u3000\uFF0C\u3001\u3002\uFF0E\u2027\uFF1B\uFF1A\uFF1F\uFF01\uFE30\u2026\u2025\uFE50\uFE51\uFE52\xB7\uFE54\uFE55\uFE56\uFE57\uFF5C\u2013\uFE31\u2014\uFE33\u2574\uFE34\uFE4F\uFF08\uFF09\uFE35\uFE36\uFF5B\uFF5D\uFE37\uFE38\u3014\u3015\uFE39\uFE3A\u3010\u3011\uFE3B\uFE3C\u300A\u300B\uFE3D\uFE3E\u3008\u3009\uFE3F\uFE40\u300C\u300D\uFE41\uFE42\u300E\u300F\uFE43\uFE44\uFE59\uFE5A"],
      ["a1a1", "\uFE5B\uFE5C\uFE5D\uFE5E\u2018\u2019\u201C\u201D\u301D\u301E\u2035\u2032\uFF03\uFF06\uFF0A\u203B\xA7\u3003\u25CB\u25CF\u25B3\u25B2\u25CE\u2606\u2605\u25C7\u25C6\u25A1\u25A0\u25BD\u25BC\u32A3\u2105\xAF\uFFE3\uFF3F\u02CD\uFE49\uFE4A\uFE4D\uFE4E\uFE4B\uFE4C\uFE5F\uFE60\uFE61\uFF0B\uFF0D\xD7\xF7\xB1\u221A\uFF1C\uFF1E\uFF1D\u2266\u2267\u2260\u221E\u2252\u2261\uFE62", 4, "\uFF5E\u2229\u222A\u22A5\u2220\u221F\u22BF\u33D2\u33D1\u222B\u222E\u2235\u2234\u2640\u2642\u2295\u2299\u2191\u2193\u2190\u2192\u2196\u2197\u2199\u2198\u2225\u2223\uFF0F"],
      ["a240", "\uFF3C\u2215\uFE68\uFF04\uFFE5\u3012\uFFE0\uFFE1\uFF05\uFF20\u2103\u2109\uFE69\uFE6A\uFE6B\u33D5\u339C\u339D\u339E\u33CE\u33A1\u338E\u338F\u33C4\xB0\u5159\u515B\u515E\u515D\u5161\u5163\u55E7\u74E9\u7CCE\u2581", 7, "\u258F\u258E\u258D\u258C\u258B\u258A\u2589\u253C\u2534\u252C\u2524\u251C\u2594\u2500\u2502\u2595\u250C\u2510\u2514\u2518\u256D"],
      ["a2a1", "\u256E\u2570\u256F\u2550\u255E\u256A\u2561\u25E2\u25E3\u25E5\u25E4\u2571\u2572\u2573\uFF10", 9, "\u2160", 9, "\u3021", 8, "\u5341\u5344\u5345\uFF21", 25, "\uFF41", 21],
      ["a340", "\uFF57\uFF58\uFF59\uFF5A\u0391", 16, "\u03A3", 6, "\u03B1", 16, "\u03C3", 6, "\u3105", 10],
      ["a3a1", "\u3110", 25, "\u02D9\u02C9\u02CA\u02C7\u02CB"],
      ["a3e1", "\u20AC"],
      ["a440", "\u4E00\u4E59\u4E01\u4E03\u4E43\u4E5D\u4E86\u4E8C\u4EBA\u513F\u5165\u516B\u51E0\u5200\u5201\u529B\u5315\u5341\u535C\u53C8\u4E09\u4E0B\u4E08\u4E0A\u4E2B\u4E38\u51E1\u4E45\u4E48\u4E5F\u4E5E\u4E8E\u4EA1\u5140\u5203\u52FA\u5343\u53C9\u53E3\u571F\u58EB\u5915\u5927\u5973\u5B50\u5B51\u5B53\u5BF8\u5C0F\u5C22\u5C38\u5C71\u5DDD\u5DE5\u5DF1\u5DF2\u5DF3\u5DFE\u5E72\u5EFE\u5F0B\u5F13\u624D"],
      ["a4a1", "\u4E11\u4E10\u4E0D\u4E2D\u4E30\u4E39\u4E4B\u5C39\u4E88\u4E91\u4E95\u4E92\u4E94\u4EA2\u4EC1\u4EC0\u4EC3\u4EC6\u4EC7\u4ECD\u4ECA\u4ECB\u4EC4\u5143\u5141\u5167\u516D\u516E\u516C\u5197\u51F6\u5206\u5207\u5208\u52FB\u52FE\u52FF\u5316\u5339\u5348\u5347\u5345\u535E\u5384\u53CB\u53CA\u53CD\u58EC\u5929\u592B\u592A\u592D\u5B54\u5C11\u5C24\u5C3A\u5C6F\u5DF4\u5E7B\u5EFF\u5F14\u5F15\u5FC3\u6208\u6236\u624B\u624E\u652F\u6587\u6597\u65A4\u65B9\u65E5\u66F0\u6708\u6728\u6B20\u6B62\u6B79\u6BCB\u6BD4\u6BDB\u6C0F\u6C34\u706B\u722A\u7236\u723B\u7247\u7259\u725B\u72AC\u738B\u4E19"],
      ["a540", "\u4E16\u4E15\u4E14\u4E18\u4E3B\u4E4D\u4E4F\u4E4E\u4EE5\u4ED8\u4ED4\u4ED5\u4ED6\u4ED7\u4EE3\u4EE4\u4ED9\u4EDE\u5145\u5144\u5189\u518A\u51AC\u51F9\u51FA\u51F8\u520A\u52A0\u529F\u5305\u5306\u5317\u531D\u4EDF\u534A\u5349\u5361\u5360\u536F\u536E\u53BB\u53EF\u53E4\u53F3\u53EC\u53EE\u53E9\u53E8\u53FC\u53F8\u53F5\u53EB\u53E6\u53EA\u53F2\u53F1\u53F0\u53E5\u53ED\u53FB\u56DB\u56DA\u5916"],
      ["a5a1", "\u592E\u5931\u5974\u5976\u5B55\u5B83\u5C3C\u5DE8\u5DE7\u5DE6\u5E02\u5E03\u5E73\u5E7C\u5F01\u5F18\u5F17\u5FC5\u620A\u6253\u6254\u6252\u6251\u65A5\u65E6\u672E\u672C\u672A\u672B\u672D\u6B63\u6BCD\u6C11\u6C10\u6C38\u6C41\u6C40\u6C3E\u72AF\u7384\u7389\u74DC\u74E6\u7518\u751F\u7528\u7529\u7530\u7531\u7532\u7533\u758B\u767D\u76AE\u76BF\u76EE\u77DB\u77E2\u77F3\u793A\u79BE\u7A74\u7ACB\u4E1E\u4E1F\u4E52\u4E53\u4E69\u4E99\u4EA4\u4EA6\u4EA5\u4EFF\u4F09\u4F19\u4F0A\u4F15\u4F0D\u4F10\u4F11\u4F0F\u4EF2\u4EF6\u4EFB\u4EF0\u4EF3\u4EFD\u4F01\u4F0B\u5149\u5147\u5146\u5148\u5168"],
      ["a640", "\u5171\u518D\u51B0\u5217\u5211\u5212\u520E\u5216\u52A3\u5308\u5321\u5320\u5370\u5371\u5409\u540F\u540C\u540A\u5410\u5401\u540B\u5404\u5411\u540D\u5408\u5403\u540E\u5406\u5412\u56E0\u56DE\u56DD\u5733\u5730\u5728\u572D\u572C\u572F\u5729\u5919\u591A\u5937\u5938\u5984\u5978\u5983\u597D\u5979\u5982\u5981\u5B57\u5B58\u5B87\u5B88\u5B85\u5B89\u5BFA\u5C16\u5C79\u5DDE\u5E06\u5E76\u5E74"],
      ["a6a1", "\u5F0F\u5F1B\u5FD9\u5FD6\u620E\u620C\u620D\u6210\u6263\u625B\u6258\u6536\u65E9\u65E8\u65EC\u65ED\u66F2\u66F3\u6709\u673D\u6734\u6731\u6735\u6B21\u6B64\u6B7B\u6C16\u6C5D\u6C57\u6C59\u6C5F\u6C60\u6C50\u6C55\u6C61\u6C5B\u6C4D\u6C4E\u7070\u725F\u725D\u767E\u7AF9\u7C73\u7CF8\u7F36\u7F8A\u7FBD\u8001\u8003\u800C\u8012\u8033\u807F\u8089\u808B\u808C\u81E3\u81EA\u81F3\u81FC\u820C\u821B\u821F\u826E\u8272\u827E\u866B\u8840\u884C\u8863\u897F\u9621\u4E32\u4EA8\u4F4D\u4F4F\u4F47\u4F57\u4F5E\u4F34\u4F5B\u4F55\u4F30\u4F50\u4F51\u4F3D\u4F3A\u4F38\u4F43\u4F54\u4F3C\u4F46\u4F63"],
      ["a740", "\u4F5C\u4F60\u4F2F\u4F4E\u4F36\u4F59\u4F5D\u4F48\u4F5A\u514C\u514B\u514D\u5175\u51B6\u51B7\u5225\u5224\u5229\u522A\u5228\u52AB\u52A9\u52AA\u52AC\u5323\u5373\u5375\u541D\u542D\u541E\u543E\u5426\u544E\u5427\u5446\u5443\u5433\u5448\u5442\u541B\u5429\u544A\u5439\u543B\u5438\u542E\u5435\u5436\u5420\u543C\u5440\u5431\u542B\u541F\u542C\u56EA\u56F0\u56E4\u56EB\u574A\u5751\u5740\u574D"],
      ["a7a1", "\u5747\u574E\u573E\u5750\u574F\u573B\u58EF\u593E\u599D\u5992\u59A8\u599E\u59A3\u5999\u5996\u598D\u59A4\u5993\u598A\u59A5\u5B5D\u5B5C\u5B5A\u5B5B\u5B8C\u5B8B\u5B8F\u5C2C\u5C40\u5C41\u5C3F\u5C3E\u5C90\u5C91\u5C94\u5C8C\u5DEB\u5E0C\u5E8F\u5E87\u5E8A\u5EF7\u5F04\u5F1F\u5F64\u5F62\u5F77\u5F79\u5FD8\u5FCC\u5FD7\u5FCD\u5FF1\u5FEB\u5FF8\u5FEA\u6212\u6211\u6284\u6297\u6296\u6280\u6276\u6289\u626D\u628A\u627C\u627E\u6279\u6273\u6292\u626F\u6298\u626E\u6295\u6293\u6291\u6286\u6539\u653B\u6538\u65F1\u66F4\u675F\u674E\u674F\u6750\u6751\u675C\u6756\u675E\u6749\u6746\u6760"],
      ["a840", "\u6753\u6757\u6B65\u6BCF\u6C42\u6C5E\u6C99\u6C81\u6C88\u6C89\u6C85\u6C9B\u6C6A\u6C7A\u6C90\u6C70\u6C8C\u6C68\u6C96\u6C92\u6C7D\u6C83\u6C72\u6C7E\u6C74\u6C86\u6C76\u6C8D\u6C94\u6C98\u6C82\u7076\u707C\u707D\u7078\u7262\u7261\u7260\u72C4\u72C2\u7396\u752C\u752B\u7537\u7538\u7682\u76EF\u77E3\u79C1\u79C0\u79BF\u7A76\u7CFB\u7F55\u8096\u8093\u809D\u8098\u809B\u809A\u80B2\u826F\u8292"],
      ["a8a1", "\u828B\u828D\u898B\u89D2\u8A00\u8C37\u8C46\u8C55\u8C9D\u8D64\u8D70\u8DB3\u8EAB\u8ECA\u8F9B\u8FB0\u8FC2\u8FC6\u8FC5\u8FC4\u5DE1\u9091\u90A2\u90AA\u90A6\u90A3\u9149\u91C6\u91CC\u9632\u962E\u9631\u962A\u962C\u4E26\u4E56\u4E73\u4E8B\u4E9B\u4E9E\u4EAB\u4EAC\u4F6F\u4F9D\u4F8D\u4F73\u4F7F\u4F6C\u4F9B\u4F8B\u4F86\u4F83\u4F70\u4F75\u4F88\u4F69\u4F7B\u4F96\u4F7E\u4F8F\u4F91\u4F7A\u5154\u5152\u5155\u5169\u5177\u5176\u5178\u51BD\u51FD\u523B\u5238\u5237\u523A\u5230\u522E\u5236\u5241\u52BE\u52BB\u5352\u5354\u5353\u5351\u5366\u5377\u5378\u5379\u53D6\u53D4\u53D7\u5473\u5475"],
      ["a940", "\u5496\u5478\u5495\u5480\u547B\u5477\u5484\u5492\u5486\u547C\u5490\u5471\u5476\u548C\u549A\u5462\u5468\u548B\u547D\u548E\u56FA\u5783\u5777\u576A\u5769\u5761\u5766\u5764\u577C\u591C\u5949\u5947\u5948\u5944\u5954\u59BE\u59BB\u59D4\u59B9\u59AE\u59D1\u59C6\u59D0\u59CD\u59CB\u59D3\u59CA\u59AF\u59B3\u59D2\u59C5\u5B5F\u5B64\u5B63\u5B97\u5B9A\u5B98\u5B9C\u5B99\u5B9B\u5C1A\u5C48\u5C45"],
      ["a9a1", "\u5C46\u5CB7\u5CA1\u5CB8\u5CA9\u5CAB\u5CB1\u5CB3\u5E18\u5E1A\u5E16\u5E15\u5E1B\u5E11\u5E78\u5E9A\u5E97\u5E9C\u5E95\u5E96\u5EF6\u5F26\u5F27\u5F29\u5F80\u5F81\u5F7F\u5F7C\u5FDD\u5FE0\u5FFD\u5FF5\u5FFF\u600F\u6014\u602F\u6035\u6016\u602A\u6015\u6021\u6027\u6029\u602B\u601B\u6216\u6215\u623F\u623E\u6240\u627F\u62C9\u62CC\u62C4\u62BF\u62C2\u62B9\u62D2\u62DB\u62AB\u62D3\u62D4\u62CB\u62C8\u62A8\u62BD\u62BC\u62D0\u62D9\u62C7\u62CD\u62B5\u62DA\u62B1\u62D8\u62D6\u62D7\u62C6\u62AC\u62CE\u653E\u65A7\u65BC\u65FA\u6614\u6613\u660C\u6606\u6602\u660E\u6600\u660F\u6615\u660A"],
      ["aa40", "\u6607\u670D\u670B\u676D\u678B\u6795\u6771\u679C\u6773\u6777\u6787\u679D\u6797\u676F\u6770\u677F\u6789\u677E\u6790\u6775\u679A\u6793\u677C\u676A\u6772\u6B23\u6B66\u6B67\u6B7F\u6C13\u6C1B\u6CE3\u6CE8\u6CF3\u6CB1\u6CCC\u6CE5\u6CB3\u6CBD\u6CBE\u6CBC\u6CE2\u6CAB\u6CD5\u6CD3\u6CB8\u6CC4\u6CB9\u6CC1\u6CAE\u6CD7\u6CC5\u6CF1\u6CBF\u6CBB\u6CE1\u6CDB\u6CCA\u6CAC\u6CEF\u6CDC\u6CD6\u6CE0"],
      ["aaa1", "\u7095\u708E\u7092\u708A\u7099\u722C\u722D\u7238\u7248\u7267\u7269\u72C0\u72CE\u72D9\u72D7\u72D0\u73A9\u73A8\u739F\u73AB\u73A5\u753D\u759D\u7599\u759A\u7684\u76C2\u76F2\u76F4\u77E5\u77FD\u793E\u7940\u7941\u79C9\u79C8\u7A7A\u7A79\u7AFA\u7CFE\u7F54\u7F8C\u7F8B\u8005\u80BA\u80A5\u80A2\u80B1\u80A1\u80AB\u80A9\u80B4\u80AA\u80AF\u81E5\u81FE\u820D\u82B3\u829D\u8299\u82AD\u82BD\u829F\u82B9\u82B1\u82AC\u82A5\u82AF\u82B8\u82A3\u82B0\u82BE\u82B7\u864E\u8671\u521D\u8868\u8ECB\u8FCE\u8FD4\u8FD1\u90B5\u90B8\u90B1\u90B6\u91C7\u91D1\u9577\u9580\u961C\u9640\u963F\u963B\u9644"],
      ["ab40", "\u9642\u96B9\u96E8\u9752\u975E\u4E9F\u4EAD\u4EAE\u4FE1\u4FB5\u4FAF\u4FBF\u4FE0\u4FD1\u4FCF\u4FDD\u4FC3\u4FB6\u4FD8\u4FDF\u4FCA\u4FD7\u4FAE\u4FD0\u4FC4\u4FC2\u4FDA\u4FCE\u4FDE\u4FB7\u5157\u5192\u5191\u51A0\u524E\u5243\u524A\u524D\u524C\u524B\u5247\u52C7\u52C9\u52C3\u52C1\u530D\u5357\u537B\u539A\u53DB\u54AC\u54C0\u54A8\u54CE\u54C9\u54B8\u54A6\u54B3\u54C7\u54C2\u54BD\u54AA\u54C1"],
      ["aba1", "\u54C4\u54C8\u54AF\u54AB\u54B1\u54BB\u54A9\u54A7\u54BF\u56FF\u5782\u578B\u57A0\u57A3\u57A2\u57CE\u57AE\u5793\u5955\u5951\u594F\u594E\u5950\u59DC\u59D8\u59FF\u59E3\u59E8\u5A03\u59E5\u59EA\u59DA\u59E6\u5A01\u59FB\u5B69\u5BA3\u5BA6\u5BA4\u5BA2\u5BA5\u5C01\u5C4E\u5C4F\u5C4D\u5C4B\u5CD9\u5CD2\u5DF7\u5E1D\u5E25\u5E1F\u5E7D\u5EA0\u5EA6\u5EFA\u5F08\u5F2D\u5F65\u5F88\u5F85\u5F8A\u5F8B\u5F87\u5F8C\u5F89\u6012\u601D\u6020\u6025\u600E\u6028\u604D\u6070\u6068\u6062\u6046\u6043\u606C\u606B\u606A\u6064\u6241\u62DC\u6316\u6309\u62FC\u62ED\u6301\u62EE\u62FD\u6307\u62F1\u62F7"],
      ["ac40", "\u62EF\u62EC\u62FE\u62F4\u6311\u6302\u653F\u6545\u65AB\u65BD\u65E2\u6625\u662D\u6620\u6627\u662F\u661F\u6628\u6631\u6624\u66F7\u67FF\u67D3\u67F1\u67D4\u67D0\u67EC\u67B6\u67AF\u67F5\u67E9\u67EF\u67C4\u67D1\u67B4\u67DA\u67E5\u67B8\u67CF\u67DE\u67F3\u67B0\u67D9\u67E2\u67DD\u67D2\u6B6A\u6B83\u6B86\u6BB5\u6BD2\u6BD7\u6C1F\u6CC9\u6D0B\u6D32\u6D2A\u6D41\u6D25\u6D0C\u6D31\u6D1E\u6D17"],
      ["aca1", "\u6D3B\u6D3D\u6D3E\u6D36\u6D1B\u6CF5\u6D39\u6D27\u6D38\u6D29\u6D2E\u6D35\u6D0E\u6D2B\u70AB\u70BA\u70B3\u70AC\u70AF\u70AD\u70B8\u70AE\u70A4\u7230\u7272\u726F\u7274\u72E9\u72E0\u72E1\u73B7\u73CA\u73BB\u73B2\u73CD\u73C0\u73B3\u751A\u752D\u754F\u754C\u754E\u754B\u75AB\u75A4\u75A5\u75A2\u75A3\u7678\u7686\u7687\u7688\u76C8\u76C6\u76C3\u76C5\u7701\u76F9\u76F8\u7709\u770B\u76FE\u76FC\u7707\u77DC\u7802\u7814\u780C\u780D\u7946\u7949\u7948\u7947\u79B9\u79BA\u79D1\u79D2\u79CB\u7A7F\u7A81\u7AFF\u7AFD\u7C7D\u7D02\u7D05\u7D00\u7D09\u7D07\u7D04\u7D06\u7F38\u7F8E\u7FBF\u8004"],
      ["ad40", "\u8010\u800D\u8011\u8036\u80D6\u80E5\u80DA\u80C3\u80C4\u80CC\u80E1\u80DB\u80CE\u80DE\u80E4\u80DD\u81F4\u8222\u82E7\u8303\u8305\u82E3\u82DB\u82E6\u8304\u82E5\u8302\u8309\u82D2\u82D7\u82F1\u8301\u82DC\u82D4\u82D1\u82DE\u82D3\u82DF\u82EF\u8306\u8650\u8679\u867B\u867A\u884D\u886B\u8981\u89D4\u8A08\u8A02\u8A03\u8C9E\u8CA0\u8D74\u8D73\u8DB4\u8ECD\u8ECC\u8FF0\u8FE6\u8FE2\u8FEA\u8FE5"],
      ["ada1", "\u8FED\u8FEB\u8FE4\u8FE8\u90CA\u90CE\u90C1\u90C3\u914B\u914A\u91CD\u9582\u9650\u964B\u964C\u964D\u9762\u9769\u97CB\u97ED\u97F3\u9801\u98A8\u98DB\u98DF\u9996\u9999\u4E58\u4EB3\u500C\u500D\u5023\u4FEF\u5026\u5025\u4FF8\u5029\u5016\u5006\u503C\u501F\u501A\u5012\u5011\u4FFA\u5000\u5014\u5028\u4FF1\u5021\u500B\u5019\u5018\u4FF3\u4FEE\u502D\u502A\u4FFE\u502B\u5009\u517C\u51A4\u51A5\u51A2\u51CD\u51CC\u51C6\u51CB\u5256\u525C\u5254\u525B\u525D\u532A\u537F\u539F\u539D\u53DF\u54E8\u5510\u5501\u5537\u54FC\u54E5\u54F2\u5506\u54FA\u5514\u54E9\u54ED\u54E1\u5509\u54EE\u54EA"],
      ["ae40", "\u54E6\u5527\u5507\u54FD\u550F\u5703\u5704\u57C2\u57D4\u57CB\u57C3\u5809\u590F\u5957\u5958\u595A\u5A11\u5A18\u5A1C\u5A1F\u5A1B\u5A13\u59EC\u5A20\u5A23\u5A29\u5A25\u5A0C\u5A09\u5B6B\u5C58\u5BB0\u5BB3\u5BB6\u5BB4\u5BAE\u5BB5\u5BB9\u5BB8\u5C04\u5C51\u5C55\u5C50\u5CED\u5CFD\u5CFB\u5CEA\u5CE8\u5CF0\u5CF6\u5D01\u5CF4\u5DEE\u5E2D\u5E2B\u5EAB\u5EAD\u5EA7\u5F31\u5F92\u5F91\u5F90\u6059"],
      ["aea1", "\u6063\u6065\u6050\u6055\u606D\u6069\u606F\u6084\u609F\u609A\u608D\u6094\u608C\u6085\u6096\u6247\u62F3\u6308\u62FF\u634E\u633E\u632F\u6355\u6342\u6346\u634F\u6349\u633A\u6350\u633D\u632A\u632B\u6328\u634D\u634C\u6548\u6549\u6599\u65C1\u65C5\u6642\u6649\u664F\u6643\u6652\u664C\u6645\u6641\u66F8\u6714\u6715\u6717\u6821\u6838\u6848\u6846\u6853\u6839\u6842\u6854\u6829\u68B3\u6817\u684C\u6851\u683D\u67F4\u6850\u6840\u683C\u6843\u682A\u6845\u6813\u6818\u6841\u6B8A\u6B89\u6BB7\u6C23\u6C27\u6C28\u6C26\u6C24\u6CF0\u6D6A\u6D95\u6D88\u6D87\u6D66\u6D78\u6D77\u6D59\u6D93"],
      ["af40", "\u6D6C\u6D89\u6D6E\u6D5A\u6D74\u6D69\u6D8C\u6D8A\u6D79\u6D85\u6D65\u6D94\u70CA\u70D8\u70E4\u70D9\u70C8\u70CF\u7239\u7279\u72FC\u72F9\u72FD\u72F8\u72F7\u7386\u73ED\u7409\u73EE\u73E0\u73EA\u73DE\u7554\u755D\u755C\u755A\u7559\u75BE\u75C5\u75C7\u75B2\u75B3\u75BD\u75BC\u75B9\u75C2\u75B8\u768B\u76B0\u76CA\u76CD\u76CE\u7729\u771F\u7720\u7728\u77E9\u7830\u7827\u7838\u781D\u7834\u7837"],
      ["afa1", "\u7825\u782D\u7820\u781F\u7832\u7955\u7950\u7960\u795F\u7956\u795E\u795D\u7957\u795A\u79E4\u79E3\u79E7\u79DF\u79E6\u79E9\u79D8\u7A84\u7A88\u7AD9\u7B06\u7B11\u7C89\u7D21\u7D17\u7D0B\u7D0A\u7D20\u7D22\u7D14\u7D10\u7D15\u7D1A\u7D1C\u7D0D\u7D19\u7D1B\u7F3A\u7F5F\u7F94\u7FC5\u7FC1\u8006\u8018\u8015\u8019\u8017\u803D\u803F\u80F1\u8102\u80F0\u8105\u80ED\u80F4\u8106\u80F8\u80F3\u8108\u80FD\u810A\u80FC\u80EF\u81ED\u81EC\u8200\u8210\u822A\u822B\u8228\u822C\u82BB\u832B\u8352\u8354\u834A\u8338\u8350\u8349\u8335\u8334\u834F\u8332\u8339\u8336\u8317\u8340\u8331\u8328\u8343"],
      ["b040", "\u8654\u868A\u86AA\u8693\u86A4\u86A9\u868C\u86A3\u869C\u8870\u8877\u8881\u8882\u887D\u8879\u8A18\u8A10\u8A0E\u8A0C\u8A15\u8A0A\u8A17\u8A13\u8A16\u8A0F\u8A11\u8C48\u8C7A\u8C79\u8CA1\u8CA2\u8D77\u8EAC\u8ED2\u8ED4\u8ECF\u8FB1\u9001\u9006\u8FF7\u9000\u8FFA\u8FF4\u9003\u8FFD\u9005\u8FF8\u9095\u90E1\u90DD\u90E2\u9152\u914D\u914C\u91D8\u91DD\u91D7\u91DC\u91D9\u9583\u9662\u9663\u9661"],
      ["b0a1", "\u965B\u965D\u9664\u9658\u965E\u96BB\u98E2\u99AC\u9AA8\u9AD8\u9B25\u9B32\u9B3C\u4E7E\u507A\u507D\u505C\u5047\u5043\u504C\u505A\u5049\u5065\u5076\u504E\u5055\u5075\u5074\u5077\u504F\u500F\u506F\u506D\u515C\u5195\u51F0\u526A\u526F\u52D2\u52D9\u52D8\u52D5\u5310\u530F\u5319\u533F\u5340\u533E\u53C3\u66FC\u5546\u556A\u5566\u5544\u555E\u5561\u5543\u554A\u5531\u5556\u554F\u5555\u552F\u5564\u5538\u552E\u555C\u552C\u5563\u5533\u5541\u5557\u5708\u570B\u5709\u57DF\u5805\u580A\u5806\u57E0\u57E4\u57FA\u5802\u5835\u57F7\u57F9\u5920\u5962\u5A36\u5A41\u5A49\u5A66\u5A6A\u5A40"],
      ["b140", "\u5A3C\u5A62\u5A5A\u5A46\u5A4A\u5B70\u5BC7\u5BC5\u5BC4\u5BC2\u5BBF\u5BC6\u5C09\u5C08\u5C07\u5C60\u5C5C\u5C5D\u5D07\u5D06\u5D0E\u5D1B\u5D16\u5D22\u5D11\u5D29\u5D14\u5D19\u5D24\u5D27\u5D17\u5DE2\u5E38\u5E36\u5E33\u5E37\u5EB7\u5EB8\u5EB6\u5EB5\u5EBE\u5F35\u5F37\u5F57\u5F6C\u5F69\u5F6B\u5F97\u5F99\u5F9E\u5F98\u5FA1\u5FA0\u5F9C\u607F\u60A3\u6089\u60A0\u60A8\u60CB\u60B4\u60E6\u60BD"],
      ["b1a1", "\u60C5\u60BB\u60B5\u60DC\u60BC\u60D8\u60D5\u60C6\u60DF\u60B8\u60DA\u60C7\u621A\u621B\u6248\u63A0\u63A7\u6372\u6396\u63A2\u63A5\u6377\u6367\u6398\u63AA\u6371\u63A9\u6389\u6383\u639B\u636B\u63A8\u6384\u6388\u6399\u63A1\u63AC\u6392\u638F\u6380\u637B\u6369\u6368\u637A\u655D\u6556\u6551\u6559\u6557\u555F\u654F\u6558\u6555\u6554\u659C\u659B\u65AC\u65CF\u65CB\u65CC\u65CE\u665D\u665A\u6664\u6668\u6666\u665E\u66F9\u52D7\u671B\u6881\u68AF\u68A2\u6893\u68B5\u687F\u6876\u68B1\u68A7\u6897\u68B0\u6883\u68C4\u68AD\u6886\u6885\u6894\u689D\u68A8\u689F\u68A1\u6882\u6B32\u6BBA"],
      ["b240", "\u6BEB\u6BEC\u6C2B\u6D8E\u6DBC\u6DF3\u6DD9\u6DB2\u6DE1\u6DCC\u6DE4\u6DFB\u6DFA\u6E05\u6DC7\u6DCB\u6DAF\u6DD1\u6DAE\u6DDE\u6DF9\u6DB8\u6DF7\u6DF5\u6DC5\u6DD2\u6E1A\u6DB5\u6DDA\u6DEB\u6DD8\u6DEA\u6DF1\u6DEE\u6DE8\u6DC6\u6DC4\u6DAA\u6DEC\u6DBF\u6DE6\u70F9\u7109\u710A\u70FD\u70EF\u723D\u727D\u7281\u731C\u731B\u7316\u7313\u7319\u7387\u7405\u740A\u7403\u7406\u73FE\u740D\u74E0\u74F6"],
      ["b2a1", "\u74F7\u751C\u7522\u7565\u7566\u7562\u7570\u758F\u75D4\u75D5\u75B5\u75CA\u75CD\u768E\u76D4\u76D2\u76DB\u7737\u773E\u773C\u7736\u7738\u773A\u786B\u7843\u784E\u7965\u7968\u796D\u79FB\u7A92\u7A95\u7B20\u7B28\u7B1B\u7B2C\u7B26\u7B19\u7B1E\u7B2E\u7C92\u7C97\u7C95\u7D46\u7D43\u7D71\u7D2E\u7D39\u7D3C\u7D40\u7D30\u7D33\u7D44\u7D2F\u7D42\u7D32\u7D31\u7F3D\u7F9E\u7F9A\u7FCC\u7FCE\u7FD2\u801C\u804A\u8046\u812F\u8116\u8123\u812B\u8129\u8130\u8124\u8202\u8235\u8237\u8236\u8239\u838E\u839E\u8398\u8378\u83A2\u8396\u83BD\u83AB\u8392\u838A\u8393\u8389\u83A0\u8377\u837B\u837C"],
      ["b340", "\u8386\u83A7\u8655\u5F6A\u86C7\u86C0\u86B6\u86C4\u86B5\u86C6\u86CB\u86B1\u86AF\u86C9\u8853\u889E\u8888\u88AB\u8892\u8896\u888D\u888B\u8993\u898F\u8A2A\u8A1D\u8A23\u8A25\u8A31\u8A2D\u8A1F\u8A1B\u8A22\u8C49\u8C5A\u8CA9\u8CAC\u8CAB\u8CA8\u8CAA\u8CA7\u8D67\u8D66\u8DBE\u8DBA\u8EDB\u8EDF\u9019\u900D\u901A\u9017\u9023\u901F\u901D\u9010\u9015\u901E\u9020\u900F\u9022\u9016\u901B\u9014"],
      ["b3a1", "\u90E8\u90ED\u90FD\u9157\u91CE\u91F5\u91E6\u91E3\u91E7\u91ED\u91E9\u9589\u966A\u9675\u9673\u9678\u9670\u9674\u9676\u9677\u966C\u96C0\u96EA\u96E9\u7AE0\u7ADF\u9802\u9803\u9B5A\u9CE5\u9E75\u9E7F\u9EA5\u9EBB\u50A2\u508D\u5085\u5099\u5091\u5080\u5096\u5098\u509A\u6700\u51F1\u5272\u5274\u5275\u5269\u52DE\u52DD\u52DB\u535A\u53A5\u557B\u5580\u55A7\u557C\u558A\u559D\u5598\u5582\u559C\u55AA\u5594\u5587\u558B\u5583\u55B3\u55AE\u559F\u553E\u55B2\u559A\u55BB\u55AC\u55B1\u557E\u5589\u55AB\u5599\u570D\u582F\u582A\u5834\u5824\u5830\u5831\u5821\u581D\u5820\u58F9\u58FA\u5960"],
      ["b440", "\u5A77\u5A9A\u5A7F\u5A92\u5A9B\u5AA7\u5B73\u5B71\u5BD2\u5BCC\u5BD3\u5BD0\u5C0A\u5C0B\u5C31\u5D4C\u5D50\u5D34\u5D47\u5DFD\u5E45\u5E3D\u5E40\u5E43\u5E7E\u5ECA\u5EC1\u5EC2\u5EC4\u5F3C\u5F6D\u5FA9\u5FAA\u5FA8\u60D1\u60E1\u60B2\u60B6\u60E0\u611C\u6123\u60FA\u6115\u60F0\u60FB\u60F4\u6168\u60F1\u610E\u60F6\u6109\u6100\u6112\u621F\u6249\u63A3\u638C\u63CF\u63C0\u63E9\u63C9\u63C6\u63CD"],
      ["b4a1", "\u63D2\u63E3\u63D0\u63E1\u63D6\u63ED\u63EE\u6376\u63F4\u63EA\u63DB\u6452\u63DA\u63F9\u655E\u6566\u6562\u6563\u6591\u6590\u65AF\u666E\u6670\u6674\u6676\u666F\u6691\u667A\u667E\u6677\u66FE\u66FF\u671F\u671D\u68FA\u68D5\u68E0\u68D8\u68D7\u6905\u68DF\u68F5\u68EE\u68E7\u68F9\u68D2\u68F2\u68E3\u68CB\u68CD\u690D\u6912\u690E\u68C9\u68DA\u696E\u68FB\u6B3E\u6B3A\u6B3D\u6B98\u6B96\u6BBC\u6BEF\u6C2E\u6C2F\u6C2C\u6E2F\u6E38\u6E54\u6E21\u6E32\u6E67\u6E4A\u6E20\u6E25\u6E23\u6E1B\u6E5B\u6E58\u6E24\u6E56\u6E6E\u6E2D\u6E26\u6E6F\u6E34\u6E4D\u6E3A\u6E2C\u6E43\u6E1D\u6E3E\u6ECB"],
      ["b540", "\u6E89\u6E19\u6E4E\u6E63\u6E44\u6E72\u6E69\u6E5F\u7119\u711A\u7126\u7130\u7121\u7136\u716E\u711C\u724C\u7284\u7280\u7336\u7325\u7334\u7329\u743A\u742A\u7433\u7422\u7425\u7435\u7436\u7434\u742F\u741B\u7426\u7428\u7525\u7526\u756B\u756A\u75E2\u75DB\u75E3\u75D9\u75D8\u75DE\u75E0\u767B\u767C\u7696\u7693\u76B4\u76DC\u774F\u77ED\u785D\u786C\u786F\u7A0D\u7A08\u7A0B\u7A05\u7A00\u7A98"],
      ["b5a1", "\u7A97\u7A96\u7AE5\u7AE3\u7B49\u7B56\u7B46\u7B50\u7B52\u7B54\u7B4D\u7B4B\u7B4F\u7B51\u7C9F\u7CA5\u7D5E\u7D50\u7D68\u7D55\u7D2B\u7D6E\u7D72\u7D61\u7D66\u7D62\u7D70\u7D73\u5584\u7FD4\u7FD5\u800B\u8052\u8085\u8155\u8154\u814B\u8151\u814E\u8139\u8146\u813E\u814C\u8153\u8174\u8212\u821C\u83E9\u8403\u83F8\u840D\u83E0\u83C5\u840B\u83C1\u83EF\u83F1\u83F4\u8457\u840A\u83F0\u840C\u83CC\u83FD\u83F2\u83CA\u8438\u840E\u8404\u83DC\u8407\u83D4\u83DF\u865B\u86DF\u86D9\u86ED\u86D4\u86DB\u86E4\u86D0\u86DE\u8857\u88C1\u88C2\u88B1\u8983\u8996\u8A3B\u8A60\u8A55\u8A5E\u8A3C\u8A41"],
      ["b640", "\u8A54\u8A5B\u8A50\u8A46\u8A34\u8A3A\u8A36\u8A56\u8C61\u8C82\u8CAF\u8CBC\u8CB3\u8CBD\u8CC1\u8CBB\u8CC0\u8CB4\u8CB7\u8CB6\u8CBF\u8CB8\u8D8A\u8D85\u8D81\u8DCE\u8DDD\u8DCB\u8DDA\u8DD1\u8DCC\u8DDB\u8DC6\u8EFB\u8EF8\u8EFC\u8F9C\u902E\u9035\u9031\u9038\u9032\u9036\u9102\u90F5\u9109\u90FE\u9163\u9165\u91CF\u9214\u9215\u9223\u9209\u921E\u920D\u9210\u9207\u9211\u9594\u958F\u958B\u9591"],
      ["b6a1", "\u9593\u9592\u958E\u968A\u968E\u968B\u967D\u9685\u9686\u968D\u9672\u9684\u96C1\u96C5\u96C4\u96C6\u96C7\u96EF\u96F2\u97CC\u9805\u9806\u9808\u98E7\u98EA\u98EF\u98E9\u98F2\u98ED\u99AE\u99AD\u9EC3\u9ECD\u9ED1\u4E82\u50AD\u50B5\u50B2\u50B3\u50C5\u50BE\u50AC\u50B7\u50BB\u50AF\u50C7\u527F\u5277\u527D\u52DF\u52E6\u52E4\u52E2\u52E3\u532F\u55DF\u55E8\u55D3\u55E6\u55CE\u55DC\u55C7\u55D1\u55E3\u55E4\u55EF\u55DA\u55E1\u55C5\u55C6\u55E5\u55C9\u5712\u5713\u585E\u5851\u5858\u5857\u585A\u5854\u586B\u584C\u586D\u584A\u5862\u5852\u584B\u5967\u5AC1\u5AC9\u5ACC\u5ABE\u5ABD\u5ABC"],
      ["b740", "\u5AB3\u5AC2\u5AB2\u5D69\u5D6F\u5E4C\u5E79\u5EC9\u5EC8\u5F12\u5F59\u5FAC\u5FAE\u611A\u610F\u6148\u611F\u60F3\u611B\u60F9\u6101\u6108\u614E\u614C\u6144\u614D\u613E\u6134\u6127\u610D\u6106\u6137\u6221\u6222\u6413\u643E\u641E\u642A\u642D\u643D\u642C\u640F\u641C\u6414\u640D\u6436\u6416\u6417\u6406\u656C\u659F\u65B0\u6697\u6689\u6687\u6688\u6696\u6684\u6698\u668D\u6703\u6994\u696D"],
      ["b7a1", "\u695A\u6977\u6960\u6954\u6975\u6930\u6982\u694A\u6968\u696B\u695E\u6953\u6979\u6986\u695D\u6963\u695B\u6B47\u6B72\u6BC0\u6BBF\u6BD3\u6BFD\u6EA2\u6EAF\u6ED3\u6EB6\u6EC2\u6E90\u6E9D\u6EC7\u6EC5\u6EA5\u6E98\u6EBC\u6EBA\u6EAB\u6ED1\u6E96\u6E9C\u6EC4\u6ED4\u6EAA\u6EA7\u6EB4\u714E\u7159\u7169\u7164\u7149\u7167\u715C\u716C\u7166\u714C\u7165\u715E\u7146\u7168\u7156\u723A\u7252\u7337\u7345\u733F\u733E\u746F\u745A\u7455\u745F\u745E\u7441\u743F\u7459\u745B\u745C\u7576\u7578\u7600\u75F0\u7601\u75F2\u75F1\u75FA\u75FF\u75F4\u75F3\u76DE\u76DF\u775B\u776B\u7766\u775E\u7763"],
      ["b840", "\u7779\u776A\u776C\u775C\u7765\u7768\u7762\u77EE\u788E\u78B0\u7897\u7898\u788C\u7889\u787C\u7891\u7893\u787F\u797A\u797F\u7981\u842C\u79BD\u7A1C\u7A1A\u7A20\u7A14\u7A1F\u7A1E\u7A9F\u7AA0\u7B77\u7BC0\u7B60\u7B6E\u7B67\u7CB1\u7CB3\u7CB5\u7D93\u7D79\u7D91\u7D81\u7D8F\u7D5B\u7F6E\u7F69\u7F6A\u7F72\u7FA9\u7FA8\u7FA4\u8056\u8058\u8086\u8084\u8171\u8170\u8178\u8165\u816E\u8173\u816B"],
      ["b8a1", "\u8179\u817A\u8166\u8205\u8247\u8482\u8477\u843D\u8431\u8475\u8466\u846B\u8449\u846C\u845B\u843C\u8435\u8461\u8463\u8469\u846D\u8446\u865E\u865C\u865F\u86F9\u8713\u8708\u8707\u8700\u86FE\u86FB\u8702\u8703\u8706\u870A\u8859\u88DF\u88D4\u88D9\u88DC\u88D8\u88DD\u88E1\u88CA\u88D5\u88D2\u899C\u89E3\u8A6B\u8A72\u8A73\u8A66\u8A69\u8A70\u8A87\u8A7C\u8A63\u8AA0\u8A71\u8A85\u8A6D\u8A62\u8A6E\u8A6C\u8A79\u8A7B\u8A3E\u8A68\u8C62\u8C8A\u8C89\u8CCA\u8CC7\u8CC8\u8CC4\u8CB2\u8CC3\u8CC2\u8CC5\u8DE1\u8DDF\u8DE8\u8DEF\u8DF3\u8DFA\u8DEA\u8DE4\u8DE6\u8EB2\u8F03\u8F09\u8EFE\u8F0A"],
      ["b940", "\u8F9F\u8FB2\u904B\u904A\u9053\u9042\u9054\u903C\u9055\u9050\u9047\u904F\u904E\u904D\u9051\u903E\u9041\u9112\u9117\u916C\u916A\u9169\u91C9\u9237\u9257\u9238\u923D\u9240\u923E\u925B\u924B\u9264\u9251\u9234\u9249\u924D\u9245\u9239\u923F\u925A\u9598\u9698\u9694\u9695\u96CD\u96CB\u96C9\u96CA\u96F7\u96FB\u96F9\u96F6\u9756\u9774\u9776\u9810\u9811\u9813\u980A\u9812\u980C\u98FC\u98F4"],
      ["b9a1", "\u98FD\u98FE\u99B3\u99B1\u99B4\u9AE1\u9CE9\u9E82\u9F0E\u9F13\u9F20\u50E7\u50EE\u50E5\u50D6\u50ED\u50DA\u50D5\u50CF\u50D1\u50F1\u50CE\u50E9\u5162\u51F3\u5283\u5282\u5331\u53AD\u55FE\u5600\u561B\u5617\u55FD\u5614\u5606\u5609\u560D\u560E\u55F7\u5616\u561F\u5608\u5610\u55F6\u5718\u5716\u5875\u587E\u5883\u5893\u588A\u5879\u5885\u587D\u58FD\u5925\u5922\u5924\u596A\u5969\u5AE1\u5AE6\u5AE9\u5AD7\u5AD6\u5AD8\u5AE3\u5B75\u5BDE\u5BE7\u5BE1\u5BE5\u5BE6\u5BE8\u5BE2\u5BE4\u5BDF\u5C0D\u5C62\u5D84\u5D87\u5E5B\u5E63\u5E55\u5E57\u5E54\u5ED3\u5ED6\u5F0A\u5F46\u5F70\u5FB9\u6147"],
      ["ba40", "\u613F\u614B\u6177\u6162\u6163\u615F\u615A\u6158\u6175\u622A\u6487\u6458\u6454\u64A4\u6478\u645F\u647A\u6451\u6467\u6434\u646D\u647B\u6572\u65A1\u65D7\u65D6\u66A2\u66A8\u669D\u699C\u69A8\u6995\u69C1\u69AE\u69D3\u69CB\u699B\u69B7\u69BB\u69AB\u69B4\u69D0\u69CD\u69AD\u69CC\u69A6\u69C3\u69A3\u6B49\u6B4C\u6C33\u6F33\u6F14\u6EFE\u6F13\u6EF4\u6F29\u6F3E\u6F20\u6F2C\u6F0F\u6F02\u6F22"],
      ["baa1", "\u6EFF\u6EEF\u6F06\u6F31\u6F38\u6F32\u6F23\u6F15\u6F2B\u6F2F\u6F88\u6F2A\u6EEC\u6F01\u6EF2\u6ECC\u6EF7\u7194\u7199\u717D\u718A\u7184\u7192\u723E\u7292\u7296\u7344\u7350\u7464\u7463\u746A\u7470\u746D\u7504\u7591\u7627\u760D\u760B\u7609\u7613\u76E1\u76E3\u7784\u777D\u777F\u7761\u78C1\u789F\u78A7\u78B3\u78A9\u78A3\u798E\u798F\u798D\u7A2E\u7A31\u7AAA\u7AA9\u7AED\u7AEF\u7BA1\u7B95\u7B8B\u7B75\u7B97\u7B9D\u7B94\u7B8F\u7BB8\u7B87\u7B84\u7CB9\u7CBD\u7CBE\u7DBB\u7DB0\u7D9C\u7DBD\u7DBE\u7DA0\u7DCA\u7DB4\u7DB2\u7DB1\u7DBA\u7DA2\u7DBF\u7DB5\u7DB8\u7DAD\u7DD2\u7DC7\u7DAC"],
      ["bb40", "\u7F70\u7FE0\u7FE1\u7FDF\u805E\u805A\u8087\u8150\u8180\u818F\u8188\u818A\u817F\u8182\u81E7\u81FA\u8207\u8214\u821E\u824B\u84C9\u84BF\u84C6\u84C4\u8499\u849E\u84B2\u849C\u84CB\u84B8\u84C0\u84D3\u8490\u84BC\u84D1\u84CA\u873F\u871C\u873B\u8722\u8725\u8734\u8718\u8755\u8737\u8729\u88F3\u8902\u88F4\u88F9\u88F8\u88FD\u88E8\u891A\u88EF\u8AA6\u8A8C\u8A9E\u8AA3\u8A8D\u8AA1\u8A93\u8AA4"],
      ["bba1", "\u8AAA\u8AA5\u8AA8\u8A98\u8A91\u8A9A\u8AA7\u8C6A\u8C8D\u8C8C\u8CD3\u8CD1\u8CD2\u8D6B\u8D99\u8D95\u8DFC\u8F14\u8F12\u8F15\u8F13\u8FA3\u9060\u9058\u905C\u9063\u9059\u905E\u9062\u905D\u905B\u9119\u9118\u911E\u9175\u9178\u9177\u9174\u9278\u9280\u9285\u9298\u9296\u927B\u9293\u929C\u92A8\u927C\u9291\u95A1\u95A8\u95A9\u95A3\u95A5\u95A4\u9699\u969C\u969B\u96CC\u96D2\u9700\u977C\u9785\u97F6\u9817\u9818\u98AF\u98B1\u9903\u9905\u990C\u9909\u99C1\u9AAF\u9AB0\u9AE6\u9B41\u9B42\u9CF4\u9CF6\u9CF3\u9EBC\u9F3B\u9F4A\u5104\u5100\u50FB\u50F5\u50F9\u5102\u5108\u5109\u5105\u51DC"],
      ["bc40", "\u5287\u5288\u5289\u528D\u528A\u52F0\u53B2\u562E\u563B\u5639\u5632\u563F\u5634\u5629\u5653\u564E\u5657\u5674\u5636\u562F\u5630\u5880\u589F\u589E\u58B3\u589C\u58AE\u58A9\u58A6\u596D\u5B09\u5AFB\u5B0B\u5AF5\u5B0C\u5B08\u5BEE\u5BEC\u5BE9\u5BEB\u5C64\u5C65\u5D9D\u5D94\u5E62\u5E5F\u5E61\u5EE2\u5EDA\u5EDF\u5EDD\u5EE3\u5EE0\u5F48\u5F71\u5FB7\u5FB5\u6176\u6167\u616E\u615D\u6155\u6182"],
      ["bca1", "\u617C\u6170\u616B\u617E\u61A7\u6190\u61AB\u618E\u61AC\u619A\u61A4\u6194\u61AE\u622E\u6469\u646F\u6479\u649E\u64B2\u6488\u6490\u64B0\u64A5\u6493\u6495\u64A9\u6492\u64AE\u64AD\u64AB\u649A\u64AC\u6499\u64A2\u64B3\u6575\u6577\u6578\u66AE\u66AB\u66B4\u66B1\u6A23\u6A1F\u69E8\u6A01\u6A1E\u6A19\u69FD\u6A21\u6A13\u6A0A\u69F3\u6A02\u6A05\u69ED\u6A11\u6B50\u6B4E\u6BA4\u6BC5\u6BC6\u6F3F\u6F7C\u6F84\u6F51\u6F66\u6F54\u6F86\u6F6D\u6F5B\u6F78\u6F6E\u6F8E\u6F7A\u6F70\u6F64\u6F97\u6F58\u6ED5\u6F6F\u6F60\u6F5F\u719F\u71AC\u71B1\u71A8\u7256\u729B\u734E\u7357\u7469\u748B\u7483"],
      ["bd40", "\u747E\u7480\u757F\u7620\u7629\u761F\u7624\u7626\u7621\u7622\u769A\u76BA\u76E4\u778E\u7787\u778C\u7791\u778B\u78CB\u78C5\u78BA\u78CA\u78BE\u78D5\u78BC\u78D0\u7A3F\u7A3C\u7A40\u7A3D\u7A37\u7A3B\u7AAF\u7AAE\u7BAD\u7BB1\u7BC4\u7BB4\u7BC6\u7BC7\u7BC1\u7BA0\u7BCC\u7CCA\u7DE0\u7DF4\u7DEF\u7DFB\u7DD8\u7DEC\u7DDD\u7DE8\u7DE3\u7DDA\u7DDE\u7DE9\u7D9E\u7DD9\u7DF2\u7DF9\u7F75\u7F77\u7FAF"],
      ["bda1", "\u7FE9\u8026\u819B\u819C\u819D\u81A0\u819A\u8198\u8517\u853D\u851A\u84EE\u852C\u852D\u8513\u8511\u8523\u8521\u8514\u84EC\u8525\u84FF\u8506\u8782\u8774\u8776\u8760\u8766\u8778\u8768\u8759\u8757\u874C\u8753\u885B\u885D\u8910\u8907\u8912\u8913\u8915\u890A\u8ABC\u8AD2\u8AC7\u8AC4\u8A95\u8ACB\u8AF8\u8AB2\u8AC9\u8AC2\u8ABF\u8AB0\u8AD6\u8ACD\u8AB6\u8AB9\u8ADB\u8C4C\u8C4E\u8C6C\u8CE0\u8CDE\u8CE6\u8CE4\u8CEC\u8CED\u8CE2\u8CE3\u8CDC\u8CEA\u8CE1\u8D6D\u8D9F\u8DA3\u8E2B\u8E10\u8E1D\u8E22\u8E0F\u8E29\u8E1F\u8E21\u8E1E\u8EBA\u8F1D\u8F1B\u8F1F\u8F29\u8F26\u8F2A\u8F1C\u8F1E"],
      ["be40", "\u8F25\u9069\u906E\u9068\u906D\u9077\u9130\u912D\u9127\u9131\u9187\u9189\u918B\u9183\u92C5\u92BB\u92B7\u92EA\u92AC\u92E4\u92C1\u92B3\u92BC\u92D2\u92C7\u92F0\u92B2\u95AD\u95B1\u9704\u9706\u9707\u9709\u9760\u978D\u978B\u978F\u9821\u982B\u981C\u98B3\u990A\u9913\u9912\u9918\u99DD\u99D0\u99DF\u99DB\u99D1\u99D5\u99D2\u99D9\u9AB7\u9AEE\u9AEF\u9B27\u9B45\u9B44\u9B77\u9B6F\u9D06\u9D09"],
      ["bea1", "\u9D03\u9EA9\u9EBE\u9ECE\u58A8\u9F52\u5112\u5118\u5114\u5110\u5115\u5180\u51AA\u51DD\u5291\u5293\u52F3\u5659\u566B\u5679\u5669\u5664\u5678\u566A\u5668\u5665\u5671\u566F\u566C\u5662\u5676\u58C1\u58BE\u58C7\u58C5\u596E\u5B1D\u5B34\u5B78\u5BF0\u5C0E\u5F4A\u61B2\u6191\u61A9\u618A\u61CD\u61B6\u61BE\u61CA\u61C8\u6230\u64C5\u64C1\u64CB\u64BB\u64BC\u64DA\u64C4\u64C7\u64C2\u64CD\u64BF\u64D2\u64D4\u64BE\u6574\u66C6\u66C9\u66B9\u66C4\u66C7\u66B8\u6A3D\u6A38\u6A3A\u6A59\u6A6B\u6A58\u6A39\u6A44\u6A62\u6A61\u6A4B\u6A47\u6A35\u6A5F\u6A48\u6B59\u6B77\u6C05\u6FC2\u6FB1\u6FA1"],
      ["bf40", "\u6FC3\u6FA4\u6FC1\u6FA7\u6FB3\u6FC0\u6FB9\u6FB6\u6FA6\u6FA0\u6FB4\u71BE\u71C9\u71D0\u71D2\u71C8\u71D5\u71B9\u71CE\u71D9\u71DC\u71C3\u71C4\u7368\u749C\u74A3\u7498\u749F\u749E\u74E2\u750C\u750D\u7634\u7638\u763A\u76E7\u76E5\u77A0\u779E\u779F\u77A5\u78E8\u78DA\u78EC\u78E7\u79A6\u7A4D\u7A4E\u7A46\u7A4C\u7A4B\u7ABA\u7BD9\u7C11\u7BC9\u7BE4\u7BDB\u7BE1\u7BE9\u7BE6\u7CD5\u7CD6\u7E0A"],
      ["bfa1", "\u7E11\u7E08\u7E1B\u7E23\u7E1E\u7E1D\u7E09\u7E10\u7F79\u7FB2\u7FF0\u7FF1\u7FEE\u8028\u81B3\u81A9\u81A8\u81FB\u8208\u8258\u8259\u854A\u8559\u8548\u8568\u8569\u8543\u8549\u856D\u856A\u855E\u8783\u879F\u879E\u87A2\u878D\u8861\u892A\u8932\u8925\u892B\u8921\u89AA\u89A6\u8AE6\u8AFA\u8AEB\u8AF1\u8B00\u8ADC\u8AE7\u8AEE\u8AFE\u8B01\u8B02\u8AF7\u8AED\u8AF3\u8AF6\u8AFC\u8C6B\u8C6D\u8C93\u8CF4\u8E44\u8E31\u8E34\u8E42\u8E39\u8E35\u8F3B\u8F2F\u8F38\u8F33\u8FA8\u8FA6\u9075\u9074\u9078\u9072\u907C\u907A\u9134\u9192\u9320\u9336\u92F8\u9333\u932F\u9322\u92FC\u932B\u9304\u931A"],
      ["c040", "\u9310\u9326\u9321\u9315\u932E\u9319\u95BB\u96A7\u96A8\u96AA\u96D5\u970E\u9711\u9716\u970D\u9713\u970F\u975B\u975C\u9766\u9798\u9830\u9838\u983B\u9837\u982D\u9839\u9824\u9910\u9928\u991E\u991B\u9921\u991A\u99ED\u99E2\u99F1\u9AB8\u9ABC\u9AFB\u9AED\u9B28\u9B91\u9D15\u9D23\u9D26\u9D28\u9D12\u9D1B\u9ED8\u9ED4\u9F8D\u9F9C\u512A\u511F\u5121\u5132\u52F5\u568E\u5680\u5690\u5685\u5687"],
      ["c0a1", "\u568F\u58D5\u58D3\u58D1\u58CE\u5B30\u5B2A\u5B24\u5B7A\u5C37\u5C68\u5DBC\u5DBA\u5DBD\u5DB8\u5E6B\u5F4C\u5FBD\u61C9\u61C2\u61C7\u61E6\u61CB\u6232\u6234\u64CE\u64CA\u64D8\u64E0\u64F0\u64E6\u64EC\u64F1\u64E2\u64ED\u6582\u6583\u66D9\u66D6\u6A80\u6A94\u6A84\u6AA2\u6A9C\u6ADB\u6AA3\u6A7E\u6A97\u6A90\u6AA0\u6B5C\u6BAE\u6BDA\u6C08\u6FD8\u6FF1\u6FDF\u6FE0\u6FDB\u6FE4\u6FEB\u6FEF\u6F80\u6FEC\u6FE1\u6FE9\u6FD5\u6FEE\u6FF0\u71E7\u71DF\u71EE\u71E6\u71E5\u71ED\u71EC\u71F4\u71E0\u7235\u7246\u7370\u7372\u74A9\u74B0\u74A6\u74A8\u7646\u7642\u764C\u76EA\u77B3\u77AA\u77B0\u77AC"],
      ["c140", "\u77A7\u77AD\u77EF\u78F7\u78FA\u78F4\u78EF\u7901\u79A7\u79AA\u7A57\u7ABF\u7C07\u7C0D\u7BFE\u7BF7\u7C0C\u7BE0\u7CE0\u7CDC\u7CDE\u7CE2\u7CDF\u7CD9\u7CDD\u7E2E\u7E3E\u7E46\u7E37\u7E32\u7E43\u7E2B\u7E3D\u7E31\u7E45\u7E41\u7E34\u7E39\u7E48\u7E35\u7E3F\u7E2F\u7F44\u7FF3\u7FFC\u8071\u8072\u8070\u806F\u8073\u81C6\u81C3\u81BA\u81C2\u81C0\u81BF\u81BD\u81C9\u81BE\u81E8\u8209\u8271\u85AA"],
      ["c1a1", "\u8584\u857E\u859C\u8591\u8594\u85AF\u859B\u8587\u85A8\u858A\u8667\u87C0\u87D1\u87B3\u87D2\u87C6\u87AB\u87BB\u87BA\u87C8\u87CB\u893B\u8936\u8944\u8938\u893D\u89AC\u8B0E\u8B17\u8B19\u8B1B\u8B0A\u8B20\u8B1D\u8B04\u8B10\u8C41\u8C3F\u8C73\u8CFA\u8CFD\u8CFC\u8CF8\u8CFB\u8DA8\u8E49\u8E4B\u8E48\u8E4A\u8F44\u8F3E\u8F42\u8F45\u8F3F\u907F\u907D\u9084\u9081\u9082\u9080\u9139\u91A3\u919E\u919C\u934D\u9382\u9328\u9375\u934A\u9365\u934B\u9318\u937E\u936C\u935B\u9370\u935A\u9354\u95CA\u95CB\u95CC\u95C8\u95C6\u96B1\u96B8\u96D6\u971C\u971E\u97A0\u97D3\u9846\u98B6\u9935\u9A01"],
      ["c240", "\u99FF\u9BAE\u9BAB\u9BAA\u9BAD\u9D3B\u9D3F\u9E8B\u9ECF\u9EDE\u9EDC\u9EDD\u9EDB\u9F3E\u9F4B\u53E2\u5695\u56AE\u58D9\u58D8\u5B38\u5F5D\u61E3\u6233\u64F4\u64F2\u64FE\u6506\u64FA\u64FB\u64F7\u65B7\u66DC\u6726\u6AB3\u6AAC\u6AC3\u6ABB\u6AB8\u6AC2\u6AAE\u6AAF\u6B5F\u6B78\u6BAF\u7009\u700B\u6FFE\u7006\u6FFA\u7011\u700F\u71FB\u71FC\u71FE\u71F8\u7377\u7375\u74A7\u74BF\u7515\u7656\u7658"],
      ["c2a1", "\u7652\u77BD\u77BF\u77BB\u77BC\u790E\u79AE\u7A61\u7A62\u7A60\u7AC4\u7AC5\u7C2B\u7C27\u7C2A\u7C1E\u7C23\u7C21\u7CE7\u7E54\u7E55\u7E5E\u7E5A\u7E61\u7E52\u7E59\u7F48\u7FF9\u7FFB\u8077\u8076\u81CD\u81CF\u820A\u85CF\u85A9\u85CD\u85D0\u85C9\u85B0\u85BA\u85B9\u85A6\u87EF\u87EC\u87F2\u87E0\u8986\u89B2\u89F4\u8B28\u8B39\u8B2C\u8B2B\u8C50\u8D05\u8E59\u8E63\u8E66\u8E64\u8E5F\u8E55\u8EC0\u8F49\u8F4D\u9087\u9083\u9088\u91AB\u91AC\u91D0\u9394\u938A\u9396\u93A2\u93B3\u93AE\u93AC\u93B0\u9398\u939A\u9397\u95D4\u95D6\u95D0\u95D5\u96E2\u96DC\u96D9\u96DB\u96DE\u9724\u97A3\u97A6"],
      ["c340", "\u97AD\u97F9\u984D\u984F\u984C\u984E\u9853\u98BA\u993E\u993F\u993D\u992E\u99A5\u9A0E\u9AC1\u9B03\u9B06\u9B4F\u9B4E\u9B4D\u9BCA\u9BC9\u9BFD\u9BC8\u9BC0\u9D51\u9D5D\u9D60\u9EE0\u9F15\u9F2C\u5133\u56A5\u58DE\u58DF\u58E2\u5BF5\u9F90\u5EEC\u61F2\u61F7\u61F6\u61F5\u6500\u650F\u66E0\u66DD\u6AE5\u6ADD\u6ADA\u6AD3\u701B\u701F\u7028\u701A\u701D\u7015\u7018\u7206\u720D\u7258\u72A2\u7378"],
      ["c3a1", "\u737A\u74BD\u74CA\u74E3\u7587\u7586\u765F\u7661\u77C7\u7919\u79B1\u7A6B\u7A69\u7C3E\u7C3F\u7C38\u7C3D\u7C37\u7C40\u7E6B\u7E6D\u7E79\u7E69\u7E6A\u7F85\u7E73\u7FB6\u7FB9\u7FB8\u81D8\u85E9\u85DD\u85EA\u85D5\u85E4\u85E5\u85F7\u87FB\u8805\u880D\u87F9\u87FE\u8960\u895F\u8956\u895E\u8B41\u8B5C\u8B58\u8B49\u8B5A\u8B4E\u8B4F\u8B46\u8B59\u8D08\u8D0A\u8E7C\u8E72\u8E87\u8E76\u8E6C\u8E7A\u8E74\u8F54\u8F4E\u8FAD\u908A\u908B\u91B1\u91AE\u93E1\u93D1\u93DF\u93C3\u93C8\u93DC\u93DD\u93D6\u93E2\u93CD\u93D8\u93E4\u93D7\u93E8\u95DC\u96B4\u96E3\u972A\u9727\u9761\u97DC\u97FB\u985E"],
      ["c440", "\u9858\u985B\u98BC\u9945\u9949\u9A16\u9A19\u9B0D\u9BE8\u9BE7\u9BD6\u9BDB\u9D89\u9D61\u9D72\u9D6A\u9D6C\u9E92\u9E97\u9E93\u9EB4\u52F8\u56A8\u56B7\u56B6\u56B4\u56BC\u58E4\u5B40\u5B43\u5B7D\u5BF6\u5DC9\u61F8\u61FA\u6518\u6514\u6519\u66E6\u6727\u6AEC\u703E\u7030\u7032\u7210\u737B\u74CF\u7662\u7665\u7926\u792A\u792C\u792B\u7AC7\u7AF6\u7C4C\u7C43\u7C4D\u7CEF\u7CF0\u8FAE\u7E7D\u7E7C"],
      ["c4a1", "\u7E82\u7F4C\u8000\u81DA\u8266\u85FB\u85F9\u8611\u85FA\u8606\u860B\u8607\u860A\u8814\u8815\u8964\u89BA\u89F8\u8B70\u8B6C\u8B66\u8B6F\u8B5F\u8B6B\u8D0F\u8D0D\u8E89\u8E81\u8E85\u8E82\u91B4\u91CB\u9418\u9403\u93FD\u95E1\u9730\u98C4\u9952\u9951\u99A8\u9A2B\u9A30\u9A37\u9A35\u9C13\u9C0D\u9E79\u9EB5\u9EE8\u9F2F\u9F5F\u9F63\u9F61\u5137\u5138\u56C1\u56C0\u56C2\u5914\u5C6C\u5DCD\u61FC\u61FE\u651D\u651C\u6595\u66E9\u6AFB\u6B04\u6AFA\u6BB2\u704C\u721B\u72A7\u74D6\u74D4\u7669\u77D3\u7C50\u7E8F\u7E8C\u7FBC\u8617\u862D\u861A\u8823\u8822\u8821\u881F\u896A\u896C\u89BD\u8B74"],
      ["c540", "\u8B77\u8B7D\u8D13\u8E8A\u8E8D\u8E8B\u8F5F\u8FAF\u91BA\u942E\u9433\u9435\u943A\u9438\u9432\u942B\u95E2\u9738\u9739\u9732\u97FF\u9867\u9865\u9957\u9A45\u9A43\u9A40\u9A3E\u9ACF\u9B54\u9B51\u9C2D\u9C25\u9DAF\u9DB4\u9DC2\u9DB8\u9E9D\u9EEF\u9F19\u9F5C\u9F66\u9F67\u513C\u513B\u56C8\u56CA\u56C9\u5B7F\u5DD4\u5DD2\u5F4E\u61FF\u6524\u6B0A\u6B61\u7051\u7058\u7380\u74E4\u758A\u766E\u766C"],
      ["c5a1", "\u79B3\u7C60\u7C5F\u807E\u807D\u81DF\u8972\u896F\u89FC\u8B80\u8D16\u8D17\u8E91\u8E93\u8F61\u9148\u9444\u9451\u9452\u973D\u973E\u97C3\u97C1\u986B\u9955\u9A55\u9A4D\u9AD2\u9B1A\u9C49\u9C31\u9C3E\u9C3B\u9DD3\u9DD7\u9F34\u9F6C\u9F6A\u9F94\u56CC\u5DD6\u6200\u6523\u652B\u652A\u66EC\u6B10\u74DA\u7ACA\u7C64\u7C63\u7C65\u7E93\u7E96\u7E94\u81E2\u8638\u863F\u8831\u8B8A\u9090\u908F\u9463\u9460\u9464\u9768\u986F\u995C\u9A5A\u9A5B\u9A57\u9AD3\u9AD4\u9AD1\u9C54\u9C57\u9C56\u9DE5\u9E9F\u9EF4\u56D1\u58E9\u652C\u705E\u7671\u7672\u77D7\u7F50\u7F88\u8836\u8839\u8862\u8B93\u8B92"],
      ["c640", "\u8B96\u8277\u8D1B\u91C0\u946A\u9742\u9748\u9744\u97C6\u9870\u9A5F\u9B22\u9B58\u9C5F\u9DF9\u9DFA\u9E7C\u9E7D\u9F07\u9F77\u9F72\u5EF3\u6B16\u7063\u7C6C\u7C6E\u883B\u89C0\u8EA1\u91C1\u9472\u9470\u9871\u995E\u9AD6\u9B23\u9ECC\u7064\u77DA\u8B9A\u9477\u97C9\u9A62\u9A65\u7E9C\u8B9C\u8EAA\u91C5\u947D\u947E\u947C\u9C77\u9C78\u9EF7\u8C54\u947F\u9E1A\u7228\u9A6A\u9B31\u9E1B\u9E1E\u7C72"],
      ["c940", "\u4E42\u4E5C\u51F5\u531A\u5382\u4E07\u4E0C\u4E47\u4E8D\u56D7\uFA0C\u5C6E\u5F73\u4E0F\u5187\u4E0E\u4E2E\u4E93\u4EC2\u4EC9\u4EC8\u5198\u52FC\u536C\u53B9\u5720\u5903\u592C\u5C10\u5DFF\u65E1\u6BB3\u6BCC\u6C14\u723F\u4E31\u4E3C\u4EE8\u4EDC\u4EE9\u4EE1\u4EDD\u4EDA\u520C\u531C\u534C\u5722\u5723\u5917\u592F\u5B81\u5B84\u5C12\u5C3B\u5C74\u5C73\u5E04\u5E80\u5E82\u5FC9\u6209\u6250\u6C15"],
      ["c9a1", "\u6C36\u6C43\u6C3F\u6C3B\u72AE\u72B0\u738A\u79B8\u808A\u961E\u4F0E\u4F18\u4F2C\u4EF5\u4F14\u4EF1\u4F00\u4EF7\u4F08\u4F1D\u4F02\u4F05\u4F22\u4F13\u4F04\u4EF4\u4F12\u51B1\u5213\u5209\u5210\u52A6\u5322\u531F\u534D\u538A\u5407\u56E1\u56DF\u572E\u572A\u5734\u593C\u5980\u597C\u5985\u597B\u597E\u5977\u597F\u5B56\u5C15\u5C25\u5C7C\u5C7A\u5C7B\u5C7E\u5DDF\u5E75\u5E84\u5F02\u5F1A\u5F74\u5FD5\u5FD4\u5FCF\u625C\u625E\u6264\u6261\u6266\u6262\u6259\u6260\u625A\u6265\u65EF\u65EE\u673E\u6739\u6738\u673B\u673A\u673F\u673C\u6733\u6C18\u6C46\u6C52\u6C5C\u6C4F\u6C4A\u6C54\u6C4B"],
      ["ca40", "\u6C4C\u7071\u725E\u72B4\u72B5\u738E\u752A\u767F\u7A75\u7F51\u8278\u827C\u8280\u827D\u827F\u864D\u897E\u9099\u9097\u9098\u909B\u9094\u9622\u9624\u9620\u9623\u4F56\u4F3B\u4F62\u4F49\u4F53\u4F64\u4F3E\u4F67\u4F52\u4F5F\u4F41\u4F58\u4F2D\u4F33\u4F3F\u4F61\u518F\u51B9\u521C\u521E\u5221\u52AD\u52AE\u5309\u5363\u5372\u538E\u538F\u5430\u5437\u542A\u5454\u5445\u5419\u541C\u5425\u5418"],
      ["caa1", "\u543D\u544F\u5441\u5428\u5424\u5447\u56EE\u56E7\u56E5\u5741\u5745\u574C\u5749\u574B\u5752\u5906\u5940\u59A6\u5998\u59A0\u5997\u598E\u59A2\u5990\u598F\u59A7\u59A1\u5B8E\u5B92\u5C28\u5C2A\u5C8D\u5C8F\u5C88\u5C8B\u5C89\u5C92\u5C8A\u5C86\u5C93\u5C95\u5DE0\u5E0A\u5E0E\u5E8B\u5E89\u5E8C\u5E88\u5E8D\u5F05\u5F1D\u5F78\u5F76\u5FD2\u5FD1\u5FD0\u5FED\u5FE8\u5FEE\u5FF3\u5FE1\u5FE4\u5FE3\u5FFA\u5FEF\u5FF7\u5FFB\u6000\u5FF4\u623A\u6283\u628C\u628E\u628F\u6294\u6287\u6271\u627B\u627A\u6270\u6281\u6288\u6277\u627D\u6272\u6274\u6537\u65F0\u65F4\u65F3\u65F2\u65F5\u6745\u6747"],
      ["cb40", "\u6759\u6755\u674C\u6748\u675D\u674D\u675A\u674B\u6BD0\u6C19\u6C1A\u6C78\u6C67\u6C6B\u6C84\u6C8B\u6C8F\u6C71\u6C6F\u6C69\u6C9A\u6C6D\u6C87\u6C95\u6C9C\u6C66\u6C73\u6C65\u6C7B\u6C8E\u7074\u707A\u7263\u72BF\u72BD\u72C3\u72C6\u72C1\u72BA\u72C5\u7395\u7397\u7393\u7394\u7392\u753A\u7539\u7594\u7595\u7681\u793D\u8034\u8095\u8099\u8090\u8092\u809C\u8290\u828F\u8285\u828E\u8291\u8293"],
      ["cba1", "\u828A\u8283\u8284\u8C78\u8FC9\u8FBF\u909F\u90A1\u90A5\u909E\u90A7\u90A0\u9630\u9628\u962F\u962D\u4E33\u4F98\u4F7C\u4F85\u4F7D\u4F80\u4F87\u4F76\u4F74\u4F89\u4F84\u4F77\u4F4C\u4F97\u4F6A\u4F9A\u4F79\u4F81\u4F78\u4F90\u4F9C\u4F94\u4F9E\u4F92\u4F82\u4F95\u4F6B\u4F6E\u519E\u51BC\u51BE\u5235\u5232\u5233\u5246\u5231\u52BC\u530A\u530B\u533C\u5392\u5394\u5487\u547F\u5481\u5491\u5482\u5488\u546B\u547A\u547E\u5465\u546C\u5474\u5466\u548D\u546F\u5461\u5460\u5498\u5463\u5467\u5464\u56F7\u56F9\u576F\u5772\u576D\u576B\u5771\u5770\u5776\u5780\u5775\u577B\u5773\u5774\u5762"],
      ["cc40", "\u5768\u577D\u590C\u5945\u59B5\u59BA\u59CF\u59CE\u59B2\u59CC\u59C1\u59B6\u59BC\u59C3\u59D6\u59B1\u59BD\u59C0\u59C8\u59B4\u59C7\u5B62\u5B65\u5B93\u5B95\u5C44\u5C47\u5CAE\u5CA4\u5CA0\u5CB5\u5CAF\u5CA8\u5CAC\u5C9F\u5CA3\u5CAD\u5CA2\u5CAA\u5CA7\u5C9D\u5CA5\u5CB6\u5CB0\u5CA6\u5E17\u5E14\u5E19\u5F28\u5F22\u5F23\u5F24\u5F54\u5F82\u5F7E\u5F7D\u5FDE\u5FE5\u602D\u6026\u6019\u6032\u600B"],
      ["cca1", "\u6034\u600A\u6017\u6033\u601A\u601E\u602C\u6022\u600D\u6010\u602E\u6013\u6011\u600C\u6009\u601C\u6214\u623D\u62AD\u62B4\u62D1\u62BE\u62AA\u62B6\u62CA\u62AE\u62B3\u62AF\u62BB\u62A9\u62B0\u62B8\u653D\u65A8\u65BB\u6609\u65FC\u6604\u6612\u6608\u65FB\u6603\u660B\u660D\u6605\u65FD\u6611\u6610\u66F6\u670A\u6785\u676C\u678E\u6792\u6776\u677B\u6798\u6786\u6784\u6774\u678D\u678C\u677A\u679F\u6791\u6799\u6783\u677D\u6781\u6778\u6779\u6794\u6B25\u6B80\u6B7E\u6BDE\u6C1D\u6C93\u6CEC\u6CEB\u6CEE\u6CD9\u6CB6\u6CD4\u6CAD\u6CE7\u6CB7\u6CD0\u6CC2\u6CBA\u6CC3\u6CC6\u6CED\u6CF2"],
      ["cd40", "\u6CD2\u6CDD\u6CB4\u6C8A\u6C9D\u6C80\u6CDE\u6CC0\u6D30\u6CCD\u6CC7\u6CB0\u6CF9\u6CCF\u6CE9\u6CD1\u7094\u7098\u7085\u7093\u7086\u7084\u7091\u7096\u7082\u709A\u7083\u726A\u72D6\u72CB\u72D8\u72C9\u72DC\u72D2\u72D4\u72DA\u72CC\u72D1\u73A4\u73A1\u73AD\u73A6\u73A2\u73A0\u73AC\u739D\u74DD\u74E8\u753F\u7540\u753E\u758C\u7598\u76AF\u76F3\u76F1\u76F0\u76F5\u77F8\u77FC\u77F9\u77FB\u77FA"],
      ["cda1", "\u77F7\u7942\u793F\u79C5\u7A78\u7A7B\u7AFB\u7C75\u7CFD\u8035\u808F\u80AE\u80A3\u80B8\u80B5\u80AD\u8220\u82A0\u82C0\u82AB\u829A\u8298\u829B\u82B5\u82A7\u82AE\u82BC\u829E\u82BA\u82B4\u82A8\u82A1\u82A9\u82C2\u82A4\u82C3\u82B6\u82A2\u8670\u866F\u866D\u866E\u8C56\u8FD2\u8FCB\u8FD3\u8FCD\u8FD6\u8FD5\u8FD7\u90B2\u90B4\u90AF\u90B3\u90B0\u9639\u963D\u963C\u963A\u9643\u4FCD\u4FC5\u4FD3\u4FB2\u4FC9\u4FCB\u4FC1\u4FD4\u4FDC\u4FD9\u4FBB\u4FB3\u4FDB\u4FC7\u4FD6\u4FBA\u4FC0\u4FB9\u4FEC\u5244\u5249\u52C0\u52C2\u533D\u537C\u5397\u5396\u5399\u5398\u54BA\u54A1\u54AD\u54A5\u54CF"],
      ["ce40", "\u54C3\u830D\u54B7\u54AE\u54D6\u54B6\u54C5\u54C6\u54A0\u5470\u54BC\u54A2\u54BE\u5472\u54DE\u54B0\u57B5\u579E\u579F\u57A4\u578C\u5797\u579D\u579B\u5794\u5798\u578F\u5799\u57A5\u579A\u5795\u58F4\u590D\u5953\u59E1\u59DE\u59EE\u5A00\u59F1\u59DD\u59FA\u59FD\u59FC\u59F6\u59E4\u59F2\u59F7\u59DB\u59E9\u59F3\u59F5\u59E0\u59FE\u59F4\u59ED\u5BA8\u5C4C\u5CD0\u5CD8\u5CCC\u5CD7\u5CCB\u5CDB"],
      ["cea1", "\u5CDE\u5CDA\u5CC9\u5CC7\u5CCA\u5CD6\u5CD3\u5CD4\u5CCF\u5CC8\u5CC6\u5CCE\u5CDF\u5CF8\u5DF9\u5E21\u5E22\u5E23\u5E20\u5E24\u5EB0\u5EA4\u5EA2\u5E9B\u5EA3\u5EA5\u5F07\u5F2E\u5F56\u5F86\u6037\u6039\u6054\u6072\u605E\u6045\u6053\u6047\u6049\u605B\u604C\u6040\u6042\u605F\u6024\u6044\u6058\u6066\u606E\u6242\u6243\u62CF\u630D\u630B\u62F5\u630E\u6303\u62EB\u62F9\u630F\u630C\u62F8\u62F6\u6300\u6313\u6314\u62FA\u6315\u62FB\u62F0\u6541\u6543\u65AA\u65BF\u6636\u6621\u6632\u6635\u661C\u6626\u6622\u6633\u662B\u663A\u661D\u6634\u6639\u662E\u670F\u6710\u67C1\u67F2\u67C8\u67BA"],
      ["cf40", "\u67DC\u67BB\u67F8\u67D8\u67C0\u67B7\u67C5\u67EB\u67E4\u67DF\u67B5\u67CD\u67B3\u67F7\u67F6\u67EE\u67E3\u67C2\u67B9\u67CE\u67E7\u67F0\u67B2\u67FC\u67C6\u67ED\u67CC\u67AE\u67E6\u67DB\u67FA\u67C9\u67CA\u67C3\u67EA\u67CB\u6B28\u6B82\u6B84\u6BB6\u6BD6\u6BD8\u6BE0\u6C20\u6C21\u6D28\u6D34\u6D2D\u6D1F\u6D3C\u6D3F\u6D12\u6D0A\u6CDA\u6D33\u6D04\u6D19\u6D3A\u6D1A\u6D11\u6D00\u6D1D\u6D42"],
      ["cfa1", "\u6D01\u6D18\u6D37\u6D03\u6D0F\u6D40\u6D07\u6D20\u6D2C\u6D08\u6D22\u6D09\u6D10\u70B7\u709F\u70BE\u70B1\u70B0\u70A1\u70B4\u70B5\u70A9\u7241\u7249\u724A\u726C\u7270\u7273\u726E\u72CA\u72E4\u72E8\u72EB\u72DF\u72EA\u72E6\u72E3\u7385\u73CC\u73C2\u73C8\u73C5\u73B9\u73B6\u73B5\u73B4\u73EB\u73BF\u73C7\u73BE\u73C3\u73C6\u73B8\u73CB\u74EC\u74EE\u752E\u7547\u7548\u75A7\u75AA\u7679\u76C4\u7708\u7703\u7704\u7705\u770A\u76F7\u76FB\u76FA\u77E7\u77E8\u7806\u7811\u7812\u7805\u7810\u780F\u780E\u7809\u7803\u7813\u794A\u794C\u794B\u7945\u7944\u79D5\u79CD\u79CF\u79D6\u79CE\u7A80"],
      ["d040", "\u7A7E\u7AD1\u7B00\u7B01\u7C7A\u7C78\u7C79\u7C7F\u7C80\u7C81\u7D03\u7D08\u7D01\u7F58\u7F91\u7F8D\u7FBE\u8007\u800E\u800F\u8014\u8037\u80D8\u80C7\u80E0\u80D1\u80C8\u80C2\u80D0\u80C5\u80E3\u80D9\u80DC\u80CA\u80D5\u80C9\u80CF\u80D7\u80E6\u80CD\u81FF\u8221\u8294\u82D9\u82FE\u82F9\u8307\u82E8\u8300\u82D5\u833A\u82EB\u82D6\u82F4\u82EC\u82E1\u82F2\u82F5\u830C\u82FB\u82F6\u82F0\u82EA"],
      ["d0a1", "\u82E4\u82E0\u82FA\u82F3\u82ED\u8677\u8674\u867C\u8673\u8841\u884E\u8867\u886A\u8869\u89D3\u8A04\u8A07\u8D72\u8FE3\u8FE1\u8FEE\u8FE0\u90F1\u90BD\u90BF\u90D5\u90C5\u90BE\u90C7\u90CB\u90C8\u91D4\u91D3\u9654\u964F\u9651\u9653\u964A\u964E\u501E\u5005\u5007\u5013\u5022\u5030\u501B\u4FF5\u4FF4\u5033\u5037\u502C\u4FF6\u4FF7\u5017\u501C\u5020\u5027\u5035\u502F\u5031\u500E\u515A\u5194\u5193\u51CA\u51C4\u51C5\u51C8\u51CE\u5261\u525A\u5252\u525E\u525F\u5255\u5262\u52CD\u530E\u539E\u5526\u54E2\u5517\u5512\u54E7\u54F3\u54E4\u551A\u54FF\u5504\u5508\u54EB\u5511\u5505\u54F1"],
      ["d140", "\u550A\u54FB\u54F7\u54F8\u54E0\u550E\u5503\u550B\u5701\u5702\u57CC\u5832\u57D5\u57D2\u57BA\u57C6\u57BD\u57BC\u57B8\u57B6\u57BF\u57C7\u57D0\u57B9\u57C1\u590E\u594A\u5A19\u5A16\u5A2D\u5A2E\u5A15\u5A0F\u5A17\u5A0A\u5A1E\u5A33\u5B6C\u5BA7\u5BAD\u5BAC\u5C03\u5C56\u5C54\u5CEC\u5CFF\u5CEE\u5CF1\u5CF7\u5D00\u5CF9\u5E29\u5E28\u5EA8\u5EAE\u5EAA\u5EAC\u5F33\u5F30\u5F67\u605D\u605A\u6067"],
      ["d1a1", "\u6041\u60A2\u6088\u6080\u6092\u6081\u609D\u6083\u6095\u609B\u6097\u6087\u609C\u608E\u6219\u6246\u62F2\u6310\u6356\u632C\u6344\u6345\u6336\u6343\u63E4\u6339\u634B\u634A\u633C\u6329\u6341\u6334\u6358\u6354\u6359\u632D\u6347\u6333\u635A\u6351\u6338\u6357\u6340\u6348\u654A\u6546\u65C6\u65C3\u65C4\u65C2\u664A\u665F\u6647\u6651\u6712\u6713\u681F\u681A\u6849\u6832\u6833\u683B\u684B\u684F\u6816\u6831\u681C\u6835\u682B\u682D\u682F\u684E\u6844\u6834\u681D\u6812\u6814\u6826\u6828\u682E\u684D\u683A\u6825\u6820\u6B2C\u6B2F\u6B2D\u6B31\u6B34\u6B6D\u8082\u6B88\u6BE6\u6BE4"],
      ["d240", "\u6BE8\u6BE3\u6BE2\u6BE7\u6C25\u6D7A\u6D63\u6D64\u6D76\u6D0D\u6D61\u6D92\u6D58\u6D62\u6D6D\u6D6F\u6D91\u6D8D\u6DEF\u6D7F\u6D86\u6D5E\u6D67\u6D60\u6D97\u6D70\u6D7C\u6D5F\u6D82\u6D98\u6D2F\u6D68\u6D8B\u6D7E\u6D80\u6D84\u6D16\u6D83\u6D7B\u6D7D\u6D75\u6D90\u70DC\u70D3\u70D1\u70DD\u70CB\u7F39\u70E2\u70D7\u70D2\u70DE\u70E0\u70D4\u70CD\u70C5\u70C6\u70C7\u70DA\u70CE\u70E1\u7242\u7278"],
      ["d2a1", "\u7277\u7276\u7300\u72FA\u72F4\u72FE\u72F6\u72F3\u72FB\u7301\u73D3\u73D9\u73E5\u73D6\u73BC\u73E7\u73E3\u73E9\u73DC\u73D2\u73DB\u73D4\u73DD\u73DA\u73D7\u73D8\u73E8\u74DE\u74DF\u74F4\u74F5\u7521\u755B\u755F\u75B0\u75C1\u75BB\u75C4\u75C0\u75BF\u75B6\u75BA\u768A\u76C9\u771D\u771B\u7710\u7713\u7712\u7723\u7711\u7715\u7719\u771A\u7722\u7727\u7823\u782C\u7822\u7835\u782F\u7828\u782E\u782B\u7821\u7829\u7833\u782A\u7831\u7954\u795B\u794F\u795C\u7953\u7952\u7951\u79EB\u79EC\u79E0\u79EE\u79ED\u79EA\u79DC\u79DE\u79DD\u7A86\u7A89\u7A85\u7A8B\u7A8C\u7A8A\u7A87\u7AD8\u7B10"],
      ["d340", "\u7B04\u7B13\u7B05\u7B0F\u7B08\u7B0A\u7B0E\u7B09\u7B12\u7C84\u7C91\u7C8A\u7C8C\u7C88\u7C8D\u7C85\u7D1E\u7D1D\u7D11\u7D0E\u7D18\u7D16\u7D13\u7D1F\u7D12\u7D0F\u7D0C\u7F5C\u7F61\u7F5E\u7F60\u7F5D\u7F5B\u7F96\u7F92\u7FC3\u7FC2\u7FC0\u8016\u803E\u8039\u80FA\u80F2\u80F9\u80F5\u8101\u80FB\u8100\u8201\u822F\u8225\u8333\u832D\u8344\u8319\u8351\u8325\u8356\u833F\u8341\u8326\u831C\u8322"],
      ["d3a1", "\u8342\u834E\u831B\u832A\u8308\u833C\u834D\u8316\u8324\u8320\u8337\u832F\u8329\u8347\u8345\u834C\u8353\u831E\u832C\u834B\u8327\u8348\u8653\u8652\u86A2\u86A8\u8696\u868D\u8691\u869E\u8687\u8697\u8686\u868B\u869A\u8685\u86A5\u8699\u86A1\u86A7\u8695\u8698\u868E\u869D\u8690\u8694\u8843\u8844\u886D\u8875\u8876\u8872\u8880\u8871\u887F\u886F\u8883\u887E\u8874\u887C\u8A12\u8C47\u8C57\u8C7B\u8CA4\u8CA3\u8D76\u8D78\u8DB5\u8DB7\u8DB6\u8ED1\u8ED3\u8FFE\u8FF5\u9002\u8FFF\u8FFB\u9004\u8FFC\u8FF6\u90D6\u90E0\u90D9\u90DA\u90E3\u90DF\u90E5\u90D8\u90DB\u90D7\u90DC\u90E4\u9150"],
      ["d440", "\u914E\u914F\u91D5\u91E2\u91DA\u965C\u965F\u96BC\u98E3\u9ADF\u9B2F\u4E7F\u5070\u506A\u5061\u505E\u5060\u5053\u504B\u505D\u5072\u5048\u504D\u5041\u505B\u504A\u5062\u5015\u5045\u505F\u5069\u506B\u5063\u5064\u5046\u5040\u506E\u5073\u5057\u5051\u51D0\u526B\u526D\u526C\u526E\u52D6\u52D3\u532D\u539C\u5575\u5576\u553C\u554D\u5550\u5534\u552A\u5551\u5562\u5536\u5535\u5530\u5552\u5545"],
      ["d4a1", "\u550C\u5532\u5565\u554E\u5539\u5548\u552D\u553B\u5540\u554B\u570A\u5707\u57FB\u5814\u57E2\u57F6\u57DC\u57F4\u5800\u57ED\u57FD\u5808\u57F8\u580B\u57F3\u57CF\u5807\u57EE\u57E3\u57F2\u57E5\u57EC\u57E1\u580E\u57FC\u5810\u57E7\u5801\u580C\u57F1\u57E9\u57F0\u580D\u5804\u595C\u5A60\u5A58\u5A55\u5A67\u5A5E\u5A38\u5A35\u5A6D\u5A50\u5A5F\u5A65\u5A6C\u5A53\u5A64\u5A57\u5A43\u5A5D\u5A52\u5A44\u5A5B\u5A48\u5A8E\u5A3E\u5A4D\u5A39\u5A4C\u5A70\u5A69\u5A47\u5A51\u5A56\u5A42\u5A5C\u5B72\u5B6E\u5BC1\u5BC0\u5C59\u5D1E\u5D0B\u5D1D\u5D1A\u5D20\u5D0C\u5D28\u5D0D\u5D26\u5D25\u5D0F"],
      ["d540", "\u5D30\u5D12\u5D23\u5D1F\u5D2E\u5E3E\u5E34\u5EB1\u5EB4\u5EB9\u5EB2\u5EB3\u5F36\u5F38\u5F9B\u5F96\u5F9F\u608A\u6090\u6086\u60BE\u60B0\u60BA\u60D3\u60D4\u60CF\u60E4\u60D9\u60DD\u60C8\u60B1\u60DB\u60B7\u60CA\u60BF\u60C3\u60CD\u60C0\u6332\u6365\u638A\u6382\u637D\u63BD\u639E\u63AD\u639D\u6397\u63AB\u638E\u636F\u6387\u6390\u636E\u63AF\u6375\u639C\u636D\u63AE\u637C\u63A4\u633B\u639F"],
      ["d5a1", "\u6378\u6385\u6381\u6391\u638D\u6370\u6553\u65CD\u6665\u6661\u665B\u6659\u665C\u6662\u6718\u6879\u6887\u6890\u689C\u686D\u686E\u68AE\u68AB\u6956\u686F\u68A3\u68AC\u68A9\u6875\u6874\u68B2\u688F\u6877\u6892\u687C\u686B\u6872\u68AA\u6880\u6871\u687E\u689B\u6896\u688B\u68A0\u6889\u68A4\u6878\u687B\u6891\u688C\u688A\u687D\u6B36\u6B33\u6B37\u6B38\u6B91\u6B8F\u6B8D\u6B8E\u6B8C\u6C2A\u6DC0\u6DAB\u6DB4\u6DB3\u6E74\u6DAC\u6DE9\u6DE2\u6DB7\u6DF6\u6DD4\u6E00\u6DC8\u6DE0\u6DDF\u6DD6\u6DBE\u6DE5\u6DDC\u6DDD\u6DDB\u6DF4\u6DCA\u6DBD\u6DED\u6DF0\u6DBA\u6DD5\u6DC2\u6DCF\u6DC9"],
      ["d640", "\u6DD0\u6DF2\u6DD3\u6DFD\u6DD7\u6DCD\u6DE3\u6DBB\u70FA\u710D\u70F7\u7117\u70F4\u710C\u70F0\u7104\u70F3\u7110\u70FC\u70FF\u7106\u7113\u7100\u70F8\u70F6\u710B\u7102\u710E\u727E\u727B\u727C\u727F\u731D\u7317\u7307\u7311\u7318\u730A\u7308\u72FF\u730F\u731E\u7388\u73F6\u73F8\u73F5\u7404\u7401\u73FD\u7407\u7400\u73FA\u73FC\u73FF\u740C\u740B\u73F4\u7408\u7564\u7563\u75CE\u75D2\u75CF"],
      ["d6a1", "\u75CB\u75CC\u75D1\u75D0\u768F\u7689\u76D3\u7739\u772F\u772D\u7731\u7732\u7734\u7733\u773D\u7725\u773B\u7735\u7848\u7852\u7849\u784D\u784A\u784C\u7826\u7845\u7850\u7964\u7967\u7969\u796A\u7963\u796B\u7961\u79BB\u79FA\u79F8\u79F6\u79F7\u7A8F\u7A94\u7A90\u7B35\u7B47\u7B34\u7B25\u7B30\u7B22\u7B24\u7B33\u7B18\u7B2A\u7B1D\u7B31\u7B2B\u7B2D\u7B2F\u7B32\u7B38\u7B1A\u7B23\u7C94\u7C98\u7C96\u7CA3\u7D35\u7D3D\u7D38\u7D36\u7D3A\u7D45\u7D2C\u7D29\u7D41\u7D47\u7D3E\u7D3F\u7D4A\u7D3B\u7D28\u7F63\u7F95\u7F9C\u7F9D\u7F9B\u7FCA\u7FCB\u7FCD\u7FD0\u7FD1\u7FC7\u7FCF\u7FC9\u801F"],
      ["d740", "\u801E\u801B\u8047\u8043\u8048\u8118\u8125\u8119\u811B\u812D\u811F\u812C\u811E\u8121\u8115\u8127\u811D\u8122\u8211\u8238\u8233\u823A\u8234\u8232\u8274\u8390\u83A3\u83A8\u838D\u837A\u8373\u83A4\u8374\u838F\u8381\u8395\u8399\u8375\u8394\u83A9\u837D\u8383\u838C\u839D\u839B\u83AA\u838B\u837E\u83A5\u83AF\u8388\u8397\u83B0\u837F\u83A6\u8387\u83AE\u8376\u839A\u8659\u8656\u86BF\u86B7"],
      ["d7a1", "\u86C2\u86C1\u86C5\u86BA\u86B0\u86C8\u86B9\u86B3\u86B8\u86CC\u86B4\u86BB\u86BC\u86C3\u86BD\u86BE\u8852\u8889\u8895\u88A8\u88A2\u88AA\u889A\u8891\u88A1\u889F\u8898\u88A7\u8899\u889B\u8897\u88A4\u88AC\u888C\u8893\u888E\u8982\u89D6\u89D9\u89D5\u8A30\u8A27\u8A2C\u8A1E\u8C39\u8C3B\u8C5C\u8C5D\u8C7D\u8CA5\u8D7D\u8D7B\u8D79\u8DBC\u8DC2\u8DB9\u8DBF\u8DC1\u8ED8\u8EDE\u8EDD\u8EDC\u8ED7\u8EE0\u8EE1\u9024\u900B\u9011\u901C\u900C\u9021\u90EF\u90EA\u90F0\u90F4\u90F2\u90F3\u90D4\u90EB\u90EC\u90E9\u9156\u9158\u915A\u9153\u9155\u91EC\u91F4\u91F1\u91F3\u91F8\u91E4\u91F9\u91EA"],
      ["d840", "\u91EB\u91F7\u91E8\u91EE\u957A\u9586\u9588\u967C\u966D\u966B\u9671\u966F\u96BF\u976A\u9804\u98E5\u9997\u509B\u5095\u5094\u509E\u508B\u50A3\u5083\u508C\u508E\u509D\u5068\u509C\u5092\u5082\u5087\u515F\u51D4\u5312\u5311\u53A4\u53A7\u5591\u55A8\u55A5\u55AD\u5577\u5645\u55A2\u5593\u5588\u558F\u55B5\u5581\u55A3\u5592\u55A4\u557D\u558C\u55A6\u557F\u5595\u55A1\u558E\u570C\u5829\u5837"],
      ["d8a1", "\u5819\u581E\u5827\u5823\u5828\u57F5\u5848\u5825\u581C\u581B\u5833\u583F\u5836\u582E\u5839\u5838\u582D\u582C\u583B\u5961\u5AAF\u5A94\u5A9F\u5A7A\u5AA2\u5A9E\u5A78\u5AA6\u5A7C\u5AA5\u5AAC\u5A95\u5AAE\u5A37\u5A84\u5A8A\u5A97\u5A83\u5A8B\u5AA9\u5A7B\u5A7D\u5A8C\u5A9C\u5A8F\u5A93\u5A9D\u5BEA\u5BCD\u5BCB\u5BD4\u5BD1\u5BCA\u5BCE\u5C0C\u5C30\u5D37\u5D43\u5D6B\u5D41\u5D4B\u5D3F\u5D35\u5D51\u5D4E\u5D55\u5D33\u5D3A\u5D52\u5D3D\u5D31\u5D59\u5D42\u5D39\u5D49\u5D38\u5D3C\u5D32\u5D36\u5D40\u5D45\u5E44\u5E41\u5F58\u5FA6\u5FA5\u5FAB\u60C9\u60B9\u60CC\u60E2\u60CE\u60C4\u6114"],
      ["d940", "\u60F2\u610A\u6116\u6105\u60F5\u6113\u60F8\u60FC\u60FE\u60C1\u6103\u6118\u611D\u6110\u60FF\u6104\u610B\u624A\u6394\u63B1\u63B0\u63CE\u63E5\u63E8\u63EF\u63C3\u649D\u63F3\u63CA\u63E0\u63F6\u63D5\u63F2\u63F5\u6461\u63DF\u63BE\u63DD\u63DC\u63C4\u63D8\u63D3\u63C2\u63C7\u63CC\u63CB\u63C8\u63F0\u63D7\u63D9\u6532\u6567\u656A\u6564\u655C\u6568\u6565\u658C\u659D\u659E\u65AE\u65D0\u65D2"],
      ["d9a1", "\u667C\u666C\u667B\u6680\u6671\u6679\u666A\u6672\u6701\u690C\u68D3\u6904\u68DC\u692A\u68EC\u68EA\u68F1\u690F\u68D6\u68F7\u68EB\u68E4\u68F6\u6913\u6910\u68F3\u68E1\u6907\u68CC\u6908\u6970\u68B4\u6911\u68EF\u68C6\u6914\u68F8\u68D0\u68FD\u68FC\u68E8\u690B\u690A\u6917\u68CE\u68C8\u68DD\u68DE\u68E6\u68F4\u68D1\u6906\u68D4\u68E9\u6915\u6925\u68C7\u6B39\u6B3B\u6B3F\u6B3C\u6B94\u6B97\u6B99\u6B95\u6BBD\u6BF0\u6BF2\u6BF3\u6C30\u6DFC\u6E46\u6E47\u6E1F\u6E49\u6E88\u6E3C\u6E3D\u6E45\u6E62\u6E2B\u6E3F\u6E41\u6E5D\u6E73\u6E1C\u6E33\u6E4B\u6E40\u6E51\u6E3B\u6E03\u6E2E\u6E5E"],
      ["da40", "\u6E68\u6E5C\u6E61\u6E31\u6E28\u6E60\u6E71\u6E6B\u6E39\u6E22\u6E30\u6E53\u6E65\u6E27\u6E78\u6E64\u6E77\u6E55\u6E79\u6E52\u6E66\u6E35\u6E36\u6E5A\u7120\u711E\u712F\u70FB\u712E\u7131\u7123\u7125\u7122\u7132\u711F\u7128\u713A\u711B\u724B\u725A\u7288\u7289\u7286\u7285\u728B\u7312\u730B\u7330\u7322\u7331\u7333\u7327\u7332\u732D\u7326\u7323\u7335\u730C\u742E\u742C\u7430\u742B\u7416"],
      ["daa1", "\u741A\u7421\u742D\u7431\u7424\u7423\u741D\u7429\u7420\u7432\u74FB\u752F\u756F\u756C\u75E7\u75DA\u75E1\u75E6\u75DD\u75DF\u75E4\u75D7\u7695\u7692\u76DA\u7746\u7747\u7744\u774D\u7745\u774A\u774E\u774B\u774C\u77DE\u77EC\u7860\u7864\u7865\u785C\u786D\u7871\u786A\u786E\u7870\u7869\u7868\u785E\u7862\u7974\u7973\u7972\u7970\u7A02\u7A0A\u7A03\u7A0C\u7A04\u7A99\u7AE6\u7AE4\u7B4A\u7B3B\u7B44\u7B48\u7B4C\u7B4E\u7B40\u7B58\u7B45\u7CA2\u7C9E\u7CA8\u7CA1\u7D58\u7D6F\u7D63\u7D53\u7D56\u7D67\u7D6A\u7D4F\u7D6D\u7D5C\u7D6B\u7D52\u7D54\u7D69\u7D51\u7D5F\u7D4E\u7F3E\u7F3F\u7F65"],
      ["db40", "\u7F66\u7FA2\u7FA0\u7FA1\u7FD7\u8051\u804F\u8050\u80FE\u80D4\u8143\u814A\u8152\u814F\u8147\u813D\u814D\u813A\u81E6\u81EE\u81F7\u81F8\u81F9\u8204\u823C\u823D\u823F\u8275\u833B\u83CF\u83F9\u8423\u83C0\u83E8\u8412\u83E7\u83E4\u83FC\u83F6\u8410\u83C6\u83C8\u83EB\u83E3\u83BF\u8401\u83DD\u83E5\u83D8\u83FF\u83E1\u83CB\u83CE\u83D6\u83F5\u83C9\u8409\u840F\u83DE\u8411\u8406\u83C2\u83F3"],
      ["dba1", "\u83D5\u83FA\u83C7\u83D1\u83EA\u8413\u83C3\u83EC\u83EE\u83C4\u83FB\u83D7\u83E2\u841B\u83DB\u83FE\u86D8\u86E2\u86E6\u86D3\u86E3\u86DA\u86EA\u86DD\u86EB\u86DC\u86EC\u86E9\u86D7\u86E8\u86D1\u8848\u8856\u8855\u88BA\u88D7\u88B9\u88B8\u88C0\u88BE\u88B6\u88BC\u88B7\u88BD\u88B2\u8901\u88C9\u8995\u8998\u8997\u89DD\u89DA\u89DB\u8A4E\u8A4D\u8A39\u8A59\u8A40\u8A57\u8A58\u8A44\u8A45\u8A52\u8A48\u8A51\u8A4A\u8A4C\u8A4F\u8C5F\u8C81\u8C80\u8CBA\u8CBE\u8CB0\u8CB9\u8CB5\u8D84\u8D80\u8D89\u8DD8\u8DD3\u8DCD\u8DC7\u8DD6\u8DDC\u8DCF\u8DD5\u8DD9\u8DC8\u8DD7\u8DC5\u8EEF\u8EF7\u8EFA"],
      ["dc40", "\u8EF9\u8EE6\u8EEE\u8EE5\u8EF5\u8EE7\u8EE8\u8EF6\u8EEB\u8EF1\u8EEC\u8EF4\u8EE9\u902D\u9034\u902F\u9106\u912C\u9104\u90FF\u90FC\u9108\u90F9\u90FB\u9101\u9100\u9107\u9105\u9103\u9161\u9164\u915F\u9162\u9160\u9201\u920A\u9225\u9203\u921A\u9226\u920F\u920C\u9200\u9212\u91FF\u91FD\u9206\u9204\u9227\u9202\u921C\u9224\u9219\u9217\u9205\u9216\u957B\u958D\u958C\u9590\u9687\u967E\u9688"],
      ["dca1", "\u9689\u9683\u9680\u96C2\u96C8\u96C3\u96F1\u96F0\u976C\u9770\u976E\u9807\u98A9\u98EB\u9CE6\u9EF9\u4E83\u4E84\u4EB6\u50BD\u50BF\u50C6\u50AE\u50C4\u50CA\u50B4\u50C8\u50C2\u50B0\u50C1\u50BA\u50B1\u50CB\u50C9\u50B6\u50B8\u51D7\u527A\u5278\u527B\u527C\u55C3\u55DB\u55CC\u55D0\u55CB\u55CA\u55DD\u55C0\u55D4\u55C4\u55E9\u55BF\u55D2\u558D\u55CF\u55D5\u55E2\u55D6\u55C8\u55F2\u55CD\u55D9\u55C2\u5714\u5853\u5868\u5864\u584F\u584D\u5849\u586F\u5855\u584E\u585D\u5859\u5865\u585B\u583D\u5863\u5871\u58FC\u5AC7\u5AC4\u5ACB\u5ABA\u5AB8\u5AB1\u5AB5\u5AB0\u5ABF\u5AC8\u5ABB\u5AC6"],
      ["dd40", "\u5AB7\u5AC0\u5ACA\u5AB4\u5AB6\u5ACD\u5AB9\u5A90\u5BD6\u5BD8\u5BD9\u5C1F\u5C33\u5D71\u5D63\u5D4A\u5D65\u5D72\u5D6C\u5D5E\u5D68\u5D67\u5D62\u5DF0\u5E4F\u5E4E\u5E4A\u5E4D\u5E4B\u5EC5\u5ECC\u5EC6\u5ECB\u5EC7\u5F40\u5FAF\u5FAD\u60F7\u6149\u614A\u612B\u6145\u6136\u6132\u612E\u6146\u612F\u614F\u6129\u6140\u6220\u9168\u6223\u6225\u6224\u63C5\u63F1\u63EB\u6410\u6412\u6409\u6420\u6424"],
      ["dda1", "\u6433\u6443\u641F\u6415\u6418\u6439\u6437\u6422\u6423\u640C\u6426\u6430\u6428\u6441\u6435\u642F\u640A\u641A\u6440\u6425\u6427\u640B\u63E7\u641B\u642E\u6421\u640E\u656F\u6592\u65D3\u6686\u668C\u6695\u6690\u668B\u668A\u6699\u6694\u6678\u6720\u6966\u695F\u6938\u694E\u6962\u6971\u693F\u6945\u696A\u6939\u6942\u6957\u6959\u697A\u6948\u6949\u6935\u696C\u6933\u693D\u6965\u68F0\u6978\u6934\u6969\u6940\u696F\u6944\u6976\u6958\u6941\u6974\u694C\u693B\u694B\u6937\u695C\u694F\u6951\u6932\u6952\u692F\u697B\u693C\u6B46\u6B45\u6B43\u6B42\u6B48\u6B41\u6B9B\uFA0D\u6BFB\u6BFC"],
      ["de40", "\u6BF9\u6BF7\u6BF8\u6E9B\u6ED6\u6EC8\u6E8F\u6EC0\u6E9F\u6E93\u6E94\u6EA0\u6EB1\u6EB9\u6EC6\u6ED2\u6EBD\u6EC1\u6E9E\u6EC9\u6EB7\u6EB0\u6ECD\u6EA6\u6ECF\u6EB2\u6EBE\u6EC3\u6EDC\u6ED8\u6E99\u6E92\u6E8E\u6E8D\u6EA4\u6EA1\u6EBF\u6EB3\u6ED0\u6ECA\u6E97\u6EAE\u6EA3\u7147\u7154\u7152\u7163\u7160\u7141\u715D\u7162\u7172\u7178\u716A\u7161\u7142\u7158\u7143\u714B\u7170\u715F\u7150\u7153"],
      ["dea1", "\u7144\u714D\u715A\u724F\u728D\u728C\u7291\u7290\u728E\u733C\u7342\u733B\u733A\u7340\u734A\u7349\u7444\u744A\u744B\u7452\u7451\u7457\u7440\u744F\u7450\u744E\u7442\u7446\u744D\u7454\u74E1\u74FF\u74FE\u74FD\u751D\u7579\u7577\u6983\u75EF\u760F\u7603\u75F7\u75FE\u75FC\u75F9\u75F8\u7610\u75FB\u75F6\u75ED\u75F5\u75FD\u7699\u76B5\u76DD\u7755\u775F\u7760\u7752\u7756\u775A\u7769\u7767\u7754\u7759\u776D\u77E0\u7887\u789A\u7894\u788F\u7884\u7895\u7885\u7886\u78A1\u7883\u7879\u7899\u7880\u7896\u787B\u797C\u7982\u797D\u7979\u7A11\u7A18\u7A19\u7A12\u7A17\u7A15\u7A22\u7A13"],
      ["df40", "\u7A1B\u7A10\u7AA3\u7AA2\u7A9E\u7AEB\u7B66\u7B64\u7B6D\u7B74\u7B69\u7B72\u7B65\u7B73\u7B71\u7B70\u7B61\u7B78\u7B76\u7B63\u7CB2\u7CB4\u7CAF\u7D88\u7D86\u7D80\u7D8D\u7D7F\u7D85\u7D7A\u7D8E\u7D7B\u7D83\u7D7C\u7D8C\u7D94\u7D84\u7D7D\u7D92\u7F6D\u7F6B\u7F67\u7F68\u7F6C\u7FA6\u7FA5\u7FA7\u7FDB\u7FDC\u8021\u8164\u8160\u8177\u815C\u8169\u815B\u8162\u8172\u6721\u815E\u8176\u8167\u816F"],
      ["dfa1", "\u8144\u8161\u821D\u8249\u8244\u8240\u8242\u8245\u84F1\u843F\u8456\u8476\u8479\u848F\u848D\u8465\u8451\u8440\u8486\u8467\u8430\u844D\u847D\u845A\u8459\u8474\u8473\u845D\u8507\u845E\u8437\u843A\u8434\u847A\u8443\u8478\u8432\u8445\u8429\u83D9\u844B\u842F\u8442\u842D\u845F\u8470\u8439\u844E\u844C\u8452\u846F\u84C5\u848E\u843B\u8447\u8436\u8433\u8468\u847E\u8444\u842B\u8460\u8454\u846E\u8450\u870B\u8704\u86F7\u870C\u86FA\u86D6\u86F5\u874D\u86F8\u870E\u8709\u8701\u86F6\u870D\u8705\u88D6\u88CB\u88CD\u88CE\u88DE\u88DB\u88DA\u88CC\u88D0\u8985\u899B\u89DF\u89E5\u89E4"],
      ["e040", "\u89E1\u89E0\u89E2\u89DC\u89E6\u8A76\u8A86\u8A7F\u8A61\u8A3F\u8A77\u8A82\u8A84\u8A75\u8A83\u8A81\u8A74\u8A7A\u8C3C\u8C4B\u8C4A\u8C65\u8C64\u8C66\u8C86\u8C84\u8C85\u8CCC\u8D68\u8D69\u8D91\u8D8C\u8D8E\u8D8F\u8D8D\u8D93\u8D94\u8D90\u8D92\u8DF0\u8DE0\u8DEC\u8DF1\u8DEE\u8DD0\u8DE9\u8DE3\u8DE2\u8DE7\u8DF2\u8DEB\u8DF4\u8F06\u8EFF\u8F01\u8F00\u8F05\u8F07\u8F08\u8F02\u8F0B\u9052\u903F"],
      ["e0a1", "\u9044\u9049\u903D\u9110\u910D\u910F\u9111\u9116\u9114\u910B\u910E\u916E\u916F\u9248\u9252\u9230\u923A\u9266\u9233\u9265\u925E\u9283\u922E\u924A\u9246\u926D\u926C\u924F\u9260\u9267\u926F\u9236\u9261\u9270\u9231\u9254\u9263\u9250\u9272\u924E\u9253\u924C\u9256\u9232\u959F\u959C\u959E\u959B\u9692\u9693\u9691\u9697\u96CE\u96FA\u96FD\u96F8\u96F5\u9773\u9777\u9778\u9772\u980F\u980D\u980E\u98AC\u98F6\u98F9\u99AF\u99B2\u99B0\u99B5\u9AAD\u9AAB\u9B5B\u9CEA\u9CED\u9CE7\u9E80\u9EFD\u50E6\u50D4\u50D7\u50E8\u50F3\u50DB\u50EA\u50DD\u50E4\u50D3\u50EC\u50F0\u50EF\u50E3\u50E0"],
      ["e140", "\u51D8\u5280\u5281\u52E9\u52EB\u5330\u53AC\u5627\u5615\u560C\u5612\u55FC\u560F\u561C\u5601\u5613\u5602\u55FA\u561D\u5604\u55FF\u55F9\u5889\u587C\u5890\u5898\u5886\u5881\u587F\u5874\u588B\u587A\u5887\u5891\u588E\u5876\u5882\u5888\u587B\u5894\u588F\u58FE\u596B\u5ADC\u5AEE\u5AE5\u5AD5\u5AEA\u5ADA\u5AED\u5AEB\u5AF3\u5AE2\u5AE0\u5ADB\u5AEC\u5ADE\u5ADD\u5AD9\u5AE8\u5ADF\u5B77\u5BE0"],
      ["e1a1", "\u5BE3\u5C63\u5D82\u5D80\u5D7D\u5D86\u5D7A\u5D81\u5D77\u5D8A\u5D89\u5D88\u5D7E\u5D7C\u5D8D\u5D79\u5D7F\u5E58\u5E59\u5E53\u5ED8\u5ED1\u5ED7\u5ECE\u5EDC\u5ED5\u5ED9\u5ED2\u5ED4\u5F44\u5F43\u5F6F\u5FB6\u612C\u6128\u6141\u615E\u6171\u6173\u6152\u6153\u6172\u616C\u6180\u6174\u6154\u617A\u615B\u6165\u613B\u616A\u6161\u6156\u6229\u6227\u622B\u642B\u644D\u645B\u645D\u6474\u6476\u6472\u6473\u647D\u6475\u6466\u64A6\u644E\u6482\u645E\u645C\u644B\u6453\u6460\u6450\u647F\u643F\u646C\u646B\u6459\u6465\u6477\u6573\u65A0\u66A1\u66A0\u669F\u6705\u6704\u6722\u69B1\u69B6\u69C9"],
      ["e240", "\u69A0\u69CE\u6996\u69B0\u69AC\u69BC\u6991\u6999\u698E\u69A7\u698D\u69A9\u69BE\u69AF\u69BF\u69C4\u69BD\u69A4\u69D4\u69B9\u69CA\u699A\u69CF\u69B3\u6993\u69AA\u69A1\u699E\u69D9\u6997\u6990\u69C2\u69B5\u69A5\u69C6\u6B4A\u6B4D\u6B4B\u6B9E\u6B9F\u6BA0\u6BC3\u6BC4\u6BFE\u6ECE\u6EF5\u6EF1\u6F03\u6F25\u6EF8\u6F37\u6EFB\u6F2E\u6F09\u6F4E\u6F19\u6F1A\u6F27\u6F18\u6F3B\u6F12\u6EED\u6F0A"],
      ["e2a1", "\u6F36\u6F73\u6EF9\u6EEE\u6F2D\u6F40\u6F30\u6F3C\u6F35\u6EEB\u6F07\u6F0E\u6F43\u6F05\u6EFD\u6EF6\u6F39\u6F1C\u6EFC\u6F3A\u6F1F\u6F0D\u6F1E\u6F08\u6F21\u7187\u7190\u7189\u7180\u7185\u7182\u718F\u717B\u7186\u7181\u7197\u7244\u7253\u7297\u7295\u7293\u7343\u734D\u7351\u734C\u7462\u7473\u7471\u7475\u7472\u7467\u746E\u7500\u7502\u7503\u757D\u7590\u7616\u7608\u760C\u7615\u7611\u760A\u7614\u76B8\u7781\u777C\u7785\u7782\u776E\u7780\u776F\u777E\u7783\u78B2\u78AA\u78B4\u78AD\u78A8\u787E\u78AB\u789E\u78A5\u78A0\u78AC\u78A2\u78A4\u7998\u798A\u798B\u7996\u7995\u7994\u7993"],
      ["e340", "\u7997\u7988\u7992\u7990\u7A2B\u7A4A\u7A30\u7A2F\u7A28\u7A26\u7AA8\u7AAB\u7AAC\u7AEE\u7B88\u7B9C\u7B8A\u7B91\u7B90\u7B96\u7B8D\u7B8C\u7B9B\u7B8E\u7B85\u7B98\u5284\u7B99\u7BA4\u7B82\u7CBB\u7CBF\u7CBC\u7CBA\u7DA7\u7DB7\u7DC2\u7DA3\u7DAA\u7DC1\u7DC0\u7DC5\u7D9D\u7DCE\u7DC4\u7DC6\u7DCB\u7DCC\u7DAF\u7DB9\u7D96\u7DBC\u7D9F\u7DA6\u7DAE\u7DA9\u7DA1\u7DC9\u7F73\u7FE2\u7FE3\u7FE5\u7FDE"],
      ["e3a1", "\u8024\u805D\u805C\u8189\u8186\u8183\u8187\u818D\u818C\u818B\u8215\u8497\u84A4\u84A1\u849F\u84BA\u84CE\u84C2\u84AC\u84AE\u84AB\u84B9\u84B4\u84C1\u84CD\u84AA\u849A\u84B1\u84D0\u849D\u84A7\u84BB\u84A2\u8494\u84C7\u84CC\u849B\u84A9\u84AF\u84A8\u84D6\u8498\u84B6\u84CF\u84A0\u84D7\u84D4\u84D2\u84DB\u84B0\u8491\u8661\u8733\u8723\u8728\u876B\u8740\u872E\u871E\u8721\u8719\u871B\u8743\u872C\u8741\u873E\u8746\u8720\u8732\u872A\u872D\u873C\u8712\u873A\u8731\u8735\u8742\u8726\u8727\u8738\u8724\u871A\u8730\u8711\u88F7\u88E7\u88F1\u88F2\u88FA\u88FE\u88EE\u88FC\u88F6\u88FB"],
      ["e440", "\u88F0\u88EC\u88EB\u899D\u89A1\u899F\u899E\u89E9\u89EB\u89E8\u8AAB\u8A99\u8A8B\u8A92\u8A8F\u8A96\u8C3D\u8C68\u8C69\u8CD5\u8CCF\u8CD7\u8D96\u8E09\u8E02\u8DFF\u8E0D\u8DFD\u8E0A\u8E03\u8E07\u8E06\u8E05\u8DFE\u8E00\u8E04\u8F10\u8F11\u8F0E\u8F0D\u9123\u911C\u9120\u9122\u911F\u911D\u911A\u9124\u9121\u911B\u917A\u9172\u9179\u9173\u92A5\u92A4\u9276\u929B\u927A\u92A0\u9294\u92AA\u928D"],
      ["e4a1", "\u92A6\u929A\u92AB\u9279\u9297\u927F\u92A3\u92EE\u928E\u9282\u9295\u92A2\u927D\u9288\u92A1\u928A\u9286\u928C\u9299\u92A7\u927E\u9287\u92A9\u929D\u928B\u922D\u969E\u96A1\u96FF\u9758\u977D\u977A\u977E\u9783\u9780\u9782\u977B\u9784\u9781\u977F\u97CE\u97CD\u9816\u98AD\u98AE\u9902\u9900\u9907\u999D\u999C\u99C3\u99B9\u99BB\u99BA\u99C2\u99BD\u99C7\u9AB1\u9AE3\u9AE7\u9B3E\u9B3F\u9B60\u9B61\u9B5F\u9CF1\u9CF2\u9CF5\u9EA7\u50FF\u5103\u5130\u50F8\u5106\u5107\u50F6\u50FE\u510B\u510C\u50FD\u510A\u528B\u528C\u52F1\u52EF\u5648\u5642\u564C\u5635\u5641\u564A\u5649\u5646\u5658"],
      ["e540", "\u565A\u5640\u5633\u563D\u562C\u563E\u5638\u562A\u563A\u571A\u58AB\u589D\u58B1\u58A0\u58A3\u58AF\u58AC\u58A5\u58A1\u58FF\u5AFF\u5AF4\u5AFD\u5AF7\u5AF6\u5B03\u5AF8\u5B02\u5AF9\u5B01\u5B07\u5B05\u5B0F\u5C67\u5D99\u5D97\u5D9F\u5D92\u5DA2\u5D93\u5D95\u5DA0\u5D9C\u5DA1\u5D9A\u5D9E\u5E69\u5E5D\u5E60\u5E5C\u7DF3\u5EDB\u5EDE\u5EE1\u5F49\u5FB2\u618B\u6183\u6179\u61B1\u61B0\u61A2\u6189"],
      ["e5a1", "\u619B\u6193\u61AF\u61AD\u619F\u6192\u61AA\u61A1\u618D\u6166\u61B3\u622D\u646E\u6470\u6496\u64A0\u6485\u6497\u649C\u648F\u648B\u648A\u648C\u64A3\u649F\u6468\u64B1\u6498\u6576\u657A\u6579\u657B\u65B2\u65B3\u66B5\u66B0\u66A9\u66B2\u66B7\u66AA\u66AF\u6A00\u6A06\u6A17\u69E5\u69F8\u6A15\u69F1\u69E4\u6A20\u69FF\u69EC\u69E2\u6A1B\u6A1D\u69FE\u6A27\u69F2\u69EE\u6A14\u69F7\u69E7\u6A40\u6A08\u69E6\u69FB\u6A0D\u69FC\u69EB\u6A09\u6A04\u6A18\u6A25\u6A0F\u69F6\u6A26\u6A07\u69F4\u6A16\u6B51\u6BA5\u6BA3\u6BA2\u6BA6\u6C01\u6C00\u6BFF\u6C02\u6F41\u6F26\u6F7E\u6F87\u6FC6\u6F92"],
      ["e640", "\u6F8D\u6F89\u6F8C\u6F62\u6F4F\u6F85\u6F5A\u6F96\u6F76\u6F6C\u6F82\u6F55\u6F72\u6F52\u6F50\u6F57\u6F94\u6F93\u6F5D\u6F00\u6F61\u6F6B\u6F7D\u6F67\u6F90\u6F53\u6F8B\u6F69\u6F7F\u6F95\u6F63\u6F77\u6F6A\u6F7B\u71B2\u71AF\u719B\u71B0\u71A0\u719A\u71A9\u71B5\u719D\u71A5\u719E\u71A4\u71A1\u71AA\u719C\u71A7\u71B3\u7298\u729A\u7358\u7352\u735E\u735F\u7360\u735D\u735B\u7361\u735A\u7359"],
      ["e6a1", "\u7362\u7487\u7489\u748A\u7486\u7481\u747D\u7485\u7488\u747C\u7479\u7508\u7507\u757E\u7625\u761E\u7619\u761D\u761C\u7623\u761A\u7628\u761B\u769C\u769D\u769E\u769B\u778D\u778F\u7789\u7788\u78CD\u78BB\u78CF\u78CC\u78D1\u78CE\u78D4\u78C8\u78C3\u78C4\u78C9\u799A\u79A1\u79A0\u799C\u79A2\u799B\u6B76\u7A39\u7AB2\u7AB4\u7AB3\u7BB7\u7BCB\u7BBE\u7BAC\u7BCE\u7BAF\u7BB9\u7BCA\u7BB5\u7CC5\u7CC8\u7CCC\u7CCB\u7DF7\u7DDB\u7DEA\u7DE7\u7DD7\u7DE1\u7E03\u7DFA\u7DE6\u7DF6\u7DF1\u7DF0\u7DEE\u7DDF\u7F76\u7FAC\u7FB0\u7FAD\u7FED\u7FEB\u7FEA\u7FEC\u7FE6\u7FE8\u8064\u8067\u81A3\u819F"],
      ["e740", "\u819E\u8195\u81A2\u8199\u8197\u8216\u824F\u8253\u8252\u8250\u824E\u8251\u8524\u853B\u850F\u8500\u8529\u850E\u8509\u850D\u851F\u850A\u8527\u851C\u84FB\u852B\u84FA\u8508\u850C\u84F4\u852A\u84F2\u8515\u84F7\u84EB\u84F3\u84FC\u8512\u84EA\u84E9\u8516\u84FE\u8528\u851D\u852E\u8502\u84FD\u851E\u84F6\u8531\u8526\u84E7\u84E8\u84F0\u84EF\u84F9\u8518\u8520\u8530\u850B\u8519\u852F\u8662"],
      ["e7a1", "\u8756\u8763\u8764\u8777\u87E1\u8773\u8758\u8754\u875B\u8752\u8761\u875A\u8751\u875E\u876D\u876A\u8750\u874E\u875F\u875D\u876F\u876C\u877A\u876E\u875C\u8765\u874F\u877B\u8775\u8762\u8767\u8769\u885A\u8905\u890C\u8914\u890B\u8917\u8918\u8919\u8906\u8916\u8911\u890E\u8909\u89A2\u89A4\u89A3\u89ED\u89F0\u89EC\u8ACF\u8AC6\u8AB8\u8AD3\u8AD1\u8AD4\u8AD5\u8ABB\u8AD7\u8ABE\u8AC0\u8AC5\u8AD8\u8AC3\u8ABA\u8ABD\u8AD9\u8C3E\u8C4D\u8C8F\u8CE5\u8CDF\u8CD9\u8CE8\u8CDA\u8CDD\u8CE7\u8DA0\u8D9C\u8DA1\u8D9B\u8E20\u8E23\u8E25\u8E24\u8E2E\u8E15\u8E1B\u8E16\u8E11\u8E19\u8E26\u8E27"],
      ["e840", "\u8E14\u8E12\u8E18\u8E13\u8E1C\u8E17\u8E1A\u8F2C\u8F24\u8F18\u8F1A\u8F20\u8F23\u8F16\u8F17\u9073\u9070\u906F\u9067\u906B\u912F\u912B\u9129\u912A\u9132\u9126\u912E\u9185\u9186\u918A\u9181\u9182\u9184\u9180\u92D0\u92C3\u92C4\u92C0\u92D9\u92B6\u92CF\u92F1\u92DF\u92D8\u92E9\u92D7\u92DD\u92CC\u92EF\u92C2\u92E8\u92CA\u92C8\u92CE\u92E6\u92CD\u92D5\u92C9\u92E0\u92DE\u92E7\u92D1\u92D3"],
      ["e8a1", "\u92B5\u92E1\u92C6\u92B4\u957C\u95AC\u95AB\u95AE\u95B0\u96A4\u96A2\u96D3\u9705\u9708\u9702\u975A\u978A\u978E\u9788\u97D0\u97CF\u981E\u981D\u9826\u9829\u9828\u9820\u981B\u9827\u98B2\u9908\u98FA\u9911\u9914\u9916\u9917\u9915\u99DC\u99CD\u99CF\u99D3\u99D4\u99CE\u99C9\u99D6\u99D8\u99CB\u99D7\u99CC\u9AB3\u9AEC\u9AEB\u9AF3\u9AF2\u9AF1\u9B46\u9B43\u9B67\u9B74\u9B71\u9B66\u9B76\u9B75\u9B70\u9B68\u9B64\u9B6C\u9CFC\u9CFA\u9CFD\u9CFF\u9CF7\u9D07\u9D00\u9CF9\u9CFB\u9D08\u9D05\u9D04\u9E83\u9ED3\u9F0F\u9F10\u511C\u5113\u5117\u511A\u5111\u51DE\u5334\u53E1\u5670\u5660\u566E"],
      ["e940", "\u5673\u5666\u5663\u566D\u5672\u565E\u5677\u571C\u571B\u58C8\u58BD\u58C9\u58BF\u58BA\u58C2\u58BC\u58C6\u5B17\u5B19\u5B1B\u5B21\u5B14\u5B13\u5B10\u5B16\u5B28\u5B1A\u5B20\u5B1E\u5BEF\u5DAC\u5DB1\u5DA9\u5DA7\u5DB5\u5DB0\u5DAE\u5DAA\u5DA8\u5DB2\u5DAD\u5DAF\u5DB4\u5E67\u5E68\u5E66\u5E6F\u5EE9\u5EE7\u5EE6\u5EE8\u5EE5\u5F4B\u5FBC\u619D\u61A8\u6196\u61C5\u61B4\u61C6\u61C1\u61CC\u61BA"],
      ["e9a1", "\u61BF\u61B8\u618C\u64D7\u64D6\u64D0\u64CF\u64C9\u64BD\u6489\u64C3\u64DB\u64F3\u64D9\u6533\u657F\u657C\u65A2\u66C8\u66BE\u66C0\u66CA\u66CB\u66CF\u66BD\u66BB\u66BA\u66CC\u6723\u6A34\u6A66\u6A49\u6A67\u6A32\u6A68\u6A3E\u6A5D\u6A6D\u6A76\u6A5B\u6A51\u6A28\u6A5A\u6A3B\u6A3F\u6A41\u6A6A\u6A64\u6A50\u6A4F\u6A54\u6A6F\u6A69\u6A60\u6A3C\u6A5E\u6A56\u6A55\u6A4D\u6A4E\u6A46\u6B55\u6B54\u6B56\u6BA7\u6BAA\u6BAB\u6BC8\u6BC7\u6C04\u6C03\u6C06\u6FAD\u6FCB\u6FA3\u6FC7\u6FBC\u6FCE\u6FC8\u6F5E\u6FC4\u6FBD\u6F9E\u6FCA\u6FA8\u7004\u6FA5\u6FAE\u6FBA\u6FAC\u6FAA\u6FCF\u6FBF\u6FB8"],
      ["ea40", "\u6FA2\u6FC9\u6FAB\u6FCD\u6FAF\u6FB2\u6FB0\u71C5\u71C2\u71BF\u71B8\u71D6\u71C0\u71C1\u71CB\u71D4\u71CA\u71C7\u71CF\u71BD\u71D8\u71BC\u71C6\u71DA\u71DB\u729D\u729E\u7369\u7366\u7367\u736C\u7365\u736B\u736A\u747F\u749A\u74A0\u7494\u7492\u7495\u74A1\u750B\u7580\u762F\u762D\u7631\u763D\u7633\u763C\u7635\u7632\u7630\u76BB\u76E6\u779A\u779D\u77A1\u779C\u779B\u77A2\u77A3\u7795\u7799"],
      ["eaa1", "\u7797\u78DD\u78E9\u78E5\u78EA\u78DE\u78E3\u78DB\u78E1\u78E2\u78ED\u78DF\u78E0\u79A4\u7A44\u7A48\u7A47\u7AB6\u7AB8\u7AB5\u7AB1\u7AB7\u7BDE\u7BE3\u7BE7\u7BDD\u7BD5\u7BE5\u7BDA\u7BE8\u7BF9\u7BD4\u7BEA\u7BE2\u7BDC\u7BEB\u7BD8\u7BDF\u7CD2\u7CD4\u7CD7\u7CD0\u7CD1\u7E12\u7E21\u7E17\u7E0C\u7E1F\u7E20\u7E13\u7E0E\u7E1C\u7E15\u7E1A\u7E22\u7E0B\u7E0F\u7E16\u7E0D\u7E14\u7E25\u7E24\u7F43\u7F7B\u7F7C\u7F7A\u7FB1\u7FEF\u802A\u8029\u806C\u81B1\u81A6\u81AE\u81B9\u81B5\u81AB\u81B0\u81AC\u81B4\u81B2\u81B7\u81A7\u81F2\u8255\u8256\u8257\u8556\u8545\u856B\u854D\u8553\u8561\u8558"],
      ["eb40", "\u8540\u8546\u8564\u8541\u8562\u8544\u8551\u8547\u8563\u853E\u855B\u8571\u854E\u856E\u8575\u8555\u8567\u8560\u858C\u8566\u855D\u8554\u8565\u856C\u8663\u8665\u8664\u879B\u878F\u8797\u8793\u8792\u8788\u8781\u8796\u8798\u8779\u8787\u87A3\u8785\u8790\u8791\u879D\u8784\u8794\u879C\u879A\u8789\u891E\u8926\u8930\u892D\u892E\u8927\u8931\u8922\u8929\u8923\u892F\u892C\u891F\u89F1\u8AE0"],
      ["eba1", "\u8AE2\u8AF2\u8AF4\u8AF5\u8ADD\u8B14\u8AE4\u8ADF\u8AF0\u8AC8\u8ADE\u8AE1\u8AE8\u8AFF\u8AEF\u8AFB\u8C91\u8C92\u8C90\u8CF5\u8CEE\u8CF1\u8CF0\u8CF3\u8D6C\u8D6E\u8DA5\u8DA7\u8E33\u8E3E\u8E38\u8E40\u8E45\u8E36\u8E3C\u8E3D\u8E41\u8E30\u8E3F\u8EBD\u8F36\u8F2E\u8F35\u8F32\u8F39\u8F37\u8F34\u9076\u9079\u907B\u9086\u90FA\u9133\u9135\u9136\u9193\u9190\u9191\u918D\u918F\u9327\u931E\u9308\u931F\u9306\u930F\u937A\u9338\u933C\u931B\u9323\u9312\u9301\u9346\u932D\u930E\u930D\u92CB\u931D\u92FA\u9325\u9313\u92F9\u92F7\u9334\u9302\u9324\u92FF\u9329\u9339\u9335\u932A\u9314\u930C"],
      ["ec40", "\u930B\u92FE\u9309\u9300\u92FB\u9316\u95BC\u95CD\u95BE\u95B9\u95BA\u95B6\u95BF\u95B5\u95BD\u96A9\u96D4\u970B\u9712\u9710\u9799\u9797\u9794\u97F0\u97F8\u9835\u982F\u9832\u9924\u991F\u9927\u9929\u999E\u99EE\u99EC\u99E5\u99E4\u99F0\u99E3\u99EA\u99E9\u99E7\u9AB9\u9ABF\u9AB4\u9ABB\u9AF6\u9AFA\u9AF9\u9AF7\u9B33\u9B80\u9B85\u9B87\u9B7C\u9B7E\u9B7B\u9B82\u9B93\u9B92\u9B90\u9B7A\u9B95"],
      ["eca1", "\u9B7D\u9B88\u9D25\u9D17\u9D20\u9D1E\u9D14\u9D29\u9D1D\u9D18\u9D22\u9D10\u9D19\u9D1F\u9E88\u9E86\u9E87\u9EAE\u9EAD\u9ED5\u9ED6\u9EFA\u9F12\u9F3D\u5126\u5125\u5122\u5124\u5120\u5129\u52F4\u5693\u568C\u568D\u5686\u5684\u5683\u567E\u5682\u567F\u5681\u58D6\u58D4\u58CF\u58D2\u5B2D\u5B25\u5B32\u5B23\u5B2C\u5B27\u5B26\u5B2F\u5B2E\u5B7B\u5BF1\u5BF2\u5DB7\u5E6C\u5E6A\u5FBE\u5FBB\u61C3\u61B5\u61BC\u61E7\u61E0\u61E5\u61E4\u61E8\u61DE\u64EF\u64E9\u64E3\u64EB\u64E4\u64E8\u6581\u6580\u65B6\u65DA\u66D2\u6A8D\u6A96\u6A81\u6AA5\u6A89\u6A9F\u6A9B\u6AA1\u6A9E\u6A87\u6A93\u6A8E"],
      ["ed40", "\u6A95\u6A83\u6AA8\u6AA4\u6A91\u6A7F\u6AA6\u6A9A\u6A85\u6A8C\u6A92\u6B5B\u6BAD\u6C09\u6FCC\u6FA9\u6FF4\u6FD4\u6FE3\u6FDC\u6FED\u6FE7\u6FE6\u6FDE\u6FF2\u6FDD\u6FE2\u6FE8\u71E1\u71F1\u71E8\u71F2\u71E4\u71F0\u71E2\u7373\u736E\u736F\u7497\u74B2\u74AB\u7490\u74AA\u74AD\u74B1\u74A5\u74AF\u7510\u7511\u7512\u750F\u7584\u7643\u7648\u7649\u7647\u76A4\u76E9\u77B5\u77AB\u77B2\u77B7\u77B6"],
      ["eda1", "\u77B4\u77B1\u77A8\u77F0\u78F3\u78FD\u7902\u78FB\u78FC\u78F2\u7905\u78F9\u78FE\u7904\u79AB\u79A8\u7A5C\u7A5B\u7A56\u7A58\u7A54\u7A5A\u7ABE\u7AC0\u7AC1\u7C05\u7C0F\u7BF2\u7C00\u7BFF\u7BFB\u7C0E\u7BF4\u7C0B\u7BF3\u7C02\u7C09\u7C03\u7C01\u7BF8\u7BFD\u7C06\u7BF0\u7BF1\u7C10\u7C0A\u7CE8\u7E2D\u7E3C\u7E42\u7E33\u9848\u7E38\u7E2A\u7E49\u7E40\u7E47\u7E29\u7E4C\u7E30\u7E3B\u7E36\u7E44\u7E3A\u7F45\u7F7F\u7F7E\u7F7D\u7FF4\u7FF2\u802C\u81BB\u81C4\u81CC\u81CA\u81C5\u81C7\u81BC\u81E9\u825B\u825A\u825C\u8583\u8580\u858F\u85A7\u8595\u85A0\u858B\u85A3\u857B\u85A4\u859A\u859E"],
      ["ee40", "\u8577\u857C\u8589\u85A1\u857A\u8578\u8557\u858E\u8596\u8586\u858D\u8599\u859D\u8581\u85A2\u8582\u8588\u8585\u8579\u8576\u8598\u8590\u859F\u8668\u87BE\u87AA\u87AD\u87C5\u87B0\u87AC\u87B9\u87B5\u87BC\u87AE\u87C9\u87C3\u87C2\u87CC\u87B7\u87AF\u87C4\u87CA\u87B4\u87B6\u87BF\u87B8\u87BD\u87DE\u87B2\u8935\u8933\u893C\u893E\u8941\u8952\u8937\u8942\u89AD\u89AF\u89AE\u89F2\u89F3\u8B1E"],
      ["eea1", "\u8B18\u8B16\u8B11\u8B05\u8B0B\u8B22\u8B0F\u8B12\u8B15\u8B07\u8B0D\u8B08\u8B06\u8B1C\u8B13\u8B1A\u8C4F\u8C70\u8C72\u8C71\u8C6F\u8C95\u8C94\u8CF9\u8D6F\u8E4E\u8E4D\u8E53\u8E50\u8E4C\u8E47\u8F43\u8F40\u9085\u907E\u9138\u919A\u91A2\u919B\u9199\u919F\u91A1\u919D\u91A0\u93A1\u9383\u93AF\u9364\u9356\u9347\u937C\u9358\u935C\u9376\u9349\u9350\u9351\u9360\u936D\u938F\u934C\u936A\u9379\u9357\u9355\u9352\u934F\u9371\u9377\u937B\u9361\u935E\u9363\u9367\u9380\u934E\u9359\u95C7\u95C0\u95C9\u95C3\u95C5\u95B7\u96AE\u96B0\u96AC\u9720\u971F\u9718\u971D\u9719\u979A\u97A1\u979C"],
      ["ef40", "\u979E\u979D\u97D5\u97D4\u97F1\u9841\u9844\u984A\u9849\u9845\u9843\u9925\u992B\u992C\u992A\u9933\u9932\u992F\u992D\u9931\u9930\u9998\u99A3\u99A1\u9A02\u99FA\u99F4\u99F7\u99F9\u99F8\u99F6\u99FB\u99FD\u99FE\u99FC\u9A03\u9ABE\u9AFE\u9AFD\u9B01\u9AFC\u9B48\u9B9A\u9BA8\u9B9E\u9B9B\u9BA6\u9BA1\u9BA5\u9BA4\u9B86\u9BA2\u9BA0\u9BAF\u9D33\u9D41\u9D67\u9D36\u9D2E\u9D2F\u9D31\u9D38\u9D30"],
      ["efa1", "\u9D45\u9D42\u9D43\u9D3E\u9D37\u9D40\u9D3D\u7FF5\u9D2D\u9E8A\u9E89\u9E8D\u9EB0\u9EC8\u9EDA\u9EFB\u9EFF\u9F24\u9F23\u9F22\u9F54\u9FA0\u5131\u512D\u512E\u5698\u569C\u5697\u569A\u569D\u5699\u5970\u5B3C\u5C69\u5C6A\u5DC0\u5E6D\u5E6E\u61D8\u61DF\u61ED\u61EE\u61F1\u61EA\u61F0\u61EB\u61D6\u61E9\u64FF\u6504\u64FD\u64F8\u6501\u6503\u64FC\u6594\u65DB\u66DA\u66DB\u66D8\u6AC5\u6AB9\u6ABD\u6AE1\u6AC6\u6ABA\u6AB6\u6AB7\u6AC7\u6AB4\u6AAD\u6B5E\u6BC9\u6C0B\u7007\u700C\u700D\u7001\u7005\u7014\u700E\u6FFF\u7000\u6FFB\u7026\u6FFC\u6FF7\u700A\u7201\u71FF\u71F9\u7203\u71FD\u7376"],
      ["f040", "\u74B8\u74C0\u74B5\u74C1\u74BE\u74B6\u74BB\u74C2\u7514\u7513\u765C\u7664\u7659\u7650\u7653\u7657\u765A\u76A6\u76BD\u76EC\u77C2\u77BA\u78FF\u790C\u7913\u7914\u7909\u7910\u7912\u7911\u79AD\u79AC\u7A5F\u7C1C\u7C29\u7C19\u7C20\u7C1F\u7C2D\u7C1D\u7C26\u7C28\u7C22\u7C25\u7C30\u7E5C\u7E50\u7E56\u7E63\u7E58\u7E62\u7E5F\u7E51\u7E60\u7E57\u7E53\u7FB5\u7FB3\u7FF7\u7FF8\u8075\u81D1\u81D2"],
      ["f0a1", "\u81D0\u825F\u825E\u85B4\u85C6\u85C0\u85C3\u85C2\u85B3\u85B5\u85BD\u85C7\u85C4\u85BF\u85CB\u85CE\u85C8\u85C5\u85B1\u85B6\u85D2\u8624\u85B8\u85B7\u85BE\u8669\u87E7\u87E6\u87E2\u87DB\u87EB\u87EA\u87E5\u87DF\u87F3\u87E4\u87D4\u87DC\u87D3\u87ED\u87D8\u87E3\u87A4\u87D7\u87D9\u8801\u87F4\u87E8\u87DD\u8953\u894B\u894F\u894C\u8946\u8950\u8951\u8949\u8B2A\u8B27\u8B23\u8B33\u8B30\u8B35\u8B47\u8B2F\u8B3C\u8B3E\u8B31\u8B25\u8B37\u8B26\u8B36\u8B2E\u8B24\u8B3B\u8B3D\u8B3A\u8C42\u8C75\u8C99\u8C98\u8C97\u8CFE\u8D04\u8D02\u8D00\u8E5C\u8E62\u8E60\u8E57\u8E56\u8E5E\u8E65\u8E67"],
      ["f140", "\u8E5B\u8E5A\u8E61\u8E5D\u8E69\u8E54\u8F46\u8F47\u8F48\u8F4B\u9128\u913A\u913B\u913E\u91A8\u91A5\u91A7\u91AF\u91AA\u93B5\u938C\u9392\u93B7\u939B\u939D\u9389\u93A7\u938E\u93AA\u939E\u93A6\u9395\u9388\u9399\u939F\u938D\u93B1\u9391\u93B2\u93A4\u93A8\u93B4\u93A3\u93A5\u95D2\u95D3\u95D1\u96B3\u96D7\u96DA\u5DC2\u96DF\u96D8\u96DD\u9723\u9722\u9725\u97AC\u97AE\u97A8\u97AB\u97A4\u97AA"],
      ["f1a1", "\u97A2\u97A5\u97D7\u97D9\u97D6\u97D8\u97FA\u9850\u9851\u9852\u98B8\u9941\u993C\u993A\u9A0F\u9A0B\u9A09\u9A0D\u9A04\u9A11\u9A0A\u9A05\u9A07\u9A06\u9AC0\u9ADC\u9B08\u9B04\u9B05\u9B29\u9B35\u9B4A\u9B4C\u9B4B\u9BC7\u9BC6\u9BC3\u9BBF\u9BC1\u9BB5\u9BB8\u9BD3\u9BB6\u9BC4\u9BB9\u9BBD\u9D5C\u9D53\u9D4F\u9D4A\u9D5B\u9D4B\u9D59\u9D56\u9D4C\u9D57\u9D52\u9D54\u9D5F\u9D58\u9D5A\u9E8E\u9E8C\u9EDF\u9F01\u9F00\u9F16\u9F25\u9F2B\u9F2A\u9F29\u9F28\u9F4C\u9F55\u5134\u5135\u5296\u52F7\u53B4\u56AB\u56AD\u56A6\u56A7\u56AA\u56AC\u58DA\u58DD\u58DB\u5912\u5B3D\u5B3E\u5B3F\u5DC3\u5E70"],
      ["f240", "\u5FBF\u61FB\u6507\u6510\u650D\u6509\u650C\u650E\u6584\u65DE\u65DD\u66DE\u6AE7\u6AE0\u6ACC\u6AD1\u6AD9\u6ACB\u6ADF\u6ADC\u6AD0\u6AEB\u6ACF\u6ACD\u6ADE\u6B60\u6BB0\u6C0C\u7019\u7027\u7020\u7016\u702B\u7021\u7022\u7023\u7029\u7017\u7024\u701C\u702A\u720C\u720A\u7207\u7202\u7205\u72A5\u72A6\u72A4\u72A3\u72A1\u74CB\u74C5\u74B7\u74C3\u7516\u7660\u77C9\u77CA\u77C4\u77F1\u791D\u791B"],
      ["f2a1", "\u7921\u791C\u7917\u791E\u79B0\u7A67\u7A68\u7C33\u7C3C\u7C39\u7C2C\u7C3B\u7CEC\u7CEA\u7E76\u7E75\u7E78\u7E70\u7E77\u7E6F\u7E7A\u7E72\u7E74\u7E68\u7F4B\u7F4A\u7F83\u7F86\u7FB7\u7FFD\u7FFE\u8078\u81D7\u81D5\u8264\u8261\u8263\u85EB\u85F1\u85ED\u85D9\u85E1\u85E8\u85DA\u85D7\u85EC\u85F2\u85F8\u85D8\u85DF\u85E3\u85DC\u85D1\u85F0\u85E6\u85EF\u85DE\u85E2\u8800\u87FA\u8803\u87F6\u87F7\u8809\u880C\u880B\u8806\u87FC\u8808\u87FF\u880A\u8802\u8962\u895A\u895B\u8957\u8961\u895C\u8958\u895D\u8959\u8988\u89B7\u89B6\u89F6\u8B50\u8B48\u8B4A\u8B40\u8B53\u8B56\u8B54\u8B4B\u8B55"],
      ["f340", "\u8B51\u8B42\u8B52\u8B57\u8C43\u8C77\u8C76\u8C9A\u8D06\u8D07\u8D09\u8DAC\u8DAA\u8DAD\u8DAB\u8E6D\u8E78\u8E73\u8E6A\u8E6F\u8E7B\u8EC2\u8F52\u8F51\u8F4F\u8F50\u8F53\u8FB4\u9140\u913F\u91B0\u91AD\u93DE\u93C7\u93CF\u93C2\u93DA\u93D0\u93F9\u93EC\u93CC\u93D9\u93A9\u93E6\u93CA\u93D4\u93EE\u93E3\u93D5\u93C4\u93CE\u93C0\u93D2\u93E7\u957D\u95DA\u95DB\u96E1\u9729\u972B\u972C\u9728\u9726"],
      ["f3a1", "\u97B3\u97B7\u97B6\u97DD\u97DE\u97DF\u985C\u9859\u985D\u9857\u98BF\u98BD\u98BB\u98BE\u9948\u9947\u9943\u99A6\u99A7\u9A1A\u9A15\u9A25\u9A1D\u9A24\u9A1B\u9A22\u9A20\u9A27\u9A23\u9A1E\u9A1C\u9A14\u9AC2\u9B0B\u9B0A\u9B0E\u9B0C\u9B37\u9BEA\u9BEB\u9BE0\u9BDE\u9BE4\u9BE6\u9BE2\u9BF0\u9BD4\u9BD7\u9BEC\u9BDC\u9BD9\u9BE5\u9BD5\u9BE1\u9BDA\u9D77\u9D81\u9D8A\u9D84\u9D88\u9D71\u9D80\u9D78\u9D86\u9D8B\u9D8C\u9D7D\u9D6B\u9D74\u9D75\u9D70\u9D69\u9D85\u9D73\u9D7B\u9D82\u9D6F\u9D79\u9D7F\u9D87\u9D68\u9E94\u9E91\u9EC0\u9EFC\u9F2D\u9F40\u9F41\u9F4D\u9F56\u9F57\u9F58\u5337\u56B2"],
      ["f440", "\u56B5\u56B3\u58E3\u5B45\u5DC6\u5DC7\u5EEE\u5EEF\u5FC0\u5FC1\u61F9\u6517\u6516\u6515\u6513\u65DF\u66E8\u66E3\u66E4\u6AF3\u6AF0\u6AEA\u6AE8\u6AF9\u6AF1\u6AEE\u6AEF\u703C\u7035\u702F\u7037\u7034\u7031\u7042\u7038\u703F\u703A\u7039\u7040\u703B\u7033\u7041\u7213\u7214\u72A8\u737D\u737C\u74BA\u76AB\u76AA\u76BE\u76ED\u77CC\u77CE\u77CF\u77CD\u77F2\u7925\u7923\u7927\u7928\u7924\u7929"],
      ["f4a1", "\u79B2\u7A6E\u7A6C\u7A6D\u7AF7\u7C49\u7C48\u7C4A\u7C47\u7C45\u7CEE\u7E7B\u7E7E\u7E81\u7E80\u7FBA\u7FFF\u8079\u81DB\u81D9\u820B\u8268\u8269\u8622\u85FF\u8601\u85FE\u861B\u8600\u85F6\u8604\u8609\u8605\u860C\u85FD\u8819\u8810\u8811\u8817\u8813\u8816\u8963\u8966\u89B9\u89F7\u8B60\u8B6A\u8B5D\u8B68\u8B63\u8B65\u8B67\u8B6D\u8DAE\u8E86\u8E88\u8E84\u8F59\u8F56\u8F57\u8F55\u8F58\u8F5A\u908D\u9143\u9141\u91B7\u91B5\u91B2\u91B3\u940B\u9413\u93FB\u9420\u940F\u9414\u93FE\u9415\u9410\u9428\u9419\u940D\u93F5\u9400\u93F7\u9407\u940E\u9416\u9412\u93FA\u9409\u93F8\u940A\u93FF"],
      ["f540", "\u93FC\u940C\u93F6\u9411\u9406\u95DE\u95E0\u95DF\u972E\u972F\u97B9\u97BB\u97FD\u97FE\u9860\u9862\u9863\u985F\u98C1\u98C2\u9950\u994E\u9959\u994C\u994B\u9953\u9A32\u9A34\u9A31\u9A2C\u9A2A\u9A36\u9A29\u9A2E\u9A38\u9A2D\u9AC7\u9ACA\u9AC6\u9B10\u9B12\u9B11\u9C0B\u9C08\u9BF7\u9C05\u9C12\u9BF8\u9C40\u9C07\u9C0E\u9C06\u9C17\u9C14\u9C09\u9D9F\u9D99\u9DA4\u9D9D\u9D92\u9D98\u9D90\u9D9B"],
      ["f5a1", "\u9DA0\u9D94\u9D9C\u9DAA\u9D97\u9DA1\u9D9A\u9DA2\u9DA8\u9D9E\u9DA3\u9DBF\u9DA9\u9D96\u9DA6\u9DA7\u9E99\u9E9B\u9E9A\u9EE5\u9EE4\u9EE7\u9EE6\u9F30\u9F2E\u9F5B\u9F60\u9F5E\u9F5D\u9F59\u9F91\u513A\u5139\u5298\u5297\u56C3\u56BD\u56BE\u5B48\u5B47\u5DCB\u5DCF\u5EF1\u61FD\u651B\u6B02\u6AFC\u6B03\u6AF8\u6B00\u7043\u7044\u704A\u7048\u7049\u7045\u7046\u721D\u721A\u7219\u737E\u7517\u766A\u77D0\u792D\u7931\u792F\u7C54\u7C53\u7CF2\u7E8A\u7E87\u7E88\u7E8B\u7E86\u7E8D\u7F4D\u7FBB\u8030\u81DD\u8618\u862A\u8626\u861F\u8623\u861C\u8619\u8627\u862E\u8621\u8620\u8629\u861E\u8625"],
      ["f640", "\u8829\u881D\u881B\u8820\u8824\u881C\u882B\u884A\u896D\u8969\u896E\u896B\u89FA\u8B79\u8B78\u8B45\u8B7A\u8B7B\u8D10\u8D14\u8DAF\u8E8E\u8E8C\u8F5E\u8F5B\u8F5D\u9146\u9144\u9145\u91B9\u943F\u943B\u9436\u9429\u943D\u943C\u9430\u9439\u942A\u9437\u942C\u9440\u9431\u95E5\u95E4\u95E3\u9735\u973A\u97BF\u97E1\u9864\u98C9\u98C6\u98C0\u9958\u9956\u9A39\u9A3D\u9A46\u9A44\u9A42\u9A41\u9A3A"],
      ["f6a1", "\u9A3F\u9ACD\u9B15\u9B17\u9B18\u9B16\u9B3A\u9B52\u9C2B\u9C1D\u9C1C\u9C2C\u9C23\u9C28\u9C29\u9C24\u9C21\u9DB7\u9DB6\u9DBC\u9DC1\u9DC7\u9DCA\u9DCF\u9DBE\u9DC5\u9DC3\u9DBB\u9DB5\u9DCE\u9DB9\u9DBA\u9DAC\u9DC8\u9DB1\u9DAD\u9DCC\u9DB3\u9DCD\u9DB2\u9E7A\u9E9C\u9EEB\u9EEE\u9EED\u9F1B\u9F18\u9F1A\u9F31\u9F4E\u9F65\u9F64\u9F92\u4EB9\u56C6\u56C5\u56CB\u5971\u5B4B\u5B4C\u5DD5\u5DD1\u5EF2\u6521\u6520\u6526\u6522\u6B0B\u6B08\u6B09\u6C0D\u7055\u7056\u7057\u7052\u721E\u721F\u72A9\u737F\u74D8\u74D5\u74D9\u74D7\u766D\u76AD\u7935\u79B4\u7A70\u7A71\u7C57\u7C5C\u7C59\u7C5B\u7C5A"],
      ["f740", "\u7CF4\u7CF1\u7E91\u7F4F\u7F87\u81DE\u826B\u8634\u8635\u8633\u862C\u8632\u8636\u882C\u8828\u8826\u882A\u8825\u8971\u89BF\u89BE\u89FB\u8B7E\u8B84\u8B82\u8B86\u8B85\u8B7F\u8D15\u8E95\u8E94\u8E9A\u8E92\u8E90\u8E96\u8E97\u8F60\u8F62\u9147\u944C\u9450\u944A\u944B\u944F\u9447\u9445\u9448\u9449\u9446\u973F\u97E3\u986A\u9869\u98CB\u9954\u995B\u9A4E\u9A53\u9A54\u9A4C\u9A4F\u9A48\u9A4A"],
      ["f7a1", "\u9A49\u9A52\u9A50\u9AD0\u9B19\u9B2B\u9B3B\u9B56\u9B55\u9C46\u9C48\u9C3F\u9C44\u9C39\u9C33\u9C41\u9C3C\u9C37\u9C34\u9C32\u9C3D\u9C36\u9DDB\u9DD2\u9DDE\u9DDA\u9DCB\u9DD0\u9DDC\u9DD1\u9DDF\u9DE9\u9DD9\u9DD8\u9DD6\u9DF5\u9DD5\u9DDD\u9EB6\u9EF0\u9F35\u9F33\u9F32\u9F42\u9F6B\u9F95\u9FA2\u513D\u5299\u58E8\u58E7\u5972\u5B4D\u5DD8\u882F\u5F4F\u6201\u6203\u6204\u6529\u6525\u6596\u66EB\u6B11\u6B12\u6B0F\u6BCA\u705B\u705A\u7222\u7382\u7381\u7383\u7670\u77D4\u7C67\u7C66\u7E95\u826C\u863A\u8640\u8639\u863C\u8631\u863B\u863E\u8830\u8832\u882E\u8833\u8976\u8974\u8973\u89FE"],
      ["f840", "\u8B8C\u8B8E\u8B8B\u8B88\u8C45\u8D19\u8E98\u8F64\u8F63\u91BC\u9462\u9455\u945D\u9457\u945E\u97C4\u97C5\u9800\u9A56\u9A59\u9B1E\u9B1F\u9B20\u9C52\u9C58\u9C50\u9C4A\u9C4D\u9C4B\u9C55\u9C59\u9C4C\u9C4E\u9DFB\u9DF7\u9DEF\u9DE3\u9DEB\u9DF8\u9DE4\u9DF6\u9DE1\u9DEE\u9DE6\u9DF2\u9DF0\u9DE2\u9DEC\u9DF4\u9DF3\u9DE8\u9DED\u9EC2\u9ED0\u9EF2\u9EF3\u9F06\u9F1C\u9F38\u9F37\u9F36\u9F43\u9F4F"],
      ["f8a1", "\u9F71\u9F70\u9F6E\u9F6F\u56D3\u56CD\u5B4E\u5C6D\u652D\u66ED\u66EE\u6B13\u705F\u7061\u705D\u7060\u7223\u74DB\u74E5\u77D5\u7938\u79B7\u79B6\u7C6A\u7E97\u7F89\u826D\u8643\u8838\u8837\u8835\u884B\u8B94\u8B95\u8E9E\u8E9F\u8EA0\u8E9D\u91BE\u91BD\u91C2\u946B\u9468\u9469\u96E5\u9746\u9743\u9747\u97C7\u97E5\u9A5E\u9AD5\u9B59\u9C63\u9C67\u9C66\u9C62\u9C5E\u9C60\u9E02\u9DFE\u9E07\u9E03\u9E06\u9E05\u9E00\u9E01\u9E09\u9DFF\u9DFD\u9E04\u9EA0\u9F1E\u9F46\u9F74\u9F75\u9F76\u56D4\u652E\u65B8\u6B18\u6B19\u6B17\u6B1A\u7062\u7226\u72AA\u77D8\u77D9\u7939\u7C69\u7C6B\u7CF6\u7E9A"],
      ["f940", "\u7E98\u7E9B\u7E99\u81E0\u81E1\u8646\u8647\u8648\u8979\u897A\u897C\u897B\u89FF\u8B98\u8B99\u8EA5\u8EA4\u8EA3\u946E\u946D\u946F\u9471\u9473\u9749\u9872\u995F\u9C68\u9C6E\u9C6D\u9E0B\u9E0D\u9E10\u9E0F\u9E12\u9E11\u9EA1\u9EF5\u9F09\u9F47\u9F78\u9F7B\u9F7A\u9F79\u571E\u7066\u7C6F\u883C\u8DB2\u8EA6\u91C3\u9474\u9478\u9476\u9475\u9A60\u9C74\u9C73\u9C71\u9C75\u9E14\u9E13\u9EF6\u9F0A"],
      ["f9a1", "\u9FA4\u7068\u7065\u7CF7\u866A\u883E\u883D\u883F\u8B9E\u8C9C\u8EA9\u8EC9\u974B\u9873\u9874\u98CC\u9961\u99AB\u9A64\u9A66\u9A67\u9B24\u9E15\u9E17\u9F48\u6207\u6B1E\u7227\u864C\u8EA8\u9482\u9480\u9481\u9A69\u9A68\u9B2E\u9E19\u7229\u864B\u8B9F\u9483\u9C79\u9EB7\u7675\u9A6B\u9C7A\u9E1D\u7069\u706A\u9EA4\u9F7E\u9F49\u9F98\u7881\u92B9\u88CF\u58BB\u6052\u7CA7\u5AFA\u2554\u2566\u2557\u2560\u256C\u2563\u255A\u2569\u255D\u2552\u2564\u2555\u255E\u256A\u2561\u2558\u2567\u255B\u2553\u2565\u2556\u255F\u256B\u2562\u2559\u2568\u255C\u2551\u2550\u256D\u256E\u2570\u256F\u2593"]
    ];
  }
});

// node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS({
  "node_modules/iconv-lite/encodings/tables/big5-added.json"(exports2, module2) {
    module2.exports = [
      ["8740", "\u43F0\u4C32\u4603\u45A6\u4578\u{27267}\u4D77\u45B3\u{27CB1}\u4CE2\u{27CC5}\u3B95\u4736\u4744\u4C47\u4C40\u{242BF}\u{23617}\u{27352}\u{26E8B}\u{270D2}\u4C57\u{2A351}\u474F\u45DA\u4C85\u{27C6C}\u4D07\u4AA4\u46A1\u{26B23}\u7225\u{25A54}\u{21A63}\u{23E06}\u{23F61}\u664D\u56FB"],
      ["8767", "\u7D95\u591D\u{28BB9}\u3DF4\u9734\u{27BEF}\u5BDB\u{21D5E}\u5AA4\u3625\u{29EB0}\u5AD1\u5BB7\u5CFC\u676E\u8593\u{29945}\u7461\u749D\u3875\u{21D53}\u{2369E}\u{26021}\u3EEC"],
      ["87a1", "\u{258DE}\u3AF5\u7AFC\u9F97\u{24161}\u{2890D}\u{231EA}\u{20A8A}\u{2325E}\u430A\u8484\u9F96\u942F\u4930\u8613\u5896\u974A\u9218\u79D0\u7A32\u6660\u6A29\u889D\u744C\u7BC5\u6782\u7A2C\u524F\u9046\u34E6\u73C4\u{25DB9}\u74C6\u9FC7\u57B3\u492F\u544C\u4131\u{2368E}\u5818\u7A72\u{27B65}\u8B8F\u46AE\u{26E88}\u4181\u{25D99}\u7BAE\u{224BC}\u9FC8\u{224C1}\u{224C9}\u{224CC}\u9FC9\u8504\u{235BB}\u40B4\u9FCA\u44E1\u{2ADFF}\u62C1\u706E\u9FCB"],
      ["8840", "\u31C0", 4, "\u{2010C}\u31C5\u{200D1}\u{200CD}\u31C6\u31C7\u{200CB}\u{21FE8}\u31C8\u{200CA}\u31C9\u31CA\u31CB\u31CC\u{2010E}\u31CD\u31CE\u0100\xC1\u01CD\xC0\u0112\xC9\u011A\xC8\u014C\xD3\u01D1\xD2\u0FFF\xCA\u0304\u1EBE\u0FFF\xCA\u030C\u1EC0\xCA\u0101\xE1\u01CE\xE0\u0251\u0113\xE9\u011B\xE8\u012B\xED\u01D0\xEC\u014D\xF3\u01D2\xF2\u016B\xFA\u01D4\xF9\u01D6\u01D8\u01DA"],
      ["88a1", "\u01DC\xFC\u0FFF\xEA\u0304\u1EBF\u0FFF\xEA\u030C\u1EC1\xEA\u0261\u23DA\u23DB"],
      ["8940", "\u{2A3A9}\u{21145}"],
      ["8943", "\u650A"],
      ["8946", "\u4E3D\u6EDD\u9D4E\u91DF"],
      ["894c", "\u{27735}\u6491\u4F1A\u4F28\u4FA8\u5156\u5174\u519C\u51E4\u52A1\u52A8\u533B\u534E\u53D1\u53D8\u56E2\u58F0\u5904\u5907\u5932\u5934\u5B66\u5B9E\u5B9F\u5C9A\u5E86\u603B\u6589\u67FE\u6804\u6865\u6D4E\u70BC\u7535\u7EA4\u7EAC\u7EBA\u7EC7\u7ECF\u7EDF\u7F06\u7F37\u827A\u82CF\u836F\u89C6\u8BBE\u8BE2\u8F66\u8F67\u8F6E"],
      ["89a1", "\u7411\u7CFC\u7DCD\u6946\u7AC9\u5227"],
      ["89ab", "\u918C\u78B8\u915E\u80BC"],
      ["89b0", "\u8D0B\u80F6\u{209E7}"],
      ["89b5", "\u809F\u9EC7\u4CCD\u9DC9\u9E0C\u4C3E\u{29DF6}\u{2700E}\u9E0A\u{2A133}\u35C1"],
      ["89c1", "\u6E9A\u823E\u7519"],
      ["89c5", "\u4911\u9A6C\u9A8F\u9F99\u7987\u{2846C}\u{21DCA}\u{205D0}\u{22AE6}\u4E24\u4E81\u4E80\u4E87\u4EBF\u4EEB\u4F37\u344C\u4FBD\u3E48\u5003\u5088\u347D\u3493\u34A5\u5186\u5905\u51DB\u51FC\u5205\u4E89\u5279\u5290\u5327\u35C7\u53A9\u3551\u53B0\u3553\u53C2\u5423\u356D\u3572\u3681\u5493\u54A3\u54B4\u54B9\u54D0\u54EF\u5518\u5523\u5528\u3598\u553F\u35A5\u35BF\u55D7\u35C5"],
      ["8a40", "\u{27D84}\u5525"],
      ["8a43", "\u{20C42}\u{20D15}\u{2512B}\u5590\u{22CC6}\u39EC\u{20341}\u8E46\u{24DB8}\u{294E5}\u4053\u{280BE}\u777A\u{22C38}\u3A34\u47D5\u{2815D}\u{269F2}\u{24DEA}\u64DD\u{20D7C}\u{20FB4}\u{20CD5}\u{210F4}\u648D\u8E7E\u{20E96}\u{20C0B}\u{20F64}\u{22CA9}\u{28256}\u{244D3}"],
      ["8a64", "\u{20D46}\u{29A4D}\u{280E9}\u47F4\u{24EA7}\u{22CC2}\u9AB2\u3A67\u{295F4}\u3FED\u3506\u{252C7}\u{297D4}\u{278C8}\u{22D44}\u9D6E\u9815"],
      ["8a76", "\u43D9\u{260A5}\u64B4\u54E3\u{22D4C}\u{22BCA}\u{21077}\u39FB\u{2106F}"],
      ["8aa1", "\u{266DA}\u{26716}\u{279A0}\u64EA\u{25052}\u{20C43}\u8E68\u{221A1}\u{28B4C}\u{20731}"],
      ["8aac", "\u480B\u{201A9}\u3FFA\u5873\u{22D8D}"],
      ["8ab2", "\u{245C8}\u{204FC}\u{26097}\u{20F4C}\u{20D96}\u5579\u40BB\u43BA"],
      ["8abb", "\u4AB4\u{22A66}\u{2109D}\u81AA\u98F5\u{20D9C}\u6379\u39FE\u{22775}\u8DC0\u56A1\u647C\u3E43"],
      ["8ac9", "\u{2A601}\u{20E09}\u{22ACF}\u{22CC9}"],
      ["8ace", "\u{210C8}\u{239C2}\u3992\u3A06\u{2829B}\u3578\u{25E49}\u{220C7}\u5652\u{20F31}\u{22CB2}\u{29720}\u34BC\u6C3D\u{24E3B}"],
      ["8adf", "\u{27574}\u{22E8B}\u{22208}\u{2A65B}\u{28CCD}\u{20E7A}\u{20C34}\u{2681C}\u7F93\u{210CF}\u{22803}\u{22939}\u35FB\u{251E3}\u{20E8C}\u{20F8D}\u{20EAA}\u3F93\u{20F30}\u{20D47}\u{2114F}\u{20E4C}"],
      ["8af6", "\u{20EAB}\u{20BA9}\u{20D48}\u{210C0}\u{2113D}\u3FF9\u{22696}\u6432\u{20FAD}"],
      ["8b40", "\u{233F4}\u{27639}\u{22BCE}\u{20D7E}\u{20D7F}\u{22C51}\u{22C55}\u3A18\u{20E98}\u{210C7}\u{20F2E}\u{2A632}\u{26B50}\u{28CD2}\u{28D99}\u{28CCA}\u95AA\u54CC\u82C4\u55B9"],
      ["8b55", "\u{29EC3}\u9C26\u9AB6\u{2775E}\u{22DEE}\u7140\u816D\u80EC\u5C1C\u{26572}\u8134\u3797\u535F\u{280BD}\u91B6\u{20EFA}\u{20E0F}\u{20E77}\u{20EFB}\u35DD\u{24DEB}\u3609\u{20CD6}\u56AF\u{227B5}\u{210C9}\u{20E10}\u{20E78}\u{21078}\u{21148}\u{28207}\u{21455}\u{20E79}\u{24E50}\u{22DA4}\u5A54\u{2101D}\u{2101E}\u{210F5}\u{210F6}\u579C\u{20E11}"],
      ["8ba1", "\u{27694}\u{282CD}\u{20FB5}\u{20E7B}\u{2517E}\u3703\u{20FB6}\u{21180}\u{252D8}\u{2A2BD}\u{249DA}\u{2183A}\u{24177}\u{2827C}\u5899\u5268\u361A\u{2573D}\u7BB2\u5B68\u4800\u4B2C\u9F27\u49E7\u9C1F\u9B8D\u{25B74}\u{2313D}\u55FB\u35F2\u5689\u4E28\u5902\u{21BC1}\u{2F878}\u9751\u{20086}\u4E5B\u4EBB\u353E\u5C23\u5F51\u5FC4\u38FA\u624C\u6535\u6B7A\u6C35\u6C3A\u706C\u722B\u4E2C\u72AD\u{248E9}\u7F52\u793B\u7CF9\u7F53\u{2626A}\u34C1"],
      ["8bde", "\u{2634B}\u8002\u8080\u{26612}\u{26951}\u535D\u8864\u89C1\u{278B2}\u8BA0\u8D1D\u9485\u9578\u957F\u95E8\u{28E0F}\u97E6\u9875\u98CE\u98DE\u9963\u{29810}\u9C7C\u9E1F\u9EC4\u6B6F\uF907\u4E37\u{20087}\u961D\u6237\u94A2"],
      ["8c40", "\u503B\u6DFE\u{29C73}\u9FA6\u3DC9\u888F\u{2414E}\u7077\u5CF5\u4B20\u{251CD}\u3559\u{25D30}\u6122\u{28A32}\u8FA7\u91F6\u7191\u6719\u73BA\u{23281}\u{2A107}\u3C8B\u{21980}\u4B10\u78E4\u7402\u51AE\u{2870F}\u4009\u6A63\u{2A2BA}\u4223\u860F\u{20A6F}\u7A2A\u{29947}\u{28AEA}\u9755\u704D\u5324\u{2207E}\u93F4\u76D9\u{289E3}\u9FA7\u77DD\u4EA3\u4FF0\u50BC\u4E2F\u4F17\u9FA8\u5434\u7D8B\u5892\u58D0\u{21DB6}\u5E92\u5E99\u5FC2\u{22712}\u658B"],
      ["8ca1", "\u{233F9}\u6919\u6A43\u{23C63}\u6CFF"],
      ["8ca7", "\u7200\u{24505}\u738C\u3EDB\u{24A13}\u5B15\u74B9\u8B83\u{25CA4}\u{25695}\u7A93\u7BEC\u7CC3\u7E6C\u82F8\u8597\u9FA9\u8890\u9FAA\u8EB9\u9FAB\u8FCF\u855F\u99E0\u9221\u9FAC\u{28DB9}\u{2143F}\u4071\u42A2\u5A1A"],
      ["8cc9", "\u9868\u676B\u4276\u573D"],
      ["8cce", "\u85D6\u{2497B}\u82BF\u{2710D}\u4C81\u{26D74}\u5D7B\u{26B15}\u{26FBE}\u9FAD\u9FAE\u5B96\u9FAF\u66E7\u7E5B\u6E57\u79CA\u3D88\u44C3\u{23256}\u{22796}\u439A\u4536"],
      ["8ce6", "\u5CD5\u{23B1A}\u8AF9\u5C78\u3D12\u{23551}\u5D78\u9FB2\u7157\u4558\u{240EC}\u{21E23}\u4C77\u3978\u344A\u{201A4}\u{26C41}\u8ACC\u4FB4\u{20239}\u59BF\u816C\u9856\u{298FA}\u5F3B"],
      ["8d40", "\u{20B9F}"],
      ["8d42", "\u{221C1}\u{2896D}\u4102\u46BB\u{29079}\u3F07\u9FB3\u{2A1B5}\u40F8\u37D6\u46F7\u{26C46}\u417C\u{286B2}\u{273FF}\u456D\u38D4\u{2549A}\u4561\u451B\u4D89\u4C7B\u4D76\u45EA\u3FC8\u{24B0F}\u3661\u44DE\u44BD\u41ED\u5D3E\u5D48\u5D56\u3DFC\u380F\u5DA4\u5DB9\u3820\u3838\u5E42\u5EBD\u5F25\u5F83\u3908\u3914\u393F\u394D\u60D7\u613D\u5CE5\u3989\u61B7\u61B9\u61CF\u39B8\u622C\u6290\u62E5\u6318\u39F8\u56B1"],
      ["8da1", "\u3A03\u63E2\u63FB\u6407\u645A\u3A4B\u64C0\u5D15\u5621\u9F9F\u3A97\u6586\u3ABD\u65FF\u6653\u3AF2\u6692\u3B22\u6716\u3B42\u67A4\u6800\u3B58\u684A\u6884\u3B72\u3B71\u3B7B\u6909\u6943\u725C\u6964\u699F\u6985\u3BBC\u69D6\u3BDD\u6A65\u6A74\u6A71\u6A82\u3BEC\u6A99\u3BF2\u6AAB\u6AB5\u6AD4\u6AF6\u6B81\u6BC1\u6BEA\u6C75\u6CAA\u3CCB\u6D02\u6D06\u6D26\u6D81\u3CEF\u6DA4\u6DB1\u6E15\u6E18\u6E29\u6E86\u{289C0}\u6EBB\u6EE2\u6EDA\u9F7F\u6EE8\u6EE9\u6F24\u6F34\u3D46\u{23F41}\u6F81\u6FBE\u3D6A\u3D75\u71B7\u5C99\u3D8A\u702C\u3D91\u7050\u7054\u706F\u707F\u7089\u{20325}\u43C1\u35F1\u{20ED8}"],
      ["8e40", "\u{23ED7}\u57BE\u{26ED3}\u713E\u{257E0}\u364E\u69A2\u{28BE9}\u5B74\u7A49\u{258E1}\u{294D9}\u7A65\u7A7D\u{259AC}\u7ABB\u7AB0\u7AC2\u7AC3\u71D1\u{2648D}\u41CA\u7ADA\u7ADD\u7AEA\u41EF\u54B2\u{25C01}\u7B0B\u7B55\u7B29\u{2530E}\u{25CFE}\u7BA2\u7B6F\u839C\u{25BB4}\u{26C7F}\u7BD0\u8421\u7B92\u7BB8\u{25D20}\u3DAD\u{25C65}\u8492\u7BFA\u7C06\u7C35\u{25CC1}\u7C44\u7C83\u{24882}\u7CA6\u667D\u{24578}\u7CC9\u7CC7\u7CE6\u7C74\u7CF3\u7CF5\u7CCE"],
      ["8ea1", "\u7E67\u451D\u{26E44}\u7D5D\u{26ED6}\u748D\u7D89\u7DAB\u7135\u7DB3\u7DD2\u{24057}\u{26029}\u7DE4\u3D13\u7DF5\u{217F9}\u7DE5\u{2836D}\u7E1D\u{26121}\u{2615A}\u7E6E\u7E92\u432B\u946C\u7E27\u7F40\u7F41\u7F47\u7936\u{262D0}\u99E1\u7F97\u{26351}\u7FA3\u{21661}\u{20068}\u455C\u{23766}\u4503\u{2833A}\u7FFA\u{26489}\u8005\u8008\u801D\u8028\u802F\u{2A087}\u{26CC3}\u803B\u803C\u8061\u{22714}\u4989\u{26626}\u{23DE3}\u{266E8}\u6725\u80A7\u{28A48}\u8107\u811A\u58B0\u{226F6}\u6C7F\u{26498}\u{24FB8}\u64E7\u{2148A}\u8218\u{2185E}\u6A53\u{24A65}\u{24A95}\u447A\u8229\u{20B0D}\u{26A52}\u{23D7E}\u4FF9\u{214FD}\u84E2\u8362\u{26B0A}\u{249A7}\u{23530}\u{21773}\u{23DF8}\u82AA\u691B\u{2F994}\u41DB"],
      ["8f40", "\u854B\u82D0\u831A\u{20E16}\u{217B4}\u36C1\u{2317D}\u{2355A}\u827B\u82E2\u8318\u{23E8B}\u{26DA3}\u{26B05}\u{26B97}\u{235CE}\u3DBF\u831D\u55EC\u8385\u450B\u{26DA5}\u83AC\u83C1\u83D3\u347E\u{26ED4}\u6A57\u855A\u3496\u{26E42}\u{22EEF}\u8458\u{25BE4}\u8471\u3DD3\u44E4\u6AA7\u844A\u{23CB5}\u7958\u84A8\u{26B96}\u{26E77}\u{26E43}\u84DE\u840F\u8391\u44A0\u8493\u84E4\u{25C91}\u4240\u{25CC0}\u4543\u8534\u5AF2\u{26E99}\u4527\u8573\u4516\u67BF\u8616"],
      ["8fa1", "\u{28625}\u{2863B}\u85C1\u{27088}\u8602\u{21582}\u{270CD}\u{2F9B2}\u456A\u8628\u3648\u{218A2}\u53F7\u{2739A}\u867E\u8771\u{2A0F8}\u87EE\u{22C27}\u87B1\u87DA\u880F\u5661\u866C\u6856\u460F\u8845\u8846\u{275E0}\u{23DB9}\u{275E4}\u885E\u889C\u465B\u88B4\u88B5\u63C1\u88C5\u7777\u{2770F}\u8987\u898A\u89A6\u89A9\u89A7\u89BC\u{28A25}\u89E7\u{27924}\u{27ABD}\u8A9C\u7793\u91FE\u8A90\u{27A59}\u7AE9\u{27B3A}\u{23F8F}\u4713\u{27B38}\u717C\u8B0C\u8B1F\u{25430}\u{25565}\u8B3F\u8B4C\u8B4D\u8AA9\u{24A7A}\u8B90\u8B9B\u8AAF\u{216DF}\u4615\u884F\u8C9B\u{27D54}\u{27D8F}\u{2F9D4}\u3725\u{27D53}\u8CD6\u{27D98}\u{27DBD}\u8D12\u8D03\u{21910}\u8CDB\u705C\u8D11\u{24CC9}\u3ED0\u8D77"],
      ["9040", "\u8DA9\u{28002}\u{21014}\u{2498A}\u3B7C\u{281BC}\u{2710C}\u7AE7\u8EAD\u8EB6\u8EC3\u92D4\u8F19\u8F2D\u{28365}\u{28412}\u8FA5\u9303\u{2A29F}\u{20A50}\u8FB3\u492A\u{289DE}\u{2853D}\u{23DBB}\u5EF8\u{23262}\u8FF9\u{2A014}\u{286BC}\u{28501}\u{22325}\u3980\u{26ED7}\u9037\u{2853C}\u{27ABE}\u9061\u{2856C}\u{2860B}\u90A8\u{28713}\u90C4\u{286E6}\u90AE\u90FD\u9167\u3AF0\u91A9\u91C4\u7CAC\u{28933}\u{21E89}\u920E\u6C9F\u9241\u9262\u{255B9}\u92B9\u{28AC6}\u{23C9B}\u{28B0C}\u{255DB}"],
      ["90a1", "\u{20D31}\u932C\u936B\u{28AE1}\u{28BEB}\u708F\u5AC3\u{28AE2}\u{28AE5}\u4965\u9244\u{28BEC}\u{28C39}\u{28BFF}\u9373\u945B\u8EBC\u9585\u95A6\u9426\u95A0\u6FF6\u42B9\u{2267A}\u{286D8}\u{2127C}\u{23E2E}\u49DF\u6C1C\u967B\u9696\u416C\u96A3\u{26ED5}\u61DA\u96B6\u78F5\u{28AE0}\u96BD\u53CC\u49A1\u{26CB8}\u{20274}\u{26410}\u{290AF}\u{290E5}\u{24AD1}\u{21915}\u{2330A}\u9731\u8642\u9736\u4A0F\u453D\u4585\u{24AE9}\u7075\u5B41\u971B\u975C\u{291D5}\u9757\u5B4A\u{291EB}\u975F\u9425\u50D0\u{230B7}\u{230BC}\u9789\u979F\u97B1\u97BE\u97C0\u97D2\u97E0\u{2546C}\u97EE\u741C\u{29433}\u97FF\u97F5\u{2941D}\u{2797A}\u4AD1\u9834\u9833\u984B\u9866\u3B0E\u{27175}\u3D51\u{20630}\u{2415C}"],
      ["9140", "\u{25706}\u98CA\u98B7\u98C8\u98C7\u4AFF\u{26D27}\u{216D3}\u55B0\u98E1\u98E6\u98EC\u9378\u9939\u{24A29}\u4B72\u{29857}\u{29905}\u99F5\u9A0C\u9A3B\u9A10\u9A58\u{25725}\u36C4\u{290B1}\u{29BD5}\u9AE0\u9AE2\u{29B05}\u9AF4\u4C0E\u9B14\u9B2D\u{28600}\u5034\u9B34\u{269A8}\u38C3\u{2307D}\u9B50\u9B40\u{29D3E}\u5A45\u{21863}\u9B8E\u{2424B}\u9C02\u9BFF\u9C0C\u{29E68}\u9DD4\u{29FB7}\u{2A192}\u{2A1AB}\u{2A0E1}\u{2A123}\u{2A1DF}\u9D7E\u9D83\u{2A134}\u9E0E\u6888"],
      ["91a1", "\u9DC4\u{2215B}\u{2A193}\u{2A220}\u{2193B}\u{2A233}\u9D39\u{2A0B9}\u{2A2B4}\u9E90\u9E95\u9E9E\u9EA2\u4D34\u9EAA\u9EAF\u{24364}\u9EC1\u3B60\u39E5\u3D1D\u4F32\u37BE\u{28C2B}\u9F02\u9F08\u4B96\u9424\u{26DA2}\u9F17\u9F16\u9F39\u569F\u568A\u9F45\u99B8\u{2908B}\u97F2\u847F\u9F62\u9F69\u7ADC\u9F8E\u7216\u4BBE\u{24975}\u{249BB}\u7177\u{249F8}\u{24348}\u{24A51}\u739E\u{28BDA}\u{218FA}\u799F\u{2897E}\u{28E36}\u9369\u93F3\u{28A44}\u92EC\u9381\u93CB\u{2896C}\u{244B9}\u7217\u3EEB\u7772\u7A43\u70D0\u{24473}\u{243F8}\u717E\u{217EF}\u70A3\u{218BE}\u{23599}\u3EC7\u{21885}\u{2542F}\u{217F8}\u3722\u{216FB}\u{21839}\u36E1\u{21774}\u{218D1}\u{25F4B}\u3723\u{216C0}\u575B\u{24A25}\u{213FE}\u{212A8}"],
      ["9240", "\u{213C6}\u{214B6}\u8503\u{236A6}\u8503\u8455\u{24994}\u{27165}\u{23E31}\u{2555C}\u{23EFB}\u{27052}\u44F4\u{236EE}\u{2999D}\u{26F26}\u67F9\u3733\u3C15\u3DE7\u586C\u{21922}\u6810\u4057\u{2373F}\u{240E1}\u{2408B}\u{2410F}\u{26C21}\u54CB\u569E\u{266B1}\u5692\u{20FDF}\u{20BA8}\u{20E0D}\u93C6\u{28B13}\u939C\u4EF8\u512B\u3819\u{24436}\u4EBC\u{20465}\u{2037F}\u4F4B\u4F8A\u{25651}\u5A68\u{201AB}\u{203CB}\u3999\u{2030A}\u{20414}\u3435\u4F29\u{202C0}\u{28EB3}\u{20275}\u8ADA\u{2020C}\u4E98"],
      ["92a1", "\u50CD\u510D\u4FA2\u4F03\u{24A0E}\u{23E8A}\u4F42\u502E\u506C\u5081\u4FCC\u4FE5\u5058\u50FC\u5159\u515B\u515D\u515E\u6E76\u{23595}\u{23E39}\u{23EBF}\u6D72\u{21884}\u{23E89}\u51A8\u51C3\u{205E0}\u44DD\u{204A3}\u{20492}\u{20491}\u8D7A\u{28A9C}\u{2070E}\u5259\u52A4\u{20873}\u52E1\u936E\u467A\u718C\u{2438C}\u{20C20}\u{249AC}\u{210E4}\u69D1\u{20E1D}\u7479\u3EDE\u7499\u7414\u7456\u7398\u4B8E\u{24ABC}\u{2408D}\u53D0\u3584\u720F\u{240C9}\u55B4\u{20345}\u54CD\u{20BC6}\u571D\u925D\u96F4\u9366\u57DD\u578D\u577F\u363E\u58CB\u5A99\u{28A46}\u{216FA}\u{2176F}\u{21710}\u5A2C\u59B8\u928F\u5A7E\u5ACF\u5A12\u{25946}\u{219F3}\u{21861}\u{24295}\u36F5\u6D05\u7443\u5A21\u{25E83}"],
      ["9340", "\u5A81\u{28BD7}\u{20413}\u93E0\u748C\u{21303}\u7105\u4972\u9408\u{289FB}\u93BD\u37A0\u5C1E\u5C9E\u5E5E\u5E48\u{21996}\u{2197C}\u{23AEE}\u5ECD\u5B4F\u{21903}\u{21904}\u3701\u{218A0}\u36DD\u{216FE}\u36D3\u812A\u{28A47}\u{21DBA}\u{23472}\u{289A8}\u5F0C\u5F0E\u{21927}\u{217AB}\u5A6B\u{2173B}\u5B44\u8614\u{275FD}\u8860\u607E\u{22860}\u{2262B}\u5FDB\u3EB8\u{225AF}\u{225BE}\u{29088}\u{26F73}\u61C0\u{2003E}\u{20046}\u{2261B}\u6199\u6198\u6075\u{22C9B}\u{22D07}\u{246D4}\u{2914D}"],
      ["93a1", "\u6471\u{24665}\u{22B6A}\u3A29\u{22B22}\u{23450}\u{298EA}\u{22E78}\u6337\u{2A45B}\u64B6\u6331\u63D1\u{249E3}\u{22D67}\u62A4\u{22CA1}\u643B\u656B\u6972\u3BF4\u{2308E}\u{232AD}\u{24989}\u{232AB}\u550D\u{232E0}\u{218D9}\u{2943F}\u66CE\u{23289}\u{231B3}\u3AE0\u4190\u{25584}\u{28B22}\u{2558F}\u{216FC}\u{2555B}\u{25425}\u78EE\u{23103}\u{2182A}\u{23234}\u3464\u{2320F}\u{23182}\u{242C9}\u668E\u{26D24}\u666B\u4B93\u6630\u{27870}\u{21DEB}\u6663\u{232D2}\u{232E1}\u661E\u{25872}\u38D1\u{2383A}\u{237BC}\u3B99\u{237A2}\u{233FE}\u74D0\u3B96\u678F\u{2462A}\u68B6\u681E\u3BC4\u6ABE\u3863\u{237D5}\u{24487}\u6A33\u6A52\u6AC9\u6B05\u{21912}\u6511\u6898\u6A4C\u3BD7\u6A7A\u6B57\u{23FC0}\u{23C9A}\u93A0\u92F2\u{28BEA}\u{28ACB}"],
      ["9440", "\u9289\u{2801E}\u{289DC}\u9467\u6DA5\u6F0B\u{249EC}\u6D67\u{23F7F}\u3D8F\u6E04\u{2403C}\u5A3D\u6E0A\u5847\u6D24\u7842\u713B\u{2431A}\u{24276}\u70F1\u7250\u7287\u7294\u{2478F}\u{24725}\u5179\u{24AA4}\u{205EB}\u747A\u{23EF8}\u{2365F}\u{24A4A}\u{24917}\u{25FE1}\u3F06\u3EB1\u{24ADF}\u{28C23}\u{23F35}\u60A7\u3EF3\u74CC\u743C\u9387\u7437\u449F\u{26DEA}\u4551\u7583\u3F63\u{24CD9}\u{24D06}\u3F58\u7555\u7673\u{2A5C6}\u3B19\u7468\u{28ACC}\u{249AB}\u{2498E}\u3AFB"],
      ["94a1", "\u3DCD\u{24A4E}\u3EFF\u{249C5}\u{248F3}\u91FA\u5732\u9342\u{28AE3}\u{21864}\u50DF\u{25221}\u{251E7}\u7778\u{23232}\u770E\u770F\u777B\u{24697}\u{23781}\u3A5E\u{248F0}\u7438\u749B\u3EBF\u{24ABA}\u{24AC7}\u40C8\u{24A96}\u{261AE}\u9307\u{25581}\u781E\u788D\u7888\u78D2\u73D0\u7959\u{27741}\u{256E3}\u410E\u799B\u8496\u79A5\u6A2D\u{23EFA}\u7A3A\u79F4\u416E\u{216E6}\u4132\u9235\u79F1\u{20D4C}\u{2498C}\u{20299}\u{23DBA}\u{2176E}\u3597\u556B\u3570\u36AA\u{201D4}\u{20C0D}\u7AE2\u5A59\u{226F5}\u{25AAF}\u{25A9C}\u5A0D\u{2025B}\u78F0\u5A2A\u{25BC6}\u7AFE\u41F9\u7C5D\u7C6D\u4211\u{25BB3}\u{25EBC}\u{25EA6}\u7CCD\u{249F9}\u{217B0}\u7C8E\u7C7C\u7CAE\u6AB2\u7DDC\u7E07\u7DD3\u7F4E\u{26261}"],
      ["9540", "\u{2615C}\u{27B48}\u7D97\u{25E82}\u426A\u{26B75}\u{20916}\u67D6\u{2004E}\u{235CF}\u57C4\u{26412}\u{263F8}\u{24962}\u7FDD\u7B27\u{2082C}\u{25AE9}\u{25D43}\u7B0C\u{25E0E}\u99E6\u8645\u9A63\u6A1C\u{2343F}\u39E2\u{249F7}\u{265AD}\u9A1F\u{265A0}\u8480\u{27127}\u{26CD1}\u44EA\u8137\u4402\u80C6\u8109\u8142\u{267B4}\u98C3\u{26A42}\u8262\u8265\u{26A51}\u8453\u{26DA7}\u8610\u{2721B}\u5A86\u417F\u{21840}\u5B2B\u{218A1}\u5AE4\u{218D8}\u86A0\u{2F9BC}\u{23D8F}\u882D\u{27422}\u5A02"],
      ["95a1", "\u886E\u4F45\u8887\u88BF\u88E6\u8965\u894D\u{25683}\u8954\u{27785}\u{27784}\u{28BF5}\u{28BD9}\u{28B9C}\u{289F9}\u3EAD\u84A3\u46F5\u46CF\u37F2\u8A3D\u8A1C\u{29448}\u5F4D\u922B\u{24284}\u65D4\u7129\u70C4\u{21845}\u9D6D\u8C9F\u8CE9\u{27DDC}\u599A\u77C3\u59F0\u436E\u36D4\u8E2A\u8EA7\u{24C09}\u8F30\u8F4A\u42F4\u6C58\u6FBB\u{22321}\u489B\u6F79\u6E8B\u{217DA}\u9BE9\u36B5\u{2492F}\u90BB\u9097\u5571\u4906\u91BB\u9404\u{28A4B}\u4062\u{28AFC}\u9427\u{28C1D}\u{28C3B}\u84E5\u8A2B\u9599\u95A7\u9597\u9596\u{28D34}\u7445\u3EC2\u{248FF}\u{24A42}\u{243EA}\u3EE7\u{23225}\u968F\u{28EE7}\u{28E66}\u{28E65}\u3ECC\u{249ED}\u{24A78}\u{23FEE}\u7412\u746B\u3EFC\u9741\u{290B0}"],
      ["9640", "\u6847\u4A1D\u{29093}\u{257DF}\u975D\u9368\u{28989}\u{28C26}\u{28B2F}\u{263BE}\u92BA\u5B11\u8B69\u493C\u73F9\u{2421B}\u979B\u9771\u9938\u{20F26}\u5DC1\u{28BC5}\u{24AB2}\u981F\u{294DA}\u92F6\u{295D7}\u91E5\u44C0\u{28B50}\u{24A67}\u{28B64}\u98DC\u{28A45}\u3F00\u922A\u4925\u8414\u993B\u994D\u{27B06}\u3DFD\u999B\u4B6F\u99AA\u9A5C\u{28B65}\u{258C8}\u6A8F\u9A21\u5AFE\u9A2F\u{298F1}\u4B90\u{29948}\u99BC\u4BBD\u4B97\u937D\u5872\u{21302}\u5822\u{249B8}"],
      ["96a1", "\u{214E8}\u7844\u{2271F}\u{23DB8}\u68C5\u3D7D\u9458\u3927\u6150\u{22781}\u{2296B}\u6107\u9C4F\u9C53\u9C7B\u9C35\u9C10\u9B7F\u9BCF\u{29E2D}\u9B9F\u{2A1F5}\u{2A0FE}\u9D21\u4CAE\u{24104}\u9E18\u4CB0\u9D0C\u{2A1B4}\u{2A0ED}\u{2A0F3}\u{2992F}\u9DA5\u84BD\u{26E12}\u{26FDF}\u{26B82}\u85FC\u4533\u{26DA4}\u{26E84}\u{26DF0}\u8420\u85EE\u{26E00}\u{237D7}\u{26064}\u79E2\u{2359C}\u{23640}\u492D\u{249DE}\u3D62\u93DB\u92BE\u9348\u{202BF}\u78B9\u9277\u944D\u4FE4\u3440\u9064\u{2555D}\u783D\u7854\u78B6\u784B\u{21757}\u{231C9}\u{24941}\u369A\u4F72\u6FDA\u6FD9\u701E\u701E\u5414\u{241B5}\u57BB\u58F3\u578A\u9D16\u57D7\u7134\u34AF\u{241AC}\u71EB\u{26C40}\u{24F97}\u5B28\u{217B5}\u{28A49}"],
      ["9740", "\u610C\u5ACE\u5A0B\u42BC\u{24488}\u372C\u4B7B\u{289FC}\u93BB\u93B8\u{218D6}\u{20F1D}\u8472\u{26CC0}\u{21413}\u{242FA}\u{22C26}\u{243C1}\u5994\u{23DB7}\u{26741}\u7DA8\u{2615B}\u{260A4}\u{249B9}\u{2498B}\u{289FA}\u92E5\u73E2\u3EE9\u74B4\u{28B63}\u{2189F}\u3EE1\u{24AB3}\u6AD8\u73F3\u73FB\u3ED6\u{24A3E}\u{24A94}\u{217D9}\u{24A66}\u{203A7}\u{21424}\u{249E5}\u7448\u{24916}\u70A5\u{24976}\u9284\u73E6\u935F\u{204FE}\u9331\u{28ACE}\u{28A16}\u9386\u{28BE7}\u{255D5}\u4935\u{28A82}\u716B"],
      ["97a1", "\u{24943}\u{20CFF}\u56A4\u{2061A}\u{20BEB}\u{20CB8}\u5502\u79C4\u{217FA}\u7DFE\u{216C2}\u{24A50}\u{21852}\u452E\u9401\u370A\u{28AC0}\u{249AD}\u59B0\u{218BF}\u{21883}\u{27484}\u5AA1\u36E2\u{23D5B}\u36B0\u925F\u5A79\u{28A81}\u{21862}\u9374\u3CCD\u{20AB4}\u4A96\u398A\u50F4\u3D69\u3D4C\u{2139C}\u7175\u42FB\u{28218}\u6E0F\u{290E4}\u44EB\u6D57\u{27E4F}\u7067\u6CAF\u3CD6\u{23FED}\u{23E2D}\u6E02\u6F0C\u3D6F\u{203F5}\u7551\u36BC\u34C8\u4680\u3EDA\u4871\u59C4\u926E\u493E\u8F41\u{28C1C}\u{26BC0}\u5812\u57C8\u36D6\u{21452}\u70FE\u{24362}\u{24A71}\u{22FE3}\u{212B0}\u{223BD}\u68B9\u6967\u{21398}\u{234E5}\u{27BF4}\u{236DF}\u{28A83}\u{237D6}\u{233FA}\u{24C9F}\u6A1A\u{236AD}\u{26CB7}\u843E\u44DF\u44CE"],
      ["9840", "\u{26D26}\u{26D51}\u{26C82}\u{26FDE}\u6F17\u{27109}\u833D\u{2173A}\u83ED\u{26C80}\u{27053}\u{217DB}\u5989\u5A82\u{217B3}\u5A61\u5A71\u{21905}\u{241FC}\u372D\u59EF\u{2173C}\u36C7\u718E\u9390\u669A\u{242A5}\u5A6E\u5A2B\u{24293}\u6A2B\u{23EF9}\u{27736}\u{2445B}\u{242CA}\u711D\u{24259}\u{289E1}\u4FB0\u{26D28}\u5CC2\u{244CE}\u{27E4D}\u{243BD}\u6A0C\u{24256}\u{21304}\u70A6\u7133\u{243E9}\u3DA5\u6CDF\u{2F825}\u{24A4F}\u7E65\u59EB\u5D2F\u3DF3\u5F5C\u{24A5D}\u{217DF}\u7DA4\u8426"],
      ["98a1", "\u5485\u{23AFA}\u{23300}\u{20214}\u577E\u{208D5}\u{20619}\u3FE5\u{21F9E}\u{2A2B6}\u7003\u{2915B}\u5D70\u738F\u7CD3\u{28A59}\u{29420}\u4FC8\u7FE7\u72CD\u7310\u{27AF4}\u7338\u7339\u{256F6}\u7341\u7348\u3EA9\u{27B18}\u906C\u71F5\u{248F2}\u73E1\u81F6\u3ECA\u770C\u3ED1\u6CA2\u56FD\u7419\u741E\u741F\u3EE2\u3EF0\u3EF4\u3EFA\u74D3\u3F0E\u3F53\u7542\u756D\u7572\u758D\u3F7C\u75C8\u75DC\u3FC0\u764D\u3FD7\u7674\u3FDC\u767A\u{24F5C}\u7188\u5623\u8980\u5869\u401D\u7743\u4039\u6761\u4045\u35DB\u7798\u406A\u406F\u5C5E\u77BE\u77CB\u58F2\u7818\u70B9\u781C\u40A8\u7839\u7847\u7851\u7866\u8448\u{25535}\u7933\u6803\u7932\u4103"],
      ["9940", "\u4109\u7991\u7999\u8FBB\u7A06\u8FBC\u4167\u7A91\u41B2\u7ABC\u8279\u41C4\u7ACF\u7ADB\u41CF\u4E21\u7B62\u7B6C\u7B7B\u7C12\u7C1B\u4260\u427A\u7C7B\u7C9C\u428C\u7CB8\u4294\u7CED\u8F93\u70C0\u{20CCF}\u7DCF\u7DD4\u7DD0\u7DFD\u7FAE\u7FB4\u729F\u4397\u8020\u8025\u7B39\u802E\u8031\u8054\u3DCC\u57B4\u70A0\u80B7\u80E9\u43ED\u810C\u732A\u810E\u8112\u7560\u8114\u4401\u3B39\u8156\u8159\u815A"],
      ["99a1", "\u4413\u583A\u817C\u8184\u4425\u8193\u442D\u81A5\u57EF\u81C1\u81E4\u8254\u448F\u82A6\u8276\u82CA\u82D8\u82FF\u44B0\u8357\u9669\u698A\u8405\u70F5\u8464\u60E3\u8488\u4504\u84BE\u84E1\u84F8\u8510\u8538\u8552\u453B\u856F\u8570\u85E0\u4577\u8672\u8692\u86B2\u86EF\u9645\u878B\u4606\u4617\u88AE\u88FF\u8924\u8947\u8991\u{27967}\u8A29\u8A38\u8A94\u8AB4\u8C51\u8CD4\u8CF2\u8D1C\u4798\u585F\u8DC3\u47ED\u4EEE\u8E3A\u55D8\u5754\u8E71\u55F5\u8EB0\u4837\u8ECE\u8EE2\u8EE4\u8EED\u8EF2\u8FB7\u8FC1\u8FCA\u8FCC\u9033\u99C4\u48AD\u98E0\u9213\u491E\u9228\u9258\u926B\u92B1\u92AE\u92BF"],
      ["9a40", "\u92E3\u92EB\u92F3\u92F4\u92FD\u9343\u9384\u93AD\u4945\u4951\u9EBF\u9417\u5301\u941D\u942D\u943E\u496A\u9454\u9479\u952D\u95A2\u49A7\u95F4\u9633\u49E5\u67A0\u4A24\u9740\u4A35\u97B2\u97C2\u5654\u4AE4\u60E8\u98B9\u4B19\u98F1\u5844\u990E\u9919\u51B4\u991C\u9937\u9942\u995D\u9962\u4B70\u99C5\u4B9D\u9A3C\u9B0F\u7A83\u9B69\u9B81\u9BDD\u9BF1\u9BF4\u4C6D\u9C20\u376F\u{21BC2}\u9D49\u9C3A"],
      ["9aa1", "\u9EFE\u5650\u9D93\u9DBD\u9DC0\u9DFC\u94F6\u8FB6\u9E7B\u9EAC\u9EB1\u9EBD\u9EC6\u94DC\u9EE2\u9EF1\u9EF8\u7AC8\u9F44\u{20094}\u{202B7}\u{203A0}\u691A\u94C3\u59AC\u{204D7}\u5840\u94C1\u37B9\u{205D5}\u{20615}\u{20676}\u{216BA}\u5757\u7173\u{20AC2}\u{20ACD}\u{20BBF}\u546A\u{2F83B}\u{20BCB}\u549E\u{20BFB}\u{20C3B}\u{20C53}\u{20C65}\u{20C7C}\u60E7\u{20C8D}\u567A\u{20CB5}\u{20CDD}\u{20CED}\u{20D6F}\u{20DB2}\u{20DC8}\u6955\u9C2F\u87A5\u{20E04}\u{20E0E}\u{20ED7}\u{20F90}\u{20F2D}\u{20E73}\u5C20\u{20FBC}\u5E0B\u{2105C}\u{2104F}\u{21076}\u671E\u{2107B}\u{21088}\u{21096}\u3647\u{210BF}\u{210D3}\u{2112F}\u{2113B}\u5364\u84AD\u{212E3}\u{21375}\u{21336}\u8B81\u{21577}\u{21619}\u{217C3}\u{217C7}\u4E78\u70BB\u{2182D}\u{2196A}"],
      ["9b40", "\u{21A2D}\u{21A45}\u{21C2A}\u{21C70}\u{21CAC}\u{21EC8}\u62C3\u{21ED5}\u{21F15}\u7198\u6855\u{22045}\u69E9\u36C8\u{2227C}\u{223D7}\u{223FA}\u{2272A}\u{22871}\u{2294F}\u82FD\u{22967}\u{22993}\u{22AD5}\u89A5\u{22AE8}\u8FA0\u{22B0E}\u97B8\u{22B3F}\u9847\u9ABD\u{22C4C}"],
      ["9b62", "\u{22C88}\u{22CB7}\u{25BE8}\u{22D08}\u{22D12}\u{22DB7}\u{22D95}\u{22E42}\u{22F74}\u{22FCC}\u{23033}\u{23066}\u{2331F}\u{233DE}\u5FB1\u6648\u66BF\u{27A79}\u{23567}\u{235F3}\u7201\u{249BA}\u77D7\u{2361A}\u{23716}\u7E87\u{20346}\u58B5\u670E"],
      ["9ba1", "\u6918\u{23AA7}\u{27657}\u{25FE2}\u{23E11}\u{23EB9}\u{275FE}\u{2209A}\u48D0\u4AB8\u{24119}\u{28A9A}\u{242EE}\u{2430D}\u{2403B}\u{24334}\u{24396}\u{24A45}\u{205CA}\u51D2\u{20611}\u599F\u{21EA8}\u3BBE\u{23CFF}\u{24404}\u{244D6}\u5788\u{24674}\u399B\u{2472F}\u{285E8}\u{299C9}\u3762\u{221C3}\u8B5E\u{28B4E}\u99D6\u{24812}\u{248FB}\u{24A15}\u7209\u{24AC0}\u{20C78}\u5965\u{24EA5}\u{24F86}\u{20779}\u8EDA\u{2502C}\u528F\u573F\u7171\u{25299}\u{25419}\u{23F4A}\u{24AA7}\u55BC\u{25446}\u{2546E}\u{26B52}\u91D4\u3473\u{2553F}\u{27632}\u{2555E}\u4718\u{25562}\u{25566}\u{257C7}\u{2493F}\u{2585D}\u5066\u34FB\u{233CC}\u60DE\u{25903}\u477C\u{28948}\u{25AAE}\u{25B89}\u{25C06}\u{21D90}\u57A1\u7151\u6FB6\u{26102}\u{27C12}\u9056\u{261B2}\u{24F9A}\u8B62\u{26402}\u{2644A}"],
      ["9c40", "\u5D5B\u{26BF7}\u8F36\u{26484}\u{2191C}\u8AEA\u{249F6}\u{26488}\u{23FEF}\u{26512}\u4BC0\u{265BF}\u{266B5}\u{2271B}\u9465\u{257E1}\u6195\u5A27\u{2F8CD}\u4FBB\u56B9\u{24521}\u{266FC}\u4E6A\u{24934}\u9656\u6D8F\u{26CBD}\u3618\u8977\u{26799}\u{2686E}\u{26411}\u{2685E}\u71DF\u{268C7}\u7B42\u{290C0}\u{20A11}\u{26926}\u9104\u{26939}\u7A45\u9DF0\u{269FA}\u9A26\u{26A2D}\u365F\u{26469}\u{20021}\u7983\u{26A34}\u{26B5B}\u5D2C\u{23519}\u83CF\u{26B9D}\u46D0\u{26CA4}\u753B\u8865\u{26DAE}\u58B6"],
      ["9ca1", "\u371C\u{2258D}\u{2704B}\u{271CD}\u3C54\u{27280}\u{27285}\u9281\u{2217A}\u{2728B}\u9330\u{272E6}\u{249D0}\u6C39\u949F\u{27450}\u{20EF8}\u8827\u88F5\u{22926}\u{28473}\u{217B1}\u6EB8\u{24A2A}\u{21820}\u39A4\u36B9\u5C10\u79E3\u453F\u66B6\u{29CAD}\u{298A4}\u8943\u{277CC}\u{27858}\u56D6\u40DF\u{2160A}\u39A1\u{2372F}\u{280E8}\u{213C5}\u71AD\u8366\u{279DD}\u{291A8}\u5A67\u4CB7\u{270AF}\u{289AB}\u{279FD}\u{27A0A}\u{27B0B}\u{27D66}\u{2417A}\u7B43\u797E\u{28009}\u6FB5\u{2A2DF}\u6A03\u{28318}\u53A2\u{26E07}\u93BF\u6836\u975D\u{2816F}\u{28023}\u{269B5}\u{213ED}\u{2322F}\u{28048}\u5D85\u{28C30}\u{28083}\u5715\u9823\u{28949}\u5DAB\u{24988}\u65BE\u69D5\u53D2\u{24AA5}\u{23F81}\u3C11\u6736\u{28090}\u{280F4}\u{2812E}\u{21FA1}\u{2814F}"],
      ["9d40", "\u{28189}\u{281AF}\u{2821A}\u{28306}\u{2832F}\u{2838A}\u35CA\u{28468}\u{286AA}\u48FA\u63E6\u{28956}\u7808\u9255\u{289B8}\u43F2\u{289E7}\u43DF\u{289E8}\u{28B46}\u{28BD4}\u59F8\u{28C09}\u8F0B\u{28FC5}\u{290EC}\u7B51\u{29110}\u{2913C}\u3DF7\u{2915E}\u{24ACA}\u8FD0\u728F\u568B\u{294E7}\u{295E9}\u{295B0}\u{295B8}\u{29732}\u{298D1}\u{29949}\u{2996A}\u{299C3}\u{29A28}\u{29B0E}\u{29D5A}\u{29D9B}\u7E9F\u{29EF8}\u{29F23}\u4CA4\u9547\u{2A293}\u71A2\u{2A2FF}\u4D91\u9012\u{2A5CB}\u4D9C\u{20C9C}\u8FBE\u55C1"],
      ["9da1", "\u8FBA\u{224B0}\u8FB9\u{24A93}\u4509\u7E7F\u6F56\u6AB1\u4EEA\u34E4\u{28B2C}\u{2789D}\u373A\u8E80\u{217F5}\u{28024}\u{28B6C}\u{28B99}\u{27A3E}\u{266AF}\u3DEB\u{27655}\u{23CB7}\u{25635}\u{25956}\u4E9A\u{25E81}\u{26258}\u56BF\u{20E6D}\u8E0E\u5B6D\u{23E88}\u{24C9E}\u63DE\u62D0\u{217F6}\u{2187B}\u6530\u562D\u{25C4A}\u541A\u{25311}\u3DC6\u{29D98}\u4C7D\u5622\u561E\u7F49\u{25ED8}\u5975\u{23D40}\u8770\u4E1C\u{20FEA}\u{20D49}\u{236BA}\u8117\u9D5E\u8D18\u763B\u9C45\u764E\u77B9\u9345\u5432\u8148\u82F7\u5625\u8132\u8418\u80BD\u55EA\u7962\u5643\u5416\u{20E9D}\u35CE\u5605\u55F1\u66F1\u{282E2}\u362D\u7534\u55F0\u55BA\u5497\u5572\u{20C41}\u{20C96}\u5ED0\u{25148}\u{20E76}\u{22C62}"],
      ["9e40", "\u{20EA2}\u9EAB\u7D5A\u55DE\u{21075}\u629D\u976D\u5494\u8CCD\u71F6\u9176\u63FC\u63B9\u63FE\u5569\u{22B43}\u9C72\u{22EB3}\u519A\u34DF\u{20DA7}\u51A7\u544D\u551E\u5513\u7666\u8E2D\u{2688A}\u75B1\u80B6\u8804\u8786\u88C7\u81B6\u841C\u{210C1}\u44EC\u7304\u{24706}\u5B90\u830B\u{26893}\u567B\u{226F4}\u{27D2F}\u{241A3}\u{27D73}\u{26ED0}\u{272B6}\u9170\u{211D9}\u9208\u{23CFC}\u{2A6A9}\u{20EAC}\u{20EF9}\u7266\u{21CA2}\u474E\u{24FC2}\u{27FF9}\u{20FEB}\u40FA"],
      ["9ea1", "\u9C5D\u651F\u{22DA0}\u48F3\u{247E0}\u{29D7C}\u{20FEC}\u{20E0A}\u6062\u{275A3}\u{20FED}"],
      ["9ead", "\u{26048}\u{21187}\u71A3\u7E8E\u9D50\u4E1A\u4E04\u3577\u5B0D\u6CB2\u5367\u36AC\u39DC\u537D\u36A5\u{24618}\u589A\u{24B6E}\u822D\u544B\u57AA\u{25A95}\u{20979}"],
      ["9ec5", "\u3A52\u{22465}\u7374\u{29EAC}\u4D09\u9BED\u{23CFE}\u{29F30}\u4C5B\u{24FA9}\u{2959E}\u{29FDE}\u845C\u{23DB6}\u{272B2}\u{267B3}\u{23720}\u632E\u7D25\u{23EF7}\u{23E2C}\u3A2A\u9008\u52CC\u3E74\u367A\u45E9\u{2048E}\u7640\u5AF0\u{20EB6}\u787A\u{27F2E}\u58A7\u40BF\u567C\u9B8B\u5D74\u7654\u{2A434}\u9E85\u4CE1\u75F9\u37FB\u6119\u{230DA}\u{243F2}"],
      ["9ef5", "\u565D\u{212A9}\u57A7\u{24963}\u{29E06}\u5234\u{270AE}\u35AD\u6C4A\u9D7C"],
      ["9f40", "\u7C56\u9B39\u57DE\u{2176C}\u5C53\u64D3\u{294D0}\u{26335}\u{27164}\u86AD\u{20D28}\u{26D22}\u{24AE2}\u{20D71}"],
      ["9f4f", "\u51FE\u{21F0F}\u5D8E\u9703\u{21DD1}\u9E81\u904C\u7B1F\u9B02\u5CD1\u7BA3\u6268\u6335\u9AFF\u7BCF\u9B2A\u7C7E\u9B2E\u7C42\u7C86\u9C15\u7BFC\u9B09\u9F17\u9C1B\u{2493E}\u9F5A\u5573\u5BC3\u4FFD\u9E98\u4FF2\u5260\u3E06\u52D1\u5767\u5056\u59B7\u5E12\u97C8\u9DAB\u8F5C\u5469\u97B4\u9940\u97BA\u532C\u6130"],
      ["9fa1", "\u692C\u53DA\u9C0A\u9D02\u4C3B\u9641\u6980\u50A6\u7546\u{2176D}\u99DA\u5273"],
      ["9fae", "\u9159\u9681\u915C"],
      ["9fb2", "\u9151\u{28E97}\u637F\u{26D23}\u6ACA\u5611\u918E\u757A\u6285\u{203FC}\u734F\u7C70\u{25C21}\u{23CFD}"],
      ["9fc1", "\u{24919}\u76D6\u9B9D\u4E2A\u{20CD4}\u83BE\u8842"],
      ["9fc9", "\u5C4A\u69C0\u50ED\u577A\u521F\u5DF5\u4ECE\u6C31\u{201F2}\u4F39\u549C\u54DA\u529A\u8D82\u35FE\u5F0C\u35F3"],
      ["9fdb", "\u6B52\u917C\u9FA5\u9B97\u982E\u98B4\u9ABA\u9EA8\u9E84\u717A\u7B14"],
      ["9fe7", "\u6BFA\u8818\u7F78"],
      ["9feb", "\u5620\u{2A64A}\u8E77\u9F53"],
      ["9ff0", "\u8DD4\u8E4F\u9E1C\u8E01\u6282\u{2837D}\u8E28\u8E75\u7AD3\u{24A77}\u7A3E\u78D8\u6CEA\u8A67\u7607"],
      ["a040", "\u{28A5A}\u9F26\u6CCE\u87D6\u75C3\u{2A2B2}\u7853\u{2F840}\u8D0C\u72E2\u7371\u8B2D\u7302\u74F1\u8CEB\u{24ABB}\u862F\u5FBA\u88A0\u44B7"],
      ["a055", "\u{2183B}\u{26E05}"],
      ["a058", "\u8A7E\u{2251B}"],
      ["a05b", "\u60FD\u7667\u9AD7\u9D44\u936E\u9B8F\u87F5"],
      ["a063", "\u880F\u8CF7\u732C\u9721\u9BB0\u35D6\u72B2\u4C07\u7C51\u994A\u{26159}\u6159\u4C04\u9E96\u617D"],
      ["a073", "\u575F\u616F\u62A6\u6239\u62CE\u3A5C\u61E2\u53AA\u{233F5}\u6364\u6802\u35D2"],
      ["a0a1", "\u5D57\u{28BC2}\u8FDA\u{28E39}"],
      ["a0a6", "\u50D9\u{21D46}\u7906\u5332\u9638\u{20F3B}\u4065"],
      ["a0ae", "\u77FE"],
      ["a0b0", "\u7CC2\u{25F1A}\u7CDA\u7A2D\u8066\u8063\u7D4D\u7505\u74F2\u8994\u821A\u670C\u8062\u{27486}\u805B\u74F0\u8103\u7724\u8989\u{267CC}\u7553\u{26ED1}\u87A9\u87CE\u81C8\u878C\u8A49\u8CAD\u8B43\u772B\u74F8\u84DA\u3635\u69B2\u8DA6"],
      ["a0d4", "\u89A9\u7468\u6DB9\u87C1\u{24011}\u74E7\u3DDB\u7176\u60A4\u619C\u3CD1\u7162\u6077"],
      ["a0e2", "\u7F71\u{28B2D}\u7250\u60E9\u4B7E\u5220\u3C18\u{23CC7}\u{25ED7}\u{27656}\u{25531}\u{21944}\u{212FE}\u{29903}\u{26DDC}\u{270AD}\u5CC1\u{261AD}\u{28A0F}\u{23677}\u{200EE}\u{26846}\u{24F0E}\u4562\u5B1F\u{2634C}\u9F50\u9EA6\u{2626B}"],
      ["a3c0", "\u2400", 31, "\u2421"],
      ["c6a1", "\u2460", 9, "\u2474", 9, "\u2170", 9, "\u4E36\u4E3F\u4E85\u4EA0\u5182\u5196\u51AB\u52F9\u5338\u5369\u53B6\u590A\u5B80\u5DDB\u2F33\u5E7F\u5EF4\u5F50\u5F61\u6534\u65E0\u7592\u7676\u8FB5\u96B6\xA8\u02C6\u30FD\u30FE\u309D\u309E\u3003\u4EDD\u3005\u3006\u3007\u30FC\uFF3B\uFF3D\u273D\u3041", 23],
      ["c740", "\u3059", 58, "\u30A1\u30A2\u30A3\u30A4"],
      ["c7a1", "\u30A5", 81, "\u0410", 5, "\u0401\u0416", 4],
      ["c840", "\u041B", 26, "\u0451\u0436", 25, "\u21E7\u21B8\u21B9\u31CF\u{200CC}\u4E5A\u{2008A}\u5202\u4491"],
      ["c8a1", "\u9FB0\u5188\u9FB1\u{27607}"],
      ["c8cd", "\uFFE2\uFFE4\uFF07\uFF02\u3231\u2116\u2121\u309B\u309C\u2E80\u2E84\u2E86\u2E87\u2E88\u2E8A\u2E8C\u2E8D\u2E95\u2E9C\u2E9D\u2EA5\u2EA7\u2EAA\u2EAC\u2EAE\u2EB6\u2EBC\u2EBE\u2EC6\u2ECA\u2ECC\u2ECD\u2ECF\u2ED6\u2ED7\u2EDE\u2EE3"],
      ["c8f5", "\u0283\u0250\u025B\u0254\u0275\u0153\xF8\u014B\u028A\u026A"],
      ["f9fe", "\uFFED"],
      ["fa40", "\u{20547}\u92DB\u{205DF}\u{23FC5}\u854C\u42B5\u73EF\u51B5\u3649\u{24942}\u{289E4}\u9344\u{219DB}\u82EE\u{23CC8}\u783C\u6744\u62DF\u{24933}\u{289AA}\u{202A0}\u{26BB3}\u{21305}\u4FAB\u{224ED}\u5008\u{26D29}\u{27A84}\u{23600}\u{24AB1}\u{22513}\u5029\u{2037E}\u5FA4\u{20380}\u{20347}\u6EDB\u{2041F}\u507D\u5101\u347A\u510E\u986C\u3743\u8416\u{249A4}\u{20487}\u5160\u{233B4}\u516A\u{20BFF}\u{220FC}\u{202E5}\u{22530}\u{2058E}\u{23233}\u{21983}\u5B82\u877D\u{205B3}\u{23C99}\u51B2\u51B8"],
      ["faa1", "\u9D34\u51C9\u51CF\u51D1\u3CDC\u51D3\u{24AA6}\u51B3\u51E2\u5342\u51ED\u83CD\u693E\u{2372D}\u5F7B\u520B\u5226\u523C\u52B5\u5257\u5294\u52B9\u52C5\u7C15\u8542\u52E0\u860D\u{26B13}\u5305\u{28ADE}\u5549\u6ED9\u{23F80}\u{20954}\u{23FEC}\u5333\u5344\u{20BE2}\u6CCB\u{21726}\u681B\u73D5\u604A\u3EAA\u38CC\u{216E8}\u71DD\u44A2\u536D\u5374\u{286AB}\u537E\u537F\u{21596}\u{21613}\u77E6\u5393\u{28A9B}\u53A0\u53AB\u53AE\u73A7\u{25772}\u3F59\u739C\u53C1\u53C5\u6C49\u4E49\u57FE\u53D9\u3AAB\u{20B8F}\u53E0\u{23FEB}\u{22DA3}\u53F6\u{20C77}\u5413\u7079\u552B\u6657\u6D5B\u546D\u{26B53}\u{20D74}\u555D\u548F\u54A4\u47A6\u{2170D}\u{20EDD}\u3DB4\u{20D4D}"],
      ["fb40", "\u{289BC}\u{22698}\u5547\u4CED\u542F\u7417\u5586\u55A9\u5605\u{218D7}\u{2403A}\u4552\u{24435}\u66B3\u{210B4}\u5637\u66CD\u{2328A}\u66A4\u66AD\u564D\u564F\u78F1\u56F1\u9787\u53FE\u5700\u56EF\u56ED\u{28B66}\u3623\u{2124F}\u5746\u{241A5}\u6C6E\u708B\u5742\u36B1\u{26C7E}\u57E6\u{21416}\u5803\u{21454}\u{24363}\u5826\u{24BF5}\u585C\u58AA\u3561\u58E0\u58DC\u{2123C}\u58FB\u5BFF\u5743\u{2A150}\u{24278}\u93D3\u35A1\u591F\u68A6\u36C3\u6E59"],
      ["fba1", "\u{2163E}\u5A24\u5553\u{21692}\u8505\u59C9\u{20D4E}\u{26C81}\u{26D2A}\u{217DC}\u59D9\u{217FB}\u{217B2}\u{26DA6}\u6D71\u{21828}\u{216D5}\u59F9\u{26E45}\u5AAB\u5A63\u36E6\u{249A9}\u5A77\u3708\u5A96\u7465\u5AD3\u{26FA1}\u{22554}\u3D85\u{21911}\u3732\u{216B8}\u5E83\u52D0\u5B76\u6588\u5B7C\u{27A0E}\u4004\u485D\u{20204}\u5BD5\u6160\u{21A34}\u{259CC}\u{205A5}\u5BF3\u5B9D\u4D10\u5C05\u{21B44}\u5C13\u73CE\u5C14\u{21CA5}\u{26B28}\u5C49\u48DD\u5C85\u5CE9\u5CEF\u5D8B\u{21DF9}\u{21E37}\u5D10\u5D18\u5D46\u{21EA4}\u5CBA\u5DD7\u82FC\u382D\u{24901}\u{22049}\u{22173}\u8287\u3836\u3BC2\u5E2E\u6A8A\u5E75\u5E7A\u{244BC}\u{20CD3}\u53A6\u4EB7\u5ED0\u53A8\u{21771}\u5E09\u5EF4\u{28482}"],
      ["fc40", "\u5EF9\u5EFB\u38A0\u5EFC\u683E\u941B\u5F0D\u{201C1}\u{2F894}\u3ADE\u48AE\u{2133A}\u5F3A\u{26888}\u{223D0}\u5F58\u{22471}\u5F63\u97BD\u{26E6E}\u5F72\u9340\u{28A36}\u5FA7\u5DB6\u3D5F\u{25250}\u{21F6A}\u{270F8}\u{22668}\u91D6\u{2029E}\u{28A29}\u6031\u6685\u{21877}\u3963\u3DC7\u3639\u5790\u{227B4}\u7971\u3E40\u609E\u60A4\u60B3\u{24982}\u{2498F}\u{27A53}\u74A4\u50E1\u5AA0\u6164\u8424\u6142\u{2F8A6}\u{26ED2}\u6181\u51F4\u{20656}\u6187\u5BAA\u{23FB7}"],
      ["fca1", "\u{2285F}\u61D3\u{28B9D}\u{2995D}\u61D0\u3932\u{22980}\u{228C1}\u6023\u615C\u651E\u638B\u{20118}\u62C5\u{21770}\u62D5\u{22E0D}\u636C\u{249DF}\u3A17\u6438\u63F8\u{2138E}\u{217FC}\u6490\u6F8A\u{22E36}\u9814\u{2408C}\u{2571D}\u64E1\u64E5\u947B\u3A66\u643A\u3A57\u654D\u6F16\u{24A28}\u{24A23}\u6585\u656D\u655F\u{2307E}\u65B5\u{24940}\u4B37\u65D1\u40D8\u{21829}\u65E0\u65E3\u5FDF\u{23400}\u6618\u{231F7}\u{231F8}\u6644\u{231A4}\u{231A5}\u664B\u{20E75}\u6667\u{251E6}\u6673\u6674\u{21E3D}\u{23231}\u{285F4}\u{231C8}\u{25313}\u77C5\u{228F7}\u99A4\u6702\u{2439C}\u{24A21}\u3B2B\u69FA\u{237C2}\u675E\u6767\u6762\u{241CD}\u{290ED}\u67D7\u44E9\u6822\u6E50\u923C\u6801\u{233E6}\u{26DA0}\u685D"],
      ["fd40", "\u{2346F}\u69E1\u6A0B\u{28ADF}\u6973\u68C3\u{235CD}\u6901\u6900\u3D32\u3A01\u{2363C}\u3B80\u67AC\u6961\u{28A4A}\u42FC\u6936\u6998\u3BA1\u{203C9}\u8363\u5090\u69F9\u{23659}\u{2212A}\u6A45\u{23703}\u6A9D\u3BF3\u67B1\u6AC8\u{2919C}\u3C0D\u6B1D\u{20923}\u60DE\u6B35\u6B74\u{227CD}\u6EB5\u{23ADB}\u{203B5}\u{21958}\u3740\u5421\u{23B5A}\u6BE1\u{23EFC}\u6BDC\u6C37\u{2248B}\u{248F1}\u{26B51}\u6C5A\u8226\u6C79\u{23DBC}\u44C5\u{23DBD}\u{241A4}\u{2490C}\u{24900}"],
      ["fda1", "\u{23CC9}\u36E5\u3CEB\u{20D32}\u9B83\u{231F9}\u{22491}\u7F8F\u6837\u{26D25}\u{26DA1}\u{26DEB}\u6D96\u6D5C\u6E7C\u6F04\u{2497F}\u{24085}\u{26E72}\u8533\u{26F74}\u51C7\u6C9C\u6E1D\u842E\u{28B21}\u6E2F\u{23E2F}\u7453\u{23F82}\u79CC\u6E4F\u5A91\u{2304B}\u6FF8\u370D\u6F9D\u{23E30}\u6EFA\u{21497}\u{2403D}\u4555\u93F0\u6F44\u6F5C\u3D4E\u6F74\u{29170}\u3D3B\u6F9F\u{24144}\u6FD3\u{24091}\u{24155}\u{24039}\u{23FF0}\u{23FB4}\u{2413F}\u51DF\u{24156}\u{24157}\u{24140}\u{261DD}\u704B\u707E\u70A7\u7081\u70CC\u70D5\u70D6\u70DF\u4104\u3DE8\u71B4\u7196\u{24277}\u712B\u7145\u5A88\u714A\u716E\u5C9C\u{24365}\u714F\u9362\u{242C1}\u712C\u{2445A}\u{24A27}\u{24A22}\u71BA\u{28BE8}\u70BD\u720E"],
      ["fe40", "\u9442\u7215\u5911\u9443\u7224\u9341\u{25605}\u722E\u7240\u{24974}\u68BD\u7255\u7257\u3E55\u{23044}\u680D\u6F3D\u7282\u732A\u732B\u{24823}\u{2882B}\u48ED\u{28804}\u7328\u732E\u73CF\u73AA\u{20C3A}\u{26A2E}\u73C9\u7449\u{241E2}\u{216E7}\u{24A24}\u6623\u36C5\u{249B7}\u{2498D}\u{249FB}\u73F7\u7415\u6903\u{24A26}\u7439\u{205C3}\u3ED7\u745C\u{228AD}\u7460\u{28EB2}\u7447\u73E4\u7476\u83B9\u746C\u3730\u7474\u93F1\u6A2C\u7482\u4953\u{24A8C}"],
      ["fea1", "\u{2415F}\u{24A79}\u{28B8F}\u5B46\u{28C03}\u{2189E}\u74C8\u{21988}\u750E\u74E9\u751E\u{28ED9}\u{21A4B}\u5BD7\u{28EAC}\u9385\u754D\u754A\u7567\u756E\u{24F82}\u3F04\u{24D13}\u758E\u745D\u759E\u75B4\u7602\u762C\u7651\u764F\u766F\u7676\u{263F5}\u7690\u81EF\u37F8\u{26911}\u{2690E}\u76A1\u76A5\u76B7\u76CC\u{26F9F}\u8462\u{2509D}\u{2517D}\u{21E1C}\u771E\u7726\u7740\u64AF\u{25220}\u7758\u{232AC}\u77AF\u{28964}\u{28968}\u{216C1}\u77F4\u7809\u{21376}\u{24A12}\u68CA\u78AF\u78C7\u78D3\u96A5\u792E\u{255E0}\u78D7\u7934\u78B1\u{2760C}\u8FB8\u8884\u{28B2B}\u{26083}\u{2261C}\u7986\u8900\u6902\u7980\u{25857}\u799D\u{27B39}\u793C\u79A9\u6E2A\u{27126}\u3EA8\u79C6\u{2910D}\u79D4"]
    ];
  }
});

// node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS({
  "node_modules/iconv-lite/encodings/dbcs-data.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // == Japanese/ShiftJIS ====================================================
      // All japanese encodings are based on JIS X set of standards:
      // JIS X 0201 - Single-byte encoding of ASCII + ¥ + Kana chars at 0xA1-0xDF.
      // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
      //              Has several variations in 1978, 1983, 1990 and 1997.
      // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
      // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
      //              2 planes, first is superset of 0208, second - revised 0212.
      //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
      // Byte encodings are:
      //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
      //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
      //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
      //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
      //               0x00-0x7F       - lower part of 0201
      //               0x8E, 0xA1-0xDF - upper part of 0201
      //               (0xA1-0xFE)x2   - 0208 plane (94x94).
      //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
      //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
      //               Used as-is in ISO2022 family.
      //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
      //                0201-1976 Roman, 0208-1978, 0208-1983.
      //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
      //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
      //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
      //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
      //
      // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
      //
      // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
      "shiftjis": {
        type: "_dbcs",
        table: function() {
          return require_shiftjis();
        },
        encodeAdd: { "\xA5": 92, "\u203E": 126 },
        encodeSkipVals: [{ from: 60736, to: 63808 }]
      },
      "csshiftjis": "shiftjis",
      "mskanji": "shiftjis",
      "sjis": "shiftjis",
      "windows31j": "shiftjis",
      "ms31j": "shiftjis",
      "xsjis": "shiftjis",
      "windows932": "shiftjis",
      "ms932": "shiftjis",
      "932": "shiftjis",
      "cp932": "shiftjis",
      "eucjp": {
        type: "_dbcs",
        table: function() {
          return require_eucjp();
        },
        encodeAdd: { "\xA5": 92, "\u203E": 126 }
      },
      // TODO: KDDI extension to Shift_JIS
      // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
      // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
      // == Chinese/GBK ==========================================================
      // http://en.wikipedia.org/wiki/GBK
      // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
      // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
      "gb2312": "cp936",
      "gb231280": "cp936",
      "gb23121980": "cp936",
      "csgb2312": "cp936",
      "csiso58gb231280": "cp936",
      "euccn": "cp936",
      // Microsoft's CP936 is a subset and approximation of GBK.
      "windows936": "cp936",
      "ms936": "cp936",
      "936": "cp936",
      "cp936": {
        type: "_dbcs",
        table: function() {
          return require_cp936();
        }
      },
      // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
      "gbk": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        }
      },
      "xgbk": "gbk",
      "isoir58": "gbk",
      // GB18030 is an algorithmic extension of GBK.
      // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
      // http://icu-project.org/docs/papers/gb18030.html
      // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
      // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
      "gb18030": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        },
        gb18030: function() {
          return require_gb18030_ranges();
        },
        encodeSkipVals: [128],
        encodeAdd: { "\u20AC": 41699 }
      },
      "chinese": "gb18030",
      // == Korean ===============================================================
      // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
      "windows949": "cp949",
      "ms949": "cp949",
      "949": "cp949",
      "cp949": {
        type: "_dbcs",
        table: function() {
          return require_cp949();
        }
      },
      "cseuckr": "cp949",
      "csksc56011987": "cp949",
      "euckr": "cp949",
      "isoir149": "cp949",
      "korean": "cp949",
      "ksc56011987": "cp949",
      "ksc56011989": "cp949",
      "ksc5601": "cp949",
      // == Big5/Taiwan/Hong Kong ================================================
      // There are lots of tables for Big5 and cp950. Please see the following links for history:
      // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
      // Variations, in roughly number of defined chars:
      //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
      //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
      //  * Big5-2003 (Taiwan standard) almost superset of cp950.
      //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
      //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
      //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
      //    Plus, it has 4 combining sequences.
      //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
      //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
      //    Implementations are not consistent within browsers; sometimes labeled as just big5.
      //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
      //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
      //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
      //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
      //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
      // 
      // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
      // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
      "windows950": "cp950",
      "ms950": "cp950",
      "950": "cp950",
      "cp950": {
        type: "_dbcs",
        table: function() {
          return require_cp950();
        }
      },
      // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
      "big5": "big5hkscs",
      "big5hkscs": {
        type: "_dbcs",
        table: function() {
          return require_cp950().concat(require_big5_added());
        },
        encodeSkipVals: [
          // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
          // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
          // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
          36457,
          36463,
          36478,
          36523,
          36532,
          36557,
          36560,
          36695,
          36713,
          36718,
          36811,
          36862,
          36973,
          36986,
          37060,
          37084,
          37105,
          37311,
          37551,
          37552,
          37553,
          37554,
          37585,
          37959,
          38090,
          38361,
          38652,
          39285,
          39798,
          39800,
          39803,
          39878,
          39902,
          39916,
          39926,
          40002,
          40019,
          40034,
          40040,
          40043,
          40055,
          40124,
          40125,
          40144,
          40279,
          40282,
          40388,
          40431,
          40443,
          40617,
          40687,
          40701,
          40800,
          40907,
          41079,
          41180,
          41183,
          36812,
          37576,
          38468,
          38637,
          // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
          41636,
          41637,
          41639,
          41638,
          41676,
          41678
        ]
      },
      "cnbig5": "big5hkscs",
      "csbig5": "big5hkscs",
      "xxbig5": "big5hkscs"
    };
  }
});

// node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS({
  "node_modules/iconv-lite/encodings/index.js"(exports2, module2) {
    "use strict";
    var modules = [
      require_internal(),
      require_utf32(),
      require_utf16(),
      require_utf7(),
      require_sbcs_codec(),
      require_sbcs_data(),
      require_sbcs_data_generated(),
      require_dbcs_codec(),
      require_dbcs_data()
    ];
    for (i = 0; i < modules.length; i++) {
      module2 = modules[i];
      for (enc in module2)
        if (Object.prototype.hasOwnProperty.call(module2, enc))
          exports2[enc] = module2[enc];
    }
    var module2;
    var enc;
    var i;
  }
});

// node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS({
  "node_modules/iconv-lite/lib/streams.js"(exports2, module2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    module2.exports = function(stream_module) {
      var Transform2 = stream_module.Transform;
      function IconvLiteEncoderStream(conv, options2) {
        this.conv = conv;
        options2 = options2 || {};
        options2.decodeStrings = false;
        Transform2.call(this, options2);
      }
      IconvLiteEncoderStream.prototype = Object.create(Transform2.prototype, {
        constructor: { value: IconvLiteEncoderStream }
      });
      IconvLiteEncoderStream.prototype._transform = function(chunk, encoding2, done) {
        if (typeof chunk != "string")
          return done(new Error("Iconv encoding stream needs strings as its input."));
        try {
          var res = this.conv.write(chunk);
          if (res && res.length) this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteEncoderStream.prototype._flush = function(done) {
        try {
          var res = this.conv.end();
          if (res && res.length) this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteEncoderStream.prototype.collect = function(cb) {
        var chunks = [];
        this.on("error", cb);
        this.on("data", function(chunk) {
          chunks.push(chunk);
        });
        this.on("end", function() {
          cb(null, Buffer3.concat(chunks));
        });
        return this;
      };
      function IconvLiteDecoderStream(conv, options2) {
        this.conv = conv;
        options2 = options2 || {};
        options2.encoding = this.encoding = "utf8";
        Transform2.call(this, options2);
      }
      IconvLiteDecoderStream.prototype = Object.create(Transform2.prototype, {
        constructor: { value: IconvLiteDecoderStream }
      });
      IconvLiteDecoderStream.prototype._transform = function(chunk, encoding2, done) {
        if (!Buffer3.isBuffer(chunk) && !(chunk instanceof Uint8Array))
          return done(new Error("Iconv decoding stream needs buffers as its input."));
        try {
          var res = this.conv.write(chunk);
          if (res && res.length) this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteDecoderStream.prototype._flush = function(done) {
        try {
          var res = this.conv.end();
          if (res && res.length) this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteDecoderStream.prototype.collect = function(cb) {
        var res = "";
        this.on("error", cb);
        this.on("data", function(chunk) {
          res += chunk;
        });
        this.on("end", function() {
          cb(null, res);
        });
        return this;
      };
      return {
        IconvLiteEncoderStream,
        IconvLiteDecoderStream
      };
    };
  }
});

// node_modules/iconv-lite/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/iconv-lite/lib/index.js"(exports2, module2) {
    "use strict";
    var Buffer3 = require_safer().Buffer;
    var bomHandling = require_bom_handling();
    var iconv2 = module2.exports;
    iconv2.encodings = null;
    iconv2.defaultCharUnicode = "\uFFFD";
    iconv2.defaultCharSingleByte = "?";
    iconv2.encode = function encode(str, encoding2, options2) {
      str = "" + (str || "");
      var encoder = iconv2.getEncoder(encoding2, options2);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer3.concat([res, trail]) : res;
    };
    iconv2.decode = function decode(buf, encoding2, options2) {
      if (typeof buf === "string") {
        if (!iconv2.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv2.skipDecodeWarning = true;
        }
        buf = Buffer3.from("" + (buf || ""), "binary");
      }
      var decoder = iconv2.getDecoder(encoding2, options2);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv2.encodingExists = function encodingExists(enc) {
      try {
        iconv2.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv2.toEncoding = iconv2.encode;
    iconv2.fromEncoding = iconv2.decode;
    iconv2._codecDataCache = {};
    iconv2.getCodec = function getCodec(encoding2) {
      if (!iconv2.encodings)
        iconv2.encodings = require_encodings();
      var enc = iconv2._canonicalizeEncoding(encoding2);
      var codecOptions = {};
      while (true) {
        var codec = iconv2._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv2.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv2);
            iconv2._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding2 + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv2._canonicalizeEncoding = function(encoding2) {
      return ("" + encoding2).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv2.getEncoder = function getEncoder(encoding2, options2) {
      var codec = iconv2.getCodec(encoding2), encoder = new codec.encoder(options2, codec);
      if (codec.bomAware && options2 && options2.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options2);
      return encoder;
    };
    iconv2.getDecoder = function getDecoder(encoding2, options2) {
      var codec = iconv2.getCodec(encoding2), decoder = new codec.decoder(options2, codec);
      if (codec.bomAware && !(options2 && options2.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options2);
      return decoder;
    };
    iconv2.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
      if (iconv2.supportsStreams)
        return;
      var streams = require_streams()(stream_module2);
      iconv2.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
      iconv2.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
      iconv2.encodeStream = function encodeStream(encoding2, options2) {
        return new iconv2.IconvLiteEncoderStream(iconv2.getEncoder(encoding2, options2), options2);
      };
      iconv2.decodeStream = function decodeStream(encoding2, options2) {
        return new iconv2.IconvLiteDecoderStream(iconv2.getDecoder(encoding2, options2), options2);
      };
      iconv2.supportsStreams = true;
    };
    var stream_module;
    try {
      stream_module = require("stream");
    } catch (e) {
    }
    if (stream_module && stream_module.Transform) {
      iconv2.enableStreamingAPI(stream_module);
    } else {
      iconv2.encodeStream = iconv2.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
    if (false) {
      console.error("iconv-lite warning: js files use non-utf8 encoding. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
    }
  }
});

// src/util/lodash.ts
function omit(obj, properties) {
  let o = {};
  for (let key of Object.keys(obj)) {
    if (!properties.includes(key)) {
      o[key] = obj[key];
    }
  }
  return o;
}
var objectProto, hasOwnProperty3;
var init_lodash = __esm({
  "src/util/lodash.ts"() {
    "use strict";
    objectProto = Object.prototype;
    hasOwnProperty3 = objectProto.hasOwnProperty;
  }
});

// src/util/processes.ts
function isRunning(pid) {
  try {
    let res = process.kill(pid, 0);
    return res == true;
  } catch (e) {
    return e["code"] === "EPERM";
  }
}
function executable(command) {
  try {
    which.sync(command);
  } catch (e) {
    return false;
  }
  return true;
}
function runCommand(cmd, opts = {}, timeout2, isWindows2 = platform === 3 /* Windows */) {
  if (!isWindows2) {
    opts.shell = opts.shell || process.env.SHELL;
  }
  opts.maxBuffer = opts.maxBuffer ?? 500 * 1024;
  let encoding2 = opts.encoding || "utf8";
  encoding2 = import_iconv_lite.default.encodingExists(encoding2) ? encoding2 : "utf8";
  return new Promise((resolve, reject) => {
    let disposable;
    let cp;
    if (typeof timeout2 === "number") {
      let timer = setTimeout(() => {
        terminate(cp);
        reject(new CancellationError());
      }, timeout2 * 1e3);
      disposable = import_node4.Disposable.create(() => {
        clearTimeout(timer);
      });
    } else if (import_node4.CancellationToken.is(timeout2)) {
      disposable = timeout2.onCancellationRequested(() => {
        terminate(cp);
        reject(new CancellationError());
      });
    }
    cp = child_process.exec(cmd, { ...omit(opts, ["encoding"]), encoding: "buffer" }, (err, stdout, stderr) => {
      if (disposable) disposable.dispose();
      if (err) {
        reject(new Error(`exited with ${err.code}
${err}
${stderr.toString("utf8")}`));
        return;
      }
      resolve(import_iconv_lite.default.decode(stdout, encoding2));
    });
  });
}
function terminate(process2, cwd2, pt = platform) {
  if (process2.killed) return;
  if (pt === 3 /* Windows */) {
    try {
      let options2 = {
        stdio: ["pipe", "pipe", "ignore"]
      };
      if (cwd2) options2.cwd = cwd2;
      child_process.execFileSync(
        "taskkill",
        ["/T", "/F", "/PID", process2.pid.toString()],
        options2
      );
      return true;
    } catch (err) {
      return false;
    }
  } else if (pt === 2 /* Linux */ || pt === 1 /* Mac */) {
    try {
      let filepath = path.join(pluginRoot, "bin/terminateProcess.sh");
      let result = child_process.spawnSync(filepath, [process2.pid.toString()]);
      return result.error ? false : true;
    } catch (err) {
      return false;
    }
  } else {
    process2.kill("SIGKILL");
    return true;
  }
}
var import_iconv_lite;
var init_processes = __esm({
  "src/util/processes.ts"() {
    "use strict";
    init_constants();
    init_errors();
    init_node();
    init_platform();
    import_iconv_lite = __toESM(require_lib3());
    init_protocol();
    init_lodash();
  }
});

// src/model/resolver.ts
var import_strip_ansi, Resolver;
var init_resolver = __esm({
  "src/model/resolver.ts"() {
    "use strict";
    init_node();
    init_fs();
    init_processes();
    import_strip_ansi = __toESM(require_strip_ansi());
    Resolver = class {
      get nodeFolder() {
        if (!executable("npm")) return Promise.resolve("");
        if (this._npmFolder) return Promise.resolve(this._npmFolder);
        return runCommand("npm --loglevel silent root -g", {}, 3e3).then((root) => {
          this._npmFolder = (0, import_strip_ansi.default)(root).trim();
          return this._npmFolder;
        });
      }
      get yarnFolder() {
        if (!executable("yarnpkg")) return Promise.resolve("");
        if (this._yarnFolder) return Promise.resolve(this._yarnFolder);
        return runCommand("yarnpkg global dir", {}, 3e3).then((root) => {
          let folder = path.join((0, import_strip_ansi.default)(root).trim(), "node_modules");
          let exists = fs.existsSync(folder);
          if (exists) this._yarnFolder = folder;
          return exists ? folder : "";
        });
      }
      async resolveModule(mod) {
        let nodeFolder = await this.nodeFolder;
        let yarnFolder = await this.yarnFolder;
        if (yarnFolder) {
          let s = await statAsync(path.join(yarnFolder, mod, "package.json"));
          if (s && s.isFile()) return path.join(yarnFolder, mod);
        }
        if (nodeFolder) {
          let s = await statAsync(path.join(nodeFolder, mod, "package.json"));
          if (s && s.isFile()) return path.join(nodeFolder, mod);
        }
        return null;
      }
    };
  }
});

// src/core/funcs.ts
function has(env, feature) {
  if (!feature.startsWith("nvim-") && !feature.startsWith("patch-")) {
    throw new Error("Feature param could only starts with nvim and patch");
  }
  if (!env.isVim && feature.startsWith("patch-")) {
    return false;
  }
  if (env.isVim && feature.startsWith("nvim-")) {
    return false;
  }
  if (env.isVim) {
    let [_, major, minor, patch] = env.version.match(/^(\d)(\d{2})(\d+)$/);
    let version2 = `${major}.${parseInt(minor, 10)}.${parseInt(patch, 10)}`;
    return semver.gte(version2, feature.slice(6));
  }
  return semver.gte(env.version, feature.slice(5));
}
async function callAsync(nvim, method, args) {
  if (!isVim) return await nvim.call(method, args);
  return await nvim.callAsync("coc#util#with_callback", [method, args]);
}
function createNameSpace(name2) {
  if (namespaceMap.has(name2)) return namespaceMap.get(name2);
  NAME_SPACE = NAME_SPACE + 1;
  namespaceMap.set(name2, NAME_SPACE);
  return NAME_SPACE;
}
function getWatchmanPath(configurations) {
  const watchmanPath = configurations.initialConfiguration.get("coc.preferences.watchmanPath", "watchman");
  return which.sync(watchmanPath, { nothrow: true });
}
async function findUp2(nvim, cwd2, filename) {
  let filepath = await nvim.call("coc#util#get_fullpath");
  filepath = path.normalize(filepath);
  let isFile2 = filepath && path.isAbsolute(filepath);
  if (isFile2 && !isParentFolder(cwd2, filepath, true)) {
    return findUp(filename, path.dirname(filepath));
  }
  let res = findUp(filename, cwd2);
  if (res && res != os.homedir()) return res;
  if (isFile2) return findUp(filename, path.dirname(filepath));
  return null;
}
function resolveModule(name2) {
  return resolver.resolveModule(name2);
}
function score(selector, uri, languageId, caseInsensitive = isWindows || isMacintosh) {
  if (Array.isArray(selector)) {
    let ret = 0;
    for (const filter2 of selector) {
      const value = score(filter2, uri, languageId);
      if (value === 10) {
        return value;
      }
      if (value > ret) {
        ret = value;
      }
    }
    return ret;
  } else if (typeof selector === "string") {
    if (selector === "*") {
      return 5;
    } else if (selector === languageId) {
      return 10;
    } else {
      return 0;
    }
  } else if (selector && import_node4.TextDocumentFilter.is(selector)) {
    let u = URI2.parse(uri);
    const { language, pattern, scheme } = selector;
    let ret = 0;
    if (scheme) {
      if (scheme === u.scheme) {
        ret = 5;
      } else if (scheme === "*") {
        ret = 3;
      } else {
        return 0;
      }
    }
    if (language) {
      if (language === languageId) {
        ret = 10;
      } else if (language === "*") {
        ret = Math.max(ret, 5);
      } else {
        return 0;
      }
    }
    if (pattern) {
      let p = caseInsensitive ? pattern.toLowerCase() : pattern;
      let f = caseInsensitive ? u.fsPath.toLowerCase() : u.fsPath;
      if (p === f || minimatch(f, p, { dot: true })) {
        ret = Math.max(ret, 5);
      } else {
        return 0;
      }
    }
    return ret;
  } else {
    return 0;
  }
}
var NAME_SPACE, resolver, namespaceMap;
var init_funcs = __esm({
  "src/core/funcs.ts"() {
    "use strict";
    init_esm();
    init_resolver();
    init_constants();
    init_fs();
    init_node();
    init_platform();
    init_protocol();
    NAME_SPACE = 2e3;
    resolver = new Resolver();
    namespaceMap = /* @__PURE__ */ new Map();
  }
});

// node_modules/marked/lib/marked.esm.js
function _getDefaults() {
  return {
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: false,
    headerPrefix: "",
    highlight: null,
    hooks: null,
    langPrefix: "language-",
    mangle: false,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
function changeDefaults(newDefaults) {
  _defaults = newDefaults;
}
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
function unescape2(html) {
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
function edit(regex2, opt) {
  regex2 = typeof regex2 === "string" ? regex2 : regex2.source;
  opt = opt || "";
  const obj = {
    replace: (name2, val) => {
      val = typeof val === "object" && "source" in val ? val.source : val;
      val = val.replace(caret, "$1");
      regex2 = regex2.replace(name2, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex2, opt);
    }
  };
  return obj;
}
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false;
    let curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (count) {
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  let level2 = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level2++;
    } else if (str[i] === b[1]) {
      level2--;
      if (level2 < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkDeprecations(opt, callback) {
  if (!opt || opt.silent) {
    return;
  }
  if (callback) {
    console.warn("marked(): callback is deprecated since version 5.0.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/using_pro#async");
  }
  if (opt.sanitize || opt.sanitizer) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
  if (opt.highlight || opt.langPrefix !== "language-") {
    console.warn("marked(): highlight and langPrefix parameters are deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-highlight.");
  }
  if (opt.mangle) {
    console.warn("marked(): mangle parameter is enabled by default, but is deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install https://www.npmjs.com/package/marked-mangle, or disable by setting `{mangle: false}`.");
  }
  if (opt.baseUrl) {
    console.warn("marked(): baseUrl parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-base-url.");
  }
  if (opt.smartypants) {
    console.warn("marked(): smartypants parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-smartypants.");
  }
  if (opt.xhtml) {
    console.warn("marked(): xhtml parameter is deprecated since version 5.0.0, should not be used and will be removed in the future. Instead use https://www.npmjs.com/package/marked-xhtml.");
  }
  if (opt.headerIds || opt.headerPrefix) {
    console.warn("marked(): headerIds and headerPrefix parameters enabled by default, but are deprecated since version 5.0.0, and will be removed in the future. To clear this warning, install  https://www.npmjs.com/package/marked-gfm-heading-id, or disable by setting `{headerIds: false}`.");
  }
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape(text)
  };
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
function smartypants(text) {
  return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
}
function mangle(text) {
  let out = "";
  for (let i = 0; i < text.length; i++) {
    const ch = Math.random() > 0.5 ? "x" + text.charCodeAt(i).toString(16) : text.charCodeAt(i).toString();
    out += "&#" + ch + ";";
  }
  return out;
}
function marked(src, opt, callback) {
  return markedInstance.parse(src, opt, callback);
}
var _defaults, escapeTest, escapeReplace, escapeTestNoEncode, escapeReplaceNoEncode, escapeReplacements, getEscapeReplacement, unescapeTest, caret, nonWordAndColonTest, originIndependentUrl, baseUrls, justDomain, protocol, domain, noopTest, _Tokenizer, block, inline, _Lexer, _Renderer, _TextRenderer, _Slugger, _Parser, _Hooks, Marked, markedInstance, options, setOptions, use, walkTokens, parseInline, parser, lexer;
var init_marked_esm = __esm({
  "node_modules/marked/lib/marked.esm.js"() {
    _defaults = _getDefaults();
    escapeTest = /[&<>"']/;
    escapeReplace = new RegExp(escapeTest.source, "g");
    escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
    escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
    escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    getEscapeReplacement = (ch) => escapeReplacements[ch];
    unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    caret = /(^|[^\[])\^/g;
    nonWordAndColonTest = /[^\w:]/g;
    originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    baseUrls = {};
    justDomain = /^[^:]+:\/*[^/]*$/;
    protocol = /^([^:]+:)[\s\S]*$/;
    domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    noopTest = { exec: () => null };
    _Tokenizer = class {
      options;
      // TODO: Fix this rules type
      rules;
      lexer;
      constructor(options2) {
        this.options = options2 || _defaults;
      }
      space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: "space",
            raw: cap[0]
          };
        }
      }
      code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text, "\n") : text
          };
        }
      }
      fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
          const raw = cap[0];
          const text = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
            text
          };
        }
      }
      heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
          let text = cap[2].trim();
          if (/#$/.test(text)) {
            const trimmed = rtrim(text, "#");
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text = trimmed.trim();
            }
          }
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text,
            tokens: this.lexer.inline(text)
          };
        }
      }
      hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      }
      blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ *>[ \t]?/gm, "");
          const top = this.lexer.state.top;
          this.lexer.state.top = true;
          const tokens = this.lexer.blockTokens(text);
          this.lexer.state.top = top;
          return {
            type: "blockquote",
            raw: cap[0],
            tokens,
            text
          };
        }
      }
      list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
          let bull = cap[1].trim();
          const isordered = bull.length > 1;
          const list2 = {
            type: "list",
            raw: "",
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
          if (this.options.pedantic) {
            bull = isordered ? bull : "[*+-]";
          }
          const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
          let raw = "";
          let itemContents = "";
          let endsWithBlankLine = false;
          while (src) {
            let endEarly = false;
            if (!(cap = itemRegex.exec(src))) {
              break;
            }
            if (this.rules.block.hr.test(src)) {
              break;
            }
            raw = cap[0];
            src = src.substring(raw.length);
            let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
            let nextLine = src.split("\n", 1)[0];
            let indent = 0;
            if (this.options.pedantic) {
              indent = 2;
              itemContents = line.trimLeft();
            } else {
              indent = cap[2].search(/[^ ]/);
              indent = indent > 4 ? 1 : indent;
              itemContents = line.slice(indent);
              indent += cap[1].length;
            }
            let blankLine = false;
            if (!line && /^ *$/.test(nextLine)) {
              raw += nextLine + "\n";
              src = src.substring(nextLine.length + 1);
              endEarly = true;
            }
            if (!endEarly) {
              const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
              const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
              const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
              const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
              while (src) {
                const rawLine = src.split("\n", 1)[0];
                nextLine = rawLine;
                if (this.options.pedantic) {
                  nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                }
                if (fencesBeginRegex.test(nextLine)) {
                  break;
                }
                if (headingBeginRegex.test(nextLine)) {
                  break;
                }
                if (nextBulletRegex.test(nextLine)) {
                  break;
                }
                if (hrRegex.test(src)) {
                  break;
                }
                if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
                  itemContents += "\n" + nextLine.slice(indent);
                } else {
                  if (blankLine) {
                    break;
                  }
                  if (line.search(/[^ ]/) >= 4) {
                    break;
                  }
                  if (fencesBeginRegex.test(line)) {
                    break;
                  }
                  if (headingBeginRegex.test(line)) {
                    break;
                  }
                  if (hrRegex.test(line)) {
                    break;
                  }
                  itemContents += "\n" + nextLine;
                }
                if (!blankLine && !nextLine.trim()) {
                  blankLine = true;
                }
                raw += rawLine + "\n";
                src = src.substring(rawLine.length + 1);
                line = nextLine.slice(indent);
              }
            }
            if (!list2.loose) {
              if (endsWithBlankLine) {
                list2.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }
            let istask = null;
            let ischecked;
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== "[ ] ";
                itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
              }
            }
            list2.items.push({
              type: "list_item",
              raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents,
              tokens: []
            });
            list2.raw += raw;
          }
          list2.items[list2.items.length - 1].raw = raw.trimRight();
          list2.items[list2.items.length - 1].text = itemContents.trimRight();
          list2.raw = list2.raw.trimRight();
          for (let i = 0; i < list2.items.length; i++) {
            this.lexer.state.top = false;
            list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
            if (!list2.loose) {
              const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
              const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
              list2.loose = hasMultipleLineBreaks;
            }
          }
          if (list2.loose) {
            for (let i = 0; i < list2.items.length; i++) {
              list2.items[i].loose = true;
            }
          }
          return list2;
        }
      }
      html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
          const token = {
            type: "html",
            block: true,
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: cap[0]
          };
          if (this.options.sanitize) {
            const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
            const paragraph = token;
            paragraph.type = "paragraph";
            paragraph.text = text;
            paragraph.tokens = this.lexer.inline(text);
          }
          return token;
        }
      }
      def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
          const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
          const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
          return {
            type: "def",
            tag,
            raw: cap[0],
            href,
            title
          };
        }
      }
      table(src) {
        const cap = this.rules.block.table.exec(src);
        if (cap) {
          const item = {
            type: "table",
            raw: cap[0],
            header: splitCells(cap[1]).map((c) => {
              return { text: c, tokens: [] };
            }),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            let l = item.align.length;
            let i, j, k, row;
            for (i = 0; i < l; i++) {
              const align = item.align[i];
              if (align) {
                if (/^ *-+: *$/.test(align)) {
                  item.align[i] = "right";
                } else if (/^ *:-+: *$/.test(align)) {
                  item.align[i] = "center";
                } else if (/^ *:-+ *$/.test(align)) {
                  item.align[i] = "left";
                } else {
                  item.align[i] = null;
                }
              }
            }
            l = item.rows.length;
            for (i = 0; i < l; i++) {
              item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
                return { text: c, tokens: [] };
              });
            }
            l = item.header.length;
            for (j = 0; j < l; j++) {
              item.header[j].tokens = this.lexer.inline(item.header[j].text);
            }
            l = item.rows.length;
            for (j = 0; j < l; j++) {
              row = item.rows[j];
              for (k = 0; k < row.length; k++) {
                row[k].tokens = this.lexer.inline(row[k].text);
              }
            }
            return item;
          }
        }
      }
      lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1],
            tokens: this.lexer.inline(cap[1])
          };
        }
      }
      paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
          return {
            type: "paragraph",
            raw: cap[0],
            text,
            tokens: this.lexer.inline(text)
          };
        }
      }
      text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
          return {
            type: "text",
            raw: cap[0],
            text: cap[0],
            tokens: this.lexer.inline(cap[0])
          };
        }
      }
      escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: escape(cap[1])
          };
        }
      }
      tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            block: false,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
          };
        }
      }
      link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
          const trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            const lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              const start = cap[0].indexOf("!") === 0 ? 5 : 4;
              const linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          let href = cap[2];
          let title = "";
          if (this.options.pedantic) {
            const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link) {
              href = link[1];
              title = link[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0], this.lexer);
        }
      }
      reflink(src, links2) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link = links2[link.toLowerCase()];
          if (!link) {
            const text = cap[0].charAt(0);
            return {
              type: "text",
              raw: text,
              text
            };
          }
          return outputLink(cap, link, cap[0], this.lexer);
        }
      }
      emStrong(src, maskedSrc, prevChar = "") {
        let match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match)
          return;
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
          return;
        const nextChar = match[1] || match[2] || "";
        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
          const lLength = [...match[0]].length - 1;
          let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
            if (!rDelim)
              continue;
            rLength = [...rDelim].length;
            if (match[3] || match[4]) {
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0)
              continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            const raw = [...src].slice(0, lLength + match.index + rLength + 1).join("");
            if (Math.min(lLength, rLength) % 2) {
              const text2 = raw.slice(1, -1);
              return {
                type: "em",
                raw,
                text: text2,
                tokens: this.lexer.inlineTokens(text2)
              };
            }
            const text = raw.slice(2, -2);
            return {
              type: "strong",
              raw,
              text,
              tokens: this.lexer.inlineTokens(text)
            };
          }
        }
      }
      codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
          let text = cap[2].replace(/\n/g, " ");
          const hasNonSpaceChars = /[^ ]/.test(text);
          const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = escape(text, true);
          return {
            type: "codespan",
            raw: cap[0],
            text
          };
        }
      }
      br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      }
      del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2])
          };
        }
      }
      autolink(src, mangle2) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          let text, href;
          if (cap[2] === "@") {
            text = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
            href = "mailto:" + text;
          } else {
            text = escape(cap[1]);
            href = text;
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      url(src, mangle2) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
          let text, href;
          if (cap[2] === "@") {
            text = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
            href = "mailto:" + text;
          } else {
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + cap[0];
            } else {
              href = cap[0];
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      inlineText(src, smartypants2) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
          let text;
          if (this.lexer.state.inRawBlock) {
            text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
          } else {
            text = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text
          };
        }
      }
    };
    block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: noopTest,
      lheading: /^((?:(?!^bull ).|\n(?!\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be replaced according to different paragraph
      // interruption rules of commonmark and the original markdown spec:
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
    block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
    block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.lheading = edit(block.lheading).replace(/bull/g, block.bullet).getRegex();
    block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
    block.normal = { ...block };
    block.gfm = {
      ...block.normal,
      table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
      // Cells
    };
    block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.pedantic = {
      ...block.normal,
      html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    };
    inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,
        //         (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
        //         | Skip orphan inside strong      | Consume to delim | (1) #***              | (2) a***#, a***                    | (3) #***a, ***a                  | (4) ***#                 | (5) #***#                         | (6) a***a
        rDelimAst: /^[^_*]*?__[^_*]*?\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\*)[punct](\*+)(?=[\s]|$)|[^punct\s](\*+)(?!\*)(?=[punct\s]|$)|(?!\*)[punct\s](\*+)(?=[^punct\s])|[\s](\*+)(?!\*)(?=[punct])|(?!\*)[punct](\*+)(?!\*)(?=[punct])|[^punct\s](\*+)(?=[^punct\s])/,
        rDelimUnd: /^[^_*]*?\*\*[^_*]*?_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\s]|$)|[^punct\s](_+)(?!_)(?=[punct\s]|$)|(?!_)[punct\s](_+)(?=[^punct\s])|[\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/
        // ^- Not allowed for _
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^((?![*_])[\spunctuation])/
    };
    inline._punctuation = "\\p{P}$+<=>`^|~";
    inline.punctuation = edit(inline.punctuation, "u").replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
    inline.anyPunctuation = /\\[punct]/g;
    inline._escapes = /\\([punct])/g;
    inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
    inline.emStrong.lDelim = edit(inline.emStrong.lDelim, "u").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "gu").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "gu").replace(/punct/g, inline._punctuation).getRegex();
    inline.anyPunctuation = edit(inline.anyPunctuation, "gu").replace(/punct/g, inline._punctuation).getRegex();
    inline._escapes = edit(inline._escapes, "gu").replace(/punct/g, inline._punctuation).getRegex();
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
    inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
    inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
    inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
    inline.normal = { ...inline };
    inline.pedantic = {
      ...inline.normal,
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
    };
    inline.gfm = {
      ...inline.normal,
      escape: edit(inline.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    };
    inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
    inline.breaks = {
      ...inline.gfm,
      br: edit(inline.br).replace("{2,}", "*").getRegex(),
      text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    };
    _Lexer = class __Lexer {
      tokens;
      options;
      state;
      tokenizer;
      inlineQueue;
      constructor(options2) {
        this.tokens = [];
        this.tokens.links = /* @__PURE__ */ Object.create(null);
        this.options = options2 || _defaults;
        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };
        const rules = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }
      /**
       * Expose Rules
       */
      static get rules() {
        return {
          block,
          inline
        };
      }
      /**
       * Static Lex Method
       */
      static lex(src, options2) {
        const lexer2 = new __Lexer(options2);
        return lexer2.lex(src);
      }
      /**
       * Static Lex Inline Method
       */
      static lexInline(src, options2) {
        const lexer2 = new __Lexer(options2);
        return lexer2.inlineTokens(src);
      }
      /**
       * Preprocessing
       */
      lex(src) {
        src = src.replace(/\r\n|\r/g, "\n");
        this.blockTokens(src, this.tokens);
        let next;
        while (next = this.inlineQueue.shift()) {
          this.inlineTokens(next.src, next.tokens);
        }
        return this.tokens;
      }
      blockTokens(src, tokens = []) {
        if (this.options.pedantic) {
          src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
        } else {
          src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
            return leading + "    ".repeat(tabs.length);
          });
        }
        let token;
        let lastToken;
        let cutSrc;
        let lastParagraphClipped;
        while (src) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.raw.length === 1 && tokens.length > 0) {
              tokens[tokens.length - 1].raw += "\n";
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startBlock.forEach((getStartIndex) => {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = cutSrc.length !== src.length;
            src = src.substring(token.raw.length);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        this.state.top = true;
        return tokens;
      }
      inline(src, tokens = []) {
        this.inlineQueue.push({ src, tokens });
        return tokens;
      }
      /**
       * Lexing/Compiling
       */
      inlineTokens(src, tokens = []) {
        let token, lastToken, cutSrc;
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;
        if (this.tokens.links) {
          const links2 = Object.keys(this.tokens.links);
          if (links2.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links2.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startInline.forEach((getStartIndex) => {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== "_") {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
    };
    _Renderer = class {
      options;
      constructor(options2) {
        this.options = options2 || _defaults;
      }
      code(code, infostring, escaped) {
        const lang = (infostring || "").match(/^\S*/)?.[0];
        if (this.options.highlight) {
          const out = this.options.highlight(code, lang);
          if (out != null && out !== code) {
            escaped = true;
            code = out;
          }
        }
        code = code.replace(/\n$/, "") + "\n";
        if (!lang) {
          return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
      }
      blockquote(quote) {
        return `<blockquote>
${quote}</blockquote>
`;
      }
      html(html, block2) {
        return html;
      }
      heading(text, level2, raw, slugger) {
        if (this.options.headerIds) {
          const id2 = this.options.headerPrefix + slugger.slug(raw);
          return `<h${level2} id="${id2}">${text}</h${level2}>
`;
        }
        return `<h${level2}>${text}</h${level2}>
`;
      }
      hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      }
      list(body, ordered, start) {
        const type = ordered ? "ol" : "ul";
        const startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
      }
      listitem(text, task, checked) {
        return `<li>${text}</li>
`;
      }
      checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      }
      paragraph(text) {
        return `<p>${text}</p>
`;
      }
      table(header, body) {
        if (body)
          body = `<tbody>${body}</tbody>`;
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      }
      tablerow(content) {
        return `<tr>
${content}</tr>
`;
      }
      tablecell(content, flags) {
        const type = flags.header ? "th" : "td";
        const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
        return tag + content + `</${type}>
`;
      }
      /**
       * span level renderer
       */
      strong(text) {
        return `<strong>${text}</strong>`;
      }
      em(text) {
        return `<em>${text}</em>`;
      }
      codespan(text) {
        return `<code>${text}</code>`;
      }
      br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      }
      del(text) {
        return `<del>${text}</del>`;
      }
      link(href, title, text) {
        const cleanHref = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (cleanHref === null) {
          return text;
        }
        href = cleanHref;
        let out = '<a href="' + href + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text + "</a>";
        return out;
      }
      image(href, title, text) {
        const cleanHref = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (cleanHref === null) {
          return text;
        }
        href = cleanHref;
        let out = `<img src="${href}" alt="${text}"`;
        if (title) {
          out += ` title="${title}"`;
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      }
      text(text) {
        return text;
      }
    };
    _TextRenderer = class {
      // no need for block level renderers
      strong(text) {
        return text;
      }
      em(text) {
        return text;
      }
      codespan(text) {
        return text;
      }
      del(text) {
        return text;
      }
      html(text) {
        return text;
      }
      text(text) {
        return text;
      }
      link(href, title, text) {
        return "" + text;
      }
      image(href, title, text) {
        return "" + text;
      }
      br() {
        return "";
      }
    };
    _Slugger = class {
      seen;
      constructor() {
        this.seen = {};
      }
      serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      }
      /**
       * Finds the next safe (unique) slug to use
       */
      getNextSafeSlug(originalSlug, isDryRun) {
        let slug = originalSlug;
        let occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      }
      /**
       * Convert string to unique id
       */
      slug(value, options2 = {}) {
        const slug = this.serialize(value);
        return this.getNextSafeSlug(slug, options2.dryrun);
      }
    };
    _Parser = class __Parser {
      options;
      renderer;
      textRenderer;
      slugger;
      constructor(options2) {
        this.options = options2 || _defaults;
        this.options.renderer = this.options.renderer || new _Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new _TextRenderer();
        this.slugger = new _Slugger();
      }
      /**
       * Static Parse Method
       */
      static parse(tokens, options2) {
        const parser2 = new __Parser(options2);
        return parser2.parse(tokens);
      }
      /**
       * Static Parse Inline Method
       */
      static parseInline(tokens, options2) {
        const parser2 = new __Parser(options2);
        return parser2.parseInline(tokens);
      }
      /**
       * Parse Loop
       */
      parse(tokens, top = true) {
        let out = "";
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            const genericToken = token;
            const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
            if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              const headingToken = token;
              out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape2(this.parseInline(headingToken.tokens, this.textRenderer)), this.slugger);
              continue;
            }
            case "code": {
              const codeToken = token;
              out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
              continue;
            }
            case "table": {
              const tableToken = token;
              let header = "";
              let cell = "";
              for (let j = 0; j < tableToken.header.length; j++) {
                cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });
              }
              header += this.renderer.tablerow(cell);
              let body = "";
              for (let j = 0; j < tableToken.rows.length; j++) {
                const row = tableToken.rows[j];
                cell = "";
                for (let k = 0; k < row.length; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              const blockquoteToken = token;
              const body = this.parse(blockquoteToken.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              const listToken = token;
              const ordered = listToken.ordered;
              const start = listToken.start;
              const loose = listToken.loose;
              let body = "";
              for (let j = 0; j < listToken.items.length; j++) {
                const item = listToken.items[j];
                const checked = item.checked;
                const task = item.task;
                let itemBody = "";
                if (item.task) {
                  const checkbox = this.renderer.checkbox(!!checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, !!checked);
              }
              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case "html": {
              const htmlToken = token;
              out += this.renderer.html(htmlToken.text, htmlToken.block);
              continue;
            }
            case "paragraph": {
              const paragraphToken = token;
              out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
              continue;
            }
            case "text": {
              let textToken = token;
              let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
              while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
                textToken = tokens[++i];
                body += "\n" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return "";
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
      /**
       * Parse Inline Tokens
       */
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = "";
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "escape": {
              const escapeToken = token;
              out += renderer.text(escapeToken.text);
              break;
            }
            case "html": {
              const tagToken = token;
              out += renderer.html(tagToken.text);
              break;
            }
            case "link": {
              const linkToken = token;
              out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));
              break;
            }
            case "image": {
              const imageToken = token;
              out += renderer.image(imageToken.href, imageToken.title, imageToken.text);
              break;
            }
            case "strong": {
              const strongToken = token;
              out += renderer.strong(this.parseInline(strongToken.tokens, renderer));
              break;
            }
            case "em": {
              const emToken = token;
              out += renderer.em(this.parseInline(emToken.tokens, renderer));
              break;
            }
            case "codespan": {
              const codespanToken = token;
              out += renderer.codespan(codespanToken.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              const delToken = token;
              out += renderer.del(this.parseInline(delToken.tokens, renderer));
              break;
            }
            case "text": {
              const textToken = token;
              out += renderer.text(textToken.text);
              break;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return "";
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
    };
    _Hooks = class {
      options;
      constructor(options2) {
        this.options = options2 || _defaults;
      }
      static passThroughHooks = /* @__PURE__ */ new Set([
        "preprocess",
        "postprocess"
      ]);
      /**
       * Process markdown before marked
       */
      preprocess(markdown) {
        return markdown;
      }
      /**
       * Process HTML after marked is finished
       */
      postprocess(html) {
        return html;
      }
    };
    Marked = class {
      defaults = _getDefaults();
      options = this.setOptions;
      parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);
      parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);
      Parser = _Parser;
      parser = _Parser.parse;
      Renderer = _Renderer;
      TextRenderer = _TextRenderer;
      Lexer = _Lexer;
      lexer = _Lexer.lex;
      Tokenizer = _Tokenizer;
      Slugger = _Slugger;
      Hooks = _Hooks;
      constructor(...args) {
        this.use(...args);
      }
      /**
       * Run callback for every token
       */
      walkTokens(tokens, callback) {
        let values = [];
        for (const token of tokens) {
          values = values.concat(callback.call(this, token));
          switch (token.type) {
            case "table": {
              const tableToken = token;
              for (const cell of tableToken.header) {
                values = values.concat(this.walkTokens(cell.tokens, callback));
              }
              for (const row of tableToken.rows) {
                for (const cell of row) {
                  values = values.concat(this.walkTokens(cell.tokens, callback));
                }
              }
              break;
            }
            case "list": {
              const listToken = token;
              values = values.concat(this.walkTokens(listToken.items, callback));
              break;
            }
            default: {
              const genericToken = token;
              if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
                this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
                  values = values.concat(this.walkTokens(genericToken[childTokens], callback));
                });
              } else if (genericToken.tokens) {
                values = values.concat(this.walkTokens(genericToken.tokens, callback));
              }
            }
          }
        }
        return values;
      }
      use(...args) {
        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
        args.forEach((pack) => {
          const opts = { ...pack };
          opts.async = this.defaults.async || opts.async || false;
          if (pack.extensions) {
            pack.extensions.forEach((ext) => {
              if (!ext.name) {
                throw new Error("extension name required");
              }
              if ("renderer" in ext) {
                const prevRenderer = extensions.renderers[ext.name];
                if (prevRenderer) {
                  extensions.renderers[ext.name] = function(...args2) {
                    let ret = ext.renderer.apply(this, args2);
                    if (ret === false) {
                      ret = prevRenderer.apply(this, args2);
                    }
                    return ret;
                  };
                } else {
                  extensions.renderers[ext.name] = ext.renderer;
                }
              }
              if ("tokenizer" in ext) {
                if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                  throw new Error("extension level must be 'block' or 'inline'");
                }
                const extLevel = extensions[ext.level];
                if (extLevel) {
                  extLevel.unshift(ext.tokenizer);
                } else {
                  extensions[ext.level] = [ext.tokenizer];
                }
                if (ext.start) {
                  if (ext.level === "block") {
                    if (extensions.startBlock) {
                      extensions.startBlock.push(ext.start);
                    } else {
                      extensions.startBlock = [ext.start];
                    }
                  } else if (ext.level === "inline") {
                    if (extensions.startInline) {
                      extensions.startInline.push(ext.start);
                    } else {
                      extensions.startInline = [ext.start];
                    }
                  }
                }
              }
              if ("childTokens" in ext && ext.childTokens) {
                extensions.childTokens[ext.name] = ext.childTokens;
              }
            });
            opts.extensions = extensions;
          }
          if (pack.renderer) {
            const renderer = this.defaults.renderer || new _Renderer(this.defaults);
            for (const prop in pack.renderer) {
              const rendererFunc = pack.renderer[prop];
              const rendererKey = prop;
              const prevRenderer = renderer[rendererKey];
              renderer[rendererKey] = (...args2) => {
                let ret = rendererFunc.apply(renderer, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(renderer, args2);
                }
                return ret || "";
              };
            }
            opts.renderer = renderer;
          }
          if (pack.tokenizer) {
            const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
            for (const prop in pack.tokenizer) {
              const tokenizerFunc = pack.tokenizer[prop];
              const tokenizerKey = prop;
              const prevTokenizer = tokenizer[tokenizerKey];
              tokenizer[tokenizerKey] = (...args2) => {
                let ret = tokenizerFunc.apply(tokenizer, args2);
                if (ret === false) {
                  ret = prevTokenizer.apply(tokenizer, args2);
                }
                return ret;
              };
            }
            opts.tokenizer = tokenizer;
          }
          if (pack.hooks) {
            const hooks = this.defaults.hooks || new _Hooks();
            for (const prop in pack.hooks) {
              const hooksFunc = pack.hooks[prop];
              const hooksKey = prop;
              const prevHook = hooks[hooksKey];
              if (_Hooks.passThroughHooks.has(prop)) {
                hooks[hooksKey] = (arg) => {
                  if (this.defaults.async) {
                    return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                      return prevHook.call(hooks, ret2);
                    });
                  }
                  const ret = hooksFunc.call(hooks, arg);
                  return prevHook.call(hooks, ret);
                };
              } else {
                hooks[hooksKey] = (...args2) => {
                  let ret = hooksFunc.apply(hooks, args2);
                  if (ret === false) {
                    ret = prevHook.apply(hooks, args2);
                  }
                  return ret;
                };
              }
            }
            opts.hooks = hooks;
          }
          if (pack.walkTokens) {
            const walkTokens2 = this.defaults.walkTokens;
            const packWalktokens = pack.walkTokens;
            opts.walkTokens = function(token) {
              let values = [];
              values.push(packWalktokens.call(this, token));
              if (walkTokens2) {
                values = values.concat(walkTokens2.call(this, token));
              }
              return values;
            };
          }
          this.defaults = { ...this.defaults, ...opts };
        });
        return this;
      }
      setOptions(opt) {
        this.defaults = { ...this.defaults, ...opt };
        return this;
      }
      #parseMarkdown(lexer2, parser2) {
        return (src, optOrCallback, callback) => {
          if (typeof optOrCallback === "function") {
            callback = optOrCallback;
            optOrCallback = null;
          }
          const origOpt = { ...optOrCallback };
          const opt = { ...this.defaults, ...origOpt };
          if (this.defaults.async === true && origOpt.async === false) {
            if (!opt.silent) {
              console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.");
            }
            opt.async = true;
          }
          const throwError = this.#onError(!!opt.silent, !!opt.async, callback);
          if (typeof src === "undefined" || src === null) {
            return throwError(new Error("marked(): input parameter is undefined or null"));
          }
          if (typeof src !== "string") {
            return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
          }
          checkDeprecations(opt, callback);
          if (opt.hooks) {
            opt.hooks.options = opt;
          }
          if (callback) {
            const resultCallback = callback;
            const highlight = opt.highlight;
            let tokens;
            try {
              if (opt.hooks) {
                src = opt.hooks.preprocess(src);
              }
              tokens = lexer2(src, opt);
            } catch (e) {
              return throwError(e);
            }
            const done = (err) => {
              let out;
              if (!err) {
                try {
                  if (opt.walkTokens) {
                    this.walkTokens(tokens, opt.walkTokens);
                  }
                  out = parser2(tokens, opt);
                  if (opt.hooks) {
                    out = opt.hooks.postprocess(out);
                  }
                } catch (e) {
                  err = e;
                }
              }
              opt.highlight = highlight;
              return err ? throwError(err) : resultCallback(null, out);
            };
            if (!highlight || highlight.length < 3) {
              return done();
            }
            delete opt.highlight;
            if (!tokens.length)
              return done();
            let pending = 0;
            this.walkTokens(tokens, (token) => {
              if (token.type === "code") {
                pending++;
                setTimeout(() => {
                  highlight(token.text, token.lang, (err, code) => {
                    if (err) {
                      return done(err);
                    }
                    if (code != null && code !== token.text) {
                      token.text = code;
                      token.escaped = true;
                    }
                    pending--;
                    if (pending === 0) {
                      done();
                    }
                  });
                }, 0);
              }
            });
            if (pending === 0) {
              done();
            }
            return;
          }
          if (opt.async) {
            return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
          }
          try {
            if (opt.hooks) {
              src = opt.hooks.preprocess(src);
            }
            const tokens = lexer2(src, opt);
            if (opt.walkTokens) {
              this.walkTokens(tokens, opt.walkTokens);
            }
            let html = parser2(tokens, opt);
            if (opt.hooks) {
              html = opt.hooks.postprocess(html);
            }
            return html;
          } catch (e) {
            return throwError(e);
          }
        };
      }
      #onError(silent, async, callback) {
        return (e) => {
          e.message += "\nPlease report this to https://github.com/markedjs/marked.";
          if (silent) {
            const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
            if (async) {
              return Promise.resolve(msg);
            }
            if (callback) {
              callback(null, msg);
              return;
            }
            return msg;
          }
          if (async) {
            return Promise.reject(e);
          }
          if (callback) {
            callback(e);
            return;
          }
          throw e;
        };
      }
    };
    markedInstance = new Marked();
    marked.options = marked.setOptions = function(options2) {
      markedInstance.setOptions(options2);
      marked.defaults = markedInstance.defaults;
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.getDefaults = _getDefaults;
    marked.defaults = _defaults;
    marked.use = function(...args) {
      markedInstance.use(...args);
      marked.defaults = markedInstance.defaults;
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.walkTokens = function(tokens, callback) {
      return markedInstance.walkTokens(tokens, callback);
    };
    marked.parseInline = markedInstance.parseInline;
    marked.Parser = _Parser;
    marked.parser = _Parser.parse;
    marked.Renderer = _Renderer;
    marked.TextRenderer = _TextRenderer;
    marked.Lexer = _Lexer;
    marked.lexer = _Lexer.lex;
    marked.Tokenizer = _Tokenizer;
    marked.Slugger = _Slugger;
    marked.Hooks = _Hooks;
    marked.parse = marked;
    options = marked.options;
    setOptions = marked.setOptions;
    use = marked.use;
    walkTokens = marked.walkTokens;
    parseInline = marked.parseInline;
    parser = _Parser.parse;
    lexer = _Lexer.lex;
  }
});

// src/util/ansiparse.ts
function parseAnsiHighlights(line, markdown = false) {
  let items = ansiparse(line);
  let highlights = [];
  let newLabel = "";
  for (let item of items) {
    if (!item.text) continue;
    let { foreground, background } = item;
    let len = byteLength(newLabel);
    let span = [len, len + byteLength(item.text)];
    if (foreground && background) {
      let hlGroup = `CocList${upperFirst(foreground)}${upperFirst(background)}`;
      highlights.push({ span, hlGroup });
    } else if (foreground) {
      let hlGroup;
      if (markdown) {
        if (foreground == "yellow") {
          hlGroup = "CocMarkdownCode";
        } else if (foreground == "blue") {
          hlGroup = "CocMarkdownLink";
        } else if (foreground == "magenta") {
          hlGroup = "CocMarkdownHeader";
        } else {
          hlGroup = `CocListFg${upperFirst(foreground)}`;
        }
      } else {
        hlGroup = `CocListFg${upperFirst(foreground)}`;
      }
      highlights.push({ span, hlGroup });
    } else if (background) {
      let hlGroup = `CocListBg${upperFirst(background)}`;
      highlights.push({ span, hlGroup });
    }
    if (item.bold) {
      highlights.push({ span, hlGroup: "CocBold" });
    } else if (item.italic) {
      highlights.push({ span, hlGroup: "CocItalic" });
    } else if (item.underline) {
      highlights.push({ span, hlGroup: "CocUnderline" });
    } else if (item.strikethrough) {
      highlights.push({ span, hlGroup: "CocStrikeThrough" });
    }
    newLabel = newLabel + item.text;
  }
  return { line: newLabel, highlights };
}
function ansiparse(str) {
  let matchingControl = null;
  let matchingData = null;
  let matchingText = "";
  let ansiState = [];
  let result = [];
  let state = {};
  let eraseChar;
  eraseChar = () => {
    let index;
    let text;
    if (matchingText.length) {
      matchingText = matchingText.substr(0, matchingText.length - 1);
    } else if (result.length) {
      index = result.length - 1;
      text = result[index].text;
      if (text.length === 1) {
        result.pop();
      } else {
        result[index].text = text.substr(0, text.length - 1);
      }
    }
  };
  for (let i = 0; i < str.length; i++) {
    if (matchingControl != null) {
      if (matchingControl == "\x1B" && str[i] == "[") {
        if (matchingText) {
          state.text = matchingText;
          result.push(state);
          state = {};
          matchingText = "";
        }
        if (matchingText == "" && (str[i + 1] == "m" || str[i + 1] == "K")) {
          if (state.foreground || state.background) {
            state.text = "";
            result.push(state);
          }
          state = {};
        }
        matchingControl = null;
        matchingData = "";
      } else {
        matchingText += matchingControl + str[i];
        matchingControl = null;
      }
      continue;
    } else if (matchingData != null) {
      if (str[i] == ";") {
        ansiState.push(matchingData);
        matchingData = "";
      } else if (str[i] == "m" || str[i] == "K") {
        ansiState.push(matchingData);
        matchingData = null;
        matchingText = "";
        ansiState.forEach((ansiCode) => {
          if (foregroundColors[ansiCode]) {
            state.foreground = foregroundColors[ansiCode];
          } else if (backgroundColors[ansiCode]) {
            state.background = backgroundColors[ansiCode];
          } else if (ansiCode == 39) {
            delete state.foreground;
          } else if (ansiCode == 49) {
            delete state.background;
          } else if (styles2[ansiCode]) {
            state[styles2[ansiCode]] = true;
          } else if (ansiCode == 22) {
            state.bold = false;
          } else if (ansiCode == 23) {
            state.italic = false;
          } else if (ansiCode == 24) {
            state.underline = false;
          } else if (ansiCode == 29) {
            state.strikethrough = false;
          }
        });
        ansiState = [];
      } else {
        matchingData += str[i];
      }
      continue;
    }
    if (str[i] == "\x1B") {
      matchingControl = str[i];
    } else if (str[i] == "\b") {
      eraseChar();
    } else {
      matchingText += str[i];
    }
  }
  if (matchingText) {
    state.text = matchingText + toText(matchingControl);
    result.push(state);
  }
  return result;
}
function stripAnsiColoring(str) {
  const ansiColorCodeRegex = /\u001b\[[0-9;]*m/g;
  return str.replace(ansiColorCodeRegex, "");
}
var foregroundColors, backgroundColors, styles2;
var init_ansiparse = __esm({
  "src/util/ansiparse.ts"() {
    "use strict";
    init_string();
    foregroundColors = {
      30: "black",
      31: "red",
      32: "green",
      33: "yellow",
      34: "blue",
      35: "magenta",
      36: "cyan",
      37: "white",
      90: "grey"
    };
    backgroundColors = {
      40: "black",
      41: "red",
      42: "green",
      43: "yellow",
      44: "blue",
      45: "magenta",
      46: "cyan",
      47: "white"
    };
    styles2 = {
      1: "bold",
      3: "italic",
      4: "underline",
      9: "strikethrough"
    };
  }
});

// src/markdown/styles.ts
function gray(str) {
  return `${styles.gray.open}${str}${styles.gray.close}`;
}
function magenta(str) {
  return `${styles.magenta.open}${str}${styles.magenta.close}`;
}
function bold(str) {
  return `${styles.bold.open}${str}${styles.bold.close}`;
}
function underline(str) {
  return `${styles.underline.open}${str}${styles.underline.close}`;
}
function strikethrough(str) {
  return `${styles.strikethrough.open}${str}${styles.strikethrough.close}`;
}
function italic(str) {
  return `${styles.italic.open}${str}${styles.italic.close}`;
}
function yellow(str) {
  return `${styles.yellow.open}${str}${styles.yellow.close}`;
}
function blue(str) {
  return `${styles.blue.open}${str}${styles.blue.close}`;
}
var init_styles = __esm({
  "src/markdown/styles.ts"() {
    "use strict";
    init_node();
  }
});

// node_modules/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/colors/lib/styles.js"(exports2, module2) {
    var styles3 = {};
    module2["exports"] = styles3;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      // legacy styles for colors pre v1.0.0
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles3[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/colors/lib/system/supports-colors.js"(exports2, module2) {
    var argv = process.argv;
    module2.exports = function() {
      if (argv.indexOf("--no-color") !== -1 || argv.indexOf("--color=false") !== -1) {
        return false;
      }
      if (argv.indexOf("--color") !== -1 || argv.indexOf("--color=true") !== -1 || argv.indexOf("--color=always") !== -1) {
        return true;
      }
      if (process.stdout && !process.stdout.isTTY) {
        return false;
      }
      if (process.platform === "win32") {
        return true;
      }
      if ("COLORTERM" in process.env) {
        return true;
      }
      if (process.env.TERM === "dumb") {
        return false;
      }
      if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
        return true;
      }
      return false;
    }();
  }
});

// node_modules/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options2) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: ["\xCB", "\u0115", "\u018E", "\u0258", "\u03A3", "\u03BE", "\u04BC", "\u0A6C"],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: ["\xD8", "\xF5", "\xF8", "\u01FE", "\u0298", "\u047A", "\u05DD", "\u06DD", "\u0E4F"],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options2) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      }, all = [].concat(soul.up, soul.down, soul.mid), zalgo2 = {};
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function is_char(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options3) {
        var result = "", counts, l;
        options3 = options3 || {};
        options3["up"] = options3["up"] || true;
        options3["mid"] = options3["mid"] || true;
        options3["down"] = options3["down"] || true;
        options3["size"] = options3["size"] || "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (is_char(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options3.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.min = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.min = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options3[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text);
    };
  }
});

// node_modules/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/colors/lib/maps/america.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = /* @__PURE__ */ function() {
      return function(letter, i, exploded) {
        if (letter === " ") return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    }();
  }
});

// node_modules/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/colors/lib/maps/zebra.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = function(letter, i, exploded) {
      return i % 2 === 0 ? letter : colors.inverse(letter);
    };
  }
});

// node_modules/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/colors/lib/maps/rainbow.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = /* @__PURE__ */ function() {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    }();
  }
});

// node_modules/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/colors/lib/maps/random.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = /* @__PURE__ */ function() {
      var available = ["underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta"];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
      };
    }();
  }
});

// node_modules/colors/lib/colors.js
var require_colors = __commonJS({
  "node_modules/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    colors.supportsColor = require_supports_colors();
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor;
    }
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      return ansiStyles[style].open + str + ansiStyles[style].close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles3 = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles3);
    function applyStyle() {
      var args = arguments;
      var argsLen = args.length;
      var str = argsLen !== 0 && String(arguments[0]);
      if (argsLen > 1) {
        for (var a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!colors.enabled || !str) {
        return str;
      }
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
      }
      return str;
    }
    function applyTheme(theme) {
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            return colors[theme[style2]](str);
          };
        })(style);
      }
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        try {
          colors.themes[theme] = require(theme);
          applyTheme(colors.themes[theme]);
          return colors.themes[theme];
        } catch (err) {
          console.log(err);
          return err;
        }
      } else {
        applyTheme(theme);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles3).forEach(function(name2) {
        ret[name2] = {
          get: function() {
            return build([name2]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split(""), i = 0;
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america();
    colors.maps.zebra = require_zebra();
    colors.maps.rainbow = require_rainbow();
    colors.maps.random = require_random();
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// node_modules/colors/safe.js
var require_safe = __commonJS({
  "node_modules/colors/safe.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// node_modules/cli-table/lib/utils.js
var require_utils = __commonJS({
  "node_modules/cli-table/lib/utils.js"(exports2) {
    exports2.repeat = function(str, times) {
      return Array(times + 1).join(str);
    };
    exports2.pad = function(str, len, pad2, dir) {
      if (len + 1 >= str.length)
        switch (dir) {
          case "left":
            str = Array(len + 1 - str.length).join(pad2) + str;
            break;
          case "both":
            var right = Math.ceil((padlen = len - str.length) / 2);
            var left = padlen - right;
            str = Array(left + 1).join(pad2) + str + Array(right + 1).join(pad2);
            break;
          default:
            str = str + Array(len + 1 - str.length).join(pad2);
        }
      ;
      return str;
    };
    exports2.truncate = function(str, length, chr) {
      chr = chr || "\u2026";
      return str.length >= length ? str.substr(0, length - chr.length) + chr : str;
    };
    function options2(defaults, opts) {
      for (var p in opts) {
        if (p === "__proto__" || p === "constructor" || p === "prototype") {
          continue;
        }
        if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {
          defaults[p] = defaults[p] || {};
          options2(defaults[p], opts[p]);
        } else {
          defaults[p] = opts[p];
        }
      }
      return defaults;
    }
    exports2.options = options2;
    exports2.strlen = function(str) {
      var code = /\u001b\[(?:\d*;){0,5}\d*m/g;
      var stripped = ("" + str).replace(code, "");
      var split = stripped.split("\n");
      return split.reduce(function(memo, s) {
        return s.length > memo ? s.length : memo;
      }, 0);
    };
  }
});

// node_modules/cli-table/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/cli-table/lib/index.js"(exports2, module2) {
    var colors = require_safe();
    var utils = require_utils();
    var repeat2 = utils.repeat;
    var truncate = utils.truncate;
    var pad2 = utils.pad;
    function Table(options2) {
      this.options = utils.options({
        chars: {
          "top": "\u2500",
          "top-mid": "\u252C",
          "top-left": "\u250C",
          "top-right": "\u2510",
          "bottom": "\u2500",
          "bottom-mid": "\u2534",
          "bottom-left": "\u2514",
          "bottom-right": "\u2518",
          "left": "\u2502",
          "left-mid": "\u251C",
          "mid": "\u2500",
          "mid-mid": "\u253C",
          "right": "\u2502",
          "right-mid": "\u2524",
          "middle": "\u2502"
        },
        truncate: "\u2026",
        colWidths: [],
        colAligns: [],
        style: {
          "padding-left": 1,
          "padding-right": 1,
          head: ["red"],
          border: ["grey"],
          compact: false
        },
        head: []
      }, options2);
      if (options2 && options2.rows) {
        for (var i = 0; i < options2.rows.length; i++) {
          this.push(options2.rows[i]);
        }
      }
    }
    Table.prototype.__proto__ = Array.prototype;
    Table.prototype.__defineGetter__("width", function() {
      var str = this.toString().split("\n");
      if (str.length) return str[0].length;
      return 0;
    });
    Table.prototype.render;
    Table.prototype.toString = function() {
      var ret = "", options2 = this.options, style = options2.style, head = options2.head, chars = options2.chars, truncater = options2.truncate, colWidths = options2.colWidths || new Array(this.head.length), totalWidth = 0;
      if (!head.length && !this.length) return "";
      if (!colWidths.length) {
        var all_rows = this.slice(0);
        if (head.length) {
          all_rows = all_rows.concat([head]);
        }
        ;
        all_rows.forEach(function(cells) {
          if (typeof cells === "object" && cells.length) {
            extractColumnWidths(cells);
          } else {
            var header_cell = Object.keys(cells)[0], value_cell = cells[header_cell];
            colWidths[0] = Math.max(colWidths[0] || 0, get_width(header_cell) || 0);
            if (typeof value_cell === "object" && value_cell.length) {
              extractColumnWidths(value_cell, 1);
            } else {
              colWidths[1] = Math.max(colWidths[1] || 0, get_width(value_cell) || 0);
            }
          }
        });
      }
      ;
      totalWidth = (colWidths.length == 1 ? colWidths[0] : colWidths.reduce(
        function(a, b) {
          return a + b;
        }
      )) + colWidths.length + 1;
      function extractColumnWidths(arr, offset) {
        var offset = offset || 0;
        arr.forEach(function(cell, i) {
          colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, get_width(cell) || 0);
        });
      }
      ;
      function get_width(obj) {
        return typeof obj == "object" && obj.width != void 0 ? obj.width : (typeof obj == "object" ? utils.strlen(obj.text) : utils.strlen(obj)) + (style["padding-left"] || 0) + (style["padding-right"] || 0);
      }
      function line(line2, left, right, intersection) {
        var width = 0, line2 = left + repeat2(line2, totalWidth - 2) + right;
        colWidths.forEach(function(w, i) {
          if (i == colWidths.length - 1) return;
          width += w + 1;
          line2 = line2.substr(0, width) + intersection + line2.substr(width + 1);
        });
        return applyStyles(options2.style.border, line2);
      }
      ;
      function lineTop() {
        var l2 = line(
          chars.top,
          chars["top-left"] || chars.top,
          chars["top-right"] || chars.top,
          chars["top-mid"]
        );
        if (l2)
          ret += l2 + "\n";
      }
      ;
      function generateRow(items, style2) {
        var cells = [], max_height = 0;
        if (!Array.isArray(items) && typeof items === "object") {
          var key = Object.keys(items)[0], value = items[key], first_cell_head = true;
          if (Array.isArray(value)) {
            items = value;
            items.unshift(key);
          } else {
            items = [key, value];
          }
        }
        items.forEach(function(item, i) {
          var contents = item.toString().split("\n").reduce(function(memo, l2) {
            memo.push(string2(l2, i));
            return memo;
          }, []);
          var height = contents.length;
          if (height > max_height) {
            max_height = height;
          }
          ;
          cells.push({ contents, height });
        });
        var lines = new Array(max_height);
        cells.forEach(function(cell, i) {
          cell.contents.forEach(function(line2, j2) {
            if (!lines[j2]) {
              lines[j2] = [];
            }
            ;
            if (style2 || first_cell_head && i === 0 && options2.style.head) {
              line2 = applyStyles(options2.style.head, line2);
            }
            lines[j2].push(line2);
          });
          for (var j = cell.height, l2 = max_height; j < l2; j++) {
            if (!lines[j]) {
              lines[j] = [];
            }
            ;
            lines[j].push(string2("", i));
          }
        });
        var ret2 = "";
        lines.forEach(function(line2, index) {
          if (ret2.length > 0) {
            ret2 += "\n" + applyStyles(options2.style.border, chars.left);
          }
          ret2 += line2.join(applyStyles(options2.style.border, chars.middle)) + applyStyles(options2.style.border, chars.right);
        });
        return applyStyles(options2.style.border, chars.left) + ret2;
      }
      ;
      function applyStyles(styles3, subject) {
        if (!subject)
          return "";
        styles3.forEach(function(style2) {
          subject = colors[style2](subject);
        });
        return subject;
      }
      ;
      function string2(str, index) {
        var str = String(typeof str == "object" && str.text ? str.text : str), length = utils.strlen(str), width = colWidths[index] - (style["padding-left"] || 0) - (style["padding-right"] || 0), align = options2.colAligns[index] || "left";
        return repeat2(" ", style["padding-left"] || 0) + (length == width ? str : length < width ? pad2(str, width + (str.length - length), " ", align == "left" ? "right" : align == "middle" ? "both" : "left") : truncater ? truncate(str, width, truncater) : str) + repeat2(" ", style["padding-right"] || 0);
      }
      ;
      if (head.length) {
        lineTop();
        ret += generateRow(head, style.head) + "\n";
      }
      if (this.length)
        this.forEach(function(cells, i) {
          if (!head.length && i == 0)
            lineTop();
          else {
            if (!style.compact || i < !!head.length ? 1 : cells.length == 0) {
              var l2 = line(
                chars.mid,
                chars["left-mid"],
                chars["right-mid"],
                chars["mid-mid"]
              );
              if (l2)
                ret += l2 + "\n";
            }
          }
          if (cells.hasOwnProperty("length") && !cells.length) {
            return;
          } else {
            ret += generateRow(cells) + "\n";
          }
          ;
        });
      var l = line(
        chars.bottom,
        chars["bottom-left"] || chars.bottom,
        chars["bottom-right"] || chars.bottom,
        chars["bottom-mid"]
      );
      if (l)
        ret += l;
      else
        ret = ret.slice(0, -1);
      return ret;
    };
    module2.exports = Table;
    module2.exports.version = "0.0.1";
  }
});

// src/markdown/renderer.ts
function identity(str) {
  return str;
}
function cleanUpHtml(input) {
  return gray(input.replace(/(<([^>]+)>)/ig, ""));
}
function fixHardReturn(text, reflow) {
  return reflow ? text.replace(HARD_RETURN, "\n") : text;
}
function indentLines(indent, text) {
  return text.replace(/(^|\n)(.+)/g, "$1" + indent + "$2");
}
function identify(indent, text) {
  if (!text) return text;
  return indent + text.split("\n").join("\n" + indent);
}
function fixNestedLists(body, indent) {
  let regex2 = new RegExp(
    "(\\S(?: |  )?)((?:" + indent + ")+)(" + POINT_REGEX + "(?:.*)+)$",
    "gm"
  );
  return body.replace(regex2, "$1\n" + indent + "$2$3");
}
function toSpaces(str) {
  return " ".repeat(str.length);
}
function toSpecialSpaces(str) {
  return SPECIAL_SPACE.repeat(str.length);
}
function bulletPointLine(indent, line) {
  if (isPointedLine(line, indent)) {
    return line;
  }
  if (!line.includes(SPECIAL_SPACE)) {
    return toSpecialSpaces(BULLET_POINT) + line;
  }
  return line;
}
function bulletPointLines(lines, indent) {
  let transform = bulletPointLine.bind(null, indent);
  return lines.split("\n").filter(identity).map(transform).join("\n");
}
function numberedLine(indent, line, num) {
  return isPointedLine(line, indent) ? {
    num: num + 1,
    line: line.replace(BULLET_POINT, numberedPoint(num + 1))
  } : {
    num,
    line: toSpaces(numberedPoint(num)) + line
  };
}
function numberedLines(lines, indent) {
  let transform = numberedLine.bind(null, indent);
  let num = 0;
  return lines.split("\n").filter(identity).map((line) => {
    const numbered = transform(line, num);
    num = numbered.num;
    return numbered.line;
  }).join("\n");
}
function list(body, ordered, indent) {
  body = body.trim();
  body = ordered ? numberedLines(body, indent) : bulletPointLines(body, indent);
  return body;
}
function section(text) {
  return text + "\n\n";
}
function undoColon(str) {
  return str.replace(COLON_REPLACER_REGEXP, ":");
}
function generateTableRow(text, escape2 = null) {
  if (!text) return [];
  escape2 = escape2 || identity;
  let lines = escape2(text).split("\n");
  let data = [];
  lines.forEach(function(line) {
    if (!line) return;
    let parsed = line.replace(TABLE_ROW_WRAP_REGEXP, "").split(TABLE_CELL_SPLIT);
    data.push(parsed.splice(0, parsed.length - 1));
  });
  return data;
}
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function unescapeEntities(html) {
  return html.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
}
var TABLE_CELL_SPLIT, TABLE_ROW_WRAP, TABLE_ROW_WRAP_REGEXP, COLON_REPLACER, COLON_REPLACER_REGEXP, HARD_RETURN, defaultOptions, BULLET_POINT_REGEX, NUMBERED_POINT_REGEX, POINT_REGEX, isPointedLine, SPECIAL_SPACE, SPACE, BULLET_POINT, numberedPoint, links, Renderer, renderer_default;
var init_renderer = __esm({
  "src/markdown/renderer.ts"() {
    "use strict";
    init_object();
    init_styles();
    TABLE_CELL_SPLIT = "^*||*^";
    TABLE_ROW_WRAP = "*|*|*|*";
    TABLE_ROW_WRAP_REGEXP = new RegExp(escapeRegExp(TABLE_ROW_WRAP), "g");
    COLON_REPLACER = "*#COLON|*";
    COLON_REPLACER_REGEXP = new RegExp(escapeRegExp(COLON_REPLACER), "g");
    HARD_RETURN = /\r/g;
    defaultOptions = {
      code: identity,
      blockquote: identity,
      html: cleanUpHtml,
      heading: magenta,
      firstHeading: magenta,
      hr: identity,
      listitem: identity,
      list,
      table: identity,
      paragraph: identity,
      strong: bold,
      em: italic,
      codespan: yellow,
      del: strikethrough,
      link: underline,
      href: underline,
      text: identity,
      unescape: true,
      emoji: false,
      width: 80,
      showSectionPrefix: false,
      tab: 2,
      tableOptions: {}
    };
    BULLET_POINT_REGEX = "\\*";
    NUMBERED_POINT_REGEX = "\\d+\\.";
    POINT_REGEX = "(?:" + [BULLET_POINT_REGEX, NUMBERED_POINT_REGEX].join("|") + ")";
    isPointedLine = function(line, indent) {
      return line.match("^(?:" + indent + ")*" + POINT_REGEX) != null;
    };
    SPECIAL_SPACE = "\0\0\0";
    SPACE = " ";
    BULLET_POINT = "* ";
    numberedPoint = function(n) {
      return n + ". ";
    };
    links = /* @__PURE__ */ new Map();
    Renderer = class {
      constructor(options2 = {}, highlightOptions = {}) {
        this.options = options2;
        this.highlightOptions = highlightOptions;
        this.o = Object.assign({}, defaultOptions, options2);
        this.tab = "  ";
        this.tableSettings = this.o.tableOptions;
        this.unescape = unescapeEntities;
        this.highlightOptions = toObject(highlightOptions);
        this.transform = this.compose(undoColon, this.unescape);
      }
      static {
        this.hooks = {
          preprocess: (str) => str,
          postprocess: (str) => {
            return str.replace(new RegExp(SPECIAL_SPACE, "g"), SPACE);
          }
        };
      }
      text(t) {
        return this.o.text(t);
      }
      code(code, lang, _escaped) {
        return "``` " + lang + "\n" + code + "\n```\n";
      }
      blockquote(quote) {
        return section(this.o.blockquote(identify(this.tab, quote.trim())));
      }
      html(html) {
        return this.o.html(html);
      }
      heading(text, level2, _raw) {
        text = this.transform(text);
        return section(
          level2 === 1 ? this.o.firstHeading(text) : this.o.heading(text)
        );
      }
      hr() {
        return `\u2500\u2500\u2500
`;
      }
      list(body, ordered) {
        body = this.o.list(body, ordered, this.tab);
        return section(fixNestedLists(indentLines(this.tab, body), this.tab));
      }
      listitem(text) {
        let transform = this.compose(this.o.listitem, this.transform);
        let isNested = text.indexOf("\n") !== -1;
        if (isNested) text = text.trim();
        return "\n" + BULLET_POINT + transform(text);
      }
      checkbox(checked) {
        return "[" + (checked ? "X" : " ") + "] ";
      }
      paragraph(text) {
        let transform = this.compose(this.o.paragraph, this.transform);
        text = transform(text);
        return section(text);
      }
      table(header, body) {
        const Table = require_lib4();
        let table = new Table(
          Object.assign(
            {},
            {
              head: generateTableRow(header)[0]
            },
            this.tableSettings
          )
        );
        generateTableRow(body, this.transform).forEach(function(row) {
          table.push(row);
        });
        return section(this.o.table(table.toString()));
      }
      tablerow(content) {
        return TABLE_ROW_WRAP + content + TABLE_ROW_WRAP + "\n";
      }
      tablecell(content, _flags) {
        return content + TABLE_CELL_SPLIT;
      }
      strong(text) {
        return this.o.strong(text);
      }
      em(text) {
        text = fixHardReturn(text, this.o.reflowText);
        return this.o.em(text);
      }
      codespan(text) {
        text = fixHardReturn(text, this.o.reflowText);
        return this.o.codespan(text.replace(/:/g, COLON_REPLACER));
      }
      br() {
        return "\n";
      }
      del(text) {
        return this.o.del(text);
      }
      link(href, title, text) {
        let prot;
        try {
          prot = decodeURIComponent(unescape(href)).replace(/[^\w:]/g, "").toLowerCase();
        } catch (e) {
          return "";
        }
        if (prot.startsWith("javascript:")) {
          return "";
        }
        if (text && href && text != href) {
          links.set(text, href);
        }
        if (text && text != href) return blue(text);
        let out = this.o.href(href);
        return this.o.link(out);
      }
      image(href, title, text) {
        let out = "![" + text;
        return out + "](" + href + ")";
      }
      // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
      compose(...funcs) {
        return (...args) => {
          for (let i = funcs.length; i-- > 0; ) {
            args = [funcs[i].apply(this, args)];
          }
          return args[0];
        };
      }
      static getLinks() {
        let res = [];
        for (let [text, href] of links.entries()) {
          res.push(`${blue(text)}: ${href}`);
        }
        links.clear();
        return res;
      }
    };
    renderer_default = Renderer;
  }
});

// src/markdown/index.ts
function toFiletype(match) {
  if (!match) return TXT;
  let mapped = filetyepsMap[match];
  return string(mapped) ? mapped : match;
}
function parseDocuments(docs, opts = {}) {
  let lines = [];
  let highlights = [];
  let codes = [];
  let idx = 0;
  for (let doc of docs) {
    let currline = lines.length;
    let { content, filetype } = doc;
    let hls = doc.highlights;
    if (filetype == MARKDOWN) {
      let info = parseMarkdown(content, opts);
      codes.push(...info.codes.map((o) => {
        o.startLine = o.startLine + currline;
        o.endLine = o.endLine + currline;
        return o;
      }));
      highlights.push(...info.highlights.map((o) => {
        o.lnum = o.lnum + currline;
        return o;
      }));
      lines.push(...info.lines);
    } else {
      let parts = content.trim().split(/\r?\n/);
      let hlGroup = FiletypeHighlights[doc.filetype];
      if (string(hlGroup)) {
        codes.push({ hlGroup, startLine: currline, endLine: currline + parts.length });
      } else {
        codes.push({ filetype: doc.filetype, startLine: currline, endLine: currline + parts.length });
      }
      lines.push(...parts);
    }
    if (Array.isArray(hls)) {
      highlights.push(...hls.map((o) => {
        return Object.assign({}, o, { lnum: o.lnum + currline });
      }));
    }
    if (Array.isArray(doc.active)) {
      let arr = getHighlightItems(content, currline, doc.active);
      if (arr.length) highlights.push(...arr);
    }
    if (idx != docs.length - 1) {
      highlights.push({
        lnum: lines.length,
        hlGroup: DIVIDING_LINE_HI_GROUP,
        colStart: 0,
        colEnd: -1
      });
      lines.push(DIVIDE_CHARACTER);
    }
    idx = idx + 1;
  }
  return { lines, highlights, codes };
}
function getHighlightItems(content, currline, active) {
  let res = [];
  let [start, end] = active;
  let lines = content.split(/\r?\n/);
  let used = 0;
  let inRange = false;
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    if (!inRange) {
      if (used + line.length > start) {
        inRange = true;
        let colStart = byteIndex(line, start - used);
        if (used + line.length > end) {
          let colEnd = byteIndex(line, end - used);
          inRange = false;
          res.push({ colStart, colEnd, lnum: i + currline, hlGroup: ACTIVE_HL_GROUP });
          break;
        } else {
          let colEnd = byteLength(line);
          res.push({ colStart, colEnd, lnum: i + currline, hlGroup: ACTIVE_HL_GROUP });
        }
      }
    } else {
      if (used + line.length > end) {
        let colEnd = byteIndex(line, end - used);
        res.push({ colStart: 0, colEnd, lnum: i + currline, hlGroup: ACTIVE_HL_GROUP });
        inRange = false;
        break;
      } else {
        let colEnd = byteLength(line);
        res.push({ colStart: 0, colEnd, lnum: i + currline, hlGroup: ACTIVE_HL_GROUP });
      }
    }
    used = used + line.length + 1;
  }
  return res;
}
function parseMarkdown(content, opts) {
  marked.setOptions({
    renderer: new renderer_default(),
    gfm: true,
    breaks: boolean(opts.breaks) ? opts.breaks : true,
    hooks: renderer_default.hooks
  });
  let lines = [];
  let highlights = [];
  let codes = [];
  let currline = 0;
  let inCodeBlock = false;
  let filetype;
  let startLnum = 0;
  let parsed = marked(content);
  let links2 = renderer_default.getLinks();
  parsed = parsed.replace(/\s*$/, "");
  if (links2.length) {
    parsed = parsed + "\n\n" + links2.join("\n");
  }
  let parsedLines = parsed.split(/\n/);
  for (let i = 0; i < parsedLines.length; i++) {
    let line = parsedLines[i];
    if (!line.length) {
      let pre = lines[lines.length - 1];
      if (!pre) continue;
      let next = parsedLines[i + 1];
      if (!next || next.startsWith(DOTS) || next.startsWith(DIVIDE_CHARACTER)) continue;
      lines.push(line);
      currline++;
      continue;
    }
    if (opts.excludeImages && line.indexOf("![") !== -1) {
      line = line.replace(/\s*!\[.*?\]\(.*?\)/g, "");
      if (!stripAnsi(line).trim().length) continue;
    }
    let ms = line.match(/^\s*```\s*(\S+)?/);
    if (ms) {
      if (!inCodeBlock) {
        let pre = parsedLines[i - 1];
        if (pre && /^\s*```\s*/.test(pre)) {
          lines.push("");
          currline++;
        }
        inCodeBlock = true;
        filetype = toFiletype(ms[1]);
        startLnum = currline;
      } else {
        inCodeBlock = false;
        codes.push({
          filetype,
          startLine: startLnum,
          endLine: currline
        });
      }
      continue;
    }
    if (inCodeBlock) {
      lines.push(line);
      currline++;
      continue;
    }
    let res = parseAnsiHighlights(line, true);
    if (line === DIVIDE_LINE) {
      highlights.push({
        hlGroup: DIVIDING_LINE_HI_GROUP,
        lnum: currline,
        colStart: 0,
        colEnd: -1
      });
    } else if (res.highlights) {
      for (let hi of res.highlights) {
        let { hlGroup, span } = hi;
        highlights.push({
          hlGroup,
          lnum: currline,
          colStart: span[0],
          colEnd: span[1]
        });
      }
    }
    lines.push(res.line);
    currline++;
  }
  return { lines, highlights, codes };
}
var FiletypeHighlights, filetyepsMap, ACTIVE_HL_GROUP, DIVIDING_LINE_HI_GROUP, MARKDOWN, DOTS, TXT, DIVIDE_CHARACTER, DIVIDE_LINE;
var init_markdown = __esm({
  "src/markdown/index.ts"() {
    "use strict";
    init_marked_esm();
    init_ansiparse();
    init_is();
    init_node();
    init_string();
    init_renderer();
    FiletypeHighlights = /* @__PURE__ */ ((FiletypeHighlights2) => {
      FiletypeHighlights2["Error"] = "CocErrorFloat";
      FiletypeHighlights2["Warning"] = "CocWarningFloat";
      FiletypeHighlights2["Info"] = "CocInfoFloat";
      FiletypeHighlights2["Hint"] = "CocHintFloat";
      return FiletypeHighlights2;
    })(FiletypeHighlights || {});
    filetyepsMap = {
      js: "javascript",
      ts: "typescript",
      bash: "sh"
    };
    ACTIVE_HL_GROUP = "CocFloatActive";
    DIVIDING_LINE_HI_GROUP = "CocFloatDividingLine";
    MARKDOWN = "markdown";
    DOTS = "```";
    TXT = "txt";
    DIVIDE_CHARACTER = "\u2500";
    DIVIDE_LINE = "\u2500\u2500\u2500";
  }
});

// src/model/floatFactory.ts
var debounceTime2, FloatFactoryImpl;
var init_floatFactory = __esm({
  "src/model/floatFactory.ts"() {
    "use strict";
    init_node();
    init_events();
    init_markdown();
    init_util();
    init_array();
    init_mutex();
    init_object();
    init_protocol();
    init_constants();
    debounceTime2 = getConditionValue(100, 10);
    FloatFactoryImpl = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.winid = 0;
        this._bufnr = 0;
        this.mutex = new Mutex();
        this.disposables = [];
        this.onCursorMoved = debounce(this._onCursorMoved.bind(this), debounceTime2);
      }
      bindEvents(autoHide, alignTop) {
        let eventNames = ["InsertLeave", "InsertEnter", "BufEnter"];
        for (let ev of eventNames) {
          events_default.on(ev, (bufnr) => {
            if (bufnr == this._bufnr) return;
            this.close();
          }, null, this.disposables);
        }
        events_default.on("MenuPopupChanged", () => {
          if (events_default.pumAlignTop == alignTop) {
            this.close();
          }
        }, null, this.disposables);
        this.disposables.push(import_node4.Disposable.create(() => {
          this.onCursorMoved.clear();
        }));
        events_default.on("CursorMoved", this.onCursorMoved.bind(this, autoHide), this, this.disposables);
        events_default.on("CursorMovedI", this.onCursorMoved.bind(this, autoHide), this, this.disposables);
      }
      unbind() {
        if (this.disposables.length) {
          disposeAll(this.disposables);
          this.disposables = [];
        }
      }
      _onCursorMoved(autoHide, bufnr, cursor) {
        if (bufnr == this._bufnr) return;
        if (bufnr == this.targetBufnr && equals(cursor, this.cursor)) {
          return;
        }
        if (bufnr != this.targetBufnr || !events_default.insertMode || autoHide) {
          this.close();
          return;
        }
      }
      /**
       * Create float window/popup at cursor position.
       * @deprecated use show method instead
       */
      async create(docs, _allowSelection = false, offsetX = 0) {
        await this.show(docs, {
          offsetX
        });
      }
      /**
       * Show documentations in float window/popup around cursor.
       * Window and buffer are reused when possible.
       * Window is closed automatically on change buffer, InsertEnter, CursorMoved and CursorMovedI.
       * @param docs List of documentations.
       * @param config Configuration for floating window/popup.
       */
      async show(docs, config = {}) {
        if (docs.length == 0 || docs.every((doc) => doc.content.length == 0)) {
          this.close();
          return;
        }
        let curr = Date.now();
        let release = await this.mutex.acquire();
        try {
          await this.createPopup(docs, config, curr);
          release();
        } catch (e) {
          this.nvim.echoError(e);
          release();
        }
      }
      async createPopup(docs, opts, timestamp) {
        docs = docs.filter((o) => o.content.trim().length > 0);
        let { lines, codes, highlights } = parseDocuments(docs, { excludeImages: opts.excludeImages, breaks: opts.breaks });
        let config = {
          codes,
          highlights,
          pumAlignTop: events_default.pumAlignTop,
          preferTop: typeof opts.preferTop === "boolean" ? opts.preferTop : false,
          offsetX: opts.offsetX || 0,
          title: opts.title || "",
          close: opts.close ? 1 : 0,
          rounded: opts.rounded ? 1 : 0,
          modes: opts.modes || ["n", "i", "ic", "s"]
        };
        if (!isVim) {
          if (typeof opts.winblend === "number") config.winblend = opts.winblend;
          if (opts.focusable != null) config.focusable = opts.focusable ? 1 : 0;
          if (opts.shadow) config.shadow = 1;
        }
        if (opts.maxHeight) config.maxHeight = opts.maxHeight;
        if (opts.maxWidth) config.maxWidth = opts.maxWidth;
        if (opts.border === true) {
          config.border = [1, 1, 1, 1];
        } else if (Array.isArray(opts.border) && !opts.border.every((o) => o == 0)) {
          config.border = opts.border.slice(0, 4);
          config.rounded = opts.rounded ? 1 : 0;
        }
        if (opts.highlight) config.highlight = opts.highlight;
        if (opts.borderhighlight) config.borderhighlight = opts.borderhighlight;
        if (opts.cursorline) config.cursorline = 1;
        if (opts.position) config.relative = opts.position === "fixed" ? config.relative = "editor" : "cursor";
        if (typeof opts.top === "number" && opts.top >= 0) config.top = opts.top;
        if (typeof opts.left === "number" && opts.left >= 0) config.left = opts.left;
        if (typeof opts.bottom === "number" && opts.bottom >= 0) config.bottom = opts.bottom;
        if (typeof opts.right === "number" && opts.right >= 0) config.right = opts.right;
        let autoHide = opts.autoHide === false ? false : true;
        if (autoHide) config.autohide = 1;
        this.unbind();
        let arr = await this.nvim.call("coc#dialog#create_cursor_float", [this.winid, this._bufnr, lines, config]);
        this.nvim.redrawVim();
        if (isFalsyOrEmpty(arr) || this.closeTs > timestamp) {
          let winid2 = arr && arr.length > 0 ? arr[2] : this.winid;
          if (winid2) {
            this.winid = 0;
            this.nvim.call("coc#float#close", [winid2], true);
            this.nvim.redrawVim();
          }
          return;
        }
        let [targetBufnr, cursor, winid, bufnr, alignTop] = arr;
        this.winid = winid;
        this._bufnr = bufnr;
        this.targetBufnr = targetBufnr;
        this.cursor = cursor;
        this.bindEvents(autoHide, alignTop == 1);
      }
      /**
       * Close float window
       */
      close() {
        let { winid, nvim } = this;
        this.closeTs = Date.now();
        this.unbind();
        if (winid) {
          this.winid = 0;
          nvim.call("coc#float#close", [winid], true);
          nvim.redrawVim();
        }
      }
      checkRetrigger(bufnr) {
        if (this.winid && this.targetBufnr == bufnr) return true;
        return false;
      }
      get bufnr() {
        return this._bufnr;
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : null;
      }
      get window() {
        return this.winid ? this.nvim.createWindow(this.winid) : null;
      }
      async activated() {
        if (!this.winid) return false;
        return await this.nvim.call("coc#float#valid", [this.winid]) != 0;
      }
      dispose() {
        this.cursor = void 0;
        this.onCursorMoved.clear();
        this.close();
      }
    };
  }
});

// src/model/regions.ts
var Regions;
var init_regions = __esm({
  "src/model/regions.ts"() {
    "use strict";
    Regions = class {
      constructor() {
        /**
         * ranges that never overlaps.
         */
        this.ranges = [];
      }
      get current() {
        let res = [];
        this.ranges.sort((a, b) => a[0] - b[0]);
        this.ranges.forEach((o) => {
          res.push(o[0], o[1]);
        });
        return res;
      }
      get isEmpty() {
        return this.ranges.length === 0;
      }
      clear() {
        this.ranges = [];
      }
      getRange(line) {
        for (const [start, end] of this.ranges) {
          if (line >= start && line <= end) return [start, end];
        }
        return void 0;
      }
      /**
       * Get the span that not covered yet, all 0 based
       */
      toUncoveredSpan(span, delta, max) {
        let [start, end] = span;
        start = Math.max(0, start - delta);
        end = Math.min(max, end + delta);
        let r = this.getRange(start);
        start = r ? r[1] : start;
        let s = this.getRange(end);
        if (s && r && s[0] === r[0] && s[1] === r[1]) return void 0;
        end = s ? s[0] : end;
        return [start, end];
      }
      /**
       * start, end 0 based, both inclusive
       */
      add(start, end) {
        if (start > end) {
          [start, end] = [end, start];
        }
        let { ranges } = this;
        if (ranges.length == 0) {
          ranges.push([start, end]);
        } else {
          ranges.sort((a, b) => a[0] - b[0]);
          let s;
          let e;
          let removedIndexes = [];
          for (let i = 0; i < ranges.length; i++) {
            let r = ranges[i];
            if (r[1] < start - 1) continue;
            if (r[0] > end + 1) break;
            removedIndexes.push(i);
            if (s == null) s = Math.min(start, r[0]);
            e = Math.max(end, r[1]);
          }
          let newRanges = removedIndexes.length ? ranges.filter((_, i) => !removedIndexes.includes(i)) : ranges;
          this.ranges = newRanges;
          if (s != null && e != null) {
            this.ranges.push([s, e]);
          } else {
            this.ranges.push([start, end]);
          }
        }
      }
      has(start, end) {
        let idx = this.ranges.findIndex((o) => o[0] <= start && o[1] >= end);
        return idx !== -1;
      }
      static mergeSpans(ranges) {
        let res = [];
        for (let r of ranges) {
          let idx = res.findIndex((o) => !(r[1] < o[0] || r[0] > o[1]));
          if (idx == -1) {
            res.push(r);
          } else {
            let o = res[idx];
            res[idx] = [Math.min(r[0], o[0]), Math.max(r[1], o[1])];
          }
        }
        return res;
      }
    };
  }
});

// src/core/ui.ts
async function getCursorPosition(nvim) {
  let [line, content] = await nvim.eval(`[line('.')-1, strpart(getline('.'), 0, col('.') - 1)]`);
  return Position.create(line, content.length);
}
async function getVisibleRanges(nvim, bufnr, winid) {
  if (winid == null) {
    const spans = await nvim.call("coc#window#visible_ranges", [bufnr]);
    if (spans.length === 0) return [];
    return Regions.mergeSpans(spans);
  }
  const span = await nvim.call("coc#window#visible_range", [winid]);
  return span == null ? [] : [span];
}
async function getLineAndPosition(nvim) {
  let [text, lnum, content] = await nvim.eval(`[getline('.'), line('.'), strpart(getline('.'), 0, col('.') - 1)]`);
  return { text, line: lnum - 1, character: content.length };
}
function createFloatFactory(nvim, conf, defaults) {
  let opts = Object.assign({}, defaults, conf);
  let factory = new FloatFactoryImpl(nvim);
  return {
    get window() {
      return factory.window;
    },
    show: (docs, option) => {
      return factory.show(docs, option ? Object.assign({}, opts, option) : opts);
    },
    activated: () => {
      return factory.activated();
    },
    dispose: () => {
      factory.dispose();
    },
    checkRetrigger: (bufnr) => {
      return factory.checkRetrigger(bufnr);
    },
    close: () => {
      factory.close();
    }
  };
}
async function showPrompt(nvim, title) {
  let res = await nvim.callAsync("coc#dialog#prompt_confirm", [title]);
  return res == 1;
}
async function moveTo(nvim, position, redraw) {
  await nvim.call("coc#cursor#move_to", [position.line, position.character]);
  if (redraw) nvim.command("redraw", true);
}
async function getOffset(nvim) {
  return await nvim.call("coc#cursor#char_offset");
}
async function getCursorScreenPosition(nvim) {
  let [row, col] = await nvim.call("coc#cursor#screen_pos");
  return { row, col };
}
async function echoLines(nvim, env, lines, truncate) {
  let cmdHeight = env.cmdheight;
  if (lines.length > cmdHeight && truncate) {
    lines = lines.slice(0, cmdHeight);
  }
  let maxLen = env.columns - 12;
  lines = lines.map((line) => {
    line = line.replace(/\n/g, " ");
    if (truncate) line = line.slice(0, maxLen);
    return line;
  });
  if (truncate && lines.length == cmdHeight) {
    let last = lines[lines.length - 1];
    lines[cmdHeight - 1] = `${last.length >= maxLen ? last.slice(0, -4) : last} ...`;
  }
  await nvim.call("coc#ui#echo_lines", [lines]);
}
function echoMessages(nvim, msg, messageType, messageLevel) {
  let hl = "Error";
  let level2 = 2 /* Error */;
  switch (messageType) {
    case "more":
      level2 = 0 /* More */;
      hl = "MoreMsg";
      break;
    case "warning":
      level2 = 1 /* Warning */;
      hl = "WarningMsg";
      break;
  }
  if (level2 >= toMessageLevel(messageLevel)) {
    let method = isVim ? "callTimer" : "call";
    nvim[method]("coc#ui#echo_messages", [hl, ("[coc.nvim] " + msg).split("\n")], true);
  }
}
function toMessageLevel(level2) {
  switch (level2) {
    case "error":
      return 2 /* Error */;
    case "warning":
      return 1 /* Warning */;
    default:
      return 0 /* More */;
  }
}
async function getSelection(nvim, mode) {
  if (mode === "currline") {
    let line = await nvim.call("line", ["."]);
    return Range.create(line - 1, 0, line, 0);
  }
  if (mode === "cursor") {
    let position = await getCursorPosition(nvim);
    return Range.create(position, position);
  }
  let res = await nvim.call("coc#cursor#get_selection", [operateModes.includes(mode) ? 1 : 0]);
  if (!res || res[0] == -1) return null;
  return Range.create(res[0], res[1], res[2], res[3]);
}
async function selectRange(nvim, range, redraw) {
  let { start, end } = range;
  let [line, endLine] = await nvim.eval(`[getline(${start.line + 1}),getline(${end.line + 1})]`);
  let col = line.length > 0 ? byteIndex(line, start.character) : 0;
  let endCol;
  let endLnum;
  let toEnd = end.character == 0;
  if (toEnd) {
    endLnum = end.line == 0 ? 0 : end.line - 1;
    let pre = await nvim.call("getline", [endLnum + 1]);
    endCol = byteLength(pre);
  } else {
    endLnum = end.line;
    endCol = endLine.length > 0 ? byteIndex(endLine, end.character) : 0;
  }
  nvim.pauseNotification();
  nvim.command(`noa call cursor(${start.line + 1},${col + 1})`, true);
  nvim.command("normal! v", true);
  nvim.command(`noa call cursor(${endLnum + 1},${endCol})`, true);
  if (toEnd) nvim.command("normal! $", true);
  await nvim.resumeNotification(redraw);
}
var operateModes;
var init_ui = __esm({
  "src/core/ui.ts"() {
    "use strict";
    init_main();
    init_floatFactory();
    init_regions();
    init_constants();
    init_string();
    operateModes = ["char", "line", "block"];
  }
});

// src/core/dialogs.ts
var Dialogs;
var init_dialogs = __esm({
  "src/core/dialogs.ts"() {
    "use strict";
    init_events();
    init_dialog();
    init_input();
    init_menu();
    init_picker();
    init_quickpick();
    init_util();
    init_array();
    init_constants();
    init_mutex();
    init_numbers();
    init_string();
    init_funcs();
    init_ui();
    Dialogs = class {
      constructor() {
        this.mutex = new Mutex();
      }
      async showDialog(config) {
        return await this.mutex.use(async () => {
          let dialog = new Dialog(this.nvim, config);
          await dialog.show(this.dialogPreference);
          return dialog;
        });
      }
      async showPrompt(title) {
        return await this.mutex.use(() => {
          return showPrompt(this.nvim, title);
        });
      }
      async createQuickPick(config) {
        return await this.mutex.use(async () => {
          let quickpick = new QuickPick(this.nvim, this.dialogPreference);
          Object.assign(quickpick, config);
          return quickpick;
        });
      }
      async showMenuPicker(items, option, token) {
        return await this.mutex.use(async () => {
          if (token && token.isCancellationRequested) return -1;
          option = option || {};
          if (typeof option === "string") option = { title: option };
          let menu = new Menu(this.nvim, { items, ...option }, token);
          let promise = new Promise((resolve) => {
            menu.onDidClose((selected) => {
              void events_default.race(["BufHidden"], 20).finally(() => {
                resolve(selected);
              });
            });
          });
          await menu.show(this.dialogPreference);
          return await promise;
        });
      }
      /**
       * Shows a selection list.
       */
      async showQuickPick(itemsOrItemsPromise, options2, token) {
        options2 = defaultValue(options2, {});
        const items = await Promise.resolve(itemsOrItemsPromise);
        if (isFalsyOrEmpty(items)) return void 0;
        let isText = items.some((s) => typeof s === "string");
        return await this.mutex.use(() => {
          return new Promise((resolve, reject) => {
            if (token.isCancellationRequested) return resolve(void 0);
            let quickpick = new QuickPick(this.nvim, this.dialogPreference);
            quickpick.items = items.map((o) => typeof o === "string" ? { label: o } : o);
            quickpick.title = toText(options2.title);
            quickpick.placeholder = options2.placeHolder ?? options2["placeholder"];
            quickpick.canSelectMany = !!options2.canPickMany;
            quickpick.matchOnDescription = options2.matchOnDescription;
            quickpick.onDidFinish((items2) => {
              if (items2 == null) return resolve(void 0);
              let arr = isText ? items2.map((o) => o.label) : items2;
              if (options2.canPickMany) return resolve(arr);
              resolve(arr[0]);
            });
            quickpick.show().catch(reject);
          });
        });
      }
      async showPickerDialog(items, title, token) {
        return await this.mutex.use(async () => {
          if (token && token.isCancellationRequested) {
            return void 0;
          }
          const picker = new Picker(this.nvim, {
            title,
            items: toPickerItems(items)
          }, token);
          let promise = new Promise((resolve) => {
            picker.onDidClose((selected) => {
              resolve(selected);
            });
          });
          await picker.show(this.dialogPreference);
          let picked = await promise;
          return picked == void 0 ? void 0 : items.filter((_, i) => picked.includes(i));
        });
      }
      async requestInput(title, _env, value, option) {
        let { nvim } = this;
        const promptInput = this.configuration.get("coc.preferences.promptInput");
        if (promptInput) {
          return await this.mutex.use(async () => {
            let input = new InputBox(nvim, toText(value));
            await input.show(title, Object.assign(this.inputPreference, defaultValue(option, {})));
            return await new Promise((resolve) => {
              input.onDidFinish((text) => {
                setTimeout(() => {
                  resolve(text);
                }, 20);
              });
            });
          });
        } else {
          return await this.mutex.use(async () => {
            let res = await callAsync(this.nvim, "input", [title + ": ", toText(value)]);
            nvim.command("normal! :<C-u>", true);
            return res;
          });
        }
      }
      /**
       * Request selection by use inputlist of vim.
       */
      async requestInputList(prompt, items) {
        let { nvim } = this;
        return await this.mutex.use(async () => {
          let list2 = items.map((text, i) => `${i + 1}. ${text}`);
          let res = await callAsync(this.nvim, "inputlist", [[`${prompt}:`, ...list2]]);
          nvim.command("normal! :<C-u>", true);
          return res >= 1 && res <= items.length ? res - 1 : -1;
        });
      }
      async createInputBox(title, value, option) {
        let input = new InputBox(this.nvim, toText(value));
        await input.show(title, Object.assign(this.inputPreference, defaultValue(option, {})));
        return input;
      }
      get inputPreference() {
        let config = this.configuration.get("dialog");
        return {
          rounded: !!config.rounded,
          maxWidth: toNumber(config.maxWidth, 80),
          highlight: defaultValue(config.floatHighlight, floatHighlightGroup),
          borderhighlight: defaultValue(config.floatBorderHighlight, floatHighlightGroup)
        };
      }
      get dialogPreference() {
        let config = this.configuration.get("dialog");
        return {
          rounded: !!config.rounded,
          maxWidth: toNumber(config.maxWidth, 80),
          maxHeight: config.maxHeight,
          floatHighlight: defaultValue(config.floatHighlight, floatHighlightGroup),
          floatBorderHighlight: defaultValue(config.floatBorderHighlight, floatHighlightGroup),
          pickerButtons: config.pickerButtons,
          pickerButtonShortcut: config.pickerButtonShortcut,
          confirmKey: toText(config.confirmKey),
          shortcutHighlight: toText(config.shortcutHighlight)
        };
      }
    };
  }
});

// src/core/highlights.ts
function convertHighlightItem(item) {
  return [item.hlGroup, item.lnum, item.colStart, item.colEnd, item.combine ? 1 : 0, item.start_incl ? 1 : 0, item.end_incl ? 1 : 0];
}
function isSame(item, curr) {
  return curr[0] == item.hlGroup && curr[1] === item.lnum && curr[2] === item.colStart && curr[3] === item.colEnd;
}
var Highlights;
var init_highlights = __esm({
  "src/core/highlights.ts"() {
    "use strict";
    init_util();
    Highlights = class {
      async diffHighlights(bufnr, ns, items, region, token) {
        let args = [bufnr, ns, Array.isArray(region) ? region[0] : 0, Array.isArray(region) ? region[1] : -1];
        let curr = await this.nvim.call("coc#highlight#get_highlights", args);
        if (!curr || token?.isCancellationRequested) return null;
        items.sort((a, b) => {
          if (a.lnum != b.lnum) return a.lnum - b.lnum;
          if (a.colStart != b.colStart) return a.colStart - b.colStart;
          return a.hlGroup > b.hlGroup ? 1 : -1;
        });
        let removeMarkers = [];
        let newItems = [];
        let itemIndex = 0;
        let maxIndex = items.length - 1;
        let maxLnum = 0;
        let map = /* @__PURE__ */ new Map();
        curr.forEach((o) => {
          maxLnum = Math.max(maxLnum, o[1]);
          let arr = map.get(o[1]);
          if (arr) {
            arr.push(o);
          } else {
            map.set(o[1], [o]);
          }
        });
        if (curr.length > 0) {
          let start = Array.isArray(region) ? region[0] : 0;
          for (let i = start; i <= maxLnum; i++) {
            let exists = defaultValue(map.get(i), []);
            exists.sort((a, b) => {
              if (a[2] != b[2]) return a[2] - b[2];
              return a[0] > b[0] ? 1 : -1;
            });
            let added = [];
            for (let j = itemIndex; j <= maxIndex; j++) {
              let o = items[j];
              if (o.lnum == i) {
                itemIndex = j + 1;
                added.push(o);
              } else {
                itemIndex = j;
                break;
              }
            }
            if (added.length == 0) {
              removeMarkers.push(...exists.map((o) => o[4]));
            } else {
              if (exists.length == 0) {
                newItems.push(...added.map((o) => convertHighlightItem(o)));
              } else {
                let skip = 0;
                let min = Math.min(exists.length, added.length);
                while (skip < min) {
                  if (isSame(added[skip], exists[skip])) {
                    skip++;
                  } else {
                    break;
                  }
                }
                let toRemove = exists.slice(skip).map((o) => o[4]);
                removeMarkers.push(...toRemove);
                newItems.push(...added.slice(skip).map((o) => convertHighlightItem(o)));
              }
            }
          }
        }
        for (let i = itemIndex; i <= maxIndex; i++) {
          newItems.push(convertHighlightItem(items[i]));
        }
        return { remove: [], add: newItems, removeMarkers };
      }
      async applyDiffHighlights(bufnr, ns, priority, diff, notify) {
        let { nvim } = this;
        let { remove: remove2, add, removeMarkers } = diff;
        if (remove2.length === 0 && add.length === 0 && removeMarkers.length === 0) return;
        nvim.pauseNotification();
        if (add.length) {
          nvim.call("coc#highlight#set", [bufnr, ns, add, priority], true);
        }
        if (removeMarkers.length) {
          nvim.call("coc#highlight#del_markers", [bufnr, ns, removeMarkers], true);
        }
        if (notify) {
          nvim.resumeNotification(true, true);
        } else {
          await nvim.resumeNotification(true);
        }
      }
    };
  }
});

// src/model/notification.ts
function toButtons(texts) {
  return texts.map((s, index) => {
    return { text: s, index };
  });
}
function toTitles(items) {
  return items.map((item) => typeof item === "string" ? item : item.title);
}
var Notification;
var init_notification = __esm({
  "src/model/notification.ts"() {
    "use strict";
    init_events();
    init_util();
    init_array();
    Notification = class {
      constructor(nvim, config, attachEvents = true) {
        this.nvim = nvim;
        this.config = config;
        this.disposables = [];
        if (attachEvents) {
          events_default.on("BufWinLeave", (bufnr) => {
            if (bufnr == this.bufnr) {
              this.dispose();
              if (config.callback) config.callback(-1);
            }
          }, null, this.disposables);
          let btns = toArray(config.buttons).filter((o) => o.disabled != true);
          events_default.on("FloatBtnClick", (bufnr, idx) => {
            if (bufnr == this.bufnr) {
              this.dispose();
              if (config.callback) config.callback(btns[idx].index);
            }
          }, null, this.disposables);
        }
      }
      get lines() {
        return this.config.content ? this.config.content.split(/\r?\n/) : [];
      }
      async show(preferences) {
        let { nvim } = this;
        let { buttons, kind, title } = this.config;
        let opts = Object.assign({}, preferences);
        opts.kind = kind ?? "";
        opts.close = this.config.closable === true ? 1 : 0;
        if (title) opts.title = title;
        if (preferences.border) {
          opts.borderhighlight = kind ? `CocNotification${kind[0].toUpperCase()}${kind.slice(1)}` : preferences.highlight;
        }
        if (Array.isArray(buttons)) {
          let actions = buttons.filter((o) => !o.disabled).map((o) => o.text);
          if (actions.length) opts.actions = actions;
        }
        let res = await nvim.call("coc#notify#create", [this.lines, opts]);
        this._winid = res[0];
        this.bufnr = res[1];
      }
      get winid() {
        return this._winid;
      }
      dispose() {
        let { winid } = this;
        if (winid) {
          this.nvim.call("coc#notify#close", [winid], true);
          this.nvim.redrawVim();
        }
        this.bufnr = void 0;
        this._winid = void 0;
        disposeAll(this.disposables);
      }
    };
  }
});

// src/model/progress.ts
function formatMessage(title, message, total) {
  let parts = [];
  if (title) parts.push(title);
  if (message) parts.push(message);
  if (total) parts.push(total + "%");
  return parts.join(" ");
}
var logger6, ProgressNotification;
var init_progress = __esm({
  "src/model/progress.ts"() {
    "use strict";
    init_events();
    init_logger();
    init_protocol();
    init_notification();
    logger6 = createLogger("model-progress");
    ProgressNotification = class extends Notification {
      constructor(nvim, option) {
        super(nvim, {
          kind: "progress",
          title: option.title,
          closable: option.cancellable
        }, false);
        this.option = option;
        this._onDidFinish = new import_node4.Emitter();
        this.onDidFinish = this._onDidFinish.event;
        this.cancelProgress = (bufnr) => {
          if (bufnr == this.bufnr && this.tokenSource) {
            this.tokenSource.cancel();
          }
        };
        this.disposables.push(this._onDidFinish);
        events_default.on("BufWinLeave", this.cancelProgress, null, this.disposables);
      }
      async show(preferences) {
        let { task } = this.option;
        let tokenSource = this.tokenSource = new import_node4.CancellationTokenSource();
        this.disposables.push(tokenSource);
        let total = 0;
        if (!preferences.disabled) {
          await super.show(preferences);
        } else {
          logger6.warn(`progress window disabled by configuration "notification.disabledProgressSources"`);
        }
        task({
          report: (p) => {
            if (!this.winid) return;
            let { nvim } = this;
            if (p.increment) {
              total += p.increment;
              nvim.call("coc#window#set_var", [this.winid, "percent", `${total}%`], true);
            }
            if (p.message) nvim.call("coc#window#set_var", [this.winid, "message", p.message], true);
          }
        }, tokenSource.token).then((res) => {
          this._onDidFinish.fire(res);
          this.dispose();
        }, (err) => {
          if (err) this.nvim.echoError(err);
          this._onDidFinish.fire(void 0);
          this.dispose();
        });
      }
    };
  }
});

// src/core/notifications.ts
var Notifications;
var init_notifications = __esm({
  "src/core/notifications.ts"() {
    "use strict";
    init_notification();
    init_progress();
    init_util();
    init_extensionRegistry();
    init_numbers();
    init_protocol();
    init_string();
    init_ui();
    Notifications = class {
      constructor(dialogs) {
        this.dialogs = dialogs;
      }
      async _showMessage(kind, message, items) {
        if (!this.enableMessageDialog) return await this.showConfirm(message, items, kind);
        let stack = Error().stack;
        if (items.length > 0) {
          let source = parseExtensionName(stack);
          return await this.showMessagePicker(`Choose action ${toText(source)}`, message, `Coc${kind}Float`, items);
        }
        await this.createNotification(kind.toLowerCase(), message, [], stack);
        return void 0;
      }
      createNotification(kind, message, items, stack) {
        return new Promise((resolve, reject) => {
          let config = {
            kind,
            content: message,
            buttons: toButtons(items),
            callback: (idx) => {
              resolve(idx);
            }
          };
          let notification = new Notification(this.nvim, config);
          notification.show(this.getNotificationPreference(stack)).catch(reject);
        });
      }
      async showMessagePicker(title, content, hlGroup, items) {
        let texts = items.map((o) => typeof o === "string" ? o : o.title);
        let res = await this.dialogs.showMenuPicker(texts, {
          position: "center",
          content,
          title: title.replace(/\r?\n/, " "),
          borderhighlight: hlGroup
        });
        return items[res];
      }
      // fallback for vim without dialog
      async showConfirm(message, items, kind) {
        if (!items || items.length == 0) {
          let msgType = kind == "Info" ? "more" : kind == "Error" ? "error" : "warning";
          this.echoMessages(message, msgType);
          return void 0;
        }
        let titles = toTitles(items);
        let choices = titles.map((s, i) => `${i + 1}${s}`);
        let res = await this.nvim.callAsync("coc#util#with_callback", ["confirm", [message, choices.join("\n"), 0, kind]]);
        return items[res - 1];
      }
      echoMessages(msg, messageType) {
        let level2 = this.configuration.get("coc.preferences.messageLevel", "more");
        echoMessages(this.nvim, msg, messageType, level2);
      }
      async showNotification(config, stack) {
        let notification = new Notification(this.nvim, config);
        await notification.show(this.getNotificationPreference(stack));
      }
      async withProgress(options2, task) {
        let config = this.configuration.get("notification");
        if (!options2.cancellable && config.statusLineProgress) {
          return await this.createStatusLineProgress(options2, task);
        }
        let progress = new ProgressNotification(this.nvim, {
          task,
          title: options2.title,
          cancellable: options2.cancellable
        });
        let minWidth = toNumber(config.minProgressWidth, 40);
        let promise = new Promise((resolve) => {
          progress.onDidFinish(resolve);
        });
        let stack = Error().stack;
        await progress.show(Object.assign(this.getNotificationPreference(stack, options2.source), { minWidth }));
        return await promise;
      }
      async createStatusLineProgress(options2, task) {
        let { title } = options2;
        let statusItem = this.statusLine.createStatusBarItem(0, true);
        statusItem.text = toText(title);
        statusItem.show();
        let total = 0;
        let result = await task({
          report: (p) => {
            if (p.increment) {
              total += p.increment;
            }
            statusItem.text = formatMessage(title, p.message, total).replace(/\r?\n/g, " ");
          }
        }, import_node4.CancellationToken.None);
        statusItem.dispose();
        return result;
      }
      get enableMessageDialog() {
        return this.configuration.get("coc.preferences.enableMessageDialog", false);
      }
      getNotificationPreference(stack, source) {
        if (!source) source = parseExtensionName(stack);
        let config = this.configuration.get("notification");
        let disabledList = defaultValue(config.disabledProgressSources, []);
        let disabled = Array.isArray(disabledList) && (disabledList.includes("*") || disabledList.includes(source));
        return {
          border: config.border,
          focusable: config.focusable,
          marginRight: toNumber(config.marginRight, 10),
          timeout: toNumber(config.timeout, 1e4),
          maxWidth: toNumber(config.maxWidth, 60),
          maxHeight: toNumber(config.maxHeight, 10),
          highlight: config.highlightGroup,
          winblend: toNumber(config.winblend, 30),
          disabled,
          source
        };
      }
    };
  }
});

// src/model/terminal.ts
var TerminalModel;
var init_terminal = __esm({
  "src/model/terminal.ts"() {
    "use strict";
    TerminalModel = class {
      constructor(cmd, args, nvim, _name, strictEnv) {
        this.cmd = cmd;
        this.args = args;
        this.nvim = nvim;
        this._name = _name;
        this.strictEnv = strictEnv;
        this.pid = 0;
      }
      async start(cwd2, env) {
        let { nvim } = this;
        let cmd = [this.cmd, ...this.args];
        let [bufnr, pid] = await nvim.call("coc#terminal#start", [cmd, cwd2, env || {}, !!this.strictEnv]);
        this.bufnr = bufnr;
        this.pid = pid;
      }
      onExit(code) {
        this.exitStatus = { code: code === -1 ? void 0 : code };
      }
      get name() {
        return this._name || this.cmd;
      }
      get processId() {
        return Promise.resolve(this.pid);
      }
      sendText(text, addNewLine = true) {
        if (!this.bufnr) return;
        this.nvim.call("coc#terminal#send", [this.bufnr, text, addNewLine], true);
      }
      async show(preserveFocus) {
        let { bufnr, nvim } = this;
        if (!bufnr) return false;
        return await nvim.call("coc#terminal#show", [bufnr, { preserveFocus }]);
      }
      async hide() {
        let { bufnr, nvim } = this;
        if (!bufnr) return;
        await nvim.eval(`coc#window#close(bufwinid(${bufnr}))`);
      }
      dispose() {
        if (!this.exitStatus) {
          this.exitStatus = { code: void 0 };
        }
        let { bufnr, nvim } = this;
        if (!bufnr) return;
        this.bufnr = void 0;
        nvim.call("coc#terminal#close", [bufnr], true);
      }
    };
  }
});

// src/core/terminals.ts
var Terminals;
var init_terminals = __esm({
  "src/core/terminals.ts"() {
    "use strict";
    init_events();
    init_terminal();
    init_util();
    init_object();
    init_protocol();
    Terminals = class {
      constructor() {
        this._terminals = /* @__PURE__ */ new Map();
        this.disposables = [];
        this._onDidOpenTerminal = new import_node4.Emitter();
        this._onDidCloseTerminal = new import_node4.Emitter();
        this.onDidCloseTerminal = this._onDidCloseTerminal.event;
        this.onDidOpenTerminal = this._onDidOpenTerminal.event;
        events_default.on("BufUnload", (bufnr) => {
          if (this._terminals.has(bufnr)) {
            let terminal = this._terminals.get(bufnr);
            this._onDidCloseTerminal.fire(terminal);
            this._terminals.delete(bufnr);
          }
        }, null, this.disposables);
        events_default.on("TermExit", (bufnr, status) => {
          let terminal = this._terminals.get(bufnr);
          if (terminal) {
            terminal.onExit(status);
            terminal.dispose();
          }
        }, null, this.disposables);
      }
      get terminals() {
        return Array.from(this._terminals.values());
      }
      async createTerminal(nvim, opts) {
        let cwd2 = opts.cwd;
        let cmd = opts.shellPath;
        let args = opts.shellArgs;
        if (!cmd) cmd = await nvim.getOption("shell");
        if (!cwd2) cwd2 = await nvim.call("getcwd");
        let terminal = new TerminalModel(cmd, args || [], nvim, opts.name, opts.strictEnv);
        await terminal.start(cwd2, opts.env);
        this._terminals.set(terminal.bufnr, terminal);
        this._onDidOpenTerminal.fire(terminal);
        return terminal;
      }
      async runTerminalCommand(nvim, cmd, cwd2, keepfocus) {
        return await nvim.callAsync("coc#ui#run_terminal", { cmd, cwd: cwd2, keepfocus: keepfocus ? 1 : 0 });
      }
      async openTerminal(nvim, cmd, opts) {
        return await nvim.call("coc#ui#open_terminal", { cmd, ...toObject(opts) });
      }
      reset() {
        for (let terminal of this._terminals.values()) {
          terminal.dispose();
        }
        this._terminals.clear();
      }
      dispose() {
        this._onDidOpenTerminal.dispose();
        this._onDidCloseTerminal.dispose();
        disposeAll(this.disposables);
        this.reset();
      }
    };
  }
});

// data/schema.json
var schema_default;
var init_schema = __esm({
  "data/schema.json"() {
    schema_default = {
      description: "Configuration file for coc.nvim",
      additionalProperties: false,
      definitions: {
        floatConfig: {
          type: "object",
          properties: {
            border: {
              type: "boolean",
              default: false,
              description: "Set to true to use borders."
            },
            rounded: {
              type: "boolean",
              default: false,
              description: "Use rounded borders when border is true."
            },
            highlight: {
              type: "string",
              default: "CocFloating",
              description: "Background highlight group of float window."
            },
            title: {
              type: "string",
              default: "",
              description: "Title used by float window."
            },
            borderhighlight: {
              type: "string",
              default: "CocFloatBorder",
              description: "Border highlight group of float window."
            },
            close: {
              type: "boolean",
              default: false,
              description: "Set to true to draw close icon"
            },
            maxWidth: {
              type: "integer",
              description: "Maximum width of float window, include border."
            },
            maxHeight: {
              type: "integer",
              minimum: 2,
              description: "Maximum height of float window, include border."
            },
            focusable: {
              type: "boolean",
              default: true,
              description: "Enable focus by user actions (wincmds, mouse events), neovim only."
            },
            shadow: {
              type: "boolean",
              default: false,
              description: "Drop shadow effect by blending with the background, neovim only."
            },
            winblend: {
              type: "integer",
              default: 0,
              minimum: 0,
              maximum: 100,
              description: "Enables pseudo-transparency by set 'winblend' option of window, neovim only."
            },
            position: {
              type: "string",
              default: "auto",
              description: "Controls how floating windows are positioned. When set to `'fixed'`, the window will be positioned according to the `top`, `bottom`, `left`, and `right` settings. When set to `'auto'`, the window follows the default position.",
              enum: ["fixed", "auto"]
            },
            top: {
              type: "number",
              description: "Distance from the top of the editor window in characters. Only takes effect when `position` is set to `'fixed'`. Will be ignored if `bottom` is set."
            },
            bottom: {
              type: "number",
              description: "Distance from the bottom of the editor window in characters. Only takes effect when `position` is set to `'fixed'`. Takes precedence over `top` if both are set."
            },
            left: {
              type: "number",
              description: "Distance from the left edge of the editor window in characters. Only takes effect when `position` is set to `'fixed'`. Will be ignored if `right` is set."
            },
            right: {
              type: "number",
              description: "Distance from the right edge of the editor window in characters. Only takes effect when `position` is set to `'fixed'`. Takes precedence over `left` if both are set."
            }
          }
        },
        "languageserver.enable": {
          type: "boolean",
          description: "Enable the languageserver, restart coc.nvim required after change.",
          default: true
        },
        "languageserver.filetypes": {
          type: "array",
          default: [],
          description: "Supported filetypes, add * in array for all filetypes.",
          items: {
            type: "string"
          }
        },
        "languageserver.maxRestartCount": {
          type: "integer",
          default: 4,
          minimum: 1,
          description: "Maximum restart count when server closed in the last 3 minutes."
        },
        "languageserver.cwd": {
          type: "string",
          default: "",
          description: "Working directory of languageserver, absolute path or relative to workspace folder, use workspace root by default"
        },
        "languageserver.settings": {
          type: "object",
          default: {},
          description: "Settings of languageserver"
        },
        "languageserver.initializationOptions": {
          type: "object",
          default: {},
          description: "initializationOptions passed to languageserver"
        },
        "languageserver.env": {
          type: "object",
          default: null,
          description: "Environment variables for child process."
        },
        "languageserver.stdioEncoding": {
          type: "string",
          default: "utf8",
          description: "Encoding used for stdio of child process."
        },
        "languageserver.rootPatterns": {
          type: "array",
          default: [],
          description: "Root patterns used to resolve rootPath from current file, default to workspace root",
          items: {
            type: "string"
          }
        },
        "languageserver.requireRootPattern": {
          type: "boolean",
          default: false,
          description: "If true, doesn't start server when root pattern not found."
        },
        "languageserver.ignoredRootPaths": {
          type: "array",
          default: [],
          description: "Absolute root paths that language server should not use as rootPath, higher priority than rootPatterns.",
          items: {
            type: "string"
          }
        },
        "languageserver.additionalSchemes": {
          type: "array",
          default: [],
          description: "Additional URI schemes, default schemes including file & untitled.",
          items: {
            type: "string"
          }
        },
        "languageserver.revealOutputChannelOn": {
          type: "string",
          default: "never",
          description: "Configure message level to show the output channel buffer",
          enum: ["info", "warn", "error", "never"]
        },
        "languageserver.progressOnInitialization": {
          type: "boolean",
          default: false,
          description: "Enable progress report on languageserver initialize."
        },
        "languageserver.trace.server": {
          type: "string",
          default: "off",
          enum: ["off", "messages", "verbose"],
          description: "Trace level of communication between server and client"
        },
        "languageserver.trace.server.verbosity": {
          type: "string",
          default: "off",
          enum: ["off", "messages", "verbose"],
          description: "Trace level of communication between server and client"
        },
        "languageserver.trace.server.format": {
          type: "string",
          default: "text",
          enum: ["text", "json"],
          description: "Text format of trace messages."
        },
        "languageserver.disableDynamicRegister": {
          type: "boolean",
          default: false,
          description: "Disable dynamic registerCapability feature for this languageserver to avoid duplicate feature registration."
        },
        "languageserver.disableSnippetCompletion": {
          type: "boolean",
          default: false,
          description: "Disable completion snippet feature for this languageserver, the languageserver may not respect it."
        },
        "languageserver.disabledFeatures": {
          type: "array",
          default: [],
          description: "Disabled features for this languageserver.",
          items: {
            type: "string",
            enum: [
              "completion",
              "configuration",
              "workspaceFolders",
              "diagnostics",
              "willSave",
              "willSaveUntil",
              "didSaveTextDocument",
              "fileSystemWatcher",
              "hover",
              "signatureHelp",
              "definition",
              "references",
              "documentHighlight",
              "documentSymbol",
              "workspaceSymbol",
              "codeAction",
              "codeLens",
              "formatting",
              "documentFormatting",
              "documentRangeFormatting",
              "documentOnTypeFormatting",
              "rename",
              "documentLink",
              "executeCommand",
              "pullConfiguration",
              "typeDefinition",
              "implementation",
              "declaration",
              "color",
              "foldingRange",
              "selectionRange",
              "progress",
              "callHierarchy",
              "linkedEditing",
              "inlayHint",
              "inlineValue",
              "typeHierarchy",
              "pullDiagnostic",
              "fileEvents",
              "semanticTokens"
            ]
          }
        },
        "languageserver.formatterPriority": {
          type: "integer",
          default: 0,
          description: "Priority of this languageserver's formatter."
        },
        languageServerSocket: {
          type: "object",
          required: ["port", "filetypes"],
          additionalProperties: false,
          properties: {
            port: {
              type: "integer",
              description: "Port number of socket server"
            },
            host: {
              type: "string",
              default: "127.0.0.1",
              description: "Host of server"
            },
            enable: {
              $ref: "#/definitions/languageserver.enable"
            },
            disableSnippetCompletion: {
              $ref: "#/definitions/languageserver.disableSnippetCompletion"
            },
            disableDynamicRegister: {
              $ref: "#/definitions/languageserver.disableDynamicRegister"
            },
            disabledFeatures: {
              $ref: "#/definitions/languageserver.disabledFeatures"
            },
            formatterPriority: {
              $ref: "#/definitions/languageserver.formatterPriority"
            },
            rootPatterns: {
              $ref: "#/definitions/languageserver.rootPatterns"
            },
            requireRootPattern: {
              $ref: "#/definitions/languageserver.requireRootPattern"
            },
            ignoredRootPaths: {
              $ref: "#/definitions/languageserver.ignoredRootPaths"
            },
            maxRestartCount: {
              $ref: "#/definitions/languageserver.maxRestartCount"
            },
            filetypes: {
              $ref: "#/definitions/languageserver.filetypes"
            },
            additionalSchemes: {
              $ref: "#/definitions/languageserver.additionalSchemes"
            },
            revealOutputChannelOn: {
              $ref: "#/definitions/languageserver.revealOutputChannelOn"
            },
            progressOnInitialization: {
              $ref: "#/definitions/languageserver.progressOnInitialization"
            },
            initializationOptions: {
              $ref: "#/definitions/languageserver.initializationOptions"
            },
            settings: {
              $ref: "#/definitions/languageserver.settings"
            },
            stdioEncoding: {
              $ref: "#/definitions/languageserver.stdioEncoding"
            },
            "trace.server": {
              $ref: "#/definitions/languageserver.trace.server"
            },
            "trace.server.verbosity": {
              $ref: "#/definitions/languageserver.trace.server.verbosity"
            },
            "trace.server.format": {
              $ref: "#/definitions/languageserver.trace.server.format"
            }
          }
        },
        languageServerModule: {
          type: "object",
          required: ["module", "filetypes"],
          additionalProperties: false,
          properties: {
            module: {
              type: "string",
              default: "",
              description: "Absolute path of Javascript file, should works in IPC mode"
            },
            args: {
              type: "array",
              default: [],
              description: "Extra arguments of module",
              items: {
                type: "string"
              }
            },
            runtime: {
              type: "string",
              default: "",
              description: "Absolute path of node runtime."
            },
            execArgv: {
              type: "array",
              default: [],
              description: 'ARGV passed to node when using module, normally used for debugging, ex: ["--nolazy", "--inspect-brk=6045"]',
              items: {
                type: "string"
              }
            },
            transport: {
              type: "string",
              default: "ipc",
              description: "Transport kind used by server, could be 'ipc', 'stdio', 'socket' and 'pipe'",
              enum: ["ipc", "stdio", "socket", "pipe"]
            },
            transportPort: {
              type: "integer",
              description: "Port number used when transport is 'socket'"
            },
            enable: {
              $ref: "#/definitions/languageserver.enable"
            },
            disableSnippetCompletion: {
              $ref: "#/definitions/languageserver.disableSnippetCompletion"
            },
            disableDynamicRegister: {
              $ref: "#/definitions/languageserver.disableDynamicRegister"
            },
            disabledFeatures: {
              $ref: "#/definitions/languageserver.disabledFeatures"
            },
            formatterPriority: {
              $ref: "#/definitions/languageserver.formatterPriority"
            },
            rootPatterns: {
              $ref: "#/definitions/languageserver.rootPatterns"
            },
            requireRootPattern: {
              $ref: "#/definitions/languageserver.requireRootPattern"
            },
            ignoredRootPaths: {
              $ref: "#/definitions/languageserver.ignoredRootPaths"
            },
            maxRestartCount: {
              $ref: "#/definitions/languageserver.maxRestartCount"
            },
            filetypes: {
              $ref: "#/definitions/languageserver.filetypes"
            },
            additionalSchemes: {
              $ref: "#/definitions/languageserver.additionalSchemes"
            },
            revealOutputChannelOn: {
              $ref: "#/definitions/languageserver.revealOutputChannelOn"
            },
            progressOnInitialization: {
              $ref: "#/definitions/languageserver.progressOnInitialization"
            },
            initializationOptions: {
              $ref: "#/definitions/languageserver.initializationOptions"
            },
            settings: {
              $ref: "#/definitions/languageserver.settings"
            },
            stdioEncoding: {
              $ref: "#/definitions/languageserver.stdioEncoding"
            },
            "trace.server": {
              $ref: "#/definitions/languageserver.trace.server"
            },
            "trace.server.verbosity": {
              $ref: "#/definitions/languageserver.trace.server.verbosity"
            },
            "trace.server.format": {
              $ref: "#/definitions/languageserver.trace.server.format"
            }
          }
        },
        languageServerCommand: {
          type: "object",
          required: ["command", "filetypes"],
          additionalProperties: false,
          properties: {
            command: {
              type: "string",
              default: "",
              description: "Executable in $PATH to start languageserver, should not used with module"
            },
            args: {
              type: "array",
              default: [],
              description: "Arguments of command",
              items: {
                type: "string"
              }
            },
            detached: {
              type: "boolean",
              default: false,
              description: "Detach the languageserver process"
            },
            shell: {
              type: "boolean",
              default: false,
              description: "Use shell for process"
            },
            enable: {
              $ref: "#/definitions/languageserver.enable"
            },
            env: {
              $ref: "#/definitions/languageserver.env"
            },
            disableSnippetCompletion: {
              $ref: "#/definitions/languageserver.disableSnippetCompletion"
            },
            disableDynamicRegister: {
              $ref: "#/definitions/languageserver.disableDynamicRegister"
            },
            disabledFeatures: {
              $ref: "#/definitions/languageserver.disabledFeatures"
            },
            formatterPriority: {
              $ref: "#/definitions/languageserver.formatterPriority"
            },
            rootPatterns: {
              $ref: "#/definitions/languageserver.rootPatterns"
            },
            requireRootPattern: {
              $ref: "#/definitions/languageserver.requireRootPattern"
            },
            ignoredRootPaths: {
              $ref: "#/definitions/languageserver.ignoredRootPaths"
            },
            maxRestartCount: {
              $ref: "#/definitions/languageserver.maxRestartCount"
            },
            filetypes: {
              $ref: "#/definitions/languageserver.filetypes"
            },
            additionalSchemes: {
              $ref: "#/definitions/languageserver.additionalSchemes"
            },
            revealOutputChannelOn: {
              $ref: "#/definitions/languageserver.revealOutputChannelOn"
            },
            progressOnInitialization: {
              $ref: "#/definitions/languageserver.progressOnInitialization"
            },
            initializationOptions: {
              $ref: "#/definitions/languageserver.initializationOptions"
            },
            settings: {
              $ref: "#/definitions/languageserver.settings"
            },
            stdioEncoding: {
              $ref: "#/definitions/languageserver.stdioEncoding"
            },
            "trace.server": {
              $ref: "#/definitions/languageserver.trace.server"
            },
            "trace.server.verbosity": {
              $ref: "#/definitions/languageserver.trace.server.verbosity"
            },
            "trace.server.format": {
              $ref: "#/definitions/languageserver.trace.server.format"
            }
          }
        }
      },
      properties: {
        "callHierarchy.enableTooltip": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Enable tooltip to show relative filepath of call hierarchy."
        },
        "callHierarchy.openCommand": {
          type: "string",
          scope: "application",
          default: "edit",
          description: "Open command for callHierarchy tree view."
        },
        "callHierarchy.splitCommand": {
          type: "string",
          scope: "application",
          default: "botright 30vs",
          description: "Window split command used by callHierarchy tree view."
        },
        "coc.preferences.rootPatterns": {
          type: ["array", "null"],
          default: null,
          scope: "application",
          description: "Root patterns to resolve workspaceFolder from parent folders of opened files, resolved from up to down.",
          deprecationMessage: "Use 'workspace.rootPatterns' instead.",
          items: {
            type: "string"
          }
        },
        "coc.preferences.bracketEnterImprove": {
          type: "boolean",
          scope: "language-overridable",
          description: "Improve enter inside bracket `<> {} [] ()` by add new empty line below and place cursor to it. Works with `coc#on_enter()`",
          default: true
        },
        "coc.preferences.currentFunctionSymbolAutoUpdate": {
          type: "boolean",
          scope: "language-overridable",
          description: "Automatically update the value of b:coc_current_function on CursorMove event",
          default: false
        },
        "coc.preferences.currentFunctionSymbolDebounceTime": {
          type: "number",
          scope: "application",
          description: "Set debounce timer for the update of b:coc_current_function on CursorMove event",
          default: 300
        },
        "coc.preferences.enableLinkedEditing": {
          type: "boolean",
          scope: "language-overridable",
          default: false,
          description: "Enable linked editing support."
        },
        "coc.preferences.enableMarkdown": {
          type: "boolean",
          scope: "application",
          description: "Tell the language server that markdown text format is supported, note that markdown text may not rendered as expected.",
          default: true
        },
        "coc.preferences.enableMessageDialog": {
          type: "boolean",
          scope: "application",
          default: false,
          description: "Enable messages shown in notification dialog."
        },
        "coc.preferences.excludeImageLinksInMarkdownDocument": {
          type: "boolean",
          description: "Exclude image links from markdown text in float window.",
          scope: "application",
          default: true
        },
        "coc.preferences.enableGFMBreaksInMarkdownDocument": {
          type: "boolean",
          description: "Exclude GFM breaks in markdown document.",
          scope: "application",
          default: true
        },
        "coc.preferences.extensionUpdateCheck": {
          type: "string",
          scope: "application",
          default: "never",
          description: "Interval for check extension update, could be daily, weekly, never",
          deprecationMessage: "Use configuration 'extensions.updateCheck' instead.",
          enum: ["daily", "weekly", "never"]
        },
        "coc.preferences.extensionUpdateUIInTab": {
          type: "boolean",
          scope: "application",
          default: false,
          deprecationMessage: "Use configuration 'extensions.updateUIInTab' instead.",
          description: "Display extension updating UI in new vim tab"
        },
        "coc.preferences.silentAutoupdate": {
          type: "boolean",
          description: "Not open split window with update status when performing auto update.",
          deprecationMessage: "Use configuration 'extensions.silentAutoupdate' instead.",
          scope: "application",
          default: true
        },
        "coc.preferences.floatActions": {
          type: "boolean",
          scope: "application",
          description: "Set to false to disable float/popup support for actions menu.",
          default: true
        },
        "coc.preferences.autoApplySingleQuickfix": {
          type: "boolean",
          scope: "application",
          description: "Automatically apply the single quickfix action .",
          default: true
        },
        "coc.preferences.formatOnSave": {
          type: "boolean",
          description: "Set to true to enable formatting on save.",
          scope: "language-overridable",
          default: false
        },
        "coc.preferences.formatOnSaveTimeout": {
          type: "integer",
          scope: "language-overridable",
          description: "How long before the format command run on save times out.",
          default: 500,
          minimum: 200,
          maximum: 5e3
        },
        "coc.preferences.formatOnSaveFiletypes": {
          type: ["null", "array"],
          scope: "resource",
          default: null,
          description: "Filetypes that should run format on save.",
          deprecationMessage: "Use 'coc.preferences.formatOnSave' as language override configuration instead, see :h coc-configuration-scope",
          items: {
            type: "string"
          }
        },
        "coc.preferences.formatOnType": {
          type: "boolean",
          description: "Set to true to enable formatting on typing.",
          scope: "language-overridable",
          default: false
        },
        "coc.preferences.formatOnTypeFiletypes": {
          type: ["null", "array"],
          default: null,
          scope: "resource",
          description: "Filetypes that should run format on typing, only works when `coc.preferences.formatOnType` is `true`",
          deprecationMessage: "Use 'coc.preferences.formatOnType' as language override configuration instead, see :h coc-configuration-scope",
          items: {
            type: "string"
          }
        },
        "coc.preferences.formatterExtension": {
          type: ["null", "string"],
          default: null,
          scope: "language-overridable",
          description: "Extension used for formatting documents. When set to null, the formatter with highest priority is used."
        },
        "coc.preferences.jumpCommand": {
          anyOf: [
            {
              type: "string",
              enum: [
                "edit",
                "split",
                "vsplit",
                "tabe",
                "drop",
                "tab drop",
                "pedit"
              ]
            },
            { type: "string", minimum: 1 }
          ],
          scope: "application",
          description: "Command used for location jump, like goto definition, goto references etc. Can be also a custom command that gives file as an argument.",
          default: "edit"
        },
        "coc.preferences.maxFileSize": {
          type: "string",
          scope: "application",
          default: "10MB",
          description: "Maximum file size in bytes that coc.nvim should handle, default '10MB'"
        },
        "coc.preferences.messageLevel": {
          type: "string",
          scope: "application",
          description: "Message level for filter echoed messages, could be 'more', 'warning' and 'error'",
          default: "more",
          enum: ["more", "warning", "error"]
        },
        "coc.preferences.promptInput": {
          type: "boolean",
          description: "Use prompt buffer in float window for user input.",
          scope: "application",
          default: true
        },
        "coc.preferences.renameFillCurrent": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Disable to stop Refactor-Rename float/popup window from populating with old name in the New Name field."
        },
        "coc.preferences.useQuickfixForLocations": {
          type: "boolean",
          scope: "application",
          description: "Use vim's quickfix list for jump locations,\n need restart on change.",
          default: false
        },
        "coc.preferences.watchmanPath": {
          type: "string",
          scope: "application",
          deprecationMessage: 'Use configuration "fileSystemWatch.watchmanPath" instead.',
          description: "executable path for https://facebook.github.io/watchman/, detected from $PATH by default",
          default: null
        },
        "coc.preferences.willSaveHandlerTimeout": {
          type: "integer",
          scope: "application",
          default: 500,
          minimum: 200,
          maximum: 5e3,
          description: "Will save handler timeout"
        },
        "coc.preferences.tagDefinitionTimeout": {
          type: "integer",
          scope: "application",
          default: 0,
          description: "The timeout of CocTagFunc, default is infinity"
        },
        "coc.source.around.disableSyntaxes": {
          type: "array",
          default: [],
          scope: "application",
          items: {
            type: "string"
          }
        },
        "coc.source.around.enable": {
          type: "boolean",
          scope: "application",
          default: true
        },
        "coc.source.around.priority": {
          type: "integer",
          scope: "application",
          default: 1
        },
        "coc.source.around.shortcut": {
          type: "string",
          scope: "application",
          default: "A"
        },
        "coc.source.buffer.disableSyntaxes": {
          type: "array",
          default: [],
          scope: "application",
          items: {
            type: "string"
          }
        },
        "coc.source.buffer.enable": {
          type: "boolean",
          scope: "application",
          default: true
        },
        "coc.source.buffer.ignoreGitignore": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Ignore git ignored files for buffer words"
        },
        "coc.source.buffer.priority": {
          type: "integer",
          scope: "application",
          default: 1
        },
        "coc.source.buffer.shortcut": {
          type: "string",
          scope: "application",
          default: "B"
        },
        "coc.source.file.disableSyntaxes": {
          type: "array",
          default: [],
          scope: "application",
          items: {
            type: "string"
          }
        },
        "coc.source.file.enable": {
          type: "boolean",
          scope: "application",
          default: true
        },
        "coc.source.file.ignoreHidden": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Ignore completion for hidden files"
        },
        "coc.source.file.ignorePatterns": {
          type: "array",
          scope: "application",
          default: [],
          description: "Ignore patterns of matcher",
          items: {
            type: "string"
          }
        },
        "coc.source.file.priority": {
          type: "integer",
          scope: "application",
          default: 10
        },
        "coc.source.file.shortcut": {
          type: "string",
          scope: "application",
          default: "F"
        },
        "coc.source.file.triggerCharacters": {
          type: "array",
          default: ["/", "\\"],
          scope: "application",
          items: {
            type: "string"
          }
        },
        "coc.source.file.trimSameExts": {
          type: "array",
          scope: "application",
          default: [".ts", ".js"],
          description: "Trim same extension on file completion",
          items: {
            type: "string"
          }
        },
        "codeLens.enable": {
          type: "boolean",
          scope: "language-overridable",
          description: "Enable codeLens feature, require neovim with set virtual text feature.",
          default: false
        },
        "codeLens.display": {
          type: "boolean",
          scope: "language-overridable",
          default: true,
          description: "Display codeLens."
        },
        "codeLens.position": {
          type: "string",
          scope: "language-overridable",
          enum: ["top", "eol", "right_align"],
          description: "Display position of codeLens virtual text.",
          default: "top"
        },
        "codeLens.separator": {
          type: "string",
          scope: "language-overridable",
          description: "Separator text for codeLens in virtual text",
          default: ""
        },
        "codeLens.subseparator": {
          type: "string",
          scope: "language-overridable",
          description: "Subseparator between codeLenses in virtual text",
          default: " | "
        },
        "colors.enable": {
          type: "boolean",
          scope: "language-overridable",
          description: "Enable colors highlight feature, for terminal vim, 'termguicolors' option should be enabled and the terminal support gui colors.",
          default: false
        },
        "colors.filetypes": {
          type: ["array", "null"],
          default: null,
          scope: "resource",
          deprecationMessage: "Use colors.enable as language override configuration instead, see :h coc-configuration-scope",
          description: 'Filetypes that should be enabled for colors highlight feature, use "*" for all filetypes.',
          items: {
            type: "string"
          }
        },
        "colors.highlightPriority": {
          type: "integer",
          scope: "application",
          description: "Priority for colors highlights, works on vim8 and neovim >= 0.6.0",
          default: 1e3,
          maximum: 4096
        },
        "cursors.cancelKey": {
          type: "string",
          scope: "application",
          default: "<esc>",
          description: "Key used for cancel cursors session."
        },
        "cursors.nextKey": {
          type: "string",
          scope: "application",
          default: "<C-n>",
          description: "Key used for jump to next cursors position."
        },
        "cursors.previousKey": {
          type: "string",
          scope: "application",
          default: "<C-p>",
          description: "Key used for jump to previous cursors position."
        },
        "cursors.wrapscan": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Searches wrap around the first or last cursors range."
        },
        "diagnostic.autoRefresh": {
          type: "boolean",
          scope: "language-overridable",
          description: "Enable automatically refresh diagnostics, use diagnosticRefresh action when it's disabled.",
          default: true
        },
        "diagnostic.checkCurrentLine": {
          type: "boolean",
          scope: "language-overridable",
          description: "When enabled, show all diagnostics of current line if there are none at the current position.",
          default: false
        },
        "diagnostic.displayByAle": {
          type: "boolean",
          scope: "language-overridable",
          description: "Use Ale, coc-diagnostics-shim.nvim, or other provider to display diagnostics in vim. This setting will disable diagnostic display using coc's handler. A restart required on change.",
          default: false
        },
        "diagnostic.displayByVimDiagnostic": {
          type: "boolean",
          scope: "language-overridable",
          description: "Display diagnostics with nvim's `vim.diagnostic`. This setting will disable diagnostic display using coc's handler. A restart required on change. Neovim only.",
          default: false
        },
        "diagnostic.enable": {
          type: "boolean",
          scope: "language-overridable",
          description: "Set to false to disable diagnostic display",
          default: true
        },
        "diagnostic.enableHighlightLineNumber": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Enable highlighting line numbers for diagnostics, only works with neovim."
        },
        "diagnostic.enableMessage": {
          type: "string",
          scope: "application",
          default: "always",
          description: "When to enable show messages of diagnostics.",
          enum: ["always", "jump", "never"]
        },
        "diagnostic.enableSign": {
          type: "boolean",
          scope: "language-overridable",
          default: true,
          description: "Enable signs for diagnostics."
        },
        "diagnostic.errorSign": {
          type: "string",
          scope: "application",
          description: "Text of error sign",
          default: ">>"
        },
        "diagnostic.filetypeMap": {
          type: "object",
          scope: "application",
          description: 'A map between buffer filetype and the filetype assigned to diagnostics. To syntax highlight diagnostics with their parent buffer type use `"default": "bufferType"`',
          default: {}
        },
        "diagnostic.floatConfig": {
          type: "object",
          scope: "application",
          description: "Configure float window style of diagnostic message.",
          allOf: [{ $ref: "#/definitions/floatConfig" }],
          additionalProperties: false,
          properties: {
            border: {},
            rounded: {},
            highlight: {},
            borderhighlight: {},
            title: {},
            close: {},
            maxHeight: {},
            maxWidth: {},
            winblend: {},
            focusable: {},
            shadow: {},
            position: {},
            top: {},
            bottom: {},
            left: {},
            right: {}
          }
        },
        "diagnostic.format": {
          type: "string",
          scope: "language-overridable",
          description: "Define the diagnostic format that shown in float window or echoed, available parts: source, code, severity, message",
          default: "%message (%source%code)"
        },
        "diagnostic.highlightLimit": {
          type: "integer",
          scope: "language-overridable",
          description: "Limit count for highlighted diagnostics, too many diagnostic highlights could make vim stop responding",
          default: 1e3
        },
        "diagnostic.highlightPriority": {
          type: "integer",
          scope: "language-overridable",
          description: "Priority for diagnostic highlights, works on vim8 and neovim >= 0.6.0",
          default: 4096,
          maximum: 4096,
          minimum: 110
        },
        "diagnostic.hintSign": {
          type: "string",
          scope: "application",
          description: "Text of hint sign",
          default: ">>"
        },
        "diagnostic.infoSign": {
          type: "string",
          scope: "application",
          description: "Text of info sign",
          default: ">>"
        },
        "diagnostic.level": {
          type: "string",
          scope: "resource",
          description: "Used for filter diagnostics by diagnostic severity.",
          default: "hint",
          enum: ["hint", "information", "warning", "error"]
        },
        "diagnostic.locationlistLevel": {
          type: ["string", "null"],
          scope: "language-overridable",
          description: "Filter diagnostics in locationlist.",
          default: null,
          enum: ["hint", "information", "warning", "error"]
        },
        "diagnostic.locationlistUpdate": {
          type: "boolean",
          scope: "language-overridable",
          description: "Update locationlist on diagnostics change, only works with locationlist opened by :CocDiagnostics command and first window of associated buffer.",
          default: true
        },
        "diagnostic.messageDelay": {
          type: "integer",
          scope: "application",
          description: "How long to wait (in milliseconds) before displaying the diagnostic message with echo or float",
          default: 200
        },
        "diagnostic.messageLevel": {
          type: ["string", "null"],
          scope: "language-overridable",
          description: "Filter diagnostic message in float window/popup.",
          default: null,
          enum: ["hint", "information", "warning", "error"]
        },
        "diagnostic.messageTarget": {
          type: "string",
          scope: "language-overridable",
          description: "Diagnostic message target.",
          default: "float",
          enum: ["echo", "float"]
        },
        "diagnostic.refreshOnInsertMode": {
          type: "boolean",
          scope: "language-overridable",
          description: "Enable diagnostic refresh on insert mode, default false.",
          default: false
        },
        "diagnostic.showDeprecated": {
          type: "boolean",
          default: true,
          scope: "language-overridable",
          description: "Show diagnostics with deprecated tag."
        },
        "diagnostic.showUnused": {
          type: "boolean",
          default: true,
          scope: "language-overridable",
          description: "Show diagnostics with unused tag, affects highlight, sign, virtual text, message"
        },
        "diagnostic.signLevel": {
          type: ["string", "null"],
          scope: "language-overridable",
          description: "Filter diagnostics displayed in signcolumn.",
          default: null,
          enum: ["hint", "information", "warning", "error"]
        },
        "diagnostic.signPriority": {
          type: "integer",
          scope: "resource",
          description: "Priority of diagnostic signs, default to 10",
          default: 10
        },
        "diagnostic.virtualText": {
          type: "boolean",
          scope: "language-overridable",
          description: "Use virtual text to display diagnostics.",
          default: false
        },
        "diagnostic.virtualTextAlign": {
          type: "string",
          scope: "language-overridable",
          description: "Position of virtual text, default 'after'. Vim9 only",
          default: "after",
          enum: ["after", "right", "below"]
        },
        "diagnostic.virtualTextCurrentLineOnly": {
          type: "boolean",
          scope: "language-overridable",
          description: "Only show virtualText diagnostic on current cursor line",
          default: true
        },
        "diagnostic.virtualTextFormat": {
          type: "string",
          scope: "language-overridable",
          description: "Define the virtual text diagnostic format, available parts: source, code, severity, message",
          default: "%message"
        },
        "diagnostic.virtualTextLevel": {
          type: ["string", "null"],
          scope: "language-overridable",
          description: "Filter diagnostic message in virtual text by level",
          default: null,
          enum: ["hint", "information", "warning", "error"]
        },
        "diagnostic.virtualTextLimitInOneLine": {
          type: "integer",
          scope: "language-overridable",
          minimum: 1,
          description: "The maximum number of diagnostic messages to disaply in one line",
          default: 999
        },
        "diagnostic.virtualTextLineSeparator": {
          type: "string",
          scope: "language-overridable",
          description: "The text that will mark a line end from the diagnostic message",
          default: " \\ "
        },
        "diagnostic.virtualTextLines": {
          type: "integer",
          scope: "language-overridable",
          description: "The number of non empty lines from a diagnostic to display",
          default: 3
        },
        "diagnostic.virtualTextPrefix": {
          type: "string",
          scope: "language-overridable",
          description: "The prefix added virtual text diagnostics",
          default: " "
        },
        "diagnostic.virtualTextWinCol": {
          type: ["integer", "null"],
          scope: "language-overridable",
          description: "Window column number to align virtual text, neovim only.",
          default: null
        },
        "diagnostic.warningSign": {
          type: "string",
          scope: "application",
          description: "Text of warning sign",
          default: "\u26A0"
        },
        "diagnostic.showRelatedInformation": {
          type: "boolean",
          default: true,
          scope: "language-overridable",
          description: "Display related information in the diagnostic floating window."
        },
        "dialog.confirmKey": {
          type: "string",
          default: "<cr>",
          scope: "application",
          description: "Confirm key for confirm selection used by menu and picker, you can always use <esc> to cancel."
        },
        "dialog.floatBorderHighlight": {
          type: ["string", "null"],
          default: null,
          scope: "application",
          description: "Highlight group for border of dialog window/popup, default to 'CocFloatBorder'"
        },
        "dialog.floatHighlight": {
          type: ["string", "null"],
          default: null,
          scope: "application",
          description: "Highlight group for dialog window/popup, default to 'CocFloating'"
        },
        "dialog.maxHeight": {
          type: "integer",
          default: 30,
          scope: "application",
          description: "Maximum height of dialog window."
        },
        "dialog.maxWidth": {
          type: "integer",
          default: 80,
          scope: "application",
          description: "Maximum width of dialog window."
        },
        "dialog.pickerButtonShortcut": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Show shortcut in buttons of picker dialog window/popup, used when dialog.pickerButtons is true."
        },
        "dialog.pickerButtons": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Show buttons for picker dialog window/popup."
        },
        "dialog.rounded": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "use rounded border for dialog window."
        },
        "dialog.shortcutHighlight": {
          type: "string",
          default: "MoreMsg",
          scope: "application",
          description: "Highlight group for shortcut character in menu dialog, default to 'MoreMsg'"
        },
        "documentHighlight.priority": {
          type: "integer",
          default: -1,
          scope: "resource",
          description: "Match priority used by document highlight, see ':h matchadd'."
        },
        "documentHighlight.limit": {
          type: "integer",
          default: 200,
          scope: "resource",
          description: "Limit the highlights added by matchaddpos, too many positions could cause vim slow."
        },
        "documentHighlight.timeout": {
          type: "integer",
          default: 300,
          minimum: 200,
          maximum: 5e3,
          scope: "resource",
          description: "Timeout for document highlight, in milliseconds."
        },
        "editor.autocmdTimeout": {
          type: "integer",
          default: 1e3,
          minimum: 100,
          maximum: 5e3,
          scope: "application",
          description: "Timeout for execute request autocmd registered by coc extensions."
        },
        "editor.codeActionsOnSave": {
          additionalProperties: {
            type: ["string", "boolean"],
            enum: ["always", "never", true, false]
          },
          type: "object",
          default: {},
          scope: "language-overridable",
          description: 'Run Code Actions for the buffer on save, normally source actions, Example: `"source.organizeImports": "always"'
        },
        "fileSystemWatch.watchmanPath": {
          type: ["null", "string"],
          scope: "application",
          description: "executable path for https://facebook.github.io/watchman/, detected from $PATH by default",
          default: null
        },
        "fileSystemWatch.enable": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Enable file system watch support for workspace folders."
        },
        "fileSystemWatch.ignoredFolders": {
          type: "array",
          default: ["/private/tmp", "/", "${tmpdir}"],
          scope: "application",
          description: "List of folders that should not be watched for file changes, environment variables and minimatch patterns can be used.",
          items: {
            type: "string"
          }
        },
        "floatFactory.floatConfig": {
          type: "object",
          scope: "application",
          description: "Configure default style float window/popup created by float factory (created around cursor and automatically closed)",
          allOf: [{ $ref: "#/definitions/floatConfig" }],
          additionalProperties: false,
          properties: {
            border: {},
            rounded: {},
            highlight: {},
            borderhighlight: {},
            title: {},
            close: {},
            maxWidth: {},
            maxHeight: {},
            winblend: {},
            focusable: {},
            shadow: {},
            position: {},
            top: {},
            bottom: {},
            left: {},
            right: {}
          }
        },
        "hover.autoHide": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Automatically hide hover float window on CursorMove or InsertEnter."
        },
        "hover.floatConfig": {
          type: "object",
          scope: "application",
          description: "Configure float window style of hover documents.",
          allOf: [{ $ref: "#/definitions/floatConfig" }],
          additionalProperties: false,
          properties: {
            border: {},
            rounded: {},
            highlight: {},
            borderhighlight: {},
            title: {},
            close: {},
            maxHeight: {},
            maxWidth: {},
            winblend: {},
            focusable: {},
            shadow: {},
            position: {},
            top: {},
            bottom: {},
            left: {},
            right: {}
          }
        },
        "hover.previewMaxHeight": {
          type: "integer",
          scope: "resource",
          default: 12,
          description: "Max height of preview window for hover."
        },
        "hover.target": {
          type: "string",
          default: "float",
          scope: "resource",
          description: "Target to show hover information, default is floating window when possible.",
          enum: ["preview", "echo", "float"]
        },
        "http.proxy": {
          type: "string",
          default: "",
          pattern: "^https?://([^:]*(:[^@]*)?@)?([^:]+|\\[[:0-9a-fA-F]+\\])(:\\d+)?/?$|^$",
          description: "The proxy setting to use. If not set, will be inherited from the `http_proxy` and `https_proxy` environment variables.",
          scope: "application"
        },
        "http.proxyAuthorization": {
          type: ["null", "string"],
          description: "The value to send as the `Proxy-Authorization` header for every network request.",
          default: null,
          scope: "application"
        },
        "http.proxyCA": {
          type: "string",
          description: "CA (file) to use as Certificate Authority",
          default: null,
          scope: "application"
        },
        "http.proxyStrictSSL": {
          type: "boolean",
          description: "Controls whether the proxy server certificate should be verified against the list of supplied CAs",
          default: true,
          scope: "application"
        },
        "extensions.updateCheck": {
          type: "string",
          scope: "application",
          default: "never",
          description: "Interval time for check extension update, could be daily, weekly, never",
          enum: ["daily", "weekly", "never"]
        },
        "extensions.recommendations": {
          type: "array",
          scope: "resource",
          description: "List of extensions recommended for installation in the current project",
          default: [],
          items: {
            type: "string"
          }
        },
        "extensions.silentAutoupdate": {
          type: "boolean",
          description: "Not open split window with update status when performing auto update.",
          scope: "application",
          default: true
        },
        "extensions.updateUIInTab": {
          type: "boolean",
          scope: "application",
          default: false,
          description: "Display extension updating UI in new vim tab"
        },
        "inlayHint.enable": {
          type: "boolean",
          default: true,
          scope: "language-overridable",
          description: "Enable inlay hint support"
        },
        "inlayHint.position": {
          type: "string",
          default: "inline",
          scope: "language-overridable",
          description: "Controls where to show inlay hints: inline in the text, or at the end of the line",
          enum: ["inline", "eol"]
        },
        "inlayHint.enableParameter": {
          type: "boolean",
          scope: "language-overridable",
          default: true,
          description: "Enable inlay hints for parameters."
        },
        "inlayHint.display": {
          type: "boolean",
          scope: "language-overridable",
          default: true,
          description: "Display inlay hints."
        },
        "inlayHint.filetypes": {
          type: ["array", "null"],
          scope: "application",
          description: "Filetypes that enable inlayHint, all filetypes are enabled by default",
          deprecationMessage: "Use inlayHint.enable with language scope instead, see :h coc-configuration-scope",
          default: null,
          items: {
            type: "string"
          }
        },
        "inlayHint.refreshOnInsertMode": {
          type: "boolean",
          default: false,
          scope: "language-overridable",
          description: "Refresh inlayHints on insert mode."
        },
        "inlayHint.maximumLength": {
          type: "integer",
          default: 0,
          minimum: 0,
          scope: "language-overridable",
          description: "Maximum overall length of inlay hints, for a single line, before they get truncated by the editor. Set to `0`to disable truncation."
        },
        "links.enable": {
          type: "boolean",
          scope: "language-overridable",
          description: "Enable document links",
          default: true
        },
        "links.tooltip": {
          type: "boolean",
          scope: "application",
          description: "Show tooltip of link under cursor on CursorHold.",
          default: false
        },
        "links.highlight": {
          type: "boolean",
          scope: "application",
          description: "Use CocLink highlight group to highlight links",
          default: false
        },
        "list.floatPreview": {
          type: "boolean",
          default: false,
          scope: "application",
          description: "Enable preview with float window/popup, default: `false`"
        },
        "list.alignColumns": {
          type: "boolean",
          default: false,
          scope: "application",
          description: "Whether to align lists in columns, default: `false`"
        },
        "list.extendedSearchMode": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Enable extended search mode which allows multiple search patterns delimited by spaces."
        },
        "list.height": {
          type: "integer",
          scope: "application",
          default: 10,
          description: "Height of split list window."
        },
        "list.indicator": {
          type: "string",
          default: ">",
          scope: "application",
          description: "The character used as first character in prompt line."
        },
        "list.insertMappings": {
          type: "object",
          scope: "application",
          default: {},
          description: "Custom keymappings on insert mode."
        },
        "list.interactiveDebounceTime": {
          type: "integer",
          default: 100,
          scope: "application",
          description: "Debounce time for input change on interactive mode."
        },
        "list.limitLines": {
          type: ["number", "null"],
          scope: "application",
          default: null,
          description: "Limit lines for list buffer."
        },
        "list.maxPreviewHeight": {
          type: "integer",
          scope: "application",
          default: 12,
          description: "Max height for preview window of list."
        },
        "list.menuAction": {
          type: "boolean",
          default: false,
          scope: "application",
          description: "Use menu picker instead of confirm() for choose action."
        },
        "list.nextKeymap": {
          type: "string",
          scope: "application",
          default: "<C-j>",
          description: "Key used for select next line on insert mode."
        },
        "list.normalMappings": {
          type: "object",
          scope: "application",
          default: {},
          description: "Custom keymappings on normal mode."
        },
        "list.previewHighlightGroup": {
          type: "string",
          scope: "application",
          default: "Search",
          description: "Highlight group used for highlight the range in preview window."
        },
        "list.previewSplitRight": {
          type: "boolean",
          scope: "application",
          default: false,
          description: "Use vsplit for preview window."
        },
        "list.previewToplineOffset": {
          type: "integer",
          scope: "application",
          default: 3,
          description: "Topline offset for list previews"
        },
        "list.previewToplineStyle": {
          type: "string",
          scope: "application",
          default: "offset",
          description: "Topline style for list previews",
          enum: ["offset", "middle"]
        },
        "list.previousKeymap": {
          type: "string",
          scope: "application",
          default: "<C-k>",
          description: "Key used for select previous line on insert mode."
        },
        "list.selectedSignText": {
          type: "string",
          scope: "application",
          default: "*",
          description: "Sign text for selected lines."
        },
        "list.signOffset": {
          type: "integer",
          scope: "application",
          default: 900,
          description: "Sign offset of list, should be different from other plugins."
        },
        "list.smartCase": {
          type: "boolean",
          default: false,
          scope: "application",
          description: "Use smartcase match for fuzzy match and strict match, --ignore-case will be ignored, may not affect interactive list."
        },
        "list.source.diagnostics.includeCode": {
          type: "boolean",
          scope: "application",
          description: "Whether to show the diagnostic code in the list.",
          default: true
        },
        "list.source.diagnostics.pathFormat": {
          type: "string",
          scope: "application",
          description: "Decide how the filepath is shown in the list.",
          enum: ["full", "short", "filename", "hidden"],
          default: "full"
        },
        "list.source.outline.ctagsFiletypes": {
          type: "array",
          scope: "application",
          default: [],
          description: "Filetypes that should use ctags for outline instead of language server.",
          items: {
            type: "string"
          }
        },
        "list.source.symbols.excludes": {
          type: "array",
          scope: "application",
          default: [],
          description: "Patterns of minimatch for filepath to exclude from symbols list.",
          items: {
            type: "string"
          }
        },
        "list.statusLineSegments": {
          type: ["array", "null"],
          scope: "application",
          default: [
            '%#CocListMode#-- %{coc#list#status("mode")} --%*',
            '%{coc#list#status("loading")}',
            '%{coc#list#status("args")}',
            '(%L/%{coc#list#status("total")})',
            "%=",
            '%#CocListPath# %{coc#list#status("cwd")} %l/%L%*'
          ],
          items: {
            types: "string"
          },
          description: "An array of statusline segments that will be used to draw the status line for list windows."
        },
        "notification.statusLineProgress": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Show progress notification in status line, instead of float window/popup."
        },
        "notification.border": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Enable rounded border for notification windows."
        },
        "notification.disabledProgressSources": {
          type: "array",
          default: [],
          scope: "application",
          description: "Sources that should be disabled for message progress, use * to disable all message only progresses",
          items: {
            type: "string"
          }
        },
        "notification.focusable": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Enable focus by user actions (wincmds, mouse events), neovim only."
        },
        "notification.highlightGroup": {
          type: "string",
          default: "Normal",
          scope: "application",
          description: "Highlight group of notification dialog."
        },
        "notification.marginRight": {
          type: "integer",
          default: 10,
          scope: "application",
          description: "Margin right to the right of editor window."
        },
        "notification.maxHeight": {
          type: "integer",
          default: 10,
          scope: "application",
          description: "Maximum content height of notification dialog."
        },
        "notification.maxWidth": {
          type: "integer",
          default: 60,
          scope: "application",
          description: "Maximum content width of notification dialog."
        },
        "notification.minProgressWidth": {
          type: "integer",
          default: 30,
          scope: "application",
          description: "Minimal with of progress notification."
        },
        "notification.timeout": {
          type: "integer",
          default: 1e4,
          scope: "application",
          description: "Timeout for auto close notifications, in milliseconds."
        },
        "notification.winblend": {
          type: "integer",
          default: 30,
          minimum: 0,
          maximum: 100,
          scope: "application",
          description: "Winblend option of notification window, neovim only."
        },
        "npm.binPath": {
          type: "string",
          scope: "application",
          default: "npm",
          description: "Command or absolute path to npm or yarn."
        },
        "outline.autoHide": {
          type: "boolean",
          scope: "application",
          default: false,
          description: "Automatically close the outline window when an item is clicked."
        },
        "outline.autoPreview": {
          type: "boolean",
          scope: "application",
          default: false,
          description: "Enable auto preview on cursor move."
        },
        "outline.autoWidth": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Automatically increase window width to avoid wrapped lines."
        },
        "outline.checkBufferSwitch": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Recreate outline view after user changed to another buffer on current tab."
        },
        "outline.codeActionKinds": {
          type: "array",
          scope: "application",
          default: ["", "quickfix", "refactor"],
          description: "Filter code actions in actions menu by kinds.",
          items: {
            type: "string",
            enum: ["", "quickfix", "refactor", "source"]
          }
        },
        "outline.detailAsDescription": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Show detail as description aside with label, when false detail will be shown in tooltip on cursor hold."
        },
        "outline.expandLevel": {
          type: "integer",
          scope: "application",
          default: 1,
          description: "Expand level of tree nodes."
        },
        "outline.followCursor": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Reveal item in outline tree on cursor hold."
        },
        "outline.keepWindow": {
          type: "boolean",
          scope: "application",
          default: false,
          description: "Jump back to original window after outline is shown."
        },
        "outline.previewBorder": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Use border for preview window."
        },
        "outline.previewBorderHighlightGroup": {
          type: "string",
          scope: "application",
          default: "Normal",
          description: "Border highlight group of preview window."
        },
        "outline.previewBorderRounded": {
          type: "boolean",
          scope: "application",
          default: false,
          description: "Use rounded border for preview window."
        },
        "outline.previewHighlightGroup": {
          type: "string",
          scope: "application",
          default: "Normal",
          description: "Highlight group of preview window."
        },
        "outline.previewMaxWidth": {
          type: "integer",
          scope: "application",
          default: 80,
          description: "Max width of preview window."
        },
        "outline.previewWinblend": {
          type: "integer",
          scope: "application",
          default: 0,
          minimum: 0,
          maximum: 100,
          description: "Enables pseudo-transparency by set 'winblend' option of window, neovim only."
        },
        "outline.showLineNumber": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Show line number of symbols."
        },
        "outline.sortBy": {
          type: "string",
          scope: "application",
          default: "category",
          description: "Sort method for symbols.",
          enum: ["position", "name", "category"]
        },
        "outline.splitCommand": {
          type: "string",
          scope: "application",
          default: "botright 30vs",
          description: "Window split command used by outline."
        },
        "outline.switchSortKey": {
          type: "string",
          scope: "application",
          default: "<C-s>",
          description: "The key used to switch sort method for symbols provider of current tree view."
        },
        "outline.togglePreviewKey": {
          type: "string",
          scope: "application",
          default: "p",
          description: "The key used to toggle auto preview feature."
        },
        "pullDiagnostic.ignored": {
          type: "array",
          default: [],
          scope: "application",
          description: "Minimatch patterns to match full filepath that should be ignored for pullDiagnostic.",
          items: {
            type: "string"
          }
        },
        "pullDiagnostic.onChange": {
          type: "boolean",
          default: true,
          scope: "language-overridable",
          description: "Whether to pull for diagnostics on document change."
        },
        "pullDiagnostic.onSave": {
          type: "boolean",
          default: false,
          scope: "language-overridable",
          description: "Whether to pull for diagnostics on document save."
        },
        "pullDiagnostic.workspace": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Whether to pull for workspace diagnostics when possible."
        },
        "refactor.afterContext": {
          type: "integer",
          scope: "application",
          default: 3,
          description: "Print num lines of trailing context after each match."
        },
        "refactor.beforeContext": {
          type: "integer",
          scope: "application",
          default: 3,
          description: "Print num lines of leading context before each match."
        },
        "refactor.openCommand": {
          type: "string",
          scope: "application",
          description: "Open command for refactor window.",
          default: "vsplit"
        },
        "refactor.saveToFile": {
          type: "boolean",
          scope: "application",
          description: "Save changed buffer to file when write refactor buffer with ':noa wa' command.",
          default: true
        },
        "refactor.showMenu": {
          type: "string",
          scope: "application",
          default: "<Tab>",
          description: "Refactor buffer local mapping to bring up menu for this chunk."
        },
        "semanticTokens.combinedModifiers": {
          type: "array",
          scope: "language-overridable",
          description: "Semantic token modifiers that should have highlight combined with syntax highlights.",
          default: ["deprecated"],
          items: {
            type: "string"
          }
        },
        "semanticTokens.enable": {
          type: "boolean",
          default: false,
          scope: "language-overridable",
          description: "Enable semantic tokens support"
        },
        "semanticTokens.filetypes": {
          type: ["array", "null"],
          scope: "resource",
          description: 'Filetypes that enable semantic tokens highlighting or ["*"] for any filetype',
          deprecationMessage: "Use semanticTokens.enable configuration with language scope instead, see :h coc-configuration-scope",
          default: null,
          items: {
            type: "string"
          }
        },
        "semanticTokens.highlightPriority": {
          type: "integer",
          scope: "language-overridable",
          description: "Priority for semantic tokens highlight.",
          default: 2048,
          maximum: 4096
        },
        "semanticTokens.incrementTypes": {
          type: "array",
          scope: "language-overridable",
          description: "Semantic token types that should increase highlight when insert at the start and end position of token.",
          default: ["variable", "string", "parameter"],
          items: {
            type: "string"
          }
        },
        "signature.enable": {
          type: "boolean",
          scope: "language-overridable",
          description: "Enable show signature help when trigger character typed.",
          default: true
        },
        "signature.floatConfig": {
          type: "object",
          scope: "application",
          description: "Configure float window style of signature documents.",
          allOf: [{ $ref: "#/definitions/floatConfig" }],
          additionalProperties: false,
          properties: {
            border: {},
            rounded: {},
            highlight: {},
            borderhighlight: {},
            title: {},
            close: {},
            maxHeight: {},
            maxWidth: {},
            winblend: {},
            focusable: {},
            shadow: {},
            position: {},
            top: {},
            bottom: {},
            left: {},
            right: {}
          }
        },
        "signature.hideOnTextChange": {
          type: "boolean",
          scope: "language-overridable",
          description: "Hide signature float window when text changed on insert mode.",
          default: false
        },
        "signature.preferShownAbove": {
          type: "boolean",
          scope: "application",
          description: "Show signature help float window above cursor when possible, require restart service on change.",
          default: true
        },
        "signature.target": {
          type: "string",
          scope: "language-overridable",
          description: "Target of signature help, use float when possible by default.",
          default: "float",
          enum: ["float", "echo"]
        },
        "signature.triggerSignatureWait": {
          type: "integer",
          scope: "language-overridable",
          default: 500,
          minimum: 200,
          maximum: 1e3,
          description: "Timeout for trigger signature help, in milliseconds."
        },
        "snippet.highlight": {
          type: "boolean",
          scope: "application",
          description: "Use highlight group 'CocSnippetVisual' to highlight placeholders with same index of current one.",
          default: false
        },
        "snippet.nextPlaceholderOnDelete": {
          type: "boolean",
          scope: "application",
          description: "Automatically jump to the next placeholder when the current one is completely deleted.",
          default: false
        },
        "snippet.statusText": {
          type: "string",
          scope: "application",
          default: "SNIP",
          description: "Text shown in statusline to indicate snippet session is activated."
        },
        "suggest.acceptSuggestionOnCommitCharacter": {
          type: "boolean",
          default: false,
          scope: "language-overridable",
          description: "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character."
        },
        "suggest.asciiCharactersOnly": {
          type: "boolean",
          description: "Trigger suggest with ASCII characters only",
          scope: "language-overridable",
          default: false
        },
        "suggest.segmenterLocales": {
          type: ["string", "null"],
          default: "",
          scope: "language-overridable",
          description: "Locales used for divide sentence into segments for around and buffer source, works when NodeJS built with intl support, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Segmenter/Segmenter#parameters, default empty string means auto detect, use null to disable this feature."
        },
        "suggest.asciiMatch": {
          type: "boolean",
          description: "Convert unicode characters to ascii for match",
          scope: "language-overridable",
          default: true
        },
        "suggest.autoTrigger": {
          type: "string",
          scope: "language-overridable",
          default: "always",
          description: "How should completion be triggered",
          enum: ["always", "trigger", "none"]
        },
        "suggest.reTriggerAfterIndent": {
          type: "boolean",
          description: "Re-Trigger completion after indent changes",
          scope: "language-overridable",
          default: true
        },
        "suggest.completionItemKindLabels": {
          type: "object",
          default: {},
          scope: "application",
          description: "Set custom labels to completion items' kinds.",
          properties: {
            text: { type: "string" },
            method: { type: "string" },
            function: { type: "string" },
            constructor: { type: "string" },
            field: { type: "string" },
            variable: { type: "string" },
            class: { type: "string" },
            interface: { type: "string" },
            module: { type: "string" },
            property: { type: "string" },
            unit: { type: "string" },
            value: { type: "string" },
            enum: { type: "string" },
            keyword: { type: "string" },
            snippet: { type: "string" },
            color: { type: "string" },
            file: { type: "string" },
            reference: { type: "string" },
            folder: { type: "string" },
            enumMember: { type: "string" },
            constant: { type: "string" },
            struct: { type: "string" },
            event: { type: "string" },
            operator: { type: "string" },
            typeParameter: { type: "string" },
            default: { type: "string" }
          },
          additionalProperties: false
        },
        "suggest.defaultSortMethod": {
          type: "string",
          description: "Default sorting behavior for suggested completion items.",
          default: "length",
          scope: "language-overridable",
          enum: ["length", "alphabetical", "none"]
        },
        "suggest.detailField": {
          type: "string",
          scope: "application",
          default: "preview",
          description: "Where to show the detail text of CompleteItem from LS.",
          enum: ["abbr", "preview"]
        },
        "suggest.detailMaxLength": {
          type: "integer",
          scope: "application",
          description: "Max length of detail that should be shown in popup menu.",
          deprecationMessage: "Use suggest.labelMaxLength instead.",
          default: 100
        },
        "suggest.enableFloat": {
          type: "boolean",
          scope: "language-overridable",
          description: "Enable float window with documentation aside with popupmenu.",
          default: true
        },
        "suggest.enablePreselect": {
          type: "boolean",
          scope: "application",
          description: "Enable preselect feature of LSP, works when suggest.noselect is false.",
          default: true
        },
        "suggest.filterGraceful": {
          type: "boolean",
          description: "Controls whether filtering and sorting suggestions accounts for small typos.",
          scope: "language-overridable",
          default: true
        },
        "suggest.filterOnBackspace": {
          type: "boolean",
          scope: "application",
          description: "Filter complete items on backspace.",
          default: true
        },
        "suggest.floatConfig": {
          type: "object",
          scope: "application",
          description: "Configure style of popup menu and documentation window of completion.",
          allOf: [{ $ref: "#/definitions/floatConfig" }],
          additionalProperties: false,
          properties: {
            border: {},
            rounded: {},
            highlight: {},
            borderhighlight: {},
            title: {},
            maxWidth: {},
            winblend: {},
            shadow: {}
          }
        },
        "suggest.formatItems": {
          type: "array",
          scope: "application",
          items: {
            enum: ["abbr", "menu", "kind", "shortcut"]
          },
          contains: {
            enum: ["abbr"]
          },
          uniqueItems: true,
          description: "Items shown in popup menu in order.",
          default: ["abbr", "menu", "kind", "shortcut"]
        },
        "suggest.highPrioritySourceLimit": {
          type: "integer",
          minimum: 1,
          maximum: 100,
          scope: "language-overridable",
          description: "Max items count for source priority bigger than or equal to 90."
        },
        "suggest.insertMode": {
          type: "string",
          scope: "language-overridable",
          default: "replace",
          description: "Controls whether words are overwritten when accepting completions.",
          enum: ["insert", "replace"]
        },
        "suggest.ignoreRegexps": {
          type: "array",
          scope: "language-overridable",
          items: {
            type: "string"
          },
          description: "Regexps to ignore when trigger suggest",
          default: []
        },
        "suggest.invalidInsertCharacters": {
          type: "array",
          items: {
            type: "string"
          },
          scope: "application",
          description: "Invalid character for strip valid word when inserting text of complete item.",
          default: ["\r", "\n"]
        },
        "suggest.labelMaxLength": {
          type: "integer",
          scope: "application",
          description: "Max length of abbr that shown as label of complete item.",
          default: 200
        },
        "suggest.languageSourcePriority": {
          type: "integer",
          default: 99,
          scope: "language-overridable",
          description: "Priority of language sources."
        },
        "suggest.localityBonus": {
          type: "boolean",
          description: "Controls whether sorting favors words that appear close to the cursor.",
          scope: "language-overridable",
          default: true
        },
        "suggest.lowPrioritySourceLimit": {
          type: "integer",
          minimum: 1,
          maximum: 100,
          scope: "language-overridable",
          description: "Max items count for source priority lower than 90."
        },
        "suggest.maxCompleteItemCount": {
          type: "integer",
          default: 256,
          scope: "language-overridable",
          description: "Maximum number of complete items shown in vim"
        },
        "suggest.minTriggerInputLength": {
          type: "integer",
          default: 1,
          scope: "language-overridable",
          description: "Minimal input length for trigger completion, default 1"
        },
        "suggest.noselect": {
          type: "boolean",
          scope: "application",
          description: "Not make vim select first item on popupmenu shown",
          default: false
        },
        "suggest.preferCompleteThanJumpPlaceholder": {
          type: "boolean",
          description: "Confirm completion instead of jump to next placeholder when completion is activated.",
          scope: "resource",
          default: false
        },
        "suggest.pumFloatConfig": {
          type: ["object", "null"],
          scope: "application",
          description: "Configure style of popup menu, suggest.floatConfig is used when not specified.",
          allOf: [{ $ref: "#/definitions/floatConfig" }],
          additionalProperties: false,
          default: null,
          properties: {
            title: {},
            border: {},
            rounded: {},
            highlight: {},
            borderhighlight: {},
            winblend: {},
            shadow: {}
          }
        },
        "suggest.removeDuplicateItems": {
          type: "boolean",
          description: "Remove completion items with duplicated word for all sources, snippet items are excluded.",
          scope: "language-overridable",
          default: false
        },
        "suggest.removeCurrentWord": {
          type: "boolean",
          description: "Remove word item (from around and buffer source) that is identical to current input",
          scope: "language-overridable",
          default: false
        },
        "suggest.reversePumAboveCursor": {
          type: "boolean",
          scope: "application",
          description: "Reverse order of complete items when pum shown above cursor.",
          default: false
        },
        "suggest.selection": {
          type: "string",
          scope: "application",
          default: "first",
          description: "Controls how suggestions are pre-selected when showing the suggest list.",
          enum: ["first", "recentlyUsed", "recentlyUsedByPrefix"]
        },
        "suggest.snippetIndicator": {
          type: "string",
          default: "~",
          scope: "application",
          description: "The character used in abbr of complete item to indicate the item could be expand as snippet."
        },
        "suggest.snippetsSupport": {
          type: "boolean",
          scope: "language-overridable",
          description: "Set to false to disable snippets support of completion.",
          default: true
        },
        "suggest.timeout": {
          type: "integer",
          default: 5e3,
          minimum: 500,
          maximum: 15e3,
          scope: "language-overridable",
          description: "Timeout for completion, in milliseconds."
        },
        "suggest.triggerAfterInsertEnter": {
          type: "boolean",
          description: "Trigger completion after InsertEnter, auto trigger should be 'always' to enable this option",
          scope: "language-overridable",
          default: false
        },
        "suggest.triggerCompletionWait": {
          type: "integer",
          default: 0,
          minimum: 0,
          maximum: 50,
          scope: "language-overridable",
          description: "Wait time between text change and completion start, completion is canceled when text changed during wait."
        },
        "suggest.virtualText": {
          type: "boolean",
          scope: "application",
          description: "Show virtual text for insert word of the selected item if any",
          default: false
        },
        "tree.closedIcon": {
          type: "string",
          scope: "application",
          default: "+",
          description: "Closed icon of tree view."
        },
        "tree.key.actions": {
          type: "string",
          scope: "application",
          default: "<tab>",
          description: "Trigger key to invoke actions."
        },
        "tree.key.activeFilter": {
          type: "string",
          scope: "application",
          default: "f",
          description: "Trigger key active filter."
        },
        "tree.key.close": {
          type: "string",
          scope: "application",
          default: "<esc>",
          description: "Trigger key to dispose the tree and close tree window."
        },
        "tree.key.collapseAll": {
          type: "string",
          scope: "application",
          default: "M",
          description: "Trigger key to collapse all tree node."
        },
        "tree.key.invoke": {
          type: "string",
          scope: "application",
          default: "<cr>",
          description: "Trigger key to invoke default command of current node or selection."
        },
        "tree.key.selectNext": {
          type: "string",
          scope: "application",
          default: "<C-j>",
          description: "Trigger key to select next item during filter."
        },
        "tree.key.selectPrevious": {
          type: "string",
          scope: "application",
          default: "<C-k>",
          description: "Trigger key to select previous item during filter."
        },
        "tree.key.toggle": {
          type: "string",
          scope: "application",
          default: "t",
          description: "Trigger key to toggle expand state of tree node, does nothing with leaf node."
        },
        "tree.key.toggleSelection": {
          type: "string",
          scope: "application",
          default: "<space>",
          description: "Trigger key to select/unselect item"
        },
        "tree.openedIcon": {
          type: "string",
          scope: "application",
          default: "-",
          description: "Opened icon of tree view."
        },
        "typeHierarchy.enableTooltip": {
          type: "boolean",
          scope: "application",
          default: true,
          description: "Enable tooltip to show relative filepath of type hierarchy."
        },
        "typeHierarchy.openCommand": {
          type: "string",
          scope: "application",
          default: "edit",
          description: "Open command for type hierarchy tree view."
        },
        "typeHierarchy.splitCommand": {
          type: "string",
          scope: "application",
          default: "botright 30vs",
          description: "Window split command used by type hierarchy tree view."
        },
        "workspace.rootPatterns": {
          type: "array",
          default: [".git", ".hg", ".projections.json"],
          scope: "application",
          description: "Root patterns to resolve workspaceFolder from parent folders of opened files, resolved from up to down.",
          items: {
            type: "string"
          }
        },
        "workspace.bottomUpFiletypes": {
          type: "array",
          default: [],
          scope: "application",
          description: 'Filetypes that should have workspace folder should resolved from base directory of file, or ["*"] for any filetype.',
          items: {
            type: "string"
          }
        },
        "workspace.ignoredFiletypes": {
          type: "array",
          default: [],
          scope: "application",
          description: "Filetypes that should be ignored for workspace folder resolve.",
          items: {
            type: "string"
          }
        },
        "workspace.ignoredFolders": {
          type: "array",
          default: [
            "$HOME",
            "$HOME/.cargo/**",
            "$HOME/.rustup/**",
            "$HOME/pkg/mod/**",
            "$HOMEBREW_PREFIX/**"
          ],
          scope: "application",
          description: "List of folders that should not be resolved as workspace folder, environment variables and minimatch patterns can be used.",
          items: {
            type: "string"
          }
        },
        "workspace.openOutputCommand": {
          type: "string",
          default: "vs",
          scope: "resource",
          description: "Command used to open output channel."
        },
        "workspace.openResourceCommand": {
          type: "string",
          default: "tab drop",
          scope: "application",
          description: "Command to open files that not loaded, load files as hidden buffers when empty."
        },
        "workspace.workspaceFolderCheckCwd": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Whether the current working directory should be used first when checking patterns match for workspace folder."
        },
        "workspace.workspaceFolderFallbackCwd": {
          type: "boolean",
          default: true,
          scope: "application",
          description: "Use current working directory as workspace folder when no root patterns resolved."
        },
        "workspace.removeEmptyWorkspaceFolder": {
          type: "boolean",
          default: false,
          scope: "application",
          description: "Automatically remove the workspace folder when no buffer associated with it."
        },
        languageserver: {
          type: "object",
          default: {},
          scope: "resource",
          description: "Dictionary of languageservers, key is used as id of languageserver, restart coc.nvim required after change.",
          patternProperties: {
            "^[_a-zA-Z]+$": {
              oneOf: [
                {
                  $ref: "#/definitions/languageServerModule"
                },
                {
                  $ref: "#/definitions/languageServerCommand"
                },
                {
                  $ref: "#/definitions/languageServerSocket"
                }
              ]
            }
          }
        }
      }
    };
  }
});

// src/util/jsonRegistry.ts
var Extensions2, JSONContributionRegistry, jsonContributionRegistry;
var init_jsonRegistry = __esm({
  "src/util/jsonRegistry.ts"() {
    "use strict";
    init_protocol();
    init_registry();
    Extensions2 = {
      JSONContribution: "base.contributions.json"
    };
    JSONContributionRegistry = class {
      constructor() {
        this._onDidChangeSchema = new import_node4.Emitter();
        this.onDidChangeSchema = this._onDidChangeSchema.event;
        this.schemasById = {};
      }
      registerSchema(uri, unresolvedSchemaContent) {
        this.schemasById[uri] = unresolvedSchemaContent;
        this._onDidChangeSchema.fire(uri);
      }
      notifySchemaChanged(uri) {
        this._onDidChangeSchema.fire(uri);
      }
      getSchemaContributions() {
        return {
          schemas: this.schemasById
        };
      }
    };
    jsonContributionRegistry = new JSONContributionRegistry();
    Registry.add(Extensions2.JSONContribution, jsonContributionRegistry);
  }
});

// node_modules/vscode-languageserver-textdocument/lib/esm/main.js
function mergeSort(data, compare2) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare2);
  mergeSort(right, compare2);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    let ret = compare2(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    let ch = text.charCodeAt(i);
    if (ch === 13 || ch === 10) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function getWellformedRange(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  const range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}
var FullTextDocument2, TextDocument2;
var init_main3 = __esm({
  "node_modules/vscode-languageserver-textdocument/lib/esm/main.js"() {
    "use strict";
    FullTextDocument2 = class _FullTextDocument {
      constructor(uri, languageId, version2, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version2;
        this._content = content;
        this._lineOffsets = void 0;
      }
      get uri() {
        return this._uri;
      }
      get languageId() {
        return this._languageId;
      }
      get version() {
        return this._version;
      }
      getText(range) {
        if (range) {
          const start = this.offsetAt(range.start);
          const end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      }
      update(changes, version2) {
        for (let change of changes) {
          if (_FullTextDocument.isIncremental(change)) {
            const range = getWellformedRange(change.range);
            const startOffset = this.offsetAt(range.start);
            const endOffset = this.offsetAt(range.end);
            this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
            const startLine = Math.max(range.start.line, 0);
            const endLine = Math.max(range.end.line, 0);
            let lineOffsets = this._lineOffsets;
            const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
            if (endLine - startLine === addedLineOffsets.length) {
              for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                lineOffsets[i + startLine + 1] = addedLineOffsets[i];
              }
            } else {
              if (addedLineOffsets.length < 1e4) {
                lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
              } else {
                this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
              }
            }
            const diff = change.text.length - (endOffset - startOffset);
            if (diff !== 0) {
              for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                lineOffsets[i] = lineOffsets[i] + diff;
              }
            }
          } else if (_FullTextDocument.isFull(change)) {
            this._content = change.text;
            this._lineOffsets = void 0;
          } else {
            throw new Error("Unknown change event received");
          }
        }
        this._version = version2;
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          let mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        let line = low - 1;
        return { line, character: offset - lineOffsets[line] };
      }
      offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      }
      get lineCount() {
        return this.getLineOffsets().length;
      }
      static isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      static isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
    };
    (function(TextDocument3) {
      function create(uri, languageId, version2, content) {
        return new FullTextDocument2(uri, languageId, version2, content);
      }
      TextDocument3.create = create;
      function update(document2, changes, version2) {
        if (document2 instanceof FullTextDocument2) {
          document2.update(changes, version2);
          return document2;
        } else {
          throw new Error("TextDocument.update: document must be created by TextDocument.create");
        }
      }
      TextDocument3.update = update;
      function applyEdits3(document2, edits) {
        let text = document2.getText();
        let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
          let diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        let lastModifiedOffset = 0;
        const spans = [];
        for (const e of sortedEdits) {
          let startOffset = document2.offsetAt(e.range.start);
          if (startOffset < lastModifiedOffset) {
            throw new Error("Overlapping edit");
          } else if (startOffset > lastModifiedOffset) {
            spans.push(text.substring(lastModifiedOffset, startOffset));
          }
          if (e.newText.length) {
            spans.push(e.newText);
          }
          lastModifiedOffset = document2.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join("");
      }
      TextDocument3.applyEdits = applyEdits3;
    })(TextDocument2 || (TextDocument2 = {}));
  }
});

// src/configuration/util.ts
function expand(input) {
  return input.replace(/\$\{(.*?)\}/g, (match, name2) => {
    if (name2.startsWith("env:")) {
      let key = name2.split(":")[1];
      return process.env[key] ?? match;
    }
    switch (name2) {
      case "tmpdir":
        return os.tmpdir();
      case "userHome":
        return os.homedir();
      case "cwd":
        return process.cwd();
      default:
        return match;
    }
  });
}
function expandObject(obj) {
  if (obj == null) return obj;
  if (typeof obj === "string") return expand(obj);
  if (Array.isArray(obj)) return obj.map((obj2) => expandObject(obj2));
  if (objectLiteral(obj)) {
    for (let key of Object.keys(obj)) {
      obj[key] = expandObject(obj[key]);
    }
    return obj;
  }
  return obj;
}
function convertTarget(updateTarget) {
  let target;
  switch (updateTarget) {
    case 1 /* Global */:
      target = 1 /* User */;
      break;
    case 2 /* Workspace */:
      target = 2 /* Workspace */;
      break;
    default:
      target = 3 /* WorkspaceFolder */;
  }
  return target;
}
function scopeToOverrides(scope) {
  let overrides;
  if (typeof scope === "string") {
    overrides = { resource: scope };
  } else if (URI2.isUri(scope)) {
    overrides = { resource: scope.toString() };
  } else if (scope != null) {
    let uri = scope["uri"];
    let languageId = scope["languageId"];
    overrides = { resource: uri, overrideIdentifier: languageId };
  }
  return overrides;
}
function overrideIdentifiersFromKey(key) {
  const identifiers = [];
  if (OVERRIDE_PROPERTY_REGEX.test(key)) {
    let matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);
    while (matches?.length) {
      const identifier = matches[1].trim();
      if (identifier) {
        identifiers.push(identifier);
      }
      matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);
    }
  }
  return distinct(identifiers);
}
function mergeConfigProperties(obj) {
  let res = {};
  for (let key of Object.keys(obj)) {
    if (key.indexOf(".") == -1) {
      res[key] = obj[key];
    } else {
      let parts = key.split(".");
      let pre = res;
      let len = parts.length;
      for (let i = 0; i < len; i++) {
        let k = parts[i];
        if (i == len - 1) {
          pre[k] = obj[key];
        } else {
          pre[k] = pre[k] || {};
          pre = pre[k];
        }
      }
    }
  }
  return res;
}
function convertErrors(content, errors) {
  let items = [];
  let document2 = TextDocument2.create(documentUri, "json", 0, content);
  for (let err of errors) {
    const range = Range.create(document2.positionAt(err.offset), document2.positionAt(err.offset + err.length));
    items.push(Diagnostic.create(range, printParseErrorCode(err.error), DiagnosticSeverity.Error));
  }
  return items;
}
function toValuesTree(properties, conflictReporter, doExpand = false) {
  const root = /* @__PURE__ */ Object.create(null);
  for (const key in properties) {
    addToValueTree(root, key, properties[key], conflictReporter, doExpand);
  }
  return root;
}
function addToValueTree(settingsTreeRoot, key, value, conflictReporter, doExpand = false) {
  const segments = key.split(".");
  const last = segments.pop();
  let curr = settingsTreeRoot;
  for (let i = 0; i < segments.length; i++) {
    const s = segments[i];
    let obj = curr[s];
    switch (typeof obj) {
      case "undefined":
        obj = curr[s] = /* @__PURE__ */ Object.create(null);
        break;
      case "object":
        break;
      default:
        if (conflictReporter) conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join(".")} is ${JSON.stringify(obj)}`);
        return;
    }
    curr = obj;
  }
  if (typeof curr === "object" && curr !== null) {
    if (doExpand) {
      curr[last] = expandObject(value);
    } else {
      curr[last] = value;
    }
  } else {
    if (conflictReporter) conflictReporter(`Ignoring ${key} as ${segments.join(".")} is ${JSON.stringify(curr)}`);
  }
}
function removeFromValueTree(valueTree, key) {
  const segments = key.split(".");
  doRemoveFromValueTree(valueTree, segments);
}
function doRemoveFromValueTree(valueTree, segments) {
  const first = segments.shift();
  if (segments.length === 0) {
    delete valueTree[first];
    return;
  }
  if (Object.keys(valueTree).includes(first)) {
    const value = valueTree[first];
    if (typeof value === "object" && !Array.isArray(value)) {
      doRemoveFromValueTree(value, segments);
      if (Object.keys(value).length === 0) {
        delete valueTree[first];
      }
    }
  }
}
function getConfigurationValue(config, settingPath, defaultValue2) {
  function accessSetting(config2, path3) {
    let current = config2;
    for (let i = 0; i < path3.length; i++) {
      if (typeof current !== "object" || current === null) {
        return void 0;
      }
      current = current[path3[i]];
    }
    return current;
  }
  const path2 = settingPath.split(".");
  const result = accessSetting(config, path2);
  return typeof result === "undefined" ? defaultValue2 : result;
}
function toJSONObject(obj) {
  if (obj) {
    if (Array.isArray(obj)) {
      return obj.map(toJSONObject);
    } else if (typeof obj === "object") {
      const res = /* @__PURE__ */ Object.create(null);
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          res[key] = toJSONObject(obj[key]);
        }
      }
      return res;
    }
  }
  return obj;
}
function compareConfigurationContents(to, from) {
  const added = to ? from ? to.keys.filter((key) => from.keys.indexOf(key) === -1) : [...to.keys] : [];
  const removed = from ? to ? from.keys.filter((key) => to.keys.indexOf(key) === -1) : [...from.keys] : [];
  const updated = [];
  if (to && from) {
    for (const key of from.keys) {
      if (to.keys.indexOf(key) !== -1) {
        const value1 = getConfigurationValue(from.contents, key);
        const value2 = getConfigurationValue(to.contents, key);
        if (!equals(value1, value2)) {
          updated.push(key);
        }
      }
    }
  }
  return { added, removed, updated };
}
function getDefaultValue(type) {
  const t = Array.isArray(type) ? type[0] : type;
  switch (t) {
    case "boolean":
      return false;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "array":
      return [];
    case "object":
      return {};
    default:
      return null;
  }
}
function lookUp(tree, key) {
  if (key) {
    if (tree && hasOwnProperty2(tree, key)) return tree[key];
    const parts = key.split(".");
    let node = tree;
    for (let i = 0; node && i < parts.length; i++) {
      node = node[parts[i]];
    }
    return node;
  }
  return tree;
}
var documentUri, OVERRIDE_IDENTIFIER_PATTERN, OVERRIDE_IDENTIFIER_REGEX, OVERRIDE_PROPERTY_PATTERN, OVERRIDE_PROPERTY_REGEX;
var init_util2 = __esm({
  "src/configuration/util.ts"() {
    "use strict";
    init_main2();
    init_main3();
    init_main();
    init_esm();
    init_array();
    init_is();
    init_node();
    init_object();
    init_types();
    documentUri = "file:///1";
    OVERRIDE_IDENTIFIER_PATTERN = `\\[([^\\]]+)\\]`;
    OVERRIDE_IDENTIFIER_REGEX = new RegExp(OVERRIDE_IDENTIFIER_PATTERN, "g");
    OVERRIDE_PROPERTY_PATTERN = `^(${OVERRIDE_IDENTIFIER_PATTERN})+$`;
    OVERRIDE_PROPERTY_REGEX = new RegExp(OVERRIDE_PROPERTY_PATTERN);
  }
});

// src/configuration/model.ts
var ConfigurationModel;
var init_model = __esm({
  "src/configuration/model.ts"() {
    "use strict";
    init_array();
    init_is();
    init_object();
    init_util2();
    ConfigurationModel = class _ConfigurationModel {
      constructor(_contents = {}, _keys = [], _overrides = []) {
        this._contents = _contents;
        this._keys = _keys;
        this._overrides = _overrides;
        this.frozen = false;
        this.overrideConfigurations = /* @__PURE__ */ new Map();
      }
      get contents() {
        return this.checkAndFreeze(this._contents);
      }
      get overrides() {
        return this.checkAndFreeze(this._overrides);
      }
      get keys() {
        return this.checkAndFreeze(this._keys);
      }
      get isFrozen() {
        return this.frozen;
      }
      checkAndFreeze(data) {
        if (this.frozen && !Object.isFrozen(data)) {
          return deepFreeze(data);
        }
        return data;
      }
      isEmpty() {
        return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
      }
      clone() {
        return new _ConfigurationModel(deepClone(this._contents), [...this.keys], deepClone(this.overrides));
      }
      toJSON() {
        return {
          contents: this.contents,
          overrides: this.overrides,
          keys: this.keys
        };
      }
      getValue(section2) {
        let res = section2 ? getConfigurationValue(this.contents, section2) : this.contents;
        return res;
      }
      getOverrideValue(section2, overrideIdentifier) {
        const overrideContents = this.getContentsForOverrideIdentifier(overrideIdentifier);
        return overrideContents ? section2 ? getConfigurationValue(overrideContents, section2) : overrideContents : void 0;
      }
      getKeysForOverrideIdentifier(identifier) {
        const keys = [];
        for (const override of this.overrides) {
          if (override.identifiers.includes(identifier)) {
            keys.push(...override.keys);
          }
        }
        return distinct(keys);
      }
      getAllOverrideIdentifiers() {
        const result = [];
        for (const override of this.overrides) {
          result.push(...override.identifiers);
        }
        return distinct(result);
      }
      override(identifier) {
        let overrideConfigurationModel = this.overrideConfigurations.get(identifier);
        if (!overrideConfigurationModel) {
          overrideConfigurationModel = this.createOverrideConfigurationModel(identifier);
          this.overrideConfigurations.set(identifier, overrideConfigurationModel);
        }
        return overrideConfigurationModel;
      }
      merge(...others) {
        const contents = deepClone(this._contents);
        const overrides = deepClone(this._overrides);
        const keys = [...this._keys];
        for (const other of others) {
          if (other.isEmpty()) {
            continue;
          }
          this.mergeContents(contents, other.contents);
          for (const otherOverride of other.overrides) {
            const [override] = overrides.filter((o) => equals(o.identifiers, otherOverride.identifiers));
            if (override) {
              this.mergeContents(override.contents, otherOverride.contents);
              override.keys.push(...otherOverride.keys);
              override.keys = distinct(override.keys);
            } else {
              overrides.push(deepClone(otherOverride));
            }
          }
          for (const key of other.keys) {
            if (keys.indexOf(key) === -1) {
              keys.push(key);
            }
          }
        }
        return new _ConfigurationModel(contents, keys, overrides);
      }
      freeze() {
        this.frozen = true;
        return this;
      }
      mergeContents(source, target) {
        for (const key of Object.keys(target)) {
          if (key in source) {
            if (objectLiteral(source[key]) && objectLiteral(target[key])) {
              this.mergeContents(source[key], target[key]);
              continue;
            }
          }
          source[key] = deepClone(target[key]);
        }
      }
      // Update methods
      setValue(key, value) {
        this.addKey(key);
        addToValueTree(this.contents, key, value, (e) => {
          console.error(e);
        });
      }
      removeValue(key) {
        if (this.removeKey(key)) {
          removeFromValueTree(this.contents, key);
        }
      }
      addKey(key) {
        let index = this.keys.length;
        for (let i = 0; i < index; i++) {
          if (key.indexOf(this.keys[i]) === 0) {
            index = i;
          }
        }
        this.keys.splice(index, 1, key);
      }
      removeKey(key) {
        const index = this.keys.indexOf(key);
        if (index !== -1) {
          this.keys.splice(index, 1);
          return true;
        }
        return false;
      }
      createOverrideConfigurationModel(identifier) {
        const overrideContents = this.getContentsForOverrideIdentifier(identifier);
        if (!overrideContents || typeof overrideContents !== "object" || !Object.keys(overrideContents).length) {
          return this;
        }
        const contents = {};
        for (const key of distinct([...Object.keys(this.contents), ...Object.keys(overrideContents)])) {
          let contentsForKey = this.contents[key];
          const overrideContentsForKey = overrideContents[key];
          if (overrideContentsForKey) {
            if (typeof contentsForKey === "object" && typeof overrideContentsForKey === "object") {
              contentsForKey = deepClone(contentsForKey);
              this.mergeContents(contentsForKey, overrideContentsForKey);
            } else {
              contentsForKey = overrideContentsForKey;
            }
          }
          contents[key] = contentsForKey;
        }
        return new _ConfigurationModel(contents, this._keys, this.overrides);
      }
      getContentsForOverrideIdentifier(identifier) {
        let contentsForIdentifierOnly = null;
        let contents = null;
        const mergeContents = (contentsToMerge) => {
          if (contentsToMerge) {
            if (contents) {
              this.mergeContents(contents, contentsToMerge);
            } else {
              contents = deepClone(contentsToMerge);
            }
          }
        };
        for (const override of this.overrides) {
          if (equals(override.identifiers, [identifier])) {
            contentsForIdentifierOnly = override.contents;
          } else if (override.identifiers.includes(identifier)) {
            mergeContents(override.contents);
          }
        }
        mergeContents(contentsForIdentifierOnly);
        return contents;
      }
    };
  }
});

// src/configuration/configuration.ts
function compare(from, to) {
  const { added, removed, updated } = compareConfigurationContents(to, from);
  const overrides = [];
  const fromOverrideIdentifiers = from?.getAllOverrideIdentifiers() ?? [];
  const toOverrideIdentifiers = to?.getAllOverrideIdentifiers() ?? [];
  if (to) {
    const addedOverrideIdentifiers = toOverrideIdentifiers.filter((key) => !fromOverrideIdentifiers.includes(key));
    for (const identifier of addedOverrideIdentifiers) {
      overrides.push([identifier, to.getKeysForOverrideIdentifier(identifier)]);
    }
  }
  if (from) {
    const removedOverrideIdentifiers = fromOverrideIdentifiers.filter((key) => !toOverrideIdentifiers.includes(key));
    for (const identifier of removedOverrideIdentifiers) {
      overrides.push([identifier, from.getKeysForOverrideIdentifier(identifier)]);
    }
  }
  if (to && from) {
    for (const identifier of fromOverrideIdentifiers) {
      if (toOverrideIdentifiers.includes(identifier)) {
        const result = compareConfigurationContents({ contents: from.getOverrideValue(void 0, identifier) || {}, keys: from.getKeysForOverrideIdentifier(identifier) }, { contents: to.getOverrideValue(void 0, identifier) || {}, keys: to.getKeysForOverrideIdentifier(identifier) });
        overrides.push([identifier, [...result.added, ...result.removed, ...result.updated]]);
      }
    }
  }
  return { added, removed, updated, overrides };
}
var FolderConfigutions, Configuration;
var init_configuration = __esm({
  "src/configuration/configuration.ts"() {
    "use strict";
    init_esm();
    init_array();
    init_fs();
    init_object();
    init_model();
    init_types();
    init_util2();
    FolderConfigutions = class {
      constructor() {
        this._folderConfigurations = /* @__PURE__ */ new Map();
      }
      get keys() {
        return this._folderConfigurations.keys();
      }
      has(folder) {
        for (let key of this.keys) {
          if (sameFile(folder, key)) return true;
        }
        return false;
      }
      set(folder, model) {
        let key = normalizeFilePath(folder);
        this._folderConfigurations.set(key, model);
      }
      get(folder) {
        let key = normalizeFilePath(folder);
        return this._folderConfigurations.get(key);
      }
      delete(folder) {
        let key = normalizeFilePath(folder);
        this._folderConfigurations.delete(key);
      }
      forEach(fn) {
        this._folderConfigurations.forEach(fn);
      }
      getConfigurationByResource(uri) {
        let u = URI2.parse(uri);
        if (u.scheme !== "file") return void 0;
        let folders = Array.from(this._folderConfigurations.keys());
        folders.sort((a, b) => b.length - a.length);
        let fullpath = u.fsPath;
        for (let folder of folders) {
          if (isParentFolder(folder, fullpath, true)) {
            return { folder, model: this._folderConfigurations.get(folder) };
          }
        }
        return void 0;
      }
    };
    Configuration = class _Configuration {
      constructor(_defaultConfiguration, _userConfiguration, _workspaceConfiguration = new ConfigurationModel(), _folderConfigurations = new FolderConfigutions(), _memoryConfiguration = new ConfigurationModel()) {
        this._defaultConfiguration = _defaultConfiguration;
        this._userConfiguration = _userConfiguration;
        this._workspaceConfiguration = _workspaceConfiguration;
        this._folderConfigurations = _folderConfigurations;
        this._memoryConfiguration = _memoryConfiguration;
        this._workspaceConsolidatedConfiguration = null;
        this._resolvedFolderConfigurations = /* @__PURE__ */ new Map();
        this._memoryConfigurationByResource = /* @__PURE__ */ new Map();
      }
      updateValue(key, value, overrides = {}) {
        let memoryConfiguration;
        if (overrides.resource) {
          memoryConfiguration = this._memoryConfigurationByResource.get(overrides.resource);
          if (!memoryConfiguration) {
            memoryConfiguration = new ConfigurationModel();
            this._memoryConfigurationByResource.set(overrides.resource, memoryConfiguration);
          }
        } else {
          memoryConfiguration = this._memoryConfiguration;
        }
        if (value === void 0) {
          memoryConfiguration.removeValue(key);
        } else {
          memoryConfiguration.setValue(key, value);
        }
        if (!overrides.resource) {
          this._workspaceConsolidatedConfiguration = null;
        }
      }
      hasFolder(folder) {
        return this._folderConfigurations.has(folder);
      }
      addFolderConfiguration(folder, model, resource) {
        this._folderConfigurations.set(folder, model);
        if (resource) {
          this._resolvedFolderConfigurations.set(resource, folder);
        }
      }
      deleteFolderConfiguration(fsPath2) {
        this._folderConfigurations.delete(fsPath2);
      }
      getWorkspaceConsolidateConfiguration() {
        if (!this._workspaceConsolidatedConfiguration) {
          this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this._userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
          this._workspaceConsolidatedConfiguration = this._workspaceConsolidatedConfiguration.freeze();
        }
        return this._workspaceConsolidatedConfiguration;
      }
      /**
       * Get folder configuration fsPath & model
       * @param uri folder or file uri
       */
      getFolderConfigurationModelForResource(uri) {
        let folder = this._resolvedFolderConfigurations.get(uri);
        if (folder) return this._folderConfigurations.get(folder);
        let conf = this._folderConfigurations.getConfigurationByResource(uri);
        if (!conf) return void 0;
        this._resolvedFolderConfigurations.set(uri, conf.folder);
        return conf.model;
      }
      resolveFolder(uri) {
        let folder = this._resolvedFolderConfigurations.get(uri);
        if (folder) return folder;
        let folders = Array.from(this._folderConfigurations.keys);
        folders.sort((a, b) => b.length - a.length);
        for (let folder2 of folders) {
          if (isParentFolder(folder2, URI2.parse(uri).fsPath, true)) {
            this._resolvedFolderConfigurations.set(uri, folder2);
            return folder2;
          }
        }
        return void 0;
      }
      getConsolidatedConfigurationModel(overrides) {
        let configuration2 = this.getWorkspaceConsolidateConfiguration();
        if (overrides.resource) {
          let folderConfiguration = this.getFolderConfigurationModelForResource(overrides.resource);
          if (folderConfiguration) {
            configuration2 = configuration2.merge(folderConfiguration);
          }
          const memoryConfigurationForResource = this._memoryConfigurationByResource.get(overrides.resource);
          if (memoryConfigurationForResource) {
            configuration2 = configuration2.merge(memoryConfigurationForResource);
          }
        }
        if (overrides.overrideIdentifier) {
          configuration2 = configuration2.override(overrides.overrideIdentifier);
        }
        return configuration2;
      }
      getValue(section2, overrides) {
        let configuration2 = this.getConsolidatedConfigurationModel(overrides);
        return configuration2.getValue(section2);
      }
      inspect(key, overrides) {
        const consolidateConfigurationModel = this.getConsolidatedConfigurationModel(overrides);
        const folderConfigurationModel = this.getFolderConfigurationModelForResource(overrides.resource);
        const memoryConfigurationModel = overrides.resource ? this._memoryConfigurationByResource.get(overrides.resource) || this._memoryConfiguration : this._memoryConfiguration;
        const defaultValue2 = overrides.overrideIdentifier ? this._defaultConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._defaultConfiguration.freeze().getValue(key);
        const userValue = overrides.overrideIdentifier ? this._userConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._userConfiguration.freeze().getValue(key);
        const workspaceValue = overrides.overrideIdentifier ? this._workspaceConfiguration.freeze().override(overrides.overrideIdentifier).getValue(key) : this._workspaceConfiguration.freeze().getValue(key);
        const workspaceFolderValue = folderConfigurationModel ? overrides.overrideIdentifier ? folderConfigurationModel.freeze().override(overrides.overrideIdentifier).getValue(key) : folderConfigurationModel.freeze().getValue(key) : void 0;
        const memoryValue = overrides.overrideIdentifier ? memoryConfigurationModel.override(overrides.overrideIdentifier).getValue(key) : memoryConfigurationModel.getValue(key);
        const value = consolidateConfigurationModel.getValue(key);
        const overrideIdentifiers = distinct(consolidateConfigurationModel.overrides.map((override) => override.identifiers).flat()).filter((overrideIdentifier) => consolidateConfigurationModel.getOverrideValue(key, overrideIdentifier) !== void 0);
        return {
          defaultValue: defaultValue2,
          userValue,
          workspaceValue,
          workspaceFolderValue,
          memoryValue,
          value,
          default: defaultValue2 !== void 0 ? { value: this._defaultConfiguration.freeze().getValue(key), override: overrides.overrideIdentifier ? this._defaultConfiguration.freeze().getOverrideValue(key, overrides.overrideIdentifier) : void 0 } : void 0,
          user: userValue !== void 0 ? { value: this._userConfiguration.freeze().getValue(key), override: overrides.overrideIdentifier ? this._userConfiguration.freeze().getOverrideValue(key, overrides.overrideIdentifier) : void 0 } : void 0,
          workspace: workspaceValue !== void 0 ? { value: this._workspaceConfiguration.freeze().getValue(key), override: overrides.overrideIdentifier ? this._workspaceConfiguration.freeze().getOverrideValue(key, overrides.overrideIdentifier) : void 0 } : void 0,
          workspaceFolder: workspaceFolderValue !== void 0 ? { value: folderConfigurationModel?.freeze().getValue(key), override: overrides.overrideIdentifier ? folderConfigurationModel?.freeze().getOverrideValue(key, overrides.overrideIdentifier) : void 0 } : void 0,
          memory: memoryValue !== void 0 ? { value: memoryConfigurationModel.getValue(key), override: overrides.overrideIdentifier ? memoryConfigurationModel.getOverrideValue(key, overrides.overrideIdentifier) : void 0 } : void 0,
          overrideIdentifiers: overrideIdentifiers.length ? overrideIdentifiers : void 0
        };
      }
      get defaults() {
        return this._defaultConfiguration;
      }
      get user() {
        return this._userConfiguration;
      }
      get workspace() {
        return this._workspaceConfiguration;
      }
      get memory() {
        return this._memoryConfiguration;
      }
      getConfigurationModel(target, folder) {
        switch (target) {
          case 0 /* Default */:
            return this._defaultConfiguration;
          case 1 /* User */:
            return this._userConfiguration;
          case 2 /* Workspace */:
            return this._workspaceConfiguration;
          case 3 /* WorkspaceFolder */:
            return this._folderConfigurations.get(folder) ?? new ConfigurationModel();
          default:
            return this._memoryConfiguration;
        }
      }
      updateFolderConfiguration(folder, model) {
        this._folderConfigurations.set(folder, model);
      }
      updateUserConfiguration(model) {
        this._userConfiguration = model;
        this._workspaceConsolidatedConfiguration = null;
      }
      updateWorkspaceConfiguration(model) {
        this._workspaceConfiguration = model;
        this._workspaceConsolidatedConfiguration = null;
      }
      updateDefaultConfiguration(model) {
        this._defaultConfiguration = model;
        this._workspaceConsolidatedConfiguration = null;
      }
      updateMemoryConfiguration(model) {
        this._memoryConfiguration = model;
        this._workspaceConsolidatedConfiguration = null;
      }
      compareAndUpdateMemoryConfiguration(memory) {
        const { added, updated, removed, overrides } = compare(this._memoryConfiguration, memory);
        const keys = [...added, ...updated, ...removed];
        if (keys.length) {
          this.updateMemoryConfiguration(memory);
        }
        return { keys, overrides };
      }
      compareAndUpdateUserConfiguration(user) {
        const { added, updated, removed, overrides } = compare(this._userConfiguration, user);
        const keys = [...added, ...updated, ...removed];
        if (keys.length) {
          this.updateUserConfiguration(user);
        }
        return { keys, overrides };
      }
      compareAndUpdateDefaultConfiguration(defaults, keys) {
        const overrides = [];
        if (!keys) {
          const { added, updated, removed } = compare(this._defaultConfiguration, defaults);
          keys = [...added, ...updated, ...removed];
        }
        for (const key of keys) {
          for (const overrideIdentifier of overrideIdentifiersFromKey(key)) {
            const fromKeys = this._defaultConfiguration.getKeysForOverrideIdentifier(overrideIdentifier);
            const toKeys = defaults.getKeysForOverrideIdentifier(overrideIdentifier);
            const keys2 = [
              ...toKeys.filter((key2) => fromKeys.indexOf(key2) === -1),
              ...fromKeys.filter((key2) => toKeys.indexOf(key2) === -1),
              ...fromKeys.filter((key2) => !equals(this._defaultConfiguration.override(overrideIdentifier).getValue(key2), defaults.override(overrideIdentifier).getValue(key2)))
            ];
            overrides.push([overrideIdentifier, keys2]);
          }
        }
        this.updateDefaultConfiguration(defaults);
        return { keys, overrides };
      }
      compareAndUpdateWorkspaceConfiguration(workspaceConfiguration) {
        const { added, updated, removed, overrides } = compare(this._workspaceConfiguration, workspaceConfiguration);
        const keys = [...added, ...updated, ...removed];
        if (keys.length) {
          this.updateWorkspaceConfiguration(workspaceConfiguration);
        }
        return { keys, overrides };
      }
      compareAndUpdateFolderConfiguration(folder, folderConfiguration) {
        const currentFolderConfiguration = this._folderConfigurations.get(folder);
        const { added, updated, removed, overrides } = compare(currentFolderConfiguration, folderConfiguration);
        const keys = [...added, ...updated, ...removed];
        if (keys.length || !currentFolderConfiguration) {
          this.updateFolderConfiguration(folder, folderConfiguration);
        }
        return { keys, overrides };
      }
      compareAndDeleteFolderConfiguration(folder) {
        const folderConfig = this._folderConfigurations.get(folder);
        if (!folderConfig) return;
        this.deleteFolderConfiguration(folder);
        const { added, updated, removed, overrides } = compare(folderConfig, void 0);
        return { keys: [...added, ...updated, ...removed], overrides };
      }
      allKeys() {
        const keys = /* @__PURE__ */ new Set();
        this._defaultConfiguration.freeze().keys.forEach((key) => keys.add(key));
        this._userConfiguration.freeze().keys.forEach((key) => keys.add(key));
        this._workspaceConfiguration.freeze().keys.forEach((key) => keys.add(key));
        this._folderConfigurations.forEach((folderConfiguration) => folderConfiguration.freeze().keys.forEach((key) => keys.add(key)));
        return [...keys.values()];
      }
      toData() {
        let { _defaultConfiguration, _memoryConfiguration, _userConfiguration, _workspaceConfiguration, _folderConfigurations } = this;
        let folders = [];
        _folderConfigurations.forEach((model, fsPath2) => {
          folders.push([fsPath2, model.toJSON()]);
        });
        return {
          defaults: _defaultConfiguration.toJSON(),
          user: _userConfiguration.toJSON(),
          workspace: _workspaceConfiguration.toJSON(),
          folders,
          memory: _memoryConfiguration.toJSON()
        };
      }
      static parse(data) {
        const defaultConfiguration = this.parseConfigurationModel(data.defaults);
        const userConfiguration = this.parseConfigurationModel(data.user);
        const workspaceConfiguration = this.parseConfigurationModel(data.workspace);
        const folderConfigurations = new FolderConfigutions();
        const memoryConfiguration = this.parseConfigurationModel(data.memory);
        data.folders.forEach((value) => {
          folderConfigurations.set(value[0], this.parseConfigurationModel(value[1]));
        });
        return new _Configuration(defaultConfiguration, userConfiguration, workspaceConfiguration, folderConfigurations, memoryConfiguration);
      }
      static parseConfigurationModel(model) {
        return new ConfigurationModel(model.contents, model.keys, model.overrides).freeze();
      }
    };
  }
});

// src/configuration/event.ts
var ConfigurationChangeEvent;
var init_event = __esm({
  "src/configuration/event.ts"() {
    "use strict";
    init_object();
    init_configuration();
    init_model();
    init_util2();
    ConfigurationChangeEvent = class {
      // public sourceConfig: any
      constructor(change, previous, currentConfiguration) {
        this.change = change;
        this.previous = previous;
        this.currentConfiguration = currentConfiguration;
        this._previousConfiguration = void 0;
        const keysSet = /* @__PURE__ */ new Set();
        change.keys.forEach((key) => keysSet.add(key));
        change.overrides.forEach(([, keys]) => keys.forEach((key) => keysSet.add(key)));
        this.affectedKeys = [...keysSet.values()];
        const configurationModel = new ConfigurationModel();
        this.affectedKeys.forEach((key) => configurationModel.setValue(key, {}));
        this.affectedKeysTree = configurationModel.contents;
      }
      get previousConfiguration() {
        if (!this._previousConfiguration && this.previous) {
          this._previousConfiguration = Configuration.parse(this.previous);
        }
        return this._previousConfiguration;
      }
      affectsConfiguration(section2, scope) {
        let overrides = scope ? scopeToOverrides(scope) : void 0;
        if (this.doesAffectedKeysTreeContains(this.affectedKeysTree, section2)) {
          if (overrides) {
            const value1 = this.previousConfiguration ? this.previousConfiguration.getValue(section2, overrides) : void 0;
            const value2 = this.currentConfiguration.getValue(section2, overrides);
            return !equals(value1, value2);
          }
          return true;
        }
        return false;
      }
      doesAffectedKeysTreeContains(affectedKeysTree, section2) {
        let requestedTree = toValuesTree({ [section2]: true }, () => {
        });
        let key;
        while (typeof requestedTree === "object" && (key = Object.keys(requestedTree)[0])) {
          affectedKeysTree = affectedKeysTree[key];
          if (!affectedKeysTree) {
            return false;
          }
          requestedTree = requestedTree[key];
        }
        return true;
      }
    };
  }
});

// src/configuration/parser.ts
var logger7, ConfigurationModelParser;
var init_parser2 = __esm({
  "src/configuration/parser.ts"() {
    "use strict";
    init_main2();
    init_main();
    init_logger();
    init_model();
    init_util2();
    logger7 = createLogger("parser");
    ConfigurationModelParser = class {
      constructor(_name) {
        this._name = _name;
        this._raw = null;
        this._configurationModel = null;
        this._parseErrors = [];
      }
      get configurationModel() {
        return this._configurationModel || new ConfigurationModel();
      }
      get errors() {
        return this._parseErrors;
      }
      parse(content, options2) {
        if (content != null) {
          const raw = this.doParseContent(content);
          this.parseRaw(raw, options2);
        }
      }
      parseRaw(raw, options2) {
        this._raw = raw;
        const { contents, keys, overrides } = this.doParseRaw(raw, options2);
        this._configurationModel = new ConfigurationModel(contents, keys, overrides);
      }
      doParseContent(content) {
        let raw = {};
        let currentProperty = null;
        let currentParent = [];
        const previousParents = [];
        const _errors = [];
        function onValue(value) {
          if (Array.isArray(currentParent)) {
            currentParent.push(value);
          } else if (currentProperty !== null) {
            currentParent[currentProperty] = value;
          }
        }
        const visitor = {
          onObjectBegin: () => {
            const object = {};
            onValue(object);
            previousParents.push(currentParent);
            currentParent = object;
            currentProperty = null;
          },
          onObjectProperty: (name2) => {
            currentProperty = name2;
          },
          onObjectEnd: () => {
            currentParent = previousParents.pop();
          },
          onArrayBegin: () => {
            const array = [];
            onValue(array);
            previousParents.push(currentParent);
            currentParent = array;
            currentProperty = null;
          },
          onArrayEnd: () => {
            currentParent = previousParents.pop();
          },
          onLiteralValue: onValue,
          onError: (error, offset, length) => {
            _errors.push({ error, length, offset });
          }
        };
        if (content) {
          try {
            visit2(content, visitor, { allowTrailingComma: true, allowEmptyContent: true });
            raw = currentParent[0] ?? {};
            if (_errors.length > 0) {
              this._parseErrors = convertErrors(content, _errors);
            }
          } catch (e) {
            this._parseErrors = [{
              range: Range.create(0, 0, 0, 0),
              message: `Error on parse configuration file ${this._name}: ${e}`
            }];
          }
        }
        return raw;
      }
      doParseRaw(raw, _options) {
        const onError = (message) => {
          console.error(`Conflict in settings file ${this._name}: ${message}`);
        };
        const contents = toValuesTree(raw, onError, true);
        const keys = Object.keys(raw);
        const overrides = this.toOverrides(raw, onError);
        return { contents, keys, overrides, restricted: [] };
      }
      toOverrides(raw, conflictReporter) {
        const overrides = [];
        for (const key of Object.keys(raw)) {
          if (OVERRIDE_PROPERTY_REGEX.test(key)) {
            const overrideRaw = {};
            for (const keyInOverrideRaw in raw[key]) {
              overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];
            }
            overrides.push({
              identifiers: overrideIdentifiersFromKey(key),
              keys: Object.keys(overrideRaw),
              contents: toValuesTree(overrideRaw, conflictReporter, true)
            });
          }
        }
        return overrides;
      }
    };
  }
});

// src/configuration/registry.ts
function validateProperty(property, _schema = void 0) {
  if (!property.trim()) {
    return "Cannot register an empty property";
  }
  if (OVERRIDE_PROPERTY_REGEX.test(property)) {
    return `Cannot register ${property}. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings`;
  }
  if (configurationRegistry.getConfigurationProperties()[property] !== void 0) {
    return `Cannot register '${property}'. This property is already registered.`;
  }
  return null;
}
var EXCLUDE_KEYS, Extensions3, allSettings, resourceSettings, resourceLanguageSettingsSchemaId, contributionRegistry, ConfigurationRegistry, configurationRegistry;
var init_registry2 = __esm({
  "src/configuration/registry.ts"() {
    "use strict";
    init_array();
    init_jsonRegistry();
    init_object();
    init_protocol();
    init_registry();
    init_types();
    init_util2();
    EXCLUDE_KEYS = ["log-path", "logPath"];
    Extensions3 = {
      Configuration: "base.contributions.configuration"
    };
    allSettings = { properties: {}, patternProperties: {} };
    resourceSettings = { properties: {}, patternProperties: {} };
    resourceLanguageSettingsSchemaId = "vscode://schemas/settings/resourceLanguage";
    contributionRegistry = Registry.as(Extensions2.JSONContribution);
    ConfigurationRegistry = class {
      constructor() {
        this._onDidSchemaChange = new import_node4.Emitter();
        this.onDidSchemaChange = this._onDidSchemaChange.event;
        this._onDidUpdateConfiguration = new import_node4.Emitter();
        this.onDidUpdateConfiguration = this._onDidUpdateConfiguration.event;
        this.resourceLanguageSettingsSchema = { properties: {}, patternProperties: {}, additionalProperties: false, errorMessage: "Unknown coc.nvim configuration property", allowTrailingCommas: true, allowComments: true };
        this.configurationProperties = {};
        this.excludedConfigurationProperties = {};
        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);
        this.registerOverridePropertyPatternKey();
      }
      registerConfiguration(configuration2, validate = true) {
        this.registerConfigurations([configuration2], validate);
      }
      registerConfigurations(configurations, validate = true) {
        const properties = this.doRegisterConfigurations(configurations, validate);
        contributionRegistry.notifySchemaChanged(resourceLanguageSettingsSchemaId);
        this._onDidSchemaChange.fire();
        this._onDidUpdateConfiguration.fire({ properties });
      }
      deregisterConfigurations(configurations) {
        const properties = this.doDeregisterConfigurations(configurations);
        contributionRegistry.notifySchemaChanged(resourceLanguageSettingsSchemaId);
        this._onDidSchemaChange.fire();
        this._onDidUpdateConfiguration.fire({ properties });
      }
      updateConfigurations({ add, remove: remove2 }) {
        const properties = [];
        properties.push(...this.doDeregisterConfigurations(remove2));
        properties.push(...this.doRegisterConfigurations(add, false));
        contributionRegistry.notifySchemaChanged(resourceLanguageSettingsSchemaId);
        this._onDidSchemaChange.fire();
        this._onDidUpdateConfiguration.fire({ properties: distinct(properties) });
      }
      doRegisterConfigurations(configurations, validate) {
        const properties = [];
        configurations.forEach((configuration2) => {
          properties.push(...this.validateAndRegisterProperties(configuration2, validate, configuration2.extensionInfo));
          this.registerJSONConfiguration(configuration2);
        });
        return properties;
      }
      doDeregisterConfigurations(configurations) {
        const properties = [];
        const deregisterConfiguration = (configuration2) => {
          for (const key in toObject(configuration2.properties)) {
            properties.push(key);
            delete this.configurationProperties[key];
            this.removeFromSchema(key, configuration2.properties[key]);
          }
        };
        for (const configuration2 of configurations) {
          deregisterConfiguration(configuration2);
        }
        return properties;
      }
      validateAndRegisterProperties(configuration2, validate, extensionInfo, scope = 1 /* APPLICATION */) {
        scope = configuration2.scope == null ? scope : configuration2.scope;
        const propertyKeys = [];
        const properties = configuration2.properties;
        for (const key in toObject(properties)) {
          const property = properties[key];
          if (validate && validateProperty(key, property)) {
            delete properties[key];
            continue;
          }
          property.source = extensionInfo;
          property.defaultDefaultValue = properties[key].default;
          this.updatePropertyDefaultValue(key, property);
          property.scope = property.scope == null ? scope : property.scope;
          if (extensionInfo) property.description = (property.description ? `${property.description}
` : "") + `From ${extensionInfo.id}`;
          if (property.hasOwnProperty("included") && !property.included) {
            this.excludedConfigurationProperties[key] = properties[key];
            delete properties[key];
            continue;
          } else {
            this.configurationProperties[key] = properties[key];
          }
          if (!properties[key].deprecationMessage && properties[key].markdownDeprecationMessage) {
            properties[key].deprecationMessage = properties[key].markdownDeprecationMessage;
          }
          propertyKeys.push(key);
        }
        return propertyKeys;
      }
      getConfigurationProperties() {
        return this.configurationProperties;
      }
      getExcludedConfigurationProperties() {
        return this.excludedConfigurationProperties;
      }
      registerJSONConfiguration(configuration2) {
        const register4 = (configuration3) => {
          const properties = configuration3.properties;
          for (const key in toObject(properties)) {
            this.updateSchema(key, properties[key]);
          }
        };
        register4(configuration2);
      }
      updateSchema(key, property) {
        allSettings.properties[key] = property;
        switch (property.scope) {
          case 2 /* WINDOW */:
          case 3 /* RESOURCE */:
            resourceSettings.properties[key] = property;
            break;
          case 4 /* LANGUAGE_OVERRIDABLE */:
            resourceSettings.properties[key] = property;
            this.resourceLanguageSettingsSchema.properties[key] = property;
            break;
        }
      }
      removeFromSchema(key, property) {
        delete allSettings.properties[key];
        switch (property.scope) {
          case 2 /* WINDOW */:
          case 3 /* RESOURCE */:
          case 4 /* LANGUAGE_OVERRIDABLE */:
            delete resourceSettings.properties[key];
            delete this.resourceLanguageSettingsSchema.properties[key];
            break;
        }
      }
      registerOverridePropertyPatternKey() {
        const resourceLanguagePropertiesSchema = {
          type: "object",
          description: "Configure editor settings to be overridden for a language.",
          errorMessage: "This setting does not support per-language configuration.",
          $ref: resourceLanguageSettingsSchemaId
        };
        allSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
        resourceSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;
      }
      updatePropertyDefaultValue(key, property) {
        let defaultValue2 = property.defaultDefaultValue;
        if (typeof defaultValue2 === "undefined" && !EXCLUDE_KEYS.some((k) => key.includes(k))) {
          defaultValue2 = getDefaultValue(property.type);
        }
        property.default = defaultValue2;
        property.defaultValueSource = void 0;
      }
    };
    configurationRegistry = new ConfigurationRegistry();
    Registry.add(Extensions3.Configuration, configurationRegistry);
  }
});

// src/configuration/index.ts
var logger8, userSettingsSchemaId, folderSettingsSchemaId, jsonRegistry, configuration, Configurations;
var init_configuration2 = __esm({
  "src/configuration/index.ts"() {
    "use strict";
    init_esm();
    init_schema();
    init_logger();
    init_util();
    init_array();
    init_constants();
    init_extensionRegistry();
    init_fs();
    init_is();
    init_jsonRegistry();
    init_node();
    init_object();
    init_protocol();
    init_registry();
    init_configuration();
    init_event();
    init_model();
    init_parser2();
    init_registry2();
    init_types();
    init_util2();
    logger8 = createLogger("configurations");
    userSettingsSchemaId = "vscode://schemas/settings/user";
    folderSettingsSchemaId = "vscode://schemas/settings/folder";
    jsonRegistry = Registry.as(Extensions2.JSONContribution);
    configuration = Registry.as(Extensions3.Configuration);
    Configurations = class {
      constructor(userConfigFile2, _proxy, noWatch = false, cwd2 = process.cwd()) {
        this.userConfigFile = userConfigFile2;
        this._proxy = _proxy;
        this.noWatch = noWatch;
        this._watchedFiles = /* @__PURE__ */ new Set();
        this._errors = /* @__PURE__ */ new Map();
        this._onError = new import_node4.Emitter();
        this._onChange = new import_node4.Emitter();
        this.disposables = [];
        this._initialized = false;
        this.cached = [];
        this.onError = this._onError.event;
        this.onDidChange = this._onChange.event;
        let defaultConfiguration = this.loadDefaultConfigurations();
        let userConfiguration = this.parseConfigurationModel(this.userConfigFile);
        this._configuration = new Configuration(defaultConfiguration, userConfiguration);
        this.watchFile(this.userConfigFile, 1 /* User */);
        let filepath = this.folderToConfigfile(cwd2);
        if (filepath) this.addFolderFile(filepath, true);
        this._initialConfiguration = this.getConfiguration(void 0, null);
      }
      /**
       * Contains default, memory and user configuration only
       */
      get initialConfiguration() {
        return this._initialConfiguration;
      }
      get markdownPreference() {
        let preferences = this._initialConfiguration.get("coc.preferences");
        return {
          excludeImages: preferences.excludeImageLinksInMarkdownDocument,
          breaks: preferences.enableGFMBreaksInMarkdownDocument
        };
      }
      get errors() {
        return this._errors;
      }
      get configuration() {
        return this._configuration;
      }
      flushConfigurations() {
        this._initialized = true;
        configuration.registerConfigurations(this.cached);
        this.cached = [];
      }
      updateConfigurations(add, remove2) {
        if (this._initialized) {
          if (!isFalsyOrEmpty(remove2)) {
            configuration.updateConfigurations({ add, remove: remove2 });
          } else {
            configuration.registerConfigurations(add);
          }
        } else {
          this.cached.push(...add);
        }
      }
      loadDefaultConfigurations() {
        let node = { properties: convertProperties(schema_default.properties) };
        configuration.registerConfiguration(node);
        configuration.onDidUpdateConfiguration((e) => {
          if (e.properties.length === 0) return;
          const dict = configuration.getConfigurationProperties();
          const toRemove = [];
          const root = /* @__PURE__ */ Object.create(null);
          const keys2 = [];
          for (let key of e.properties) {
            let def = dict[key];
            if (def) {
              keys2.push(key);
              let val = def.default;
              addToValueTree(root, key, val, (msg) => {
                logger8.error(`Conflict configuration: ${msg}`);
              });
            } else {
              toRemove.push(key);
            }
          }
          const model2 = this._configuration.defaults.merge(new ConfigurationModel(root, keys2));
          toRemove.forEach((key) => {
            model2.removeValue(key);
          });
          if (!this._initialized) {
            this._configuration.updateDefaultConfiguration(model2);
            this._initialConfiguration = this.getConfiguration(void 0, null);
          } else {
            this.changeConfiguration(0 /* Default */, model2, void 0, e.properties);
          }
        }, null, this.disposables);
        let properties = configuration.getConfigurationProperties();
        let config = {};
        let keys = [];
        Object.keys(properties).forEach((key) => {
          let value = properties[key].default;
          keys.push(key);
          addToValueTree(config, key, value, void 0);
        });
        let model = new ConfigurationModel(config, keys);
        return model;
      }
      getDescription(key) {
        let property = allSettings.properties[key];
        return property ? property.description : void 0;
      }
      getJSONSchema(uri) {
        if (uri === userSettingsSchemaId) {
          return {
            properties: allSettings.properties,
            patternProperties: allSettings.patternProperties,
            definitions: Object.assign(getExtensionDefinitions(), schema_default.definitions),
            additionalProperties: false,
            allowTrailingCommas: true,
            allowComments: true
          };
        }
        if (uri === folderSettingsSchemaId) {
          return {
            properties: resourceSettings.properties,
            patternProperties: resourceSettings.patternProperties,
            definitions: Object.assign(getExtensionDefinitions(), schema_default.definitions),
            errorMessage: "Configuration property may not work as folder configuration",
            additionalProperties: false,
            allowTrailingCommas: true,
            allowComments: true
          };
        }
        let schemas = jsonRegistry.getSchemaContributions().schemas;
        if (hasOwnProperty2(schemas, uri)) return schemas[uri];
        return void 0;
      }
      parseConfigurationModel(filepath, filecontents) {
        if (!filepath || !fs.existsSync(filepath)) return new ConfigurationModel();
        let parser2 = new ConfigurationModelParser(filepath);
        let content = filecontents || fs.readFileSync(filepath, "utf8");
        let uri = URI2.file(filepath).toString();
        parser2.parse(content);
        if (!isFalsyOrEmpty(parser2.errors)) {
          this._errors.set(uri, parser2.errors);
          this._onError.fire({ uri, diagnostics: parser2.errors });
        } else {
          this._errors.delete(uri);
          this._onError.fire({ uri, diagnostics: [] });
        }
        return parser2.configurationModel;
      }
      folderToConfigfile(folder) {
        if (sameFile(folder, os.homedir())) return void 0;
        let filepath = path.join(folder, ".vim", CONFIG_FILE_NAME);
        if (sameFile(filepath, this.userConfigFile)) return void 0;
        return filepath;
      }
      // change memory configuration
      updateMemoryConfig(props) {
        let keys = Object.keys(props);
        if (!props || keys.length == 0) return;
        let memoryModel = this._configuration.memory.clone();
        let properties = configuration.getConfigurationProperties();
        keys.forEach((key) => {
          let val = props[key];
          if (val === void 0) {
            memoryModel.removeValue(key);
          } else if (properties[key] != null) {
            memoryModel.setValue(key, val);
          } else if (objectLiteral(val)) {
            for (let k of Object.keys(val)) {
              memoryModel.setValue(`${key}.${k}`, val[k]);
            }
          } else {
            memoryModel.setValue(key, val);
          }
        });
        this.changeConfiguration(4 /* Memory */, memoryModel, void 0, keys);
      }
      /**
       * Add new folder config file.
       */
      addFolderFile(configFilePath, fromCwd = false, resource) {
        let folder = normalizeFilePath(path.resolve(configFilePath, "../.."));
        if (this._configuration.hasFolder(folder) || !fs.existsSync(configFilePath)) return false;
        let configFile;
        try {
          configFile = fs.readFileSync(configFilePath, "utf8");
        } catch (_err) {
          return false;
        }
        this.watchFile(configFilePath, 3 /* WorkspaceFolder */);
        let model = this.parseConfigurationModel(configFilePath, configFile);
        this._configuration.addFolderConfiguration(folder, model, resource);
        logger8.info(`Add folder configuration from ${fromCwd ? "cwd" : "file"}:`, configFilePath);
        return true;
      }
      watchFile(filepath, target) {
        if (!fs.existsSync(filepath) || this._watchedFiles.has(filepath) || this.noWatch) return;
        this._watchedFiles.add(filepath);
        const folder = 3 /* WorkspaceFolder */ ? normalizeFilePath(path.resolve(filepath, "../..")) : void 0;
        let disposable = watchFile(filepath, () => {
          let model = this.parseConfigurationModel(filepath);
          this.changeConfiguration(target, model, folder);
        });
        this.disposables.push(disposable);
      }
      /**
       * Update ConfigurationModel and fire event.
       */
      changeConfiguration(target, model, folder, keys) {
        const listOnly = target === 0 /* Default */ && keys && keys.every((key) => key.startsWith("list.source"));
        let configuration2 = this._configuration;
        let previous = listOnly ? void 0 : configuration2.toData();
        let change;
        if (target === 0 /* Default */) {
          change = configuration2.compareAndUpdateDefaultConfiguration(model, keys);
        } else if (target === 1 /* User */) {
          change = configuration2.compareAndUpdateUserConfiguration(model);
        } else if (target === 2 /* Workspace */) {
          change = configuration2.compareAndUpdateWorkspaceConfiguration(model);
        } else if (target === 3 /* WorkspaceFolder */) {
          change = configuration2.compareAndUpdateFolderConfiguration(folder, model);
        } else {
          change = configuration2.compareAndUpdateMemoryConfiguration(model);
        }
        if (!change || change.keys.length == 0) return;
        if (target !== 3 /* WorkspaceFolder */, target !== 2 /* Workspace */) {
          this._initialConfiguration = this.getConfiguration(void 0, null);
        }
        if (listOnly) return;
        let ev = new ConfigurationChangeEvent(change, previous, configuration2);
        ev.source = target;
        this._onChange.fire(ev);
      }
      getDefaultResource() {
        let root = this._proxy?.root;
        if (!root) return void 0;
        return URI2.file(root).toString();
      }
      /**
       * Get workspace configuration
       */
      getConfiguration(section2, scope) {
        let configuration2 = this._configuration;
        let overrides = scope ? scopeToOverrides(scope) : { resource: scope === null ? void 0 : this.getDefaultResource() };
        const config = Object.freeze(lookUp(configuration2.getValue(void 0, overrides), section2));
        const result = {
          has(key) {
            return typeof lookUp(config, key) !== "undefined";
          },
          get: (key, defaultValue2) => {
            let result2 = lookUp(config, key);
            if (result2 == null) return defaultValue2;
            return result2;
          },
          update: (key, value, updateTarget = false) => {
            const resource = overrides.resource;
            let entry = section2 ? `${section2}.${key}` : key;
            let target;
            if (typeof updateTarget === "boolean") {
              target = updateTarget ? 1 /* User */ : 3 /* WorkspaceFolder */;
            } else {
              target = convertTarget(updateTarget);
            }
            let folder;
            if (target === 3 /* WorkspaceFolder */) {
              folder = this._configuration.resolveFolder(resource) ?? this.resolveWorkspaceFolderForResource(resource);
              if (!folder) {
                console.error(`Unable to locate workspace folder configuration for ${resource}`);
                logger8.error(`Unable to locate workspace folder configuration`, resource, Error().stack);
                return;
              }
            }
            let model = this._configuration.getConfigurationModel(target, folder).clone();
            if (value === void 0) {
              model.removeValue(entry);
            } else {
              model.setValue(entry, value);
            }
            this.changeConfiguration(target, model, folder);
            let fsPath2;
            if (target === 3 /* WorkspaceFolder */) {
              fsPath2 = this.folderToConfigfile(folder);
            } else if (target === 1 /* User */) {
              fsPath2 = this.userConfigFile;
            }
            return fsPath2 ? this._proxy?.modifyConfiguration(fsPath2, entry, value) : Promise.resolve();
          },
          inspect: (key) => {
            key = section2 ? `${section2}.${key}` : key;
            const config2 = this._configuration.inspect(key, overrides);
            return {
              key,
              defaultValue: config2.defaultValue,
              globalValue: config2.userValue,
              workspaceValue: config2.workspaceValue,
              workspaceFolderValue: config2.workspaceFolderValue
            };
          }
        };
        Object.defineProperty(result, "has", {
          enumerable: false
        });
        Object.defineProperty(result, "get", {
          enumerable: false
        });
        Object.defineProperty(result, "update", {
          enumerable: false
        });
        Object.defineProperty(result, "inspect", {
          enumerable: false
        });
        if (typeof config === "object") {
          mixin(result, config, false);
        }
        return deepFreeze(result);
      }
      /**
       * Resolve folder configuration from uri.
       */
      locateFolderConfigution(uri) {
        let folder = this._configuration.resolveFolder(uri);
        if (folder) return true;
        let u = URI2.parse(uri);
        if (u.scheme !== "file") return false;
        let dir = folder = findUp(".vim", u.fsPath);
        if (!dir) return false;
        folder = path.dirname(dir);
        let filepath = this.folderToConfigfile(folder);
        if (filepath) {
          this.addFolderFile(filepath, false, uri);
          return true;
        }
        return false;
      }
      /**
       * Resolve workspace folder config file path.
       */
      resolveWorkspaceFolderForResource(resource) {
        if (this._proxy && typeof this._proxy.getWorkspaceFolder === "function") {
          let uri = this._proxy.getWorkspaceFolder(resource);
          if (!uri) return void 0;
          let fsPath2 = uri.fsPath;
          let configFilePath = this.folderToConfigfile(fsPath2);
          if (configFilePath) {
            if (!fs.existsSync(configFilePath)) {
              fs.mkdirSync(path.dirname(configFilePath), { recursive: true });
              fs.writeFileSync(configFilePath, "{}", "utf8");
            }
            this.addFolderFile(configFilePath, false, resource);
            return fsPath2;
          }
        }
        return void 0;
      }
      /**
       * Reset configurations for test, not trigger configuration change event.
       */
      reset() {
        this._errors.clear();
        let model = new ConfigurationModel();
        this._configuration.updateMemoryConfiguration(model);
        this._initialConfiguration = this.getConfiguration(void 0, null);
      }
      dispose() {
        this._onError.dispose();
        this._onChange.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/configuration/shape.ts
var logger9, ConfigurationProxy;
var init_shape = __esm({
  "src/configuration/shape.ts"() {
    "use strict";
    init_main2();
    init_esm();
    init_logger();
    init_node();
    logger9 = createLogger("configuration-shape");
    ConfigurationProxy = class {
      constructor(resolver2, _test = false) {
        this.resolver = resolver2;
        this._test = _test;
      }
      get root() {
        return this.resolver.root;
      }
      async modifyConfiguration(fsPath2, key, value) {
        if (this._test) return;
        logger9.info(`modify configuration file: ${fsPath2}`, key, value);
        let dir = path.dirname(fsPath2);
        let formattingOptions = { tabSize: 2, insertSpaces: true };
        if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
        let content = fs.readFileSync(fsPath2, { flag: "a+" }).toString("utf8");
        content = content || "{}";
        let edits = modify(content, [key], value, { formattingOptions });
        content = applyEdits(content, edits);
        fs.writeFileSync(fsPath2, content, { encoding: "utf8" });
      }
      getWorkspaceFolder(resource) {
        if (typeof this.resolver.getWorkspaceFolder === "function") {
          let workspaceFolder = this.resolver.getWorkspaceFolder(resource);
          if (workspaceFolder) return URI2.parse(workspaceFolder.uri);
        }
        return void 0;
      }
    };
  }
});

// src/core/autocmds.ts
function toAutocmdOption(item) {
  let { id: id2, option } = item;
  let opt = { group: groupName };
  if (option.buffer) opt.buffer = option.buffer;
  if (option.pattern) opt.pattern = option.pattern;
  if (option.once) opt.once = true;
  if (option.nested) opt.nested = true;
  let method = option.request ? "request" : "notify";
  let args = isFalsyOrEmpty(option.arglist) ? "" : ", " + option.arglist.join(", ");
  let command = `call coc#rpc#${method}('doAutocmd', [${id2}${args}])`;
  opt.command = command;
  return opt;
}
function createCommand(id2, event, autocmd) {
  let args = isFalsyOrEmpty(autocmd.arglist) ? "" : ", " + autocmd.arglist.join(", ");
  let method = autocmd.request ? "request" : "notify";
  let opt = "";
  if (autocmd.once) opt += " ++once";
  if (autocmd.nested) opt += " ++nested";
  return `autocmd ${groupName} ${event}${opt}  call coc#rpc#${method}('doAutocmd', [${id2}${args}])`;
}
var logger10, AutocmdItem, groupName, Autocmds;
var init_autocmds = __esm({
  "src/core/autocmds.ts"() {
    "use strict";
    init_logger();
    init_array();
    init_extensionRegistry();
    init_lodash();
    init_protocol();
    logger10 = createLogger("autocmds");
    AutocmdItem = class {
      constructor(id2, option) {
        this.id = id2;
        this.option = option;
      }
      get extensiionName() {
        if (this._extensiionName) return this._extensiionName;
        this._extensiionName = parseExtensionName(this.option.stack);
        return this._extensiionName;
      }
    };
    groupName = "coc_dynamic_autocmd";
    Autocmds = class {
      constructor() {
        this.autocmds = /* @__PURE__ */ new Map();
        this.id = 0;
      }
      attach(nvim) {
        this.nvim = nvim;
      }
      async doAutocmd(id2, args, timeout2 = 1e3) {
        let autocmd = this.autocmds.get(id2);
        if (autocmd) {
          let option = autocmd.option;
          logger10.trace(`Invoke autocmd from "${autocmd.extensiionName}"`, option);
          try {
            let tokenSource = new import_node4.CancellationTokenSource();
            let promise = Promise.resolve(option.callback.apply(option.thisArg, [...args, tokenSource.token]));
            if (option.request) {
              let timer;
              let tp = new Promise((resolve) => {
                timer = setTimeout(() => {
                  tokenSource.cancel();
                  logger10.error(`Autocmd timeout after ${timeout2}ms`, omit(option, ["callback", "stack"]), autocmd.option.stack);
                  resolve(void 0);
                }, timeout2);
              });
              await Promise.race([tp, promise]);
              clearTimeout(timer);
              tokenSource.dispose();
            } else {
              await promise;
            }
          } catch (e) {
            logger10.error(`Error on autocmd "${option.event}"`, omit(option, ["callback", "stack"]), e);
          }
        }
      }
      registerAutocmd(autocmd) {
        let id2 = ++this.id;
        let item = new AutocmdItem(id2, autocmd);
        this.autocmds.set(id2, item);
        this.createAutocmd(item);
        return import_node4.Disposable.create(() => {
          this.autocmds.delete(id2);
        });
      }
      createAutocmd(item) {
        let { option } = item;
        let event = Array.isArray(option.event) ? option.event.join(",") : option.event;
        if (/\buser\b/i.test(event)) {
          let cmd = createCommand(item.id, event, option);
          this.nvim.command(cmd, true);
        } else {
          let opt = toAutocmdOption(item);
          this.nvim.createAutocmd(
            Array.isArray(item.option.event) ? item.option.event : item.option.event.split(","),
            opt,
            true
          );
        }
      }
      removeExtensionAutocmds(extensiionName) {
        let { nvim, autocmds } = this;
        nvim.pauseNotification();
        nvim.command(`autocmd! ${groupName}`, true);
        let items = autocmds.values();
        for (const item of items) {
          if (item.extensiionName === extensiionName) {
            autocmds.delete(item.id);
            continue;
          }
          this.createAutocmd(item);
        }
        nvim.resumeNotification(false, true);
      }
      dispose() {
        this.autocmds.clear();
      }
    };
  }
});

// src/core/contentProvider.ts
function getAutocmdCommand(scheme) {
  let rhs = `call coc#rpc#request('CocAutocmd', ['BufReadCmd','${scheme}', expand('<afile>')]) | filetype detect`;
  return `autocmd! coc_dynamic_content BufReadCmd,FileReadCmd,SourceCmd ${scheme}:/* ${rhs}`;
}
var ContentProvider;
var init_contentProvider = __esm({
  "src/core/contentProvider.ts"() {
    "use strict";
    init_esm();
    init_events();
    init_util();
    init_protocol();
    init_string();
    ContentProvider = class {
      constructor(documents) {
        this.documents = documents;
        this.disposables = [];
        this.providers = /* @__PURE__ */ new Map();
        this._onDidProviderChange = new import_node4.Emitter();
        this.onDidProviderChange = this._onDidProviderChange.event;
      }
      attach(nvim) {
        this.nvim = nvim;
        events_default.on("BufReadCmd", this.onBufReadCmd, this, this.disposables);
      }
      get schemes() {
        return Array.from(this.providers.keys());
      }
      async onBufReadCmd(scheme, uri) {
        let provider = this.providers.get(scheme);
        if (!provider) return;
        let tokenSource = new import_node4.CancellationTokenSource();
        let content = await Promise.resolve(provider.provideTextDocumentContent(URI2.parse(uri), tokenSource.token));
        let buf = await this.nvim.buffer;
        await buf.setLines(toText(content).split(/\r?\n/), {
          start: 0,
          end: -1,
          strictIndexing: false
        });
        process.nextTick(() => {
          void events_default.fire("BufCreate", [buf.id]);
        });
      }
      resetAutocmds() {
        let { nvim, schemes } = this;
        nvim.pauseNotification();
        nvim.command(`autocmd! coc_dynamic_content`, true);
        for (let scheme of schemes) {
          nvim.command(getAutocmdCommand(scheme), true);
        }
        nvim.resumeNotification(false, true);
      }
      registerTextDocumentContentProvider(scheme, provider) {
        this.providers.set(scheme, provider);
        this._onDidProviderChange.fire();
        let disposables = [];
        if (provider.onDidChange) {
          provider.onDidChange(async (uri) => {
            let doc = this.documents.getDocument(uri.toString());
            if (!doc) return;
            let tokenSource = new import_node4.CancellationTokenSource();
            let content = await Promise.resolve(provider.provideTextDocumentContent(uri, tokenSource.token));
            await doc.buffer.setLines(content.split(/\r?\n/), {
              start: 0,
              end: -1,
              strictIndexing: false
            });
          }, null, disposables);
        }
        this.nvim.command(getAutocmdCommand(scheme), true);
        return import_node4.Disposable.create(() => {
          this.providers.delete(scheme);
          disposeAll(disposables);
          this.resetAutocmds();
          this._onDidProviderChange.fire();
        });
      }
      dispose() {
        disposeAll(this.disposables);
        this._onDidProviderChange.dispose();
        this.providers.clear();
      }
    };
  }
});

// src/util/position.ts
function rangeInRange(r, range) {
  return positionInRange(r.start, range) === 0 && positionInRange(r.end, range) === 0;
}
function equalsRange(r, range) {
  if (!samePosition(r.start, range.start)) return false;
  return samePosition(r.end, range.end);
}
function samePosition(one, two) {
  return one.line === two.line && one.character === two.character;
}
function adjacentPosition(pos, range) {
  return samePosition(pos, range.start) || samePosition(pos, range.end);
}
function compareRangesUsingStarts(a, b) {
  const aStartLineNumber = a.start.line | 0;
  const bStartLineNumber = b.start.line | 0;
  if (aStartLineNumber === bStartLineNumber) {
    const aStartColumn = a.start.character | 0;
    const bStartColumn = b.start.character | 0;
    if (aStartColumn === bStartColumn) {
      const aEndLineNumber = a.end.line | 0;
      const bEndLineNumber = b.end.line | 0;
      if (aEndLineNumber === bEndLineNumber) {
        const aEndColumn = a.end.character | 0;
        const bEndColumn = b.end.character | 0;
        return aEndColumn - bEndColumn;
      }
      return aEndLineNumber - bEndLineNumber;
    }
    return aStartColumn - bStartColumn;
  }
  return aStartLineNumber - bStartLineNumber;
}
function toValidRange(range, max) {
  let { start, end } = range;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    let m = start;
    start = end;
    end = m;
  }
  start = Position.create(Math.max(0, start.line), Math.max(0, start.character));
  let endCharacter = Math.max(0, end.character);
  if (typeof max === "number" && endCharacter > max) endCharacter = max;
  end = Position.create(Math.max(0, end.line), endCharacter);
  return { start, end };
}
function rangeAdjacent(r, range) {
  if (comparePosition(r.end, range.start) == 0) {
    return true;
  }
  if (comparePosition(range.end, r.start) == 0) {
    return true;
  }
  return false;
}
function rangeOverlap(r, range) {
  let { start, end } = r;
  if (comparePosition(end, range.start) <= 0) {
    return false;
  }
  if (comparePosition(start, range.end) >= 0) {
    return false;
  }
  return true;
}
function rangeIntersect(r, range) {
  if (positionInRange(r.start, range) == 0) {
    return true;
  }
  if (positionInRange(r.end, range) == 0) {
    return true;
  }
  if (rangeInRange(range, r)) {
    return true;
  }
  return false;
}
function adjustRangePosition(range, position) {
  let { line, character } = position;
  let { start, end } = range;
  let endCharacter = end.line == start.line ? end.character + character : end.character;
  return Range.create(start.line + line, character + start.character, end.line + line, endCharacter);
}
function lineInRange(line, range) {
  let { start, end } = range;
  return line >= start.line && line <= end.line;
}
function emptyRange(range) {
  let { start, end } = range;
  return start.line == end.line && start.character == end.character;
}
function positionInRange(position, range) {
  let { start, end } = range;
  if (comparePosition(position, start) < 0) return -1;
  if (comparePosition(position, end) > 0) return 1;
  return 0;
}
function comparePosition(position, other) {
  if (position.line > other.line) return 1;
  if (other.line == position.line && position.character > other.character) return 1;
  if (other.line == position.line && position.character == other.character) return 0;
  return -1;
}
function getEnd(start, content) {
  const lines = content.split(/\r?\n/);
  const len = lines.length;
  const lastLine = lines[len - 1];
  const end = len == 1 ? start.character + content.length : lastLine.length;
  return Position.create(start.line + len - 1, end);
}
var init_position = __esm({
  "src/util/position.ts"() {
    "use strict";
    init_main();
  }
});

// src/util/diff.ts
function diffLines(oldLines, newLines, startLine) {
  let endOffset = 0;
  let startOffset = 0;
  let parts = oldLines.slice(startLine + 1);
  for (let i = 0; i < Math.min(parts.length, newLines.length); i++) {
    if (parts[parts.length - 1 - i] == newLines[newLines.length - 1 - i]) {
      endOffset = endOffset + 1;
    } else {
      break;
    }
  }
  for (let i = 0; i <= Math.min(startLine, newLines.length - 1 - endOffset); i++) {
    if (oldLines[i] == newLines[i]) {
      startOffset = startOffset + 1;
    } else {
      break;
    }
  }
  let replacement = newLines.slice(startOffset, newLines.length - endOffset);
  let end = oldLines.length - endOffset;
  if (end > startOffset && replacement.length) {
    let offset = 0;
    for (let i = 0; i < Math.min(replacement.length, end - startOffset); i++) {
      if (replacement[i] == oldLines[startOffset + i]) {
        offset = offset + 1;
      } else {
        break;
      }
    }
    if (offset) {
      return {
        start: startOffset + offset,
        end,
        replacement: replacement.slice(offset)
      };
    }
  }
  return {
    start: startOffset,
    end,
    replacement
  };
}
function patchLine(from, to, fill = " ") {
  if (from == to) return to;
  let idx = to.indexOf(from);
  if (idx !== -1) return fill.repeat(byteLength(to.substring(0, idx))) + from;
  let result = fastDiff(from, to);
  let str = "";
  for (let item of result) {
    if (item[0] == fastDiff.DELETE) {
      return to;
    } else if (item[0] == fastDiff.INSERT) {
      str = str + fill.repeat(byteLength(item[1]));
    } else {
      str = str + item[1];
    }
  }
  return str;
}
function getTextEdit(oldLines, newLines, cursor, insertMode) {
  let ol = oldLines.length;
  let nl = newLines.length;
  let n;
  if (cursor) {
    n = nl > ol && insertMode && cursor.line > 0 ? cursor.line - 1 : cursor.line;
  } else {
    n = Math.min(ol, nl);
  }
  let used = 0;
  for (let i = 0; i < n; i++) {
    if (newLines[i] === oldLines[i]) {
      used += 1;
    } else {
      break;
    }
  }
  if (ol == nl && used == ol) return void 0;
  let delta = nl - ol;
  let r = Math.min(ol - used, nl - used);
  let e = 0;
  for (let i = 0; i < r; i++) {
    if (newLines[nl - i - 1] === oldLines[ol - i - 1]) {
      e += 1;
    } else {
      break;
    }
  }
  let inserted = e == 0 ? newLines.slice(used) : newLines.slice(used, -e);
  if (delta == 0 && cursor && inserted.length == 1) {
    let newLine = newLines[used];
    let oldLine = oldLines[used];
    let nl2 = newLine.length;
    let ol2 = oldLine.length;
    if (nl2 === 0) return TextEdit.del(Range.create(used, 0, used, ol2));
    if (ol2 === 0) return TextEdit.insert(Position.create(used, 0), newLine);
    let character = Math.min(cursor.character, nl2);
    if (!insertMode && nl2 >= ol2 && character !== nl2) {
      character += 1;
    }
    let r2 = 0;
    for (let i = 0; i < nl2 - character; i++) {
      let idx = ol2 - 1 - i;
      if (idx === -1) break;
      if (newLine[nl2 - 1 - i] === oldLine[idx]) {
        r2 += 1;
      } else {
        break;
      }
    }
    let l = 0;
    for (let i = 0; i < Math.min(ol2 - r2, nl2 - r2); i++) {
      if (newLine[i] === oldLine[i]) {
        l += 1;
      } else {
        break;
      }
    }
    let newText = r2 === 0 ? newLine.slice(l) : newLine.slice(l, -r2);
    return TextEdit.replace(Range.create(used, l, used, ol2 - r2), newText);
  }
  let text = inserted.length > 0 ? inserted.join("\n") + "\n" : "";
  if (text.length === 0 && used === ol - e) return void 0;
  let original = oldLines.slice(used, ol - e).join("\n") + "\n";
  let edit2 = TextEdit.replace(Range.create(used, 0, ol - e, 0), text);
  return reduceReplceEdit(edit2, original, cursor);
}
function getCommonSuffixLen(a, b, max) {
  if (max === 0) return 0;
  let al = a.length;
  let bl = b.length;
  let n = 0;
  for (let i = 0; i < max; i++) {
    if (a[al - 1 - i] === b[bl - 1 - i]) {
      n++;
    } else {
      break;
    }
  }
  return n;
}
function getCommonPrefixLen(a, b, max) {
  if (max === 0) return 0;
  let n = 0;
  for (let i = 0; i < max; i++) {
    if (a[i] === b[i]) {
      n++;
    } else {
      break;
    }
  }
  return n;
}
function reduceReplceEdit(edit2, original, cursor) {
  let { newText, range } = edit2;
  if (emptyRange(range) || newText === "") return edit2;
  let endOffset;
  if (cursor) {
    let newEnd = getEnd(range.start, newText);
    if (positionInRange(cursor, Range.create(range.start, newEnd)) === 0) {
      endOffset = 0;
      let lc = newEnd.line - cursor.line + 1;
      let lines = newText.split("\n");
      let len = lines.length;
      for (let i = 0; i < lc; i++) {
        let idx = len - i - 1;
        if (i == lc - 1) {
          let s2 = idx === 0 ? range.start.character : 0;
          endOffset += lines[idx].slice(cursor.character - s2).length;
        } else {
          endOffset += lines[idx].length + 1;
        }
      }
    }
  }
  let sl;
  let pl;
  let min = Math.min(original.length, newText.length);
  if (endOffset) {
    sl = getCommonSuffixLen(original, newText, endOffset);
    pl = getCommonPrefixLen(original, newText, min - sl);
  } else {
    pl = getCommonPrefixLen(original, newText, min);
    sl = getCommonSuffixLen(original, newText, min - pl);
  }
  let s = pl === 0 ? range.start : getEnd(range.start, original.slice(0, pl));
  let e = sl === 0 ? range.end : getEnd(range.start, original.slice(0, -sl));
  let text = newText.slice(pl, sl === 0 ? void 0 : -sl);
  return TextEdit.replace(Range.create(s, e), text);
}
var init_diff = __esm({
  "src/util/diff.ts"() {
    "use strict";
    init_main();
    init_node();
    init_string();
    init_position();
  }
});

// src/util/textedit.ts
function getStartLine(edit2) {
  let { start, end } = edit2.range;
  if (edit2.newText.endsWith("\n") && start.line == end.line && start.character == 0 && end.character == 0) {
    return start.line - 1;
  }
  return start.line;
}
function lineCountChange(edit2) {
  let { newText } = edit2;
  let range = getWellformedRange2(edit2.range);
  let n = range.end.line - range.start.line;
  return newText.split(/\r?\n/).length - n - 1;
}
function getWellformedRange2(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function mergeSort2(data, compare2) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort2(left, compare2);
  mergeSort2(right, compare2);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    let ret = compare2(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function mergeSortEdits(edits) {
  return mergeSort2(edits, (a, b) => {
    let diff = a.range.start.line - b.range.start.line;
    if (diff === 0) {
      return a.range.start.character - b.range.start.character;
    }
    return diff;
  });
}
function emptyWorkspaceEdit(edit2) {
  let { changes, documentChanges } = edit2;
  if (documentChanges && documentChanges.length) return false;
  if (changes && Object.keys(changes).length) return false;
  return true;
}
function getRangesFromEdit(uri, edit2) {
  let { changes, documentChanges } = edit2;
  if (changes) {
    let edits = changes[uri];
    return edits ? edits.map((e) => e.range) : void 0;
  } else if (Array.isArray(documentChanges)) {
    for (let c of documentChanges) {
      if (TextDocumentEdit.is(c) && c.textDocument.uri == uri) {
        return c.edits.map((e) => e.range);
      }
    }
  }
  return void 0;
}
function getConfirmAnnotations(changes, changeAnnotations) {
  let keys = [];
  const add = (key) => {
    if (key && !keys.includes(key) && changeAnnotations[key]?.needsConfirmation) keys.push(key);
  };
  for (let change of changes) {
    if (TextDocumentEdit.is(change)) {
      change.edits.forEach((edit2) => {
        add(edit2["annotationId"]);
      });
    } else {
      add(change.annotationId);
    }
  }
  return keys;
}
function isDeniedEdit(edit2, denied) {
  if (AnnotatedTextEdit.is(edit2) && denied.includes(edit2.annotationId)) return true;
  return false;
}
function createFilteredChanges(documentChanges, denied) {
  let changes = [];
  documentChanges.forEach((change) => {
    if (TextDocumentEdit.is(change)) {
      let edits = change.edits.filter((edit2) => {
        return !isDeniedEdit(edit2, denied);
      });
      if (edits.length > 0) {
        changes.push({ textDocument: change.textDocument, edits });
      }
    } else if (!denied.includes(change.annotationId)) {
      changes.push(change);
    }
  });
  return changes;
}
function getAnnotationKey(change) {
  let key;
  if (TextDocumentEdit.is(change)) {
    if (AnnotatedTextEdit.is(change.edits[0])) {
      key = change.edits[0].annotationId;
    }
  } else {
    key = change.annotationId;
  }
  return key;
}
function toDocumentChanges(edit2) {
  if (edit2.documentChanges) return edit2.documentChanges;
  let changes = [];
  for (let [uri, edits] of Object.entries(toObject(edit2.changes))) {
    changes.push({ textDocument: { uri, version: null }, edits });
  }
  return changes;
}
function filterSortEdits(textDocument, edits) {
  let res = [];
  let end = textDocument.end;
  let checkEnd = end.line > 0 && end.character == 0;
  let prevDelete;
  for (let i = 0; i < edits.length; i++) {
    let edit2 = edits[i];
    let { newText, range } = edit2;
    let max = (textDocument.lines[range.end.line] ?? "").length;
    range = toValidRange(edit2.range, max);
    if (prevDelete) {
      if (samePosition(prevDelete, range.start) && emptyRange(range) && newText.length > 0) {
        let last = res[res.length - 1];
        last.newText = newText;
        prevDelete = void 0;
        continue;
      }
      prevDelete = void 0;
    }
    if (newText.includes("\r")) newText = newText.replace(/\r\n/g, "\n");
    let d = comparePosition(range.end, end);
    if (d > 0) range.end = { line: end.line, character: end.character };
    if (textDocument.getText(range) !== newText) {
      if (d === 0 && checkEnd && !emptyRange(range) && newText.endsWith("\n")) {
        newText = newText.slice(0, -1);
        let text = textDocument.lines[end.line - 1];
        range.end = Position.create(end.line - 1, text.length);
      } else if (newText.length == 0) {
        prevDelete = range.start;
      }
      res.push({ range, newText });
    }
  }
  return mergeSortEdits(res);
}
function applyEdits2(document2, edits) {
  if (isFalsyOrEmpty(edits)) return void 0;
  if (edits.length == 1) {
    let { start, end } = edits[0].range;
    let { lines } = document2;
    let sl = lines[start.line] ?? "";
    let el = lines[end.line] ?? "";
    let content = sl.substring(0, start.character) + edits[0].newText + el.substring(end.character);
    if (end.line >= lines.length && document2.eol) {
      if (content == "") return [...lines.slice(0, start.line)];
      if (content.endsWith("\n")) content = content.slice(0, -1);
      return [...lines.slice(0, start.line), ...content.split("\n")];
    }
    return [...lines.slice(0, start.line), ...content.split("\n"), ...lines.slice(end.line + 1)];
  }
  let text = document2.getText();
  let lastModifiedOffset = 0;
  const spans = [];
  for (const e of edits) {
    let startOffset = document2.offsetAt(e.range.start);
    if (startOffset < lastModifiedOffset) {
      throw new Error("Overlapping edit");
    } else if (startOffset > lastModifiedOffset) {
      spans.push(text.substring(lastModifiedOffset, startOffset));
    }
    if (e.newText.length) {
      spans.push(e.newText);
    }
    lastModifiedOffset = document2.offsetAt(e.range.end);
  }
  spans.push(text.substring(lastModifiedOffset));
  let result = spans.join("");
  if (result === text) return void 0;
  return contentToLines(result, document2.eol);
}
function toTextChanges(lines, edits) {
  return edits.map((o) => {
    let { start, end } = o.range;
    let sl = toText(lines[start.line]);
    let sc = byteIndex(sl, start.character);
    let el = end.line == start.line ? sl : toText(lines[end.line]);
    let ec = byteIndex(el, end.character);
    let { newText } = o;
    return [newText.length > 0 ? newText.split("\n") : [], start.line, sc, end.line, ec];
  });
}
function getChangedPosition(start, edit2) {
  let { range, newText } = edit2;
  if (comparePosition(range.end, start) <= 0) {
    let lines = newText.split("\n");
    let lineCount = lines.length - (range.end.line - range.start.line) - 1;
    let character = start.character;
    if (range.end.line == start.line) {
      let last = lines[lines.length - 1].length;
      if (lines.length > 1) {
        character = last + character - range.end.character;
      } else {
        character = range.start.character + last + character - range.end.character;
      }
    }
    return { line: lineCount, character: character - start.character };
  }
  return { line: 0, character: 0 };
}
function getPosition(start, edit2) {
  let { line, character } = start;
  let { range, newText } = edit2;
  let { end } = range;
  let lines = newText.split("\n");
  let lineCount = lines.length - (end.line - range.start.line) - 1;
  let c = range.end.line - start.line;
  if (c > 0) return { line, character };
  if (c < 0) return { line: line + lineCount, character };
  if (lines.length > 1) {
    let last = lines[lines.length - 1].length;
    return { line: line + lineCount, character: last + character - end.character };
  }
  let d = range.start.character - range.end.character;
  return { line: line + lineCount, character: d + newText.length + character };
}
function getPositionFromEdits(start, edits) {
  let position = Position.create(start.line, start.character);
  let before = false;
  for (let i = edits.length - 1; i >= 0; i--) {
    let edit2 = edits[i];
    if (before) {
      position.line += lineCountChange(edit2);
      continue;
    }
    let d = comparePosition(edit2.range.end, position);
    if (d > 0) continue;
    if (edit2.range.end.line == position.line) {
      position = getPosition(position, edit2);
    } else {
      before = true;
      position.line += lineCountChange(edit2);
    }
  }
  return position;
}
function getChangedLineCount(start, edits) {
  let total = 0;
  for (let edit2 of edits) {
    let r = getWellformedRange2(edit2.range);
    if (comparePosition(r.end, start) <= 0) {
      total += lineCountChange(edit2);
    }
  }
  return total;
}
function mergeTextEdits(edits, oldLines, newLines) {
  let start = edits[0].range.start;
  let end = edits[edits.length - 1].range.end;
  let lr = oldLines.length - end.line;
  let cr = (oldLines[end.line] ?? "").length - end.character;
  let line = newLines.length - lr;
  let character = (newLines[line] ?? "").length - cr;
  let newText = getText(start, Position.create(line, character), newLines);
  return TextEdit.replace(Range.create(start, end), newText);
}
function getText(start, end, lines) {
  if (start.line === end.line) {
    return toText(lines[start.line]).slice(start.character, end.character);
  }
  let spans = [];
  for (let i = start.line; i <= end.line; i++) {
    let s = lines[i] ?? "";
    if (i === start.line) {
      spans.push(s.slice(start.character));
    } else if (i === end.line) {
      spans.push(s.slice(0, end.character));
    } else {
      spans.push(s);
    }
  }
  return spans.join("\n");
}
var init_textedit = __esm({
  "src/util/textedit.ts"() {
    "use strict";
    init_main();
    init_array();
    init_object();
    init_position();
    init_string();
  }
});

// src/model/chars.ts
function getCharCode(str) {
  if (/^\d+$/.test(str)) return parseInt(str, 10);
  if (str.length > 0) return str.charCodeAt(0);
  return void 0;
}
function sameScope(a, b) {
  if (a < boundary) return b < boundary;
  return b >= boundary;
}
function detectLanguage(code) {
  if (code >= 19968 && code <= 40959) return "cn";
  if (code >= 12352 && code <= 12447 || code >= 12448 && code <= 12543) return "ja";
  if (code >= 44032 && code <= 55215) return "ko";
  return "";
}
function* parseSegments(text, segmenterLocales) {
  if (Intl === void 0 || typeof Intl["Segmenter"] !== "function") {
    yield text;
    return;
  }
  let res = [];
  let items = new Intl["Segmenter"](segmenterLocales === "" ? void 0 : segmenterLocales, { granularity: "word" }).segment(text);
  for (let item of items) {
    if (item.isWordLike) {
      yield item.segment;
    }
  }
  return res;
}
function splitKeywordOption(iskeyword) {
  let res = [];
  let i = 0;
  let s = 0;
  let len = iskeyword.length;
  for (; i < len; i++) {
    let c = iskeyword[i];
    if (i + 1 == len && s != len) {
      res.push(iskeyword.slice(s, len));
      continue;
    }
    if (c == ",") {
      let d = i - s;
      if (d == 0) continue;
      if (d == 1) {
        let p = iskeyword[i - 1];
        if (p == "^" || p == ",") {
          res.push(p == "," ? "," : "^,");
          s = i + 1;
          if (p == "^" && iskeyword[i + 1] == ",") {
            i++;
            s++;
          }
          continue;
        }
      }
      res.push(iskeyword.slice(s, i));
      s = i + 1;
    }
  }
  return res;
}
var WORD_RANGES, MAX_CODE_UNIT, boundary, IntegerRanges, Chars;
var init_chars = __esm({
  "src/model/chars.ts"() {
    "use strict";
    init_main();
    init_util();
    init_array();
    init_object();
    init_string();
    WORD_RANGES = [[257, 893], [895, 902], [904, 1369], [1376, 1416], [1418, 1469], [1471, 1471], [1473, 1474], [1476, 1522], [1525, 1547], [1549, 1562], [1564, 1566], [1568, 1641], [1646, 1747], [1749, 1791], [1806, 2403], [2406, 2415], [2417, 3571], [3573, 3662], [3664, 3673], [3676, 3843], [3859, 3897], [3902, 3972], [3974, 4169], [4176, 4346], [4348, 4960], [4969, 5740], [5743, 5759], [5761, 5786], [5789, 5866], [5870, 5940], [5943, 6099], [6109, 6143], [6155, 8191], [10240, 10495], [10649, 10711], [10716, 10747], [10750, 11775], [11904, 12287], [12321, 12335], [12337, 12348], [12350, 64829], [64832, 65071], [65132, 65279], [65296, 65305], [65313, 65338], [65345, 65370], [65382, 65535]];
    MAX_CODE_UNIT = 65535;
    boundary = 19968;
    IntegerRanges = class _IntegerRanges {
      /**
       * Sorted ranges without overlap
       */
      constructor(ranges = [], wordChars = false) {
        this.ranges = ranges;
        this.wordChars = wordChars;
      }
      clone() {
        return new _IntegerRanges(this.ranges.slice(), this.wordChars);
      }
      /**
       * Add new range
       */
      add(start, end) {
        let index = 0;
        let removeCount = 0;
        if (end != null && end < start) {
          let t = end;
          end = start;
          start = t;
        }
        end = end == null ? start : end;
        for (let r of this.ranges) {
          let [s, e] = r;
          if (e < start) {
            index++;
            continue;
          }
          if (s > end) break;
          removeCount++;
          if (s < start) start = s;
          if (e > end) {
            end = e;
            break;
          }
        }
        this.ranges.splice(index, removeCount, [start, end]);
      }
      exclude(start, end) {
        if (end != null && end < start) {
          let t = end;
          end = start;
          start = t;
        }
        end = end == null ? start : end;
        let index = 0;
        let removeCount = 0;
        let created = [];
        for (let r of this.ranges) {
          let [s, e] = r;
          if (e < start) {
            index++;
            continue;
          }
          if (s > end) break;
          removeCount++;
          if (s < start) {
            created.push([s, start - 1]);
          }
          if (e > end) {
            created.push([end + 1, e]);
            break;
          }
        }
        if (removeCount == 0 && created.length == 0) return;
        this.ranges.splice(index, removeCount, ...created);
      }
      flatten() {
        return this.ranges.reduce((p, c) => p.concat(c), []);
      }
      includes(n) {
        if (n > 256 && this.wordChars) return intable(n, WORD_RANGES);
        return intable(n, this.ranges);
      }
      static fromKeywordOption(iskeyword) {
        let range = new _IntegerRanges();
        for (let part of splitKeywordOption(iskeyword)) {
          let exclude = part.length > 1 && part.startsWith("^");
          let method = exclude ? "exclude" : "add";
          if (exclude) part = part.slice(1);
          if (part === "@" && !exclude) {
            range.wordChars = true;
            range[method](65, 90);
            range[method](97, 122);
            range[method](192, 255);
          } else if (part == "@-@") {
            range[method]("@".charCodeAt(0));
          } else if (part.length == 1 || /^\d+$/.test(part)) {
            range[method](getCharCode(part));
          } else if (part.includes("-")) {
            let items = part.split("-", 2);
            let start = getCharCode(items[0]);
            let end = getCharCode(items[1]);
            if (start === void 0 || end === void 0) continue;
            range[method](start, end);
          }
        }
        return range;
      }
    };
    Chars = class _Chars {
      constructor(keywordOption) {
        this.ranges = IntegerRanges.fromKeywordOption(keywordOption);
      }
      addKeyword(ch) {
        this.ranges.add(ch.codePointAt(0));
      }
      clone() {
        let chars = new _Chars("");
        chars.ranges = this.ranges.clone();
        return chars;
      }
      isKeywordCode(code) {
        if (code === 32 || code > MAX_CODE_UNIT) return false;
        if (isHighSurrogate(code)) return false;
        return this.ranges.includes(code);
      }
      isKeywordChar(ch) {
        let code = ch.charCodeAt(0);
        return this.isKeywordCode(code);
      }
      isKeyword(word) {
        for (let i = 0, l = word.length; i < l; i++) {
          if (!this.isKeywordChar(word[i])) return false;
        }
        return true;
      }
      *iterateWords(text) {
        let start = -1;
        let prevCode;
        for (let i = 0, l = text.length; i < l; i++) {
          let code = text.charCodeAt(i);
          if (this.isKeywordCode(code)) {
            if (start == -1) {
              start = i;
            } else if (prevCode !== void 0 && !sameScope(prevCode, code)) {
              yield [start, i];
              start = i;
            }
          } else {
            if (start != -1) {
              yield [start, i];
              start = -1;
            }
          }
          if (i === l - 1 && start != -1) {
            yield [start, i + 1];
          }
          prevCode = code;
        }
      }
      matchLine(line, segmenterLocales = void 0, min = 2, max = 1024) {
        let res = /* @__PURE__ */ new Set();
        let l = line.length;
        if (l > max) {
          line = line.slice(0, max);
          l = max;
        }
        for (let [start, end] of this.iterateWords(line)) {
          if (end - start < min) continue;
          let word = line.slice(start, end);
          let code = word.charCodeAt(0);
          if (segmenterLocales != null && code > 255) {
            if (segmenterLocales == "") {
              segmenterLocales = detectLanguage(code);
            }
            for (let text of parseSegments(word, segmenterLocales)) {
              res.add(text);
            }
          } else {
            res.add(word);
          }
        }
        return Array.from(res);
      }
      async computeWordRanges(lines, range, token) {
        let s = range.start.line;
        let e = range.end.line;
        let res = {};
        let ts = Date.now();
        for (let i = s; i <= e; i++) {
          let text = lines[i];
          if (text === void 0) break;
          let sc = i === s ? range.start.character : 0;
          if (i === s) text = text.slice(sc);
          if (i === e) text = text.slice(0, range.end.character - sc);
          if (Date.now() - ts > 15) {
            if (token && token.isCancellationRequested) break;
            await waitImmediate();
            ts = Date.now();
          }
          for (let [start, end] of this.iterateWords(text)) {
            let word = text.slice(start, end);
            let arr = hasOwnProperty2(res, word) ? res[word] : [];
            arr.push(Range.create(i, start + sc, i, end + sc));
            res[word] = arr;
          }
        }
        return res;
      }
    };
  }
});

// src/model/textline.ts
var TextLine;
var init_textline = __esm({
  "src/model/textline.ts"() {
    "use strict";
    init_main();
    TextLine = class {
      constructor(line, text, isLastLine) {
        this._line = line;
        this._text = text;
        this._isLastLine = isLastLine;
      }
      /**
       * The zero-based line number.
       */
      get lineNumber() {
        return this._line;
      }
      /**
       * The text of this line without the line separator characters.
       */
      get text() {
        return this._text;
      }
      /**
       * The range this line covers without the line separator characters.
       */
      get range() {
        return Range.create(this._line, 0, this._line, this._text.length);
      }
      /**
       * The range this line covers with the line separator characters.
       */
      get rangeIncludingLineBreak() {
        return this._isLastLine ? this.range : Range.create(this._line, 0, this._line + 1, 0);
      }
      /**
       * The offset of the first character which is not a whitespace character as defined
       * by `/\s/`. **Note** that if a line is all whitespace the length of the line is returned.
       */
      get firstNonWhitespaceCharacterIndex() {
        return /^(\s*)/.exec(this._text)[1].length;
      }
      /**
       * Whether this line is whitespace only, shorthand
       * for {@link TextLine.firstNonWhitespaceCharacterIndex} === {@link TextLine.text TextLine.text.length}.
       */
      get isEmptyOrWhitespace() {
        return this.firstNonWhitespaceCharacterIndex === this._text.length;
      }
    };
  }
});

// src/model/textdocument.ts
function computeLinesOffsets(lines, eol) {
  const result = [];
  let textOffset = 0;
  for (let line of lines) {
    result.push(textOffset);
    textOffset += line.length + 1;
  }
  if (eol) result.push(textOffset);
  return result;
}
var LinesTextDocument;
var init_textdocument = __esm({
  "src/model/textdocument.ts"() {
    "use strict";
    init_main();
    init_string();
    init_textline();
    LinesTextDocument = class {
      constructor(uri, languageId, version2, lines, bufnr, eol) {
        this.uri = uri;
        this.languageId = languageId;
        this.version = version2;
        this.lines = lines;
        this.bufnr = bufnr;
        this.eol = eol;
      }
      get content() {
        if (!this._content) {
          this._content = this.lines.join("\n") + (this.eol ? "\n" : "");
        }
        return this._content;
      }
      get length() {
        if (!this._content) {
          let n = this.lines.reduce((p, c) => {
            return p + c.length + 1;
          }, 0);
          return this.eol ? n : n - 1;
        }
        return this._content.length;
      }
      get end() {
        let line = this.lineCount - 1;
        if (this.eol) return Position.create(line, 0);
        return Position.create(line, this.lines[line].length);
      }
      get lineCount() {
        return this.lines.length + (this.eol ? 1 : 0);
      }
      intersectWith(range) {
        let start = Position.create(0, 0);
        if (start.line < range.start.line) {
          start = range.start;
        } else if (range.start.line === start.line) {
          start = Position.create(start.line, Math.max(start.character, range.start.character));
        }
        let end = this.end;
        if (range.end.line < end.line) {
          end = range.end;
        } else if (range.end.line === end.line) {
          end = Position.create(end.line, Math.min(end.character, range.end.character));
        }
        return Range.create(start, end);
      }
      getText(range) {
        if (range) {
          let { start, end } = range;
          if (start.line === end.line) {
            if (start.character === end.character) return "";
            let line = toText(this.lines[start.line]);
            return line.substring(start.character, end.character);
          }
          return this.content.substring(this.offsetAt(range.start), this.offsetAt(range.end));
        }
        return this.content;
      }
      lineAt(lineOrPos) {
        const line = Position.is(lineOrPos) ? lineOrPos.line : lineOrPos;
        if (typeof line !== "number" || line < 0 || line >= this.lineCount || Math.floor(line) !== line) {
          throw new Error("Illegal value for `line`");
        }
        return new TextLine(line, this.lines[line] ?? "", line === this.lineCount - 1);
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this.content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0;
        let high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          let mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        let line = low - 1;
        return { line, character: offset - lineOffsets[line] };
      }
      offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this.content.length;
        } else if (position.line < 0) {
          return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this.content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLinesOffsets(this.lines, this.eol);
        }
        return this._lineOffsets;
      }
    };
  }
});

// src/model/document.ts
function fireDetach(bufnr) {
  void events_default.fire("BufDetach", [bufnr]);
}
function fireLinesChanged(bufnr) {
  void events_default.fire("LinesChanged", [bufnr]);
}
function getUri(fullpath, id2, buftype) {
  if (!fullpath) return `untitled:${id2}`;
  if (path.isAbsolute(fullpath)) return URI2.file(path.normalize(fullpath)).toString();
  if (isUrl(fullpath)) return URI2.parse(fullpath).toString();
  if (buftype != "") return `${buftype}:${id2}`;
  return `unknown:${id2}`;
}
function getNotAttachReason(buftype, enabled, size) {
  if (!["", "acwrite"].includes(buftype)) {
    return `not a normal buffer, buftype "${buftype}"`;
  }
  if (enabled === 0) {
    return `b:coc_enabled = 0`;
  }
  return `buffer size ${size} exceed coc.preferences.maxFileSize`;
}
var import_buffer, logger11, debounceTime3, Document;
var init_document = __esm({
  "src/model/document.ts"() {
    "use strict";
    import_buffer = require("buffer");
    init_main();
    init_esm();
    init_events();
    init_logger();
    init_constants();
    init_diff();
    init_util();
    init_is();
    init_node();
    init_object();
    init_position();
    init_protocol();
    init_string();
    init_textedit();
    init_chars();
    init_textdocument();
    logger11 = createLogger("document");
    debounceTime3 = getConditionValue(150, 15);
    Document = class {
      constructor(buffer, env, nvim, opts) {
        this.buffer = buffer;
        this.env = env;
        this.nvim = nvim;
        this.isIgnored = false;
        this.eol = true;
        this._disposed = false;
        this._attached = false;
        this._notAttachReason = "";
        this._previewwindow = false;
        this._winid = -1;
        this._commandLine = false;
        this._applyQueque = [];
        this.disposables = [];
        // real current lines
        this.lines = [];
        this._onDocumentChange = new import_node4.Emitter();
        this.onDocumentChange = this._onDocumentChange.event;
        this.fireContentChanges = debounce(() => {
          this._fireContentChanges();
        }, debounceTime3);
        this.init(opts);
      }
      /**
       * Synchronize content
       */
      get content() {
        return this.syncLines.join("\n") + (this.eol ? "\n" : "");
      }
      get attached() {
        return this._attached;
      }
      /**
       * Synchronized textDocument.
       */
      get textDocument() {
        return this._textDocument;
      }
      get syncLines() {
        return this._textDocument.lines;
      }
      get version() {
        return this._textDocument.version;
      }
      /**
       * Buffer number
       */
      get bufnr() {
        return this.buffer.id;
      }
      get bufname() {
        return this._bufname;
      }
      get filetype() {
        return this._filetype;
      }
      get uri() {
        return this._uri;
      }
      get isCommandLine() {
        return this._commandLine;
      }
      /**
       * LanguageId of TextDocument, main filetype are used for combined filetypes
       * with '.'
       */
      get languageId() {
        let { _filetype } = this;
        return _filetype.includes(".") ? _filetype.match(/(.*?)\./)[1] : _filetype;
      }
      /**
       * Get current buffer changedtick.
       */
      get changedtick() {
        return this._changedtick;
      }
      /**
       * Map filetype for languageserver.
       */
      convertFiletype(filetype) {
        switch (filetype) {
          case "javascript.jsx":
            return "javascriptreact";
          case "typescript.jsx":
          case "typescript.tsx":
            return "typescriptreact";
          case "tex":
            return "latex";
          default: {
            let map = this.env.filetypeMap;
            return String(map[filetype] || filetype);
          }
        }
      }
      /**
       * Scheme of document.
       */
      get schema() {
        return URI2.parse(this.uri).scheme;
      }
      /**
       * Line count of current buffer.
       */
      get lineCount() {
        return this.lines.length;
      }
      /**
       * Window ID when buffer create, could be -1 when no window associated.
       */
      get winid() {
        return this._winid;
      }
      /**
       * Returns if current document is opened with previewwindow
       * @deprecated
       */
      get previewwindow() {
        return this._previewwindow;
      }
      /**
       * Initialize document model.
       */
      init(opts) {
        let buftype = this.buftype = opts.buftype;
        this._bufname = opts.bufname;
        this._commandLine = opts.commandline === 1;
        this._previewwindow = !!opts.previewwindow;
        this._winid = opts.winid;
        this.variables = toObject(opts.variables);
        this._changedtick = opts.changedtick;
        this.eol = opts.eol == 1;
        this._uri = getUri(opts.fullpath, this.bufnr, buftype);
        if (Array.isArray(opts.lines)) {
          this.lines = opts.lines.map((line) => toText(line));
          this._attached = true;
          this.attach();
        } else {
          this.lines = [];
          this._notAttachReason = getNotAttachReason(buftype, this.variables[`coc_enabled`], opts.size);
        }
        this._filetype = this.convertFiletype(opts.filetype);
        this.setIskeyword(opts.iskeyword, opts.lisp);
        this.createTextDocument(1, this.lines);
      }
      get notAttachReason() {
        return this._notAttachReason;
      }
      attach() {
        let lines = this.lines;
        this.buffer.attach(true).then((res) => {
          if (!res) fireDetach(this.bufnr);
        }, (_e) => {
          fireDetach(this.bufnr);
        });
        const onLinesChange = (id2, lines2) => {
          let prev = this._applyQueque.shift();
          if (prev && equals(prev, lines2)) {
            return;
          }
          this.lines = lines2;
          fireLinesChanged(id2);
          if (events_default.completing) return;
          this.fireContentChanges();
        };
        if (isVim) {
          this.buffer.listen("vim_lines", (bufnr, tick, changes) => {
            if (tick && tick > this._changedtick) {
              this._changedtick = tick;
              for (const change of changes) {
                lines = [...lines.slice(0, change[0]), ...change[2], ...lines.slice(change[0] + change[1])];
              }
              onLinesChange(bufnr, lines);
            }
          }, this.disposables);
        } else {
          this.buffer.listen("lines", (buf, tick, firstline, lastline, linedata) => {
            if (tick && tick > this._changedtick) {
              this._changedtick = tick;
              lines = [...lines.slice(0, firstline), ...linedata, ...lastline == -1 ? [] : lines.slice(lastline)];
              if (lines.length == 0) lines = [""];
              onLinesChange(buf.id, lines);
            }
          }, this.disposables);
          this.buffer.listen("detach", () => {
            fireDetach(this.bufnr);
          }, this.disposables);
        }
      }
      /**
       * Check if document changed after last synchronize
       */
      get dirty() {
        return this.lines !== this.syncLines;
      }
      get hasChanged() {
        if (!this.dirty) return false;
        return !equals(this.lines, this.syncLines);
      }
      /**
       * Cursor position if document is current document
       */
      get cursor() {
        let { cursor } = events_default;
        if (cursor.bufnr !== this.bufnr) return void 0;
        let content = this.lines[cursor.lnum - 1] ?? "";
        return Position.create(cursor.lnum - 1, characterIndex(content, cursor.col - 1));
      }
      _fireContentChanges(edit2) {
        if (this.lines === this.syncLines) return;
        let textDocument = this._textDocument;
        let changes = [];
        if (!edit2) edit2 = getTextEdit(textDocument.lines, this.lines, this.cursor, events_default.cursor.insert);
        let original;
        if (edit2) {
          original = textDocument.getText(edit2.range);
          changes.push({ range: edit2.range, text: edit2.newText, rangeLength: original.length });
        } else {
          original = "";
        }
        let created = this.createTextDocument(this.version + (edit2 ? 1 : 0), this.lines);
        this._onDocumentChange.fire(Object.freeze({
          bufnr: this.bufnr,
          original,
          originalLines: textDocument.lines,
          textDocument: { version: created.version, uri: this.uri },
          document: created,
          contentChanges: changes
        }));
      }
      async applyEdits(edits, joinUndo = false, move = false) {
        if (Array.isArray(arguments[1])) edits = arguments[1];
        if (!this._attached || edits.length === 0) return;
        this._forceSync();
        let textDocument = this.textDocument;
        edits = filterSortEdits(textDocument, edits);
        let newLines = applyEdits2(textDocument, edits);
        if (!newLines) return;
        let lines = textDocument.lines;
        let changed = diffLines(lines, newLines, getStartLine(edits[0]));
        let isAppend = changed.start === changed.end && changed.start === lines.length;
        let original = lines.slice(changed.start, changed.end);
        let changes = [];
        if (edits.length < 200 && changed.start !== changed.end && edits[edits.length - 1].range.end.line < lines.length) {
          changes = toTextChanges(lines, edits);
        }
        let cursor;
        let isCurrent = events_default.bufnr === this.bufnr;
        let col;
        if (move && isCurrent && !isAppend) {
          let pos = Position.is(move) ? move : this.cursor;
          if (pos) {
            let position = getPositionFromEdits(pos, edits);
            if (comparePosition(pos, position) !== 0) {
              let content = toText(newLines[position.line]);
              let col2 = byteIndex(content, position.character) + 1;
              cursor = [position.line + 1, col2];
            }
            col = byteIndex(this.lines[pos.line], pos.character) + 1;
          }
        }
        this.nvim.pauseNotification();
        if (isCurrent && joinUndo) this.nvim.command("undojoin", true);
        if (isAppend) {
          this.buffer.setLines(changed.replacement, { start: -1, end: -1 }, true);
        } else {
          this.nvim.call("coc#ui#set_lines", [
            this.bufnr,
            this._changedtick,
            original,
            changed.replacement,
            changed.start,
            changed.end,
            changes,
            cursor,
            col
          ], true);
        }
        this.nvim.resumeNotification(isCurrent, true);
        this._applyQueque.push(newLines);
        this.lines = newLines;
        await waitNextTick();
        fireLinesChanged(this.bufnr);
        let textEdit = edits.length == 1 ? edits[0] : mergeTextEdits(edits, lines, newLines);
        this.fireContentChanges.clear();
        this._fireContentChanges(textEdit);
        let range = Range.create(changed.start, 0, changed.start + changed.replacement.length, 0);
        return TextEdit.replace(range, original.join("\n") + (original.length > 0 ? "\n" : ""));
      }
      async changeLines(lines) {
        let filtered = [];
        let newLines = this.lines.slice();
        for (let [lnum, text] of lines) {
          if (newLines[lnum] != text) {
            filtered.push([lnum, text]);
            newLines[lnum] = text;
          }
        }
        if (!filtered.length) return;
        this.nvim.call("coc#ui#change_lines", [this.bufnr, filtered], true);
        this.nvim.redrawVim();
        this._applyQueque.push(newLines);
        this.lines = newLines;
        await waitNextTick();
        fireLinesChanged(this.bufnr);
        this._forceSync();
      }
      _forceSync() {
        if (!this._attached) return;
        this.fireContentChanges.clear();
        this._fireContentChanges();
      }
      forceSync() {
        if (false) {
          this._forceSync();
        }
      }
      /**
       * Get offset from lnum & col
       */
      getOffset(lnum, col) {
        return this.textDocument.offsetAt({
          line: lnum - 1,
          character: col
        });
      }
      /**
       * Check string is word.
       */
      isWord(word) {
        return this.chars.isKeyword(word);
      }
      getStartWord(text) {
        let i = 0;
        for (; i < text.length; i++) {
          if (!this.chars.isKeywordChar(text[i])) break;
        }
        return text.slice(0, i);
      }
      /**
       * Current word for replacement
       */
      getWordRangeAtPosition(position, extraChars, current = true) {
        let chars = this.chars;
        if (extraChars && extraChars.length) {
          chars = this.chars.clone();
          for (let ch2 of extraChars) {
            chars.addKeyword(ch2);
          }
        }
        let line = this.getline(position.line, current);
        let ch = line[position.character];
        if (ch == null || !chars.isKeywordChar(ch)) return null;
        let start = position.character;
        let end = position.character + 1;
        while (start >= 0) {
          let ch2 = line[start - 1];
          if (!ch2 || !chars.isKeywordChar(ch2)) break;
          start = start - 1;
        }
        while (end <= line.length) {
          let ch2 = line[end];
          if (!ch2 || !chars.isKeywordChar(ch2)) break;
          end = end + 1;
        }
        return Range.create(position.line, start, position.line, end);
      }
      createTextDocument(version2, lines) {
        let { uri, languageId, eol } = this;
        let textDocument = this._textDocument = new LinesTextDocument(uri, languageId, version2, lines, this.bufnr, eol);
        return textDocument;
      }
      /**
       * Get ranges of word in textDocument.
       */
      getSymbolRanges(word) {
        let { version: version2, languageId, uri } = this;
        let textDocument = new LinesTextDocument(uri, languageId, version2, this.lines, this.bufnr, this.eol);
        let res = [];
        let content = textDocument.getText();
        let str = "";
        for (let i = 0, l = content.length; i < l; i++) {
          let ch = content[i];
          if ("-" == ch && str.length == 0) {
            continue;
          }
          let isKeyword = this.chars.isKeywordChar(ch);
          if (isKeyword) {
            str = str + ch;
          }
          if (str.length > 0 && !isKeyword && str == word) {
            res.push(Range.create(textDocument.positionAt(i - str.length), textDocument.positionAt(i)));
          }
          if (!isKeyword) {
            str = "";
          }
        }
        return res;
      }
      /**
       * Adjust col with new valid character before position.
       */
      fixStartcol(position, valids) {
        let line = this.getline(position.line);
        if (!line) return 0;
        let { character } = position;
        let start = line.slice(0, character);
        let col = byteLength(start);
        let { chars } = this;
        for (let i = start.length - 1; i >= 0; i--) {
          let c = start[i];
          if (!chars.isKeywordChar(c) && !valids.includes(c)) {
            break;
          }
          col = col - byteLength(c);
        }
        return col;
      }
      /**
       * Add vim highlight items from highlight group and range.
       * Synchronized lines are used for calculate cols.
       */
      addHighlights(items, hlGroup, range, opts = {}) {
        let { start, end } = range;
        if (emptyRange(range)) return;
        for (let line = start.line; line <= end.line; line++) {
          const text = this.getline(line, false);
          let colStart = line == start.line ? byteIndex(text, start.character) : 0;
          let colEnd = line == end.line ? byteIndex(text, end.character) : import_buffer.Buffer.byteLength(text);
          if (colStart >= colEnd) continue;
          items.push(Object.assign({ hlGroup, lnum: line, colStart, colEnd }, opts));
        }
      }
      /**
       * Line content 0 based line
       */
      getline(line, current = true) {
        if (current) return this.lines[line] || "";
        return this.syncLines[line] || "";
      }
      /**
       * Get lines, zero indexed, end exclude.
       */
      getLines(start, end) {
        return this.lines.slice(start ?? 0, end ?? this.lines.length);
      }
      /**
       * Get current content text.
       */
      getDocumentContent() {
        let content = this.lines.join("\n");
        return this.eol ? content + "\n" : content;
      }
      /**
       * Get variable value by key, defined by `b:coc_{key}`
       */
      getVar(key, defaultValue2) {
        let val = this.variables[`coc_${key}`];
        return val === void 0 ? defaultValue2 : val;
      }
      /**
       * Get position from lnum & col
       */
      getPosition(lnum, col) {
        let line = this.getline(lnum - 1);
        if (!line || col == 0) return { line: lnum - 1, character: 0 };
        let pre = byteSlice(line, 0, col - 1);
        return { line: lnum - 1, character: pre.length };
      }
      /**
       * Recreate document with new filetype.
       */
      setFiletype(filetype) {
        this._filetype = this.convertFiletype(filetype);
        let lines = this._textDocument.lines;
        this._textDocument = new LinesTextDocument(this.uri, this.languageId, 1, lines, this.bufnr, this.eol);
      }
      /**
       * Change iskeyword option of document
       */
      setIskeyword(iskeyword, lisp) {
        let chars = this.chars = new Chars(iskeyword);
        let additional = this.getVar("additional_keywords", []);
        if (lisp) chars.addKeyword("-");
        if (additional && Array.isArray(additional)) {
          for (let ch of additional) {
            chars.addKeyword(ch);
          }
        }
      }
      /**
       * Detach document.
       */
      detach() {
        disposeAll(this.disposables);
        if (this._disposed) return;
        this._disposed = true;
        this._attached = false;
        this.lines = [];
        this.fireContentChanges.clear();
        this._onDocumentChange.dispose();
      }
      /**
       * Synchronize latest document content
       */
      async synchronize() {
        if (!this.attached) return;
        let { changedtick } = this;
        await this.patchChange();
        if (changedtick != this.changedtick) {
          await wait(50);
        }
      }
      /**
       * Synchronize buffer change
       */
      async patchChange() {
        if (!this._attached) return;
        this._changedtick = await this.nvim.call("coc#util#get_changedtick", [this.bufnr]);
        this._forceSync();
      }
      getSha256() {
        return sha256(this.lines.join("\n"));
      }
      async fetchLines() {
        let lines = await this.nvim.call("getbufline", [this.bufnr, 1, "$"]);
        this.lines = lines;
        fireLinesChanged(this.bufnr);
        this.fireContentChanges();
        logger11.error(`Buffer ${this.bufnr} not synchronized on vim9, consider send bug report!`);
      }
    };
  }
});

// src/util/convert.ts
function convertFormatOptions(opts) {
  let obj = { tabSize: opts.tabsize, insertSpaces: opts.expandtab == 1 };
  if (opts.insertFinalNewline) obj.insertFinalNewline = true;
  if (opts.trimTrailingWhitespace) obj.trimTrailingWhitespace = true;
  if (opts.trimFinalNewlines) obj.trimFinalNewlines = true;
  return obj;
}
function getSymbolKind(kind) {
  switch (kind) {
    case SymbolKind.File:
      return "File";
    case SymbolKind.Module:
      return "Module";
    case SymbolKind.Namespace:
      return "Namespace";
    case SymbolKind.Package:
      return "Package";
    case SymbolKind.Class:
      return "Class";
    case SymbolKind.Method:
      return "Method";
    case SymbolKind.Property:
      return "Property";
    case SymbolKind.Field:
      return "Field";
    case SymbolKind.Constructor:
      return "Constructor";
    case SymbolKind.Enum:
      return "Enum";
    case SymbolKind.Interface:
      return "Interface";
    case SymbolKind.Function:
      return "Function";
    case SymbolKind.Variable:
      return "Variable";
    case SymbolKind.Constant:
      return "Constant";
    case SymbolKind.String:
      return "String";
    case SymbolKind.Number:
      return "Number";
    case SymbolKind.Boolean:
      return "Boolean";
    case SymbolKind.Array:
      return "Array";
    case SymbolKind.Object:
      return "Object";
    case SymbolKind.Key:
      return "Key";
    case SymbolKind.Null:
      return "Null";
    case SymbolKind.EnumMember:
      return "EnumMember";
    case SymbolKind.Struct:
      return "Struct";
    case SymbolKind.Event:
      return "Event";
    case SymbolKind.Operator:
      return "Operator";
    case SymbolKind.TypeParameter:
      return "TypeParameter";
    default:
      return "Unknown";
  }
}
var init_convert = __esm({
  "src/util/convert.ts"() {
    "use strict";
    init_main();
  }
});

// node_modules/bytes/index.js
var require_bytes = __commonJS({
  "node_modules/bytes/index.js"(exports2, module2) {
    "use strict";
    module2.exports = bytes2;
    module2.exports.format = format3;
    module2.exports.parse = parse3;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes2(value, options2) {
      if (typeof value === "string") {
        return parse3(value);
      }
      if (typeof value === "number") {
        return format3(value, options2);
      }
      return null;
    }
    function format3(value, options2) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options2 && options2.thousandsSeparator || "";
      var unitSeparator = options2 && options2.unitSeparator || "";
      var decimalPlaces = options2 && options2.decimalPlaces !== void 0 ? options2.decimalPlaces : 2;
      var fixedDecimals = Boolean(options2 && options2.fixedDecimals);
      var unit = options2 && options2.unit || "";
      if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.pb) {
          unit = "PB";
        } else if (mag >= map.tb) {
          unit = "TB";
        } else if (mag >= map.gb) {
          unit = "GB";
        } else if (mag >= map.mb) {
          unit = "MB";
        } else if (mag >= map.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.split(".").map(function(s, i) {
          return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join(".");
      }
      return str + unitSeparator + unit;
    }
    function parse3(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      if (isNaN(floatValue)) {
        return null;
      }
      return Math.floor(map[unit] * floatValue);
    }
  }
});

// src/core/documents.ts
var logger12, cwd, Documents;
var init_documents = __esm({
  "src/core/documents.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_commands();
    init_events();
    init_logger();
    init_document();
    init_util();
    init_constants();
    init_convert();
    init_fs();
    init_is();
    init_node();
    init_platform();
    init_protocol();
    init_string();
    logger12 = createLogger("core-documents");
    cwd = normalizeFilePath(process.cwd());
    Documents = class {
      constructor(configurations, workspaceFolder) {
        this.configurations = configurations;
        this.workspaceFolder = workspaceFolder;
        this._attached = false;
        this._currentResolve = false;
        this.disposables = [];
        this.creating = /* @__PURE__ */ new Map();
        this.buffers = /* @__PURE__ */ new Map();
        this.resolves = [];
        this._onDidOpenTextDocument = new import_node4.Emitter();
        this._onDidCloseDocument = new import_node4.Emitter();
        this._onDidChangeDocument = new import_node4.Emitter();
        this._onDidSaveDocument = new import_node4.Emitter();
        this._onWillSaveDocument = new import_node4.Emitter();
        this.onDidOpenTextDocument = this._onDidOpenTextDocument.event;
        this.onDidCloseDocument = this._onDidCloseDocument.event;
        this.onDidChangeDocument = this._onDidChangeDocument.event;
        this.onDidSaveTextDocument = this._onDidSaveDocument.event;
        this.onWillSaveTextDocument = this._onWillSaveDocument.event;
        this._cwd = cwd;
        this.getConfiguration();
        this.configurations.onDidChange(this.getConfiguration, this, this.disposables);
      }
      async attach(nvim, env) {
        if (this._attached) return;
        this.nvim = nvim;
        this._env = env;
        this._attached = true;
        let { bufnrs, bufnr } = await this.nvim.call("coc#util#all_state");
        this._bufnr = bufnr;
        await Promise.all(bufnrs.map((bufnr2) => this.createDocument(bufnr2)));
        if (isVim) {
          const checkedTick = /* @__PURE__ */ new Map();
          events_default.on("CursorHold", async (bufnr2) => {
            let doc = this.getDocument(bufnr2);
            if (doc && doc.attached && checkedTick.get(bufnr2) != doc.changedtick) {
              let sha2562 = doc.getSha256();
              let same = await nvim.callVim("coc#vim9#Check_sha256", [bufnr2, sha2562]);
              checkedTick.set(bufnr2, doc.changedtick);
              if (!same) await doc.fetchLines();
            }
          }, null, this.disposables);
        }
        events_default.on("BufDetach", this.onBufDetach, this, this.disposables);
        events_default.on("BufRename", async (bufnr2) => {
          this.detachBuffer(bufnr2);
          await this.createDocument(bufnr2);
        }, null, this.disposables);
        events_default.on("DirChanged", (cwd2) => {
          this._cwd = normalizeFilePath(cwd2);
        }, null, this.disposables);
        const checkCurrentBuffer = (bufnr2) => {
          this._bufnr = bufnr2;
          void this.createDocument(bufnr2);
        };
        events_default.on("CursorMoved", checkCurrentBuffer, null, this.disposables);
        events_default.on("CursorMovedI", checkCurrentBuffer, null, this.disposables);
        events_default.on("BufUnload", this.onBufUnload, this, this.disposables);
        events_default.on("BufEnter", this.onBufEnter, this, this.disposables);
        events_default.on("BufCreate", this.onBufCreate, this, this.disposables);
        events_default.on("TermOpen", this.onBufCreate, this, this.disposables);
        events_default.on("BufWritePost", this.onBufWritePost, this, this.disposables);
        events_default.on("BufWritePre", this.onBufWritePre, this, this.disposables);
        events_default.on("FileType", this.onFileTypeChange, this, this.disposables);
        events_default.on("BufEnter", (bufnr2) => {
          void this.createDocument(bufnr2);
        }, null, this.disposables);
      }
      getConfiguration(e) {
        if (!e || e.affectsConfiguration("coc.preferences")) {
          let config = this.configurations.initialConfiguration.get("coc.preferences");
          const bytes2 = require_bytes();
          this.config = {
            maxFileSize: bytes2.parse(config.maxFileSize),
            willSaveHandlerTimeout: defaultValue(config.willSaveHandlerTimeout, 500),
            useQuickfixForLocations: config.useQuickfixForLocations
          };
        }
      }
      get bufnr() {
        return this._bufnr;
      }
      get root() {
        return this._root;
      }
      get cwd() {
        return this._cwd;
      }
      get documents() {
        return Array.from(this.buffers.values()).filter((o) => o.attached);
      }
      async getCurrentUri() {
        let bufnr = await this.nvim.call("bufnr", ["%"]);
        let doc = this.getDocument(bufnr);
        return doc ? doc.uri : void 0;
      }
      *attached(schema) {
        for (let doc of this.buffers.values()) {
          if (!doc.attached) continue;
          if (schema && doc.schema !== schema) continue;
          yield doc;
        }
      }
      get bufnrs() {
        return this.buffers.keys();
      }
      detach() {
        this._attached = false;
        for (let bufnr of this.buffers.keys()) {
          this.onBufUnload(bufnr);
        }
      }
      resolveRoot(rootPatterns, requireRootPattern = false) {
        let doc = this.getDocument(this.bufnr);
        let resolved;
        if (doc && doc.schema == "file") {
          let dir = path.dirname(URI2.parse(doc.uri).fsPath);
          resolved = resolveRoot(dir, rootPatterns, this.cwd);
        } else {
          resolved = resolveRoot(this.cwd, rootPatterns);
        }
        if (requireRootPattern && !resolved) {
          throw new Error(`Required root pattern not resolved.`);
        }
        return resolved;
      }
      get textDocuments() {
        let docs = [];
        for (let b of this.buffers.values()) {
          if (b.attached) docs.push(b.textDocument);
        }
        return docs;
      }
      getDocument(uri, caseInsensitive = isWindows || isMacintosh) {
        if (typeof uri === "number") {
          return this.buffers.get(uri);
        }
        let u = URI2.parse(uri);
        uri = u.toString();
        let isFile2 = u.scheme === "file";
        for (let doc of this.buffers.values()) {
          if (doc.uri === uri) return doc;
          if (isFile2 && caseInsensitive && doc.uri.toLowerCase() === uri.toLowerCase()) return doc;
        }
        return null;
      }
      /**
       * Expand filepath with `~` and/or environment placeholders
       */
      expand(input) {
        if (input.startsWith("~")) {
          input = os.homedir() + input.slice(1);
        }
        if (input.includes("$")) {
          let doc = this.getDocument(this.bufnr);
          let fsPath2 = doc ? URI2.parse(doc.uri).fsPath : "";
          const root = this._root || this._cwd;
          input = input.replace(/\$\{(.*?)\}/g, (match, name2) => {
            if (name2.startsWith("env:")) {
              let key = name2.split(":")[1];
              let val = key ? process.env[key] : "";
              return val;
            }
            switch (name2) {
              case "tmpdir":
                return os.tmpdir();
              case "userHome":
                return os.homedir();
              case "workspace":
              case "workspaceRoot":
              case "workspaceFolder":
                return root;
              case "workspaceFolderBasename":
                return path.basename(root);
              case "cwd":
                return this._cwd;
              case "file":
                return fsPath2;
              case "fileDirname":
                return fsPath2 ? path.dirname(fsPath2) : "";
              case "fileExtname":
                return fsPath2 ? path.extname(fsPath2) : "";
              case "fileBasename":
                return fsPath2 ? path.basename(fsPath2) : "";
              case "fileBasenameNoExtension": {
                let base = fsPath2 ? path.basename(fsPath2) : "";
                return base ? base.slice(0, base.length - path.extname(base).length) : "";
              }
              default:
                return match;
            }
          });
          input = input.replace(/\$[\w]+/g, (match) => {
            if (match == "$HOME") return os.homedir();
            return process.env[match.slice(1)] || match;
          });
        }
        return input;
      }
      /**
       * Current document.
       */
      get document() {
        if (this._currentResolve) {
          return new Promise((resolve) => {
            this.resolves.push(resolve);
          });
        }
        this._currentResolve = true;
        return new Promise((resolve) => {
          this.nvim.eval(`coc#util#get_bufoptions(bufnr("%"),${this.config.maxFileSize})`).then((opts) => {
            let doc;
            if (opts != null) {
              this.creating.delete(opts.bufnr);
              doc = this._createDocument(opts);
            }
            this.resolveCurrent(doc);
            resolve(doc);
            this._currentResolve = false;
          }, () => {
            resolve(void 0);
            this._currentResolve = false;
          });
        });
      }
      resolveCurrent(document2) {
        if (this.resolves.length > 0) {
          while (this.resolves.length) {
            const fn = this.resolves.pop();
            if (fn) fn(document2);
          }
        }
      }
      get uri() {
        let { bufnr } = this;
        if (bufnr) {
          let doc = this.getDocument(bufnr);
          if (doc) return doc.uri;
        }
        return null;
      }
      /**
       * Current filetypes.
       */
      get filetypes() {
        let res = /* @__PURE__ */ new Set();
        for (let doc of this.attached()) {
          res.add(doc.filetype);
        }
        return res;
      }
      /**
       * Get filetype by check same extension name buffer.
       */
      getLanguageId(filepath) {
        let ext = path.extname(filepath);
        if (!ext) return "";
        for (let doc of this.attached()) {
          let fsPath2 = URI2.parse(doc.uri).fsPath;
          if (path.extname(fsPath2) == ext) {
            return doc.languageId;
          }
        }
        return "";
      }
      async getLines(uri) {
        let doc = this.getDocument(uri);
        if (doc) return doc.textDocument.lines;
        let u = URI2.parse(uri);
        if (u.scheme !== "file") return [];
        try {
          let content = await readFile(u.fsPath, "utf8");
          return content.split(/\r?\n/);
        } catch (e) {
          return [];
        }
      }
      /**
       * Current languageIds.
       */
      get languageIds() {
        let res = /* @__PURE__ */ new Set();
        for (let doc of this.attached()) {
          res.add(doc.languageId);
        }
        return res;
      }
      /**
       * Get format options
       */
      async getFormatOptions(uri) {
        let bufnr = typeof uri === "number" ? uri : this.getBufnr(uri);
        let res = await this.nvim.call("coc#util#get_format_opts", [bufnr]);
        return convertFormatOptions(res);
      }
      getBufnr(uri) {
        if (!uri) return 0;
        let doc = this.getDocument(uri);
        return doc ? doc.bufnr : 0;
      }
      /**
       * Create document by bufnr.
       */
      async createDocument(bufnr) {
        let doc = this.buffers.get(bufnr);
        if (doc) return doc;
        if (this.creating.has(bufnr)) return await this.creating.get(bufnr);
        let promise = new Promise((resolve) => {
          this.nvim.call("coc#util#get_bufoptions", [bufnr, this.config.maxFileSize]).then((opts) => {
            if (!this.creating.has(bufnr)) {
              resolve(void 0);
              return;
            }
            this.creating.delete(bufnr);
            if (!opts) {
              resolve(void 0);
              return;
            }
            doc = this._createDocument(opts);
            resolve(doc);
          }, () => {
            this.creating.delete(bufnr);
            resolve(void 0);
          });
        });
        this.creating.set(bufnr, promise);
        return await promise;
      }
      async onBufCreate(bufnr) {
        this.onBufUnload(bufnr);
        await this.createDocument(bufnr);
      }
      _createDocument(opts) {
        let { bufnr } = opts;
        if (this.buffers.has(bufnr)) return this.buffers.get(bufnr);
        let buffer = this.nvim.createBuffer(bufnr);
        let doc = new Document(buffer, this._env, this.nvim, opts);
        if (opts.size > this.config.maxFileSize) logger12.warn(`buffer ${opts.bufnr} size exceed maxFileSize ${this.config.maxFileSize}, not attached.`);
        this.buffers.set(bufnr, doc);
        if (doc.attached) {
          if (doc.schema == "file") {
            this.configurations.locateFolderConfigution(doc.uri);
            let root = this.workspaceFolder.resolveRoot(doc, this._cwd, true, this.expand.bind(this));
            if (root && bufnr == this._bufnr) this.changeRoot(root);
          }
          this._onDidOpenTextDocument.fire(doc.textDocument);
          doc.onDocumentChange((e) => this._onDidChangeDocument.fire(e));
        }
        logger12.debug("buffer created", bufnr, doc.attached, doc.uri);
        return doc;
      }
      onBufEnter(bufnr) {
        this._bufnr = bufnr;
        let doc = this.buffers.get(bufnr);
        if (doc) {
          let workspaceFolder = this.workspaceFolder.getWorkspaceFolder(URI2.parse(doc.uri));
          if (workspaceFolder) this._root = URI2.parse(workspaceFolder.uri).fsPath;
        }
      }
      onBufUnload(bufnr) {
        this.creating.delete(bufnr);
        void this.onBufDetach(bufnr, false);
      }
      async onBufDetach(bufnr, checkReload = true) {
        this.detachBuffer(bufnr);
        if (checkReload) {
          let loaded = await this.nvim.call("bufloaded", [bufnr]);
          if (loaded) await this.createDocument(bufnr);
        }
      }
      detachBuffer(bufnr) {
        let doc = this.buffers.get(bufnr);
        if (!doc) return;
        logger12.debug("document detach", bufnr, doc.uri);
        this._onDidCloseDocument.fire(doc.textDocument);
        this.buffers.delete(bufnr);
        doc.detach();
        const uris = this.textDocuments.map((o) => URI2.parse(o.uri));
        this.workspaceFolder.onDocumentDetach(uris);
      }
      async onBufWritePost(bufnr, changedtick) {
        let doc = this.buffers.get(bufnr);
        if (doc) {
          if (doc.changedtick != changedtick) await doc.patchChange();
          this._onDidSaveDocument.fire(doc.textDocument);
        }
      }
      async onBufWritePre(bufnr, bufname, changedtick) {
        let doc = this.buffers.get(bufnr);
        if (!doc || !doc.attached) return;
        if (doc.bufname != bufname) {
          this.detachBuffer(bufnr);
          doc = await this.createDocument(bufnr);
          if (!doc.attached) return;
        }
        if (doc.changedtick != changedtick) {
          await doc.synchronize();
        } else {
          await doc.patchChange();
        }
        let firing = true;
        let thenables = [];
        let event = {
          bufnr: doc.bufnr,
          document: doc.textDocument,
          reason: import_node4.TextDocumentSaveReason.Manual,
          waitUntil: (thenable) => {
            if (!firing) {
              this.nvim.echoError(`waitUntil can't be used in async manner, check log for details`);
            } else {
              thenables.push(thenable);
            }
          }
        };
        this._onWillSaveDocument.fire(event);
        firing = false;
        let total = thenables.length;
        if (total) {
          let promise = new Promise((resolve) => {
            const willSaveHandlerTimeout = this.config.willSaveHandlerTimeout;
            let timer = setTimeout(() => {
              this.nvim.outWriteLine(`Will save handler timeout after ${willSaveHandlerTimeout}ms`);
              resolve(void 0);
            }, willSaveHandlerTimeout);
            let i = 0;
            let called = false;
            for (let p of thenables) {
              let cb = (res) => {
                if (called) return;
                called = true;
                clearTimeout(timer);
                resolve(res);
              };
              p.then((res) => {
                if (Array.isArray(res) && res.length && TextEdit.is(res[0])) {
                  return cb(res);
                }
                i = i + 1;
                if (i == total) cb(void 0);
              }, (e) => {
                logger12.error(`Error on will save handler:`, e);
                i = i + 1;
                if (i == total) cb(void 0);
              });
            }
          });
          let edits = await promise;
          if (edits) await doc.applyEdits(edits, false, this.bufnr === doc.bufnr);
        }
        await this.tryCodeActionsOnSave(doc);
      }
      async tryCodeActionsOnSave(doc) {
        let editorConfig = this.configurations.getConfiguration("editor", doc.textDocument);
        let conf = editorConfig.get("codeActionsOnSave", {});
        if (emptyObject(conf)) return false;
        const actions = [];
        for (const key of Object.keys(conf)) {
          if (conf[key] === true || conf[key] === "always") {
            actions.push(key);
          }
        }
        if (actions.length === 0) return false;
        await commands_default.executeCommand("editor.action.executeCodeActions", doc, void 0, actions, this.config.willSaveHandlerTimeout);
        return true;
      }
      onFileTypeChange(filetype, bufnr) {
        let doc = this.getDocument(bufnr);
        if (!doc) return;
        let converted = doc.convertFiletype(filetype);
        if (converted == doc.filetype) return;
        this._onDidCloseDocument.fire(doc.textDocument);
        doc.setFiletype(filetype);
        this._onDidOpenTextDocument.fire(doc.textDocument);
      }
      async getQuickfixList(locations) {
        let filesLines = {};
        let filepathList = locations.reduce((pre, curr) => {
          let u = URI2.parse(curr.uri);
          if (u.scheme == "file" && !pre.includes(u.fsPath) && !this.getDocument(curr.uri)) {
            pre.push(u.fsPath);
          }
          return pre;
        }, []);
        await Promise.all(filepathList.map((fsPath2) => {
          return new Promise((resolve) => {
            readFile(fsPath2, "utf8").then((content) => {
              filesLines[fsPath2] = content.split(/\r?\n/);
              resolve(void 0);
            }, () => {
              resolve();
            });
          });
        }));
        return await Promise.all(locations.map((loc) => {
          let { uri, range } = loc;
          let { fsPath: fsPath2 } = URI2.parse(uri);
          let text;
          let lines = filesLines[fsPath2];
          if (lines) text = lines[range.start.line];
          return this.getQuickfixItem(loc, text);
        }));
      }
      /**
       * Populate locations to UI.
       */
      async showLocations(locations) {
        let { nvim } = this;
        let items = await this.getQuickfixList(locations);
        if (this.config.useQuickfixForLocations) {
          let openCommand = await nvim.getVar("coc_quickfix_open_command");
          if (typeof openCommand != "string") {
            openCommand = items.length < 10 ? `copen ${items.length}` : "copen";
          }
          nvim.pauseNotification();
          nvim.call("setqflist", [items], true);
          nvim.command(openCommand, true);
          nvim.resumeNotification(false, true);
        } else {
          await nvim.setVar("coc_jump_locations", items);
          if (this._env.locationlist) {
            nvim.command("CocList --normal --auto-preview location", true);
          } else {
            nvim.call("coc#util#do_autocmd", ["CocLocationsChange"], true);
          }
        }
      }
      fixUnixPrefix(filepath) {
        if (!this._env.isCygwin || !/^\w:/.test(filepath)) return filepath;
        return this._env.unixPrefix + filepath[0].toLowerCase() + filepath.slice(2).replace(/\\/g, "/");
      }
      /**
       * Convert location to quickfix item.
       */
      async getQuickfixItem(loc, text, type = "", module2) {
        let targetRange = loc.targetRange;
        if (LocationLink.is(loc)) {
          loc = Location.create(loc.targetUri, loc.targetRange);
        }
        let doc = this.getDocument(loc.uri);
        let { uri, range } = loc;
        let { start, end } = range;
        let u = URI2.parse(uri);
        if (!text && u.scheme == "file") {
          text = await this.getLine(uri, start.line);
        }
        let endLine = start.line == end.line ? text : await this.getLine(uri, end.line);
        let item = {
          uri,
          filename: u.scheme == "file" ? this.fixUnixPrefix(u.fsPath) : uri,
          lnum: start.line + 1,
          end_lnum: end.line + 1,
          col: text ? byteIndex(text, start.character) + 1 : start.character + 1,
          end_col: endLine ? byteIndex(endLine, end.character) + 1 : end.character + 1,
          text: text || "",
          range
        };
        if (targetRange) item.targetRange = targetRange;
        if (module2) item.module = module2;
        if (type) item.type = type;
        if (doc) item.bufnr = doc.bufnr;
        return item;
      }
      /**
       * Get content of line by uri and line.
       */
      async getLine(uri, line) {
        let document2 = this.getDocument(uri);
        if (document2 && document2.attached) return document2.getline(line) || "";
        if (!uri.startsWith("file:")) return "";
        let fsPath2 = URI2.parse(uri).fsPath;
        if (!fs.existsSync(fsPath2)) return "";
        return await readFileLine(fsPath2, line);
      }
      /**
       * Get content from buffer or file by uri.
       */
      async readFile(uri) {
        let document2 = this.getDocument(uri);
        if (document2) {
          await document2.patchChange();
          return document2.content;
        }
        let u = URI2.parse(uri);
        if (u.scheme != "file") return "";
        let lines = await this.nvim.call("readfile", [u.fsPath]);
        return lines.join("\n") + "\n";
      }
      reset() {
        this.creating.clear();
        for (let bufnr of this.buffers.keys()) {
          this.onBufUnload(bufnr);
        }
        this.buffers.clear();
        this.changeRoot(process.cwd());
      }
      changeRoot(dir) {
        this._root = normalizeFilePath(dir);
      }
      dispose() {
        for (let bufnr of this.buffers.keys()) {
          this.onBufUnload(bufnr);
        }
        this._attached = false;
        this.buffers.clear();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/core/editors.ts
function renamed(editor, info) {
  let { document: document2, uri } = editor;
  if (document2.bufnr != info.bufnr) return false;
  let u = URI2.parse(uri);
  if (u.scheme === "file") return !sameFile(u.fsPath, info.fullpath);
  return false;
}
var logger13, Editors;
var init_editors = __esm({
  "src/core/editors.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_events();
    init_logger();
    init_convert();
    init_fs();
    init_protocol();
    logger13 = createLogger("core-editors");
    Editors = class {
      constructor(documents) {
        this.documents = documents;
        this.disposables = [];
        this.editors = /* @__PURE__ */ new Map();
        this.tabIds = /* @__PURE__ */ new Set();
        this._onDidTabClose = new import_node4.Emitter();
        this._onDidChangeActiveTextEditor = new import_node4.Emitter();
        this._onDidChangeVisibleTextEditors = new import_node4.Emitter();
        this.onDidTabClose = this._onDidTabClose.event;
        this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
        this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
      }
      get activeTextEditor() {
        return this.editors.get(this.winid);
      }
      get visibleTextEditors() {
        return Array.from(this.editors.values());
      }
      isVisible(bufnr) {
        for (let editor of this.editors.values()) {
          if (editor.bufnr == bufnr) return true;
        }
        return false;
      }
      getBufWinids(bufnr) {
        let winids = [];
        for (let editor of this.editors.values()) {
          if (editor.bufnr == bufnr) winids.push(editor.winid);
        }
        return winids;
      }
      onChangeCurrent(editor) {
        let id2 = editor.id;
        if (id2 === this.previousId) return;
        this.previousId = id2;
        this._onDidChangeActiveTextEditor.fire(editor);
      }
      async attach(nvim) {
        this.nvim = nvim;
        let [winid, infos] = await nvim.eval(`[win_getid(),coc#util#editor_infos()]`);
        this.winid = winid;
        await Promise.allSettled(infos.map((info) => {
          return this.createTextEditor(info.winid);
        }));
        events_default.on("BufUnload", (bufnr) => {
          for (let [winid2, editor] of this.editors.entries()) {
            if (bufnr == editor.bufnr) {
              this.editors.delete(winid2);
            }
          }
        }, null, this.disposables);
        events_default.on("CursorHold", this.checkEditors, this, this.disposables);
        events_default.on("TabNew", (tabid) => {
          this.tabIds.add(tabid);
        }, null, this.disposables);
        events_default.on("TabClosed", this.checkTabs, this, this.disposables);
        events_default.on("WinEnter", (winid2) => {
          this.winid = winid2;
          let editor = this.editors.get(winid2);
          if (editor) this.onChangeCurrent(editor);
        }, null, this.disposables);
        events_default.on("WinClosed", (winid2) => {
          if (this.editors.has(winid2)) {
            this.editors.delete(winid2);
            this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
          }
        }, null, this.disposables);
        events_default.on("BufWinEnter", async (_, winid2) => {
          this.winid = winid2;
          let changed = await this.createTextEditor(winid2);
          if (changed) this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
        }, null, this.disposables);
      }
      checkTabs(ids) {
        let changed = false;
        for (let editor of this.editors.values()) {
          if (!ids.includes(editor.tabpageid)) {
            changed = true;
            this.editors.delete(editor.winid);
          }
        }
        for (let id2 of Array.from(this.tabIds)) {
          if (!ids.includes(id2)) this._onDidTabClose.fire(id2);
        }
        this.tabIds = new Set(ids);
        if (changed) this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
      }
      checkUnloadedBuffers(bufnrs) {
        for (let bufnr of this.documents.bufnrs) {
          if (!bufnrs.includes(bufnr)) {
            void events_default.fire("BufUnload", [bufnr]);
          }
        }
      }
      async checkEditors() {
        let [winid, bufnrs, infos] = await this.nvim.eval(`[win_getid(),coc#util#get_loaded_bufs(),coc#util#editor_infos()]`);
        this.winid = winid;
        this.checkUnloadedBuffers(bufnrs);
        let changed = false;
        let winids = /* @__PURE__ */ new Set();
        for (let info of infos) {
          let editor = this.editors.get(info.winid);
          let create = false;
          if (!editor) {
            create = true;
          } else if (renamed(editor, info)) {
            await events_default.fire("BufRename", [info.bufnr]);
            create = true;
          } else if (editor.document.bufnr != info.bufnr || editor.tabpageid != info.tabid) {
            create = true;
          }
          if (create) {
            await this.createTextEditor(info.winid);
            changed = true;
          }
          winids.add(info.winid);
        }
        if (this.cleanupEditors(winids)) {
          changed = true;
        }
        if (changed) this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
      }
      cleanupEditors(winids) {
        let changed = false;
        for (let winid of Array.from(this.editors.keys())) {
          if (!winids.has(winid)) {
            changed = true;
            this.editors.delete(winid);
          }
        }
        return changed;
      }
      async createTextEditor(winid) {
        let { documents, nvim } = this;
        let opts = await nvim.call("coc#util#get_editoroption", [winid]);
        if (!opts) return false;
        this.tabIds.add(opts.tabpageid);
        let doc = documents.getDocument(opts.bufnr);
        if (doc && doc.attached) {
          let editor = this.fromOptions(opts);
          this.editors.set(winid, editor);
          if (winid == this.winid) this.onChangeCurrent(editor);
          logger13.debug("editor created winid & bufnr & tabpageid: ", winid, opts.bufnr, opts.tabpageid);
          return true;
        } else {
          this.editors.delete(opts.winid);
        }
        return false;
      }
      fromOptions(opts) {
        let { visibleRanges, bufnr, formatOptions } = opts;
        let document2 = this.documents.getDocument(bufnr);
        return {
          id: `${opts.tabpageid}-${opts.winid}-${document2.uri}`,
          tabpageid: opts.tabpageid,
          winid: opts.winid,
          winnr: opts.winnr,
          uri: document2.uri,
          bufnr: document2.bufnr,
          document: document2,
          visibleRanges: visibleRanges.map((o) => Range.create(o[0] - 1, 0, o[1], 0)),
          options: convertFormatOptions(formatOptions)
        };
      }
    };
  }
});

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto, rnds8Pool, poolPtr;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    import_crypto = __toESM(require("crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// node_modules/uuid/dist/esm-node/stringify.js
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
var byteToHex;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-node/stringify.js"() {
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
  }
});

// node_modules/uuid/dist/esm-node/v1.js
function v1(options2, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options2 = options2 || {};
  let node = options2.node || _nodeId;
  let clockseq = options2.clockseq !== void 0 ? options2.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    const seedBytes = options2.random || (options2.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options2.msecs !== void 0 ? options2.msecs : Date.now();
  let nsecs = options2.nsecs !== void 0 ? options2.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options2.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options2.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || unsafeStringify(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-node/native.js
var import_crypto2, native_default;
var init_native = __esm({
  "node_modules/uuid/dist/esm-node/native.js"() {
    import_crypto2 = __toESM(require("crypto"));
    native_default = {
      randomUUID: import_crypto2.default.randomUUID
    };
  }
});

// node_modules/uuid/dist/esm-node/v4.js
function v4(options2, buf, offset) {
  if (native_default.randomUUID && !buf && !options2) {
    return native_default.randomUUID();
  }
  options2 = options2 || {};
  const rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    init_native();
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-node/index.js
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    init_v1();
    init_v4();
  }
});

// node_modules/node-int64/Int64.js
var require_Int64 = __commonJS({
  "node_modules/node-int64/Int64.js"(exports2, module2) {
    var VAL32 = 4294967296;
    var _HEX = [];
    for (i = 0; i < 256; i++) {
      _HEX[i] = (i > 15 ? "" : "0") + i.toString(16);
    }
    var i;
    var Int64 = module2.exports = function(a1, a2) {
      if (a1 instanceof Buffer) {
        this.buffer = a1;
        this.offset = a2 || 0;
      } else if (Object.prototype.toString.call(a1) == "[object Uint8Array]") {
        this.buffer = new Buffer(a1);
        this.offset = a2 || 0;
      } else {
        this.buffer = this.buffer || new Buffer(8);
        this.offset = 0;
        this.setValue.apply(this, arguments);
      }
    };
    Int64.MAX_INT = Math.pow(2, 53);
    Int64.MIN_INT = -Math.pow(2, 53);
    Int64.prototype = {
      constructor: Int64,
      /**
       * Do in-place 2's compliment.  See
       * http://en.wikipedia.org/wiki/Two's_complement
       */
      _2scomp: function() {
        var b = this.buffer, o = this.offset, carry = 1;
        for (var i2 = o + 7; i2 >= o; i2--) {
          var v = (b[i2] ^ 255) + carry;
          b[i2] = v & 255;
          carry = v >> 8;
        }
      },
      /**
       * Set the value. Takes any of the following arguments:
       *
       * setValue(string) - A hexidecimal string
       * setValue(number) - Number (throws if n is outside int64 range)
       * setValue(hi, lo) - Raw bits as two 32-bit values
       */
      setValue: function(hi, lo) {
        var negate = false;
        if (arguments.length == 1) {
          if (typeof hi == "number") {
            negate = hi < 0;
            hi = Math.abs(hi);
            lo = hi % VAL32;
            hi = hi / VAL32;
            if (hi > VAL32) throw new RangeError(hi + " is outside Int64 range");
            hi = hi | 0;
          } else if (typeof hi == "string") {
            hi = (hi + "").replace(/^0x/, "");
            lo = hi.substr(-8);
            hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : "";
            hi = parseInt(hi, 16);
            lo = parseInt(lo, 16);
          } else {
            throw new Error(hi + " must be a Number or String");
          }
        }
        var b = this.buffer, o = this.offset;
        for (var i2 = 7; i2 >= 0; i2--) {
          b[o + i2] = lo & 255;
          lo = i2 == 4 ? hi : lo >>> 8;
        }
        if (negate) this._2scomp();
      },
      /**
       * Convert to a native JS number.
       *
       * WARNING: Do not expect this value to be accurate to integer precision for
       * large (positive or negative) numbers!
       *
       * @param allowImprecise If true, no check is performed to verify the
       * returned value is accurate to integer precision.  If false, imprecise
       * numbers (very large positive or negative numbers) will be forced to +/-
       * Infinity.
       */
      toNumber: function(allowImprecise) {
        var b = this.buffer, o = this.offset;
        var negate = b[o] & 128, x = 0, carry = 1;
        for (var i2 = 7, m = 1; i2 >= 0; i2--, m *= 256) {
          var v = b[o + i2];
          if (negate) {
            v = (v ^ 255) + carry;
            carry = v >> 8;
            v = v & 255;
          }
          x += v * m;
        }
        if (!allowImprecise && x >= Int64.MAX_INT) {
          return negate ? -Infinity : Infinity;
        }
        return negate ? -x : x;
      },
      /**
       * Convert to a JS Number. Returns +/-Infinity for values that can't be
       * represented to integer precision.
       */
      valueOf: function() {
        return this.toNumber(false);
      },
      /**
       * Return string value
       *
       * @param radix Just like Number#toString()'s radix
       */
      toString: function(radix) {
        return this.valueOf().toString(radix || 10);
      },
      /**
       * Return a string showing the buffer octets, with MSB on the left.
       *
       * @param sep separator string. default is '' (empty string)
       */
      toOctetString: function(sep) {
        var out = new Array(8);
        var b = this.buffer, o = this.offset;
        for (var i2 = 0; i2 < 8; i2++) {
          out[i2] = _HEX[b[o + i2]];
        }
        return out.join(sep || "");
      },
      /**
       * Returns the int64's 8 bytes in a buffer.
       *
       * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if
       *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.
       */
      toBuffer: function(rawBuffer) {
        if (rawBuffer && this.offset === 0) return this.buffer;
        var out = new Buffer(8);
        this.buffer.copy(out, 0, this.offset, this.offset + 8);
        return out;
      },
      /**
       * Copy 8 bytes of int64 into target buffer at target offset.
       *
       * @param {Buffer} targetBuffer       Buffer to copy into.
       * @param {number} [targetOffset=0]   Offset into target buffer.
       */
      copy: function(targetBuffer, targetOffset) {
        this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);
      },
      /**
       * Returns a number indicating whether this comes before or after or is the
       * same as the other in sort order.
       *
       * @param {Int64} other  Other Int64 to compare.
       */
      compare: function(other) {
        if ((this.buffer[this.offset] & 128) != (other.buffer[other.offset] & 128)) {
          return other.buffer[other.offset] - this.buffer[this.offset];
        }
        for (var i2 = 0; i2 < 8; i2++) {
          if (this.buffer[this.offset + i2] !== other.buffer[other.offset + i2]) {
            return this.buffer[this.offset + i2] - other.buffer[other.offset + i2];
          }
        }
        return 0;
      },
      /**
       * Returns a boolean indicating if this integer is equal to other.
       *
       * @param {Int64} other  Other Int64 to compare.
       */
      equals: function(other) {
        return this.compare(other) === 0;
      },
      /**
       * Pretty output in console.log
       */
      inspect: function() {
        return "[Int64 value:" + this + " octets:" + this.toOctetString(" ") + "]";
      }
    };
  }
});

// node_modules/bser/index.js
var require_bser = __commonJS({
  "node_modules/bser/index.js"(exports2) {
    var EE = require("events").EventEmitter;
    var util = require("util");
    var os2 = require("os");
    var assert2 = require("assert");
    var Int64 = require_Int64();
    var isBigEndian = os2.endianness() == "BE";
    function nextPow2(size) {
      return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));
    }
    function Accumulator(initsize) {
      this.buf = Buffer.alloc(nextPow2(initsize || 8192));
      this.readOffset = 0;
      this.writeOffset = 0;
    }
    exports2.Accumulator = Accumulator;
    Accumulator.prototype.writeAvail = function() {
      return this.buf.length - this.writeOffset;
    };
    Accumulator.prototype.readAvail = function() {
      return this.writeOffset - this.readOffset;
    };
    Accumulator.prototype.reserve = function(size) {
      if (size < this.writeAvail()) {
        return;
      }
      if (this.readOffset > 0) {
        this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);
        this.writeOffset -= this.readOffset;
        this.readOffset = 0;
      }
      if (size < this.writeAvail()) {
        return;
      }
      var buf = Buffer.alloc(nextPow2(this.buf.length + size - this.writeAvail()));
      this.buf.copy(buf);
      this.buf = buf;
    };
    Accumulator.prototype.append = function(buf) {
      if (Buffer.isBuffer(buf)) {
        this.reserve(buf.length);
        buf.copy(this.buf, this.writeOffset, 0, buf.length);
        this.writeOffset += buf.length;
      } else {
        var size = Buffer.byteLength(buf);
        this.reserve(size);
        this.buf.write(buf, this.writeOffset);
        this.writeOffset += size;
      }
    };
    Accumulator.prototype.assertReadableSize = function(size) {
      if (this.readAvail() < size) {
        throw new Error("wanted to read " + size + " bytes but only have " + this.readAvail());
      }
    };
    Accumulator.prototype.peekString = function(size) {
      this.assertReadableSize(size);
      return this.buf.toString("utf-8", this.readOffset, this.readOffset + size);
    };
    Accumulator.prototype.readString = function(size) {
      var str = this.peekString(size);
      this.readOffset += size;
      return str;
    };
    Accumulator.prototype.peekInt = function(size) {
      this.assertReadableSize(size);
      switch (size) {
        case 1:
          return this.buf.readInt8(this.readOffset, size);
        case 2:
          return isBigEndian ? this.buf.readInt16BE(this.readOffset, size) : this.buf.readInt16LE(this.readOffset, size);
        case 4:
          return isBigEndian ? this.buf.readInt32BE(this.readOffset, size) : this.buf.readInt32LE(this.readOffset, size);
        case 8:
          var big = this.buf.slice(this.readOffset, this.readOffset + 8);
          if (isBigEndian) {
            return new Int64(big);
          }
          return new Int64(byteswap64(big));
        default:
          throw new Error("invalid integer size " + size);
      }
    };
    Accumulator.prototype.readInt = function(bytes2) {
      var ival = this.peekInt(bytes2);
      if (ival instanceof Int64 && isFinite(ival.valueOf())) {
        ival = ival.valueOf();
      }
      this.readOffset += bytes2;
      return ival;
    };
    Accumulator.prototype.peekDouble = function() {
      this.assertReadableSize(8);
      return isBigEndian ? this.buf.readDoubleBE(this.readOffset) : this.buf.readDoubleLE(this.readOffset);
    };
    Accumulator.prototype.readDouble = function() {
      var dval = this.peekDouble();
      this.readOffset += 8;
      return dval;
    };
    Accumulator.prototype.readAdvance = function(size) {
      if (size > 0) {
        this.assertReadableSize(size);
      } else if (size < 0 && this.readOffset + size < 0) {
        throw new Error("advance with negative offset " + size + " would seek off the start of the buffer");
      }
      this.readOffset += size;
    };
    Accumulator.prototype.writeByte = function(value) {
      this.reserve(1);
      this.buf.writeInt8(value, this.writeOffset);
      ++this.writeOffset;
    };
    Accumulator.prototype.writeInt = function(value, size) {
      this.reserve(size);
      switch (size) {
        case 1:
          this.buf.writeInt8(value, this.writeOffset);
          break;
        case 2:
          if (isBigEndian) {
            this.buf.writeInt16BE(value, this.writeOffset);
          } else {
            this.buf.writeInt16LE(value, this.writeOffset);
          }
          break;
        case 4:
          if (isBigEndian) {
            this.buf.writeInt32BE(value, this.writeOffset);
          } else {
            this.buf.writeInt32LE(value, this.writeOffset);
          }
          break;
        default:
          throw new Error("unsupported integer size " + size);
      }
      this.writeOffset += size;
    };
    Accumulator.prototype.writeDouble = function(value) {
      this.reserve(8);
      if (isBigEndian) {
        this.buf.writeDoubleBE(value, this.writeOffset);
      } else {
        this.buf.writeDoubleLE(value, this.writeOffset);
      }
      this.writeOffset += 8;
    };
    var BSER_ARRAY = 0;
    var BSER_OBJECT = 1;
    var BSER_STRING = 2;
    var BSER_INT8 = 3;
    var BSER_INT16 = 4;
    var BSER_INT32 = 5;
    var BSER_INT64 = 6;
    var BSER_REAL = 7;
    var BSER_TRUE = 8;
    var BSER_FALSE = 9;
    var BSER_NULL = 10;
    var BSER_TEMPLATE = 11;
    var BSER_SKIP = 12;
    var ST_NEED_PDU = 0;
    var ST_FILL_PDU = 1;
    var MAX_INT8 = 127;
    var MAX_INT16 = 32767;
    var MAX_INT32 = 2147483647;
    function BunserBuf() {
      EE.call(this);
      this.buf = new Accumulator();
      this.state = ST_NEED_PDU;
    }
    util.inherits(BunserBuf, EE);
    exports2.BunserBuf = BunserBuf;
    BunserBuf.prototype.append = function(buf, synchronous) {
      if (synchronous) {
        this.buf.append(buf);
        return this.process(synchronous);
      }
      try {
        this.buf.append(buf);
      } catch (err) {
        this.emit("error", err);
        return;
      }
      this.processLater();
    };
    BunserBuf.prototype.processLater = function() {
      var self = this;
      process.nextTick(function() {
        try {
          self.process(false);
        } catch (err) {
          self.emit("error", err);
        }
      });
    };
    BunserBuf.prototype.process = function(synchronous) {
      if (this.state == ST_NEED_PDU) {
        if (this.buf.readAvail() < 2) {
          return;
        }
        this.expectCode(0);
        this.expectCode(1);
        this.pduLen = this.decodeInt(
          true
          /* relaxed */
        );
        if (this.pduLen === false) {
          this.buf.readAdvance(-2);
          return;
        }
        this.buf.reserve(this.pduLen);
        this.state = ST_FILL_PDU;
      }
      if (this.state == ST_FILL_PDU) {
        if (this.buf.readAvail() < this.pduLen) {
          return;
        }
        var val = this.decodeAny();
        if (synchronous) {
          return val;
        }
        this.emit("value", val);
        this.state = ST_NEED_PDU;
      }
      if (!synchronous && this.buf.readAvail() > 0) {
        this.processLater();
      }
    };
    BunserBuf.prototype.raise = function(reason) {
      throw new Error(reason + ", in Buffer of length " + this.buf.buf.length + " (" + this.buf.readAvail() + " readable) at offset " + this.buf.readOffset + " buffer: " + JSON.stringify(this.buf.buf.slice(
        this.buf.readOffset,
        this.buf.readOffset + 32
      ).toJSON()));
    };
    BunserBuf.prototype.expectCode = function(expected) {
      var code = this.buf.readInt(1);
      if (code != expected) {
        this.raise("expected bser opcode " + expected + " but got " + code);
      }
    };
    BunserBuf.prototype.decodeAny = function() {
      var code = this.buf.peekInt(1);
      switch (code) {
        case BSER_INT8:
        case BSER_INT16:
        case BSER_INT32:
        case BSER_INT64:
          return this.decodeInt();
        case BSER_REAL:
          this.buf.readAdvance(1);
          return this.buf.readDouble();
        case BSER_TRUE:
          this.buf.readAdvance(1);
          return true;
        case BSER_FALSE:
          this.buf.readAdvance(1);
          return false;
        case BSER_NULL:
          this.buf.readAdvance(1);
          return null;
        case BSER_STRING:
          return this.decodeString();
        case BSER_ARRAY:
          return this.decodeArray();
        case BSER_OBJECT:
          return this.decodeObject();
        case BSER_TEMPLATE:
          return this.decodeTemplate();
        default:
          this.raise("unhandled bser opcode " + code);
      }
    };
    BunserBuf.prototype.decodeArray = function() {
      this.expectCode(BSER_ARRAY);
      var nitems = this.decodeInt();
      var arr = [];
      for (var i = 0; i < nitems; ++i) {
        arr.push(this.decodeAny());
      }
      return arr;
    };
    BunserBuf.prototype.decodeObject = function() {
      this.expectCode(BSER_OBJECT);
      var nitems = this.decodeInt();
      var res = {};
      for (var i = 0; i < nitems; ++i) {
        var key = this.decodeString();
        var val = this.decodeAny();
        res[key] = val;
      }
      return res;
    };
    BunserBuf.prototype.decodeTemplate = function() {
      this.expectCode(BSER_TEMPLATE);
      var keys = this.decodeArray();
      var nitems = this.decodeInt();
      var arr = [];
      for (var i = 0; i < nitems; ++i) {
        var obj = {};
        for (var keyidx = 0; keyidx < keys.length; ++keyidx) {
          if (this.buf.peekInt(1) == BSER_SKIP) {
            this.buf.readAdvance(1);
            continue;
          }
          var val = this.decodeAny();
          obj[keys[keyidx]] = val;
        }
        arr.push(obj);
      }
      return arr;
    };
    BunserBuf.prototype.decodeString = function() {
      this.expectCode(BSER_STRING);
      var len = this.decodeInt();
      return this.buf.readString(len);
    };
    BunserBuf.prototype.decodeInt = function(relaxSizeAsserts) {
      if (relaxSizeAsserts && this.buf.readAvail() < 1) {
        return false;
      } else {
        this.buf.assertReadableSize(1);
      }
      var code = this.buf.peekInt(1);
      var size = 0;
      switch (code) {
        case BSER_INT8:
          size = 1;
          break;
        case BSER_INT16:
          size = 2;
          break;
        case BSER_INT32:
          size = 4;
          break;
        case BSER_INT64:
          size = 8;
          break;
        default:
          this.raise("invalid bser int encoding " + code);
      }
      if (relaxSizeAsserts && this.buf.readAvail() < 1 + size) {
        return false;
      }
      this.buf.readAdvance(1);
      return this.buf.readInt(size);
    };
    function loadFromBuffer(input) {
      var buf = new BunserBuf();
      var result = buf.append(input, true);
      if (buf.buf.readAvail()) {
        throw Error(
          "excess data found after input buffer, use BunserBuf instead"
        );
      }
      if (typeof result === "undefined") {
        throw Error(
          "no bser found in string and no error raised!?"
        );
      }
      return result;
    }
    exports2.loadFromBuffer = loadFromBuffer;
    function byteswap64(buf) {
      var swap = Buffer.alloc(buf.length);
      for (var i = 0; i < buf.length; i++) {
        swap[i] = buf[buf.length - 1 - i];
      }
      return swap;
    }
    function dump_int64(buf, val) {
      var be = val.toBuffer();
      if (isBigEndian) {
        buf.writeByte(BSER_INT64);
        buf.append(be);
        return;
      }
      var le = byteswap64(be);
      buf.writeByte(BSER_INT64);
      buf.append(le);
    }
    function dump_int(buf, val) {
      var abs = Math.abs(val);
      if (abs <= MAX_INT8) {
        buf.writeByte(BSER_INT8);
        buf.writeInt(val, 1);
      } else if (abs <= MAX_INT16) {
        buf.writeByte(BSER_INT16);
        buf.writeInt(val, 2);
      } else if (abs <= MAX_INT32) {
        buf.writeByte(BSER_INT32);
        buf.writeInt(val, 4);
      } else {
        dump_int64(buf, new Int64(val));
      }
    }
    function dump_any(buf, val) {
      switch (typeof val) {
        case "number":
          if (isFinite(val) && Math.floor(val) === val) {
            dump_int(buf, val);
          } else {
            buf.writeByte(BSER_REAL);
            buf.writeDouble(val);
          }
          return;
        case "string":
          buf.writeByte(BSER_STRING);
          dump_int(buf, Buffer.byteLength(val));
          buf.append(val);
          return;
        case "boolean":
          buf.writeByte(val ? BSER_TRUE : BSER_FALSE);
          return;
        case "object":
          if (val === null) {
            buf.writeByte(BSER_NULL);
            return;
          }
          if (val instanceof Int64) {
            dump_int64(buf, val);
            return;
          }
          if (Array.isArray(val)) {
            buf.writeByte(BSER_ARRAY);
            dump_int(buf, val.length);
            for (var i = 0; i < val.length; ++i) {
              dump_any(buf, val[i]);
            }
            return;
          }
          buf.writeByte(BSER_OBJECT);
          var keys = Object.keys(val);
          var num_keys = keys.length;
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var v = val[key];
            if (typeof v == "undefined") {
              num_keys--;
            }
          }
          dump_int(buf, num_keys);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var v = val[key];
            if (typeof v == "undefined") {
              continue;
            }
            dump_any(buf, key);
            try {
              dump_any(buf, v);
            } catch (e) {
              throw new Error(
                e.message + " (while serializing object property with name `" + key + "')"
              );
            }
          }
          return;
        default:
          throw new Error("cannot serialize type " + typeof val + " to BSER");
      }
    }
    function dumpToBuffer(val) {
      var buf = new Accumulator();
      buf.writeByte(0);
      buf.writeByte(1);
      buf.writeByte(BSER_INT32);
      buf.writeInt(0, 4);
      dump_any(buf, val);
      var off = buf.writeOffset;
      var len = off - 7;
      buf.writeOffset = 3;
      buf.writeInt(len, 4);
      buf.writeOffset = off;
      return buf.buf.slice(0, off);
    }
    exports2.dumpToBuffer = dumpToBuffer;
  }
});

// node_modules/fb-watchman/index.js
var require_fb_watchman = __commonJS({
  "node_modules/fb-watchman/index.js"(exports2, module2) {
    "use strict";
    var net2 = require("net");
    var EE = require("events").EventEmitter;
    var util = require("util");
    var childProcess = require("child_process");
    var bser = require_bser();
    var unilateralTags = ["subscription", "log"];
    function Client(options2) {
      var self = this;
      EE.call(this);
      this.watchmanBinaryPath = "watchman";
      if (options2 && options2.watchmanBinaryPath) {
        this.watchmanBinaryPath = options2.watchmanBinaryPath.trim();
      }
      ;
      this.commands = [];
    }
    util.inherits(Client, EE);
    module2.exports.Client = Client;
    Client.prototype.sendNextCommand = function() {
      if (this.currentCommand) {
        return;
      }
      this.currentCommand = this.commands.shift();
      if (!this.currentCommand) {
        return;
      }
      this.socket.write(bser.dumpToBuffer(this.currentCommand.cmd));
    };
    Client.prototype.cancelCommands = function(why) {
      var error = new Error(why);
      var cmds = this.commands;
      this.commands = [];
      if (this.currentCommand) {
        cmds.unshift(this.currentCommand);
        this.currentCommand = null;
      }
      cmds.forEach(function(cmd) {
        cmd.cb(error);
      });
    };
    Client.prototype.connect = function() {
      var self = this;
      function makeSock(sockname) {
        self.bunser = new bser.BunserBuf();
        self.bunser.on("value", function(obj) {
          var unilateral = false;
          for (var i = 0; i < unilateralTags.length; i++) {
            var tag = unilateralTags[i];
            if (tag in obj) {
              unilateral = tag;
            }
          }
          if (unilateral) {
            self.emit(unilateral, obj);
          } else if (self.currentCommand) {
            var cmd = self.currentCommand;
            self.currentCommand = null;
            if ("error" in obj) {
              var error = new Error(obj.error);
              error.watchmanResponse = obj;
              cmd.cb(error);
            } else {
              cmd.cb(null, obj);
            }
          }
          self.sendNextCommand();
        });
        self.bunser.on("error", function(err) {
          self.emit("error", err);
        });
        self.socket = net2.createConnection(sockname);
        self.socket.on("connect", function() {
          self.connecting = false;
          self.emit("connect");
          self.sendNextCommand();
        });
        self.socket.on("error", function(err) {
          self.connecting = false;
          self.emit("error", err);
        });
        self.socket.on("data", function(buf) {
          if (self.bunser) {
            self.bunser.append(buf);
          }
        });
        self.socket.on("end", function() {
          self.socket = null;
          self.bunser = null;
          self.cancelCommands("The watchman connection was closed");
          self.emit("end");
        });
      }
      if (process.env.WATCHMAN_SOCK) {
        makeSock(process.env.WATCHMAN_SOCK);
        return;
      }
      var args = ["--no-pretty", "get-sockname"];
      var proc = null;
      var spawnFailed = false;
      function spawnError(error) {
        if (spawnFailed) {
          return;
        }
        spawnFailed = true;
        if (error.code === "EACCES" || error.errno === "EACCES") {
          error.message = "The Watchman CLI is installed but cannot be spawned because of a permission problem";
        } else if (error.code === "ENOENT" || error.errno === "ENOENT") {
          error.message = "Watchman was not found in PATH.  See https://facebook.github.io/watchman/docs/install.html for installation instructions";
        }
        console.error("Watchman: ", error.message);
        self.emit("error", error);
      }
      try {
        proc = childProcess.spawn(this.watchmanBinaryPath, args, {
          stdio: ["ignore", "pipe", "pipe"],
          windowsHide: true
        });
      } catch (error) {
        spawnError(error);
        return;
      }
      var stdout = [];
      var stderr = [];
      proc.stdout.on("data", function(data) {
        stdout.push(data);
      });
      proc.stderr.on("data", function(data) {
        data = data.toString("utf8");
        stderr.push(data);
        console.error(data);
      });
      proc.on("error", function(error) {
        spawnError(error);
      });
      proc.on("close", function(code, signal) {
        if (code !== 0) {
          spawnError(new Error(
            self.watchmanBinaryPath + " " + args.join(" ") + " returned with exit code=" + code + ", signal=" + signal + ", stderr= " + stderr.join("")
          ));
          return;
        }
        try {
          var obj = JSON.parse(stdout.join(""));
          if ("error" in obj) {
            var error = new Error(obj.error);
            error.watchmanResponse = obj;
            self.emit("error", error);
            return;
          }
          makeSock(obj.sockname);
        } catch (e) {
          self.emit("error", e);
        }
      });
    };
    Client.prototype.command = function(args, done) {
      done = done || function() {
      };
      this.commands.push({ cmd: args, cb: done });
      if (!this.socket) {
        if (!this.connecting) {
          this.connecting = true;
          this.connect();
          return;
        }
        return;
      }
      this.sendNextCommand();
    };
    var cap_versions = {
      "cmd-watch-del-all": "3.1.1",
      "cmd-watch-project": "3.1",
      "relative_root": "3.3",
      "term-dirname": "3.1",
      "term-idirname": "3.1",
      "wildmatch": "3.7"
    };
    function vers_compare(a, b) {
      a = a.split(".");
      b = b.split(".");
      for (var i = 0; i < 3; i++) {
        var d = parseInt(a[i] || "0") - parseInt(b[i] || "0");
        if (d != 0) {
          return d;
        }
      }
      return 0;
    }
    function have_cap(vers, name2) {
      if (name2 in cap_versions) {
        return vers_compare(vers, cap_versions[name2]) >= 0;
      }
      return false;
    }
    Client.prototype._synthesizeCapabilityCheck = function(resp, optional, required) {
      resp.capabilities = {};
      var version2 = resp.version;
      optional.forEach(function(name2) {
        resp.capabilities[name2] = have_cap(version2, name2);
      });
      required.forEach(function(name2) {
        var have = have_cap(version2, name2);
        resp.capabilities[name2] = have;
        if (!have) {
          resp.error = "client required capability `" + name2 + "` is not supported by this server";
        }
      });
      return resp;
    };
    Client.prototype.capabilityCheck = function(caps, done) {
      var optional = caps.optional || [];
      var required = caps.required || [];
      var self = this;
      this.command(["version", {
        optional,
        required
      }], function(error, resp) {
        if (error) {
          done(error);
          return;
        }
        if (!("capabilities" in resp)) {
          resp = self._synthesizeCapabilityCheck(resp, optional, required);
          if (resp.error) {
            error = new Error(resp.error);
            error.watchmanResponse = resp;
            done(error);
            return;
          }
        }
        done(null, resp);
      });
    };
    Client.prototype.end = function() {
      this.cancelCommands("The client was ended");
      if (this.socket) {
        this.socket.end();
        this.socket = null;
      }
      this.bunser = null;
    };
  }
});

// src/core/watchman.ts
var logger14, requiredCapabilities, Watchman;
var init_watchman = __esm({
  "src/core/watchman.ts"() {
    "use strict";
    init_esm_node();
    init_logger();
    init_node();
    logger14 = createLogger("core-watchman");
    requiredCapabilities = ["relative_root", "cmd-watch-project", "wildmatch", "field-new"];
    Watchman = class _Watchman {
      constructor(binaryPath, channel) {
        this.channel = channel;
        this._disposed = false;
        const watchman = require_fb_watchman();
        this.client = new watchman.Client({
          watchmanBinaryPath: binaryPath
        });
        this.client.setMaxListeners(300);
      }
      checkCapability() {
        let { client } = this;
        return new Promise((resolve) => {
          client.capabilityCheck({
            optional: [],
            required: requiredCapabilities
          }, (error, resp) => {
            if (error) return resolve(false);
            let { capabilities } = resp;
            for (let key of Object.keys(capabilities)) {
              if (!capabilities[key]) return resolve(false);
            }
            resolve(true);
          });
        });
      }
      async watchProject(root) {
        let resp = await this.command(["watch-project", root]);
        let { watch, warning, relative_path } = resp;
        if (!watch) return false;
        if (warning) logger14.warn(warning);
        this.watch = watch;
        this.relative_path = relative_path;
        logger14.info(`watchman watching project: ${root}`);
        this.appendOutput(`watchman watching project: ${root}`);
        return true;
      }
      command(args) {
        return new Promise((resolve, reject) => {
          this.client.command(args, (error, resp) => {
            if (error) return reject(error);
            resolve(resp);
          });
        });
      }
      async subscribe(globPattern, cb) {
        let { watch, relative_path } = this;
        if (!watch) throw new Error("watchman not watching");
        let { clock } = await this.command(["clock", watch]);
        let uid = v1_default();
        let sub = {
          expression: ["allof", ["match", "**/*", "wholename"]],
          fields: ["name", "size", "new", "exists", "type", "mtime_ms", "ctime_ms"],
          since: clock
        };
        let root = watch;
        if (relative_path) {
          sub.relative_root = relative_path;
          root = path.join(watch, relative_path);
        }
        if (!this.client) return;
        let { subscribe } = await this.command(["subscribe", watch, uid, sub]);
        this.appendOutput(`subscribing "${globPattern}" in ${root}`);
        this.client.on("subscription", (resp) => {
          if (!resp || resp.subscription != uid) return;
          let { files } = resp;
          if (!files) return;
          files = files.filter((f) => f.type == "f" && minimatch(f.name, globPattern, { dot: true }));
          if (!files.length) return;
          let ev = Object.assign({}, resp);
          if (this.relative_path) ev.root = path.resolve(resp.root, this.relative_path);
          this.appendOutput(`file change detected: ${JSON.stringify(ev, null, 2)}`);
          cb(ev);
        });
        return {
          dispose: () => {
            void this.unsubscribe(subscribe);
          },
          subscribe
        };
      }
      unsubscribe(subscription) {
        if (this._disposed) return Promise.resolve();
        let { watch } = this;
        if (!watch) return;
        this.appendOutput(`unsubscribe "${subscription}" in: ${watch}`);
        return this.command(["unsubscribe", watch, subscription]).catch((e) => {
          if (e.message?.includes("The client was ended")) logger14.error(e);
        });
      }
      dispose() {
        if (this._disposed) return;
        this._disposed = true;
        if (this.client) {
          this.client.end();
          this.client = void 0;
        }
      }
      appendOutput(message, type = "Info") {
        if (this.channel) {
          this.channel.appendLine(`[${type}  - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}] ${message}`);
        }
      }
      static async createClient(binaryPath, root, channel) {
        let watchman;
        try {
          watchman = new _Watchman(binaryPath, channel);
          let valid = await watchman.checkCapability();
          if (!valid) throw new Error("required capabilities do not exist.");
          let watching = await watchman.watchProject(root);
          if (!watching) throw new Error("unable to watch");
          return watchman;
        } catch (e) {
          if (watchman) watchman.dispose();
          throw e;
        }
      }
    };
  }
});

// src/core/fileSystemWatcher.ts
var logger15, WATCHMAN_COMMAND, FileSystemWatcherManager, FileSystemWatcher;
var init_fileSystemWatcher = __esm({
  "src/core/fileSystemWatcher.ts"() {
    "use strict";
    init_esm();
    init_logger();
    init_util();
    init_array();
    init_fs();
    init_node();
    init_protocol();
    init_watchman();
    logger15 = createLogger("fileSystemWatcher");
    WATCHMAN_COMMAND = "watchman";
    FileSystemWatcherManager = class _FileSystemWatcherManager {
      constructor(workspaceFolder, config) {
        this.workspaceFolder = workspaceFolder;
        this.config = config;
        this.clientsMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.creating = /* @__PURE__ */ new Set();
        this._onDidCreateClient = new import_node4.Emitter();
        this.disabled = false;
        this.onDidCreateClient = this._onDidCreateClient.event;
        if (!config.enable) {
          this.disabled = true;
        }
      }
      static {
        this.watchers = /* @__PURE__ */ new Set();
      }
      attach(channel) {
        this.channel = channel;
        let createClient = (folder) => {
          let root = URI2.parse(folder.uri).fsPath;
          void this.createClient(root);
        };
        this.workspaceFolder.workspaceFolders.forEach((folder) => {
          createClient(folder);
        });
        this.workspaceFolder.onDidChangeWorkspaceFolders((e) => {
          e.added.forEach((folder) => {
            createClient(folder);
          });
          e.removed.forEach((folder) => {
            let root = URI2.parse(folder.uri).fsPath;
            let client = this.clientsMap.get(root);
            if (client) {
              this.clientsMap.delete(root);
              client.dispose();
            }
          });
        }, null, this.disposables);
      }
      waitClient(root) {
        if (this.clientsMap.has(root)) return Promise.resolve(this.clientsMap.get(root));
        return new Promise((resolve) => {
          let disposable = this.onDidCreateClient((r) => {
            if (r == root) {
              disposable.dispose();
              resolve(this.clientsMap.get(r));
            }
          });
        });
      }
      async createClient(root, skipCheck = false) {
        if (!skipCheck && (this.disabled || isFolderIgnored(root, this.config.ignoredFolders))) return;
        if (this.has(root)) return this.waitClient(root);
        try {
          this.creating.add(root);
          let watchmanPath = await this.getWatchmanPath();
          let client = await Watchman.createClient(watchmanPath, root, this.channel);
          this.creating.delete(root);
          this.clientsMap.set(root, client);
          for (let watcher of _FileSystemWatcherManager.watchers) {
            watcher.listen(root, client);
          }
          this._onDidCreateClient.fire(root);
          return client;
        } catch (e) {
          this.creating.delete(root);
          if (this.channel) this.channel.appendLine(`Error on create watchman client: ${e}`);
          return false;
        }
      }
      async getWatchmanPath() {
        let watchmanPath = this.config.watchmanPath ?? WATCHMAN_COMMAND;
        if (!process.env.WATCHMAN_SOCK) {
          watchmanPath = await which(watchmanPath, { all: false });
        }
        return watchmanPath;
      }
      has(root) {
        let curr = Array.from(this.clientsMap.keys());
        curr.push(...this.creating);
        return curr.some((r) => sameFile(r, root));
      }
      createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        let fileWatcher = new FileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
        let base = typeof globPattern === "string" ? void 0 : globPattern.baseUri.fsPath;
        for (let [root, client] of this.clientsMap.entries()) {
          if (base && isParentFolder(root, base, true)) {
            base = void 0;
          }
          fileWatcher.listen(root, client);
        }
        if (base) void this.createClient(base);
        _FileSystemWatcherManager.watchers.add(fileWatcher);
        return fileWatcher;
      }
      dispose() {
        this._onDidCreateClient.dispose();
        for (let client of this.clientsMap.values()) {
          if (client) client.dispose();
        }
        this.clientsMap.clear();
        _FileSystemWatcherManager.watchers.clear();
        disposeAll(this.disposables);
      }
    };
    FileSystemWatcher = class {
      constructor(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        this.globPattern = globPattern;
        this.ignoreCreateEvents = ignoreCreateEvents;
        this.ignoreChangeEvents = ignoreChangeEvents;
        this.ignoreDeleteEvents = ignoreDeleteEvents;
        this._onDidCreate = new import_node4.Emitter();
        this._onDidChange = new import_node4.Emitter();
        this._onDidDelete = new import_node4.Emitter();
        this._onDidRename = new import_node4.Emitter();
        this.disposables = [];
        this._disposed = false;
        this.onDidCreate = this._onDidCreate.event;
        this.onDidChange = this._onDidChange.event;
        this.onDidDelete = this._onDidDelete.event;
        this.onDidRename = this._onDidRename.event;
        this._onDidListen = new import_node4.Emitter();
        this.onDidListen = this._onDidListen.event;
      }
      listen(root, client) {
        let {
          globPattern,
          ignoreCreateEvents,
          ignoreChangeEvents,
          ignoreDeleteEvents
        } = this;
        let pattern;
        let basePath;
        if (typeof globPattern === "string") {
          pattern = globPattern;
        } else {
          pattern = globPattern.pattern;
          basePath = globPattern.baseUri.fsPath;
          if (!isParentFolder(root, basePath, true)) return;
        }
        const onChange = (change) => {
          let { root: root2, files } = change;
          if (basePath && !sameFile(root2, basePath)) {
            files = files.filter((f) => {
              if (f.type != "f") return false;
              let fullpath = path.join(root2, f.name);
              if (!isParentFolder(basePath, fullpath)) return false;
              return minimatch(path.relative(basePath, fullpath), pattern, { dot: true });
            });
          } else {
            files = files.filter((f) => f.type == "f" && minimatch(f.name, pattern, { dot: true }));
          }
          for (let file of files) {
            let uri = URI2.file(path.join(root2, file.name));
            if (!file.exists) {
              if (!ignoreDeleteEvents) this._onDidDelete.fire(uri);
            } else {
              if (file.new === true) {
                if (!ignoreCreateEvents) this._onDidCreate.fire(uri);
              } else {
                if (!ignoreChangeEvents) this._onDidChange.fire(uri);
              }
            }
          }
          if (files.length == 2 && files[0].exists !== files[1].exists) {
            let oldFile = files.find((o) => o.exists !== true);
            let newFile = files.find((o) => o.exists === true);
            if (oldFile.size == newFile.size) {
              this._onDidRename.fire({
                oldUri: URI2.file(path.join(root2, oldFile.name)),
                newUri: URI2.file(path.join(root2, newFile.name))
              });
            }
          }
          if (files.length > 2 && files.length % 2 == 0) {
            let [oldFiles, newFiles] = splitArray(files, (o) => o.exists === false);
            if (oldFiles.length == newFiles.length) {
              for (let oldFile of oldFiles) {
                let newFile = newFiles.find((o) => o.size == oldFile.size && o.mtime_ms == oldFile.mtime_ms);
                if (newFile) {
                  this._onDidRename.fire({
                    oldUri: URI2.file(path.join(root2, oldFile.name)),
                    newUri: URI2.file(path.join(root2, newFile.name))
                  });
                }
              }
            }
          }
        };
        client.subscribe(pattern, onChange).then((disposable) => {
          if (!disposable) return;
          this._onDidListen.fire();
          this.subscribe = disposable.subscribe;
          if (this._disposed) return disposable.dispose();
          this.disposables.push(disposable);
        }, (e) => {
          if (e instanceof Error && e.message.includes("client was ended")) return;
          logger15.error(`Error on subscribe ${pattern}`, e);
        });
      }
      dispose() {
        this._disposed = true;
        FileSystemWatcherManager.watchers.delete(this);
        this._onDidRename.dispose();
        this._onDidCreate.dispose();
        this._onDidChange.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/model/highlighter.ts
var Highlighter;
var init_highlighter = __esm({
  "src/model/highlighter.ts"() {
    "use strict";
    init_ansiparse();
    init_string();
    Highlighter = class {
      constructor() {
        this.lines = [];
        this._highlights = [];
      }
      addLine(line, hlGroup) {
        if (line.includes("\n")) {
          for (let content of line.split(/\r?\n/)) {
            this.addLine(content, hlGroup);
          }
          return;
        }
        if (hlGroup) {
          this._highlights.push({
            lnum: this.lines.length,
            colStart: line.match(/^\s*/)[0].length,
            colEnd: byteLength(line),
            hlGroup
          });
        }
        if (line.includes("\x1B")) {
          let res = parseAnsiHighlights(line);
          for (let hl of res.highlights) {
            let { span, hlGroup: hlGroup2 } = hl;
            this._highlights.push({
              lnum: this.lines.length,
              colStart: span[0],
              colEnd: span[1],
              hlGroup: hlGroup2
            });
          }
          this.lines.push(res.line);
        } else {
          this.lines.push(line);
        }
      }
      addLines(lines) {
        this.lines.push(...lines);
      }
      /**
       * Add texts to new Lines
       */
      addTexts(items) {
        let len = this.lines.length;
        let text = "";
        for (let item of items) {
          let colStart = byteLength(text);
          if (item.hlGroup) {
            this._highlights.push({
              lnum: len,
              colStart,
              colEnd: colStart + byteLength(item.text),
              hlGroup: item.hlGroup
            });
          }
          text += item.text;
        }
        this.lines.push(text);
      }
      addText(text, hlGroup) {
        if (!text) return;
        let { lines } = this;
        let pre = lines[lines.length - 1] || "";
        if (text.includes("\n")) {
          let parts = text.split("\n");
          this.addText(parts[0], hlGroup);
          for (let line of parts.slice(1)) {
            this.addLine(line, hlGroup);
          }
          return;
        }
        if (hlGroup) {
          let colStart = byteLength(pre);
          this._highlights.push({
            lnum: lines.length ? lines.length - 1 : 0,
            colStart,
            colEnd: colStart + byteLength(text),
            hlGroup
          });
        }
        if (lines.length) {
          lines[lines.length - 1] = `${pre}${text}`;
        } else {
          lines.push(text);
        }
      }
      get length() {
        return this.lines.length;
      }
      getline(line) {
        return this.lines[line] || "";
      }
      get highlights() {
        return this._highlights;
      }
      get content() {
        return this.lines.join("\n");
      }
      // default to replace
      render(buffer, start = 0, end = -1) {
        buffer.setLines(this.lines, { start, end, strictIndexing: false }, true);
        for (let item of this._highlights) {
          buffer.addHighlight({
            hlGroup: item.hlGroup,
            colStart: item.colStart,
            colEnd: item.colEnd,
            line: start + item.lnum,
            srcId: -1
          });
        }
      }
    };
  }
});

// src/model/editInspect.ts
function getOriginalLine(item, change) {
  if (typeof item.lnum !== "number") return void 0;
  let lnum = item.lnum;
  if (change) {
    let edits = mergeSortEdits(change.edits);
    let pos = getPositionFromEdits(Position.create(lnum - 1, 0), edits);
    lnum = pos.line + 1;
  }
  return lnum;
}
function grouByAnnotation(changes, annotations) {
  let map = /* @__PURE__ */ new Map();
  for (let change of changes) {
    let id2 = getAnnotationKey(change) ?? null;
    let key = id2 ? annotations[id2]?.label : null;
    let arr = map.get(key);
    if (arr) {
      arr.push(change);
    } else {
      map.set(key, [change]);
    }
  }
  return map;
}
var global_id, EditInspect;
var init_editInspect = __esm({
  "src/model/editInspect.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_events();
    init_util();
    init_array();
    init_fs();
    init_node();
    init_textedit();
    init_highlighter();
    global_id = 0;
    EditInspect = class {
      constructor(nvim, keymaps) {
        this.nvim = nvim;
        this.keymaps = keymaps;
        this.disposables = [];
        this.items = [];
        this.renameMap = /* @__PURE__ */ new Map();
        events_default.on("BufUnload", (bufnr) => {
          if (bufnr == this.bufnr) this.dispose();
        }, null, this.disposables);
      }
      addFile(filepath, highlighter, lnum) {
        this.items.push({
          index: highlighter.length,
          filepath,
          lnum
        });
      }
      async show(state) {
        let { nvim } = this;
        let id2 = global_id++;
        nvim.pauseNotification();
        nvim.command(`tabe +setl\\ buftype=nofile CocWorkspaceEdit${id2}`, true);
        nvim.command(`setl bufhidden=wipe nolist`, true);
        nvim.command("setl nobuflisted wrap undolevels=-1 filetype=cocedits noswapfile", true);
        await nvim.resumeNotification(true);
        let buffer = await nvim.buffer;
        let cwd2 = await nvim.call("getcwd");
        this.bufnr = buffer.id;
        const relpath = (uri) => {
          let fsPath2 = URI2.parse(uri).fsPath;
          return isParentFolder(cwd2, fsPath2, true) ? path.relative(cwd2, fsPath2) : fsPath2;
        };
        const absPath = (filepath) => {
          return path.isAbsolute(filepath) ? filepath : path.join(cwd2, filepath);
        };
        let highlighter = new Highlighter();
        let changes = toArray(state.edit.documentChanges);
        let map = grouByAnnotation(changes, state.edit.changeAnnotations ?? {});
        for (let [label, changes2] of map.entries()) {
          if (label) {
            highlighter.addLine(label, "MoreMsg");
            highlighter.addLine("");
          }
          for (let change of changes2) {
            if (TextDocumentEdit.is(change)) {
              let linesChange = state.changes[change.textDocument.uri];
              let fsPath2 = relpath(change.textDocument.uri);
              highlighter.addTexts([
                { text: "Change", hlGroup: "Title" },
                { text: " " },
                { text: fsPath2, hlGroup: "Directory" },
                { text: `:${linesChange.lnum}`, hlGroup: "LineNr" }
              ]);
              this.addFile(fsPath2, highlighter, linesChange.lnum);
              highlighter.addLine("");
              this.addChangedLines(highlighter, linesChange, fsPath2, linesChange.lnum);
              highlighter.addLine("");
            } else if (CreateFile.is(change) || DeleteFile.is(change)) {
              let title = DeleteFile.is(change) ? "Delete" : "Create";
              let fsPath2 = relpath(change.uri);
              highlighter.addTexts([
                { text: title, hlGroup: "Title" },
                { text: " " },
                { text: fsPath2, hlGroup: "Directory" }
              ]);
              this.addFile(fsPath2, highlighter);
              highlighter.addLine("");
            } else if (RenameFile.is(change)) {
              let oldPath = relpath(change.oldUri);
              let newPath = relpath(change.newUri);
              highlighter.addTexts([
                { text: "Rename", hlGroup: "Title" },
                { text: " " },
                { text: oldPath, hlGroup: "Directory" },
                { text: "->", hlGroup: "Comment" },
                { text: newPath, hlGroup: "Directory" }
              ]);
              this.renameMap.set(oldPath, newPath);
              this.addFile(newPath, highlighter);
              highlighter.addLine("");
            }
          }
        }
        nvim.pauseNotification();
        highlighter.render(buffer);
        buffer.setOption("modifiable", false, true);
        await nvim.resumeNotification(true);
        this.disposables.push(this.keymaps.registerLocalKeymap(buffer.id, "n", "<CR>", async () => {
          let lnum = await nvim.call("line", ".");
          let col = await nvim.call("col", ".");
          let find;
          for (let i = this.items.length - 1; i >= 0; i--) {
            let item = this.items[i];
            if (lnum >= item.index) {
              find = item;
              break;
            }
          }
          if (!find) return;
          let uri = URI2.file(absPath(find.filepath)).toString();
          let filepath = this.renameMap.has(find.filepath) ? this.renameMap.get(find.filepath) : find.filepath;
          await nvim.call("coc#util#open_file", ["tab drop", absPath(filepath)]);
          let documentChanges = toArray(state.edit.documentChanges);
          let change = documentChanges.find((o) => TextDocumentEdit.is(o) && o.textDocument.uri == uri);
          let originLine = getOriginalLine(find, change);
          if (originLine !== void 0) await nvim.call("cursor", [originLine, col]);
          nvim.redrawVim();
        }, true));
        this.disposables.push(this.keymaps.registerLocalKeymap(buffer.id, "n", "<esc>", async () => {
          nvim.command("bwipeout!", true);
        }, true));
      }
      addChangedLines(highlighter, linesChange, fsPath2, lnum) {
        let diffs = fastDiff(linesChange.oldLines.join("\n"), linesChange.newLines.join("\n"));
        for (let i = 0; i < diffs.length; i++) {
          let diff = diffs[i];
          if (diff[0] == fastDiff.EQUAL) {
            let text = diff[1];
            if (!text.includes("\n")) {
              highlighter.addText(text);
            } else {
              let parts = text.split("\n");
              highlighter.addText(parts[0]);
              let curr = lnum + parts.length - 1;
              highlighter.addLine("");
              highlighter.addTexts([
                { text: "Change", hlGroup: "Title" },
                { text: " " },
                { text: fsPath2, hlGroup: "Directory" },
                { text: `:${curr}`, hlGroup: "LineNr" }
              ]);
              this.addFile(fsPath2, highlighter, curr);
              highlighter.addLine("");
              let last = parts[parts.length - 1];
              highlighter.addText(last);
            }
            lnum += text.split("\n").length - 1;
          } else if (diff[0] == fastDiff.DELETE) {
            lnum += diff[1].split("\n").length - 1;
            highlighter.addText(diff[1], "DiffDelete");
          } else {
            highlighter.addText(diff[1], "DiffAdd");
          }
        }
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/core/files.ts
function fileMatch(root, relpath, pattern) {
  let filepath = path.join(root, relpath);
  if (typeof pattern !== "string") {
    let base = pattern.baseUri.fsPath;
    if (!isParentFolder(base, filepath)) return false;
    let rp = path.relative(base, filepath);
    return minimatch(rp, pattern.pattern, { dot: true });
  }
  return minimatch(relpath, pattern, { dot: true });
}
function fsPath(uri) {
  return URI2.parse(uri).fsPath;
}
var logger16, Files;
var init_files = __esm({
  "src/core/files.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_events();
    init_logger();
    init_editInspect();
    init_errors();
    init_fs();
    init_node();
    init_protocol();
    init_string();
    init_textedit();
    logger16 = createLogger("core-files");
    Files = class {
      constructor(documents, configurations, workspaceFolderControl, keymaps) {
        this.documents = documents;
        this.configurations = configurations;
        this.workspaceFolderControl = workspaceFolderControl;
        this.keymaps = keymaps;
        this.operationTimeout = 500;
        this._onDidCreateFiles = new import_node4.Emitter();
        this._onDidRenameFiles = new import_node4.Emitter();
        this._onDidDeleteFiles = new import_node4.Emitter();
        this._onWillCreateFiles = new import_node4.Emitter();
        this._onWillRenameFiles = new import_node4.Emitter();
        this._onWillDeleteFiles = new import_node4.Emitter();
        this.onDidCreateFiles = this._onDidCreateFiles.event;
        this.onDidRenameFiles = this._onDidRenameFiles.event;
        this.onDidDeleteFiles = this._onDidDeleteFiles.event;
        this.onWillCreateFiles = this._onWillCreateFiles.event;
        this.onWillRenameFiles = this._onWillRenameFiles.event;
        this.onWillDeleteFiles = this._onWillDeleteFiles.event;
      }
      attach(nvim, env, window2) {
        this.nvim = nvim;
        this.env = env;
        this.window = window2;
      }
      async openTextDocument(uri) {
        uri = typeof uri === "string" ? URI2.file(uri) : uri;
        let doc = this.documents.getDocument(uri.toString());
        if (doc) return doc;
        const scheme = uri.scheme;
        if (scheme == "file") {
          if (!fs.existsSync(uri.fsPath)) throw fileNotExists(uri.fsPath);
          fs.accessSync(uri.fsPath, fs.constants.R_OK);
        }
        if (scheme == "untitled") {
          await this.nvim.call("coc#util#open_file", ["tab drop", uri.path]);
          return await this.documents.document;
        }
        return await this.loadResource(uri.toString(), null);
      }
      async jumpTo(uri, position, openCommand) {
        if (!openCommand) openCommand = this.configurations.initialConfiguration.get("coc.preferences.jumpCommand", "edit");
        let { nvim } = this;
        let u = uri instanceof URI2 ? uri : URI2.parse(uri);
        let doc = this.documents.getDocument(u.with({ fragment: "" }).toString());
        let bufnr = doc ? doc.bufnr : -1;
        if (!position && u.scheme === "file" && u.fragment) {
          let parts = u.fragment.split(",");
          let lnum = parseInt(parts[0], 10);
          if (!isNaN(lnum)) {
            let col = parts.length > 0 && /^\d+$/.test(parts[1]) ? parseInt(parts[1], 10) : void 0;
            position = Position.create(lnum - 1, col == null ? 0 : col - 1);
          }
        }
        if (bufnr != -1 && openCommand == "edit") {
          nvim.pauseNotification();
          nvim.command(`silent! normal! m'`, true);
          nvim.command(`buffer ${bufnr}`, true);
          nvim.command(`if &filetype ==# '' | filetype detect | endif`, true);
          if (position) {
            let line = doc.getline(position.line);
            let col = byteIndex(line, position.character) + 1;
            nvim.call("cursor", [position.line + 1, col], true);
          }
          await nvim.resumeNotification(true);
        } else {
          let { fsPath: fsPath2, scheme } = u;
          let pos = position == null ? null : [position.line, position.character];
          if (scheme == "file") {
            let bufname = normalizeFilePath(fsPath2);
            await this.nvim.call("coc#util#jump", [openCommand, bufname, pos]);
          } else {
            await this.nvim.call("coc#util#jump", [openCommand, uri.toString(), pos]);
          }
        }
      }
      /**
       * Open resource by uri
       */
      async openResource(uri) {
        let { nvim } = this;
        let u = URI2.parse(uri);
        if (/^https?/.test(u.scheme)) {
          await nvim.call("coc#ui#open_url", uri);
          return;
        }
        await this.jumpTo(uri);
        await this.documents.document;
      }
      /**
       * Load uri as document.
       */
      async loadResource(uri, cmd) {
        let doc = this.documents.getDocument(uri);
        if (doc) return doc;
        if (cmd === void 0) {
          const preferences = this.configurations.getConfiguration("workspace");
          cmd = preferences.get("openResourceCommand", "tab drop");
        }
        let u = URI2.parse(uri);
        let bufname = u.scheme === "file" ? u.fsPath : uri;
        let bufnr;
        if (cmd) {
          let winid = await this.nvim.call("win_getid");
          bufnr = await this.nvim.call("coc#util#open_file", [cmd, bufname]);
          await this.nvim.call("win_gotoid", [winid]);
        } else {
          let arr = await this.nvim.call("coc#ui#open_files", [[bufname]]);
          bufnr = arr[0];
        }
        return await this.documents.createDocument(bufnr);
      }
      /**
       * Load the files that not loaded
       */
      async loadResources(uris) {
        let { documents } = this;
        let files = uris.map((uri) => {
          let u = URI2.parse(uri);
          return u.scheme == "file" ? u.fsPath : uri;
        });
        let bufnrs = await this.nvim.call("coc#ui#open_files", [files]);
        return await Promise.all(bufnrs.map((bufnr) => {
          return documents.createDocument(bufnr);
        }));
      }
      /**
       * Create a file in vim and disk
       */
      async createFile(filepath, opts = {}, recovers) {
        let { nvim } = this;
        let exists = fs.existsSync(filepath);
        if (exists && !opts.overwrite && !opts.ignoreIfExists) {
          throw fileExists(filepath);
        }
        if (!exists || opts.overwrite) {
          let tokenSource = new import_node4.CancellationTokenSource();
          await this.fireWaitUntilEvent(this._onWillCreateFiles, {
            files: [URI2.file(filepath)],
            token: tokenSource.token
          }, recovers);
          tokenSource.cancel();
          let dir = path.dirname(filepath);
          if (!fs.existsSync(dir)) {
            let folder;
            let curr = dir;
            while (![".", "/", path.parse(dir).root].includes(curr)) {
              if (fs.existsSync(path.dirname(curr))) {
                folder = curr;
                break;
              }
              curr = path.dirname(curr);
            }
            fs.mkdirSync(dir, { recursive: true });
            if (Array.isArray(recovers)) {
              recovers.push(() => {
                fs.rmSync(folder, { force: true, recursive: true });
              });
            }
          }
          fs.writeFileSync(filepath, "", "utf8");
          if (Array.isArray(recovers)) {
            recovers.push(() => {
              fs.rmSync(filepath, { force: true, recursive: true });
            });
          }
          let doc = await this.loadResource(filepath);
          let bufnr = doc.bufnr;
          if (Array.isArray(recovers)) {
            recovers.push(() => {
              void events_default.fire("BufUnload", [bufnr]);
              return nvim.command(`silent! bd! ${bufnr}`);
            });
          }
          this._onDidCreateFiles.fire({ files: [URI2.file(filepath)] });
        }
      }
      /**
       * Delete a file or folder from vim and disk.
       */
      async deleteFile(filepath, opts = {}, recovers) {
        let { ignoreIfNotExists, recursive } = opts;
        let stat = await statAsync(filepath);
        let isDir = stat && stat.isDirectory();
        if (!stat && !ignoreIfNotExists) {
          throw fileNotExists(filepath);
        }
        if (stat == null) return;
        let uri = URI2.file(filepath);
        await this.fireWaitUntilEvent(this._onWillDeleteFiles, { files: [uri] }, recovers);
        if (!isDir) {
          let bufnr = await this.nvim.call("bufnr", [filepath]);
          if (bufnr) {
            void events_default.fire("BufUnload", [bufnr]);
            await this.nvim.command(`silent! bwipeout ${bufnr}`);
            if (Array.isArray(recovers)) {
              recovers.push(() => {
                return this.loadResource(uri.toString());
              });
            }
          }
        }
        let folder = path.join(os.tmpdir(), "coc-" + process.pid);
        fs.mkdirSync(folder, { recursive: true });
        let md5 = crypto.createHash("md5").update(filepath).digest("hex");
        if (isDir && recursive) {
          let dest = path.join(folder, md5);
          let dir = path.dirname(filepath);
          fs.renameSync(filepath, dest);
          if (Array.isArray(recovers)) {
            recovers.push(async () => {
              fs.mkdirSync(dir, { recursive: true });
              fs.renameSync(dest, filepath);
            });
          }
        } else if (isDir) {
          fs.rmdirSync(filepath);
          if (Array.isArray(recovers)) {
            recovers.push(() => {
              fs.mkdirSync(filepath);
            });
          }
        } else {
          let dest = path.join(folder, md5);
          let dir = path.dirname(filepath);
          fs.renameSync(filepath, dest);
          if (Array.isArray(recovers)) {
            recovers.push(() => {
              fs.mkdirSync(dir, { recursive: true });
              fs.renameSync(dest, filepath);
            });
          }
        }
        this._onDidDeleteFiles.fire({ files: [uri] });
      }
      /**
       * Rename a file or folder on vim and disk
       */
      async renameFile(oldPath, newPath, opts = {}, recovers) {
        let { nvim } = this;
        let { overwrite, ignoreIfExists } = opts;
        if (newPath === oldPath) return;
        let exists = fs.existsSync(newPath);
        if (exists && ignoreIfExists && !overwrite) return;
        if (exists && !overwrite) throw fileExists(newPath);
        let oldStat = await statAsync(oldPath);
        let loaded = oldStat && oldStat.isDirectory() ? 0 : await nvim.call("bufloaded", [oldPath]);
        if (!loaded && !oldStat) throw fileNotExists(oldPath);
        let file = { newUri: URI2.parse(newPath), oldUri: URI2.parse(oldPath) };
        if (!opts.skipEvent) await this.fireWaitUntilEvent(this._onWillRenameFiles, { files: [file] }, recovers);
        if (loaded) {
          let bufnr = await nvim.call("coc#ui#rename_file", [oldPath, newPath, oldStat != null]);
          await this.documents.onBufCreate(bufnr);
        } else {
          if (oldStat.isDirectory()) {
            for (let doc of this.documents.attached("file")) {
              let u = URI2.parse(doc.uri);
              if (isParentFolder(oldPath, u.fsPath, false)) {
                let filepath = u.fsPath.replace(oldPath, newPath);
                let bufnr = await nvim.call("coc#ui#rename_file", [u.fsPath, filepath, false]);
                await this.documents.onBufCreate(bufnr);
              }
            }
          }
          fs.renameSync(oldPath, newPath);
        }
        if (Array.isArray(recovers)) {
          recovers.push(() => {
            return this.renameFile(newPath, oldPath, { skipEvent: true });
          });
        }
        if (!opts.skipEvent) this._onDidRenameFiles.fire({ files: [file] });
      }
      /**
       * Return denied annotations
       */
      async promptAnnotations(documentChanges, changeAnnotations) {
        let toConfirm = changeAnnotations ? getConfirmAnnotations(documentChanges, changeAnnotations) : [];
        let denied = [];
        for (let key of toConfirm) {
          let annotation = changeAnnotations[key];
          let res = await this.window.showMenuPicker(["Yes", "No"], {
            position: "center",
            title: "Confirm edits",
            content: annotation.label + (annotation.description ? " " + annotation.description : "")
          });
          if (res !== 0) denied.push(key);
        }
        return denied;
      }
      /**
       * Apply WorkspaceEdit.
       */
      async applyEdit(edit2, nested) {
        let documentChanges = toDocumentChanges(edit2);
        let recovers = [];
        let currentOnly = false;
        try {
          let denied = await this.promptAnnotations(documentChanges, edit2.changeAnnotations);
          if (denied.length > 0) documentChanges = createFilteredChanges(documentChanges, denied);
          let changes = {};
          let currentUri = await this.documents.getCurrentUri();
          currentOnly = documentChanges.every((o) => TextDocumentEdit.is(o) && o.textDocument.uri === currentUri);
          this.validateChanges(documentChanges);
          for (const change of documentChanges) {
            if (TextDocumentEdit.is(change)) {
              let { textDocument, edits } = change;
              let { uri } = textDocument;
              let doc = await this.loadResource(uri);
              let revertEdit = await doc.applyEdits(edits, false, uri === currentUri);
              if (revertEdit) {
                let version2 = doc.version;
                let { newText, range } = revertEdit;
                changes[uri] = {
                  uri,
                  lnum: range.start.line + 1,
                  newLines: doc.getLines(range.start.line, range.end.line),
                  oldLines: newText.endsWith("\n") ? newText.slice(0, -1).split("\n") : newText.split("\n")
                };
                recovers.push(async () => {
                  let doc2 = this.documents.getDocument(uri);
                  if (!doc2 || !doc2.attached || doc2.version !== version2) return;
                  await doc2.applyEdits([revertEdit]);
                  textDocument.version = doc2.version;
                });
              }
            } else if (CreateFile.is(change)) {
              await this.createFile(fsPath(change.uri), change.options, recovers);
            } else if (DeleteFile.is(change)) {
              await this.deleteFile(fsPath(change.uri), change.options, recovers);
            } else if (RenameFile.is(change)) {
              await this.renameFile(fsPath(change.oldUri), fsPath(change.newUri), change.options, recovers);
            }
          }
          if (recovers.length === 0) return true;
          if (!nested) this.editState = { edit: { documentChanges, changeAnnotations: edit2.changeAnnotations }, changes, recovers, applied: true };
          this.nvim.redrawVim();
        } catch (e) {
          logger16.error("Error on applyEdits:", edit2, e);
          if (!nested) void this.window.showErrorMessage(`Error on applyEdits: ${e}`);
          await this.undoChanges(recovers);
          return false;
        }
        if (nested || currentOnly) return true;
        void this.window.showInformationMessage(`Use ':wa' to save changes or ':CocCommand workspace.inspectEdit' to inspect.`);
        return true;
      }
      async undoChanges(recovers) {
        while (recovers.length > 0) {
          let fn = recovers.pop();
          await Promise.resolve(fn());
        }
      }
      async inspectEdit() {
        if (!this.editState) {
          void this.window.showWarningMessage("No workspace edit to inspect");
          return;
        }
        let inspect2 = new EditInspect(this.nvim, this.keymaps);
        await inspect2.show(this.editState);
      }
      async undoWorkspaceEdit() {
        let { editState } = this;
        if (!editState || !editState.applied) {
          void this.window.showWarningMessage(`No workspace edit to undo`);
          return;
        }
        editState.applied = false;
        await this.undoChanges(editState.recovers);
      }
      async redoWorkspaceEdit() {
        let { editState } = this;
        if (!editState || editState.applied) {
          void this.window.showWarningMessage(`No workspace edit to redo`);
          return;
        }
        this.editState = void 0;
        await this.applyEdit(editState.edit);
      }
      validateChanges(documentChanges) {
        let { documents } = this;
        for (let change of documentChanges) {
          if (TextDocumentEdit.is(change)) {
            let { uri, version: version2 } = change.textDocument;
            let doc = documents.getDocument(uri);
            if (typeof version2 === "number" && version2 > 0) {
              if (!doc) throw notLoaded(uri);
              if (doc.version != version2) throw new Error(`${uri} changed before apply edit`);
            } else if (!doc && !isFile(uri)) {
              throw badScheme(uri);
            }
          } else if (CreateFile.is(change) || DeleteFile.is(change)) {
            if (!isFile(change.uri)) throw badScheme(change.uri);
          } else if (RenameFile.is(change)) {
            if (!isFile(change.oldUri) || !isFile(change.newUri)) {
              throw badScheme(change.oldUri);
            }
          }
        }
      }
      async findFiles(include, exclude, maxResults, token) {
        let folders = this.workspaceFolderControl.workspaceFolders;
        if (token?.isCancellationRequested || !folders.length || maxResults === 0) return [];
        maxResults = maxResults ?? Infinity;
        let roots = folders.map((o) => URI2.parse(o.uri).fsPath);
        let pattern;
        if (typeof include !== "string") {
          pattern = include.pattern;
          roots = [include.baseUri.fsPath];
        } else {
          pattern = include;
        }
        let res = [];
        let exceed = false;
        const ac = new AbortController();
        if (token) {
          token.onCancellationRequested(() => {
            if (!ac.signal.aborted) ac.abort();
          });
        }
        for (let root of roots) {
          try {
            let files = await glob.glob(pattern, {
              signal: ac.signal,
              dot: true,
              cwd: root,
              nodir: true,
              absolute: false
            });
            if (token?.isCancellationRequested) break;
            for (let file of files) {
              if (exclude && fileMatch(root, file, exclude)) continue;
              res.push(URI2.file(path.join(root, file)));
              if (res.length === maxResults) {
                exceed = true;
                break;
              }
            }
            if (exceed) break;
          } catch (e) {
            if (e["name"] === "AbortError") {
              break;
            }
          }
        }
        return res;
      }
      async fireWaitUntilEvent(emitter, properties, recovers) {
        let firing = true;
        let promises = [];
        emitter.fire({
          ...properties,
          waitUntil: (thenable) => {
            if (!firing) throw shouldNotAsync("waitUntil");
            let tp = new Promise((resolve) => {
              setTimeout(resolve, this.operationTimeout);
            });
            let promise = Promise.race([thenable, tp]).then((edit2) => {
              if (edit2 && WorkspaceEdit.is(edit2)) {
                return this.applyEdit(edit2, true);
              }
            });
            promises.push(promise);
          }
        });
        firing = false;
        await Promise.all(promises);
      }
    };
  }
});

// src/core/keymaps.ts
function getKeymapModifier(mode, cmd) {
  if (cmd) return "<Cmd>";
  if (mode == "n" || mode == "o" || mode == "x" || mode == "v") return "<C-U>";
  if (mode == "i") return "<C-o>";
  if (mode == "s") return "<Esc>";
  return "<Cmd>";
}
function getBufnr(buffer) {
  return typeof buffer === "number" ? buffer : 0;
}
function toKeymapOption(option) {
  const conf = typeof option == "boolean" ? { sync: !option } : option;
  return Object.assign({ sync: true, cancel: true, silent: true }, conf);
}
var logger17, Keymaps;
var init_keymaps = __esm({
  "src/core/keymaps.ts"() {
    "use strict";
    init_logger();
    init_constants();
    init_protocol();
    init_string();
    logger17 = createLogger("core-keymaps");
    Keymaps = class {
      constructor() {
        this.keymaps = /* @__PURE__ */ new Map();
      }
      attach(nvim) {
        this.nvim = nvim;
      }
      async doKeymap(key, defaultReturn) {
        let keymap = this.keymaps.get(key) ?? this.keymaps.get("coc-" + key);
        if (!keymap) {
          logger17.error(`keymap for ${key} not found`);
          return defaultReturn;
        }
        let [fn, repeat2] = keymap;
        let res = await Promise.resolve(fn());
        if (repeat2) await this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-${key})", -1)`);
        if (res == null) return defaultReturn;
        return res;
      }
      /**
       * Register global <Plug>(coc-${key}) key mapping.
       */
      registerKeymap(modes, name2, fn, opts = {}) {
        if (!name2) throw new Error(`Invalid key ${name2} of registerKeymap`);
        let key = `coc-${name2}`;
        if (this.keymaps.has(key)) throw new Error(`keymap: "${name2}" already exists.`);
        const lhs = `<Plug>(${key})`;
        opts = Object.assign({ sync: true, cancel: true, silent: true, repeat: false }, opts);
        let { nvim } = this;
        this.keymaps.set(key, [fn, !!opts.repeat]);
        let method = opts.sync ? "request" : "notify";
        for (let mode of modes) {
          if (mode == "i") {
            const cancel = opts.cancel ? 1 : 0;
            nvim.setKeymap(mode, lhs, `coc#_insert_key('${method}', '${key}', ${cancel})`, {
              expr: true,
              noremap: true,
              silent: opts.silent
            });
          } else {
            nvim.setKeymap(mode, lhs, `:${getKeymapModifier(mode, opts.cmd)}call coc#rpc#${method}('doKeymap', ['${key}'])<cr>`, {
              noremap: true,
              silent: opts.silent
            });
          }
        }
        return import_node4.Disposable.create(() => {
          this.keymaps.delete(key);
          for (let m of modes) {
            nvim.deleteKeymap(m, lhs);
          }
        });
      }
      registerExprKeymap(mode, lhs, fn, buffer = false, cancel = true) {
        let bufnr = getBufnr(buffer);
        let id2 = `${mode}-${toBase64(lhs)}${buffer ? `-${bufnr}` : ""}`;
        let { nvim } = this;
        let rhs;
        if (mode == "i") {
          rhs = `coc#_insert_key('request', '${id2}', ${cancel ? "1" : "0"})`;
        } else {
          rhs = `coc#rpc#request('doKeymap', ['${id2}'])`;
        }
        let opts = { noremap: true, silent: true, expr: true, nowait: true };
        if (buffer !== false) {
          nvim.call("coc#compat#buf_add_keymap", [bufnr, mode, lhs, rhs, opts], true);
        } else {
          nvim.setKeymap(mode, lhs, rhs, opts);
        }
        this.keymaps.set(id2, [fn, false]);
        return import_node4.Disposable.create(() => {
          this.keymaps.delete(id2);
          if (buffer) {
            nvim.call("coc#compat#buf_del_keymap", [bufnr, mode, lhs], true);
          } else {
            nvim.deleteKeymap(mode, lhs);
          }
        });
      }
      registerLocalKeymap(bufnr, mode, lhs, fn, option) {
        let { nvim } = this;
        let buffer = nvim.createBuffer(bufnr);
        let id2 = `local-${bufnr}-${mode}-${toBase64(lhs)}`;
        const opts = toKeymapOption(option);
        this.keymaps.set(id2, [fn, !!opts.repeat]);
        const method = opts.sync ? "request" : "notify";
        const opt = { noremap: true, silent: opts.silent !== false };
        if (isVim && opts.special) opt.special = true;
        if (mode == "i") {
          const cancel = opts.cancel ? 1 : 0;
          opt.expr = true;
          buffer.setKeymap(mode, lhs, `coc#_insert_key('${method}', '${id2}', ${cancel})`, opt);
        } else {
          opt.nowait = true;
          const modify2 = getKeymapModifier(mode, opts.cmd);
          buffer.setKeymap(mode, lhs, `:${modify2}call coc#rpc#${method}('doKeymap', ['${id2}'])<CR>`, opt);
        }
        return import_node4.Disposable.create(() => {
          this.keymaps.delete(id2);
          buffer.deleteKeymap(mode, lhs);
        });
      }
    };
  }
});

// src/core/watchers.ts
var logger18, Watchers;
var init_watchers = __esm({
  "src/core/watchers.ts"() {
    "use strict";
    init_events();
    init_logger();
    init_util();
    init_protocol();
    init_string();
    logger18 = createLogger("watchers");
    Watchers = class {
      constructor() {
        this.optionCallbacks = /* @__PURE__ */ new Map();
        this.globalCallbacks = /* @__PURE__ */ new Map();
        this.disposables = [];
        events_default.on("OptionSet", async (changed, oldValue, newValue) => {
          let cbs = Array.from(this.optionCallbacks.get(changed) ?? []);
          await Promise.allSettled(cbs.map((cb) => {
            return (async () => {
              try {
                await Promise.resolve(cb(oldValue, newValue));
              } catch (e) {
                this.nvim.errWriteLine(`Error on OptionSet '${changed}': ${toErrorText(e)}`);
                logger18.error(`Error on OptionSet callback:`, e);
              }
            })();
          }));
        }, null, this.disposables);
        events_default.on("GlobalChange", async (changed, oldValue, newValue) => {
          let cbs = Array.from(this.globalCallbacks.get(changed) ?? []);
          await Promise.allSettled(cbs.map((cb) => {
            return (async () => {
              try {
                await Promise.resolve(cb(oldValue, newValue));
              } catch (e) {
                this.nvim.errWriteLine(`Error on GlobalChange '${changed}': ${toErrorText(e)}`);
                logger18.error(`Error on GlobalChange callback:`, e);
              }
            })();
          }));
        }, null, this.disposables);
      }
      get options() {
        return Array.from(this.optionCallbacks.keys());
      }
      attach(nvim, _env) {
        this.nvim = nvim;
      }
      /**
       * Watch for option change.
       */
      watchOption(key, callback, disposables) {
        let cbs = this.optionCallbacks.get(key);
        if (!cbs) {
          cbs = /* @__PURE__ */ new Set();
          this.optionCallbacks.set(key, cbs);
        }
        cbs.add(callback);
        let cmd = `autocmd! coc_dynamic_option OptionSet ${key} call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])`;
        this.nvim.command(cmd, true);
        let disposable = import_node4.Disposable.create(() => {
          let cbs2 = this.optionCallbacks.get(key);
          cbs2.delete(callback);
          if (cbs2.size === 0) this.nvim.command(`autocmd! coc_dynamic_option OptionSet ${key}`, true);
        });
        if (disposables) disposables.push(disposable);
        return disposable;
      }
      /**
       * Watch global variable, works on neovim only.
       */
      watchGlobal(key, callback, disposables) {
        let { nvim } = this;
        let cbs = this.globalCallbacks.get(key);
        if (!cbs) {
          cbs = /* @__PURE__ */ new Set();
          this.globalCallbacks.set(key, cbs);
        }
        cbs.add(callback);
        nvim.call("coc#_watch", key, true);
        let disposable = import_node4.Disposable.create(() => {
          let cbs2 = this.globalCallbacks.get(key);
          cbs2.delete(callback);
          if (cbs2.size === 0) nvim.call("coc#_unwatch", key, true);
        });
        if (disposables) disposables.push(disposable);
        return disposable;
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/core/workspaceFolder.ts
function toWorkspaceFolder(fsPath2) {
  if (!fsPath2 || !path.isAbsolute(fsPath2)) {
    logger19.error(`Invalid folder: ${fsPath2}, full path required.`);
    return void 0;
  }
  return {
    name: path.basename(fsPath2),
    uri: URI2.file(fsPath2).toString()
  };
}
var PatternType, logger19, PatternTypes, checkPatternTimeout, extensionRegistry3, WorkspaceFolderController;
var init_workspaceFolder = __esm({
  "src/core/workspaceFolder.ts"() {
    "use strict";
    init_esm();
    init_events();
    init_logger();
    init_util();
    init_array();
    init_errors();
    init_extensionRegistry();
    init_fs();
    init_node();
    init_object();
    init_protocol();
    init_registry();
    PatternType = /* @__PURE__ */ ((PatternType2) => {
      PatternType2[PatternType2["Buffer"] = 0] = "Buffer";
      PatternType2[PatternType2["LanguageServer"] = 1] = "LanguageServer";
      PatternType2[PatternType2["Global"] = 2] = "Global";
      return PatternType2;
    })(PatternType || {});
    logger19 = createLogger("core-workspaceFolder");
    PatternTypes = [0 /* Buffer */, 1 /* LanguageServer */, 2 /* Global */];
    checkPatternTimeout = getConditionValue(5e3, 50);
    extensionRegistry3 = Registry.as(Extensions.ExtensionContribution);
    WorkspaceFolderController = class {
      constructor(configurations) {
        this.configurations = configurations;
        this._onDidChangeWorkspaceFolders = new import_node4.Emitter();
        this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
        // filetype => patterns
        this.rootPatterns = /* @__PURE__ */ new Map();
        this._workspaceFolders = [];
        this._tokenSources = /* @__PURE__ */ new Set();
        events_default.on("VimLeavePre", this.cancelAll, this);
        this.updateConfiguration(true);
        this.configurations.onDidChange((e) => {
          if (e.affectsConfiguration("workspace") || e.affectsConfiguration("coc.preferences")) {
            this.updateConfiguration(false);
          }
        });
      }
      updateConfiguration(init) {
        const allConfig = this.configurations.initialConfiguration;
        let config = allConfig.get("workspace");
        let oldConfig = allConfig.get("coc.preferences.rootPatterns");
        this.config = {
          rootPatterns: isFalsyOrEmpty(oldConfig) ? toArray(config.rootPatterns) : oldConfig,
          ignoredFiletypes: toArray(config.ignoredFiletypes),
          bottomUpFiletypes: toArray(config.bottomUpFiletypes),
          ignoredFolders: toArray(config.ignoredFolders),
          workspaceFolderCheckCwd: !!config.workspaceFolderCheckCwd,
          workspaceFolderFallbackCwd: !!config.workspaceFolderFallbackCwd
        };
        if (init) {
          const lspConfig = allConfig.get("languageserver", {});
          this.addServerRootPatterns(lspConfig);
        }
      }
      addServerRootPatterns(lspConfig) {
        for (let key of Object.keys(toObject(lspConfig))) {
          let config = lspConfig[key];
          let { filetypes, rootPatterns } = config;
          if (Array.isArray(filetypes) && !isFalsyOrEmpty(rootPatterns)) {
            filetypes.filter((s) => typeof s === "string").forEach((filetype) => {
              this.addRootPattern(filetype, rootPatterns);
            });
          }
        }
      }
      cancelAll() {
        for (let tokenSource of this._tokenSources) {
          tokenSource.cancel();
        }
      }
      setWorkspaceFolders(folders) {
        if (!folders || !Array.isArray(folders)) return;
        let arr = folders.map((f) => toWorkspaceFolder(f));
        this._workspaceFolders = arr.filter((o) => o != null);
      }
      getWorkspaceFolder(uri) {
        if (uri.scheme !== "file") return void 0;
        let folders = Array.from(this._workspaceFolders).map((o) => URI2.parse(o.uri).fsPath);
        folders.sort((a, b) => b.length - a.length);
        let fsPath2 = uri.fsPath;
        let folder = folders.find((f) => isParentFolder(f, fsPath2, true));
        return toWorkspaceFolder(folder);
      }
      getRelativePath(pathOrUri, includeWorkspace) {
        let resource;
        let p = "";
        if (typeof pathOrUri === "string") {
          resource = URI2.file(pathOrUri);
          p = pathOrUri;
        } else if (pathOrUri != null) {
          resource = pathOrUri;
          p = pathOrUri.fsPath;
        }
        if (!resource) return p;
        const folder = this.getWorkspaceFolder(resource);
        if (!folder) return p;
        if (typeof includeWorkspace === "undefined" && this._workspaceFolders) {
          includeWorkspace = this._workspaceFolders.length > 1;
        }
        let result = path.relative(URI2.parse(folder.uri).fsPath, resource.fsPath);
        result = result == "" ? resource.fsPath : result;
        if (includeWorkspace && folder.name) {
          result = `${folder.name}/${result}`;
        }
        return result;
      }
      get workspaceFolders() {
        return this._workspaceFolders;
      }
      addRootPattern(filetype, rootPatterns) {
        let patterns = this.rootPatterns.get(filetype) ?? [];
        for (let p of rootPatterns) {
          if (!patterns.includes(p)) {
            patterns.push(p);
          }
        }
        this.rootPatterns.set(filetype, patterns);
      }
      resolveRoot(document2, cwd2, fireEvent, expand2) {
        if (document2.buftype !== "" || document2.schema !== "file") return null;
        let u = URI2.parse(document2.uri);
        let dir = isDirectory(u.fsPath) ? path.normalize(u.fsPath) : path.dirname(u.fsPath);
        let { ignoredFiletypes, ignoredFolders, workspaceFolderCheckCwd, workspaceFolderFallbackCwd, bottomUpFiletypes } = this.config;
        if (ignoredFiletypes?.includes(document2.filetype)) return null;
        ignoredFolders = Array.isArray(ignoredFolders) ? ignoredFolders.filter((s) => s && s.length > 0).map((s) => expand2(s)) : [];
        let res = null;
        for (let patternType of PatternTypes) {
          let patterns = this.getRootPatterns(document2, patternType);
          if (patterns && patterns.length) {
            let isBottomUp = bottomUpFiletypes.includes("*") || bottomUpFiletypes.includes(document2.filetype);
            let root = resolveRoot(dir, patterns, cwd2, isBottomUp, workspaceFolderCheckCwd, ignoredFolders);
            if (root) {
              res = root;
              break;
            }
          }
        }
        if (!res && workspaceFolderFallbackCwd && !isFolderIgnored(cwd2, ignoredFolders) && isParentFolder(cwd2, dir, true)) {
          res = cwd2;
        }
        if (res) this.addWorkspaceFolder(res, fireEvent);
        return res;
      }
      addWorkspaceFolder(folder, fireEvent) {
        let workspaceFolder = toWorkspaceFolder(folder);
        if (!workspaceFolder) return void 0;
        if (this._workspaceFolders.findIndex((o) => o.uri == workspaceFolder.uri) == -1) {
          this._workspaceFolders.push(workspaceFolder);
          if (fireEvent) {
            this._onDidChangeWorkspaceFolders.fire({
              added: [workspaceFolder],
              removed: []
            });
          }
        }
        return workspaceFolder;
      }
      renameWorkspaceFolder(oldPath, newPath) {
        let added = toWorkspaceFolder(newPath);
        if (!added) return;
        let idx = this._workspaceFolders.findIndex((f) => URI2.parse(f.uri).fsPath == oldPath);
        if (idx == -1) return;
        let removed = this.workspaceFolders[idx];
        this._workspaceFolders.splice(idx, 1, added);
        this._onDidChangeWorkspaceFolders.fire({
          removed: [removed],
          added: [added]
        });
      }
      removeWorkspaceFolder(fsPath2) {
        let removed = toWorkspaceFolder(fsPath2);
        if (!removed) return;
        let idx = this._workspaceFolders.findIndex((f) => f.uri == removed.uri);
        if (idx == -1) return;
        this._workspaceFolders.splice(idx, 1);
        this._onDidChangeWorkspaceFolders.fire({
          removed: [removed],
          added: []
        });
      }
      onDocumentDetach(uris) {
        let shouldCheck = this.configurations.initialConfiguration.get("workspace.removeEmptyWorkspaceFolder", false);
        if (!shouldCheck) return;
        let filepaths = [];
        for (const uri of uris) {
          if (uri.scheme === "file") {
            filepaths.push(uri.fsPath);
          }
        }
        for (const item of this.workspaceFolders) {
          const folder = URI2.parse(item.uri).fsPath;
          if (!filepaths.some((f) => isParentFolder(folder, f))) {
            this.removeWorkspaceFolder(folder);
            return;
          }
        }
      }
      getRootPatterns(document2, patternType) {
        if (patternType == 0 /* Buffer */) return document2.getVar("root_patterns", []);
        if (patternType == 1 /* LanguageServer */) return this.getServerRootPatterns(document2.languageId);
        return this.config.rootPatterns;
      }
      reset() {
        this.rootPatterns.clear();
        this._workspaceFolders = [];
      }
      /**
       * Get rootPatterns of filetype by languageserver configuration and extension configuration.
       */
      getServerRootPatterns(filetype) {
        let patterns = extensionRegistry3.getRootPatternsByFiletype(filetype);
        patterns = patterns.concat(toArray(this.rootPatterns.get(filetype)));
        return distinct(patterns);
      }
      checkFolder(dir, patterns, token) {
        return checkFolder(dir, patterns, token);
      }
      async checkPatterns(folders, patterns) {
        if (isFalsyOrEmpty(folders)) return false;
        let dirs = folders.map((f) => URI2.parse(f.uri).fsPath);
        let find = false;
        let tokenSource = new import_node4.CancellationTokenSource();
        this._tokenSources.add(tokenSource);
        let token = tokenSource.token;
        let timer = setTimeout(() => {
          tokenSource.cancel();
        }, checkPatternTimeout);
        let results = await Promise.allSettled(dirs.map((dir) => {
          return this.checkFolder(dir, patterns, token).then((checked) => {
            this._tokenSources.delete(tokenSource);
            if (checked) {
              find = true;
              clearTimeout(timer);
              tokenSource.cancel();
            }
          });
        }));
        clearTimeout(timer);
        results.forEach((res) => {
          if (res.status === "rejected" && !isCancellationError(res.reason)) {
            logger19.error(`checkPatterns error:`, patterns, res.reason);
          }
        });
        return find;
      }
    };
  }
});

// src/model/bufferSync.ts
var BufferSync;
var init_bufferSync = __esm({
  "src/model/bufferSync.ts"() {
    "use strict";
    init_events();
    init_util();
    init_is();
    BufferSync = class {
      constructor(_create, documents) {
        this._create = _create;
        this.disposables = [];
        this.itemsMap = /* @__PURE__ */ new Map();
        let { disposables } = this;
        for (let doc of documents.attached()) {
          this.create(doc);
        }
        documents.onDidOpenTextDocument((e) => {
          this.create(documents.getDocument(e.bufnr));
        }, null, disposables);
        documents.onDidChangeDocument((e) => {
          this.onChange(e);
        }, null, disposables);
        documents.onDidCloseDocument((e) => {
          this.delete(e.bufnr);
        }, null, disposables);
        events_default.on("LinesChanged", this.onTextChange, this, disposables);
        events_default.on("WindowVisible", this.onVisible, this, disposables);
      }
      onTextChange(bufnr) {
        let o = this.itemsMap.get(bufnr);
        if (o && func(o.item.onTextChange)) {
          o.item.onTextChange();
        }
      }
      onVisible(ev) {
        let o = this.itemsMap.get(ev.bufnr);
        if (o && typeof o.item.onVisible === "function") {
          o.item.onVisible(ev.winid, ev.region);
        }
      }
      get items() {
        return Array.from(this.itemsMap.values()).map((x) => x.item);
      }
      getItem(bufnr) {
        if (bufnr == null) return void 0;
        if (typeof bufnr === "number") {
          return this.itemsMap.get(bufnr)?.item;
        }
        let o = Array.from(this.itemsMap.values()).find((v) => {
          return v.uri == bufnr;
        });
        return o ? o.item : void 0;
      }
      create(doc) {
        let o = this.itemsMap.get(doc.bufnr);
        if (o) o.item.dispose();
        let item = this._create(doc);
        if (item) this.itemsMap.set(doc.bufnr, { uri: doc.uri, item });
      }
      onChange(e) {
        let o = this.itemsMap.get(e.bufnr);
        if (o && typeof o.item.onChange == "function") {
          o.item.onChange(e);
        }
      }
      delete(bufnr) {
        let o = this.itemsMap.get(bufnr);
        if (o) {
          o.item.dispose();
          this.itemsMap.delete(bufnr);
        }
      }
      reset() {
        for (let o of this.itemsMap.values()) {
          o.item.dispose();
        }
        this.itemsMap.clear();
      }
      dispose() {
        disposeAll(this.disposables);
        for (let o of this.itemsMap.values()) {
          o.item.dispose();
        }
        this._create = void 0;
        this.itemsMap.clear();
      }
    };
  }
});

// src/model/db.ts
var DB;
var init_db = __esm({
  "src/model/db.ts"() {
    "use strict";
    init_node();
    init_object();
    DB = class {
      constructor(filepath) {
        this.filepath = filepath;
      }
      /**
       * Get data by key.
       * @param {string} key unique key allows dot notation.
       * @returns {any}
       */
      fetch(key) {
        let obj = this.load();
        if (!key) return obj;
        let parts = key.split(".");
        for (let part of parts) {
          if (typeof obj[part] === "undefined") {
            return void 0;
          }
          obj = obj[part];
        }
        return obj;
      }
      /**
       * Check if key exists
       * @param {string} key unique key allows dot notation.
       */
      exists(key) {
        let obj = this.load();
        let parts = key.split(".");
        for (let part of parts) {
          if (typeof obj[part] === "undefined") {
            return false;
          }
          obj = obj[part];
        }
        return true;
      }
      /**
       * Delete data by key
       * @param {string} key unique key allows dot notation.
       */
      delete(key) {
        let obj = this.load();
        let origin = obj;
        let parts = key.split(".");
        let len = parts.length;
        for (let i = 0; i < len; i++) {
          if (typeof obj[parts[i]] === "undefined") {
            break;
          }
          if (i == len - 1) {
            delete obj[parts[i]];
            fs.writeFileSync(this.filepath, JSON.stringify(origin, null, 2), "utf8");
            break;
          }
          obj = obj[parts[i]];
        }
      }
      /**
       * Save data with key
       * @param {string} key unique string that allows dot notation.
       * @param {number|null|boolean|string|{[index} data saved data.
       */
      push(key, data) {
        let origin = toObject(this.load());
        let obj = origin;
        let parts = key.split(".");
        let len = parts.length;
        for (let i = 0; i < len; i++) {
          let key2 = parts[i];
          if (i == len - 1) {
            obj[key2] = data;
            let dir = path.dirname(this.filepath);
            fs.mkdirSync(dir, { recursive: true });
            fs.writeFileSync(this.filepath, JSON.stringify(origin, null, 2));
            break;
          }
          if (typeof obj[key2] == "undefined") {
            obj[key2] = {};
            obj = obj[key2];
          } else {
            obj = obj[key2];
          }
        }
      }
      load() {
        let dir = path.dirname(this.filepath);
        let exists = fs.existsSync(dir);
        if (!exists) {
          fs.mkdirSync(dir, { recursive: true });
          fs.writeFileSync(this.filepath, "{}", "utf8");
          return {};
        }
        try {
          let content = fs.readFileSync(this.filepath, "utf8");
          return JSON.parse(content.trim());
        } catch (e) {
          fs.writeFileSync(this.filepath, "{}", "utf8");
          return {};
        }
      }
      /**
       * Empty db file.
       */
      clear() {
        let exists = fs.existsSync(this.filepath);
        if (!exists) return;
        fs.writeFileSync(this.filepath, "{}", "utf8");
      }
      /**
       * Remove db file.
       */
      destroy() {
        if (fs.existsSync(this.filepath)) {
          fs.unlinkSync(this.filepath);
        }
      }
    };
  }
});

// src/model/status.ts
var frames, StatusLine;
var init_status = __esm({
  "src/model/status.ts"() {
    "use strict";
    init_esm_node();
    frames = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
    StatusLine = class {
      constructor() {
        this.items = /* @__PURE__ */ new Map();
        this.shownIds = /* @__PURE__ */ new Set();
        this._text = "";
        this.interval = setInterval(() => {
          this.setStatusText();
        }, 100).unref();
      }
      dispose() {
        this.items.clear();
        this.shownIds.clear();
        clearInterval(this.interval);
      }
      reset() {
        this.items.clear();
        this.shownIds.clear();
      }
      createStatusBarItem(priority, isProgress = false) {
        let uid = v1_default();
        let item = {
          text: "",
          priority,
          isProgress,
          show: () => {
            this.shownIds.add(uid);
            this.setStatusText();
          },
          hide: () => {
            this.shownIds.delete(uid);
            this.setStatusText();
          },
          dispose: () => {
            this.shownIds.delete(uid);
            this.items.delete(uid);
            this.setStatusText();
          }
        };
        this.items.set(uid, item);
        return item;
      }
      getText() {
        if (this.shownIds.size == 0) return "";
        let d = /* @__PURE__ */ new Date();
        let idx = Math.floor(d.getMilliseconds() / 100);
        let text = "";
        let items = [];
        for (let [id2, item] of this.items) {
          if (this.shownIds.has(id2)) {
            items.push(item);
          }
        }
        items.sort((a, b) => a.priority - b.priority);
        for (let item of items) {
          if (!item.isProgress) {
            text = `${text} ${item.text}`;
          } else {
            text = `${text} ${frames[idx]} ${item.text}`;
          }
        }
        return text;
      }
      setStatusText() {
        let text = this.getText();
        let { nvim } = this;
        if (text != this._text && nvim) {
          this._text = text;
          nvim.pauseNotification();
          this.nvim.setVar("coc_status", text, true);
          this.nvim.callTimer("coc#util#do_autocmd", ["CocStatusChange"], true);
          nvim.resumeNotification(false, true);
        }
      }
    };
  }
});

// src/model/task.ts
var Task;
var init_task = __esm({
  "src/model/task.ts"() {
    "use strict";
    init_events();
    init_util();
    init_protocol();
    Task = class {
      /**
       * @param {Neovim} nvim
       * @param {string} id unique id
       */
      constructor(nvim, id2) {
        this.nvim = nvim;
        this.id = id2;
        this.disposables = [];
        this._onExit = new import_node4.Emitter();
        this._onStderr = new import_node4.Emitter();
        this._onStdout = new import_node4.Emitter();
        this.onExit = this._onExit.event;
        this.onStdout = this._onStdout.event;
        this.onStderr = this._onStderr.event;
        events_default.on("TaskExit", (id3, code) => {
          if (id3 == this.id) {
            this._onExit.fire(code);
          }
        }, null, this.disposables);
        events_default.on("TaskStderr", (id3, lines) => {
          if (id3 == this.id) {
            this._onStderr.fire(lines);
          }
        }, null, this.disposables);
        events_default.on("TaskStdout", (id3, lines) => {
          if (id3 == this.id) {
            this._onStdout.fire(lines);
          }
        }, null, this.disposables);
      }
      /**
       * Start task, task will be restarted when already running.
       * @param {TaskOptions} opts
       * @returns {Promise<boolean>}
       */
      async start(opts) {
        let { nvim } = this;
        return await nvim.call("coc#task#start", [this.id, opts]);
      }
      /**
       * Stop task by SIGTERM or SIGKILL
       */
      async stop() {
        let { nvim } = this;
        await nvim.call("coc#task#stop", [this.id]);
      }
      /**
       * Check if the task is running.
       */
      get running() {
        let { nvim } = this;
        return nvim.call("coc#task#running", [this.id]);
      }
      /**
       * Stop task and dispose all events.
       */
      dispose() {
        let { nvim } = this;
        nvim.call("coc#task#stop", [this.id], true);
        this._onStdout.dispose();
        this._onStderr.dispose();
        this._onExit.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/workspace.ts
var logger20, methods, Workspace, workspace_default;
var init_workspace = __esm({
  "src/workspace.ts"() {
    "use strict";
    init_esm();
    init_configuration2();
    init_shape();
    init_autocmds();
    init_channels();
    init_contentProvider();
    init_documents();
    init_editors();
    init_fileSystemWatcher();
    init_files();
    init_funcs();
    init_keymaps();
    init_ui();
    init_watchers();
    init_workspaceFolder();
    init_events();
    init_logger();
    init_bufferSync();
    init_db();
    init_fuzzyMatch();
    init_mru();
    init_status();
    init_strwidth();
    init_task();
    init_constants();
    init_fs();
    init_node();
    init_object();
    init_processes();
    init_protocol();
    logger20 = createLogger("workspace");
    methods = [
      "showMessage",
      "runTerminalCommand",
      "openTerminal",
      "showQuickpick",
      "menuPick",
      "openLocalConfig",
      "showPrompt",
      "createStatusBarItem",
      "createOutputChannel",
      "showOutputChannel",
      "requestInput",
      "echoLines",
      "getCursorPosition",
      "moveTo",
      "getOffset",
      "getSelectedRange",
      "selectRange",
      "createTerminal"
    ];
    Workspace = class {
      constructor() {
        this.isTrusted = true;
        this.statusLine = new StatusLine();
        this._onDidRuntimePathChange = new import_node4.Emitter();
        this.onDidRuntimePathChange = this._onDidRuntimePathChange.event;
        void initFuzzyWasm().then((api) => {
          this.fuzzyExports = api;
        });
        void StrWidth.create().then((strWdith) => {
          this.strWdith = strWdith;
        });
        events_default.on("VimResized", (columns, lines) => {
          Object.assign(toObject(this.env), { columns, lines });
        });
        Object.defineProperty(this.statusLine, "nvim", {
          get: () => this.nvim
        });
        let configurations = this.configurations = new Configurations(userConfigFile, new ConfigurationProxy(this));
        this.workspaceFolderControl = new WorkspaceFolderController(this.configurations);
        let documents = this.documentsManager = new Documents(this.configurations, this.workspaceFolderControl);
        this.contentProvider = new ContentProvider(documents);
        this.watchers = new Watchers();
        this.autocmds = new Autocmds();
        this.keymaps = new Keymaps();
        this.files = new Files(documents, this.configurations, this.workspaceFolderControl, this.keymaps);
        this.editors = new Editors(documents);
        this.onDidChangeWorkspaceFolders = this.workspaceFolderControl.onDidChangeWorkspaceFolders;
        this.onDidChangeConfiguration = this.configurations.onDidChange;
        this.onDidOpenTextDocument = documents.onDidOpenTextDocument;
        this.onDidChangeTextDocument = documents.onDidChangeDocument;
        this.onDidCloseTextDocument = documents.onDidCloseDocument;
        this.onDidSaveTextDocument = documents.onDidSaveTextDocument;
        this.onWillSaveTextDocument = documents.onWillSaveTextDocument;
        this.onDidCreateFiles = this.files.onDidCreateFiles;
        this.onDidRenameFiles = this.files.onDidRenameFiles;
        this.onDidDeleteFiles = this.files.onDidDeleteFiles;
        this.onWillCreateFiles = this.files.onWillCreateFiles;
        this.onWillRenameFiles = this.files.onWillRenameFiles;
        this.onWillDeleteFiles = this.files.onWillDeleteFiles;
        let watchConfig = configurations.initialConfiguration.inspect("fileSystemWatch").globalValue ?? {};
        let watchmanPath = watchConfig.watchmanPath ? watchConfig.watchmanPath : configurations.initialConfiguration.inspect("coc.preferences.watchmanPath").globalValue;
        if (typeof watchmanPath === "string") watchmanPath = this.expand(watchmanPath);
        const config = {
          watchmanPath,
          enable: watchConfig.enable == null ? true : !!watchConfig.enable,
          ignoredFolders: (Array.isArray(watchConfig.ignoredFolders) ? watchConfig.ignoredFolders.filter((s) => typeof s === "string") : ["${tmpdir}", "/private/tmp", "/"]).map((p) => this.expand(p))
        };
        this.fileSystemWatchers = new FileSystemWatcherManager(this.workspaceFolderControl, config);
      }
      get initialConfiguration() {
        return this.configurations.initialConfiguration;
      }
      async init(window2) {
        let { nvim } = this;
        for (let method of methods) {
          Object.defineProperty(this, method, {
            get: () => {
              return (...args) => {
                let stack = "\n" + Error().stack.split("\n").slice(2, 4).join("\n");
                logger20.warn(`workspace.${method} is deprecated, please use window.${method} instead.`, stack);
                return window2[method].apply(window2, args);
              };
            }
          });
        }
        for (let name2 of ["onDidOpenTerminal", "onDidCloseTerminal"]) {
          Object.defineProperty(this, name2, {
            get: () => {
              let stack = "\n" + Error().stack.split("\n").slice(2, 4).join("\n");
              logger20.warn(`workspace.${name2} is deprecated, please use window.${name2} instead.`, stack);
              return window2[name2];
            }
          });
        }
        let env = this._env = await nvim.call("coc#util#vim_info");
        window2.init(env);
        this.checkVersion(APIVERSION);
        this.configurations.updateMemoryConfig(this._env.config);
        this.workspaceFolderControl.setWorkspaceFolders(this._env.workspaceFolders);
        this.workspaceFolderControl.onDidChangeWorkspaceFolders(() => {
          nvim.setVar("WorkspaceFolders", this.folderPaths, true);
        });
        this.files.attach(nvim, env, window2);
        this.contentProvider.attach(nvim);
        this.registerTextDocumentContentProvider("output", channels_default.getProvider(nvim));
        this.keymaps.attach(nvim);
        this.autocmds.attach(nvim);
        this.watchers.attach(nvim, env);
        this.watchers.watchOption("runtimepath", async (oldValue, newValue) => {
          let oldList = oldValue.split(",");
          let newList = newValue.split(",");
          let paths = newList.filter((x) => !oldList.includes(x));
          if (paths.length > 0) {
            let filepaths = [];
            await Promise.allSettled(paths.map((filepath) => {
              return new Promise((resolve, reject) => {
                let converted = this.fixWin32unixFilepath(filepath);
                getFileType(converted).then((t) => {
                  if (t == 2 /* Directory */) {
                    filepaths.push(converted);
                  }
                  resolve(void 0);
                }, reject);
              });
            }));
            if (filepaths.length > 0) {
              this._onDidRuntimePathChange.fire(filepaths);
              this.env.runtimepath = [...oldList, ...filepaths].join(",");
            }
          }
        });
        await this.documentsManager.attach(this.nvim, this._env);
        await this.editors.attach(nvim);
        let channel = channels_default.create("watchman", nvim);
        this.fileSystemWatchers.attach(channel);
        if (this.strWdith) this.strWdith.setAmbw(!env.ambiguousIsNarrow);
      }
      checkVersion(version2) {
        if (this._env.apiversion != version2) {
          this.nvim.echoError(`API version ${this._env.apiversion} is not ${APIVERSION}, please build coc.nvim by 'npm ci' after pull source code.`);
        }
      }
      getDisplayWidth(text, cache = false) {
        return this.strWdith.getWidth(text, cache);
      }
      get version() {
        return VERSION;
      }
      get cwd() {
        return this.documentsManager.cwd;
      }
      get env() {
        return this._env;
      }
      get root() {
        return this.documentsManager.root || this.cwd;
      }
      get rootPath() {
        return this.root;
      }
      get bufnr() {
        return this.documentsManager.bufnr;
      }
      /**
       * @deprecated
       */
      get insertMode() {
        return events_default.insertMode;
      }
      /**
       * @deprecated always true
       */
      get floatSupported() {
        return true;
      }
      /**
       * @deprecated
       */
      get uri() {
        return this.documentsManager.uri;
      }
      /**
       * @deprecated
       */
      get workspaceFolder() {
        return this.workspaceFolders[0];
      }
      get textDocuments() {
        return this.documentsManager.textDocuments;
      }
      get documents() {
        return this.documentsManager.documents;
      }
      get document() {
        return this.documentsManager.document;
      }
      get workspaceFolders() {
        return this.workspaceFolderControl.workspaceFolders;
      }
      fixWin32unixFilepath(filepath) {
        return this.documentsManager.fixUnixPrefix(filepath);
      }
      checkPatterns(patterns, folders) {
        return this.workspaceFolderControl.checkPatterns(folders ?? this.workspaceFolderControl.workspaceFolders, patterns);
      }
      get folderPaths() {
        return this.workspaceFolders.map((f) => URI2.parse(f.uri).fsPath);
      }
      get channelNames() {
        return channels_default.names;
      }
      get pluginRoot() {
        return pluginRoot;
      }
      get isVim() {
        return this._env.isVim;
      }
      get isNvim() {
        return !this._env.isVim;
      }
      /**
       * Kept for backward compatible
       */
      get completeOpt() {
        return "";
      }
      get filetypes() {
        return this.documentsManager.filetypes;
      }
      get languageIds() {
        return this.documentsManager.languageIds;
      }
      /**
       * @deprecated
       */
      createNameSpace(name2) {
        return createNameSpace(name2);
      }
      has(feature) {
        return has(this.env, feature);
      }
      /**
       * Register autocmd on vim.
       */
      registerAutocmd(autocmd, disposables) {
        let opts = Object.assign({}, autocmd);
        Error.captureStackTrace(opts);
        let disposable = this.autocmds.registerAutocmd(opts);
        if (disposables) disposables.push(disposable);
        return disposable;
      }
      /**
       * Watch for option change.
       */
      watchOption(key, callback, disposables) {
        return this.watchers.watchOption(key, callback, disposables);
      }
      /**
       * Watch global variable, works on neovim only.
       */
      watchGlobal(key, callback, disposables) {
        let cb = callback ?? function() {
        };
        return this.watchers.watchGlobal(key, cb, disposables);
      }
      /**
       * Check if selector match document.
       */
      match(selector, document2) {
        return score(selector, document2.uri, document2.languageId);
      }
      /**
       * Create a FileSystemWatcher instance, doesn't fail when watchman not found.
       */
      createFileSystemWatcher(globPattern, ignoreCreate, ignoreChange, ignoreDelete) {
        return this.fileSystemWatchers.createFileSystemWatcher(globPattern, ignoreCreate, ignoreChange, ignoreDelete);
      }
      createFuzzyMatch() {
        return new FuzzyMatch(this.fuzzyExports);
      }
      getWatchmanPath() {
        return getWatchmanPath(this.configurations);
      }
      /**
       * Get configuration by section and optional resource uri.
       */
      getConfiguration(section2, scope) {
        return this.configurations.getConfiguration(section2, scope);
      }
      resolveJSONSchema(uri) {
        return this.configurations.getJSONSchema(uri);
      }
      /**
       * Get created document by uri or bufnr.
       */
      getDocument(uri) {
        return this.documentsManager.getDocument(uri);
      }
      hasDocument(uri, version2) {
        let doc = this.documentsManager.getDocument(uri);
        return doc && (version2 != null ? doc.version == version2 : true);
      }
      getUri(bufnr, defaultValue2 = "") {
        let doc = this.documentsManager.getDocument(bufnr);
        return doc ? doc.uri : defaultValue2;
      }
      isAttached(bufnr) {
        let doc = this.documentsManager.getDocument(bufnr);
        return doc != null && doc.attached;
      }
      /**
       * Get attached document by uri or bufnr.
       * Throw error when document doesn't exist or isn't attached.
       */
      getAttachedDocument(uri) {
        let doc = this.getDocument(uri);
        if (!doc) throw new Error(`Buffer ${uri} not created.`);
        if (!doc.attached) throw new Error(`Buffer ${uri} not attached, ${doc.notAttachReason}`);
        return doc;
      }
      /**
       * Convert location to quickfix item.
       */
      getQuickfixItem(loc, text, type = "", module2) {
        return this.documentsManager.getQuickfixItem(loc, text, type, module2);
      }
      /**
       * Create persistence Mru instance.
       */
      createMru(name2) {
        return new Mru(name2);
      }
      async getQuickfixList(locations) {
        return this.documentsManager.getQuickfixList(locations);
      }
      /**
       * Populate locations to UI.
       */
      async showLocations(locations) {
        await this.documentsManager.showLocations(locations);
      }
      /**
       * Get content of line by uri and line.
       */
      getLine(uri, line) {
        return this.documentsManager.getLine(uri, line);
      }
      /**
       * Get WorkspaceFolder of uri
       */
      getWorkspaceFolder(uri) {
        return this.workspaceFolderControl.getWorkspaceFolder(typeof uri === "string" ? URI2.parse(uri) : uri);
      }
      /**
       * Get content from buffer or file by uri.
       */
      readFile(uri) {
        return this.documentsManager.readFile(uri);
      }
      async getCurrentState() {
        let document2 = await this.document;
        let position = await getCursorPosition(this.nvim);
        return {
          document: document2.textDocument,
          position
        };
      }
      async getFormatOptions(uri) {
        return this.documentsManager.getFormatOptions(uri);
      }
      /**
       * Resolve module from yarn or npm.
       */
      resolveModule(name2) {
        return resolveModule(name2);
      }
      /**
       * Run nodejs command
       */
      async runCommand(cmd, cwd2, timeout2) {
        return runCommand(cmd, { cwd: cwd2 ?? this.cwd }, timeout2);
      }
      /**
       * Expand filepath with `~` and/or environment placeholders
       */
      expand(filepath) {
        return this.documentsManager.expand(filepath);
      }
      async callAsync(method, args) {
        return await callAsync(this.nvim, method, args);
      }
      registerTextDocumentContentProvider(scheme, provider) {
        return this.contentProvider.registerTextDocumentContentProvider(scheme, provider);
      }
      registerKeymap(modes, key, fn, opts = {}) {
        return this.keymaps.registerKeymap(modes, key, fn, opts);
      }
      registerExprKeymap(mode, key, fn, buffer = false, cancel = true) {
        return this.keymaps.registerExprKeymap(mode, key, fn, buffer, cancel);
      }
      registerLocalKeymap(bufnr, mode, key, fn, notify = false) {
        if (typeof arguments[0] === "string") {
          bufnr = this.bufnr;
          mode = arguments[0];
          key = arguments[1];
          fn = arguments[2];
          notify = arguments[3] ?? false;
        }
        return this.keymaps.registerLocalKeymap(bufnr, mode, key, fn, notify);
      }
      /**
       * Create Task instance that runs in vim.
       */
      createTask(id2) {
        return new Task(this.nvim, id2);
      }
      /**
       * Create DB instance at extension root.
       */
      createDatabase(name2) {
        return new DB(path.join(dataHome, name2 + ".json"));
      }
      registerBufferSync(create) {
        return new BufferSync(create, this.documentsManager);
      }
      async attach() {
        await this.documentsManager.attach(this.nvim, this._env);
      }
      jumpTo(uri, position, openCommand) {
        return this.files.jumpTo(uri, position, openCommand);
      }
      /**
       * Findup for filename or filenames from current filepath or root.
       */
      findUp(filename) {
        return findUp2(this.nvim, this.cwd, filename);
      }
      /**
       * Apply WorkspaceEdit.
       */
      applyEdit(edit2) {
        return this.files.applyEdit(edit2);
      }
      /**
       * Create a file in vim and disk
       */
      createFile(filepath, opts = {}) {
        return this.files.createFile(filepath, opts);
      }
      /**
       * Load uri as document.
       */
      loadFile(uri, cmd) {
        return this.files.loadResource(uri, cmd);
      }
      /**
       * Load the files that not loaded
       */
      async loadFiles(uris) {
        return this.files.loadResources(uris);
      }
      /**
       * Rename file in vim and disk
       */
      async renameFile(oldPath, newPath, opts = {}) {
        await this.files.renameFile(oldPath, newPath, opts);
      }
      /**
       * Delete file from vim and disk.
       */
      async deleteFile(filepath, opts = {}) {
        await this.files.deleteFile(filepath, opts);
      }
      /**
       * Open resource by uri
       */
      async openResource(uri) {
        await this.files.openResource(uri);
      }
      async computeWordRanges(uri, range, token) {
        let doc = this.getDocument(uri);
        if (!doc) return null;
        return await doc.chars.computeWordRanges(doc.textDocument.lines, range, token);
      }
      openTextDocument(uri) {
        return this.files.openTextDocument(uri);
      }
      getRelativePath(pathOrUri, includeWorkspace) {
        return this.workspaceFolderControl.getRelativePath(pathOrUri, includeWorkspace);
      }
      asRelativePath(pathOrUri, includeWorkspace) {
        return this.getRelativePath(pathOrUri, includeWorkspace);
      }
      async findFiles(include, exclude, maxResults, token) {
        return this.files.findFiles(include, exclude, maxResults, token);
      }
      detach() {
        this.documentsManager.detach();
      }
      reset() {
        this.statusLine.reset();
        this.configurations.reset();
        this.workspaceFolderControl.reset();
        this.documentsManager.reset();
      }
      dispose() {
        channels_default.dispose();
        this.autocmds.dispose();
        this.statusLine.dispose();
        this.watchers.dispose();
        this.contentProvider.dispose();
        this.documentsManager.dispose();
        this.configurations.dispose();
      }
    };
    workspace_default = new Workspace();
  }
});

// src/tree/filter.ts
var sessionKey, HistoryInput, Filter;
var init_filter2 = __esm({
  "src/tree/filter.ts"() {
    "use strict";
    init_events();
    init_protocol();
    init_util();
    sessionKey = "filter";
    HistoryInput = class {
      constructor() {
        this.history = [];
      }
      next(input) {
        let idx = this.history.indexOf(input);
        return this.history[idx + 1] ?? this.history[0];
      }
      previous(input) {
        let idx = this.history.indexOf(input);
        return this.history[idx - 1] ?? this.history[this.history.length - 1];
      }
      add(input) {
        let idx = this.history.indexOf(input);
        if (idx !== -1) {
          this.history.splice(idx, 1);
        }
        this.history.unshift(input);
      }
      toJSON() {
        return `[${this.history.join(",")}]`;
      }
    };
    Filter = class {
      constructor(nvim, keys) {
        this.nvim = nvim;
        this._activated = false;
        this.history = new HistoryInput();
        this.disposables = [];
        this._onDidUpdate = new import_node4.Emitter();
        this._onDidExit = new import_node4.Emitter();
        this._onDidKeyPress = new import_node4.Emitter();
        this.onDidKeyPress = this._onDidKeyPress.event;
        this.onDidUpdate = this._onDidUpdate.event;
        this.onDidExit = this._onDidExit.event;
        this.text = "";
        events_default.on("InputChar", (session, character) => {
          if (session !== sessionKey || !this._activated) return;
          if (!keys.includes(character)) {
            if (character.length == 1) {
              this.text = this.text + character;
              this._onDidUpdate.fire(this.text);
              return;
            }
            if (character == "<bs>" || character == "<C-h>") {
              this.text = this.text.slice(0, -1);
              this._onDidUpdate.fire(this.text);
              return;
            }
            if (character == "<C-u>") {
              this.text = "";
              this._onDidUpdate.fire(this.text);
              return;
            }
            if (character == "<C-n>") {
              let text = this.history.next(this.text);
              if (text) {
                this.text = text;
                this._onDidUpdate.fire(this.text);
              }
              return;
            }
            if (character == "<C-p>") {
              let text = this.history.previous(this.text);
              if (text) {
                this.text = text;
                this._onDidUpdate.fire(this.text);
              }
            }
            if (character == "<esc>" || character == "<C-o>") {
              this.deactivate();
              return;
            }
          }
          this._onDidKeyPress.fire(character);
        }, null, this.disposables);
      }
      active() {
        this._activated = true;
        this.text = "";
        this.nvim.call("coc#prompt#start_prompt", [sessionKey], true);
      }
      deactivate(node) {
        if (!this._activated) return;
        this.nvim.call("coc#prompt#stop_prompt", [sessionKey], true);
        this._activated = false;
        let { text } = this;
        this.text = "";
        this._onDidExit.fire(node);
        this.history.add(text);
      }
      get activated() {
        return this._activated;
      }
      dispose() {
        this.deactivate();
        this._onDidKeyPress.dispose();
        this._onDidUpdate.dispose();
        this._onDidExit.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/tree/TreeItem.ts
function getItemLabel(item) {
  return TreeItemLabel.is(item.label) ? item.label.label : item.label;
}
var TreeItemLabel, TreeItemCollapsibleState, TreeItem;
var init_TreeItem = __esm({
  "src/tree/TreeItem.ts"() {
    "use strict";
    init_esm();
    init_node();
    ((TreeItemLabel3) => {
      function is(obj) {
        return typeof obj.label == "string";
      }
      TreeItemLabel3.is = is;
    })(TreeItemLabel || (TreeItemLabel = {}));
    TreeItemCollapsibleState = /* @__PURE__ */ ((TreeItemCollapsibleState2) => {
      TreeItemCollapsibleState2[TreeItemCollapsibleState2["None"] = 0] = "None";
      TreeItemCollapsibleState2[TreeItemCollapsibleState2["Collapsed"] = 1] = "Collapsed";
      TreeItemCollapsibleState2[TreeItemCollapsibleState2["Expanded"] = 2] = "Expanded";
      return TreeItemCollapsibleState2;
    })(TreeItemCollapsibleState || {});
    TreeItem = class {
      constructor(label, collapsibleState = 0 /* None */) {
        this.collapsibleState = collapsibleState;
        if (URI2.isUri(label)) {
          this.resourceUri = label;
          this.label = path.basename(label.path);
          this.id = label.toString();
        } else {
          this.label = label;
        }
      }
    };
  }
});

// src/tree/TreeView.ts
var TreeView_exports = {};
__export(TreeView_exports, {
  default: () => BasicTreeView
});
var logger21, retryTimeout, maxRetry, highlightNamespace, signOffset, globalId, BasicTreeView;
var init_TreeView = __esm({
  "src/tree/TreeView.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_events();
    init_logger();
    init_fuzzyMatch();
    init_util();
    init_array();
    init_filter();
    init_mutex();
    init_node();
    init_object();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    init_filter2();
    init_TreeItem();
    logger21 = createLogger("BasicTreeView");
    retryTimeout = getConditionValue(500, 10);
    maxRetry = getConditionValue(5, 1);
    highlightNamespace = "tree";
    signOffset = 3e3;
    globalId = 1;
    BasicTreeView = class {
      constructor(viewId, opts) {
        this.viewId = viewId;
        this.opts = opts;
        this._selection = [];
        this._keymapDefs = [];
        this._onDispose = new import_node4.Emitter();
        this._onDidRefrash = new import_node4.Emitter();
        this._onDidExpandElement = new import_node4.Emitter();
        this._onDidCollapseElement = new import_node4.Emitter();
        this._onDidChangeSelection = new import_node4.Emitter();
        this._onDidChangeVisibility = new import_node4.Emitter();
        this._onDidFilterStateChange = new import_node4.Emitter();
        this._onDidCursorMoved = new import_node4.Emitter();
        this.onDidRefrash = this._onDidRefrash.event;
        this.onDispose = this._onDispose.event;
        this.onDidExpandElement = this._onDidExpandElement.event;
        this.onDidCollapseElement = this._onDidCollapseElement.event;
        this.onDidChangeSelection = this._onDidChangeSelection.event;
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        this.onDidFilterStateChange = this._onDidFilterStateChange.event;
        this.onDidCursorMoved = this._onDidCursorMoved.event;
        this.retryTimers = 0;
        this.renderedItems = [];
        this.nodesMap = /* @__PURE__ */ new Map();
        this.mutex = new Mutex();
        this.disposables = [];
        this.lineState = { titleCount: 0, messageCount: 0 };
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        if (opts.enableFilter) {
          this.filter = new Filter(this.nvim, [this.keys.selectNext, this.keys.selectPrevious, this.keys.invoke]);
        }
        let id2 = globalId;
        globalId = globalId + 1;
        this.bufname = `CocTree${id2}`;
        this.tooltipFactory = window_default.createFloatFactory({ modes: ["n"] });
        this.provider = opts.treeDataProvider;
        this.leafIndent = opts.disableLeafIndent !== true;
        this.winfixwidth = opts.winfixwidth !== false;
        this.autoWidth = opts.autoWidth === true;
        let message;
        Object.defineProperty(this, "message", {
          set: (msg) => {
            message = msg ? msg.replace(/\r?\n/g, " ") : void 0;
            this.updateHeadLines();
          },
          get: () => {
            return message;
          }
        });
        let title = viewId.replace(/\r?\n/g, " ");
        Object.defineProperty(this, "title", {
          set: (newTitle) => {
            title = newTitle ? newTitle.replace(/\r?\n/g, " ") : void 0;
            this.updateHeadLines();
          },
          get: () => {
            return title;
          }
        });
        let description;
        Object.defineProperty(this, "description", {
          set: (desc) => {
            description = desc ? desc.replace(/\r?\n/g, " ") : void 0;
            this.updateHeadLines();
          },
          get: () => {
            return description;
          }
        });
        let filterText;
        Object.defineProperty(this, "filterText", {
          set: (text) => {
            let { titleCount, messageCount } = this.lineState;
            let start = titleCount + messageCount;
            if (text != null) {
              let highlights = [{
                lnum: start,
                colStart: byteLength(text),
                colEnd: byteLength(text) + 1,
                hlGroup: "Cursor"
              }];
              this.renderedItems = [];
              this.updateUI([text + " "], highlights, start, -1, true);
              void this.doFilter(text);
            } else if (filterText != null) {
              this.updateUI([], [], start, start + 1);
            }
            filterText = text;
          },
          get: () => {
            return filterText;
          }
        });
        if (this.provider.onDidChangeTreeData) {
          this.provider.onDidChangeTreeData(this.onDataChange, this, this.disposables);
        }
        events_default.on("BufUnload", (bufnr) => {
          if (bufnr != this.bufnr) return;
          let isVisible = this.winid != null;
          this.winid = void 0;
          this.bufnr = void 0;
          if (isVisible) this._onDidChangeVisibility.fire({ visible: false });
          this.dispose();
        }, null, this.disposables);
        events_default.on("WinClosed", (winid) => {
          if (this.winid === winid) {
            this.winid = void 0;
            this._onDidChangeVisibility.fire({ visible: false });
          }
        }, null, this.disposables);
        events_default.on("BufWinLeave", (bufnr, winid) => {
          if (bufnr == this.bufnr && winid == this.winid) {
            this.winid = void 0;
            this._onDidChangeVisibility.fire({ visible: false });
          }
        }, null, this.disposables);
        window_default.onDidTabClose((id3) => {
          if (this._targetTabId === id3) {
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("CursorHold", async (bufnr, cursor) => {
          if (bufnr != this.bufnr) return;
          await this.onHover(cursor[0]);
        }, null, this.disposables);
        events_default.on(["CursorMoved", "BufEnter"], () => {
          this.cancelResolve();
        }, null, this.disposables);
        let debounced = debounce((bufnr, cursor) => {
          if (bufnr !== this.bufnr) return;
          let element = this.getElementByLnum(cursor[0] - 1);
          this._onDidCursorMoved.fire(element);
        }, 30);
        this.disposables.push(import_node4.Disposable.create(() => {
          debounced.clear();
        }));
        events_default.on("CursorMoved", debounced, null, this.disposables);
        events_default.on("WinEnter", (winid) => {
          if (winid != this.windowId || !this.filtering) return;
          let buf = this.nvim.createBuffer(this.bufnr);
          let line = this.startLnum - 1;
          let len = toText(this.filterText).length;
          let range = Range.create(line, len, line, len + 1);
          buf.highlightRanges(highlightNamespace, "Cursor", [range]);
          this.nvim.call("coc#prompt#start_prompt", [sessionKey], true);
          this.redraw();
        }, null, this.disposables);
        events_default.on("WinLeave", (winid) => {
          if (winid != this.windowId || !this.filtering) return;
          let buf = this.nvim.createBuffer(this.bufnr);
          this.nvim.call("coc#prompt#stop_prompt", [sessionKey], true);
          buf.clearNamespace(highlightNamespace, this.startLnum - 1, this.startLnum);
        }, null, this.disposables);
        this.disposables.push(this._onDidChangeVisibility, this._onDidCursorMoved, this._onDidChangeSelection, this._onDidCollapseElement, this._onDidExpandElement);
        if (this.filter) {
          this.filter.onDidExit((node) => {
            this.nodesMap.clear();
            this.filterText = void 0;
            this.itemsToFilter = void 0;
            if (node && typeof this.provider.getParent === "function") {
              this.renderedItems = [];
              void this.reveal(node, { focus: true });
            } else {
              this.clearSelection();
              void this.render();
            }
            this._onDidFilterStateChange.fire(false);
          });
          this.filter.onDidUpdate((text) => {
            this.filterText = text;
          });
          this.filter.onDidKeyPress(async (character) => {
            let items = toArray(this.renderedItems);
            let curr = this.selection[0];
            if (character == "<up>" || character == this.keys.selectPrevious) {
              let idx = items.findIndex((o) => o.node == curr);
              let index = idx == -1 || idx == 0 ? items.length - 1 : idx - 1;
              let node = items[index]?.node;
              if (node) this.selectItem(node, true);
            }
            if (character == "<down>" || character == this.keys.selectNext) {
              let idx = items.findIndex((o) => o.node == curr);
              let index = idx == -1 || idx == items.length - 1 ? 0 : idx + 1;
              let node = items[index]?.node;
              if (node) this.selectItem(node, true);
            }
            if (character == "<cr>" || character == this.keys.invoke) {
              if (!curr) return;
              await this.invokeCommand(curr);
              this.filter.deactivate(curr);
            }
          });
        }
      }
      get windowId() {
        return this.winid;
      }
      get targetTabId() {
        return this._targetTabId;
      }
      get targetWinId() {
        return this._targetWinId;
      }
      get targetBufnr() {
        return this._targetBufnr;
      }
      get startLnum() {
        let filterCount = this.filterText == null ? 0 : 1;
        return this.lineState.messageCount + this.lineState.titleCount + filterCount;
      }
      get nvim() {
        return workspace_default.nvim;
      }
      get filtering() {
        return this.filter != null && this.filter.activated;
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("tree")) {
          let config = workspace_default.getConfiguration("tree", null);
          this.config = {
            openedIcon: config.get("openedIcon", " "),
            closedIcon: config.get("closedIcon", " ")
          };
          this.keys = {
            close: config.get("key.close"),
            invoke: config.get("key.invoke"),
            toggle: config.get("key.toggle"),
            actions: config.get("key.actions"),
            collapseAll: config.get("key.collapseAll"),
            toggleSelection: config.get("key.toggleSelection"),
            activeFilter: config.get("key.activeFilter"),
            selectNext: config.get("key.selectNext"),
            selectPrevious: config.get("key.selectPrevious")
          };
          if (e && this.visible) {
            void this.render();
          }
        }
      }
      async doFilter(text) {
        let items = [];
        let index = 0;
        let release = await this.mutex.acquire();
        try {
          if (!this.itemsToFilter) {
            let itemsToFilter = [];
            const addNodes = async (nodes2) => {
              for (let n of nodes2) {
                itemsToFilter.push(n);
                let arr = await Promise.resolve(this.provider.getChildren(n));
                if (!isFalsyOrEmpty(arr)) await addNodes(arr);
              }
            };
            let nodes = await Promise.resolve(this.provider.getChildren());
            await addNodes(nodes);
            this.itemsToFilter = itemsToFilter;
          }
          let lowInput = text.toLowerCase();
          let emptyInput = text.length === 0;
          for (let n of this.itemsToFilter) {
            let item = await this.getTreeItem(n);
            let label = getItemLabel(item);
            let score3 = 0;
            if (!emptyInput) {
              let res = fuzzyScoreGracefulAggressive(text, lowInput, 0, label, label.toLowerCase(), 0, { boostFullMatch: true, firstMatchCanBeWeak: true });
              if (!res) continue;
              score3 = res[0];
              item.label = { label, highlights: toSpans(label, res) };
            } else {
              item.label = { label, highlights: [] };
            }
            item.collapsibleState = 0 /* None */;
            let { line, highlights: highlights2 } = this.getRenderedLine(item, index, 0);
            items.push({
              level: 0,
              node: n,
              line,
              index,
              score: score3,
              highlights: highlights2
            });
            index += 1;
          }
          items.sort((a, b) => {
            if (a.score != b.score) return b.score - a.score;
            return a.index - b.index;
          });
          let lnum = this.startLnum;
          let highlights = [];
          let renderedItems = this.renderedItems = items.map((o, idx) => {
            highlights.push(...o.highlights.map((h) => {
              h.lnum = lnum + idx;
              return h;
            }));
            delete o.index;
            delete o.score;
            delete o.highlights;
            return o;
          });
          this.updateUI(renderedItems.map((o) => o.line), highlights, lnum, -1, true);
          if (renderedItems.length) {
            this.selectItem(renderedItems[0].node, true);
          } else {
            this.clearSelection();
          }
          this.redraw();
          release();
        } catch (e) {
          release();
          logger21.error(`Error on tree filter:`, e);
        }
      }
      async onHover(lnum) {
        let element = this.getElementByLnum(lnum - 1);
        if (!element || !this.nodesMap.has(element)) return;
        let obj = this.nodesMap.get(element);
        let item = obj.item;
        if (!item.tooltip && !obj.resolved) item = await this.resolveItem(element, item);
        if (!item.tooltip) return;
        let isMarkdown2 = MarkupContent.is(item.tooltip) && item.tooltip.kind == MarkupKind.Markdown;
        let doc = {
          filetype: isMarkdown2 ? "markdown" : "txt",
          content: MarkupContent.is(item.tooltip) ? item.tooltip.value : item.tooltip
        };
        await this.tooltipFactory.show([doc]);
      }
      async onClick(element) {
        let { nvim } = this;
        let [line, col] = await nvim.eval(`[getline('.'),col('.')]`);
        let pre = byteSlice(line, 0, col - 1);
        let character = line[pre.length];
        let { openedIcon, closedIcon } = this.config;
        if (/^\s*$/.test(pre) && [openedIcon, closedIcon].includes(character)) {
          await this.toggleExpand(element);
        } else {
          await this.invokeCommand(element);
        }
      }
      async invokeCommand(element) {
        let obj = this.nodesMap.get(element);
        if (!obj) return;
        this.selectItem(element);
        let item = obj.item;
        if (!item.command) item = await this.resolveItem(element, item);
        if (!item || !item.command) throw new Error(`Failed to resolve command from TreeItem.`);
        await commands_default.execute(item.command);
      }
      async invokeActions(element) {
        if (!element) return;
        this.selectItem(element);
        if (typeof this.provider.resolveActions !== "function") {
          await window_default.showWarningMessage("No actions");
          return;
        }
        let obj = this.nodesMap.get(element);
        let actions = await Promise.resolve(this.provider.resolveActions(obj.item, element));
        if (!actions || actions.length == 0) {
          await window_default.showWarningMessage("No actions available");
          return;
        }
        let keys = actions.map((o) => o.title);
        let res = await window_default.showMenuPicker(keys, "Choose action");
        if (res == -1) return;
        await Promise.resolve(actions[res].handler(element));
      }
      async onDataChange(node) {
        if (this.filtering) {
          this.itemsToFilter = void 0;
          await this.doFilter(toText(this.filterText));
          return;
        }
        this.clearSelection();
        if (!node) {
          await this.render();
          return;
        }
        let release = await this.mutex.acquire();
        try {
          let items = this.renderedItems;
          let idx = items.findIndex((o) => o.node === node);
          if (idx != -1 && this.bufnr) {
            let obj = items[idx];
            let level2 = obj.level;
            let removeCount = 0;
            for (let i = idx; i < items.length; i++) {
              let o = items[i];
              if (i == idx || o && o.level > level2) {
                removeCount += 1;
              }
            }
            let appendItems = [];
            let highlights = [];
            let start = idx + this.startLnum;
            await this.appendTreeNode(node, level2, start, appendItems, highlights);
            items.splice(idx, removeCount, ...appendItems);
            this.updateUI(appendItems.map((o) => o.line), highlights, start, start + removeCount);
          }
          release();
        } catch (e) {
          let errMsg = `Error on tree refresh: ${e}`;
          logger21.error(errMsg, e);
          this.nvim.errWriteLine("[coc.nvim] " + errMsg);
          release();
        }
      }
      async resolveItem(element, item) {
        if (typeof this.provider.resolveTreeItem === "function") {
          let tokenSource = this.resolveTokenSource = new import_node4.CancellationTokenSource();
          let token = tokenSource.token;
          item = await Promise.resolve(this.provider.resolveTreeItem(item, element, token));
          tokenSource.dispose();
          this.resolveTokenSource = void 0;
          if (token.isCancellationRequested) return void 0;
        }
        this.nodesMap.set(element, { item, resolved: true });
        return item;
      }
      get visible() {
        if (!this.bufnr) return false;
        return this.winid != null;
      }
      get valid() {
        return typeof this.bufnr === "number";
      }
      get selection() {
        return this._selection.slice();
      }
      async checkLines() {
        if (!this.bufnr) return false;
        let buf = this.nvim.createBuffer(this.bufnr);
        let curr = await buf.lines;
        let { titleCount, messageCount } = this.lineState;
        curr = curr.slice(titleCount + messageCount);
        let lines = this.renderedItems.map((o) => o.line);
        return equals(curr, lines);
      }
      /**
       * Expand/collapse TreeItem.
       */
      async toggleExpand(element) {
        let o = this.nodesMap.get(element);
        if (!o) return;
        let treeItem = o.item;
        let lnum = this.getItemLnum(element);
        let nodeIdx = lnum - this.startLnum;
        let obj = this.renderedItems[nodeIdx];
        if (!obj || treeItem.collapsibleState == 0 /* None */) {
          if (typeof this.provider.getParent === "function") {
            let node = await Promise.resolve(this.provider.getParent(element));
            if (node) {
              await this.toggleExpand(node);
              this.focusItem(node);
            }
          }
          return;
        }
        let removeCount = 0;
        if (treeItem.collapsibleState == 2 /* Expanded */) {
          let level2 = obj.level;
          for (let i = nodeIdx + 1; i < this.renderedItems.length; i++) {
            let o2 = this.renderedItems[i];
            if (!o2 || o2.level <= level2) break;
            removeCount += 1;
          }
          treeItem.collapsibleState = 1 /* Collapsed */;
        } else if (treeItem.collapsibleState == 1 /* Collapsed */) {
          treeItem.collapsibleState = 2 /* Expanded */;
        }
        let newItems = [];
        let newHighlights = [];
        await this.appendTreeNode(obj.node, obj.level, lnum, newItems, newHighlights);
        this.renderedItems.splice(nodeIdx, removeCount + 1, ...newItems);
        this.updateUI(newItems.map((o2) => o2.line), newHighlights, lnum, lnum + removeCount + 1);
        this.refreshSigns();
        if (treeItem.collapsibleState == 1 /* Collapsed */) {
          this._onDidCollapseElement.fire({ element });
        } else {
          this._onDidExpandElement.fire({ element });
        }
      }
      toggleSelection(element) {
        if (!element) return;
        let idx = this._selection.findIndex((o) => o === element);
        if (idx !== -1) {
          this.unselectItem(idx);
        } else {
          this.selectItem(element);
        }
      }
      clearSelection() {
        if (!this.bufnr) return;
        this._selection = [];
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.unplaceSign({ group: "CocTree" });
        this._onDidChangeSelection.fire({ selection: [] });
      }
      selectItem(item, forceSingle, noRedraw) {
        let { nvim } = this;
        let row = this.getItemLnum(item);
        if (row == null || !this.bufnr) return;
        let buf = nvim.createBuffer(this.bufnr);
        let exists = this._selection.includes(item);
        if (!this.opts.canSelectMany || forceSingle) {
          this._selection = [item];
        } else if (!exists) {
          this._selection.push(item);
        }
        nvim.pauseNotification();
        if (!this.opts.canSelectMany || forceSingle) {
          buf.unplaceSign({ group: "CocTree" });
        }
        nvim.call("win_execute", [this.winid, `normal! ${row + 1}G`], true);
        buf.placeSign({ id: signOffset + row, lnum: row + 1, name: "CocTreeSelected", group: "CocTree" });
        if (!noRedraw) this.redraw();
        nvim.resumeNotification(false, true);
        if (!exists) this._onDidChangeSelection.fire({ selection: this._selection });
      }
      unselectItem(idx) {
        let item = this._selection[idx];
        let row = this.getItemLnum(item);
        if (row == null || !this.bufnr) return;
        this._selection.splice(idx, 1);
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.unplaceSign({ group: "CocTree", id: signOffset + row });
        this._onDidChangeSelection.fire({ selection: this._selection });
      }
      focusItem(element) {
        if (!this.winid) return;
        let lnum = this.getItemLnum(element);
        if (lnum == null) return;
        this.nvim.call("win_execute", [this.winid, `exe ${lnum + 1}`], true);
      }
      getElementByLnum(lnum) {
        let item = this.renderedItems[lnum - this.startLnum];
        return item ? item.node : void 0;
      }
      getItemLnum(item) {
        let idx = this.renderedItems.findIndex((o) => o.node === item);
        if (idx == -1) return void 0;
        return this.startLnum + idx;
      }
      async getTreeItem(element) {
        let exists;
        let resolved = false;
        let obj = this.nodesMap.get(element);
        if (obj != null) {
          exists = obj.item;
          resolved = obj.resolved;
        }
        let item = await Promise.resolve(this.provider.getTreeItem(element));
        if (exists && item && exists.collapsibleState != 0 /* None */ && item.collapsibleState != 0 /* None */) {
          item.collapsibleState = exists.collapsibleState;
        }
        this.nodesMap.set(element, { item, resolved });
        return item;
      }
      getRenderedLine(treeItem, lnum, level2) {
        let { openedIcon, closedIcon } = this.config;
        const highlights = [];
        const { label, deprecated, description } = treeItem;
        let prefix = "  ".repeat(level2);
        const addHighlight = (text, hlGroup) => {
          let colStart = byteLength(prefix);
          highlights.push({
            lnum,
            hlGroup,
            colStart,
            colEnd: colStart + byteLength(text)
          });
        };
        switch (treeItem.collapsibleState) {
          case 2 /* Expanded */: {
            addHighlight(openedIcon, "CocTreeOpenClose");
            prefix += openedIcon + " ";
            break;
          }
          case 1 /* Collapsed */: {
            addHighlight(closedIcon, "CocTreeOpenClose");
            prefix += closedIcon + " ";
            break;
          }
          default:
            prefix += this.leafIndent ? "  " : "";
        }
        if (treeItem.icon) {
          let { text, hlGroup } = treeItem.icon;
          addHighlight(text, hlGroup);
          prefix += text + " ";
        }
        if (TreeItemLabel.is(label) && Array.isArray(label.highlights)) {
          let colStart = byteLength(prefix);
          for (let o of label.highlights) {
            highlights.push({
              lnum,
              hlGroup: "CocSearch",
              colStart: colStart + o[0],
              colEnd: colStart + o[1]
            });
          }
        }
        let labelText = getItemLabel(treeItem);
        if (deprecated) {
          addHighlight(labelText, "CocDeprecatedHighlight");
        }
        prefix += labelText;
        if (description && description.indexOf("\n") == -1) {
          prefix += " ";
          addHighlight(description, "CocTreeDescription");
          prefix += description;
        }
        return { line: prefix, highlights };
      }
      async appendTreeNode(element, level2, lnum, items, highlights) {
        let treeItem = await this.getTreeItem(element);
        if (!treeItem) return 0;
        let takes = 1;
        let res = this.getRenderedLine(treeItem, lnum, level2);
        highlights.push(...res.highlights);
        items.push({ level: level2, line: res.line, node: element });
        if (treeItem.collapsibleState == 2 /* Expanded */) {
          let l = level2 + 1;
          let children = await Promise.resolve(this.provider.getChildren(element));
          for (let el of toArray(children)) {
            let n = await this.appendTreeNode(el, l, lnum + takes, items, highlights);
            takes = takes + n;
          }
        }
        return takes;
      }
      updateUI(lines, highlights, start = 0, end = -1, noRedraw = false) {
        if (!this.bufnr) return;
        let { nvim, winid } = this;
        let buf = nvim.createBuffer(this.bufnr);
        nvim.pauseNotification();
        buf.setOption("modifiable", true, true);
        void buf.setLines(lines, { start, end, strictIndexing: false }, true);
        if (this.autoWidth) this.nvim.call("coc#window#adjust_width", [winid], true);
        if (highlights.length) {
          let highlightEnd = end == -1 ? -1 : start + lines.length;
          buf.updateHighlights(highlightNamespace, highlights, { start, end: highlightEnd });
        }
        buf.setOption("modifiable", false, true);
        if (!noRedraw) this.redraw();
        nvim.resumeNotification(false, true);
      }
      async reveal(element, options2 = {}) {
        if (this.filtering) return;
        let isShown = this.getItemLnum(element) != null;
        let { select, focus, expand: expand2 } = options2;
        let curr = element;
        if (typeof this.provider.getParent !== "function") {
          throw new Error("missing getParent function from provider for reveal.");
        }
        if (!isShown) {
          while (curr) {
            let parentNode = await Promise.resolve(this.provider.getParent(curr));
            if (parentNode) {
              let item = await this.getTreeItem(parentNode);
              item.collapsibleState = 2 /* Expanded */;
              curr = parentNode;
            } else {
              break;
            }
          }
        }
        if (expand2) {
          let item = await this.getTreeItem(element);
          if (item.collapsibleState != 0 /* None */) {
            item.collapsibleState = 2 /* Expanded */;
            if (typeof expand2 === "boolean") expand2 = 1;
            if (expand2 > 1) {
              let curr2 = Math.min(expand2, 2);
              let nodes = await Promise.resolve(this.provider.getChildren(element));
              while (!isFalsyOrEmpty(nodes)) {
                let arr = [];
                for (let n of nodes) {
                  let item2 = await this.getTreeItem(n);
                  if (item2.collapsibleState == 0 /* None */) continue;
                  item2.collapsibleState = 2 /* Expanded */;
                  if (curr2 > 1) {
                    let res = await Promise.resolve(this.provider.getChildren(n));
                    arr.push(...res);
                  }
                }
                nodes = arr;
                curr2 = curr2 - 1;
              }
            }
          }
        }
        if (!isShown || expand2) {
          await this.render();
        }
        if (select !== false) this.selectItem(element);
        if (focus) this.focusItem(element);
      }
      updateHeadLines(initialize = false) {
        let { titleCount, messageCount } = this.lineState;
        let end = initialize ? -1 : titleCount + messageCount;
        let lines = [];
        let highlights = [];
        if (this.message) {
          highlights.push({ hlGroup: "MoreMsg", colStart: 0, colEnd: byteLength(this.message), lnum: 0 });
          lines.push(this.message);
          lines.push("");
        }
        if (this.title) {
          highlights.push({ hlGroup: "CocTreeTitle", colStart: 0, colEnd: byteLength(this.title), lnum: lines.length });
          if (this.description) {
            let colStart = byteLength(this.title) + 1;
            highlights.push({ hlGroup: "Comment", colStart, colEnd: colStart + byteLength(this.description), lnum: lines.length });
          }
          lines.push(this.title + (this.description ? " " + this.description : ""));
        }
        this.lineState.messageCount = this.message ? 2 : 0;
        this.lineState.titleCount = this.title ? 1 : 0;
        this.updateUI(lines, highlights, 0, end);
        if (!initialize) {
          this.refreshSigns();
        }
      }
      /**
       * Update signs after collapse/expand or head change
       */
      refreshSigns() {
        let { selection, nvim, bufnr } = this;
        if (!selection.length || !bufnr) return;
        let buf = nvim.createBuffer(bufnr);
        nvim.pauseNotification();
        buf.unplaceSign({ group: "CocTree" });
        for (let n of selection) {
          let row = this.getItemLnum(n);
          if (row == null) continue;
          buf.placeSign({ id: signOffset + row, lnum: row + 1, name: "CocTreeSelected", group: "CocTree" });
        }
        nvim.resumeNotification(false, true);
      }
      // Render all tree items
      async render() {
        if (!this.bufnr) return;
        let release = await this.mutex.acquire();
        try {
          let lines = [];
          let highlights = [];
          let { startLnum } = this;
          let nodes = await Promise.resolve(this.provider.getChildren());
          let level2 = 0;
          let lnum = startLnum;
          let renderedItems = [];
          if (isFalsyOrEmpty(nodes)) {
            this.message = "No results";
          } else {
            if (this.message == "No results") this.message = "";
            for (let node of nodes) {
              let n = await this.appendTreeNode(node, level2, lnum, renderedItems, highlights);
              lnum += n;
            }
          }
          lines.push(...renderedItems.map((o) => o.line));
          this.renderedItems = renderedItems;
          let delta = this.startLnum - startLnum;
          highlights.forEach((o) => o.lnum = o.lnum + delta);
          this.updateUI(lines, highlights, this.startLnum, -1);
          this._onDidRefrash.fire();
          this.retryTimers = 0;
          release();
        } catch (err) {
          logger21.error("Error on render", err);
          this.renderedItems = [];
          this.nodesMap.clear();
          this.lineState = { titleCount: 0, messageCount: 1 };
          release();
          let errMsg = `${err}`.replace(/\r?\n/g, " ");
          this.updateUI([errMsg], [{ hlGroup: "WarningMsg", colStart: 0, colEnd: byteLength(errMsg), lnum: 0 }]);
          if (this.retryTimers == maxRetry) return;
          this.timer = setTimeout(() => {
            this.retryTimers = this.retryTimers + 1;
            void this.render();
          }, retryTimeout);
        }
      }
      async show(splitCommand = "belowright 30vs", waitRender = true) {
        let { nvim } = this;
        let [targetBufnr, windowId] = await nvim.eval(`[bufnr("%"),win_getid()]`);
        this._targetBufnr = targetBufnr;
        this._targetWinId = windowId;
        let opts = {
          command: splitCommand,
          bufname: this.bufname,
          viewId: this.viewId.replace(/"/g, '\\"'),
          bufnr: defaultValue(this.bufnr, -1),
          winid: defaultValue(this.winid, -1),
          bufhidden: defaultValue(this.opts.bufhidden, "wipe"),
          canSelectMany: this.opts.canSelectMany === true,
          winfixwidth: this.winfixwidth === true
        };
        let [bufnr, winid, tabId] = await nvim.call("coc#ui#create_tree", [opts]);
        this.bufnr = bufnr;
        this.winid = winid;
        this._targetTabId = tabId;
        if (winid != opts.winid) this._onDidChangeVisibility.fire({ visible: true });
        if (bufnr == opts.bufnr) return true;
        this.registerKeymaps();
        this.updateHeadLines(true);
        let promise = this.render();
        if (waitRender) await promise;
        return true;
      }
      registerLocalKeymap(mode, key, fn, notify = false) {
        if (!this.bufnr) {
          this._keymapDefs.push({ mode, key, fn, notify });
        } else {
          this.addLocalKeymap(mode, key, fn, notify);
        }
      }
      addLocalKeymap(mode, key, fn, notify = true) {
        if (!key) return;
        workspace_default.registerLocalKeymap(this.bufnr, mode, key, async () => {
          let lnum = await this.nvim.call("line", ["."]);
          let element = this.getElementByLnum(lnum - 1);
          await Promise.resolve(fn(element));
        }, notify);
      }
      registerKeymaps() {
        let { toggleSelection, actions, close, invoke, toggle, collapseAll, activeFilter } = this.keys;
        let { nvim, _keymapDefs } = this;
        this.disposables.push(workspace_default.registerLocalKeymap(this.bufnr, "n", "<C-o>", () => {
          nvim.call("win_gotoid", [this._targetWinId], true);
        }, true));
        this.addLocalKeymap("n", "<LeftRelease>", async (element) => {
          if (element) await this.onClick(element);
        });
        if (this.filter != null) {
          this.addLocalKeymap("n", activeFilter, async () => {
            this.nvim.command(`exe ${this.startLnum}`, true);
            this.filter.active();
            this.filterText = "";
            this._onDidFilterStateChange.fire(true);
          });
        }
        this.addLocalKeymap("n", toggleSelection, (element) => this.toggleSelection(element));
        this.addLocalKeymap("n", invoke, (element) => this.invokeCommand(element));
        this.addLocalKeymap("n", actions, (element) => this.invokeActions(element));
        this.addLocalKeymap("n", toggle, (element) => this.toggleExpand(element));
        this.addLocalKeymap("n", collapseAll, () => this.collapseAll());
        this.addLocalKeymap("n", close, () => this.hide());
        while (_keymapDefs.length) {
          const def = _keymapDefs.pop();
          this.addLocalKeymap(def.mode, def.key, def.fn, def.notify);
        }
      }
      hide() {
        this.nvim.call("coc#window#close", [this.winid], true);
        this.redraw();
        this.winid = void 0;
        this._onDidChangeVisibility.fire({ visible: false });
      }
      redraw() {
        if (workspace_default.isVim || this.filter?.activated) {
          this.nvim.command("redraw", true);
        }
      }
      async collapseAll() {
        for (let obj of this.nodesMap.values()) {
          let item = obj.item;
          if (item.collapsibleState == 2 /* Expanded */) {
            item.collapsibleState = 1 /* Collapsed */;
          }
        }
        await this.render();
      }
      cancelResolve() {
        if (this.resolveTokenSource) {
          this.resolveTokenSource.cancel();
          this.resolveTokenSource = void 0;
        }
      }
      dispose() {
        if (!this.provider) return;
        if (this.timer) clearTimeout(this.timer);
        this.cancelResolve();
        let { bufnr } = this;
        if (this.winid) this._onDidChangeVisibility.fire({ visible: false });
        if (bufnr) this.nvim.command(`silent! bwipeout! ${bufnr}`, true);
        this._keymapDefs = [];
        this.winid = void 0;
        this.bufnr = void 0;
        this.filter?.dispose();
        this._selection = [];
        this.itemsToFilter = [];
        this.tooltipFactory.dispose();
        this.renderedItems = [];
        this.nodesMap.clear();
        this.provider = void 0;
        this._onDispose.fire();
        this._onDispose.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/window.ts
var Window, window_default;
var init_window = __esm({
  "src/window.ts"() {
    "use strict";
    init_channels();
    init_dialogs();
    init_highlights();
    init_notifications();
    init_terminals();
    init_ui();
    init_object();
    init_protocol();
    Window = class {
      constructor() {
        this.highlights = new Highlights();
        this.terminalManager = new Terminals();
        this.dialogs = new Dialogs();
        this.notifications = new Notifications(this.dialogs);
        Object.defineProperty(this.highlights, "nvim", {
          get: () => this.nvim
        });
        Object.defineProperty(this.dialogs, "nvim", {
          get: () => this.nvim
        });
        Object.defineProperty(this.dialogs, "configuration", {
          get: () => this.workspace.initialConfiguration
        });
        Object.defineProperty(this.notifications, "nvim", {
          get: () => this.nvim
        });
        Object.defineProperty(this.notifications, "configuration", {
          get: () => this.workspace.initialConfiguration
        });
        Object.defineProperty(this.notifications, "statusLine", {
          get: () => this.workspace.statusLine
        });
      }
      init(_env) {
      }
      get activeTextEditor() {
        return this.workspace.editors.activeTextEditor;
      }
      get visibleTextEditors() {
        return this.workspace.editors.visibleTextEditors;
      }
      get onDidTabClose() {
        return this.workspace.editors.onDidTabClose;
      }
      get onDidChangeActiveTextEditor() {
        return this.workspace.editors.onDidChangeActiveTextEditor;
      }
      get onDidChangeVisibleTextEditors() {
        return this.workspace.editors.onDidChangeVisibleTextEditors;
      }
      get terminals() {
        return this.terminalManager.terminals;
      }
      get onDidOpenTerminal() {
        return this.terminalManager.onDidOpenTerminal;
      }
      get onDidCloseTerminal() {
        return this.terminalManager.onDidCloseTerminal;
      }
      async createTerminal(opts) {
        return await this.terminalManager.createTerminal(this.nvim, opts);
      }
      /**
       * Run command in vim terminal for result
       * @param cmd Command to run.
       * @param cwd Cwd of terminal, default to result of |getcwd()|.
       */
      async runTerminalCommand(cmd, cwd2, keepfocus = false) {
        return await this.terminalManager.runTerminalCommand(this.nvim, cmd, cwd2, keepfocus);
      }
      /**
       * Open terminal window.
       * @param cmd Command to run.
       * @param opts Terminal option.
       * @returns number buffer number of terminal
       */
      async openTerminal(cmd, opts) {
        return await this.terminalManager.openTerminal(this.nvim, cmd, opts);
      }
      /**
       * Reveal message with message type.
       * @param msg Message text to show.
       * @param messageType Type of message, could be `error` `warning` and `more`, default to `more`
       */
      showMessage(msg, messageType = "more") {
        this.notifications.echoMessages(msg, messageType);
      }
      /**
       * Create a new output channel
       * @param name Unique name of output channel.
       * @returns A new output channel.
       */
      createOutputChannel(name2) {
        return channels_default.create(name2, this.nvim);
      }
      /**
       * Reveal buffer of output channel.
       * @param name Name of output channel.
       * @param cmd command for open output channel.
       * @param preserveFocus Preserve window focus when true.
       */
      showOutputChannel(name2, cmd, preserveFocus) {
        let command = cmd ? cmd : this.configuration.get("workspace.openOutputCommand", "vs");
        channels_default.show(name2, command, preserveFocus);
      }
      /**
       * Echo lines at the bottom of vim.
       * @param lines Line list.
       * @param truncate Truncate the lines to avoid 'press enter to continue' when true
       */
      async echoLines(lines, truncate = false) {
        await echoLines(this.nvim, this.workspace.env, lines, truncate);
      }
      /**
       * Get current cursor position (line, character both 0 based).
       * @returns Cursor position.
       */
      getCursorPosition() {
        return getCursorPosition(this.nvim);
      }
      /**
       * Move cursor to position.
       * @param position LSP position.
       */
      async moveTo(position) {
        await moveTo(this.nvim, position, this.workspace.env.isVim);
      }
      /**
       * Get selected range for current document
       */
      getSelectedRange(mode) {
        return getSelection(this.nvim, mode);
      }
      /**
       * Visual select range of current document
       */
      async selectRange(range) {
        await selectRange(this.nvim, range, this.nvim.isVim);
      }
      /**
       * Get current cursor character offset in document,
       * length of line break would always be 1.
       * @returns Character offset.
       */
      getOffset() {
        return getOffset(this.nvim);
      }
      /**
       * Get screen position of current cursor(relative to editor),
       * both `row` and `col` are 0 based.
       * @returns Cursor screen position.
       */
      getCursorScreenPosition() {
        return getCursorScreenPosition(this.nvim);
      }
      /**
       * Create a {@link TreeView} instance.
       * @param viewId Id of the view, used as title of TreeView when title doesn't exist.
       * @param options Options for creating the {@link TreeView}
       * @returns a {@link TreeView}.
       */
      createTreeView(viewId, options2) {
        const BasicTreeView2 = (init_TreeView(), __toCommonJS(TreeView_exports)).default;
        return new BasicTreeView2(viewId, options2);
      }
      /**
       * Create statusbar item that would be included in `g:coc_status`.
       * @param priority Higher priority item would be shown right.
       * @param option
       * @return A new status bar item.
       */
      createStatusBarItem(priority = 0, option = {}) {
        return this.workspace.statusLine.createStatusBarItem(priority, option.progress);
      }
      /**
       * Get diff from highlight items and current highlights on vim.
       * Return null when buffer not loaded
       * @param bufnr Buffer number
       * @param ns Highlight namespace
       * @param items Highlight items
       * @param region 0 based start and end line count (end inclusive)
       * @param token CancellationToken
       * @returns {Promise<HighlightDiff | null>}
       */
      async diffHighlights(bufnr, ns, items, region, token) {
        return this.highlights.diffHighlights(bufnr, ns, items, region, token);
      }
      /**
       * Create a FloatFactory, user's configurations are respected.
       * @param {FloatWinConfig} conf - Float window configuration
       * @returns {FloatFactory}
       */
      createFloatFactory(conf) {
        let configuration2 = this.workspace.initialConfiguration;
        let defaults = toObject(configuration2.get("floatFactory.floatConfig"));
        let markdownPreference = this.workspace.configurations.markdownPreference;
        return createFloatFactory(this.workspace.nvim, Object.assign({ ...markdownPreference, maxWidth: 80 }, conf), defaults);
      }
      /**
       * Show quickpick for single item, use `window.menuPick` for menu at current current position.
       * @deprecated Use 'window.showMenuPicker()' or `window.showQuickPick` instead.
       * @param items Label list.
       * @param placeholder Prompt text, default to 'choose by number'.
       * @returns Index of selected item, or -1 when canceled.
       */
      async showQuickpick(items, placeholder = "Choose by number") {
        return await this.showMenuPicker(items, { title: placeholder, position: "center" });
      }
      /**
       * Shows a selection list.
       */
      async showQuickPick(itemsOrItemsPromise, options2, token = import_node4.CancellationToken.None) {
        return await this.dialogs.showQuickPick(itemsOrItemsPromise, options2, token);
      }
      /**
       * Creates a {@link QuickPick} to let the user pick an item or items from a
       * list of items of type T.
       *
       * Note that in many cases the more convenient {@link window.showQuickPick}
       * is easier to use. {@link window.createQuickPick} should be used
       * when {@link window.showQuickPick} does not offer the required flexibility.
       * @return A new {@link QuickPick}.
       */
      async createQuickPick(config = {}) {
        return await this.dialogs.createQuickPick(config);
      }
      async requestInputList(prompt, items) {
        if (items.length > this.workspace.env.lines) {
          items = items.slice(0, this.workspace.env.lines - 2);
        }
        return await this.dialogs.requestInputList(prompt, items);
      }
      /**
       * Show menu picker at current cursor position.
       * @param items Array of texts.
       * @param option Options for menu.
       * @param token A token that can be used to signal cancellation.
       * @returns Selected index (0 based), -1 when canceled.
       */
      async showMenuPicker(items, option, token) {
        return await this.dialogs.showMenuPicker(items, option, token);
      }
      /**
       * Prompt user for confirm, a float/popup window would be used when possible,
       * use vim's |confirm()| function as callback.
       * @param title The prompt text.
       * @returns Result of confirm.
       */
      async showPrompt(title) {
        return await this.dialogs.showPrompt(title);
      }
      /**
       * Show dialog window at the center of screen.
       * Note that the dialog would always be closed after button click.
       * @param config Dialog configuration.
       * @returns Dialog or null when dialog can't work.
       */
      async showDialog(config) {
        return await this.dialogs.showDialog(config);
      }
      /**
       * Request input from user
       * @param title Title text of prompt window.
       * @param value Default value of input, empty text by default.
       * @param {InputOptions} option for input window
       * @returns {Promise<string>}
       */
      async requestInput(title, value, option) {
        return await this.dialogs.requestInput(title, this.workspace.env, value, option);
      }
      /**
       * Creates and show a {@link InputBox} to let the user enter some text input.
       * @return A new {@link InputBox}.
       */
      async createInputBox(title, value, option) {
        return await this.dialogs.createInputBox(title, value, option);
      }
      async showPickerDialog(items, title, token) {
        return await this.dialogs.showPickerDialog(items, title, token);
      }
      /**
       * Show an information message to users. Optionally provide an array of items which will be presented as
       * clickable buttons.
       * @param message The message to show.
       * @param items A set of items that will be rendered as actions in the message.
       * @return Promise that resolves to the selected item or `undefined` when being dismissed.
       */
      async showInformationMessage(message, ...items) {
        return await this.notifications._showMessage("Info", message, items);
      }
      /**
       * Show an warning message to users. Optionally provide an array of items which will be presented as
       * clickable buttons.
       * @param message The message to show.
       * @param items A set of items that will be rendered as actions in the message.
       * @return Promise that resolves to the selected item or `undefined` when being dismissed.
       */
      async showWarningMessage(message, ...items) {
        return await this.notifications._showMessage("Warning", message, items);
      }
      /**
       * Show an error message to users. Optionally provide an array of items which will be presented as
       * clickable buttons.
       * @param message The message to show.
       * @param items A set of items that will be rendered as actions in the message.
       * @return Promise that resolves to the selected item or `undefined` when being dismissed.
       */
      async showErrorMessage(message, ...items) {
        return await this.notifications._showMessage("Error", message, items);
      }
      async showNotification(config) {
        let stack = Error().stack;
        await this.notifications.showNotification(config, stack);
      }
      /**
       * Show progress in the editor. Progress is shown while running the given callback
       * and while the promise it returned isn't resolved nor rejected.
       */
      async withProgress(options2, task) {
        return this.notifications.withProgress(options2, task);
      }
      /**
       * Apply highlight diffs, normally used with `window.diffHighlights`
       *
       * Timer is used to add highlights when there're too many highlight items to add,
       * the highlight process won't be finished on that case.
       * @param {number} bufnr - Buffer name
       * @param {string} ns - Namespace
       * @param {number} priority
       * @param {HighlightDiff} diff
       * @param {boolean} notify - Use notification, default false.
       * @returns {Promise<void>}
       */
      async applyDiffHighlights(bufnr, ns, priority, diff, notify = false) {
        return this.highlights.applyDiffHighlights(bufnr, ns, priority, diff, notify);
      }
      /**
       * Get visible ranges of bufnr with optional winid
       */
      async getVisibleRanges(bufnr, winid) {
        return await getVisibleRanges(this.nvim, bufnr, winid);
      }
      get configuration() {
        return this.workspace.initialConfiguration;
      }
      dispose() {
        this.terminalManager.dispose();
      }
    };
    window_default = new Window();
  }
});

// src/completion/types.ts
var SourceType;
var init_types2 = __esm({
  "src/completion/types.ts"() {
    "use strict";
    SourceType = /* @__PURE__ */ ((SourceType2) => {
      SourceType2[SourceType2["Native"] = 0] = "Native";
      SourceType2[SourceType2["Remote"] = 1] = "Remote";
      SourceType2[SourceType2["Service"] = 2] = "Service";
      return SourceType2;
    })(SourceType || {});
  }
});

// src/util/async.ts
function waitImmediate2() {
  return new Promise((resolve) => {
    setImmediate(() => {
      resolve(void 0);
    });
  });
}
async function runSequence(funcs, token) {
  for (const fn of funcs) {
    if (token.isCancellationRequested) {
      break;
    }
    await fn();
  }
}
async function forEach(items, func2, token, options2) {
  if (items.length === 0) {
    return;
  }
  const timer = new Timer(options2?.yieldAfter);
  function runBatch(start) {
    timer.start();
    for (let i = start; i < items.length; i++) {
      func2(items[i]);
      if (timer.shouldYield()) {
        if (options2?.yieldCallback) {
          options2.yieldCallback();
        }
        return i + 1;
      }
    }
    return -1;
  }
  let index = runBatch(0);
  while (index !== -1) {
    await waitImmediate2();
    if (token !== void 0 && token.isCancellationRequested) {
      break;
    }
    index = runBatch(index);
  }
}
async function filter(items, isValid, onFilter, token) {
  if (items.length === 0) return;
  const timer = new Timer();
  const len = items.length;
  function convertBatch(start) {
    const result = [];
    timer.start();
    for (let i = start; i < len; i++) {
      let item = items[i];
      let res = isValid(item);
      if (res === true) {
        result.push(item);
      } else if (res) {
        result.push(Object.assign({}, item, res));
      }
      if (timer.shouldYield()) {
        let done = i === len - 1;
        onFilter(result, done);
        return done ? -1 : i + 1;
      }
    }
    onFilter(result, true);
    return -1;
  }
  let index = convertBatch(0);
  while (index !== -1) {
    await waitImmediate2();
    if (token != null && token.isCancellationRequested) {
      break;
    }
    index = convertBatch(index);
  }
}
var defaultYieldTimeout, Timer;
var init_async = __esm({
  "src/util/async.ts"() {
    "use strict";
    defaultYieldTimeout = 15;
    Timer = class {
      constructor(yieldAfter = defaultYieldTimeout) {
        this.yieldAfter = Math.max(yieldAfter, defaultYieldTimeout);
        this.startTime = Date.now();
        this.counter = 0;
        this.total = 0;
        this.counterInterval = 1;
      }
      start() {
        this.startTime = Date.now();
      }
      shouldYield() {
        if (++this.counter >= this.counterInterval) {
          const timeTaken = Date.now() - this.startTime;
          const timeLeft = Math.max(0, this.yieldAfter - timeTaken);
          this.total += this.counter;
          this.counter = 0;
          if (timeTaken >= this.yieldAfter || timeLeft <= 1) {
            this.counterInterval = 1;
            this.total = 0;
            return true;
          } else {
            switch (timeTaken) {
              case 0:
              case 1:
                this.counterInterval = this.total * 2;
                break;
            }
          }
        }
        return false;
      }
    };
  }
});

// src/snippets/eval.ts
function generateContextId(bufnr) {
  return `${bufnr}-${context_id++}`;
}
function hasPython(snip) {
  if (!snip) return false;
  if (snip.context) return true;
  if (snip.actions && Object.keys(snip.actions).length > 0) return true;
  return false;
}
function getResetPythonCode(context) {
  const pyCodes = [];
  pyCodes.push(`${contexts_var} = ${contexts_var} if '${contexts_var}' in locals() else {}`);
  pyCodes.push(`context = ${contexts_var}.get('${context.id}', {}).get('context', None)`);
  pyCodes.push(`match = ${contexts_var}.get('${context.id}', {}).get('match', None)`);
  return pyCodes;
}
function getPyBlockCode(snip) {
  let { range, line } = snip;
  let pyCodes = [
    "import re, os, vim, string, random",
    `path = vim.eval('coc#util#get_fullpath()') or ""`,
    `fn = os.path.basename(path)`
  ];
  let start = `(${range.start.line},${range.start.character})`;
  let end = `(${range.start.line},${range.end.character})`;
  let indent = line.match(/^\s*/)[0];
  pyCodes.push(...getResetPythonCode(snip));
  pyCodes.push(`snip = SnippetUtil("${escapeString(indent)}", ${start}, ${end}, context)`);
  return pyCodes;
}
function getInitialPythonCode(context) {
  let pyCodes = [
    "import re, os, vim, string, random",
    `path = vim.eval('coc#util#get_fullpath()') or ""`,
    `fn = os.path.basename(path)`
  ];
  let { range, regex: regex2, line, id: id2 } = context;
  if (context.context) {
    pyCodes.push(`snip = ContextSnippet()`);
    pyCodes.push(`context = ${context.context}`);
  } else {
    pyCodes.push(`context = None`);
  }
  if (regex2 && Range.is(range)) {
    let trigger = line.slice(range.start.character, range.end.character);
    pyCodes.push(`pattern = re.compile("${escapeString(regex2)}")`);
    pyCodes.push(`match = pattern.search("${escapeString(trigger)}")`);
  } else {
    pyCodes.push(`match = None`);
  }
  pyCodes.push(`${contexts_var} = ${contexts_var} if '${contexts_var}' in locals() else {}`);
  let prefix = id2.match(/^\w+-/)[0];
  pyCodes.push(`${contexts_var} = {k: v for k, v in ${contexts_var}.items() if k.startswith('${prefix}')}`);
  pyCodes.push(`${contexts_var}['${context.id}'] = {'context': context, 'match': match}`);
  return pyCodes;
}
async function executePythonCode(nvim, codes) {
  if (codes.length == 0) return;
  let lines = [...codes];
  lines.unshift(`__requesting = ${events_default.requesting ? "True" : "False"}`);
  try {
    await nvim.command(`pyx ${addPythonTryCatch(lines.join("\n"))}`);
  } catch (e) {
    let err = new Error(e.message);
    err.stack = `Error on execute python code:
${codes.join("\n")}
` + e.stack;
    throw err;
  }
}
function getVariablesCode(values) {
  let keys = Object.keys(values);
  if (keys.length == 0) return `t = ()`;
  let maxIndex = Math.max.apply(null, keys.map((v) => Number(v)));
  let vals = new Array(maxIndex).fill('""');
  for (let [idx, val] of Object.entries(values)) {
    vals[idx] = `"${escapeString(val)}"`;
  }
  return `t = (${vals.join(",")},)`;
}
function addPythonTryCatch(code, force = false) {
  if (!isVim && force === false) return code;
  let lines = [
    "import traceback, vim",
    `vim.vars['errmsg'] = ''`,
    "try:"
  ];
  lines.push(...code.split("\n").map((line) => "    " + line));
  lines.push("except Exception as e:");
  lines.push(`    vim.vars['errmsg'] = traceback.format_exc()`);
  return lines.join("\n");
}
function escapeString(input) {
  return input.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\t/g, "\\t").replace(/\n/g, "\\n");
}
var contexts_var, context_id;
var init_eval = __esm({
  "src/snippets/eval.ts"() {
    "use strict";
    init_main();
    init_events();
    init_constants();
    contexts_var = "__coc_ultisnip_contexts";
    context_id = 1;
  }
});

// src/snippets/string.ts
var SnippetString;
var init_string2 = __esm({
  "src/snippets/string.ts"() {
    "use strict";
    SnippetString = class _SnippetString {
      constructor(value) {
        this._tabstop = 1;
        this.value = value || "";
      }
      static isSnippetString(thing) {
        if (thing instanceof _SnippetString) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return typeof thing.value === "string";
      }
      static _escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      appendText(str) {
        this.value += _SnippetString._escape(str);
        return this;
      }
      appendTabstop(num = this._tabstop++) {
        this.value += "$";
        this.value += num;
        return this;
      }
      appendPlaceholder(value, num = this._tabstop++) {
        if (typeof value === "function") {
          const nested = new _SnippetString();
          nested._tabstop = this._tabstop;
          value(nested);
          this._tabstop = nested._tabstop;
          value = nested.value;
        } else {
          value = _SnippetString._escape(value);
        }
        this.value += "${";
        this.value += num;
        this.value += ":";
        this.value += value;
        this.value += "}";
        return this;
      }
      appendChoice(values, num = this._tabstop++) {
        const value = values.map((s) => s.replaceAll(/[|\\,]/g, "\\$&")).join(",");
        this.value += "${";
        this.value += num;
        this.value += "|";
        this.value += value;
        this.value += "|}";
        return this;
      }
      appendVariable(name2, defaultValue2) {
        if (typeof defaultValue2 === "function") {
          const nested = new _SnippetString();
          nested._tabstop = this._tabstop;
          defaultValue2(nested);
          this._tabstop = nested._tabstop;
          defaultValue2 = nested.value;
        } else if (typeof defaultValue2 === "string") {
          defaultValue2 = defaultValue2.replace(/\$|}/g, "\\$&");
        }
        this.value += "${";
        this.value += name2;
        if (defaultValue2) {
          this.value += ":";
          this.value += defaultValue2;
        }
        this.value += "}";
        return this;
      }
    };
  }
});

// src/snippets/util.ts
var util_exports = {};
__export(util_exports, {
  WordsSource: () => WordsSource,
  convertRegex: () => convertRegex,
  getAction: () => getAction,
  getNewRange: () => getNewRange,
  getTextAfter: () => getTextAfter,
  getTextBefore: () => getTextBefore,
  normalizeSnippetString: () => normalizeSnippetString,
  reduceTextEdit: () => reduceTextEdit,
  shouldFormat: () => shouldFormat,
  toSnippetString: () => toSnippetString,
  wordsSource: () => wordsSource
});
function convertRegex(str) {
  if (str.indexOf("\\z") !== -1) {
    throw new Error("pattern \\z not supported");
  }
  if (str.indexOf("(?s)") !== -1) {
    throw new Error("pattern (?s) not supported");
  }
  if (str.indexOf("(?x)") !== -1) {
    throw new Error("pattern (?x) not supported");
  }
  if (str.indexOf("\n") !== -1) {
    throw new Error("pattern \\n not supported");
  }
  if (conditionRe.test(str)) {
    throw new Error("pattern (?id/name)yes-pattern|no-pattern not supported");
  }
  return str.replace(regex, (match, p1) => {
    if (match.startsWith("(?#")) return "";
    if (match.startsWith("(?P<")) return "(?" + match.slice(3);
    if (match.startsWith("(?P=")) return `\\k<${p1}>`;
    return "^";
  });
}
function getAction(opt, action) {
  if (!opt || !opt.actions) return void 0;
  return opt.actions[action];
}
function shouldFormat(snippet) {
  if (/^\s/.test(snippet)) return true;
  if (snippet.indexOf("\n") !== -1) return true;
  return false;
}
function normalizeSnippetString(snippet, indent, opts) {
  let lines = snippet.split(/\r?\n/);
  let ind = opts.insertSpaces ? " ".repeat(opts.tabSize) : "	";
  let tabSize = defaultValue(opts.tabSize, 2);
  let noExpand = opts.noExpand;
  let trimTrailingWhitespace = opts.trimTrailingWhitespace;
  lines = lines.map((line, idx) => {
    let space = line.match(/^\s*/)[0];
    let pre = space;
    let isTab = space.startsWith("	");
    if (isTab && opts.insertSpaces && !noExpand) {
      pre = ind.repeat(space.length);
    } else if (!isTab && !opts.insertSpaces) {
      pre = ind.repeat(space.length / tabSize);
    }
    return (idx == 0 || trimTrailingWhitespace && line.length == 0 ? "" : indent) + pre + line.slice(space.length);
  });
  return lines.join("\n");
}
function getNewRange(base, pos, value) {
  const { line, character } = base;
  const start = {
    line: line + pos.line,
    character: pos.line == 0 ? character + pos.character : pos.character
  };
  return Range.create(start, getEnd(start, value));
}
function reduceTextEdit(edit2, oldText) {
  let { range, newText } = edit2;
  let ol = oldText.length;
  let nl = newText.length;
  if (ol === 0 || nl === 0) return edit2;
  let { start, end } = range;
  let bo = 0;
  for (let i = 1; i <= Math.min(nl, ol); i++) {
    if (newText[i - 1] === oldText[i - 1]) {
      bo = i;
    } else {
      break;
    }
  }
  let eo = 0;
  let t = Math.min(nl - bo, ol - bo);
  if (t > 0) {
    for (let i = 1; i <= t; i++) {
      if (newText[nl - i] === oldText[ol - i]) {
        eo = i;
      } else {
        break;
      }
    }
  }
  let text = eo == 0 ? newText.slice(bo) : newText.slice(bo, -eo);
  if (bo > 0) start = getEnd(start, newText.slice(0, bo));
  if (eo > 0) end = getEnd(range.start, oldText.slice(0, -eo));
  return TextEdit.replace(Range.create(start, end), text);
}
function getTextBefore(range, text, pos) {
  let newLines = [];
  let { line, character } = range.start;
  let n = pos.line - line;
  const lines = text.split("\n");
  for (let i = 0; i <= n; i++) {
    let line2 = lines[i];
    if (i == n) {
      newLines.push(line2.slice(0, i == 0 ? pos.character - character : pos.character));
    } else {
      newLines.push(line2);
    }
  }
  return newLines.join("\n");
}
function getTextAfter(range, text, pos) {
  let newLines = [];
  let n = range.end.line - pos.line;
  const lines = text.split("\n");
  let len = lines.length;
  for (let i = 0; i <= n; i++) {
    let idx = len - i - 1;
    let line = lines[idx];
    if (i == n) {
      let sc = range.start.character;
      let from = idx == 0 ? pos.character - sc : pos.character;
      newLines.unshift(line.slice(from));
    } else {
      newLines.unshift(line);
    }
  }
  return newLines.join("\n");
}
function toSnippetString(snippet) {
  if (typeof snippet !== "string" && !SnippetString.isSnippetString(snippet)) {
    throw new TypeError(`snippet should be string or SnippetString`);
  }
  return SnippetString.isSnippetString(snippet) ? snippet.value : snippet;
}
var stringStartRe, conditionRe, commentRe, namedCaptureRe, namedReferenceRe, regex, WordsSource, wordsSource;
var init_util3 = __esm({
  "src/snippets/util.ts"() {
    "use strict";
    init_main();
    init_util();
    init_position();
    init_string2();
    stringStartRe = /\\A/;
    conditionRe = /\(\?\(\w+\).+\|/;
    commentRe = /\(\?#.*?\)/;
    namedCaptureRe = /\(\?P<\w+>.*?\)/;
    namedReferenceRe = /\(\?P=(\w+)\)/;
    regex = new RegExp(`${commentRe.source}|${stringStartRe.source}|${namedCaptureRe.source}|${namedReferenceRe.source}`, "g");
    WordsSource = class {
      constructor() {
        this.name = "$words";
        this.shortcut = "";
        this.triggerOnly = true;
        this.words = [];
      }
      doComplete(opt) {
        return {
          startcol: this.startcol,
          items: this.words.map((s) => {
            return { word: s, filterText: opt.input };
          })
        };
      }
    };
    wordsSource = new WordsSource();
  }
});

// src/snippets/parser.ts
function walk(marker, visitor, ignoreChild = false) {
  const stack = [...marker];
  while (stack.length > 0) {
    const marker2 = stack.shift();
    if (ignoreChild && marker2 instanceof TextmateSnippet) continue;
    const recurse = visitor(marker2);
    if (!recurse) {
      break;
    }
    stack.unshift(...marker2.children);
  }
}
function transformEscapes(input, backslashIndexes = []) {
  let res = "";
  let len = input.length;
  let i = 0;
  let toUpper = false;
  let toLower2 = false;
  while (i < len) {
    let ch = input[i];
    if (ch.charCodeAt(0) === 92 /* Backslash */ && !backslashIndexes.includes(i)) {
      let next = input[i + 1];
      if (escapedCharacters.includes(next)) {
        i++;
        continue;
      }
      if (next == "u" || next == "l") {
        let follow = input[i + 2];
        if (follow) res = res + (next == "u" ? follow.toUpperCase() : follow.toLowerCase());
        i = i + 3;
        continue;
      }
      if (next == "U" || next == "L") {
        if (next == "U") {
          toUpper = true;
        } else {
          toLower2 = true;
        }
        i = i + 2;
        continue;
      }
      if (next == "E") {
        toUpper = false;
        toLower2 = false;
        i = i + 2;
        continue;
      }
      if (next == "n") {
        res += "\n";
        i = i + 2;
        continue;
      }
      if (next == "t") {
        res += "	";
        i = i + 2;
        continue;
      }
    }
    if (toUpper) {
      ch = ch.toUpperCase();
    } else if (toLower2) {
      ch = ch.toLowerCase();
    }
    res += ch;
    i++;
  }
  return res;
}
function mergeTexts(marker, begin = 0) {
  let { children } = marker;
  let end;
  let start;
  for (let i = begin; i < children.length; i++) {
    let m2 = children[i];
    if (m2 instanceof Text) {
      if (start !== void 0) {
        end = i;
      } else {
        start = i;
      }
    } else {
      if (end !== void 0) {
        break;
      }
      start = void 0;
    }
  }
  if (end === void 0) return;
  let newText = "";
  for (let i = start; i <= end; i++) {
    newText += children[i].toString();
  }
  let m = new Text(newText);
  children.splice(start, end - start + 1, m);
  m.parent = marker;
  return mergeTexts(marker, start + 1);
}
function getPlaceholderId(p) {
  if (typeof p.id === "number") return p.id;
  p.id = id++;
  return p.id;
}
var import_child_process, logger22, ULTISNIP_VARIABLES, id, snippet_id, knownRegexOptions, ultisnipSpecialEscape, Scanner, Marker, Text, CodeBlock, TransformableMarker, Placeholder, Choice, Transform, ConditionString, FormatString, Variable, TextmateSnippet, SnippetParser, escapedCharacters;
var init_parser3 = __esm({
  "src/snippets/parser.ts"() {
    "use strict";
    import_child_process = require("child_process");
    init_logger();
    init_array();
    init_async();
    init_charCode();
    init_errors();
    init_node();
    init_string();
    init_eval();
    init_util3();
    logger22 = createLogger("snippets-parser");
    ULTISNIP_VARIABLES = ["VISUAL", "YANK", "UUID"];
    id = 0;
    snippet_id = 0;
    knownRegexOptions = ["d", "g", "i", "m", "s", "u", "y"];
    ultisnipSpecialEscape = ["u", "l", "U", "L", "E", "n", "t"];
    Scanner = class _Scanner {
      static {
        this._table = {
          [36 /* DollarSign */]: 0 /* Dollar */,
          [58 /* Colon */]: 1 /* Colon */,
          [44 /* Comma */]: 2 /* Comma */,
          [123 /* OpenCurlyBrace */]: 3 /* CurlyOpen */,
          [125 /* CloseCurlyBrace */]: 4 /* CurlyClose */,
          [92 /* Backslash */]: 5 /* Backslash */,
          [47 /* Slash */]: 6 /* Forwardslash */,
          [124 /* Pipe */]: 7 /* Pipe */,
          [43 /* Plus */]: 11 /* Plus */,
          [45 /* Dash */]: 12 /* Dash */,
          [63 /* QuestionMark */]: 13 /* QuestionMark */,
          [40 /* OpenParen */]: 15 /* OpenParen */,
          [41 /* CloseParen */]: 16 /* CloseParen */,
          [96 /* BackTick */]: 17 /* BackTick */,
          [33 /* ExclamationMark */]: 18 /* ExclamationMark */
        };
      }
      static isDigitCharacter(ch) {
        return ch >= 48 /* Digit0 */ && ch <= 57 /* Digit9 */;
      }
      static isVariableCharacter(ch) {
        return ch === 95 /* Underline */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 65 /* A */ && ch <= 90 /* Z */;
      }
      constructor() {
        this.text("");
      }
      text(value) {
        this.value = value;
        this.pos = 0;
      }
      tokenText(token) {
        return this.value.substr(token.pos, token.len);
      }
      isEnd() {
        return this.pos >= this.value.length;
      }
      next() {
        if (this.pos >= this.value.length) {
          return { type: 14 /* EOF */, pos: this.pos, len: 0 };
        }
        let pos = this.pos;
        let len = 0;
        let ch = this.value.charCodeAt(pos);
        let type;
        type = _Scanner._table[ch];
        if (typeof type === "number") {
          this.pos += 1;
          return { type, pos, len: 1 };
        }
        if (_Scanner.isDigitCharacter(ch)) {
          type = 8 /* Int */;
          do {
            len += 1;
            ch = this.value.charCodeAt(pos + len);
          } while (_Scanner.isDigitCharacter(ch));
          this.pos += len;
          return { type, pos, len };
        }
        if (_Scanner.isVariableCharacter(ch)) {
          type = 9 /* VariableName */;
          do {
            ch = this.value.charCodeAt(pos + ++len);
          } while (_Scanner.isVariableCharacter(ch) || _Scanner.isDigitCharacter(ch));
          this.pos += len;
          return { type, pos, len };
        }
        type = 10 /* Format */;
        do {
          len += 1;
          ch = this.value.charCodeAt(pos + len);
        } while (!isNaN(ch) && typeof _Scanner._table[ch] === "undefined" && !_Scanner.isDigitCharacter(ch) && !_Scanner.isVariableCharacter(ch));
        this.pos += len;
        return { type, pos, len };
      }
    };
    Marker = class {
      constructor() {
        this._children = [];
      }
      appendChild(child) {
        if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
          this._children[this._children.length - 1].value += child.value;
        } else {
          child.parent = this;
          this._children.push(child);
        }
        return this;
      }
      setOnlyChild(child) {
        child.parent = this;
        this._children = [child];
      }
      replaceChildren(children) {
        for (const child of children) {
          child.parent = this;
        }
        this._children = children;
      }
      replaceWith(newMarker) {
        if (!this.parent) return false;
        let p = this.parent;
        let idx = p.children.indexOf(this);
        if (idx == -1) return false;
        newMarker.parent = p;
        p.children.splice(idx, 1, newMarker);
        return true;
      }
      insertBefore(text) {
        if (!this.parent) return;
        let p = this.parent;
        let idx = p.children.indexOf(this);
        if (idx == -1) return;
        let prev = p.children[idx - 1];
        if (prev instanceof Text) {
          let v = prev.value;
          prev.replaceWith(new Text(v + text));
        } else {
          let marker = new Text(text);
          marker.parent = p;
          p.children.splice(idx, 0, marker);
        }
      }
      get children() {
        return this._children;
      }
      get snippet() {
        let candidate = this;
        while (true) {
          if (!candidate) {
            return void 0;
          }
          if (candidate instanceof TextmateSnippet) {
            return candidate;
          }
          candidate = candidate.parent;
        }
      }
      toString() {
        return this.children.reduce((prev, cur) => prev + cur.toString(), "");
      }
      len() {
        return 0;
      }
    };
    Text = class _Text extends Marker {
      constructor(value) {
        super();
        this.value = value;
      }
      static escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      toString() {
        return this.value;
      }
      toTextmateString() {
        return _Text.escape(this.value);
      }
      len() {
        return this.value.length;
      }
      clone() {
        return new _Text(this.value);
      }
    };
    CodeBlock = class _CodeBlock extends Marker {
      constructor(code, kind, value, related) {
        super();
        this.code = code;
        this.kind = kind;
        this._value = "";
        this._related = [];
        if (Array.isArray(related)) {
          this._related = related;
        } else if (kind === "python") {
          this._related = _CodeBlock.parseRelated(code);
        }
        if (typeof value === "string") this._value = value;
      }
      static parseRelated(code) {
        let list2 = [];
        let arr;
        let re = /\bt\[(\d+)\]/g;
        while (true) {
          arr = re.exec(code);
          if (arr == null) break;
          let n = parseInt(arr[1], 10);
          if (!list2.includes(n)) list2.push(n);
        }
        return list2;
      }
      get related() {
        return this._related;
      }
      get index() {
        if (this.parent instanceof Placeholder) {
          return this.parent.index;
        }
        return void 0;
      }
      async resolve(nvim, token) {
        if (!this.code.length) return;
        if (token?.isCancellationRequested) return;
        let res;
        if (this.kind == "python") {
          res = await this.evalPython(nvim, token);
        } else if (this.kind == "vim") {
          res = await this.evalVim(nvim);
        } else if (this.kind == "shell") {
          res = await this.evalShell();
        }
        if (token?.isCancellationRequested) return;
        if (res != null) this._value = res;
      }
      async evalShell() {
        let opts = { windowsHide: true };
        Object.assign(opts, { shell: process.env.SHELL });
        let res = await (0, import_util.promisify)(import_child_process.exec)(this.code, opts);
        return res.stdout.replace(/\s*$/, "");
      }
      async evalVim(nvim) {
        let res = await nvim.eval(this.code);
        return res == null ? "" : res.toString();
      }
      async evalPython(nvim, token) {
        let curr = toText(this._value);
        let lines = [`snip._reset("${escapeString(curr)}")`];
        lines.push(...this.code.split(/\r?\n/).map((line) => line.replace(/\t/g, "    ")));
        await executePythonCode(nvim, lines);
        if (token?.isCancellationRequested) return;
        return await nvim.call(`pyxeval`, "str(snip.rv)");
      }
      len() {
        return this._value.length;
      }
      toString() {
        return this._value;
      }
      get value() {
        return this._value;
      }
      toTextmateString() {
        let t = "";
        if (this.kind == "python") {
          t = "!p ";
        } else if (this.kind == "shell") {
          t = "";
        } else if (this.kind == "vim") {
          t = "!v ";
        }
        return "`" + t + this.code + "`";
      }
      clone() {
        return new _CodeBlock(this.code, this.kind, this.value, this._related.slice());
      }
    };
    TransformableMarker = class extends Marker {
    };
    Placeholder = class _Placeholder extends TransformableMarker {
      constructor(index) {
        super();
        this.index = index;
        this.primary = false;
      }
      get isFinalTabstop() {
        return this.index === 0;
      }
      get choice() {
        return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
      }
      toTextmateString() {
        let transformString = "";
        if (this.transform) {
          transformString = this.transform.toTextmateString();
        }
        if (this.children.length === 0 && !this.transform) {
          return `$${this.index}`;
        } else if (this.children.length === 0 || this.children.length == 1 && this.children[0].toTextmateString() == "") {
          return `\${${this.index}${transformString}}`;
        } else if (this.choice) {
          return `\${${this.index}|${this.choice.toTextmateString()}|${transformString}}`;
        } else {
          return `\${${this.index}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
        }
      }
      clone() {
        let ret = new _Placeholder(this.index);
        if (this.transform) {
          ret.transform = this.transform.clone();
        }
        ret.id = this.id;
        ret.primary = this.primary;
        ret._children = this.children.map((child) => {
          let m = child.clone();
          m.parent = ret;
          return m;
        });
        return ret;
      }
      checkParentPlaceHolders() {
        let idx = this.index;
        let p = this.parent;
        while (p != null && !(p instanceof TextmateSnippet)) {
          if (p instanceof _Placeholder && p.index == idx) {
            throw new Error(`Parent placeholder has same index: ${idx}`);
          }
          p = p.parent;
        }
      }
    };
    Choice = class _Choice extends Marker {
      constructor(index = 0) {
        super();
        this.options = [];
        this._index = index;
      }
      appendChild(marker) {
        if (marker instanceof Text) {
          marker.parent = this;
          this.options.push(marker);
        }
        return this;
      }
      toString() {
        return this.options[this._index].value;
      }
      toTextmateString() {
        return this.options.map((option) => option.value.replace(/\||,/g, "\\$&")).join(",");
      }
      len() {
        return this.options[this._index].len();
      }
      clone() {
        let ret = new _Choice(this._index);
        for (let opt of this.options) {
          ret.appendChild(opt);
        }
        return ret;
      }
    };
    Transform = class _Transform extends Marker {
      constructor() {
        super(...arguments);
        this.ascii = false;
        this.ultisnip = false;
      }
      resolve(value) {
        let didMatch = false;
        let ret = value.replace(this.regexp, (...args) => {
          didMatch = true;
          return this._replace(args.slice(0, -2));
        });
        if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) {
          ret = this._replace([]);
        }
        return ret;
      }
      _replace(groups) {
        let ret = "";
        let backslashIndexes = [];
        for (const marker of this._children) {
          let val = "";
          let len = ret.length;
          if (marker instanceof FormatString) {
            val = marker.resolve(groups[marker.index] ?? "");
            if (this.ultisnip && val.indexOf("\\") !== -1) {
              for (let idx of iterateCharacter(val, "\\")) {
                backslashIndexes.push(len + idx);
              }
            }
          } else if (marker instanceof ConditionString) {
            val = marker.resolve(groups[marker.index]);
            if (this.ultisnip) {
              val = val.replace(/(?<!\\)\$(\d+)/g, (...args) => {
                return toText(groups[Number(args[1])]);
              });
            }
          } else {
            val = marker.toString();
          }
          ret += val;
        }
        if (this.ascii) ret = unidecode(ret);
        return this.ultisnip ? transformEscapes(ret, backslashIndexes) : ret;
      }
      toString() {
        return "";
      }
      toTextmateString() {
        let format3 = this.children.map((c) => c.toTextmateString()).join("");
        if (this.ultisnip) {
          format3 = format3.replace(/\\\\(\w)/g, (match, ch) => {
            if (ultisnipSpecialEscape.includes(ch)) {
              return "\\" + ch;
            }
            return match;
          });
        }
        return `/${this.regexp.source}/${format3}/${(this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : "")}`;
      }
      clone() {
        let ret = new _Transform();
        ret.regexp = new RegExp(this.regexp.source, (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
        ret._children = this.children.map((child) => {
          let m = child.clone();
          m.parent = ret;
          return m;
        });
        return ret;
      }
    };
    ConditionString = class _ConditionString extends Marker {
      constructor(index, ifValue, elseValue) {
        super();
        this.index = index;
        this.ifValue = ifValue;
        this.elseValue = elseValue;
      }
      resolve(value) {
        if (value) return this.ifValue;
        return this.elseValue;
      }
      toTextmateString() {
        return "(?" + this.index + ":" + this.ifValue + (this.elseValue ? ":" + this.elseValue : "") + ")";
      }
      clone() {
        return new _ConditionString(this.index, this.ifValue, this.elseValue);
      }
    };
    FormatString = class _FormatString extends Marker {
      constructor(index, shorthandName, ifValue, elseValue) {
        super();
        this.index = index;
        this.shorthandName = shorthandName;
        this.ifValue = ifValue;
        this.elseValue = elseValue;
      }
      resolve(value) {
        if (this.shorthandName === "upcase") {
          return !value ? "" : value.toLocaleUpperCase();
        } else if (this.shorthandName === "downcase") {
          return !value ? "" : value.toLocaleLowerCase();
        } else if (this.shorthandName === "capitalize") {
          return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
        } else if (this.shorthandName === "pascalcase") {
          return !value ? "" : this._toPascalCase(value);
        } else if (Boolean(value) && typeof this.ifValue === "string") {
          return this.ifValue;
        } else if (!value && typeof this.elseValue === "string") {
          return this.elseValue;
        } else {
          return value || "";
        }
      }
      _toPascalCase(value) {
        const match = value.match(/[a-z]+/gi);
        if (!match) {
          return value;
        }
        return match.map((word) => word.charAt(0).toUpperCase() + word.substr(1).toLowerCase()).join("");
      }
      toTextmateString() {
        let value = "${";
        value += this.index;
        if (this.shorthandName) {
          value += `:/${this.shorthandName}`;
        } else if (this.ifValue && this.elseValue) {
          value += `:?${this.ifValue}:${this.elseValue}`;
        } else if (this.ifValue) {
          value += `:+${this.ifValue}`;
        } else if (this.elseValue) {
          value += `:-${this.elseValue}`;
        }
        value += "}";
        return value;
      }
      clone() {
        let ret = new _FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
        return ret;
      }
    };
    Variable = class _Variable extends TransformableMarker {
      constructor(name2, resolved = false) {
        super();
        this.name = name2;
        this._resolved = resolved;
      }
      get resolved() {
        return this._resolved;
      }
      async resolve(resolver2) {
        let value = await resolver2.resolve(this);
        this._resolved = true;
        if (value && value.includes("\n")) {
          let indent = "";
          this.snippet.walk((m) => {
            if (m == this) {
              return false;
            }
            if (m instanceof Text) {
              let lines2 = m.toString().split(/\r?\n/);
              indent = lines2[lines2.length - 1].match(/^\s*/)[0];
            }
            return true;
          }, true);
          let lines = value.split("\n");
          let indents = lines.filter((s) => s.length > 0).map((s) => s.match(/^\s*/)[0]);
          let minIndent = indents.reduce((p, c) => p < c.length ? p : c.length, 0);
          let newLines = lines.map((s, i) => i == 0 || s.length == 0 || !s.startsWith(" ".repeat(minIndent)) ? s : indent + s.slice(minIndent));
          value = newLines.join("\n");
        }
        if (typeof value !== "string") return false;
        if (this.transform) {
          value = this.transform.resolve(toText(value));
        }
        this._children = [new Text(value.toString())];
        return true;
      }
      toTextmateString() {
        let transformString = "";
        if (this.transform) {
          transformString = this.transform.toTextmateString();
        }
        if (this.children.length === 0) {
          return `\${${this.name}${transformString}}`;
        } else {
          return `\${${this.name}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
        }
      }
      clone() {
        const ret = new _Variable(this.name, this.resolved);
        if (this.transform) {
          ret.transform = this.transform.clone();
        }
        ret._children = this.children.map((child) => {
          let m = child.clone();
          m.parent = ret;
          return m;
        });
        return ret;
      }
    };
    TextmateSnippet = class _TextmateSnippet extends Marker {
      constructor(ultisnip, id2) {
        super();
        this.related = {};
        this.ultisnip = ultisnip === true;
        this.id = id2 ?? snippet_id++;
      }
      get hasPythonBlock() {
        if (!this.ultisnip) return false;
        return this.pyBlocks.length > 0;
      }
      get hasCodeBlock() {
        if (!this.ultisnip) return false;
        let { pyBlocks, otherBlocks } = this;
        return pyBlocks.length > 0 || otherBlocks.length > 0;
      }
      /**
       * Values for each placeholder index
       */
      get values() {
        let values = {};
        let maxIndexNumber = 0;
        this.placeholders.forEach((c) => {
          if (!Number.isInteger(c.index)) return;
          maxIndexNumber = Math.max(c.index, maxIndexNumber);
          if (c.transform != null) return;
          if (c.primary || values[c.index] === void 0) values[c.index] = c.toString();
        });
        for (let i = 0; i <= maxIndexNumber; i++) {
          if (values[i] === void 0) values[i] = "";
        }
        return values;
      }
      get orderedPyIndexBlocks() {
        let res = [];
        let filtered = this.pyBlocks.filter((o) => typeof o.index === "number");
        if (filtered.length === 0) return res;
        let allIndexes = filtered.map((o) => o.index);
        let usedIndexes = [];
        const checkBlock = (b) => {
          let { related } = b;
          if (related.length == 0 || related.every((idx) => !allIndexes.includes(idx) || usedIndexes.includes(idx))) {
            usedIndexes.push(b.index);
            res.push(b);
            return true;
          }
          return false;
        };
        while (filtered.length > 0) {
          let c = false;
          for (let b of filtered) {
            if (checkBlock(b)) {
              c = true;
            }
          }
          if (!c) {
            break;
          }
          filtered = filtered.filter((o) => !usedIndexes.includes(o.index));
        }
        return res;
      }
      async evalCodeBlocks(nvim, pyCodes) {
        const { pyBlocks, otherBlocks } = this.placeholderInfo;
        await Promise.all(otherBlocks.map((block2) => {
          let pre = block2.value;
          return block2.resolve(nvim).then(() => {
            if (block2.parent instanceof Placeholder && pre !== block2.value) {
              this.onPlaceholderUpdate(block2.parent);
            }
          });
        }));
        if (pyCodes.length === 0) return;
        let relatedBlocks = pyBlocks.filter((o) => o.index === void 0 && o.related.length > 0);
        const variableCode = getVariablesCode(this.values);
        await executePythonCode(nvim, [...pyCodes, variableCode]);
        for (let block2 of pyBlocks) {
          let pre = block2.value;
          if (relatedBlocks.includes(block2)) continue;
          await block2.resolve(nvim);
          if (pre === block2.value) continue;
          if (block2.parent instanceof Placeholder) {
            this.onPlaceholderUpdate(block2.parent);
            await executePythonCode(nvim, [getVariablesCode(this.values)]);
          }
        }
        for (let block2 of this.orderedPyIndexBlocks) {
          await this.updatePyIndexBlock(nvim, block2);
        }
        for (let block2 of relatedBlocks) {
          await block2.resolve(nvim);
        }
      }
      /**
       * Update python blocks after user change Placeholder with index
       */
      async updatePythonCodes(nvim, marker, codes, token) {
        let index = marker.index;
        let blocks = this.getDependentPyIndexBlocks(index);
        await runSequence([async () => {
          await executePythonCode(nvim, [...codes, getVariablesCode(this.values)]);
        }, async () => {
          for (let block2 of blocks) {
            await this.updatePyIndexBlock(nvim, block2, token);
          }
        }, async () => {
          let filtered = this.pyBlocks.filter((o) => o.index === void 0 && o.related.length > 0);
          for (let block2 of filtered) {
            await block2.resolve(nvim, token);
          }
        }], token);
      }
      getDependentPyIndexBlocks(index) {
        const res = [];
        const taken = [];
        let filtered = this.pyBlocks.filter((o) => typeof o.index === "number");
        const search = (idx) => {
          let blocks = filtered.filter((o) => !taken.includes(o.index) && o.related.includes(idx));
          if (blocks.length > 0) {
            res.push(...blocks);
            blocks.forEach((b) => {
              search(b.index);
            });
          }
        };
        search(index);
        return res;
      }
      /**
       * Update single index block
       */
      async updatePyIndexBlock(nvim, block2, token) {
        let pre = block2.value;
        await block2.resolve(nvim, token);
        if (pre === block2.value || token?.isCancellationRequested) return;
        if (block2.parent instanceof Placeholder) {
          this.onPlaceholderUpdate(block2.parent);
        }
        await executePythonCode(nvim, [getVariablesCode(this.values)]);
      }
      get placeholderInfo() {
        const pyBlocks = [];
        const otherBlocks = [];
        let placeholders = [];
        this.walk((candidate) => {
          if (candidate instanceof Placeholder) {
            placeholders.push(candidate);
          } else if (candidate instanceof CodeBlock) {
            if (candidate.kind === "python") {
              pyBlocks.push(candidate);
            } else {
              otherBlocks.push(candidate);
            }
          }
          return true;
        }, true);
        return { placeholders, pyBlocks, otherBlocks };
      }
      get variables() {
        const variables = [];
        this.walk((candidate) => {
          if (candidate instanceof Variable) {
            variables.push(candidate);
          }
          return true;
        }, true);
        return variables;
      }
      get placeholders() {
        let placeholders = [];
        this.walk((candidate) => {
          if (candidate instanceof Placeholder) {
            placeholders.push(candidate);
          }
          return true;
        }, true);
        return placeholders;
      }
      get pyBlocks() {
        return this.placeholderInfo.pyBlocks;
      }
      get otherBlocks() {
        return this.placeholderInfo.otherBlocks;
      }
      get first() {
        let { placeholders } = this;
        let [normals, finals] = groupBy(placeholders.filter((p) => !p.transform), (v) => v.index !== 0);
        if (normals.length) {
          let minIndex = Math.min.apply(null, normals.map((o) => o.index));
          let arr = normals.filter((v) => v.index == minIndex);
          return arr.find((p) => p.primary) ?? arr[0];
        }
        return finals.find((o) => o.primary) ?? finals[0];
      }
      async update(nvim, marker, token) {
        this.onPlaceholderUpdate(marker);
        let codes = this.related.codes ?? [];
        if (codes.length === 0 || !this.hasPythonBlock) return;
        await this.updatePythonCodes(nvim, marker, codes, token);
      }
      /**
       * Reflact changes for related markers.
       */
      onPlaceholderUpdate(marker) {
        let val = marker.toString();
        let markers = this.placeholders.filter((o) => o.index == marker.index);
        for (let p of markers) {
          p.checkParentPlaceHolders();
          if (p === marker) continue;
          let newText = p.transform ? p.transform.resolve(val) : val;
          p.setOnlyChild(new Text(toText(newText)));
        }
        this.synchronizeParents(markers);
      }
      synchronizeParents(markers) {
        let parents = /* @__PURE__ */ new Set();
        markers.forEach((m) => {
          let p = m.parent;
          if (p instanceof Placeholder) parents.add(p);
        });
        for (let p of parents) {
          this.onPlaceholderUpdate(p);
        }
      }
      offset(marker) {
        let pos = 0;
        let found = false;
        this.walk((candidate) => {
          if (candidate === marker) {
            found = true;
            return false;
          }
          pos += candidate.len();
          return true;
        }, true);
        if (!found) {
          return -1;
        }
        return pos;
      }
      fullLen(marker) {
        let ret = 0;
        walk([marker], (marker2) => {
          ret += marker2.len();
          return true;
        });
        return ret;
      }
      getTextBefore(marker, parent) {
        let res = "";
        const calc = (m) => {
          let p = m.parent;
          if (!p) return;
          let s = "";
          for (let b of p.children) {
            if (b === m) break;
            s = s + b.toString();
          }
          res = s + res;
          if (p == parent) return;
          calc(p);
        };
        calc(marker);
        return res;
      }
      enclosingPlaceholders(placeholder) {
        let ret = [];
        let { parent } = placeholder;
        while (parent) {
          if (parent instanceof Placeholder) {
            ret.push(parent);
          }
          parent = parent.parent;
        }
        return ret;
      }
      async resolveVariables(resolver2) {
        let variables = this.variables;
        if (variables.length === 0) return;
        let failed = [];
        let succeed = [];
        let promises = [];
        const changedParents = /* @__PURE__ */ new Set();
        for (let item of variables) {
          promises.push(item.resolve(resolver2).then((res) => {
            changedParents.add(item.parent);
            let arr = res ? succeed : failed;
            arr.push(item);
          }, onUnexpectedError));
        }
        await Promise.allSettled(promises);
        for (const variable of succeed) {
          let text = new Text(variable.toString());
          variable.replaceWith(text);
        }
        if (failed.length > 0) {
          let indexMap = /* @__PURE__ */ new Map();
          const primarySet = /* @__PURE__ */ new Set();
          let max = this.getMaxPlaceholderIndex();
          for (let i = 0; i < failed.length; i++) {
            const v = failed[i];
            let idx = indexMap.get(v.name);
            if (idx == null) {
              idx = ++max;
              indexMap.set(v.name, idx);
            }
            let p = new Placeholder(idx);
            p.transform = v.transform;
            if (!p.transform && !primarySet.has(idx)) {
              primarySet.add(idx);
              p.primary = true;
            }
            let newText = p.transform ? p.transform.resolve(v.name) : v.name;
            p.setOnlyChild(new Text(toText(newText)));
            v.replaceWith(p);
          }
        }
        changedParents.forEach((marker) => {
          mergeTexts(marker);
          if (marker instanceof Placeholder) this.onPlaceholderUpdate(marker);
        });
      }
      getMaxPlaceholderIndex() {
        let res = 0;
        this.walk((candidate) => {
          if (candidate instanceof Placeholder) {
            res = Math.max(res, candidate.index);
          }
          return true;
        }, true);
        return res;
      }
      replace(marker, children) {
        marker.replaceChildren(children);
        if (marker instanceof Placeholder) {
          this.onPlaceholderUpdate(marker);
        }
      }
      toTextmateString() {
        return this.children.reduce((prev, cur) => prev + cur.toTextmateString(), "");
      }
      clone() {
        let ret = new _TextmateSnippet(this.ultisnip, this.id);
        ret.related.codes = this.related.codes;
        ret.related.context = this.related.context;
        ret._children = this.children.map((child) => {
          let m = child.clone();
          m.parent = ret;
          return m;
        });
        return ret;
      }
      walk(visitor, ignoreChild = false) {
        walk(this.children, visitor, ignoreChild);
      }
    };
    SnippetParser = class _SnippetParser {
      constructor(ultisnip) {
        this.ultisnip = ultisnip;
        this._scanner = new Scanner();
      }
      static escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      static isPlainText(value) {
        let s = new _SnippetParser().parse(value.replace(/\$0$/, ""), false);
        return s.children.length == 1 && s.children[0] instanceof Text;
      }
      text(value) {
        return this.parse(value, false).toString();
      }
      parse(value, insertFinalTabstop) {
        this._scanner.text(value);
        this._token = this._scanner.next();
        const snippet = new TextmateSnippet(this.ultisnip);
        while (this._parse(snippet)) {
        }
        const defaultValues = /* @__PURE__ */ new Map();
        const incompletePlaceholders = [];
        let complexPlaceholders = [];
        let hasFinal = false;
        snippet.walk((marker) => {
          if (marker instanceof Placeholder) {
            if (marker.index == 0) hasFinal = true;
            if (marker.children.some((o) => o instanceof Placeholder)) {
              marker.primary = true;
              complexPlaceholders.push(marker);
            } else if (!defaultValues.has(marker.index) && marker.children.length > 0) {
              marker.primary = true;
              defaultValues.set(marker.index, marker.toString());
            } else {
              incompletePlaceholders.push(marker);
            }
          }
          return true;
        });
        const complexIndexes = complexPlaceholders.map((p) => p.index);
        for (const placeholder of incompletePlaceholders) {
          if (defaultValues.has(placeholder.index)) {
            let val = defaultValues.get(placeholder.index);
            let text = new Text(placeholder.transform ? placeholder.transform.resolve(val) : val);
            placeholder.setOnlyChild(text);
          } else if (!complexIndexes.includes(placeholder.index)) {
            if (placeholder.transform) {
              let text = new Text(placeholder.transform.resolve(""));
              placeholder.setOnlyChild(text);
            } else {
              placeholder.primary = true;
              defaultValues.set(placeholder.index, "");
            }
          }
        }
        const resolveComplex = () => {
          let resolved = /* @__PURE__ */ new Set();
          for (let p of complexPlaceholders) {
            if (p.children.every((o) => !(o instanceof Placeholder) || defaultValues.has(o.index))) {
              let val = p.toString();
              defaultValues.set(p.index, val);
              for (let placeholder of incompletePlaceholders.filter((o) => o.index == p.index)) {
                let text = new Text(placeholder.transform ? placeholder.transform.resolve(val) : val);
                placeholder.setOnlyChild(text);
              }
              resolved.add(p.index);
            }
          }
          complexPlaceholders = complexPlaceholders.filter((p) => !resolved.has(p.index));
          if (complexPlaceholders.length == 0 || !resolved.size) return;
          resolveComplex();
        };
        resolveComplex();
        if (!hasFinal && insertFinalTabstop) {
          snippet.appendChild(new Placeholder(0));
        }
        return snippet;
      }
      _accept(type, value) {
        if (type === void 0 || this._token.type === type) {
          let ret = !value ? true : this._scanner.tokenText(this._token);
          this._token = this._scanner.next();
          return ret;
        }
        return false;
      }
      _backTo(token) {
        this._scanner.pos = token.pos + token.len;
        this._token = token;
        return false;
      }
      _until(type, checkBackSlash = false) {
        if (this._token.type === 14 /* EOF */) {
          return false;
        }
        let start = this._token;
        let pre;
        while (this._token.type !== type || checkBackSlash && pre && pre.type === 5 /* Backslash */) {
          if (checkBackSlash) pre = this._token;
          this._token = this._scanner.next();
          if (this._token.type === 14 /* EOF */) {
            return false;
          }
        }
        let value = this._scanner.value.substring(start.pos, this._token.pos);
        this._token = this._scanner.next();
        return value;
      }
      _parse(marker) {
        return this._parseEscaped(marker) || this._parseCodeBlock(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
      }
      // \$, \\, \} -> just text
      _parseEscaped(marker) {
        let value;
        if (value = this._accept(5 /* Backslash */, true)) {
          value = this._accept(0 /* Dollar */, true) || this._accept(4 /* CurlyClose */, true) || this._accept(5 /* Backslash */, true) || this.ultisnip && this._accept(3 /* CurlyOpen */, true) || this.ultisnip && this._accept(17 /* BackTick */, true) || value;
          marker.appendChild(new Text(value));
          return true;
        }
        return false;
      }
      // $foo -> variable, $1 -> tabstop
      _parseTabstopOrVariableName(parent) {
        let value;
        const token = this._token;
        const match = this._accept(0 /* Dollar */) && (value = this._accept(9 /* VariableName */, true) || this._accept(8 /* Int */, true));
        if (!match) {
          return this._backTo(token);
        }
        if (/^\d+$/.test(value)) {
          parent.appendChild(new Placeholder(Number(value)));
        } else {
          if (this.ultisnip && !ULTISNIP_VARIABLES.includes(value)) {
            parent.appendChild(new Text("$" + value));
          } else {
            parent.appendChild(new Variable(value));
          }
        }
        return true;
      }
      _checkCulybrace(marker) {
        let count = 0;
        for (marker of marker.children) {
          if (marker instanceof Text) {
            let text = marker.value;
            for (let index = 0; index < text.length; index++) {
              const ch = text[index];
              if (ch === "{") {
                count++;
              } else if (ch === "}") {
                count--;
              }
            }
          }
        }
        return count <= 0;
      }
      // ${1:<children>}, ${1} -> placeholder
      _parseComplexPlaceholder(parent) {
        let index;
        const token = this._token;
        const match = this._accept(0 /* Dollar */) && this._accept(3 /* CurlyOpen */) && (index = this._accept(8 /* Int */, true));
        if (!match) {
          return this._backTo(token);
        }
        const placeholder = new Placeholder(Number(index));
        if (this._accept(1 /* Colon */)) {
          while (true) {
            const lastChar = this._scanner.isEnd();
            if (this._accept(4 /* CurlyClose */)) {
              if (!this._checkCulybrace(placeholder) && !lastChar) {
                placeholder.appendChild(new Text("}"));
                continue;
              }
              parent.appendChild(placeholder);
              return true;
            }
            if (this._parse(placeholder)) {
              continue;
            }
            parent.appendChild(new Text("${" + index + ":"));
            placeholder.children.forEach(parent.appendChild, parent);
            return true;
          }
        } else if (placeholder.index > 0 && this._accept(7 /* Pipe */)) {
          const choice = new Choice();
          while (true) {
            if (this._parseChoiceElement(choice)) {
              if (this._accept(2 /* Comma */)) {
                continue;
              }
              if (this._accept(7 /* Pipe */)) {
                placeholder.appendChild(choice);
                if (this._accept(4 /* CurlyClose */)) {
                  parent.appendChild(placeholder);
                  return true;
                }
              }
            }
            this._backTo(token);
            return false;
          }
        } else if (this._accept(6 /* Forwardslash */)) {
          if (this._parseTransform(placeholder)) {
            parent.appendChild(placeholder);
            return true;
          }
          this._backTo(token);
          return false;
        } else if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(placeholder);
          return true;
        } else {
          return this._backTo(token);
        }
      }
      _parseChoiceElement(parent) {
        const token = this._token;
        const values = [];
        while (true) {
          if (this._token.type === 2 /* Comma */ || this._token.type === 7 /* Pipe */) {
            break;
          }
          let value;
          if (value = this._accept(5 /* Backslash */, true)) {
            value = this._accept(2 /* Comma */, true) || this._accept(7 /* Pipe */, true) || this._accept(5 /* Backslash */, true) || value;
          } else {
            value = this._accept(void 0, true);
          }
          if (!value) {
            this._backTo(token);
            return false;
          }
          values.push(value);
        }
        if (values.length === 0) {
          this._backTo(token);
          return false;
        }
        parent.appendChild(new Text(values.join("")));
        return true;
      }
      // ${foo:<children>}, ${foo} -> variable
      _parseComplexVariable(parent) {
        let name2;
        const token = this._token;
        const match = this._accept(0 /* Dollar */) && this._accept(3 /* CurlyOpen */) && (name2 = this._accept(9 /* VariableName */, true));
        if (!match) {
          return this._backTo(token);
        }
        if (this.ultisnip && !ULTISNIP_VARIABLES.includes(name2)) {
          return this._backTo(token);
        }
        const variable = new Variable(name2);
        if (this._accept(1 /* Colon */)) {
          while (true) {
            if (this._accept(4 /* CurlyClose */)) {
              parent.appendChild(variable);
              return true;
            }
            if (this._parse(variable)) {
              continue;
            }
            parent.appendChild(new Text("${" + name2 + ":"));
            variable.children.forEach(parent.appendChild, parent);
            return true;
          }
        } else if (this._accept(6 /* Forwardslash */)) {
          if (this._parseTransform(variable)) {
            parent.appendChild(variable);
            return true;
          }
          this._backTo(token);
          return false;
        } else if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(variable);
          return true;
        } else {
          return this._backTo(token);
        }
      }
      _parseTransform(parent) {
        let transform = new Transform();
        transform.ultisnip = this.ultisnip === true;
        let regexValue = "";
        let regexOptions = "";
        while (true) {
          if (this._accept(6 /* Forwardslash */)) {
            break;
          }
          let escaped;
          if (escaped = this._accept(5 /* Backslash */, true)) {
            escaped = this._accept(6 /* Forwardslash */, true) || escaped;
            regexValue += escaped;
            continue;
          }
          if (this._token.type !== 14 /* EOF */) {
            regexValue += this._accept(void 0, true);
            continue;
          }
          return false;
        }
        while (true) {
          if (this._accept(6 /* Forwardslash */)) {
            break;
          }
          let escaped;
          if (escaped = this._accept(5 /* Backslash */, true)) {
            escaped = this._accept(5 /* Backslash */, true) || this._accept(6 /* Forwardslash */, true) || escaped;
            transform.appendChild(new Text(escaped));
            continue;
          }
          if (this._parseFormatString(transform) || this._parseConditionString(transform) || this._parseAnything(transform)) {
            continue;
          }
          return false;
        }
        let ascii = false;
        while (true) {
          if (this._accept(4 /* CurlyClose */)) {
            break;
          }
          if (this._token.type !== 14 /* EOF */) {
            let c = this._accept(void 0, true);
            if (c == "a") {
              ascii = true;
            } else {
              if (!knownRegexOptions.includes(c)) {
                logger22.error(`Unknown regex option: ${c}`);
              }
              regexOptions += c;
            }
            continue;
          }
          return false;
        }
        try {
          if (ascii) transform.ascii = true;
          if (this.ultisnip) regexValue = convertRegex(regexValue);
          transform.regexp = new RegExp(regexValue, regexOptions);
        } catch (e) {
          return false;
        }
        parent.transform = transform;
        return true;
      }
      _parseConditionString(parent) {
        if (!this.ultisnip) return false;
        const token = this._token;
        if (!this._accept(15 /* OpenParen */)) {
          return false;
        }
        if (!this._accept(13 /* QuestionMark */)) {
          this._backTo(token);
          return false;
        }
        let index = this._accept(8 /* Int */, true);
        if (!index) {
          this._backTo(token);
          return false;
        }
        if (!this._accept(1 /* Colon */)) {
          this._backTo(token);
          return false;
        }
        let text = this._until(16 /* CloseParen */, true);
        if (text) {
          let i = 0;
          while (i < text.length) {
            let t = text[i];
            if (t == ":" && text[i - 1] != "\\") {
              break;
            }
            i++;
          }
          let ifValue = text.slice(0, i);
          let elseValue = text.slice(i + 1);
          parent.appendChild(new ConditionString(Number(index), ifValue, elseValue));
          return true;
        }
        this._backTo(token);
        return false;
      }
      _parseFormatString(parent) {
        const token = this._token;
        if (!this._accept(0 /* Dollar */)) {
          return false;
        }
        let complex = false;
        if (this._accept(3 /* CurlyOpen */)) {
          complex = true;
        }
        let index = this._accept(8 /* Int */, true);
        if (!index) {
          this._backTo(token);
          return false;
        } else if (!complex) {
          parent.appendChild(new FormatString(Number(index)));
          return true;
        } else if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(new FormatString(Number(index)));
          return true;
        } else if (!this._accept(1 /* Colon */)) {
          this._backTo(token);
          return false;
        }
        if (this.ultisnip) {
          this._backTo(token);
          return false;
        }
        if (this._accept(6 /* Forwardslash */)) {
          let shorthand = this._accept(9 /* VariableName */, true);
          if (!shorthand || !this._accept(4 /* CurlyClose */)) {
            this._backTo(token);
            return false;
          } else {
            parent.appendChild(new FormatString(Number(index), shorthand));
            return true;
          }
        } else if (this._accept(11 /* Plus */)) {
          let ifValue = this._until(4 /* CurlyClose */);
          if (ifValue) {
            parent.appendChild(new FormatString(Number(index), void 0, ifValue, void 0));
            return true;
          }
        } else if (this._accept(12 /* Dash */)) {
          let elseValue = this._until(4 /* CurlyClose */);
          if (elseValue) {
            parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
            return true;
          }
        } else if (this._accept(13 /* QuestionMark */)) {
          let ifValue = this._until(1 /* Colon */);
          if (ifValue) {
            let elseValue = this._until(4 /* CurlyClose */);
            if (elseValue) {
              parent.appendChild(new FormatString(Number(index), void 0, ifValue, elseValue));
              return true;
            }
          }
        } else {
          let elseValue = this._until(4 /* CurlyClose */);
          if (elseValue) {
            parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
            return true;
          }
        }
        this._backTo(token);
        return false;
      }
      _parseCodeBlock(parent) {
        if (!this.ultisnip) return false;
        const token = this._token;
        if (!this._accept(17 /* BackTick */)) {
          return false;
        }
        let text = this._until(17 /* BackTick */, true);
        if (text) {
          if (!text.startsWith("!")) {
            let marker = new CodeBlock(text.trim(), "shell");
            parent.appendChild(marker);
            return true;
          }
          if (text.startsWith("!v")) {
            let marker = new CodeBlock(text.slice(2).trim(), "vim");
            parent.appendChild(marker);
            return true;
          }
          if (text.startsWith("!p")) {
            let code = text.slice(2);
            if (code.indexOf("\n") == -1) {
              let marker = new CodeBlock(code.trim(), "python");
              parent.appendChild(marker);
            } else {
              let codes = code.split(/\r?\n/);
              codes = codes.filter((s) => !/^\s*$/.test(s));
              if (!codes.length) return true;
              let ind = codes[0].match(/^\s*/)[0];
              if (ind.length && codes.every((s) => s.startsWith(ind))) {
                codes = codes.map((s) => s.slice(ind.length));
              }
              if (ind == " " && codes[0].startsWith(ind)) codes[0] = codes[0].slice(1);
              let marker = new CodeBlock(codes.join("\n"), "python");
              parent.appendChild(marker);
            }
            return true;
          }
        }
        this._backTo(token);
        return false;
      }
      _parseAnything(marker) {
        if (this._token.type !== 14 /* EOF */) {
          let text = this._scanner.tokenText(this._token);
          marker.appendChild(new Text(text));
          this._accept(void 0);
          return true;
        }
        return false;
      }
    };
    escapedCharacters = [":", "(", ")", "{", "}"];
  }
});

// src/util/map.ts
var Touch, _a, LinkedMap, LRUCache;
var init_map = __esm({
  "src/util/map.ts"() {
    "use strict";
    ((Touch2) => {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (Touch = {}));
    LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      before(key) {
        const item = this._map.get(key);
        return item ? item.previous?.value : void 0;
      }
      after(key) {
        const item = this._map.get(key);
        return item ? item.next?.value : void 0;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
  }
});

// src/completion/util.ts
function useAscii(input) {
  return input.length > 0 && input.charCodeAt(0) < ASCII_END;
}
function getKindText(kind, kindMap, defaultKindText) {
  return number(kind) ? kindMap.get(kind) ?? defaultKindText : kind;
}
function getKindHighlight(kind) {
  return number(kind) ? highlightsMap[kind] ?? DEFAULT_HL_GROUP : DEFAULT_HL_GROUP;
}
function getPriority(source, defaultValue2) {
  if (number(source.priority)) {
    return source.priority;
  }
  return defaultValue2;
}
function getDetail(item, filetype) {
  const { detail, labelDetails, label } = item;
  if (!isEmpty(labelDetails)) {
    let content = (labelDetails.detail ?? "") + (labelDetails.description ? ` ${labelDetails.description}` : "");
    return { filetype: "txt", content };
  }
  if (detail && detail !== label) {
    let isText = /^[\w-\s.,\t\n]+$/.test(detail);
    return { filetype: isText ? "txt" : filetype, content: detail };
  }
  return void 0;
}
function deltaCount(info) {
  if (!info.insertChar || !info.insertChars) return 0;
  if (info.insertChars.length != 2) return 0;
  let pre = info.pre;
  let last = pre[pre.length - 1];
  if (last !== info.insertChars[0] || !pariedCharacters.has(last)) return 0;
  let next = info.line[pre.length];
  if (!next || pariedCharacters.get(last) != next) return 0;
  return 1;
}
function toCompleteDoneItem(selected, item) {
  if (!item || !selected) return {};
  return Object.assign({
    word: selected.word,
    abbr: selected.abbr,
    kind: selected.kind,
    menu: selected.menu,
    source: selected.source.name,
    isSnippet: selected.isSnippet,
    user_data: `${selected.source.name}:0`
  }, item);
}
function getDocumentaions(completeItem, filetype, detailRendered = false) {
  let docs = [];
  if (isCompletionItem(completeItem)) {
    let { documentation } = completeItem;
    if (!detailRendered) {
      let doc = getDetail(completeItem, filetype);
      if (doc) docs.push(doc);
    }
    if (documentation) {
      if (typeof documentation == "string") {
        docs.push({ filetype: "txt", content: documentation });
      } else if (documentation.value) {
        docs.push({
          filetype: documentation.kind == "markdown" ? "markdown" : "txt",
          content: documentation.value
        });
      }
    }
  } else {
    if (completeItem.documentation) {
      docs = completeItem.documentation;
    } else if (completeItem.info) {
      docs.push({ content: completeItem.info, filetype: "txt" });
    }
  }
  return docs;
}
function getResumeInput(option, pretext) {
  if (!option) return null;
  const { line, col } = option;
  const start = characterIndex(line, col);
  const pl = pretext.length;
  if (pl < start) return null;
  for (let i = 0; i < start; i++) {
    if (pretext.charCodeAt(i) !== line.charCodeAt(i)) {
      return null;
    }
  }
  return byteSlice(pretext, option.col);
}
function checkIgnoreRegexps(ignoreRegexps, input) {
  if (!ignoreRegexps || ignoreRegexps.length == 0 || input.length == 0) return false;
  return ignoreRegexps.some((regexp) => {
    try {
      return new RegExp(regexp).test(input);
    } catch (e) {
      return false;
    }
  });
}
function createKindMap(labels) {
  return /* @__PURE__ */ new Map([
    [CompletionItemKind.Text, labels["text"] ?? "v"],
    [CompletionItemKind.Method, labels["method"] ?? "f"],
    [CompletionItemKind.Function, labels["function"] ?? "f"],
    [CompletionItemKind.Constructor, typeof labels["constructor"] == "function" ? "f" : labels["constructor"] ?? ""],
    [CompletionItemKind.Field, labels["field"] ?? "m"],
    [CompletionItemKind.Variable, labels["variable"] ?? "v"],
    [CompletionItemKind.Class, labels["class"] ?? "C"],
    [CompletionItemKind.Interface, labels["interface"] ?? "I"],
    [CompletionItemKind.Module, labels["module"] ?? "M"],
    [CompletionItemKind.Property, labels["property"] ?? "m"],
    [CompletionItemKind.Unit, labels["unit"] ?? "U"],
    [CompletionItemKind.Value, labels["value"] ?? "v"],
    [CompletionItemKind.Enum, labels["enum"] ?? "E"],
    [CompletionItemKind.Keyword, labels["keyword"] ?? "k"],
    [CompletionItemKind.Snippet, labels["snippet"] ?? "S"],
    [CompletionItemKind.Color, labels["color"] ?? "v"],
    [CompletionItemKind.File, labels["file"] ?? "F"],
    [CompletionItemKind.Reference, labels["reference"] ?? "r"],
    [CompletionItemKind.Folder, labels["folder"] ?? "F"],
    [CompletionItemKind.EnumMember, labels["enumMember"] ?? "m"],
    [CompletionItemKind.Constant, labels["constant"] ?? "v"],
    [CompletionItemKind.Struct, labels["struct"] ?? "S"],
    [CompletionItemKind.Event, labels["event"] ?? "E"],
    [CompletionItemKind.Operator, labels["operator"] ?? "O"],
    [CompletionItemKind.TypeParameter, labels["typeParameter"] ?? "T"]
  ]);
}
function shouldStop(bufnr, info, option) {
  let { pre } = info;
  if (pre.length === 0 || getUnicodeClass(pre[pre.length - 1]) === "space") return true;
  if (option.bufnr != bufnr || option.linenr != info.lnum) return true;
  let text = byteSlice(option.line, 0, option.col);
  if (!pre.startsWith(text)) return true;
  return false;
}
function getInput(chars, pre, asciiCharactersOnly) {
  let len = 0;
  let prev;
  for (let i = pre.length - 1; i >= 0; i--) {
    let code = pre.charCodeAt(i);
    let word = isWordCode(chars, code, asciiCharactersOnly);
    if (!word || prev !== void 0 && !sameScope(prev, code)) {
      break;
    }
    len += 1;
    prev = code;
  }
  return len == 0 ? "" : pre.slice(-len);
}
function isWordCode(chars, code, asciiCharactersOnly) {
  if (!chars.isKeywordCode(code)) return false;
  if (isLowSurrogate(code)) return false;
  if (asciiCharactersOnly && code >= 255) return false;
  return true;
}
function highlightOffset(pre, item) {
  let { filterText, abbr } = item;
  let idx = abbr.indexOf(filterText);
  if (idx == -1) return -1;
  let n = idx == 0 ? 0 : byteIndex(abbr, idx);
  return pre + n;
}
function emptLabelDetails(labelDetails) {
  if (!labelDetails) return true;
  return !labelDetails.detail && !labelDetails.description;
}
function isSnippetItem(item, itemDefaults) {
  let insertTextFormat = item.insertTextFormat ?? itemDefaults.insertTextFormat;
  return insertTextFormat === InsertTextFormat.Snippet;
}
function hasAction(item, itemDefaults) {
  return isSnippetItem(item, itemDefaults) || !isFalsyOrEmpty(item.additionalTextEdits);
}
function toValidWord(snippet, excludes) {
  for (let i = 0; i < snippet.length; i++) {
    let code = snippet.charCodeAt(i);
    if (excludes.includes(code)) {
      return snippet.slice(0, i);
    }
  }
  return snippet;
}
function snippetToWord(text, kind) {
  if (kind === CompletionItemKind.Function || kind === CompletionItemKind.Method || kind === CompletionItemKind.Class) {
    text = text.replace(/\(.+/, "");
  }
  if (!text.includes(DollarSign)) return text;
  return toValidWord(new SnippetParser().text(text), INVALID_WORD_CHARS);
}
function getWord(item, itemDefaults) {
  let { label, data, kind } = item;
  if (data && string(data.word)) return data.word;
  let textToInsert = item.textEdit ? item.textEdit.newText : item.insertText;
  if (!string(textToInsert)) return label;
  return isSnippetItem(item, itemDefaults) ? snippetToWord(textToInsert, kind) : toValidWord(textToInsert, INVALID_WORD_CHARS);
}
function getReplaceRange(item, defaultRange, character, insertMode) {
  let editRange;
  if (item.textEdit) {
    editRange = InsertReplaceEdit.is(item.textEdit) ? item.textEdit : item.textEdit.range;
  } else if (defaultRange) {
    editRange = defaultRange;
  }
  let range;
  if (editRange) {
    if (Range.is(editRange)) {
      range = editRange;
    } else {
      range = insertMode == "insert" /* Insert */ ? editRange.insert : editRange.replace;
    }
  }
  if (range && number(character) && range.start.character > character) range.start.character = character;
  return range;
}
function toItemKey(item) {
  let label = item.filterText;
  let source = item.source.name;
  let kind = item.kind ?? "";
  return `${label}|${source}|${kind}`;
}
var INVALID_WORD_CHARS, DollarSign, QuestionMark, MAX_CODE_POINT, MAX_MRU_ITEMS, DEFAULT_HL_GROUP, highlightsMap, Converter, MruLoader;
var init_util4 = __esm({
  "src/completion/util.ts"() {
    "use strict";
    init_main();
    init_chars();
    init_parser3();
    init_util();
    init_array();
    init_charCode();
    init_constants();
    init_is();
    init_map();
    init_node();
    init_object();
    init_string();
    init_types2();
    INVALID_WORD_CHARS = [10 /* LineFeed */, 13 /* CarriageReturn */];
    DollarSign = "$";
    QuestionMark = "?";
    MAX_CODE_POINT = 1114111;
    MAX_MRU_ITEMS = 100;
    DEFAULT_HL_GROUP = "CocSymbolDefault";
    highlightsMap = {
      [CompletionItemKind.Text]: "CocSymbolText",
      [CompletionItemKind.Method]: "CocSymbolMethod",
      [CompletionItemKind.Function]: "CocSymbolFunction",
      [CompletionItemKind.Constructor]: "CocSymbolConstructor",
      [CompletionItemKind.Field]: "CocSymbolField",
      [CompletionItemKind.Variable]: "CocSymbolVariable",
      [CompletionItemKind.Class]: "CocSymbolClass",
      [CompletionItemKind.Interface]: "CocSymbolInterface",
      [CompletionItemKind.Module]: "CocSymbolModule",
      [CompletionItemKind.Property]: "CocSymbolProperty",
      [CompletionItemKind.Unit]: "CocSymbolUnit",
      [CompletionItemKind.Value]: "CocSymbolValue",
      [CompletionItemKind.Enum]: "CocSymbolEnum",
      [CompletionItemKind.Keyword]: "CocSymbolKeyword",
      [CompletionItemKind.Snippet]: "CocSymbolSnippet",
      [CompletionItemKind.Color]: "CocSymbolColor",
      [CompletionItemKind.File]: "CocSymbolFile",
      [CompletionItemKind.Reference]: "CocSymbolReference",
      [CompletionItemKind.Folder]: "CocSymbolFolder",
      [CompletionItemKind.EnumMember]: "CocSymbolEnumMember",
      [CompletionItemKind.Constant]: "CocSymbolConstant",
      [CompletionItemKind.Struct]: "CocSymbolStruct",
      [CompletionItemKind.Event]: "CocSymbolEvent",
      [CompletionItemKind.Operator]: "CocSymbolOperator",
      [CompletionItemKind.TypeParameter]: "CocSymbolTypeParameter"
    };
    Converter = class {
      constructor(inputStart, option, opt) {
        this.inputStart = inputStart;
        this.option = option;
        this.opt = opt;
        // cache the sliced text
        this.previousCache = /* @__PURE__ */ new Map();
        this.postCache = /* @__PURE__ */ new Map();
        this.minCharacter = Number.MAX_SAFE_INTEGER;
        this.character = opt.position.character;
        this.inputLen = opt.position.character - inputStart;
      }
      /**
       * Text before input to replace
       */
      getPrevious(character) {
        if (this.previousCache.has(character)) return this.previousCache.get(character);
        let prev = this.opt.line.slice(character, this.inputStart);
        this.previousCache.set(character, prev);
        return prev;
      }
      /**
       * Text after cursor to replace
       */
      getAfter(character) {
        if (this.postCache.has(character)) return this.postCache.get(character);
        let text = this.opt.line.slice(this.character, character);
        this.postCache.set(character, text);
        return text;
      }
      /**
       * Exclude follow characters to replace from end of word
       */
      fixFollow(word, isSnippet, endCharacter) {
        if (isSnippet || endCharacter <= this.character) return word;
        let toReplace = this.getAfter(endCharacter);
        if (word.length - this.inputLen > toReplace.length && word.endsWith(toReplace)) {
          return word.slice(0, -toReplace.length);
        }
        return word;
      }
      /**
       * Better filter text with prefix before input removed if exists.
       */
      getDelta(filterText, character) {
        if (character < this.inputStart) {
          let prev = this.getPrevious(character);
          if (filterText.startsWith(prev)) return prev.length;
        }
        return 0;
      }
      convertToDurationItem(item) {
        if (isCompletionItem(item)) {
          return this.convertLspCompleteItem(item);
        } else if (string(item.word)) {
          return this.convertVimCompleteItem(item);
        }
        return void 0;
      }
      convertVimCompleteItem(item) {
        const { option } = this;
        const { range, asciiMatch } = option;
        const word = toText(item.word);
        const character = range.start.character;
        this.minCharacter = Math.min(this.minCharacter, character);
        let filterText = item.filterText ?? word;
        filterText = asciiMatch ? unidecode(filterText) : filterText;
        const delta = this.getDelta(filterText, character);
        return {
          word: this.fixFollow(word, item.isSnippet, range.end.character),
          abbr: item.abbr ?? word,
          filterText,
          delta,
          character,
          dup: item.dup === 1,
          menu: item.menu,
          kind: item.kind,
          isSnippet: !!item.isSnippet,
          insertText: item.insertText,
          preselect: item.preselect,
          sortText: item.sortText,
          deprecated: item.deprecated,
          detail: item.detail,
          labelDetails: item.labelDetails,
          get source() {
            return option.source;
          },
          get priority() {
            return option.source.priority ?? 99;
          },
          get shortcut() {
            return toText(option.source.shortcut);
          }
        };
      }
      convertLspCompleteItem(item) {
        const { option, inputStart } = this;
        const label = item.label.trim();
        const itemDefaults = toObject(option.itemDefaults);
        const word = getWord(item, itemDefaults);
        const range = getReplaceRange(item, itemDefaults?.editRange, inputStart, this.option.insertMode) ?? option.range;
        const character = range.start.character;
        const data = toObject(item.data);
        const filterText = item.filterText ?? item.label;
        const delta = this.getDelta(filterText, character);
        let obj = {
          // the word to be insert from it's own character.
          word: this.fixFollow(word, isSnippetItem(item, itemDefaults), range.end.character),
          abbr: label,
          character,
          delta,
          kind: item.kind,
          detail: item.detail,
          sortText: item.sortText,
          filterText,
          preselect: item.preselect === true,
          deprecated: item.deprecated === true || item.tags?.includes(CompletionItemTag.Deprecated),
          isSnippet: hasAction(item, itemDefaults),
          get source() {
            return option.source;
          },
          get priority() {
            return option.priority;
          },
          get shortcut() {
            return toText(option.source.shortcut);
          },
          dup: data.dup !== 0
        };
        this.minCharacter = Math.min(this.minCharacter, character);
        if (data.optional && !obj.abbr.endsWith(QuestionMark)) obj.abbr += QuestionMark;
        if (!emptLabelDetails(item.labelDetails)) obj.labelDetails = item.labelDetails;
        if (number(item["score"]) && !obj.sortText) obj.sortText = String.fromCodePoint(MAX_CODE_POINT - Math.round(item["score"]));
        return obj;
      }
    };
    MruLoader = class {
      constructor() {
        this.max = 0;
        this.items = new LRUCache(MAX_MRU_ITEMS);
        this.itemsNoPrefix = new LRUCache(MAX_MRU_ITEMS);
      }
      getScore(input, item, selection) {
        let key = toItemKey(item);
        if (input.length == 0) return this.itemsNoPrefix.get(key) ?? -1;
        if (selection === "recentlyUsedByPrefix" /* RecentlyUsedByPrefix */) key = `${input}|${key}`;
        let map = selection === "recentlyUsed" /* RecentlyUsed */ ? this.itemsNoPrefix : this.items;
        return map.get(key) ?? -1;
      }
      add(prefix, item) {
        if (!number(item.kind)) return;
        let key = toItemKey(item);
        if (!item.filterText.startsWith(prefix)) {
          prefix = "";
        }
        let line = `${prefix}|${key}`;
        this.items.set(line, this.max);
        this.itemsNoPrefix.set(key, this.max);
        this.max += 1;
      }
      clear() {
        this.max = 0;
        this.items.clear();
        this.itemsNoPrefix.clear();
      }
    };
  }
});

// src/diagnostic/util.ts
function formatDiagnostic(format3, diagnostic) {
  let { source, code, severity, message } = diagnostic;
  let s = getSeverityName(severity)[0];
  const codeStr = code ? " " + code : "";
  return format3.replace("%source", source).replace("%code", codeStr).replace("%severity", s).replace("%message", message);
}
function getSeverityName(severity) {
  switch (severity) {
    case DiagnosticSeverity.Warning:
      return "Warning";
    case DiagnosticSeverity.Information:
      return "Information";
    case DiagnosticSeverity.Hint:
      return "Hint";
    default:
      return "Error";
  }
}
function getSeverityType(severity) {
  switch (severity) {
    case DiagnosticSeverity.Warning:
      return "W";
    case DiagnosticSeverity.Information:
      return "I";
    case DiagnosticSeverity.Hint:
      return "I";
    default:
      return "E";
  }
}
function severityLevel(level2) {
  if (level2 == null) return void 0;
  switch (level2) {
    case "hint":
      return DiagnosticSeverity.Hint;
    case "information":
      return DiagnosticSeverity.Information;
    case "warning":
      return DiagnosticSeverity.Warning;
    case "error":
      return DiagnosticSeverity.Error;
    default:
      return DiagnosticSeverity.Hint;
  }
}
function getNameFromSeverity(severity) {
  switch (severity) {
    case DiagnosticSeverity.Error:
      return "CocError";
    case DiagnosticSeverity.Warning:
      return "CocWarning";
    case DiagnosticSeverity.Information:
      return "CocInfo";
    case DiagnosticSeverity.Hint:
      return "CocHint";
    default:
      return "CocError";
  }
}
function getLocationListItem(bufnr, diagnostic, lines) {
  let { start, end } = diagnostic.range;
  let owner = diagnostic.source || "coc.nvim";
  let msg = diagnostic.message.split("\n")[0];
  let type = getSeverityName(diagnostic.severity).slice(0, 1).toUpperCase();
  return {
    bufnr,
    lnum: start.line + 1,
    end_lnum: end.line + 1,
    col: Array.isArray(lines) ? byteIndex(lines[start.line] ?? "", start.character) + 1 : start.character + 1,
    end_col: Array.isArray(lines) ? byteIndex(lines[end.line] ?? "", end.character) + 1 : end.character + 1,
    text: `[${owner}${diagnostic.code ? " " + diagnostic.code : ""}] ${msg} [${type}]`,
    type
  };
}
function sortDiagnostics(a, b) {
  let sa = a.severity ?? 1;
  let sb = b.severity ?? 1;
  if (sa != sb) return sa - sb;
  let d = comparePosition(a.range.start, b.range.start);
  if (d != 0) return d;
  return a.source > b.source ? 1 : -1;
}
function getHighlightGroup(diagnostic) {
  let hlGroups2 = [];
  let tags = diagnostic.tags || [];
  if (tags.includes(DiagnosticTag.Deprecated)) {
    hlGroups2.push("CocDeprecatedHighlight" /* Deprecated */);
  }
  if (tags.includes(DiagnosticTag.Unnecessary)) {
    hlGroups2.push("CocUnusedHighlight" /* Unused */);
  }
  switch (diagnostic.severity) {
    case DiagnosticSeverity.Hint:
      hlGroups2.push("CocHintHighlight" /* Hint */);
      break;
    case DiagnosticSeverity.Information:
      hlGroups2.push("CocInfoHighlight" /* Information */);
      break;
    case DiagnosticSeverity.Warning:
      hlGroups2.push("CocWarningHighlight" /* Warning */);
      break;
    case DiagnosticSeverity.Error:
      hlGroups2.push("CocErrorHighlight" /* Error */);
      break;
  }
  return hlGroups2;
}
function adjustDiagnostics(diagnostics, edit2) {
  let res = [];
  let { range } = edit2;
  for (let diag of diagnostics) {
    let r = diag.range;
    if (rangeOverlap(range, r)) continue;
    if (comparePosition(r.start, range.end) > 0) {
      let s = getPosition(r.start, edit2);
      let e = getPosition(r.end, edit2);
      if (s.line >= 0 && s.character >= 0 && e.line >= 0 && e.character >= 0) {
        diag.range = Range.create(s, e);
      }
    }
    res.push(diag);
  }
  return res;
}
var init_util5 = __esm({
  "src/diagnostic/util.ts"() {
    "use strict";
    init_main();
    init_position();
    init_string();
    init_textedit();
  }
});

// src/diagnostic/buffer.ts
var signGroup, NAMESPACE, hlGroups, delay, aleMethod, virtualTextSrcId, floatFactory, DiagnosticBuffer;
var init_buffer = __esm({
  "src/diagnostic/buffer.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_events();
    init_util();
    init_ansiparse();
    init_array();
    init_errors();
    init_node();
    init_position();
    init_protocol();
    init_window();
    init_workspace();
    init_util5();
    signGroup = "CocDiagnostic";
    NAMESPACE = "diagnostic";
    hlGroups = ["CocErrorHighlight", "CocWarningHighlight", "CocInfoHighlight", "CocHintHighlight", "CocDeprecatedHighlight", "CocUnusedHighlight"];
    delay = getConditionValue(50, 10);
    aleMethod = getConditionValue("ale#other_source#ShowResults", "MockAleResults");
    DiagnosticBuffer = class {
      constructor(nvim, doc) {
        this.nvim = nvim;
        this.doc = doc;
        this.diagnosticsMap = /* @__PURE__ */ new Map();
        this._disposed = false;
        this._dirties = /* @__PURE__ */ new Set();
        this._refreshing = false;
        this._onDidRefresh = new import_node4.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this.loadConfiguration();
        let timer;
        let fn = () => {
          clearTimeout(timer);
          this._refreshing = true;
          timer = setTimeout(() => {
            this._refreshing = false;
            if (!this._autoRefresh) return;
            void this._refresh(true);
          }, delay);
        };
        fn.clear = () => {
          this._refreshing = false;
          clearTimeout(timer);
        };
        this.refreshHighlights = fn;
      }
      get _autoRefresh() {
        return this.config.enable && this.config.autoRefresh && this.dirty && !this.doc.hasChanged;
      }
      get config() {
        return this._config;
      }
      loadConfiguration() {
        let config = workspace_default.getConfiguration("diagnostic", this.doc);
        let changed = this._config && config.enable != this._config.enable;
        this._config = {
          enable: config.get("enable", true),
          floatConfig: config.get("floatConfig", {}),
          messageTarget: config.get("messageTarget", "float"),
          enableHighlightLineNumber: config.get("enableHighlightLineNumber", true),
          highlightLimit: config.get("highlightLimit", 1e3),
          highlightPriority: config.get("highlightPriority"),
          autoRefresh: config.get("autoRefresh", true),
          checkCurrentLine: config.get("checkCurrentLine", false),
          enableSign: workspace_default.env.sign && config.get("enableSign", true),
          locationlistUpdate: config.get("locationlistUpdate", true),
          enableMessage: config.get("enableMessage", "always"),
          virtualText: config.get("virtualText", false),
          virtualTextAlign: config.get("virtualTextAlign", "after"),
          virtualTextWinCol: config.get("virtualTextWinCol", null),
          virtualTextCurrentLineOnly: config.get("virtualTextCurrentLineOnly"),
          virtualTextPrefix: config.get("virtualTextPrefix", " "),
          virtualTextFormat: config.get("virtualTextFormat", "%message"),
          virtualTextLimitInOneLine: config.get("virtualTextLimitInOneLine", 999),
          virtualTextLineSeparator: config.get("virtualTextLineSeparator", " \\ "),
          virtualTextLines: config.get("virtualTextLines", 3),
          displayByAle: config.get("displayByAle", false),
          displayByVimDiagnostic: config.get("displayByVimDiagnostic", false),
          level: severityLevel(config.get("level", "hint")),
          locationlistLevel: severityLevel(config.get("locationlistLevel")),
          signLevel: severityLevel(config.get("signLevel")),
          virtualTextLevel: severityLevel(config.get("virtualTextLevel")),
          messageLevel: severityLevel(config.get("messageLevel")),
          signPriority: config.get("signPriority", 10),
          refreshOnInsertMode: config.get("refreshOnInsertMode", false),
          filetypeMap: config.get("filetypeMap", {}),
          showUnused: config.get("showUnused", true),
          showDeprecated: config.get("showDeprecated", true),
          format: config.get("format", "[%source%code] [%severity] %message"),
          showRelatedInformation: config.get("showRelatedInformation", true)
        };
        if (this._config.virtualText && !virtualTextSrcId) {
          void this.nvim.createNamespace("coc-diagnostic-virtualText").then((id2) => {
            virtualTextSrcId = id2;
          });
        }
        if (changed) {
          if (this.config.enable) {
            void this._refresh(false);
          } else {
            this.clear();
          }
        }
      }
      async setState(enable) {
        let curr = this._config.enable;
        if (curr == enable) return;
        this._config.enable = enable;
        if (enable) {
          await this._refresh(false);
        } else {
          this.clear();
        }
      }
      get dirty() {
        return this._dirties.size > 0;
      }
      get bufnr() {
        return this.doc.bufnr;
      }
      get uri() {
        return this.doc.uri;
      }
      onChange(e) {
        let changes = e.contentChanges;
        if (changes.length > 0) {
          let edit2 = TextEdit.replace(changes[0].range, changes[0].text);
          for (let [collection, diagnostics] of this.diagnosticsMap.entries()) {
            let arr = adjustDiagnostics(diagnostics, edit2);
            this.diagnosticsMap.set(collection, arr);
          }
          this._dirties = new Set(this.diagnosticsMap.keys());
        }
        if (!this.config.autoRefresh) return;
        this.refreshHighlights();
      }
      onTextChange() {
        this._dirties = new Set(this.diagnosticsMap.keys());
        this.refreshHighlights.clear();
      }
      get displayByAle() {
        return this._config.displayByAle;
      }
      get displayByVimDiagnostic() {
        return this.nvim.isVim === false && this._config.displayByVimDiagnostic;
      }
      clearHighlight(collection) {
        this.buffer.clearNamespace(NAMESPACE + collection);
      }
      clearSigns(collection) {
        this.buffer.unplaceSign({ group: signGroup + collection });
      }
      get diagnostics() {
        let res = [];
        for (let diags of this.diagnosticsMap.values()) {
          res.push(...diags);
        }
        return res;
      }
      get buffer() {
        return this.nvim.createBuffer(this.bufnr);
      }
      refreshAle(collection, diagnostics) {
        let aleItems = diagnostics.map((o) => {
          let range = o.range;
          return {
            text: o.message,
            code: o.code,
            lnum: range.start.line + 1,
            col: range.start.character + 1,
            end_lnum: range.end.line + 1,
            end_col: range.end.character,
            type: getSeverityType(o.severity)
          };
        });
        this.nvim.call(aleMethod, [this.bufnr, "coc" + collection, aleItems], true);
      }
      /**
       * Update diagnostics when diagnostics change on collection.
       * @param {string} collection
       * @param {Diagnostic[]} diagnostics
       */
      async update(collection, diagnostics) {
        let { diagnosticsMap } = this;
        let curr = diagnosticsMap.get(collection);
        if (!this._dirties.has(collection) && isFalsyOrEmpty(diagnostics) && isFalsyOrEmpty(curr)) return;
        diagnosticsMap.set(collection, diagnostics);
        void this.checkFloat();
        if (!this.config.enable || diagnostics.length > 0 && this._refreshing) {
          this._dirties.add(collection);
          return;
        }
        let info = await this.getDiagnosticInfo(diagnostics.length === 0);
        if (!info || info.winid == -1) {
          this._dirties.add(collection);
          return;
        }
        let map = /* @__PURE__ */ new Map();
        map.set(collection, diagnostics);
        this.refresh(map, info);
      }
      async checkFloat() {
        if (workspace_default.bufnr != this.bufnr || !floatFactory) return;
        let pos = await window_default.getCursorPosition();
        let diagnostics = this.getDiagnosticsAtPosition(pos);
        if (diagnostics.length == 0) {
          floatFactory.close();
        }
      }
      /**
       * Reset all diagnostics of current buffer
       */
      async reset(diagnostics) {
        this.refreshHighlights.clear();
        let { diagnosticsMap } = this;
        for (let key of diagnosticsMap.keys()) {
          if (isFalsyOrEmpty(diagnostics[key])) diagnostics[key] = [];
        }
        for (let [key, value] of Object.entries(diagnostics)) {
          diagnosticsMap.set(key, value);
        }
        this._dirties = new Set(diagnosticsMap.keys());
        await this._refresh(false);
      }
      async onCursorHold(lnum, col) {
        if (this.config.enableMessage !== "always") return;
        let pos = this.doc.getPosition(lnum, col);
        await this.echoMessage(true, pos);
      }
      /**
       * Echo diagnostic message under cursor.
       */
      async echoMessage(truncate = false, position, target) {
        const config = this.config;
        if (!config.enable || config.enableMessage === "never" || this.displayByAle || this.displayByVimDiagnostic) return false;
        if (!target) target = config.messageTarget;
        let useFloat = target == "float";
        let diagnostics = this.getDiagnosticsAtPosition(position);
        if (config.messageLevel) {
          diagnostics = diagnostics.filter((diagnostic) => {
            return diagnostic.severity && diagnostic.severity <= config.messageLevel;
          });
        }
        if (useFloat) {
          await this.showFloat(diagnostics);
        } else {
          const lines = [];
          diagnostics.forEach((diagnostic) => {
            lines.push(formatDiagnostic(config.format, diagnostic));
          });
          if (lines.length) {
            await this.nvim.command('echo ""');
            await window_default.echoLines(lines, truncate);
          }
        }
        return true;
      }
      async showVirtualTextCurrentLine(lnum) {
        let { config } = this;
        if (!config.virtualTextCurrentLineOnly || events_default.insertMode && !config.refreshOnInsertMode) return false;
        let enabled = await this.isEnabled();
        if (!enabled) return false;
        this.showVirtualText(lnum);
        return true;
      }
      async showFloat(diagnostics, target = "float") {
        if (target !== "float") return false;
        if (!floatFactory) floatFactory = window_default.createFloatFactory({ modes: ["n"], autoHide: true });
        if (diagnostics.length == 0) {
          floatFactory.close();
          return false;
        }
        if (events_default.insertMode) return false;
        let config = this.config;
        let ft = "";
        let docs = [];
        if (Object.keys(config.filetypeMap).length > 0) {
          let filetype = this.doc.filetype;
          const defaultFiletype = config.filetypeMap["default"] || "";
          ft = config.filetypeMap[filetype] || (defaultFiletype == "bufferType" ? filetype : defaultFiletype);
        }
        diagnostics.forEach((diagnostic) => {
          let filetype = "Error";
          if (diagnostic.filetype) {
            filetype = diagnostic.filetype;
          } else if (ft === "") {
            switch (diagnostic.severity) {
              case DiagnosticSeverity.Hint:
                filetype = "Hint";
                break;
              case DiagnosticSeverity.Warning:
                filetype = "Warning";
                break;
              case DiagnosticSeverity.Information:
                filetype = "Info";
                break;
            }
          } else {
            filetype = ft;
          }
          let msg = diagnostic.message;
          let link = diagnostic.codeDescription?.href ?? "";
          if (config.showRelatedInformation && diagnostic.relatedInformation?.length) {
            msg = `${diagnostic.message}

Related information:
`;
            for (const info of diagnostic.relatedInformation) {
              const fsPath2 = URI2.parse(info.location.uri).fsPath;
              const basename = path.basename(fsPath2);
              const line = info.location.range.start.line + 1;
              const column = info.location.range.start.character + 1;
              msg = `${msg}
  * ${basename}#${line},${column}: ${info.message}`;
            }
            msg = msg + "\n\n";
          }
          docs.push({
            filetype,
            content: formatDiagnostic(config.format, {
              ...diagnostic,
              message: msg
            })
          });
          if (link) docs.push({ filetype: "txt", content: link });
        });
        await floatFactory.show(docs, this.config.floatConfig);
        return true;
      }
      /**
       * Get buffer info needed for refresh.
       */
      async getDiagnosticInfo(force) {
        let { refreshOnInsertMode } = this._config;
        let { nvim, bufnr } = this;
        let checkInsert = !refreshOnInsertMode;
        if (force) {
          checkInsert = false;
        } else {
          let disabledByInsert = events_default.insertMode && !refreshOnInsertMode;
          if (disabledByInsert) return void 0;
        }
        return await nvim.call("coc#util#diagnostic_info", [bufnr, checkInsert]).catch(onUnexpectedError);
      }
      /**
       * Refresh changed diagnostics to UI.
       */
      refresh(diagnosticsMap, info) {
        let { nvim, displayByAle, displayByVimDiagnostic } = this;
        for (let collection of diagnosticsMap.keys()) {
          this._dirties.delete(collection);
        }
        if (displayByAle) {
          nvim.pauseNotification();
          for (let [collection, diagnostics] of diagnosticsMap.entries()) {
            this.refreshAle(collection, diagnostics);
          }
          nvim.resumeNotification(true, true);
        } else if (displayByVimDiagnostic) {
          nvim.pauseNotification();
          this.setDiagnosticInfo(true);
          nvim.resumeNotification(true, true);
        } else {
          let emptyCollections = [];
          nvim.pauseNotification();
          for (let [collection, diagnostics] of diagnosticsMap.entries()) {
            if (diagnostics.length == 0) emptyCollections.push(collection);
            this.addSigns(collection, diagnostics);
            this.updateHighlights(collection, diagnostics);
          }
          this.showVirtualText(info.lnum);
          this.updateLocationList(info.winid, info.locationlist);
          this.setDiagnosticInfo();
          nvim.resumeNotification(true, true);
          emptyCollections.forEach((name2) => {
            this.diagnosticsMap.delete(name2);
          });
        }
        this._onDidRefresh.fire(this.diagnostics);
      }
      updateLocationList(winid, title) {
        if (!this._config.locationlistUpdate || winid == -1 || title !== "Diagnostics of coc") return;
        let items = this.toLocationListItems(this.diagnostics);
        this.nvim.call("coc#ui#setloclist", [winid, items, "r", "Diagnostics of coc"], true);
      }
      toLocationListItems(diagnostics) {
        let { locationlistLevel } = this._config;
        let items = [];
        let lines = this.doc.textDocument.lines;
        diagnostics.sort(sortDiagnostics);
        for (let diagnostic of diagnostics) {
          if (locationlistLevel && diagnostic.severity && diagnostic.severity > locationlistLevel) continue;
          items.push(getLocationListItem(this.bufnr, diagnostic, lines));
        }
        return items;
      }
      addSigns(collection, diagnostics) {
        let { enableSign, signLevel } = this._config;
        if (!enableSign) return;
        let group = signGroup + collection;
        let signs = [];
        let signsMap = /* @__PURE__ */ new Map();
        for (let diagnostic of diagnostics) {
          let { range, severity } = diagnostic;
          if (!severity || signLevel && severity > signLevel) {
            continue;
          }
          let line = range.start.line;
          let exists = signsMap.get(line) || [];
          if (exists.includes(severity)) {
            continue;
          }
          exists.push(severity);
          signsMap.set(line, exists);
          let priority = this._config.signPriority + 4 - severity;
          signs.push({ name: getNameFromSeverity(severity), lnum: line + 1, priority });
        }
        this.nvim.call("coc#ui#update_signs", [this.bufnr, group, signs], true);
      }
      setDiagnosticInfo(full = false) {
        let lnums = [0, 0, 0, 0];
        let info = { error: 0, warning: 0, information: 0, hint: 0, lnums };
        let items = [];
        for (let diagnostics of this.diagnosticsMap.values()) {
          for (let diagnostic of diagnostics) {
            let lnum = diagnostic.range.start.line + 1;
            switch (diagnostic.severity) {
              case DiagnosticSeverity.Warning:
                info.warning = info.warning + 1;
                lnums[1] = lnums[1] ? Math.min(lnums[1], lnum) : lnum;
                break;
              case DiagnosticSeverity.Information:
                info.information = info.information + 1;
                lnums[2] = lnums[2] ? Math.min(lnums[2], lnum) : lnum;
                break;
              case DiagnosticSeverity.Hint:
                info.hint = info.hint + 1;
                lnums[3] = lnums[3] ? Math.min(lnums[3], lnum) : lnum;
                break;
              default:
                lnums[0] = lnums[0] ? Math.min(lnums[0], lnum) : lnum;
                info.error = info.error + 1;
            }
            if (full) {
              let { start, end } = diagnostic.range;
              items.push({
                file: URI2.parse(this.doc.uri).fsPath,
                lnum: start.line + 1,
                end_lnum: end.line + 1,
                col: start.character + 1,
                end_col: end.character + 1,
                code: diagnostic.code,
                source: diagnostic.source,
                message: diagnostic.message,
                severity: getSeverityName(diagnostic.severity),
                level: diagnostic.severity ?? 0,
                location: Location.create(this.doc.uri, diagnostic.range)
              });
            }
          }
        }
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.setVar("coc_diagnostic_info", info, true);
        buf.setVar("coc_diagnostic_map", items, true);
        this.nvim.call("coc#util#do_autocmd", ["CocDiagnosticChange"], true);
      }
      showVirtualText(lnum) {
        let { _config: config } = this;
        let { virtualText, virtualTextLevel } = config;
        if (!virtualText || lnum < 0) return;
        let { virtualTextPrefix, virtualTextLimitInOneLine, virtualTextCurrentLineOnly } = this._config;
        let { diagnostics, buffer } = this;
        if (virtualTextCurrentLineOnly) {
          diagnostics = diagnostics.filter((d) => {
            let { start, end } = d.range;
            return start.line <= lnum - 1 && end.line >= lnum - 1;
          });
        }
        diagnostics.sort(sortDiagnostics);
        buffer.clearNamespace(virtualTextSrcId);
        let map = /* @__PURE__ */ new Map();
        let opts = {
          text_align: config.virtualTextAlign,
          virt_text_win_col: config.virtualTextWinCol
        };
        for (let i = diagnostics.length - 1; i >= 0; i--) {
          let diagnostic = diagnostics[i];
          if (virtualTextLevel && diagnostic.severity && diagnostic.severity > virtualTextLevel) {
            continue;
          }
          let { line } = diagnostic.range.start;
          let highlight = getNameFromSeverity(diagnostic.severity) + "VirtualText";
          let msg = diagnostic.message.split(/\n/).map((l) => l.trim()).filter((l) => l.length > 0).slice(0, this._config.virtualTextLines).join(this._config.virtualTextLineSeparator);
          let arr = map.get(line) ?? [];
          const formattedDiagnostic = formatDiagnostic(this._config.virtualTextFormat, {
            ...diagnostic,
            message: msg
          });
          arr.unshift([virtualTextPrefix + stripAnsiColoring(formattedDiagnostic), highlight]);
          map.set(line, arr);
        }
        for (let [line, blocks] of map.entries()) {
          buffer.setVirtualText(virtualTextSrcId, line, blocks.slice(0, virtualTextLimitInOneLine), opts);
        }
      }
      updateHighlights(collection, diagnostics) {
        if (!diagnostics.length) {
          this.clearHighlight(collection);
        } else {
          let items = this.getHighlightItems(diagnostics);
          let priority = this._config.highlightPriority;
          this.buffer.updateHighlights(NAMESPACE + collection, items, { priority });
        }
      }
      /**
       * Refresh all diagnostics
       */
      async _refresh(dirtyOnly) {
        let info = await this.getDiagnosticInfo(!dirtyOnly);
        if (!info || info.winid == -1 || !this.config.enable) return;
        let { _dirties } = this;
        if (dirtyOnly) {
          let map = /* @__PURE__ */ new Map();
          for (let [key, diagnostics] of this.diagnosticsMap.entries()) {
            if (!_dirties.has(key)) continue;
            map.set(key, diagnostics);
          }
          this.refresh(map, info);
        } else {
          this.refresh(this.diagnosticsMap, info);
        }
      }
      getHighlightItems(diagnostics) {
        let res = [];
        for (let i = 0; i < Math.min(this._config.highlightLimit, diagnostics.length); i++) {
          let diagnostic = diagnostics[i];
          let hlGroups2 = getHighlightGroup(diagnostic);
          for (const hlGroup of hlGroups2) {
            this.doc.addHighlights(res, hlGroup, diagnostic.range);
          }
        }
        res.sort((a, b) => {
          if (a.lnum != b.lnum) return a.lnum - b.lnum;
          if (a.colStart != b.colStart) return a.colStart - b.colStart;
          return hlGroups.indexOf(b.hlGroup) - hlGroups.indexOf(a.hlGroup);
        });
        return res;
      }
      /**
       * Clear all diagnostics from UI.
       */
      clear() {
        let { nvim } = this;
        let collections = Array.from(this.diagnosticsMap.keys());
        this.refreshHighlights.clear();
        this._dirties.clear();
        if (this.displayByAle) {
          for (let collection of collections) {
            this.nvim.call(aleMethod, [this.bufnr, collection, []], true);
          }
        } else {
          nvim.pauseNotification();
          this.buffer.deleteVar("coc_diagnostic_info");
          this.buffer.deleteVar("coc_diagnostic_map");
          for (let collection of collections) {
            this.clearHighlight(collection);
            this.clearSigns(collection);
          }
          if (this._config.virtualText) {
            this.buffer.clearNamespace(virtualTextSrcId);
          }
          nvim.resumeNotification(true, true);
        }
      }
      /**
       * Get diagnostics at cursor position.
       */
      getDiagnosticsAt(pos, checkCurrentLine) {
        let diagnostics = [];
        for (let diags of this.diagnosticsMap.values()) {
          if (checkCurrentLine) {
            diagnostics.push(...diags.filter((o) => lineInRange(pos.line, o.range)));
          } else {
            diagnostics.push(...diags.filter((o) => positionInRange(pos, o.range) == 0));
          }
        }
        diagnostics.sort(sortDiagnostics);
        return diagnostics;
      }
      getDiagnosticsAtPosition(pos) {
        let { config, doc } = this;
        let res = this.getDiagnosticsAt(pos, config.checkCurrentLine);
        if (config.checkCurrentLine || res.length) return res;
        let total = doc.getline(pos.line).length;
        if (pos.character + 1 == total) {
          res = this.getDiagnosticsAt(Position.create(pos.line, pos.character + 1), false);
          if (res.length) return res;
        }
        if (pos.line === doc.lineCount - 1 && pos.character == 0) {
          pos = Position.create(pos.line + 1, 0);
          res = this.getDiagnosticsAt(pos, true);
        }
        return res;
      }
      async isEnabled() {
        if (this._disposed || !this.config.enable) return false;
        let buf = this.nvim.createBuffer(this.bufnr);
        let res = await buf.getVar("coc_diagnostic_disable");
        return res != 1;
      }
      dispose() {
        this.clear();
        this.diagnosticsMap.clear();
        this._onDidRefresh.dispose();
        this._disposed = true;
      }
    };
  }
});

// src/diagnostic/collection.ts
var HintTags, DiagnosticCollection;
var init_collection = __esm({
  "src/diagnostic/collection.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_array();
    init_protocol();
    init_workspace();
    HintTags = [DiagnosticTag.Deprecated, DiagnosticTag.Unnecessary];
    DiagnosticCollection = class {
      constructor(name2, onDispose) {
        this.name = name2;
        this.onDispose = onDispose;
        this.diagnosticsMap = /* @__PURE__ */ new Map();
        this._onDidDiagnosticsChange = new import_node4.Emitter();
        this.onDidDiagnosticsChange = this._onDidDiagnosticsChange.event;
      }
      set(entries, diagnostics) {
        let diagnosticsPerFile = /* @__PURE__ */ new Map();
        if (!Array.isArray(entries)) {
          let doc = workspace_default.getDocument(entries);
          let uri = doc ? doc.uri : entries;
          diagnosticsPerFile.set(uri, diagnostics || []);
        } else {
          for (let item of entries) {
            let [uri, diagnostics2] = item;
            let doc = workspace_default.getDocument(uri);
            uri = doc ? doc.uri : uri;
            if (diagnostics2 == null) {
              diagnostics2 = [];
            } else {
              diagnostics2 = (diagnosticsPerFile.get(uri) || []).concat(diagnostics2);
            }
            diagnosticsPerFile.set(uri, diagnostics2);
          }
        }
        for (let item of diagnosticsPerFile) {
          let [uri, diagnostics2] = item;
          uri = URI2.parse(uri).toString();
          diagnostics2.forEach((o) => {
            o.range = o.range ?? Range.create(0, 0, 0, 0);
            o.message = o.message ?? "";
            o.source = o.source || this.name;
            if (!o.severity && Array.isArray(o.tags) && intersect(o.tags, HintTags)) {
              o.severity = DiagnosticSeverity.Hint;
            }
          });
          this.diagnosticsMap.set(uri, diagnostics2);
          this._onDidDiagnosticsChange.fire(uri);
        }
      }
      delete(uri) {
        this.diagnosticsMap.delete(uri);
        this._onDidDiagnosticsChange.fire(uri);
      }
      clear() {
        let uris = Array.from(this.diagnosticsMap.keys());
        uris = uris.filter((uri) => this.diagnosticsMap.get(uri).length > 0);
        this.diagnosticsMap.clear();
        for (let uri of uris) {
          this._onDidDiagnosticsChange.fire(uri);
        }
      }
      forEach(callback, thisArg) {
        for (let uri of this.diagnosticsMap.keys()) {
          let diagnostics = this.diagnosticsMap.get(uri);
          callback.call(thisArg, uri, diagnostics, this);
        }
      }
      entries() {
        return this.diagnosticsMap.entries();
      }
      get(uri) {
        let arr = this.diagnosticsMap.get(uri);
        return arr == null ? [] : arr.slice();
      }
      has(uri) {
        return this.diagnosticsMap.has(uri);
      }
      dispose() {
        this.clear();
        if (this.onDispose) this.onDispose();
        this._onDidDiagnosticsChange.dispose();
      }
    };
  }
});

// src/diagnostic/manager.ts
var DiagnosticManager, manager_default;
var init_manager = __esm({
  "src/diagnostic/manager.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_commands();
    init_events();
    init_util();
    init_array();
    init_constants();
    init_fs();
    init_position();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    init_buffer();
    init_collection();
    init_util5();
    DiagnosticManager = class {
      constructor() {
        this._onDidRefresh = new import_node4.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this.enabled = true;
        this.collections = [];
        this.disposables = [];
      }
      init() {
        commands_default.register({
          id: "workspace.diagnosticRelated",
          execute: () => this.jumpRelated()
        }, false, "jump to related locations of current diagnostic.");
        this.defineSigns(workspace_default.initialConfiguration.get("diagnostic"));
        let globalValue = workspace_default.initialConfiguration.inspect("diagnostic.enable").globalValue;
        this.enabled = globalValue !== false;
        this.buffers = workspace_default.registerBufferSync((doc) => {
          let buf = new DiagnosticBuffer(this.nvim, doc);
          buf.onDidRefresh((diagnostics2) => {
            this._onDidRefresh.fire({ diagnostics: diagnostics2, uri: buf.uri, bufnr: buf.bufnr });
          });
          let diagnostics = this.getDiagnostics(buf);
          if (Object.keys(diagnostics).length > 0 && buf.config.autoRefresh) {
            void buf.reset(diagnostics);
          }
          return buf;
        });
        workspace_default.onDidChangeConfiguration((e) => {
          if (this.buffers && e.affectsConfiguration("diagnostic")) {
            for (let item of this.buffers.items) {
              item.loadConfiguration();
            }
          }
        }, null, this.disposables);
        let config = workspace_default.initialConfiguration.get("diagnostic");
        events_default.on("CursorMoved", (bufnr, cursor) => {
          if (this.messageTimer) clearTimeout(this.messageTimer);
          this.messageTimer = setTimeout(() => {
            let buf = this.buffers.getItem(bufnr);
            if (buf == null || buf.dirty) return;
            void Promise.allSettled([
              buf.onCursorHold(cursor[0], cursor[1]),
              buf.showVirtualTextCurrentLine(cursor[0])
            ]);
          }, config.messageDelay);
        }, null, this.disposables);
        events_default.on(["InsertEnter", "BufEnter"], () => {
          clearTimeout(this.messageTimer);
        }, null, this.disposables);
        events_default.on("InsertLeave", (bufnr) => {
          let buf = this.buffers.getItem(bufnr);
          if (!buf || buf.config.refreshOnInsertMode) return;
          for (let buf2 of this.buffers.items) {
            buf2.refreshHighlights();
          }
        }, null, this.disposables);
        events_default.on("BufWinEnter", (bufnr) => {
          let buf = this.buffers.getItem(bufnr);
          if (buf) buf.refreshHighlights();
        }, null, this.disposables);
        this.checkConfigurationErrors();
        workspace_default.configurations.onError((ev) => {
          const collection = this.create("config");
          collection.set(ev.uri, ev.diagnostics);
        }, null, this.disposables);
      }
      checkConfigurationErrors() {
        const errors = workspace_default.configurations.errors;
        if (!isFalsyOrEmpty(errors)) {
          const collection = this.create("config");
          for (let [uri, diagnostics] of errors.entries()) {
            let fsPath2 = URI2.parse(uri).fsPath;
            void window_default.showErrorMessage(`Error detected for config file ${fsPath2}, please check diagnostics list.`);
            collection.set(uri, diagnostics);
          }
        }
      }
      defineSigns(config) {
        let { nvim } = this;
        nvim.pauseNotification();
        for (let kind of ["Error", "Warning", "Info", "Hint"]) {
          let cmd = `sign define Coc${kind} linehl=Coc${kind}Line`;
          let signText = config[kind.toLowerCase() + "Sign"];
          if (signText) cmd += ` texthl=Coc${kind}Sign text=${signText}`;
          if (!isVim && config.enableHighlightLineNumber) cmd += ` numhl=Coc${kind}Sign`;
          nvim.command(cmd, true);
        }
        nvim.resumeNotification(false, true);
      }
      getItem(bufnr) {
        return this.buffers.getItem(bufnr);
      }
      /**
       * Fill location list with diagnostics
       */
      async setLocationlist(bufnr) {
        let doc = workspace_default.getAttachedDocument(bufnr);
        let buf = this.getItem(doc.bufnr);
        let diagnostics = [];
        for (let diags of Object.values(this.getDiagnostics(buf))) {
          diagnostics.push(...diags);
        }
        let items = buf.toLocationListItems(diagnostics);
        await this.nvim.call("coc#ui#setloclist", [0, items, " ", "Diagnostics of coc"]);
      }
      /**
       * Create collection by name
       */
      create(name2) {
        let collection = this.getCollectionByName(name2);
        if (collection) return collection;
        collection = new DiagnosticCollection(name2, () => {
          let idx = this.collections.findIndex((o) => o == collection);
          if (idx !== -1) this.collections.splice(idx, 1);
        });
        this.collections.push(collection);
        collection.onDidDiagnosticsChange((uri) => {
          let buf = this.buffers?.getItem(uri);
          if (buf && buf.config.autoRefresh) void buf.update(name2, this.getDiagnosticsByCollection(buf, collection));
        });
        return collection;
      }
      /**
       * Get diagnostics ranges from document
       */
      getSortedRanges(uri, minLevel, severity) {
        let collections = this.getCollections(uri);
        let res = [];
        let level2 = severity ? severityLevel(severity) : 0;
        for (let collection of collections) {
          let diagnostics = collection.get(uri);
          if (level2) {
            diagnostics = diagnostics.filter((o) => o.severity == level2);
          } else {
            if (minLevel && minLevel < DiagnosticSeverity.Hint) {
              diagnostics = diagnostics.filter((o) => {
                return o.severity && o.severity > minLevel ? false : true;
              });
            }
          }
          let ranges = diagnostics.map((o) => o.range);
          res.push(...ranges);
        }
        res.sort((a, b) => {
          if (a.start.line != b.start.line) {
            return a.start.line - b.start.line;
          }
          return a.start.character - b.start.character;
        });
        return res;
      }
      /**
       * Get readonly diagnostics for a buffer
       */
      getDiagnostics(buf) {
        let res = {};
        for (let collection of this.collections) {
          if (!collection.has(buf.uri)) continue;
          res[collection.name] = this.getDiagnosticsByCollection(buf, collection);
        }
        return res;
      }
      /**
       * Get filtered diagnostics by collection.
       */
      getDiagnosticsByCollection(buf, collection) {
        let { level: level2, showUnused, showDeprecated } = buf.config;
        let items = collection.get(buf.uri) ?? [];
        if (items.length) {
          items = items.filter((d) => {
            if (level2 && d.severity && d.severity > level2) {
              return false;
            }
            if (!showUnused && d.tags?.includes(DiagnosticTag.Unnecessary)) {
              return false;
            }
            if (!showDeprecated && d.tags?.includes(DiagnosticTag.Deprecated)) {
              return false;
            }
            return true;
          });
          items.sort((a, b) => {
            return comparePosition(a.range.start, b.range.start);
          });
        }
        return items;
      }
      getDiagnosticsInRange(document2, range) {
        let res = [];
        for (let collection of this.collections) {
          for (let item of collection.get(document2.uri) ?? []) {
            if (rangeIntersect(item.range, range)) {
              res.push(item);
            }
          }
        }
        return res;
      }
      /**
       * Show diagnostics under cursor in preview window
       */
      async preview() {
        let diagnostics = await this.getCurrentDiagnostics();
        if (diagnostics.length == 0) {
          this.nvim.command("pclose", true);
          return;
        }
        let lines = [];
        for (let diagnostic of diagnostics) {
          let { source, code, severity, message } = diagnostic;
          let s = getSeverityName(severity)[0];
          lines.push(`[${source}${code ? " " + code : ""}] [${s}]`);
          lines.push(...message.split(/\r?\n/));
          lines.push("");
        }
        this.nvim.call("coc#ui#preview_info", [lines, "txt"], true);
      }
      async prepareJump(severity) {
        let bufnr = await this.nvim.call("bufnr", ["%"]);
        let item = this.buffers.getItem(bufnr);
        if (!item) return;
        let ranges = this.getSortedRanges(item.uri, item.config.level, severity);
        if (isFalsyOrEmpty(ranges)) return;
        let curpos = await window_default.getCursorPosition();
        let wrapscan = await this.nvim.getOption("wrapscan");
        return {
          item,
          curpos,
          wrapscan: wrapscan != 0,
          ranges
        };
      }
      /**
       * Jump to previous diagnostic position
       */
      async jumpPrevious(severity) {
        let result = await this.prepareJump(severity);
        if (!result) return;
        let { curpos, item, wrapscan, ranges } = result;
        let pos;
        for (let i = ranges.length - 1; i >= 0; i--) {
          let end = ranges[i].end;
          if (comparePosition(end, curpos) < 0) {
            pos = ranges[i].start;
            break;
          }
        }
        if (!pos && wrapscan) pos = ranges[ranges.length - 1].start;
        if (pos) {
          await window_default.moveTo(pos);
          await item.echoMessage(false, pos);
        } else {
          void window_default.showWarningMessage(`No more diagnostic before cursor position`);
        }
      }
      /**
       * Jump to next diagnostic position
       */
      async jumpNext(severity) {
        let result = await this.prepareJump(severity);
        if (!result) return;
        let { curpos, item, wrapscan, ranges } = result;
        let pos;
        for (let i = 0; i <= ranges.length - 1; i++) {
          let start = ranges[i].start;
          if (comparePosition(start, curpos) > 0) {
            let arr = await this.nvim.call("coc#util#valid_position", [start.line, start.character]);
            if ((arr[0] != start.line || arr[1] != start.character) && comparePosition(Position.create(arr[0], arr[1]), curpos) <= 0) {
              continue;
            }
            pos = Position.create(arr[0], arr[1]);
            break;
          }
        }
        if (!pos && wrapscan) pos = ranges[0].start;
        if (pos) {
          await window_default.moveTo(pos);
          await item.echoMessage(false, pos);
        } else {
          void window_default.showWarningMessage(`No more diagnostic after cursor position`);
        }
      }
      /**
       * Get all sorted diagnostics
       */
      async getDiagnosticList() {
        let res = [];
        let config = workspace_default.getConfiguration("diagnostic");
        let level2 = severityLevel(config.get("level", "hint"));
        for (let collection of this.collections) {
          for (let [uri, diagnostics] of collection.entries()) {
            if (diagnostics.length == 0) continue;
            let u = URI2.parse(uri);
            let doc = workspace_default.getDocument(uri);
            let lines = doc && doc.attached ? doc.textDocument.lines : void 0;
            if (!lines && u.scheme === "file") {
              try {
                const max = diagnostics.reduce((p, c) => {
                  return Math.max(c.range.end.line, p);
                }, 0);
                lines = await readFileLines(u.fsPath, 0, max);
              } catch (e) {
              }
            }
            for (let diagnostic of diagnostics) {
              if (diagnostic.severity && diagnostic.severity > level2) continue;
              let { start, end } = diagnostic.range;
              let o = {
                file: u.fsPath,
                bufnr: doc ? doc.bufnr : void 0,
                lnum: start.line + 1,
                end_lnum: end.line + 1,
                col: Array.isArray(lines) ? byteIndex(lines[start.line] ?? "", start.character) + 1 : start.character + 1,
                end_col: Array.isArray(lines) ? byteIndex(lines[end.line] ?? "", end.character) + 1 : end.character + 1,
                code: diagnostic.code,
                source: diagnostic.source ?? collection.name,
                message: diagnostic.message,
                severity: getSeverityName(diagnostic.severity),
                level: diagnostic.severity ?? 0,
                location: Location.create(uri, diagnostic.range)
              };
              res.push(o);
            }
          }
        }
        res.sort((a, b) => {
          if (a.level !== b.level) {
            return a.level - b.level;
          }
          if (a.file !== b.file) {
            return a.file > b.file ? 1 : -1;
          } else {
            if (a.lnum != b.lnum) {
              return a.lnum - b.lnum;
            }
            return a.col - b.col;
          }
        });
        return res;
      }
      async getBufferAndPosition() {
        let [bufnr, lnum, col] = await this.nvim.eval(`[bufnr("%"),line('.'),col('.')]`);
        let item = this.buffers.getItem(bufnr);
        if (!item) return;
        let pos = item.doc.getPosition(lnum, col);
        return [item, pos];
      }
      async getCurrentDiagnostics() {
        let res = await this.getBufferAndPosition();
        if (!res) return;
        return res[0].getDiagnosticsAtPosition(res[1]);
      }
      async echoCurrentMessage(target) {
        let res = await this.getBufferAndPosition();
        if (!res) return;
        let [item, position] = res;
        await item.echoMessage(false, position, target);
      }
      async jumpRelated() {
        let locations = await this.relatedInformation();
        if (locations.length == 1) {
          await workspace_default.jumpTo(locations[0].uri, locations[0].range.start);
        } else if (locations.length > 1) {
          await workspace_default.showLocations(locations);
        } else {
          void window_default.showWarningMessage("No related information found.");
        }
      }
      async relatedInformation() {
        let diagnostics = await this.getCurrentDiagnostics();
        let diagnostic = diagnostics.find((o) => o.relatedInformation != null);
        let locations = diagnostic ? diagnostic.relatedInformation.map((o) => o.location) : [];
        return locations;
      }
      reset() {
        clearTimeout(this.messageTimer);
        this.buffers.reset();
        for (let collection of this.collections) {
          collection.dispose();
        }
        this.collections = [];
      }
      dispose() {
        clearTimeout(this.messageTimer);
        this.buffers.dispose();
        for (let collection of this.collections) {
          collection.dispose();
        }
        this.collections = [];
        disposeAll(this.disposables);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      getCollectionByName(name2) {
        return this.collections.find((o) => o.name == name2);
      }
      getCollections(uri) {
        return this.collections.filter((c) => c.has(uri));
      }
      async toggleDiagnostic(enable) {
        this.enabled = enable == void 0 ? !this.enabled : enable != 0;
        await Promise.allSettled(this.buffers.items.map((buf) => {
          return buf.setState(this.enabled);
        }));
      }
      async toggleDiagnosticBuffer(bufnr, enable) {
        bufnr = bufnr ?? workspace_default.bufnr;
        let buf = this.buffers.getItem(bufnr);
        if (buf) {
          let isEnabled = enable == void 0 ? await buf.isEnabled() : enable == 0;
          await this.nvim.call("setbufvar", [bufnr, "coc_diagnostic_disable", isEnabled ? 1 : 0]);
          await buf.setState(!isEnabled);
        }
      }
      /**
       * Refresh diagnostics by uri or bufnr
       */
      async refreshBuffer(uri) {
        let buf = this.buffers.getItem(uri);
        if (!buf) return false;
        await buf.reset(this.getDiagnostics(buf));
        return true;
      }
      /**
       * Force diagnostics refresh.
       */
      async refresh(bufnr) {
        let items;
        if (!bufnr) {
          items = this.buffers.items;
        } else {
          let item = this.buffers.getItem(bufnr);
          items = item ? [item] : [];
        }
        for (let item of items) {
          await this.refreshBuffer(item.uri);
        }
      }
    };
    manager_default = new DiagnosticManager();
  }
});

// src/provider/manager.ts
function addLocation(arr, location) {
  if (Location.is(location)) {
    let { range, uri } = location;
    if (arr.find((o) => o.uri == uri && equals(o.range, range)) != null) return;
    arr.push(location);
  } else if (location && typeof location.targetUri === "string") {
    let { targetUri, targetSelectionRange, targetRange } = location;
    if (arr.find((o) => o.uri == targetUri && equals(o.range, targetSelectionRange)) != null) return;
    arr.push({
      uri: targetUri,
      range: targetSelectionRange,
      targetRange
    });
  }
}
var logger23, Manager;
var init_manager2 = __esm({
  "src/provider/manager.ts"() {
    "use strict";
    init_main();
    init_logger();
    init_errors();
    init_extensionRegistry();
    init_object();
    init_protocol();
    init_string();
    init_workspace();
    logger23 = createLogger("provider-manager");
    Manager = class {
      constructor() {
        this.providers = /* @__PURE__ */ new Set();
      }
      hasProvider(document2) {
        return this.getProvider(document2) != null;
      }
      addProvider(item) {
        if (!item.provider.hasOwnProperty("__extensionName")) {
          Error.captureStackTrace(item);
          let name2;
          Object.defineProperty(item.provider, "__extensionName", {
            get: () => {
              if (name2) return name2;
              name2 = parseExtensionName(toText(item["stack"]));
              return name2;
            },
            enumerable: true
          });
        }
        this.providers.add(item);
        return import_node4.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      handleResults(results, name2, token) {
        let serverCancelError;
        results.forEach((res) => {
          if (res.status === "rejected") {
            if (!shouldIgnore(res.reason)) logger23.error(`Provider error on ${name2}:`, res.reason);
            if (token && !token.isCancellationRequested && isCancellationError(res.reason)) {
              serverCancelError = res.reason;
            }
          }
        });
        if (serverCancelError) throw serverCancelError;
      }
      getProvider(document2) {
        let currScore = 0;
        let providerItem;
        for (let item of this.providers) {
          let { selector, priority } = item;
          let score3 = workspace_default.match(selector, document2);
          if (score3 == 0) continue;
          if (typeof priority == "number" && priority > 0) {
            score3 = score3 + priority;
          }
          if (score3 < currScore) continue;
          currScore = score3;
          providerItem = item;
        }
        return providerItem;
      }
      getProvideByExtension(document2, extension) {
        for (let item of this.providers) {
          if (item.provider["__extensionName"] === extension) {
            return item;
          }
        }
        logger23.warn(`User-specified formatter not found for ${document2.languageId}:`, extension);
        return void 0;
      }
      getFormatProvider(document2) {
        const userChoice = workspace_default.getConfiguration("coc.preferences", document2).get("formatterExtension");
        if (userChoice) {
          let provider = this.getProvideByExtension(document2, userChoice);
          if (provider) return provider;
        }
        return this.getProvider(document2);
      }
      getProviderById(id2) {
        let item = Array.from(this.providers).find((o) => o.id == id2);
        return item ? item.provider : null;
      }
      getProviders(document2) {
        let items = Array.from(this.providers);
        items = items.filter((item) => workspace_default.match(item.selector, document2) > 0);
        return items.sort((a, b) => workspace_default.match(b.selector, document2) - workspace_default.match(a.selector, document2));
      }
      addLocation(locations, location) {
        if (Array.isArray(location)) {
          for (let loc of location) {
            if (Location.is(loc)) {
              addLocation(locations, loc);
            } else if (loc && typeof loc.targetUri === "string") {
              addLocation(locations, loc);
            }
          }
        } else if (Location.is(location)) {
          addLocation(locations, location);
        }
      }
    };
  }
});

// src/provider/callHierarchyManager.ts
var CallHierarchyManager;
var init_callHierarchyManager = __esm({
  "src/provider/callHierarchyManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    CallHierarchyManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async prepareCallHierarchy(document2, position, token) {
        let item = this.getProvider(document2);
        if (!item) return null;
        let { provider } = item;
        return await Promise.resolve(provider.prepareCallHierarchy(document2, position, token));
      }
      async provideCallHierarchyOutgoingCalls(document2, item, token) {
        let providerItem = this.getProvider(document2);
        if (!providerItem) return null;
        let { provider } = providerItem;
        return await Promise.resolve(provider.provideCallHierarchyOutgoingCalls(item, token));
      }
      async provideCallHierarchyIncomingCalls(document2, item, token) {
        let providerItem = this.getProvider(document2);
        if (!providerItem) return null;
        let { provider } = providerItem;
        return await Promise.resolve(provider.provideCallHierarchyIncomingCalls(item, token));
      }
    };
  }
});

// src/provider/codeActionManager.ts
function codeActionContains(kinds, kind) {
  return kinds.some((k) => kind === k || kind.startsWith(k + "."));
}
function checkAction(only, action) {
  if (isFalsyOrEmpty(only)) return true;
  if (Command.is(action)) return false;
  return codeActionContains(only, action.kind);
}
var CodeActionManager;
var init_codeActionManager = __esm({
  "src/provider/codeActionManager.ts"() {
    "use strict";
    init_esm_node();
    init_main();
    init_array();
    init_is();
    init_lodash();
    init_manager2();
    CodeActionManager = class extends Manager {
      register(selector, provider, clientId, codeActionKinds) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          kinds: codeActionKinds,
          clientId
        });
      }
      async provideCodeActions(document2, range, context, token) {
        let providers = this.getProviders(document2);
        const only = isFalsyOrEmpty(context.only) ? void 0 : context.only;
        if (only) {
          providers = providers.filter((p) => {
            if (Array.isArray(p.kinds) && !p.kinds.some((kind) => codeActionContains(only, kind))) {
              return false;
            }
            return true;
          });
        }
        let res = [];
        const titles = [];
        let results = await Promise.allSettled(providers.map((item) => {
          let { provider, id: id2 } = item;
          let fn = async () => {
            let actions = await Promise.resolve(provider.provideCodeActions(document2, range, context, token));
            let extensionName = provider["__extensionName"];
            if (isFalsyOrEmpty(actions)) return;
            for (let action of actions) {
              if (titles.includes(action.title) || !checkAction(only, action)) continue;
              if (Command.is(action)) {
                let codeAction = {
                  title: action.title,
                  command: action,
                  providerId: id2,
                  extensionName
                };
                res.push(codeAction);
              } else {
                res.push(Object.assign({ providerId: id2 }, action));
              }
              titles.push(action.title);
            }
          };
          return fn();
        }));
        this.handleResults(results, "provideCodeActions");
        return res;
      }
      async resolveCodeAction(codeAction, token) {
        if (codeAction.edit != null || codeAction.providerId == null) return codeAction;
        let provider = this.getProviderById(codeAction.providerId);
        if (!provider || !func(provider.resolveCodeAction)) return codeAction;
        let resolved = await Promise.resolve(provider.resolveCodeAction(omit(codeAction, ["providerId"]), token));
        return resolved ?? codeAction;
      }
    };
  }
});

// src/provider/codeLensManager.ts
var CodeLensManager;
var init_codeLensManager = __esm({
  "src/provider/codeLensManager.ts"() {
    "use strict";
    init_esm_node();
    init_lodash();
    init_manager2();
    init_is();
    CodeLensManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideCodeLenses(document2, token) {
        let providers = this.getProviders(document2);
        let codeLens = [];
        let results = await Promise.allSettled(providers.map((item) => {
          let { provider, id: id2 } = item;
          return Promise.resolve(provider.provideCodeLenses(document2, token)).then((res) => {
            if (Array.isArray(res)) {
              for (let item2 of res) {
                codeLens.push(Object.assign({ source: id2 }, item2));
              }
            }
          });
        }));
        this.handleResults(results, "provideCodeLenses");
        return codeLens;
      }
      async resolveCodeLens(codeLens, token) {
        if (isCommand(codeLens.command)) return codeLens;
        let provider = this.getProviderById(codeLens.source);
        if (!provider || typeof provider.resolveCodeLens != "function") {
          return codeLens;
        }
        let res = await Promise.resolve(provider.resolveCodeLens(omit(codeLens, ["source"]), token));
        Object.assign(codeLens, res);
        return codeLens;
      }
    };
  }
});

// src/provider/declarationManager.ts
var DeclarationManager;
var init_declarationManager = __esm({
  "src/provider/declarationManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    DeclarationManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDeclaration(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideDeclaration(document2, position, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideDeclaration");
        return locations;
      }
    };
  }
});

// src/provider/definitionManager.ts
var DefinitionManager;
var init_definitionManager = __esm({
  "src/provider/definitionManager.ts"() {
    "use strict";
    init_esm_node();
    init_main();
    init_manager2();
    DefinitionManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDefinition(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideDefinition(document2, position, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideDefinition");
        return locations;
      }
      async provideDefinitionLinks(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideDefinition(document2, position, token)).then((location) => {
            if (Array.isArray(location)) {
              location.forEach((loc) => {
                if (LocationLink.is(loc)) {
                  locations.push(loc);
                }
              });
            }
          });
        }));
        this.handleResults(results, "provideDefinition");
        return locations;
      }
    };
  }
});

// src/provider/documentColorManager.ts
var DocumentColorManager;
var init_documentColorManager = __esm({
  "src/provider/documentColorManager.ts"() {
    "use strict";
    init_esm_node();
    init_object();
    init_manager2();
    DocumentColorManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDocumentColors(document2, token) {
        let items = this.getProviders(document2);
        let colors = [];
        const results = await Promise.allSettled(items.map((item) => {
          let { id: id2 } = item;
          return Promise.resolve(item.provider.provideDocumentColors(document2, token)).then((arr) => {
            let noCheck = colors.length == 0;
            if (Array.isArray(arr)) {
              for (let color of arr) {
                if (noCheck || !colors.some((o) => equals(o.range, color.range))) {
                  colors.push(Object.assign({ source: id2 }, color));
                }
              }
            }
          });
        }));
        this.handleResults(results, "provideDocumentColors");
        return colors;
      }
      async provideColorPresentations(colorInformation, document2, token) {
        let providers = this.getProviders(document2);
        let { range, color } = colorInformation;
        for (let item of providers) {
          let res = await Promise.resolve(item.provider.provideColorPresentations(color, { document: document2, range }, token));
          if (res) return res;
        }
        return null;
      }
    };
  }
});

// src/provider/documentHighlightManager.ts
var DocumentHighlightManager;
var init_documentHighlightManager = __esm({
  "src/provider/documentHighlightManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    DocumentHighlightManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDocumentHighlights(document2, position, token) {
        let items = this.getProviders(document2);
        let res = null;
        for (const item of items) {
          try {
            res = await Promise.resolve(item.provider.provideDocumentHighlights(document2, position, token));
            if (res != null) break;
          } catch (e) {
            this.handleResults([{ status: "rejected", reason: e }], "provideDocumentHighlights");
          }
        }
        return res;
      }
    };
  }
});

// src/provider/documentLinkManager.ts
function rangeToString(range) {
  return `${range.start.line},${range.start.character},${range.end.line},${range.end.character}`;
}
var DocumentLinkManager;
var init_documentLinkManager = __esm({
  "src/provider/documentLinkManager.ts"() {
    "use strict";
    init_esm_node();
    init_lodash();
    init_manager2();
    DocumentLinkManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDocumentLinks(document2, token) {
        let items = this.getProviders(document2);
        if (items.length == 0) return null;
        const links2 = [];
        const seenRanges = /* @__PURE__ */ new Set();
        const results = await Promise.allSettled(items.map(async (item) => {
          let { id: id2, provider } = item;
          const arr = await provider.provideDocumentLinks(document2, token);
          if (Array.isArray(arr)) {
            let check = links2.length > 0;
            arr.forEach((link) => {
              if (check) {
                const rangeString = rangeToString(link.range);
                if (!seenRanges.has(rangeString)) {
                  seenRanges.add(rangeString);
                  links2.push(Object.assign({ source: id2 }, link));
                }
              } else {
                if (items.length > 1) seenRanges.add(rangeToString(link.range));
                links2.push(Object.assign({ source: id2 }, link));
              }
            });
          }
        }));
        this.handleResults(results, "provideDocumentLinks");
        return links2;
      }
      async resolveDocumentLink(link, token) {
        let provider = this.getProviderById(link.source);
        if (typeof provider.resolveDocumentLink === "function") {
          let resolved = await Promise.resolve(provider.resolveDocumentLink(omit(link, ["source"]), token));
          if (resolved) Object.assign(link, resolved);
        }
        return link;
      }
    };
  }
});

// src/provider/documentSymbolManager.ts
function asDocumentSymbolTree(infos) {
  infos = infos.slice().sort((a, b) => {
    return compareRangesUsingStarts(a.location.range, b.location.range);
  });
  const res = [];
  const parentStack = [];
  for (const info of infos) {
    const element = {
      name: toText(info.name),
      kind: info.kind,
      tags: toArray(info.tags),
      detail: "",
      range: info.location.range,
      selectionRange: info.location.range
    };
    if (info.deprecated) {
      element.tags.push(SymbolTag.Deprecated);
    }
    while (true) {
      if (parentStack.length === 0) {
        parentStack.push(element);
        res.push(element);
        break;
      }
      const parent = parentStack[parentStack.length - 1];
      if (rangeInRange(element.range, parent.range) && !equalsRange(parent.range, element.range)) {
        parent.children = toArray(parent.children);
        parent.children.push(element);
        parentStack.push(element);
        break;
      }
      parentStack.pop();
    }
  }
  return res;
}
var DocumentSymbolManager;
var init_documentSymbolManager = __esm({
  "src/provider/documentSymbolManager.ts"() {
    "use strict";
    init_esm_node();
    init_main();
    init_array();
    init_position();
    init_string();
    init_manager2();
    DocumentSymbolManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      getMetaData(document2) {
        let item = this.getProvider(document2);
        if (!item) return null;
        return item.provider.meta ?? {};
      }
      async provideDocumentSymbols(document2, token) {
        let item = this.getProvider(document2);
        if (!item) return null;
        let symbols = [];
        let results = await Promise.allSettled([item].map((item2) => {
          return Promise.resolve(item2.provider.provideDocumentSymbols(document2, token)).then((result) => {
            if (!token.isCancellationRequested && !isFalsyOrEmpty(result)) {
              if (DocumentSymbol.is(result[0])) {
                symbols = result;
              } else {
                symbols = asDocumentSymbolTree(result);
              }
            }
          });
        }));
        this.handleResults(results, "provideDocumentSymbols");
        return symbols;
      }
    };
  }
});

// src/provider/foldingRangeManager.ts
function getParent(line, sortedRanges) {
  for (let r of sortedRanges) {
    if (line >= r.startLine) {
      if (line <= r.endLine) {
        return r;
      } else {
        continue;
      }
    } else {
      break;
    }
  }
  return void 0;
}
var FoldingRangeManager;
var init_foldingRangeManager = __esm({
  "src/provider/foldingRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    FoldingRangeManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      /**
       * Multiple providers can be registered for a language. In that case providers are asked in
       * parallel and the results are merged.
       * If multiple folding ranges start at the same position, only the range of the first registered provider is used.
       * If a folding range overlaps with an other range that has a smaller position, it is also ignored.
       */
      async provideFoldingRanges(document2, context, token) {
        let items = this.getProviders(document2);
        let ranges = [];
        let results = await Promise.allSettled(items.map((item) => {
          return Promise.resolve(item.provider.provideFoldingRanges(document2, context, token)).then((res) => {
            if (Array.isArray(res) && res.length > 0) {
              if (ranges.length == 0) {
                ranges.push(...res);
              } else {
                for (let r of res) {
                  let sp = getParent(r.startLine, ranges);
                  if (sp?.startLine === r.startLine) continue;
                  let ep = getParent(r.endLine, ranges);
                  if (sp === ep) {
                    ranges.push(r);
                  }
                }
              }
              ranges.sort((a, b) => a.startLine - b.startLine);
            }
          });
        }));
        this.handleResults(results, "provideFoldingRanges");
        return ranges;
      }
    };
  }
});

// src/provider/formatManager.ts
var FormatManager;
var init_formatManager = __esm({
  "src/provider/formatManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    FormatManager = class extends Manager {
      register(selector, provider, priority) {
        return this.addProvider({
          id: v4_default(),
          selector,
          priority,
          provider
        });
      }
      async provideDocumentFormattingEdits(document2, options2, token) {
        let item = this.getFormatProvider(document2);
        if (!item) return null;
        let { provider } = item;
        let res = await Promise.resolve(provider.provideDocumentFormattingEdits(document2, options2, token));
        if (Array.isArray(res)) {
          Object.defineProperty(res, "__extensionName", {
            get: () => item.provider["__extensionName"]
          });
        }
        return res;
      }
    };
  }
});

// src/provider/formatRangeManager.ts
var FormatRangeManager;
var init_formatRangeManager = __esm({
  "src/provider/formatRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    FormatRangeManager = class extends Manager {
      register(selector, provider, priority) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          priority
        });
      }
      /**
       * Multiple providers can be registered for a language. In that case providers are sorted
       * by their {@link languages.match score} and the best-matching provider is used. Failure
       * of the selected provider will cause a failure of the whole operation.
       */
      async provideDocumentRangeFormattingEdits(document2, range, options2, token) {
        let item = this.getFormatProvider(document2);
        if (!item) return null;
        let { provider } = item;
        let res = await Promise.resolve(provider.provideDocumentRangeFormattingEdits(document2, range, options2, token));
        if (Array.isArray(res)) {
          Object.defineProperty(res, "__extensionName", {
            get: () => item.provider["__extensionName"]
          });
        }
        return res;
      }
    };
  }
});

// src/provider/hoverManager.ts
var HoverManager;
var init_hoverManager = __esm({
  "src/provider/hoverManager.ts"() {
    "use strict";
    init_esm_node();
    init_is();
    init_object();
    init_manager2();
    HoverManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideHover(document2, position, token) {
        let items = this.getProviders(document2);
        let hovers = [];
        let results = await Promise.allSettled(items.map((item) => {
          return Promise.resolve(item.provider.provideHover(document2, position, token)).then((hover) => {
            if (!isHover(hover)) return;
            if (hovers.findIndex((o) => equals(o.contents, hover.contents)) == -1) {
              hovers.push(hover);
            }
          });
        }));
        this.handleResults(results, "provideHover");
        return hovers;
      }
    };
  }
});

// src/provider/implementationManager.ts
var ImplementationManager;
var init_implementationManager = __esm({
  "src/provider/implementationManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    ImplementationManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideImplementations(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideImplementation(document2, position, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideImplementations");
        return locations;
      }
    };
  }
});

// src/provider/inlayHintManager.ts
function sameHint(one, other) {
  if (comparePosition(one.position, other.position) !== 0) return false;
  return getLabel(one) === getLabel(other);
}
function isInlayHint(obj) {
  if (!obj || !Position.is(obj.position) || obj.label == null) return false;
  if (typeof obj.label !== "string") return Array.isArray(obj.label) && obj.label.every((p) => typeof p.value === "string");
  return true;
}
function isValidInlayHint(hint, range) {
  if (hint.label.length === 0 || Array.isArray(hint.label) && hint.label.every((part) => part.value.length === 0)) {
    logger24.warn("INVALID inlay hint, empty label", hint);
    return false;
  }
  if (!isInlayHint(hint)) {
    logger24.warn("INVALID inlay hint", hint);
    return false;
  }
  if (range && positionInRange(hint.position, range) !== 0) {
    return false;
  }
  return true;
}
function getLabel(hint) {
  if (typeof hint.label === "string") return hint.label;
  return hint.label.map((o) => o.value).join("");
}
var logger24, InlayHintManger;
var init_inlayHintManager = __esm({
  "src/provider/inlayHintManager.ts"() {
    "use strict";
    init_esm_node();
    init_main();
    init_logger();
    init_position();
    init_manager2();
    logger24 = createLogger("inlayHintManger");
    InlayHintManger = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      /**
       * Multiple providers can be registered for a language. In that case providers are asked in
       * parallel and the results are merged. A failing provider (rejected promise or exception) will
       * not cause a failure of the whole operation.
       */
      async provideInlayHints(document2, range, token) {
        let items = this.getProviders(document2);
        let inlayHints = [];
        let results = await Promise.allSettled(items.map(async (item) => {
          let { id: id2, provider } = item;
          let hints = await Promise.resolve(provider.provideInlayHints(document2, range, token));
          if (!Array.isArray(hints) || token.isCancellationRequested) return;
          let noCheck = inlayHints.length == 0;
          for (let hint of hints) {
            if (!isValidInlayHint(hint, range)) continue;
            if (!noCheck && inlayHints.findIndex((o) => sameHint(o, hint)) != -1) continue;
            inlayHints.push({ providerId: id2, ...hint });
          }
        }));
        this.handleResults(results, "provideInlayHints", token);
        return inlayHints;
      }
      async resolveInlayHint(hint, token) {
        let provider = this.getProviderById(hint.providerId);
        if (!provider || typeof provider.resolveInlayHint !== "function" || hint.resolved === true) return hint;
        let res = await Promise.resolve(provider.resolveInlayHint(hint, token));
        if (token.isCancellationRequested) return hint;
        return Object.assign(hint, res, { resolved: true });
      }
    };
  }
});

// src/provider/inlineValueManager.ts
var InlineValueManager;
var init_inlineValueManager = __esm({
  "src/provider/inlineValueManager.ts"() {
    "use strict";
    init_esm_node();
    init_object();
    init_manager2();
    InlineValueManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      /**
       * Multiple providers can be registered for a language. In that case providers are asked in
       * parallel and the results are merged. A failing provider (rejected promise or exception) will
       * not cause a failure of the whole operation.
       */
      async provideInlineValues(document2, viewPort, context, token) {
        const items = this.getProviders(document2);
        const values = [];
        const results = await Promise.allSettled(items.map((item) => {
          return Promise.resolve(item.provider.provideInlineValues(document2, viewPort, context, token)).then((arr) => {
            if (!Array.isArray(arr)) return;
            let noCheck = values.length === 0;
            for (let value of arr) {
              if (noCheck || values.every((o) => !equals(o, value))) {
                values.push(value);
              }
            }
          });
        }));
        this.handleResults(results, "provideInlineValues");
        return values;
      }
    };
  }
});

// src/provider/linkedEditingRangeManager.ts
var logger25, LinkedEditingRangeManager;
var init_linkedEditingRangeManager = __esm({
  "src/provider/linkedEditingRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_logger();
    init_manager2();
    logger25 = createLogger("linkedEditingManager");
    LinkedEditingRangeManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      /**
       * Multiple providers can be registered for a language. In that case providers are sorted
       * by their {@link workspace.match score} and the best-matching provider that has a result is used. Failure
       * of the selected provider will cause a failure of the whole operation.
       */
      async provideLinkedEditingRanges(document2, position, token) {
        let items = this.getProviders(document2);
        for (let item of items) {
          let res = await Promise.resolve(item.provider.provideLinkedEditingRanges(document2, position, token));
          if (res != null) return res;
        }
        return null;
      }
    };
  }
});

// src/provider/onTypeFormatManager.ts
var OnTypeFormatManager;
var init_onTypeFormatManager = __esm({
  "src/provider/onTypeFormatManager.ts"() {
    "use strict";
    init_esm_node();
    init_workspace();
    init_manager2();
    OnTypeFormatManager = class extends Manager {
      register(selector, provider, triggerCharacters) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          triggerCharacters: triggerCharacters ?? []
        });
      }
      couldTrigger(document2, triggerCharacter) {
        for (let o of this.providers) {
          let { triggerCharacters, selector } = o;
          if (workspace_default.match(selector, document2) > 0 && triggerCharacters.includes(triggerCharacter)) {
            return o.provider;
          }
        }
        return null;
      }
      async onCharacterType(character, document2, position, token) {
        let items = this.getProviders(document2);
        let item = items.find((o) => o.triggerCharacters.includes(character));
        if (!item) return null;
        let formatOpts = await workspace_default.getFormatOptions(document2.uri);
        return await Promise.resolve(item.provider.provideOnTypeFormattingEdits(document2, position, character, formatOpts, token));
      }
    };
  }
});

// src/provider/referenceManager.ts
var ReferenceManager;
var init_referenceManager = __esm({
  "src/provider/referenceManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    ReferenceManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideReferences(document2, position, context, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideReferences(document2, position, context, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideReferences");
        return locations;
      }
    };
  }
});

// src/provider/renameManager.ts
var RenameManager;
var init_renameManager = __esm({
  "src/provider/renameManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    RenameManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      /**
       * Multiple providers can be registered for a language. In that case providers are sorted
       * by their {@link workspace.match score} and asked in sequence. The first provider producing a result
       * defines the result of the whole operation.
       */
      async provideRenameEdits(document2, position, newName, token) {
        let items = this.getProviders(document2);
        let edit2 = null;
        for (const item of items) {
          try {
            edit2 = await Promise.resolve(item.provider.provideRenameEdits(document2, position, newName, token));
          } catch (e) {
            this.handleResults([{ status: "rejected", reason: e }], "provideRenameEdits");
          }
          if (edit2 != null) break;
        }
        return edit2;
      }
      async prepareRename(document2, position, token) {
        let items = this.getProviders(document2);
        items = items.filter((o) => typeof o.provider.prepareRename === "function");
        if (items.length === 0) return null;
        for (const item of items) {
          let res = await Promise.resolve(item.provider.prepareRename(document2, position, token));
          if (res != null) return res;
        }
        return false;
      }
    };
  }
});

// src/provider/selectionRangeManager.ts
var SelectionRangeManager;
var init_selectionRangeManager = __esm({
  "src/provider/selectionRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_object();
    init_position();
    init_manager2();
    SelectionRangeManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      /**
       * Multiple providers can be registered for a language. In that case providers are asked in
       * parallel and the results are merged. A failing provider (rejected promise or exception) will
       * not cause a failure of the whole operation.
       */
      async provideSelectionRanges(document2, positions, token) {
        let items = this.getProviders(document2);
        if (items.length === 0) return null;
        let selectionRangeResult = [];
        let results = await Promise.allSettled(items.map((item) => {
          return Promise.resolve(item.provider.provideSelectionRanges(document2, positions, token)).then((ranges) => {
            if (Array.isArray(ranges) && ranges.length > 0) {
              selectionRangeResult.push(ranges);
            }
          });
        }));
        this.handleResults(results, "provideSelectionRanges");
        if (selectionRangeResult.length === 0) return null;
        let selectionRanges = selectionRangeResult[0];
        if (selectionRangeResult.length > 1) {
          for (let i = 1; i <= selectionRangeResult.length - 1; i++) {
            let start = selectionRanges[0].range;
            let end = selectionRanges[selectionRanges.length - 1].range;
            let ranges = selectionRangeResult[i];
            let len = ranges.length;
            if (rangeInRange(end, ranges[0].range) && !equals(end, ranges[0].range)) {
              selectionRanges.push(...ranges);
            } else if (rangeInRange(ranges[len - 1].range, start) && !equals(ranges[len - 1].range, start)) {
              selectionRanges.unshift(...ranges);
            }
          }
        }
        for (let i = 0; i < selectionRanges.length - 1; i++) {
          let r = selectionRanges[i];
          r.parent = selectionRanges[i + 1];
        }
        return selectionRanges;
      }
    };
  }
});

// src/provider/semanticTokensManager.ts
var SemanticTokensManager;
var init_semanticTokensManager = __esm({
  "src/provider/semanticTokensManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    SemanticTokensManager = class extends Manager {
      register(selector, provider, legend) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          legend
        });
      }
      getLegend(document2) {
        const item = this.getProvider(document2);
        if (!item) return;
        return item.legend;
      }
      hasSemanticTokensEdits(document2) {
        let provider = this.getProvider(document2)?.provider;
        if (!provider) return false;
        return typeof provider.provideDocumentSemanticTokensEdits === "function";
      }
      async provideDocumentSemanticTokens(document2, token) {
        let provider = this.getProvider(document2)?.provider;
        if (!provider || typeof provider.provideDocumentSemanticTokens !== "function") return null;
        return await Promise.resolve(provider.provideDocumentSemanticTokens(document2, token));
      }
      async provideDocumentSemanticTokensEdits(document2, previousResultId, token) {
        let item = this.getProvider(document2);
        if (!item || typeof item.provider.provideDocumentSemanticTokensEdits !== "function") return null;
        return await Promise.resolve(item.provider.provideDocumentSemanticTokensEdits(document2, previousResultId, token));
      }
    };
  }
});

// src/provider/semanticTokensRangeManager.ts
var SemanticTokensRangeManager;
var init_semanticTokensRangeManager = __esm({
  "src/provider/semanticTokensRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    SemanticTokensRangeManager = class extends Manager {
      register(selector, provider, legend) {
        return this.addProvider({
          id: v4_default(),
          selector,
          legend,
          provider
        });
      }
      getLegend(document2) {
        const item = this.getProvider(document2);
        if (!item) return;
        return item.legend;
      }
      async provideDocumentRangeSemanticTokens(document2, range, token) {
        let item = this.getProvider(document2);
        if (!item) return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentRangeSemanticTokens(document2, range, token));
      }
    };
  }
});

// src/provider/signatureManager.ts
var SignatureManager;
var init_signatureManager = __esm({
  "src/provider/signatureManager.ts"() {
    "use strict";
    init_esm_node();
    init_array();
    init_manager2();
    SignatureManager = class extends Manager {
      register(selector, provider, triggerCharacters) {
        triggerCharacters = isFalsyOrEmpty(triggerCharacters) ? [] : triggerCharacters;
        let characters = triggerCharacters.reduce((p, c) => p.concat(c.length == 1 ? [c] : c.split(/\s*/g)), []);
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          triggerCharacters: characters
        });
      }
      shouldTrigger(document2, triggerCharacter) {
        let items = this.getProviders(document2);
        if (items.length === 0) return false;
        for (let item of items) {
          if (item.triggerCharacters.includes(triggerCharacter)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Multiple providers can be registered for a language. In that case providers are sorted
       * by their {@link languages.match score} and called sequentially until a provider returns a
       * valid result.
       */
      async provideSignatureHelp(document2, position, token, context) {
        let items = this.getProviders(document2);
        for (const item of items) {
          let res = await Promise.resolve(item.provider.provideSignatureHelp(document2, position, token, context));
          if (res && res.signatures && res.signatures.length > 0) return res;
        }
        return null;
      }
    };
  }
});

// src/provider/typeDefinitionManager.ts
var TypeDefinitionManager;
var init_typeDefinitionManager = __esm({
  "src/provider/typeDefinitionManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    TypeDefinitionManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideTypeDefinition(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideTypeDefinition(document2, position, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideTypeDefinition");
        return locations;
      }
    };
  }
});

// src/provider/typeHierarchyManager.ts
var excludeKeys, TypeHierarchyManager;
var init_typeHierarchyManager = __esm({
  "src/provider/typeHierarchyManager.ts"() {
    "use strict";
    init_esm_node();
    init_lodash();
    init_manager2();
    excludeKeys = ["source"];
    TypeHierarchyManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      /**
       * Multiple providers can be registered for a language. In that case providers are asked in
       * parallel and the results are merged. A failing provider (rejected promise or exception) will
       * not cause a failure of the whole operation.
       */
      async prepareTypeHierarchy(document2, position, token) {
        const items = this.getProviders(document2);
        let hierarchyItems = [];
        let results = await Promise.allSettled(items.map((item) => {
          let { provider, id: id2 } = item;
          return (async () => {
            let arr = await Promise.resolve(provider.prepareTypeHierarchy(document2, position, token));
            if (Array.isArray(arr)) {
              let noCheck = hierarchyItems.length === 0;
              arr.forEach((item2) => {
                if (noCheck || hierarchyItems.every((o) => o.name !== item2.name)) {
                  hierarchyItems.push(Object.assign({ source: id2 }, item2));
                }
              });
            }
          })();
        }));
        this.handleResults(results, "prepareTypeHierarchy");
        return hierarchyItems;
      }
      async provideTypeHierarchySupertypes(item, token) {
        let { source } = item;
        const provider = this.getProviderById(source);
        if (!provider) return [];
        return await Promise.resolve(provider.provideTypeHierarchySupertypes(omit(item, excludeKeys), token)).then((arr) => {
          if (Array.isArray(arr)) {
            return arr.map((item2) => {
              return Object.assign({ source }, item2);
            });
          }
          return [];
        });
      }
      async provideTypeHierarchySubtypes(item, token) {
        let { source } = item;
        const provider = this.getProviderById(source);
        if (!provider) return [];
        return await Promise.resolve(provider.provideTypeHierarchySubtypes(omit(item, excludeKeys), token)).then((arr) => {
          if (Array.isArray(arr)) {
            return arr.map((item2) => {
              return Object.assign({ source }, item2);
            });
          }
          return [];
        });
      }
    };
  }
});

// src/provider/workspaceSymbolsManager.ts
var WorkspaceSymbolManager;
var init_workspaceSymbolsManager = __esm({
  "src/provider/workspaceSymbolsManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager2();
    WorkspaceSymbolManager = class extends Manager {
      register(provider) {
        return this.addProvider({
          id: v4_default(),
          selector: [{ language: "*" }],
          provider
        });
      }
      async provideWorkspaceSymbols(query, token) {
        let entries = Array.from(this.providers);
        let infos = [];
        let results = await Promise.allSettled(entries.map((o) => {
          let { id: id2, provider } = o;
          return Promise.resolve(provider.provideWorkspaceSymbols(query, token)).then((list2) => {
            if (Array.isArray(list2)) {
              infos.push(...list2.map((item) => Object.assign({ source: id2 }, item)));
            }
          });
        }));
        this.handleResults(results, "provideWorkspaceSymbols");
        return infos;
      }
      async resolveWorkspaceSymbol(symbolInfo, token) {
        let provider = this.getProviderById(symbolInfo.source);
        if (!provider || typeof provider.resolveWorkspaceSymbol !== "function") return symbolInfo;
        return provider.resolveWorkspaceSymbol(symbolInfo, token);
      }
      hasProvider() {
        return this.providers.size > 0;
      }
    };
  }
});

// node_modules/mimic-response/index.js
var require_mimic_response = __commonJS({
  "node_modules/mimic-response/index.js"(exports2, module2) {
    "use strict";
    var knownProperties = [
      "aborted",
      "complete",
      "headers",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "method",
      "rawHeaders",
      "rawTrailers",
      "setTimeout",
      "socket",
      "statusCode",
      "statusMessage",
      "trailers",
      "url"
    ];
    module2.exports = (fromStream, toStream) => {
      if (toStream._readableState.autoDestroy) {
        throw new Error("The second stream must have the `autoDestroy` option set to `false`");
      }
      const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));
      const properties = {};
      for (const property of fromProperties) {
        if (property in toStream) {
          continue;
        }
        properties[property] = {
          get() {
            const value = fromStream[property];
            const isFunction = typeof value === "function";
            return isFunction ? value.bind(fromStream) : value;
          },
          set(value) {
            fromStream[property] = value;
          },
          enumerable: true,
          configurable: false
        };
      }
      Object.defineProperties(toStream, properties);
      fromStream.once("aborted", () => {
        toStream.destroy();
        toStream.emit("aborted");
      });
      fromStream.once("close", () => {
        if (fromStream.complete) {
          if (toStream.readable) {
            toStream.once("end", () => {
              toStream.emit("close");
            });
          } else {
            toStream.emit("close");
          }
        } else {
          toStream.emit("close");
        }
      });
      return toStream;
    };
  }
});

// node_modules/decompress-response/index.js
var require_decompress_response = __commonJS({
  "node_modules/decompress-response/index.js"(exports2, module2) {
    "use strict";
    var { Transform: Transform2, PassThrough } = require("stream");
    var zlib = require("zlib");
    var mimicResponse = require_mimic_response();
    module2.exports = (response) => {
      const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
      if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
        return response;
      }
      const isBrotli = contentEncoding === "br";
      if (isBrotli && typeof zlib.createBrotliDecompress !== "function") {
        response.destroy(new Error("Brotli is not supported on Node.js < 12"));
        return response;
      }
      let isEmpty2 = true;
      const checker = new Transform2({
        transform(data, _encoding, callback) {
          isEmpty2 = false;
          callback(null, data);
        },
        flush(callback) {
          callback();
        }
      });
      const finalStream = new PassThrough({
        autoDestroy: false,
        destroy(error, callback) {
          response.destroy();
          callback(error);
        }
      });
      const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
      decompressStream.once("error", (error) => {
        if (isEmpty2 && !response.readable) {
          finalStream.end();
          return;
        }
        finalStream.destroy(error);
      });
      mimicResponse(response, finalStream);
      response.pipe(checker).pipe(decompressStream).pipe(finalStream);
      return finalStream;
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse3(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format3) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format3];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name2) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name2, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name2, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os2 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level2) {
      if (level2 === 0) {
        return false;
      }
      return {
        level: level2,
        hasBasic: true,
        has256: level2 >= 2,
        has16m: level2 >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os2.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level2 = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level2);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node3 = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node3();
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    var url = require("url");
    var URL5 = url.URL;
    var http2 = require("http");
    var https2 = require("https");
    var Writable = require("stream").Writable;
    var assert2 = require("assert");
    var debug = require_debug2();
    var useNativeURL = false;
    try {
      assert2(new URL5());
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop;
    function RedirectableRequest(options2, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options2);
      this._options = options2;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self = this;
      this._onNativeResponse = function(response) {
        try {
          self._processResponse(response);
        } catch (cause) {
          self.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding2, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding2)) {
        callback = encoding2;
        encoding2 = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding: encoding2 });
        this._currentRequest.write(data, encoding2, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding2, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding2 = null;
      } else if (isFunction(encoding2)) {
        callback = encoding2;
        encoding2 = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding2, function() {
          self._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name2, value) {
      this._options.headers[name2] = value;
      this._currentRequest.setHeader(name2, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name2) {
      delete this._options.headers[name2];
      this._currentRequest.removeHeader(name2);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self._timeout) {
          clearTimeout(self._timeout);
        }
        self._timeout = setTimeout(function() {
          self.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self._timeout) {
          clearTimeout(self._timeout);
          self._timeout = null;
        }
        self.removeListener("abort", clearTimer);
        self.removeListener("error", clearTimer);
        self.removeListener("response", clearTimer);
        self.removeListener("close", clearTimer);
        if (callback) {
          self.removeListener("timeout", callback);
        }
        if (!self.socket) {
          self._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options2) {
      if (!options2.headers) {
        options2.headers = {};
      }
      if (options2.host) {
        if (!options2.hostname) {
          options2.hostname = options2.host;
        }
        delete options2.host;
      }
      if (!options2.pathname && options2.path) {
        var searchPos = options2.path.indexOf("?");
        if (searchPos < 0) {
          options2.pathname = options2.path;
        } else {
          options2.pathname = options2.path.substring(0, searchPos);
          options2.search = options2.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol2 = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol2];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol2);
      }
      if (this._options.agents) {
        var scheme = protocol2.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request2._redirectable = this;
      for (var event of events) {
        request2.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, […]
        // a client MUST send the target URI in absolute-form […].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request2 === self._currentRequest) {
            if (error) {
              self.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request2.finished) {
                request2.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self._ended) {
              request2.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl2(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol2 = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol2] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request2(input, options2, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options2;
            options2 = validateUrl(input);
            input = { protocol: protocol2 };
          }
          if (isFunction(options2)) {
            callback = options2;
            options2 = null;
          }
          options2 = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options2);
          options2.nativeProtocols = nativeProtocols;
          if (!isString(options2.host) && !isString(options2.hostname)) {
            options2.hostname = "::1";
          }
          assert2.equal(options2.protocol, protocol2, "protocol mismatch");
          debug("options", options2);
          return new RedirectableRequest(options2, callback);
        }
        function get(input, options2, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options2, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request2, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL5(input);
      } else {
        parsed = validateUrl(url.parse(input));
        if (!isString(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl2(relative, base) {
      return useNativeURL ? new URL5(relative, base) : parseUrl(url.resolve(base, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread = target || {};
      for (var key of preservedUrlFields) {
        spread[key] = urlObject[key];
      }
      if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
      }
      if (spread.port !== "") {
        spread.port = Number(spread.port);
      }
      spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
      return spread;
    }
    function removeMatchingHeaders(regex2, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex2.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request2, error) {
      for (var event of events) {
        request2.removeListener(event, eventHandlers[event]);
      }
      request2.on("error", noop);
      request2.destroy(error);
    }
    function isSubdomain(subdomain, domain2) {
      assert2(isString(subdomain) && isString(domain2));
      var dot = subdomain.length - domain2.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain2);
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL5 && value instanceof URL5;
    }
    module2.exports = wrap({ http: http2, https: https2 });
    module2.exports.wrap = wrap;
  }
});

// node_modules/@tootallnate/once/dist/index.js
var require_dist = __commonJS({
  "node_modules/@tootallnate/once/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function once(emitter, name2, { signal } = {}) {
      return new Promise((resolve, reject) => {
        function cleanup() {
          signal === null || signal === void 0 ? void 0 : signal.removeEventListener("abort", cleanup);
          emitter.removeListener(name2, onEvent);
          emitter.removeListener("error", onError);
        }
        function onEvent(...args) {
          cleanup();
          resolve(args);
        }
        function onError(err) {
          cleanup();
          reject(err);
        }
        signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", cleanup);
        emitter.on(name2, onEvent);
        emitter.on("error", onError);
      });
    }
    exports2.default = once;
  }
});

// node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "node_modules/agent-base/dist/src/promisify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function promisify2(fn) {
      return function(req, opts) {
        return new Promise((resolve, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve(rtn);
            }
          });
        });
      };
    }
    exports2.default = promisify2;
  }
});

// node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/agent-base/dist/src/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = require("events");
    var debug_1 = __importDefault(require_src());
    var promisify_1 = __importDefault(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  }
});

// node_modules/http-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "node_modules/http-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var debug_1 = __importDefault(require_src());
    var once_1 = __importDefault(require_dist());
    var agent_base_1 = require_src2();
    var debug = (0, debug_1.default)("http-proxy-agent");
    function isHTTPS(protocol2) {
      return typeof protocol2 === "string" ? /^https:?$/i.test(protocol2) : false;
    }
    var HttpProxyAgent2 = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("Creating new HttpProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       *
       * @api protected
       */
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          const parsed = url_1.default.parse(req.path);
          if (!parsed.protocol) {
            parsed.protocol = "http:";
          }
          if (!parsed.hostname) {
            parsed.hostname = opts.hostname || opts.host || null;
          }
          if (parsed.port == null && typeof opts.port) {
            parsed.port = String(opts.port);
          }
          if (parsed.port === "80") {
            parsed.port = "";
          }
          req.path = url_1.default.format(parsed);
          if (proxy.auth) {
            req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
          }
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          if (req._header) {
            let first;
            let endOfHeaders;
            debug("Regenerating stored HTTP header string for request");
            req._header = null;
            req._implicitHeader();
            if (req.output && req.output.length > 0) {
              debug("Patching connection write() output buffer with updated header");
              first = req.output[0];
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.output[0] = req._header + first.substring(endOfHeaders);
              debug("Output buffer: %o", req.output);
            } else if (req.outputData && req.outputData.length > 0) {
              debug("Patching connection write() output buffer with updated header");
              first = req.outputData[0].data;
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.outputData[0].data = req._header + first.substring(endOfHeaders);
              debug("Output buffer: %o", req.outputData[0].data);
            }
          }
          yield (0, once_1.default)(socket, "connect");
          return socket;
        });
      }
    };
    exports2.default = HttpProxyAgent2;
  }
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/http-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpProxyAgent2(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpProxyAgent3) {
      createHttpProxyAgent3.HttpProxyAgent = agent_1.default;
      createHttpProxyAgent3.prototype = agent_1.default.prototype;
    })(createHttpProxyAgent2 || (createHttpProxyAgent2 = {}));
    module2.exports = createHttpProxyAgent2;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports2.default = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent2 = __commonJS({
  "node_modules/https-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent2 = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       *
       * @api protected
       */
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name2 of Object.keys(headers)) {
            payload += `${name2}: ${headers[name2]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              debug("Upgrading socket connection to TLS");
              const servername = opts.servername || opts.host;
              return tls_1.default.connect(Object.assign(Object.assign({}, omit2(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket({ writable: false });
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports2.default = HttpsProxyAgent2;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol2) {
      return typeof protocol2 === "string" ? /^https:?$/i.test(protocol2) : false;
    }
    function omit2(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent2());
    function createHttpsProxyAgent2(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent3) {
      createHttpsProxyAgent3.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent3.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent2 || (createHttpsProxyAgent2 = {}));
    module2.exports = createHttpsProxyAgent2;
  }
});

// src/model/fetch.ts
function getRequestModule(url) {
  return url.protocol === "https:" ? import_follow_redirects.https : import_follow_redirects.http;
}
function getText2(data) {
  if (typeof data === "string" || Buffer.isBuffer(data)) return data;
  return JSON.stringify(data);
}
function toURL(urlInput) {
  if (urlInput instanceof import_url2.URL) return urlInput;
  let url = new import_url2.URL(urlInput);
  if (!["https:", "http:"].includes(url.protocol)) throw new Error(`Not valid protocol with ${urlInput}, should be http: or https:`);
  return url;
}
function toPort(port, protocol2) {
  if (port) {
    port = typeof port === "number" ? port : parseInt(port, 10);
    if (!isNaN(port)) return port;
  }
  return protocol2.startsWith("https") ? 443 : 80;
}
function getDataType(data) {
  if (data === null) return "null";
  if (data === void 0) return "undefined";
  if (typeof data == "string") return "string";
  if (Buffer.isBuffer(data)) return "buffer";
  if (Array.isArray(data) || objectLiteral(data)) return "object";
  return "unknown";
}
function getSystemProxyURI(endpoint, env = process.env) {
  let noProxy = env.NO_PROXY ?? env.no_proxy;
  if (noProxy === "*") {
    return null;
  }
  if (noProxy) {
    const hostname = endpoint.hostname.replace(/^\.*/, ".").toLowerCase();
    const port = toPort(endpoint.port, endpoint.protocol).toString();
    const noProxyList = noProxy.split(",");
    for (let i = 0, len = noProxyList.length; i < len; i++) {
      let noProxyItem = noProxyList[i].trim().toLowerCase();
      if (noProxyItem.includes(":")) {
        let noProxyItemParts = noProxyItem.split(":", 2);
        let noProxyHost = noProxyItemParts[0].replace(/^\.*/, ".");
        let noProxyPort = noProxyItemParts[1];
        if (port == noProxyPort && hostname.endsWith(noProxyHost)) {
          return null;
        }
      } else {
        noProxyItem = noProxyItem.replace(/^\.*/, ".");
        if (hostname.endsWith(noProxyItem)) {
          return null;
        }
      }
    }
  }
  let proxyUri;
  if (endpoint.protocol === "http:") {
    proxyUri = env.HTTP_PROXY || env.http_proxy || null;
  } else {
    proxyUri = env.HTTPS_PROXY || env.https_proxy || env.HTTP_PROXY || env.http_proxy || null;
  }
  return proxyUri;
}
function getAgent(endpoint, options2) {
  let proxy = options2.proxy || getSystemProxyURI(endpoint);
  if (proxy) {
    let proxyURL;
    try {
      proxyURL = new import_url2.URL(proxy);
      if (!/^https?:$/.test(proxyURL.protocol)) return null;
    } catch (e) {
      return null;
    }
    let opts = {
      host: proxyURL.hostname,
      port: toPort(proxyURL.port, proxyURL.protocol),
      auth: proxyURL.username ? `${proxyURL.username}:${toText(proxyURL.password)}` : void 0,
      rejectUnauthorized: typeof options2.proxyStrictSSL === "boolean" ? options2.proxyStrictSSL : true
    };
    logger26.info(`Using proxy ${proxy} from ${options2.proxy ? "configuration" : "system environment"} for ${endpoint.hostname}:`);
    return endpoint.protocol === "http:" ? (0, import_http_proxy_agent.default)(opts) : (0, import_https_proxy_agent.default)(opts);
  }
  return null;
}
function resolveRequestOptions(url, options2) {
  let config = workspace_default.getConfiguration("http", null);
  let dataType = getDataType(options2.data);
  let proxyOptions = {
    proxy: config.get("proxy", ""),
    proxyStrictSSL: config.get("proxyStrictSSL", true),
    proxyAuthorization: config.get("proxyAuthorization", null),
    proxyCA: config.get("proxyCA", null)
  };
  if (options2.query && !url.search) {
    url.search = `?${(0, import_querystring.stringify)(options2.query)}`;
  }
  let agent = getAgent(url, proxyOptions);
  let opts = {
    method: options2.method ?? "GET",
    hostname: url.hostname,
    port: toPort(url.port, url.protocol),
    path: url.pathname + url.search,
    agent,
    rejectUnauthorized: proxyOptions.proxyStrictSSL,
    maxRedirects: 3,
    headers: {
      "User-Agent": "Mozilla/5.0 (X11; Linux x86_64)",
      "Accept-Encoding": "gzip, deflate",
      ...options2.headers ?? {}
    }
  };
  if (dataType == "object") {
    opts.headers["Content-Type"] = "application/json";
  } else if (dataType == "string") {
    opts.headers["Content-Type"] = "text/plain";
  }
  if (proxyOptions.proxyAuthorization) opts.headers["Proxy-Authorization"] = proxyOptions.proxyAuthorization;
  if (proxyOptions.proxyCA) opts.ca = fs.readFileSync(proxyOptions.proxyCA);
  if (options2.user) opts.auth = options2.user + ":" + toText(options2.password);
  if (url.username) opts.auth = url.username + ":" + toText(url.password);
  if (options2.timeout) opts.timeout = options2.timeout;
  if (options2.buffer) opts.buffer = true;
  return opts;
}
function request(url, data, opts, token) {
  let mod = getRequestModule(url);
  return new Promise((resolve, reject) => {
    if (token) {
      let disposable = token.onCancellationRequested(() => {
        disposable.dispose();
        req.destroy(new CancellationError());
      });
    }
    let timer;
    const req = mod.request(opts, (res) => {
      let readable = res;
      if (res.statusCode >= 200 && res.statusCode < 300 || res.statusCode === 1223) {
        let headers = res.headers;
        let chunks = [];
        let contentType = toText(headers["content-type"]);
        readable = (0, import_decompress_response.default)(res);
        readable.on("data", (chunk) => {
          chunks.push(chunk);
        });
        readable.on("end", () => {
          clearTimeout(timer);
          let buf = Buffer.concat(chunks);
          if (!opts.buffer && (contentType.startsWith("application/json") || contentType.startsWith("text/"))) {
            let ms = contentType.match(/charset=(\S+)/);
            let encoding2 = ms ? ms[1] : "utf8";
            let rawData = buf.toString(encoding2);
            if (!contentType.includes("application/json")) {
              resolve(rawData);
            } else {
              try {
                const parsedData = JSON.parse(rawData);
                resolve(parsedData);
              } catch (e) {
                reject(new Error(`Parse response error: ${e}`));
              }
            }
          } else {
            resolve(buf);
          }
        });
        readable.on("error", (err) => {
          reject(new Error(`Connection error to ${url}: ${err.message}`));
        });
      } else {
        reject(new Error(`Bad response from ${url}: ${res.statusCode}`));
      }
    });
    req.on("error", (e) => {
      if (opts.agent && e["code"] == "ECONNRESET") {
        timer = setTimeout(() => {
          reject(e);
        }, timeout);
      } else {
        reject(e);
      }
    });
    req.on("timeout", () => {
      req.destroy(new Error(`Request timeout after ${opts.timeout}ms`));
    });
    if (data) req.write(getText2(data));
    if (opts.timeout) req.setTimeout(opts.timeout);
    req.end();
  });
}
function fetch(urlInput, options2 = {}, token) {
  let url = toURL(urlInput);
  let opts = resolveRequestOptions(url, options2);
  return request(url, options2.data, opts, token).catch((err) => {
    logger26.error(`Fetch error for ${url}:`, opts, err);
    if (opts.agent && opts.agent.proxy) {
      let { proxy } = opts.agent;
      throw new Error(`Request failed using proxy ${proxy.host}: ${err.message}`);
    } else {
      throw err;
    }
  });
}
var import_decompress_response, import_follow_redirects, import_http_proxy_agent, import_https_proxy_agent, import_querystring, import_url2, logger26, timeout;
var init_fetch = __esm({
  "src/model/fetch.ts"() {
    "use strict";
    import_decompress_response = __toESM(require_decompress_response());
    import_follow_redirects = __toESM(require_follow_redirects());
    import_http_proxy_agent = __toESM(require_dist2());
    import_https_proxy_agent = __toESM(require_dist3());
    import_querystring = require("querystring");
    import_url2 = require("url");
    init_logger();
    init_errors();
    init_is();
    init_node();
    init_workspace();
    init_string();
    init_util();
    logger26 = createLogger("model-fetch");
    timeout = getConditionValue(500, 50);
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding2) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding2 === "string") {
          buf.fill(fill, encoding2);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/content-disposition/index.js
var require_content_disposition = __commonJS({
  "node_modules/content-disposition/index.js"(exports2, module2) {
    "use strict";
    module2.exports = contentDisposition;
    module2.exports.parse = parse3;
    var basename = require("path").basename;
    var Buffer3 = require_safe_buffer().Buffer;
    var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
    var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
    var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
    var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
    var QESC_REGEXP = /\\([\u0000-\u007f])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
    var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
    var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
    var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
    function contentDisposition(filename, options2) {
      var opts = options2 || {};
      var type = opts.type || "attachment";
      var params = createparams(filename, opts.fallback);
      return format3(new ContentDisposition(type, params));
    }
    function createparams(filename, fallback) {
      if (filename === void 0) {
        return;
      }
      var params = {};
      if (typeof filename !== "string") {
        throw new TypeError("filename must be a string");
      }
      if (fallback === void 0) {
        fallback = true;
      }
      if (typeof fallback !== "string" && typeof fallback !== "boolean") {
        throw new TypeError("fallback must be a string or boolean");
      }
      if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
        throw new TypeError("fallback must be ISO-8859-1 string");
      }
      var name2 = basename(filename);
      var isQuotedString = TEXT_REGEXP.test(name2);
      var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name2) : basename(fallback);
      var hasFallback = typeof fallbackName === "string" && fallbackName !== name2;
      if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name2)) {
        params["filename*"] = name2;
      }
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name2;
      }
      return params;
    }
    function format3(obj) {
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string2 = String(type).toLowerCase();
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
          string2 += "; " + param + "=" + val;
        }
      }
      return string2;
    }
    function decodefield(str) {
      var match = EXT_VALUE_REGEXP.exec(str);
      if (!match) {
        throw new TypeError("invalid extended field value");
      }
      var charset = match[1].toLowerCase();
      var encoded = match[2];
      var value;
      var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
      switch (charset) {
        case "iso-8859-1":
          value = getlatin1(binary);
          break;
        case "utf-8":
          value = Buffer3.from(binary, "binary").toString("utf8");
          break;
        default:
          throw new TypeError("unsupported charset in extended field");
      }
      return value;
    }
    function getlatin1(val) {
      return String(val).replace(NON_LATIN1_REGEXP, "?");
    }
    function parse3(string2) {
      if (!string2 || typeof string2 !== "string") {
        throw new TypeError("argument string is required");
      }
      var match = DISPOSITION_TYPE_REGEXP.exec(string2);
      if (!match) {
        throw new TypeError("invalid type format");
      }
      var index = match[0].length;
      var type = match[1].toLowerCase();
      var key;
      var names = [];
      var params = {};
      var value;
      index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
      while (match = PARAM_REGEXP.exec(string2)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (names.indexOf(key) !== -1) {
          throw new TypeError("invalid duplicate parameter");
        }
        names.push(key);
        if (key.indexOf("*") + 1 === key.length) {
          key = key.slice(0, -1);
          value = decodefield(value);
          params[key] = value;
          continue;
        }
        if (typeof params[key] === "string") {
          continue;
        }
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
        }
        params[key] = value;
      }
      if (index !== -1 && index !== string2.length) {
        throw new TypeError("invalid parameter format");
      }
      return new ContentDisposition(type, params);
    }
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16));
    }
    function pencode(char) {
      return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
    }
    function qstring(val) {
      var str = String(val);
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ustring(val) {
      var str = String(val);
      var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
      return "UTF-8''" + encoded;
    }
    function ContentDisposition(type, parameters) {
      this.type = type;
      this.parameters = parameters;
    }
  }
});

// node_modules/tar/lib/high-level-opt.js
var require_high_level_opt = __commonJS({
  "node_modules/tar/lib/high-level-opt.js"(exports2, module2) {
    "use strict";
    var argmap = /* @__PURE__ */ new Map([
      ["C", "cwd"],
      ["f", "file"],
      ["z", "gzip"],
      ["P", "preservePaths"],
      ["U", "unlink"],
      ["strip-components", "strip"],
      ["stripComponents", "strip"],
      ["keep-newer", "newer"],
      ["keepNewer", "newer"],
      ["keep-newer-files", "newer"],
      ["keepNewerFiles", "newer"],
      ["k", "keep"],
      ["keep-existing", "keep"],
      ["keepExisting", "keep"],
      ["m", "noMtime"],
      ["no-mtime", "noMtime"],
      ["p", "preserveOwner"],
      ["L", "follow"],
      ["h", "follow"]
    ]);
    module2.exports = (opt) => opt ? Object.keys(opt).map((k) => [
      argmap.has(k) ? argmap.get(k) : k,
      opt[k]
    ]).reduce((set, kv) => (set[kv[0]] = kv[1], set), /* @__PURE__ */ Object.create(null)) : {};
  }
});

// node_modules/tar/node_modules/minipass/index.js
var require_minipass = __commonJS({
  "node_modules/tar/node_modules/minipass/index.js"(exports2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var stringdecoder = require("string_decoder");
    var SD = stringdecoder.StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFER = Symbol("buffer");
    var PIPES = Symbol("pipes");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var ERROR = Symbol("error");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var ABORT = Symbol("abort");
    var ABORTED = Symbol("aborted");
    var SIGNAL = Symbol("signal");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end) this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    var Minipass = class _Minipass extends Stream {
      constructor(options2) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this[PIPES] = [];
        this[BUFFER] = [];
        this[OBJECTMODE] = options2 && options2.objectMode || false;
        if (this[OBJECTMODE]) this[ENCODING] = null;
        else this[ENCODING] = options2 && options2.encoding || null;
        if (this[ENCODING] === "buffer") this[ENCODING] = null;
        this[ASYNC] = options2 && !!options2.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
        if (options2 && options2.debugExposeBuffer === true) {
          Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
        }
        if (options2 && options2.debugExposePipes === true) {
          Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
        }
        this[SIGNAL] = options2 && options2.signal;
        this[ABORTED] = false;
        if (this[SIGNAL]) {
          this[SIGNAL].addEventListener("abort", () => this[ABORT]());
          if (this[SIGNAL].aborted) {
            this[ABORT]();
          }
        }
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE]) throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this[BUFFER].length)
            this[BUFFER] = this[BUFFER].map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      // drop everything and get out of the flow completely
      [ABORT]() {
        this[ABORTED] = true;
        this.emit("abort", this[SIGNAL].reason);
        this.destroy(this[SIGNAL].reason);
      }
      get aborted() {
        return this[ABORTED];
      }
      set aborted(_) {
      }
      write(chunk, encoding2, cb) {
        if (this[ABORTED]) return false;
        if (this[EOF]) throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit(
            "error",
            Object.assign(
              new Error("Cannot call write after a stream was destroyed"),
              { code: "ERR_STREAM_DESTROYED" }
            )
          );
          return true;
        }
        if (typeof encoding2 === "function") cb = encoding2, encoding2 = "utf8";
        if (!encoding2) encoding2 = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
          if (this.flowing) this.emit("data", chunk);
          else this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding2 === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding2);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
        if (this.flowing) this.emit("data", chunk);
        else this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0) this.emit("readable");
        if (cb) fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED]) return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE]) n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
          if (this.encoding) this[BUFFER] = [this[BUFFER].join("")];
          else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null) this[BUFFERSHIFT]();
        else {
          this[BUFFER][0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF]) this.emit("drain");
        return chunk;
      }
      end(chunk, encoding2, cb) {
        if (typeof chunk === "function") cb = chunk, chunk = null;
        if (typeof encoding2 === "function") cb = encoding2, encoding2 = "utf8";
        if (chunk) this.write(chunk, encoding2);
        if (cb) this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED]) return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length) this[FLUSH]();
        else if (this[EOF]) this[MAYBE_EMIT_END]();
        else this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
        else this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
        else this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        this.emit("data", chunk);
        return this.flowing;
      }
      pipe(dest, opts) {
        if (this[DESTROYED]) return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
        else opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end) dest.end();
        } else {
          this[PIPES].push(
            !opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts)
          );
          if (this[ASYNC]) defer(() => this[RESUME]());
          else this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this[PIPES].find((p2) => p2.dest === dest);
        if (p) {
          this[PIPES].splice(this[PIPES].indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this[PIPES].length && !this.flowing) this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));
          else fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED]) this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED]) return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          super.emit(ERROR, data);
          const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this[PIPES]) {
          if (p.dest.write(data) === false) this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END]) return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC]) defer(() => this[EMITEND2]());
        else this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this[PIPES]) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this[PIPES]) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE]) buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE]) buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then(
          (buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength)
        );
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        let stopped = false;
        const stop = () => {
          this.pause();
          stopped = true;
          return Promise.resolve({ done: true });
        };
        const next = () => {
          if (stopped) return stop();
          const res = this.read();
          if (res !== null) return Promise.resolve({ done: false, value: res });
          if (this[EOF]) return stop();
          let resolve = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            this.removeListener(DESTROYED, ondestroy);
            stop();
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.removeListener(DESTROYED, ondestroy);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            this.removeListener(DESTROYED, ondestroy);
            stop();
            resolve({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return {
          next,
          throw: stop,
          return: stop,
          [ASYNCITERATOR]() {
            return this;
          }
        };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        let stopped = false;
        const stop = () => {
          this.pause();
          this.removeListener(ERROR, stop);
          this.removeListener(DESTROYED, stop);
          this.removeListener("end", stop);
          stopped = true;
          return { done: true };
        };
        const next = () => {
          if (stopped) return stop();
          const value = this.read();
          return value === null ? stop() : { value };
        };
        this.once("end", stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
          next,
          throw: stop,
          return: stop,
          [ITERATOR]() {
            return this;
          }
        };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er) this.emit("error", er);
          else this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED]) this.close();
        if (er) this.emit("error", er);
        else this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof _Minipass || s instanceof Stream || s instanceof EE && // readable
        (typeof s.pipe === "function" || // writable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
    exports2.Minipass = Minipass;
  }
});

// node_modules/minizlib/constants.js
var require_constants3 = __commonJS({
  "node_modules/minizlib/constants.js"(exports2, module2) {
    var realZlibConstants = require("zlib").constants || /* istanbul ignore next */
    { ZLIB_VERNUM: 4736 };
    module2.exports = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31
    }, realZlibConstants));
  }
});

// node_modules/minizlib/node_modules/minipass/index.js
var require_minipass2 = __commonJS({
  "node_modules/minizlib/node_modules/minipass/index.js"(exports2, module2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    module2.exports = class Minipass extends Stream {
      constructor(options2) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options2 && options2.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options2 && options2.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options2 && !!options2.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      write(chunk, encoding2, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding2 === "function")
          cb = encoding2, encoding2 = "utf8";
        if (!encoding2)
          encoding2 = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding2 === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding2);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = [this.buffer.join("")];
          else
            this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer[0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding2, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding2 === "function")
          cb = encoding2, encoding2 = "utf8";
        if (chunk)
          this.write(chunk, encoding2);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this.pipes.find((p2) => p2.dest === dest);
        if (p) {
          this.pipes.splice(this.pipes.indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          const ret2 = super.emit("error", data);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this.pipes) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this.pipes) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this.pipes) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || // readable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/minizlib/index.js
var require_minizlib = __commonJS({
  "node_modules/minizlib/index.js"(exports2) {
    "use strict";
    var assert2 = require("assert");
    var Buffer3 = require("buffer").Buffer;
    var realZlib = require("zlib");
    var constants = exports2.constants = require_constants3();
    var Minipass = require_minipass2();
    var OriginalBufferConcat = Buffer3.concat;
    var _superWrite = Symbol("_superWrite");
    var ZlibError = class extends Error {
      constructor(err) {
        super("zlib: " + err.message);
        this.code = err.code;
        this.errno = err.errno;
        if (!this.code)
          this.code = "ZLIB_ERROR";
        this.message = "zlib: " + err.message;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "ZlibError";
      }
    };
    var _opts = Symbol("opts");
    var _flushFlag = Symbol("flushFlag");
    var _finishFlushFlag = Symbol("finishFlushFlag");
    var _fullFlushFlag = Symbol("fullFlushFlag");
    var _handle = Symbol("handle");
    var _onError = Symbol("onError");
    var _sawError = Symbol("sawError");
    var _level = Symbol("level");
    var _strategy = Symbol("strategy");
    var _ended = Symbol("ended");
    var _defaultFullFlush = Symbol("_defaultFullFlush");
    var ZlibBase = class extends Minipass {
      constructor(opts, mode) {
        if (!opts || typeof opts !== "object")
          throw new TypeError("invalid options for ZlibBase constructor");
        super(opts);
        this[_sawError] = false;
        this[_ended] = false;
        this[_opts] = opts;
        this[_flushFlag] = opts.flush;
        this[_finishFlushFlag] = opts.finishFlush;
        try {
          this[_handle] = new realZlib[mode](opts);
        } catch (er) {
          throw new ZlibError(er);
        }
        this[_onError] = (err) => {
          if (this[_sawError])
            return;
          this[_sawError] = true;
          this.close();
          this.emit("error", err);
        };
        this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        this.once("end", () => this.close);
      }
      close() {
        if (this[_handle]) {
          this[_handle].close();
          this[_handle] = null;
          this.emit("close");
        }
      }
      reset() {
        if (!this[_sawError]) {
          assert2(this[_handle], "zlib binding closed");
          return this[_handle].reset();
        }
      }
      flush(flushFlag) {
        if (this.ended)
          return;
        if (typeof flushFlag !== "number")
          flushFlag = this[_fullFlushFlag];
        this.write(Object.assign(Buffer3.alloc(0), { [_flushFlag]: flushFlag }));
      }
      end(chunk, encoding2, cb) {
        if (chunk)
          this.write(chunk, encoding2);
        this.flush(this[_finishFlushFlag]);
        this[_ended] = true;
        return super.end(null, null, cb);
      }
      get ended() {
        return this[_ended];
      }
      write(chunk, encoding2, cb) {
        if (typeof encoding2 === "function")
          cb = encoding2, encoding2 = "utf8";
        if (typeof chunk === "string")
          chunk = Buffer3.from(chunk, encoding2);
        if (this[_sawError])
          return;
        assert2(this[_handle], "zlib binding closed");
        const nativeHandle = this[_handle]._handle;
        const originalNativeClose = nativeHandle.close;
        nativeHandle.close = () => {
        };
        const originalClose = this[_handle].close;
        this[_handle].close = () => {
        };
        Buffer3.concat = (args) => args;
        let result;
        try {
          const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
          result = this[_handle]._processChunk(chunk, flushFlag);
          Buffer3.concat = OriginalBufferConcat;
        } catch (err) {
          Buffer3.concat = OriginalBufferConcat;
          this[_onError](new ZlibError(err));
        } finally {
          if (this[_handle]) {
            this[_handle]._handle = nativeHandle;
            nativeHandle.close = originalNativeClose;
            this[_handle].close = originalClose;
            this[_handle].removeAllListeners("error");
          }
        }
        if (this[_handle])
          this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        let writeReturn;
        if (result) {
          if (Array.isArray(result) && result.length > 0) {
            writeReturn = this[_superWrite](Buffer3.from(result[0]));
            for (let i = 1; i < result.length; i++) {
              writeReturn = this[_superWrite](result[i]);
            }
          } else {
            writeReturn = this[_superWrite](Buffer3.from(result));
          }
        }
        if (cb)
          cb();
        return writeReturn;
      }
      [_superWrite](data) {
        return super.write(data);
      }
    };
    var Zlib = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.Z_NO_FLUSH;
        opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
        this[_level] = opts.level;
        this[_strategy] = opts.strategy;
      }
      params(level2, strategy) {
        if (this[_sawError])
          return;
        if (!this[_handle])
          throw new Error("cannot switch params when binding is closed");
        if (!this[_handle].params)
          throw new Error("not supported in this implementation");
        if (this[_level] !== level2 || this[_strategy] !== strategy) {
          this.flush(constants.Z_SYNC_FLUSH);
          assert2(this[_handle], "zlib binding closed");
          const origFlush = this[_handle].flush;
          this[_handle].flush = (flushFlag, cb) => {
            this.flush(flushFlag);
            cb();
          };
          try {
            this[_handle].params(level2, strategy);
          } finally {
            this[_handle].flush = origFlush;
          }
          if (this[_handle]) {
            this[_level] = level2;
            this[_strategy] = strategy;
          }
        }
      }
    };
    var Deflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Deflate");
      }
    };
    var Inflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Inflate");
      }
    };
    var _portable = Symbol("_portable");
    var Gzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gzip");
        this[_portable] = opts && !!opts.portable;
      }
      [_superWrite](data) {
        if (!this[_portable])
          return super[_superWrite](data);
        this[_portable] = false;
        data[9] = 255;
        return super[_superWrite](data);
      }
    };
    var Gunzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gunzip");
      }
    };
    var DeflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "DeflateRaw");
      }
    };
    var InflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "InflateRaw");
      }
    };
    var Unzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Unzip");
      }
    };
    var Brotli = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
        opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
      }
    };
    var BrotliCompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliCompress");
      }
    };
    var BrotliDecompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliDecompress");
      }
    };
    exports2.Deflate = Deflate;
    exports2.Inflate = Inflate;
    exports2.Gzip = Gzip;
    exports2.Gunzip = Gunzip;
    exports2.DeflateRaw = DeflateRaw;
    exports2.InflateRaw = InflateRaw;
    exports2.Unzip = Unzip;
    if (typeof realZlib.BrotliCompress === "function") {
      exports2.BrotliCompress = BrotliCompress;
      exports2.BrotliDecompress = BrotliDecompress;
    } else {
      exports2.BrotliCompress = exports2.BrotliDecompress = class {
        constructor() {
          throw new Error("Brotli is not supported in this version of Node.js");
        }
      };
    }
  }
});

// node_modules/tar/lib/normalize-windows-path.js
var require_normalize_windows_path = __commonJS({
  "node_modules/tar/lib/normalize-windows-path.js"(exports2, module2) {
    var platform2 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    module2.exports = platform2 !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");
  }
});

// node_modules/tar/lib/read-entry.js
var require_read_entry = __commonJS({
  "node_modules/tar/lib/read-entry.js"(exports2, module2) {
    "use strict";
    var { Minipass } = require_minipass();
    var normPath = require_normalize_windows_path();
    var SLURP = Symbol("slurp");
    module2.exports = class ReadEntry extends Minipass {
      constructor(header, ex, gex) {
        super();
        this.pause();
        this.extended = ex;
        this.globalExtended = gex;
        this.header = header;
        this.startBlockSize = 512 * Math.ceil(header.size / 512);
        this.blockRemain = this.startBlockSize;
        this.remain = header.size;
        this.type = header.type;
        this.meta = false;
        this.ignore = false;
        switch (this.type) {
          case "File":
          case "OldFile":
          case "Link":
          case "SymbolicLink":
          case "CharacterDevice":
          case "BlockDevice":
          case "Directory":
          case "FIFO":
          case "ContiguousFile":
          case "GNUDumpDir":
            break;
          case "NextFileHasLongLinkpath":
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
          case "GlobalExtendedHeader":
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this.meta = true;
            break;
          // NOTE: gnutar and bsdtar treat unrecognized types as 'File'
          // it may be worth doing the same, but with a warning.
          default:
            this.ignore = true;
        }
        this.path = normPath(header.path);
        this.mode = header.mode;
        if (this.mode) {
          this.mode = this.mode & 4095;
        }
        this.uid = header.uid;
        this.gid = header.gid;
        this.uname = header.uname;
        this.gname = header.gname;
        this.size = header.size;
        this.mtime = header.mtime;
        this.atime = header.atime;
        this.ctime = header.ctime;
        this.linkpath = normPath(header.linkpath);
        this.uname = header.uname;
        this.gname = header.gname;
        if (ex) {
          this[SLURP](ex);
        }
        if (gex) {
          this[SLURP](gex, true);
        }
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain) {
          throw new Error("writing more to entry than is appropriate");
        }
        const r = this.remain;
        const br = this.blockRemain;
        this.remain = Math.max(0, r - writeLen);
        this.blockRemain = Math.max(0, br - writeLen);
        if (this.ignore) {
          return true;
        }
        if (r >= writeLen) {
          return super.write(data);
        }
        return super.write(data.slice(0, r));
      }
      [SLURP](ex, global2) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path")) {
            this[k] = k === "path" || k === "linkpath" ? normPath(ex[k]) : ex[k];
          }
        }
      }
    };
  }
});

// node_modules/tar/lib/types.js
var require_types2 = __commonJS({
  "node_modules/tar/lib/types.js"(exports2) {
    "use strict";
    exports2.name = /* @__PURE__ */ new Map([
      ["0", "File"],
      // same as File
      ["", "OldFile"],
      ["1", "Link"],
      ["2", "SymbolicLink"],
      // Devices and FIFOs aren't fully supported
      // they are parsed, but skipped when unpacking
      ["3", "CharacterDevice"],
      ["4", "BlockDevice"],
      ["5", "Directory"],
      ["6", "FIFO"],
      // same as File
      ["7", "ContiguousFile"],
      // pax headers
      ["g", "GlobalExtendedHeader"],
      ["x", "ExtendedHeader"],
      // vendor-specific stuff
      // skip
      ["A", "SolarisACL"],
      // like 5, but with data, which should be skipped
      ["D", "GNUDumpDir"],
      // metadata only, skip
      ["I", "Inode"],
      // data = link path of next file
      ["K", "NextFileHasLongLinkpath"],
      // data = path of next file
      ["L", "NextFileHasLongPath"],
      // skip
      ["M", "ContinuationFile"],
      // like L
      ["N", "OldGnuLongPath"],
      // skip
      ["S", "SparseFile"],
      // skip
      ["V", "TapeVolumeHeader"],
      // like x
      ["X", "OldExtendedHeader"]
    ]);
    exports2.code = new Map(Array.from(exports2.name).map((kv) => [kv[1], kv[0]]));
  }
});

// node_modules/tar/lib/large-numbers.js
var require_large_numbers = __commonJS({
  "node_modules/tar/lib/large-numbers.js"(exports2, module2) {
    "use strict";
    var encode = (num, buf) => {
      if (!Number.isSafeInteger(num)) {
        throw Error("cannot encode number outside of javascript safe integer range");
      } else if (num < 0) {
        encodeNegative(num, buf);
      } else {
        encodePositive(num, buf);
      }
      return buf;
    };
    var encodePositive = (num, buf) => {
      buf[0] = 128;
      for (var i = buf.length; i > 1; i--) {
        buf[i - 1] = num & 255;
        num = Math.floor(num / 256);
      }
    };
    var encodeNegative = (num, buf) => {
      buf[0] = 255;
      var flipped = false;
      num = num * -1;
      for (var i = buf.length; i > 1; i--) {
        var byte = num & 255;
        num = Math.floor(num / 256);
        if (flipped) {
          buf[i - 1] = onesComp(byte);
        } else if (byte === 0) {
          buf[i - 1] = 0;
        } else {
          flipped = true;
          buf[i - 1] = twosComp(byte);
        }
      }
    };
    var parse3 = (buf) => {
      const pre = buf[0];
      const value = pre === 128 ? pos(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
      if (value === null) {
        throw Error("invalid base256 encoding");
      }
      if (!Number.isSafeInteger(value)) {
        throw Error("parsed number outside of javascript safe integer range");
      }
      return value;
    };
    var twos = (buf) => {
      var len = buf.length;
      var sum = 0;
      var flipped = false;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        var f;
        if (flipped) {
          f = onesComp(byte);
        } else if (byte === 0) {
          f = byte;
        } else {
          flipped = true;
          f = twosComp(byte);
        }
        if (f !== 0) {
          sum -= f * Math.pow(256, len - i - 1);
        }
      }
      return sum;
    };
    var pos = (buf) => {
      var len = buf.length;
      var sum = 0;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        if (byte !== 0) {
          sum += byte * Math.pow(256, len - i - 1);
        }
      }
      return sum;
    };
    var onesComp = (byte) => (255 ^ byte) & 255;
    var twosComp = (byte) => (255 ^ byte) + 1 & 255;
    module2.exports = {
      encode,
      parse: parse3
    };
  }
});

// node_modules/tar/lib/header.js
var require_header = __commonJS({
  "node_modules/tar/lib/header.js"(exports2, module2) {
    "use strict";
    var types = require_types2();
    var pathModule = require("path").posix;
    var large = require_large_numbers();
    var SLURP = Symbol("slurp");
    var TYPE = Symbol("type");
    var Header = class {
      constructor(data, off, ex, gex) {
        this.cksumValid = false;
        this.needPax = false;
        this.nullBlock = false;
        this.block = null;
        this.path = null;
        this.mode = null;
        this.uid = null;
        this.gid = null;
        this.size = null;
        this.mtime = null;
        this.cksum = null;
        this[TYPE] = "0";
        this.linkpath = null;
        this.uname = null;
        this.gname = null;
        this.devmaj = 0;
        this.devmin = 0;
        this.atime = null;
        this.ctime = null;
        if (Buffer.isBuffer(data)) {
          this.decode(data, off || 0, ex, gex);
        } else if (data) {
          this.set(data);
        }
      }
      decode(buf, off, ex, gex) {
        if (!off) {
          off = 0;
        }
        if (!buf || !(buf.length >= off + 512)) {
          throw new Error("need 512 bytes for header");
        }
        this.path = decString(buf, off, 100);
        this.mode = decNumber(buf, off + 100, 8);
        this.uid = decNumber(buf, off + 108, 8);
        this.gid = decNumber(buf, off + 116, 8);
        this.size = decNumber(buf, off + 124, 12);
        this.mtime = decDate(buf, off + 136, 12);
        this.cksum = decNumber(buf, off + 148, 12);
        this[SLURP](ex);
        this[SLURP](gex, true);
        this[TYPE] = decString(buf, off + 156, 1);
        if (this[TYPE] === "") {
          this[TYPE] = "0";
        }
        if (this[TYPE] === "0" && this.path.slice(-1) === "/") {
          this[TYPE] = "5";
        }
        if (this[TYPE] === "5") {
          this.size = 0;
        }
        this.linkpath = decString(buf, off + 157, 100);
        if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
          this.uname = decString(buf, off + 265, 32);
          this.gname = decString(buf, off + 297, 32);
          this.devmaj = decNumber(buf, off + 329, 8);
          this.devmin = decNumber(buf, off + 337, 8);
          if (buf[off + 475] !== 0) {
            const prefix = decString(buf, off + 345, 155);
            this.path = prefix + "/" + this.path;
          } else {
            const prefix = decString(buf, off + 345, 130);
            if (prefix) {
              this.path = prefix + "/" + this.path;
            }
            this.atime = decDate(buf, off + 476, 12);
            this.ctime = decDate(buf, off + 488, 12);
          }
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++) {
          sum += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
          sum += buf[i];
        }
        this.cksumValid = sum === this.cksum;
        if (this.cksum === null && sum === 8 * 32) {
          this.nullBlock = true;
        }
      }
      [SLURP](ex, global2) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path")) {
            this[k] = ex[k];
          }
        }
      }
      encode(buf, off) {
        if (!buf) {
          buf = this.block = Buffer.alloc(512);
          off = 0;
        }
        if (!off) {
          off = 0;
        }
        if (!(buf.length >= off + 512)) {
          throw new Error("need 512 bytes for header");
        }
        const prefixSize = this.ctime || this.atime ? 130 : 155;
        const split = splitPrefix(this.path || "", prefixSize);
        const path2 = split[0];
        const prefix = split[1];
        this.needPax = split[2];
        this.needPax = encString(buf, off, 100, path2) || this.needPax;
        this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
        this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
        this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
        this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
        this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
        buf[off + 156] = this[TYPE].charCodeAt(0);
        this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
        buf.write("ustar\x0000", off + 257, 8);
        this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
        this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
        this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
        this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
        this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
        if (buf[off + 475] !== 0) {
          this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
        } else {
          this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
          this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
          this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++) {
          sum += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
          sum += buf[i];
        }
        this.cksum = sum;
        encNumber(buf, off + 148, 8, this.cksum);
        this.cksumValid = true;
        return this.needPax;
      }
      set(data) {
        for (const i in data) {
          if (data[i] !== null && data[i] !== void 0) {
            this[i] = data[i];
          }
        }
      }
      get type() {
        return types.name.get(this[TYPE]) || this[TYPE];
      }
      get typeKey() {
        return this[TYPE];
      }
      set type(type) {
        if (types.code.has(type)) {
          this[TYPE] = types.code.get(type);
        } else {
          this[TYPE] = type;
        }
      }
    };
    var splitPrefix = (p, prefixSize) => {
      const pathSize = 100;
      let pp = p;
      let prefix = "";
      let ret;
      const root = pathModule.parse(p).root || ".";
      if (Buffer.byteLength(pp) < pathSize) {
        ret = [pp, prefix, false];
      } else {
        prefix = pathModule.dirname(pp);
        pp = pathModule.basename(pp);
        do {
          if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize) {
            ret = [pp, prefix, false];
          } else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize) {
            ret = [pp.slice(0, pathSize - 1), prefix, true];
          } else {
            pp = pathModule.join(pathModule.basename(prefix), pp);
            prefix = pathModule.dirname(prefix);
          }
        } while (prefix !== root && !ret);
        if (!ret) {
          ret = [p.slice(0, pathSize - 1), "", true];
        }
      }
      return ret;
    };
    var decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
    var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
    var numToDate = (num) => num === null ? null : new Date(num * 1e3);
    var decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
    var nanNull = (value) => isNaN(value) ? null : value;
    var decSmallNumber = (buf, off, size) => nanNull(parseInt(
      buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(),
      8
    ));
    var MAXNUM = {
      12: 8589934591,
      8: 2097151
    };
    var encNumber = (buf, off, size, number2) => number2 === null ? false : number2 > MAXNUM[size] || number2 < 0 ? (large.encode(number2, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number2), false);
    var encSmallNumber = (buf, off, size, number2) => buf.write(octalString(number2, size), off, size, "ascii");
    var octalString = (number2, size) => padOctal(Math.floor(number2).toString(8), size);
    var padOctal = (string2, size) => (string2.length === size - 1 ? string2 : new Array(size - string2.length - 1).join("0") + string2 + " ") + "\0";
    var encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1e3);
    var NULLS = new Array(156).join("\0");
    var encString = (buf, off, size, string2) => string2 === null ? false : (buf.write(string2 + NULLS, off, size, "utf8"), string2.length !== Buffer.byteLength(string2) || string2.length > size);
    module2.exports = Header;
  }
});

// node_modules/tar/lib/pax.js
var require_pax = __commonJS({
  "node_modules/tar/lib/pax.js"(exports2, module2) {
    "use strict";
    var Header = require_header();
    var path2 = require("path");
    var Pax = class {
      constructor(obj, global2) {
        this.atime = obj.atime || null;
        this.charset = obj.charset || null;
        this.comment = obj.comment || null;
        this.ctime = obj.ctime || null;
        this.gid = obj.gid || null;
        this.gname = obj.gname || null;
        this.linkpath = obj.linkpath || null;
        this.mtime = obj.mtime || null;
        this.path = obj.path || null;
        this.size = obj.size || null;
        this.uid = obj.uid || null;
        this.uname = obj.uname || null;
        this.dev = obj.dev || null;
        this.ino = obj.ino || null;
        this.nlink = obj.nlink || null;
        this.global = global2 || false;
      }
      encode() {
        const body = this.encodeBody();
        if (body === "") {
          return null;
        }
        const bodyLen = Buffer.byteLength(body);
        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
        const buf = Buffer.allocUnsafe(bufLen);
        for (let i = 0; i < 512; i++) {
          buf[i] = 0;
        }
        new Header({
          // XXX split the path
          // then the path should be PaxHeader + basename, but less than 99,
          // prepend with the dirname
          path: ("PaxHeader/" + path2.basename(this.path)).slice(0, 99),
          mode: this.mode || 420,
          uid: this.uid || null,
          gid: this.gid || null,
          size: bodyLen,
          mtime: this.mtime || null,
          type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
          linkpath: "",
          uname: this.uname || "",
          gname: this.gname || "",
          devmaj: 0,
          devmin: 0,
          atime: this.atime || null,
          ctime: this.ctime || null
        }).encode(buf);
        buf.write(body, 512, bodyLen, "utf8");
        for (let i = bodyLen + 512; i < buf.length; i++) {
          buf[i] = 0;
        }
        return buf;
      }
      encodeBody() {
        return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
      }
      encodeField(field) {
        if (this[field] === null || this[field] === void 0) {
          return "";
        }
        const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
        const s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
        const byteLen = Buffer.byteLength(s);
        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
        if (byteLen + digits >= Math.pow(10, digits)) {
          digits += 1;
        }
        const len = digits + byteLen;
        return len + s;
      }
    };
    Pax.parse = (string2, ex, g) => new Pax(merge(parseKV(string2), ex), g);
    var merge = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a;
    var parseKV = (string2) => string2.replace(/\n$/, "").split("\n").reduce(parseKVLine, /* @__PURE__ */ Object.create(null));
    var parseKVLine = (set, line) => {
      const n = parseInt(line, 10);
      if (n !== Buffer.byteLength(line) + 1) {
        return set;
      }
      line = line.slice((n + " ").length);
      const kv = line.split("=");
      const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
      if (!k) {
        return set;
      }
      const v = kv.join("=");
      set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
      return set;
    };
    module2.exports = Pax;
  }
});

// node_modules/tar/lib/strip-trailing-slashes.js
var require_strip_trailing_slashes = __commonJS({
  "node_modules/tar/lib/strip-trailing-slashes.js"(exports2, module2) {
    module2.exports = (str) => {
      let i = str.length - 1;
      let slashesStart = -1;
      while (i > -1 && str.charAt(i) === "/") {
        slashesStart = i;
        i--;
      }
      return slashesStart === -1 ? str : str.slice(0, slashesStart);
    };
  }
});

// node_modules/tar/lib/warn-mixin.js
var require_warn_mixin = __commonJS({
  "node_modules/tar/lib/warn-mixin.js"(exports2, module2) {
    "use strict";
    module2.exports = (Base) => class extends Base {
      warn(code, message, data = {}) {
        if (this.file) {
          data.file = this.file;
        }
        if (this.cwd) {
          data.cwd = this.cwd;
        }
        data.code = message instanceof Error && message.code || code;
        data.tarCode = code;
        if (!this.strict && data.recoverable !== false) {
          if (message instanceof Error) {
            data = Object.assign(message, data);
            message = message.message;
          }
          this.emit("warn", data.tarCode, message, data);
        } else if (message instanceof Error) {
          this.emit("error", Object.assign(message, data));
        } else {
          this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
        }
      }
    };
  }
});

// node_modules/tar/lib/winchars.js
var require_winchars = __commonJS({
  "node_modules/tar/lib/winchars.js"(exports2, module2) {
    "use strict";
    var raw = [
      "|",
      "<",
      ">",
      "?",
      ":"
    ];
    var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
    var toWin = new Map(raw.map((char, i) => [char, win[i]]));
    var toRaw = new Map(win.map((char, i) => [char, raw[i]]));
    module2.exports = {
      encode: (s) => raw.reduce((s2, c) => s2.split(c).join(toWin.get(c)), s),
      decode: (s) => win.reduce((s2, c) => s2.split(c).join(toRaw.get(c)), s)
    };
  }
});

// node_modules/tar/lib/strip-absolute-path.js
var require_strip_absolute_path = __commonJS({
  "node_modules/tar/lib/strip-absolute-path.js"(exports2, module2) {
    var { isAbsolute, parse: parse3 } = require("path").win32;
    module2.exports = (path2) => {
      let r = "";
      let parsed = parse3(path2);
      while (isAbsolute(path2) || parsed.root) {
        const root = path2.charAt(0) === "/" && path2.slice(0, 4) !== "//?/" ? "/" : parsed.root;
        path2 = path2.slice(root.length);
        r += root;
        parsed = parse3(path2);
      }
      return [r, path2];
    };
  }
});

// node_modules/tar/lib/mode-fix.js
var require_mode_fix = __commonJS({
  "node_modules/tar/lib/mode-fix.js"(exports2, module2) {
    "use strict";
    module2.exports = (mode, isDir, portable) => {
      mode &= 4095;
      if (portable) {
        mode = (mode | 384) & ~18;
      }
      if (isDir) {
        if (mode & 256) {
          mode |= 64;
        }
        if (mode & 32) {
          mode |= 8;
        }
        if (mode & 4) {
          mode |= 1;
        }
      }
      return mode;
    };
  }
});

// node_modules/tar/lib/write-entry.js
var require_write_entry = __commonJS({
  "node_modules/tar/lib/write-entry.js"(exports2, module2) {
    "use strict";
    var { Minipass } = require_minipass();
    var Pax = require_pax();
    var Header = require_header();
    var fs2 = require("fs");
    var path2 = require("path");
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var prefixPath = (path3, prefix) => {
      if (!prefix) {
        return normPath(path3);
      }
      path3 = normPath(path3).replace(/^\.(\/|$)/, "");
      return stripSlash(prefix) + "/" + path3;
    };
    var maxReadSize = 16 * 1024 * 1024;
    var PROCESS = Symbol("process");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var HEADER = Symbol("header");
    var READ = Symbol("read");
    var LSTAT = Symbol("lstat");
    var ONLSTAT = Symbol("onlstat");
    var ONREAD = Symbol("onread");
    var ONREADLINK = Symbol("onreadlink");
    var OPENFILE = Symbol("openfile");
    var ONOPENFILE = Symbol("onopenfile");
    var CLOSE = Symbol("close");
    var MODE = Symbol("mode");
    var AWAITDRAIN = Symbol("awaitDrain");
    var ONDRAIN = Symbol("ondrain");
    var PREFIX = Symbol("prefix");
    var HAD_ERROR = Symbol("hadError");
    var warner = require_warn_mixin();
    var winchars = require_winchars();
    var stripAbsolutePath = require_strip_absolute_path();
    var modeFix = require_mode_fix();
    var WriteEntry = warner(class WriteEntry extends Minipass {
      constructor(p, opt) {
        opt = opt || {};
        super(opt);
        if (typeof p !== "string") {
          throw new TypeError("path is required");
        }
        this.path = normPath(p);
        this.portable = !!opt.portable;
        this.myuid = process.getuid && process.getuid() || 0;
        this.myuser = process.env.USER || "";
        this.maxReadSize = opt.maxReadSize || maxReadSize;
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.preservePaths = !!opt.preservePaths;
        this.cwd = normPath(opt.cwd || process.cwd());
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.prefix = opt.prefix ? normPath(opt.prefix) : null;
        this.fd = null;
        this.blockLen = null;
        this.blockRemain = null;
        this.buf = null;
        this.offset = null;
        this.length = null;
        this.pos = null;
        this.remain = null;
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.win32 = !!opt.win32 || process.platform === "win32";
        if (this.win32) {
          this.path = winchars.decode(this.path.replace(/\\/g, "/"));
          p = p.replace(/\\/g, "/");
        }
        this.absolute = normPath(opt.absolute || path2.resolve(this.cwd, p));
        if (this.path === "") {
          this.path = "./";
        }
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.statCache.has(this.absolute)) {
          this[ONLSTAT](this.statCache.get(this.absolute));
        } else {
          this[LSTAT]();
        }
      }
      emit(ev, ...data) {
        if (ev === "error") {
          this[HAD_ERROR] = true;
        }
        return super.emit(ev, ...data);
      }
      [LSTAT]() {
        fs2.lstat(this.absolute, (er, stat) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONLSTAT](stat);
        });
      }
      [ONLSTAT](stat) {
        this.statCache.set(this.absolute, stat);
        this.stat = stat;
        if (!stat.isFile()) {
          stat.size = 0;
        }
        this.type = getType(stat);
        this.emit("stat", stat);
        this[PROCESS]();
      }
      [PROCESS]() {
        switch (this.type) {
          case "File":
            return this[FILE]();
          case "Directory":
            return this[DIRECTORY]();
          case "SymbolicLink":
            return this[SYMLINK]();
          // unsupported types are ignored.
          default:
            return this.end();
        }
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      [PREFIX](path3) {
        return prefixPath(path3, this.prefix);
      }
      [HEADER]() {
        if (this.type === "Directory" && this.portable) {
          this.noMtime = true;
        }
        this.header = new Header({
          path: this[PREFIX](this.path),
          // only apply the prefix to hard links.
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          // only the permissions and setuid/setgid/sticky bitflags
          // not the higher-order bits that specify file type
          mode: this[MODE](this.stat.mode),
          uid: this.portable ? null : this.stat.uid,
          gid: this.portable ? null : this.stat.gid,
          size: this.stat.size,
          mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
          type: this.type,
          uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
          atime: this.portable ? null : this.stat.atime,
          ctime: this.portable ? null : this.stat.ctime
        });
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.header.atime,
            ctime: this.portable ? null : this.header.ctime,
            gid: this.portable ? null : this.header.gid,
            mtime: this.noMtime ? null : this.mtime || this.header.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.header.size,
            uid: this.portable ? null : this.header.uid,
            uname: this.portable ? null : this.header.uname,
            dev: this.portable ? null : this.stat.dev,
            ino: this.portable ? null : this.stat.ino,
            nlink: this.portable ? null : this.stat.nlink
          }).encode());
        }
        super.write(this.header.block);
      }
      [DIRECTORY]() {
        if (this.path.slice(-1) !== "/") {
          this.path += "/";
        }
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [SYMLINK]() {
        fs2.readlink(this.absolute, (er, linkpath) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONREADLINK](linkpath);
        });
      }
      [ONREADLINK](linkpath) {
        this.linkpath = normPath(linkpath);
        this[HEADER]();
        this.end();
      }
      [HARDLINK](linkpath) {
        this.type = "Link";
        this.linkpath = normPath(path2.relative(this.cwd, linkpath));
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [FILE]() {
        if (this.stat.nlink > 1) {
          const linkKey = this.stat.dev + ":" + this.stat.ino;
          if (this.linkCache.has(linkKey)) {
            const linkpath = this.linkCache.get(linkKey);
            if (linkpath.indexOf(this.cwd) === 0) {
              return this[HARDLINK](linkpath);
            }
          }
          this.linkCache.set(linkKey, this.absolute);
        }
        this[HEADER]();
        if (this.stat.size === 0) {
          return this.end();
        }
        this[OPENFILE]();
      }
      [OPENFILE]() {
        fs2.open(this.absolute, "r", (er, fd) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONOPENFILE](fd);
        });
      }
      [ONOPENFILE](fd) {
        this.fd = fd;
        if (this[HAD_ERROR]) {
          return this[CLOSE]();
        }
        this.blockLen = 512 * Math.ceil(this.stat.size / 512);
        this.blockRemain = this.blockLen;
        const bufLen = Math.min(this.blockLen, this.maxReadSize);
        this.buf = Buffer.allocUnsafe(bufLen);
        this.offset = 0;
        this.pos = 0;
        this.remain = this.stat.size;
        this.length = this.buf.length;
        this[READ]();
      }
      [READ]() {
        const { fd, buf, offset, length, pos } = this;
        fs2.read(fd, buf, offset, length, pos, (er, bytesRead) => {
          if (er) {
            return this[CLOSE](() => this.emit("error", er));
          }
          this[ONREAD](bytesRead);
        });
      }
      [CLOSE](cb) {
        fs2.close(this.fd, cb);
      }
      [ONREAD](bytesRead) {
        if (bytesRead <= 0 && this.remain > 0) {
          const er = new Error("encountered unexpected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead > this.remain) {
          const er = new Error("did not encounter expected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead === this.remain) {
          for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
            this.buf[i + this.offset] = 0;
            bytesRead++;
            this.remain++;
          }
        }
        const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
        const flushed = this.write(writeBuf);
        if (!flushed) {
          this[AWAITDRAIN](() => this[ONDRAIN]());
        } else {
          this[ONDRAIN]();
        }
      }
      [AWAITDRAIN](cb) {
        this.once("drain", cb);
      }
      write(writeBuf) {
        if (this.blockRemain < writeBuf.length) {
          const er = new Error("writing more data than expected");
          er.path = this.absolute;
          return this.emit("error", er);
        }
        this.remain -= writeBuf.length;
        this.blockRemain -= writeBuf.length;
        this.pos += writeBuf.length;
        this.offset += writeBuf.length;
        return super.write(writeBuf);
      }
      [ONDRAIN]() {
        if (!this.remain) {
          if (this.blockRemain) {
            super.write(Buffer.alloc(this.blockRemain));
          }
          return this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
        }
        if (this.offset >= this.length) {
          this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
          this.offset = 0;
        }
        this.length = this.buf.length - this.offset;
        this[READ]();
      }
    });
    var WriteEntrySync = class extends WriteEntry {
      [LSTAT]() {
        this[ONLSTAT](fs2.lstatSync(this.absolute));
      }
      [SYMLINK]() {
        this[ONREADLINK](fs2.readlinkSync(this.absolute));
      }
      [OPENFILE]() {
        this[ONOPENFILE](fs2.openSync(this.absolute, "r"));
      }
      [READ]() {
        let threw = true;
        try {
          const { fd, buf, offset, length, pos } = this;
          const bytesRead = fs2.readSync(fd, buf, offset, length, pos);
          this[ONREAD](bytesRead);
          threw = false;
        } finally {
          if (threw) {
            try {
              this[CLOSE](() => {
              });
            } catch (er) {
            }
          }
        }
      }
      [AWAITDRAIN](cb) {
        cb();
      }
      [CLOSE](cb) {
        fs2.closeSync(this.fd);
        cb();
      }
    };
    var WriteEntryTar = warner(class WriteEntryTar extends Minipass {
      constructor(readEntry, opt) {
        opt = opt || {};
        super(opt);
        this.preservePaths = !!opt.preservePaths;
        this.portable = !!opt.portable;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.readEntry = readEntry;
        this.type = readEntry.type;
        if (this.type === "Directory" && this.portable) {
          this.noMtime = true;
        }
        this.prefix = opt.prefix || null;
        this.path = normPath(readEntry.path);
        this.mode = this[MODE](readEntry.mode);
        this.uid = this.portable ? null : readEntry.uid;
        this.gid = this.portable ? null : readEntry.gid;
        this.uname = this.portable ? null : readEntry.uname;
        this.gname = this.portable ? null : readEntry.gname;
        this.size = readEntry.size;
        this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
        this.atime = this.portable ? null : readEntry.atime;
        this.ctime = this.portable ? null : readEntry.ctime;
        this.linkpath = normPath(readEntry.linkpath);
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.remain = readEntry.size;
        this.blockRemain = readEntry.startBlockSize;
        this.header = new Header({
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          // only the permissions and setuid/setgid/sticky bitflags
          // not the higher-order bits that specify file type
          mode: this.mode,
          uid: this.portable ? null : this.uid,
          gid: this.portable ? null : this.gid,
          size: this.size,
          mtime: this.noMtime ? null : this.mtime,
          type: this.type,
          uname: this.portable ? null : this.uname,
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime
        });
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.atime,
            ctime: this.portable ? null : this.ctime,
            gid: this.portable ? null : this.gid,
            mtime: this.noMtime ? null : this.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.size,
            uid: this.portable ? null : this.uid,
            uname: this.portable ? null : this.uname,
            dev: this.portable ? null : this.readEntry.dev,
            ino: this.portable ? null : this.readEntry.ino,
            nlink: this.portable ? null : this.readEntry.nlink
          }).encode());
        }
        super.write(this.header.block);
        readEntry.pipe(this);
      }
      [PREFIX](path3) {
        return prefixPath(path3, this.prefix);
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain) {
          throw new Error("writing more to entry than is appropriate");
        }
        this.blockRemain -= writeLen;
        return super.write(data);
      }
      end() {
        if (this.blockRemain) {
          super.write(Buffer.alloc(this.blockRemain));
        }
        return super.end();
      }
    });
    WriteEntry.Sync = WriteEntrySync;
    WriteEntry.Tar = WriteEntryTar;
    var getType = (stat) => stat.isFile() ? "File" : stat.isDirectory() ? "Directory" : stat.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
    module2.exports = WriteEntry;
  }
});

// node_modules/tar/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/tar/node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/tar/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/tar/node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list2) {
      var self = this;
      if (!(self instanceof Yallist)) {
        self = new Yallist();
      }
      self.tail = null;
      self.head = null;
      self.length = 0;
      if (list2 && typeof list2.forEach === "function") {
        list2.forEach(function(item) {
          self.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self.push(arguments[i]);
        }
      }
      return self;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self, node, value) {
      var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
      if (inserted.next === null) {
        self.tail = inserted;
      }
      if (inserted.prev === null) {
        self.head = inserted;
      }
      self.length++;
      return inserted;
    }
    function push(self, item) {
      self.tail = new Node(item, self.tail, null, self);
      if (!self.head) {
        self.head = self.tail;
      }
      self.length++;
    }
    function unshift(self, item) {
      self.head = new Node(item, null, self.head, self);
      if (!self.tail) {
        self.tail = self.head;
      }
      self.length++;
    }
    function Node(value, prev, next, list2) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list2);
      }
      this.list = list2;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/tar/lib/pack.js
var require_pack = __commonJS({
  "node_modules/tar/lib/pack.js"(exports2, module2) {
    "use strict";
    var PackJob = class {
      constructor(path3, absolute) {
        this.path = path3 || "./";
        this.absolute = absolute;
        this.entry = null;
        this.stat = null;
        this.readdir = null;
        this.pending = false;
        this.ignore = false;
        this.piped = false;
      }
    };
    var { Minipass } = require_minipass();
    var zlib = require_minizlib();
    var ReadEntry = require_read_entry();
    var WriteEntry = require_write_entry();
    var WriteEntrySync = WriteEntry.Sync;
    var WriteEntryTar = WriteEntry.Tar;
    var Yallist = require_yallist();
    var EOF = Buffer.alloc(1024);
    var ONSTAT = Symbol("onStat");
    var ENDED = Symbol("ended");
    var QUEUE = Symbol("queue");
    var CURRENT = Symbol("current");
    var PROCESS = Symbol("process");
    var PROCESSING = Symbol("processing");
    var PROCESSJOB = Symbol("processJob");
    var JOBS = Symbol("jobs");
    var JOBDONE = Symbol("jobDone");
    var ADDFSENTRY = Symbol("addFSEntry");
    var ADDTARENTRY = Symbol("addTarEntry");
    var STAT = Symbol("stat");
    var READDIR = Symbol("readdir");
    var ONREADDIR = Symbol("onreaddir");
    var PIPE = Symbol("pipe");
    var ENTRY = Symbol("entry");
    var ENTRYOPT = Symbol("entryOpt");
    var WRITEENTRYCLASS = Symbol("writeEntryClass");
    var WRITE = Symbol("write");
    var ONDRAIN = Symbol("ondrain");
    var fs2 = require("fs");
    var path2 = require("path");
    var warner = require_warn_mixin();
    var normPath = require_normalize_windows_path();
    var Pack = warner(class Pack extends Minipass {
      constructor(opt) {
        super(opt);
        opt = opt || /* @__PURE__ */ Object.create(null);
        this.opt = opt;
        this.file = opt.file || "";
        this.cwd = opt.cwd || process.cwd();
        this.maxReadSize = opt.maxReadSize;
        this.preservePaths = !!opt.preservePaths;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.prefix = normPath(opt.prefix || "");
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.readdirCache = opt.readdirCache || /* @__PURE__ */ new Map();
        this[WRITEENTRYCLASS] = WriteEntry;
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        this.portable = !!opt.portable;
        this.zip = null;
        if (opt.gzip || opt.brotli) {
          if (opt.gzip && opt.brotli) {
            throw new TypeError("gzip and brotli are mutually exclusive");
          }
          if (opt.gzip) {
            if (typeof opt.gzip !== "object") {
              opt.gzip = {};
            }
            if (this.portable) {
              opt.gzip.portable = true;
            }
            this.zip = new zlib.Gzip(opt.gzip);
          }
          if (opt.brotli) {
            if (typeof opt.brotli !== "object") {
              opt.brotli = {};
            }
            this.zip = new zlib.BrotliCompress(opt.brotli);
          }
          this.zip.on("data", (chunk) => super.write(chunk));
          this.zip.on("end", (_) => super.end());
          this.zip.on("drain", (_) => this[ONDRAIN]());
          this.on("resume", (_) => this.zip.resume());
        } else {
          this.on("drain", this[ONDRAIN]);
        }
        this.noDirRecurse = !!opt.noDirRecurse;
        this.follow = !!opt.follow;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;
        this[QUEUE] = new Yallist();
        this[JOBS] = 0;
        this.jobs = +opt.jobs || 4;
        this[PROCESSING] = false;
        this[ENDED] = false;
      }
      [WRITE](chunk) {
        return super.write(chunk);
      }
      add(path3) {
        this.write(path3);
        return this;
      }
      end(path3) {
        if (path3) {
          this.write(path3);
        }
        this[ENDED] = true;
        this[PROCESS]();
        return this;
      }
      write(path3) {
        if (this[ENDED]) {
          throw new Error("write after end");
        }
        if (path3 instanceof ReadEntry) {
          this[ADDTARENTRY](path3);
        } else {
          this[ADDFSENTRY](path3);
        }
        return this.flowing;
      }
      [ADDTARENTRY](p) {
        const absolute = normPath(path2.resolve(this.cwd, p.path));
        if (!this.filter(p.path, p)) {
          p.resume();
        } else {
          const job = new PackJob(p.path, absolute, false);
          job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
          job.entry.on("end", (_) => this[JOBDONE](job));
          this[JOBS] += 1;
          this[QUEUE].push(job);
        }
        this[PROCESS]();
      }
      [ADDFSENTRY](p) {
        const absolute = normPath(path2.resolve(this.cwd, p));
        this[QUEUE].push(new PackJob(p, absolute));
        this[PROCESS]();
      }
      [STAT](job) {
        job.pending = true;
        this[JOBS] += 1;
        const stat = this.follow ? "stat" : "lstat";
        fs2[stat](job.absolute, (er, stat2) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er) {
            this.emit("error", er);
          } else {
            this[ONSTAT](job, stat2);
          }
        });
      }
      [ONSTAT](job, stat) {
        this.statCache.set(job.absolute, stat);
        job.stat = stat;
        if (!this.filter(job.path, stat)) {
          job.ignore = true;
        }
        this[PROCESS]();
      }
      [READDIR](job) {
        job.pending = true;
        this[JOBS] += 1;
        fs2.readdir(job.absolute, (er, entries) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er) {
            return this.emit("error", er);
          }
          this[ONREADDIR](job, entries);
        });
      }
      [ONREADDIR](job, entries) {
        this.readdirCache.set(job.absolute, entries);
        job.readdir = entries;
        this[PROCESS]();
      }
      [PROCESS]() {
        if (this[PROCESSING]) {
          return;
        }
        this[PROCESSING] = true;
        for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {
          this[PROCESSJOB](w.value);
          if (w.value.ignore) {
            const p = w.next;
            this[QUEUE].removeNode(w);
            w.next = p;
          }
        }
        this[PROCESSING] = false;
        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
          if (this.zip) {
            this.zip.end(EOF);
          } else {
            super.write(EOF);
            super.end();
          }
        }
      }
      get [CURRENT]() {
        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
      }
      [JOBDONE](job) {
        this[QUEUE].shift();
        this[JOBS] -= 1;
        this[PROCESS]();
      }
      [PROCESSJOB](job) {
        if (job.pending) {
          return;
        }
        if (job.entry) {
          if (job === this[CURRENT] && !job.piped) {
            this[PIPE](job);
          }
          return;
        }
        if (!job.stat) {
          if (this.statCache.has(job.absolute)) {
            this[ONSTAT](job, this.statCache.get(job.absolute));
          } else {
            this[STAT](job);
          }
        }
        if (!job.stat) {
          return;
        }
        if (job.ignore) {
          return;
        }
        if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
          if (this.readdirCache.has(job.absolute)) {
            this[ONREADDIR](job, this.readdirCache.get(job.absolute));
          } else {
            this[READDIR](job);
          }
          if (!job.readdir) {
            return;
          }
        }
        job.entry = this[ENTRY](job);
        if (!job.entry) {
          job.ignore = true;
          return;
        }
        if (job === this[CURRENT] && !job.piped) {
          this[PIPE](job);
        }
      }
      [ENTRYOPT](job) {
        return {
          onwarn: (code, msg, data) => this.warn(code, msg, data),
          noPax: this.noPax,
          cwd: this.cwd,
          absolute: job.absolute,
          preservePaths: this.preservePaths,
          maxReadSize: this.maxReadSize,
          strict: this.strict,
          portable: this.portable,
          linkCache: this.linkCache,
          statCache: this.statCache,
          noMtime: this.noMtime,
          mtime: this.mtime,
          prefix: this.prefix
        };
      }
      [ENTRY](job) {
        this[JOBS] += 1;
        try {
          return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
        } catch (er) {
          this.emit("error", er);
        }
      }
      [ONDRAIN]() {
        if (this[CURRENT] && this[CURRENT].entry) {
          this[CURRENT].entry.resume();
        }
      }
      // like .pipe() but using super, because our write() is special
      [PIPE](job) {
        job.piped = true;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        const source = job.entry;
        const zip = this.zip;
        if (zip) {
          source.on("data", (chunk) => {
            if (!zip.write(chunk)) {
              source.pause();
            }
          });
        } else {
          source.on("data", (chunk) => {
            if (!super.write(chunk)) {
              source.pause();
            }
          });
        }
      }
      pause() {
        if (this.zip) {
          this.zip.pause();
        }
        return super.pause();
      }
    });
    var PackSync = class extends Pack {
      constructor(opt) {
        super(opt);
        this[WRITEENTRYCLASS] = WriteEntrySync;
      }
      // pause/resume are no-ops in sync streams.
      pause() {
      }
      resume() {
      }
      [STAT](job) {
        const stat = this.follow ? "statSync" : "lstatSync";
        this[ONSTAT](job, fs2[stat](job.absolute));
      }
      [READDIR](job, stat) {
        this[ONREADDIR](job, fs2.readdirSync(job.absolute));
      }
      // gotta get it all in this tick
      [PIPE](job) {
        const source = job.entry;
        const zip = this.zip;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        if (zip) {
          source.on("data", (chunk) => {
            zip.write(chunk);
          });
        } else {
          source.on("data", (chunk) => {
            super[WRITE](chunk);
          });
        }
      }
    };
    Pack.Sync = PackSync;
    module2.exports = Pack;
  }
});

// node_modules/fs-minipass/node_modules/minipass/index.js
var require_minipass3 = __commonJS({
  "node_modules/fs-minipass/node_modules/minipass/index.js"(exports2, module2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    module2.exports = class Minipass extends Stream {
      constructor(options2) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options2 && options2.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options2 && options2.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options2 && !!options2.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      write(chunk, encoding2, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding2 === "function")
          cb = encoding2, encoding2 = "utf8";
        if (!encoding2)
          encoding2 = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding2 === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding2);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = [this.buffer.join("")];
          else
            this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer[0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding2, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding2 === "function")
          cb = encoding2, encoding2 = "utf8";
        if (chunk)
          this.write(chunk, encoding2);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this.pipes.find((p2) => p2.dest === dest);
        if (p) {
          this.pipes.splice(this.pipes.indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          const ret2 = super.emit("error", data);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this.pipes) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this.pipes) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this.pipes) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || // readable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/fs-minipass/index.js
var require_fs_minipass = __commonJS({
  "node_modules/fs-minipass/index.js"(exports2) {
    "use strict";
    var MiniPass = require_minipass3();
    var EE = require("events").EventEmitter;
    var fs2 = require("fs");
    var writev = fs2.writev;
    if (!writev) {
      const binding = process.binding("fs");
      const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
      writev = (fd, iovec, pos, cb) => {
        const done = (er, bw) => cb(er, bw, iovec);
        const req = new FSReqWrap();
        req.oncomplete = done;
        binding.writeBuffers(fd, iovec, pos, req);
      };
    }
    var _autoClose = Symbol("_autoClose");
    var _close = Symbol("_close");
    var _ended = Symbol("_ended");
    var _fd = Symbol("_fd");
    var _finished = Symbol("_finished");
    var _flags = Symbol("_flags");
    var _flush = Symbol("_flush");
    var _handleChunk = Symbol("_handleChunk");
    var _makeBuf = Symbol("_makeBuf");
    var _mode = Symbol("_mode");
    var _needDrain = Symbol("_needDrain");
    var _onerror = Symbol("_onerror");
    var _onopen = Symbol("_onopen");
    var _onread = Symbol("_onread");
    var _onwrite = Symbol("_onwrite");
    var _open = Symbol("_open");
    var _path = Symbol("_path");
    var _pos = Symbol("_pos");
    var _queue = Symbol("_queue");
    var _read = Symbol("_read");
    var _readSize = Symbol("_readSize");
    var _reading = Symbol("_reading");
    var _remain = Symbol("_remain");
    var _size = Symbol("_size");
    var _write = Symbol("_write");
    var _writing = Symbol("_writing");
    var _defaultFlag = Symbol("_defaultFlag");
    var _errored = Symbol("_errored");
    var ReadStream = class extends MiniPass {
      constructor(path2, opt) {
        opt = opt || {};
        super(opt);
        this.readable = true;
        this.writable = false;
        if (typeof path2 !== "string")
          throw new TypeError("path must be a string");
        this[_errored] = false;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_path] = path2;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        if (typeof this[_fd] === "number")
          this[_read]();
        else
          this[_open]();
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      write() {
        throw new TypeError("this is a readable stream");
      }
      end() {
        throw new TypeError("this is a readable stream");
      }
      [_open]() {
        fs2.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_read]();
        }
      }
      [_makeBuf]() {
        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
      }
      [_read]() {
        if (!this[_reading]) {
          this[_reading] = true;
          const buf = this[_makeBuf]();
          if (buf.length === 0)
            return process.nextTick(() => this[_onread](null, 0, buf));
          fs2.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
        }
      }
      [_onread](er, br, buf) {
        this[_reading] = false;
        if (er)
          this[_onerror](er);
        else if (this[_handleChunk](br, buf))
          this[_read]();
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
      [_onerror](er) {
        this[_reading] = true;
        this[_close]();
        this.emit("error", er);
      }
      [_handleChunk](br, buf) {
        let ret = false;
        this[_remain] -= br;
        if (br > 0)
          ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
        if (br === 0 || this[_remain] <= 0) {
          ret = false;
          this[_close]();
          super.end();
        }
        return ret;
      }
      emit(ev, data) {
        switch (ev) {
          case "prefinish":
          case "finish":
            break;
          case "drain":
            if (typeof this[_fd] === "number")
              this[_read]();
            break;
          case "error":
            if (this[_errored])
              return;
            this[_errored] = true;
            return super.emit(ev, data);
          default:
            return super.emit(ev, data);
        }
      }
    };
    var ReadStreamSync = class extends ReadStream {
      [_open]() {
        let threw = true;
        try {
          this[_onopen](null, fs2.openSync(this[_path], "r"));
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_read]() {
        let threw = true;
        try {
          if (!this[_reading]) {
            this[_reading] = true;
            do {
              const buf = this[_makeBuf]();
              const br = buf.length === 0 ? 0 : fs2.readSync(this[_fd], buf, 0, buf.length, null);
              if (!this[_handleChunk](br, buf))
                break;
            } while (true);
            this[_reading] = false;
          }
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.closeSync(fd);
          this.emit("close");
        }
      }
    };
    var WriteStream = class extends EE {
      constructor(path2, opt) {
        opt = opt || {};
        super(opt);
        this.readable = false;
        this.writable = true;
        this[_errored] = false;
        this[_writing] = false;
        this[_ended] = false;
        this[_needDrain] = false;
        this[_queue] = [];
        this[_path] = path2;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
        this[_pos] = typeof opt.start === "number" ? opt.start : null;
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        const defaultFlag = this[_pos] !== null ? "r+" : "w";
        this[_defaultFlag] = opt.flags === void 0;
        this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
        if (this[_fd] === null)
          this[_open]();
      }
      emit(ev, data) {
        if (ev === "error") {
          if (this[_errored])
            return;
          this[_errored] = true;
        }
        return super.emit(ev, data);
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      [_onerror](er) {
        this[_close]();
        this[_writing] = true;
        this.emit("error", er);
      }
      [_open]() {
        fs2.open(
          this[_path],
          this[_flags],
          this[_mode],
          (er, fd) => this[_onopen](er, fd)
        );
      }
      [_onopen](er, fd) {
        if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
          this[_flags] = "w";
          this[_open]();
        } else if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_flush]();
        }
      }
      end(buf, enc) {
        if (buf)
          this.write(buf, enc);
        this[_ended] = true;
        if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
          this[_onwrite](null, 0);
        return this;
      }
      write(buf, enc) {
        if (typeof buf === "string")
          buf = Buffer.from(buf, enc);
        if (this[_ended]) {
          this.emit("error", new Error("write() after end()"));
          return false;
        }
        if (this[_fd] === null || this[_writing] || this[_queue].length) {
          this[_queue].push(buf);
          this[_needDrain] = true;
          return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
      }
      [_write](buf) {
        fs2.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
      [_onwrite](er, bw) {
        if (er)
          this[_onerror](er);
        else {
          if (this[_pos] !== null)
            this[_pos] += bw;
          if (this[_queue].length)
            this[_flush]();
          else {
            this[_writing] = false;
            if (this[_ended] && !this[_finished]) {
              this[_finished] = true;
              this[_close]();
              this.emit("finish");
            } else if (this[_needDrain]) {
              this[_needDrain] = false;
              this.emit("drain");
            }
          }
        }
      }
      [_flush]() {
        if (this[_queue].length === 0) {
          if (this[_ended])
            this[_onwrite](null, 0);
        } else if (this[_queue].length === 1)
          this[_write](this[_queue].pop());
        else {
          const iovec = this[_queue];
          this[_queue] = [];
          writev(
            this[_fd],
            iovec,
            this[_pos],
            (er, bw) => this[_onwrite](er, bw)
          );
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
    };
    var WriteStreamSync = class extends WriteStream {
      [_open]() {
        let fd;
        if (this[_defaultFlag] && this[_flags] === "r+") {
          try {
            fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
          } catch (er) {
            if (er.code === "ENOENT") {
              this[_flags] = "w";
              return this[_open]();
            } else
              throw er;
          }
        } else
          fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
        this[_onopen](null, fd);
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.closeSync(fd);
          this.emit("close");
        }
      }
      [_write](buf) {
        let threw = true;
        try {
          this[_onwrite](
            null,
            fs2.writeSync(this[_fd], buf, 0, buf.length, this[_pos])
          );
          threw = false;
        } finally {
          if (threw)
            try {
              this[_close]();
            } catch (_) {
            }
        }
      }
    };
    exports2.ReadStream = ReadStream;
    exports2.ReadStreamSync = ReadStreamSync;
    exports2.WriteStream = WriteStream;
    exports2.WriteStreamSync = WriteStreamSync;
  }
});

// node_modules/tar/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/tar/lib/parse.js"(exports2, module2) {
    "use strict";
    var warner = require_warn_mixin();
    var Header = require_header();
    var EE = require("events");
    var Yallist = require_yallist();
    var maxMetaEntrySize = 1024 * 1024;
    var Entry = require_read_entry();
    var Pax = require_pax();
    var zlib = require_minizlib();
    var { nextTick } = require("process");
    var gzipHeader = Buffer.from([31, 139]);
    var STATE = Symbol("state");
    var WRITEENTRY = Symbol("writeEntry");
    var READENTRY = Symbol("readEntry");
    var NEXTENTRY = Symbol("nextEntry");
    var PROCESSENTRY = Symbol("processEntry");
    var EX = Symbol("extendedHeader");
    var GEX = Symbol("globalExtendedHeader");
    var META = Symbol("meta");
    var EMITMETA = Symbol("emitMeta");
    var BUFFER = Symbol("buffer");
    var QUEUE = Symbol("queue");
    var ENDED = Symbol("ended");
    var EMITTEDEND = Symbol("emittedEnd");
    var EMIT = Symbol("emit");
    var UNZIP = Symbol("unzip");
    var CONSUMECHUNK = Symbol("consumeChunk");
    var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
    var CONSUMEBODY = Symbol("consumeBody");
    var CONSUMEMETA = Symbol("consumeMeta");
    var CONSUMEHEADER = Symbol("consumeHeader");
    var CONSUMING = Symbol("consuming");
    var BUFFERCONCAT = Symbol("bufferConcat");
    var MAYBEEND = Symbol("maybeEnd");
    var WRITING = Symbol("writing");
    var ABORTED = Symbol("aborted");
    var DONE = Symbol("onDone");
    var SAW_VALID_ENTRY = Symbol("sawValidEntry");
    var SAW_NULL_BLOCK = Symbol("sawNullBlock");
    var SAW_EOF = Symbol("sawEOF");
    var CLOSESTREAM = Symbol("closeStream");
    var noop = (_) => true;
    module2.exports = warner(class Parser extends EE {
      constructor(opt) {
        opt = opt || {};
        super(opt);
        this.file = opt.file || "";
        this[SAW_VALID_ENTRY] = null;
        this.on(DONE, (_) => {
          if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
            this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
          }
        });
        if (opt.ondone) {
          this.on(DONE, opt.ondone);
        } else {
          this.on(DONE, (_) => {
            this.emit("prefinish");
            this.emit("finish");
            this.emit("end");
          });
        }
        this.strict = !!opt.strict;
        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
        this.filter = typeof opt.filter === "function" ? opt.filter : noop;
        const isTBR = opt.file && (opt.file.endsWith(".tar.br") || opt.file.endsWith(".tbr"));
        this.brotli = !opt.gzip && opt.brotli !== void 0 ? opt.brotli : isTBR ? void 0 : false;
        this.writable = true;
        this.readable = false;
        this[QUEUE] = new Yallist();
        this[BUFFER] = null;
        this[READENTRY] = null;
        this[WRITEENTRY] = null;
        this[STATE] = "begin";
        this[META] = "";
        this[EX] = null;
        this[GEX] = null;
        this[ENDED] = false;
        this[UNZIP] = null;
        this[ABORTED] = false;
        this[SAW_NULL_BLOCK] = false;
        this[SAW_EOF] = false;
        this.on("end", () => this[CLOSESTREAM]());
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        if (typeof opt.onentry === "function") {
          this.on("entry", opt.onentry);
        }
      }
      [CONSUMEHEADER](chunk, position) {
        if (this[SAW_VALID_ENTRY] === null) {
          this[SAW_VALID_ENTRY] = false;
        }
        let header;
        try {
          header = new Header(chunk, position, this[EX], this[GEX]);
        } catch (er) {
          return this.warn("TAR_ENTRY_INVALID", er);
        }
        if (header.nullBlock) {
          if (this[SAW_NULL_BLOCK]) {
            this[SAW_EOF] = true;
            if (this[STATE] === "begin") {
              this[STATE] = "header";
            }
            this[EMIT]("eof");
          } else {
            this[SAW_NULL_BLOCK] = true;
            this[EMIT]("nullBlock");
          }
        } else {
          this[SAW_NULL_BLOCK] = false;
          if (!header.cksumValid) {
            this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
          } else if (!header.path) {
            this.warn("TAR_ENTRY_INVALID", "path is required", { header });
          } else {
            const type = header.type;
            if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {
              this.warn("TAR_ENTRY_INVALID", "linkpath required", { header });
            } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {
              this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header });
            } else {
              const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
              if (!this[SAW_VALID_ENTRY]) {
                if (entry.remain) {
                  const onend = () => {
                    if (!entry.invalid) {
                      this[SAW_VALID_ENTRY] = true;
                    }
                  };
                  entry.on("end", onend);
                } else {
                  this[SAW_VALID_ENTRY] = true;
                }
              }
              if (entry.meta) {
                if (entry.size > this.maxMetaEntrySize) {
                  entry.ignore = true;
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = "ignore";
                  entry.resume();
                } else if (entry.size > 0) {
                  this[META] = "";
                  entry.on("data", (c) => this[META] += c);
                  this[STATE] = "meta";
                }
              } else {
                this[EX] = null;
                entry.ignore = entry.ignore || !this.filter(entry.path, entry);
                if (entry.ignore) {
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = entry.remain ? "ignore" : "header";
                  entry.resume();
                } else {
                  if (entry.remain) {
                    this[STATE] = "body";
                  } else {
                    this[STATE] = "header";
                    entry.end();
                  }
                  if (!this[READENTRY]) {
                    this[QUEUE].push(entry);
                    this[NEXTENTRY]();
                  } else {
                    this[QUEUE].push(entry);
                  }
                }
              }
            }
          }
        }
      }
      [CLOSESTREAM]() {
        nextTick(() => this.emit("close"));
      }
      [PROCESSENTRY](entry) {
        let go = true;
        if (!entry) {
          this[READENTRY] = null;
          go = false;
        } else if (Array.isArray(entry)) {
          this.emit.apply(this, entry);
        } else {
          this[READENTRY] = entry;
          this.emit("entry", entry);
          if (!entry.emittedEnd) {
            entry.on("end", (_) => this[NEXTENTRY]());
            go = false;
          }
        }
        return go;
      }
      [NEXTENTRY]() {
        do {
        } while (this[PROCESSENTRY](this[QUEUE].shift()));
        if (!this[QUEUE].length) {
          const re = this[READENTRY];
          const drainNow = !re || re.flowing || re.size === re.remain;
          if (drainNow) {
            if (!this[WRITING]) {
              this.emit("drain");
            }
          } else {
            re.once("drain", (_) => this.emit("drain"));
          }
        }
      }
      [CONSUMEBODY](chunk, position) {
        const entry = this[WRITEENTRY];
        const br = entry.blockRemain;
        const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
        entry.write(c);
        if (!entry.blockRemain) {
          this[STATE] = "header";
          this[WRITEENTRY] = null;
          entry.end();
        }
        return c.length;
      }
      [CONSUMEMETA](chunk, position) {
        const entry = this[WRITEENTRY];
        const ret = this[CONSUMEBODY](chunk, position);
        if (!this[WRITEENTRY]) {
          this[EMITMETA](entry);
        }
        return ret;
      }
      [EMIT](ev, data, extra) {
        if (!this[QUEUE].length && !this[READENTRY]) {
          this.emit(ev, data, extra);
        } else {
          this[QUEUE].push([ev, data, extra]);
        }
      }
      [EMITMETA](entry) {
        this[EMIT]("meta", this[META]);
        switch (entry.type) {
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this[EX] = Pax.parse(this[META], this[EX], false);
            break;
          case "GlobalExtendedHeader":
            this[GEX] = Pax.parse(this[META], this[GEX], true);
            break;
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].path = this[META].replace(/\0.*/, "");
            break;
          case "NextFileHasLongLinkpath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].linkpath = this[META].replace(/\0.*/, "");
            break;
          /* istanbul ignore next */
          default:
            throw new Error("unknown meta: " + entry.type);
        }
      }
      abort(error) {
        this[ABORTED] = true;
        this.emit("abort", error);
        this.warn("TAR_ABORT", error, { recoverable: false });
      }
      write(chunk) {
        if (this[ABORTED]) {
          return;
        }
        const needSniff = this[UNZIP] === null || this.brotli === void 0 && this[UNZIP] === false;
        if (needSniff && chunk) {
          if (this[BUFFER]) {
            chunk = Buffer.concat([this[BUFFER], chunk]);
            this[BUFFER] = null;
          }
          if (chunk.length < gzipHeader.length) {
            this[BUFFER] = chunk;
            return true;
          }
          for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
            if (chunk[i] !== gzipHeader[i]) {
              this[UNZIP] = false;
            }
          }
          const maybeBrotli = this.brotli === void 0;
          if (this[UNZIP] === false && maybeBrotli) {
            if (chunk.length < 512) {
              if (this[ENDED]) {
                this.brotli = true;
              } else {
                this[BUFFER] = chunk;
                return true;
              }
            } else {
              try {
                new Header(chunk.slice(0, 512));
                this.brotli = false;
              } catch (_) {
                this.brotli = true;
              }
            }
          }
          if (this[UNZIP] === null || this[UNZIP] === false && this.brotli) {
            const ended = this[ENDED];
            this[ENDED] = false;
            this[UNZIP] = this[UNZIP] === null ? new zlib.Unzip() : new zlib.BrotliDecompress();
            this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
            this[UNZIP].on("error", (er) => this.abort(er));
            this[UNZIP].on("end", (_) => {
              this[ENDED] = true;
              this[CONSUMECHUNK]();
            });
            this[WRITING] = true;
            const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
            this[WRITING] = false;
            return ret2;
          }
        }
        this[WRITING] = true;
        if (this[UNZIP]) {
          this[UNZIP].write(chunk);
        } else {
          this[CONSUMECHUNK](chunk);
        }
        this[WRITING] = false;
        const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
        if (!ret && !this[QUEUE].length) {
          this[READENTRY].once("drain", (_) => this.emit("drain"));
        }
        return ret;
      }
      [BUFFERCONCAT](c) {
        if (c && !this[ABORTED]) {
          this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
        }
      }
      [MAYBEEND]() {
        if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
          this[EMITTEDEND] = true;
          const entry = this[WRITEENTRY];
          if (entry && entry.blockRemain) {
            const have = this[BUFFER] ? this[BUFFER].length : 0;
            this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
            if (this[BUFFER]) {
              entry.write(this[BUFFER]);
            }
            entry.end();
          }
          this[EMIT](DONE);
        }
      }
      [CONSUMECHUNK](chunk) {
        if (this[CONSUMING]) {
          this[BUFFERCONCAT](chunk);
        } else if (!chunk && !this[BUFFER]) {
          this[MAYBEEND]();
        } else {
          this[CONSUMING] = true;
          if (this[BUFFER]) {
            this[BUFFERCONCAT](chunk);
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          } else {
            this[CONSUMECHUNKSUB](chunk);
          }
          while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          }
          this[CONSUMING] = false;
        }
        if (!this[BUFFER] || this[ENDED]) {
          this[MAYBEEND]();
        }
      }
      [CONSUMECHUNKSUB](chunk) {
        let position = 0;
        const length = chunk.length;
        while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
          switch (this[STATE]) {
            case "begin":
            case "header":
              this[CONSUMEHEADER](chunk, position);
              position += 512;
              break;
            case "ignore":
            case "body":
              position += this[CONSUMEBODY](chunk, position);
              break;
            case "meta":
              position += this[CONSUMEMETA](chunk, position);
              break;
            /* istanbul ignore next */
            default:
              throw new Error("invalid state: " + this[STATE]);
          }
        }
        if (position < length) {
          if (this[BUFFER]) {
            this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
          } else {
            this[BUFFER] = chunk.slice(position);
          }
        }
      }
      end(chunk) {
        if (!this[ABORTED]) {
          if (this[UNZIP]) {
            this[UNZIP].end(chunk);
          } else {
            this[ENDED] = true;
            if (this.brotli === void 0) chunk = chunk || Buffer.alloc(0);
            this.write(chunk);
          }
        }
      }
    });
  }
});

// node_modules/tar/lib/list.js
var require_list = __commonJS({
  "node_modules/tar/lib/list.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Parser = require_parse2();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var path2 = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function") {
        cb = opt_, files = null, opt_ = {};
      } else if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (typeof files === "function") {
        cb = files, files = null;
      }
      if (!files) {
        files = [];
      } else {
        files = Array.from(files);
      }
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      if (files.length) {
        filesFilter(opt, files);
      }
      if (!opt.noResume) {
        onentryFunction(opt);
      }
      return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list2(opt);
    };
    var onentryFunction = (opt) => {
      const onentry = opt.onentry;
      opt.onentry = onentry ? (e) => {
        onentry(e);
        e.resume();
      } : (e) => e.resume();
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [stripSlash(f), true]));
      const filter2 = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path2.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path2.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter2 ? (file, entry) => filter2(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var listFileSync = (opt) => {
      const p = list2(opt);
      const file = opt.file;
      let threw = true;
      let fd;
      try {
        const stat = fs2.statSync(file);
        const readSize = opt.maxReadSize || 16 * 1024 * 1024;
        if (stat.size < readSize) {
          p.end(fs2.readFileSync(file));
        } else {
          let pos = 0;
          const buf = Buffer.allocUnsafe(readSize);
          fd = fs2.openSync(file, "r");
          while (pos < stat.size) {
            const bytesRead = fs2.readSync(fd, buf, 0, readSize, pos);
            pos += bytesRead;
            p.write(buf.slice(0, bytesRead));
          }
          p.end();
        }
        threw = false;
      } finally {
        if (threw && fd) {
          try {
            fs2.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var listFile = (opt, cb) => {
      const parse3 = new Parser(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve, reject) => {
        parse3.on("error", reject);
        parse3.on("end", resolve);
        fs2.stat(file, (er, stat) => {
          if (er) {
            reject(er);
          } else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(parse3);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var list2 = (opt) => new Parser(opt);
  }
});

// node_modules/tar/lib/create.js
var require_create = __commonJS({
  "node_modules/tar/lib/create.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fsm = require_fs_minipass();
    var t = require_list();
    var path2 = require("path");
    module2.exports = (opt_, files, cb) => {
      if (typeof files === "function") {
        cb = files;
      }
      if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
    };
    var createFileSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      const stream = new fsm.WriteStreamSync(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var createFile = (opt, files, cb) => {
      const p = new Pack(opt);
      const stream = new fsm.WriteStream(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      const promise = new Promise((res, rej) => {
        stream.on("error", rej);
        stream.on("close", res);
        p.on("error", rej);
      });
      addFilesAsync(p, files);
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path2.resolve(p.cwd, file.slice(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else {
          p.add(file);
        }
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path2.resolve(p.cwd, file.slice(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else {
          p.add(file);
        }
      }
      p.end();
    };
    var createSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      addFilesSync(p, files);
      return p;
    };
    var create = (opt, files) => {
      const p = new Pack(opt);
      addFilesAsync(p, files);
      return p;
    };
  }
});

// node_modules/tar/lib/replace.js
var require_replace = __commonJS({
  "node_modules/tar/lib/replace.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var t = require_list();
    var path2 = require("path");
    var Header = require_header();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file) {
        throw new TypeError("file is required");
      }
      if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr")) {
        throw new TypeError("cannot append to compressed archives");
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
    };
    var replaceSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      let threw = true;
      let fd;
      let position;
      try {
        try {
          fd = fs2.openSync(opt.file, "r+");
        } catch (er) {
          if (er.code === "ENOENT") {
            fd = fs2.openSync(opt.file, "w+");
          } else {
            throw er;
          }
        }
        const st = fs2.fstatSync(fd);
        const headBuf = Buffer.alloc(512);
        POSITION: for (position = 0; position < st.size; position += 512) {
          for (let bufPos = 0, bytes2 = 0; bufPos < 512; bufPos += bytes2) {
            bytes2 = fs2.readSync(
              fd,
              headBuf,
              bufPos,
              headBuf.length - bufPos,
              position + bufPos
            );
            if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
              throw new Error("cannot append to compressed archives");
            }
            if (!bytes2) {
              break POSITION;
            }
          }
          const h = new Header(headBuf);
          if (!h.cksumValid) {
            break;
          }
          const entryBlockSize = 512 * Math.ceil(h.size / 512);
          if (position + entryBlockSize + 512 > st.size) {
            break;
          }
          position += entryBlockSize;
          if (opt.mtimeCache) {
            opt.mtimeCache.set(h.path, h.mtime);
          }
        }
        threw = false;
        streamSync(opt, p, position, fd, files);
      } finally {
        if (threw) {
          try {
            fs2.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var streamSync = (opt, p, position, fd, files) => {
      const stream = new fsm.WriteStreamSync(opt.file, {
        fd,
        start: position
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var replace = (opt, files, cb) => {
      files = Array.from(files);
      const p = new Pack(opt);
      const getPos = (fd, size, cb_) => {
        const cb2 = (er, pos) => {
          if (er) {
            fs2.close(fd, (_) => cb_(er));
          } else {
            cb_(null, pos);
          }
        };
        let position = 0;
        if (size === 0) {
          return cb2(null, 0);
        }
        let bufPos = 0;
        const headBuf = Buffer.alloc(512);
        const onread = (er, bytes2) => {
          if (er) {
            return cb2(er);
          }
          bufPos += bytes2;
          if (bufPos < 512 && bytes2) {
            return fs2.read(
              fd,
              headBuf,
              bufPos,
              headBuf.length - bufPos,
              position + bufPos,
              onread
            );
          }
          if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
            return cb2(new Error("cannot append to compressed archives"));
          }
          if (bufPos < 512) {
            return cb2(null, position);
          }
          const h = new Header(headBuf);
          if (!h.cksumValid) {
            return cb2(null, position);
          }
          const entryBlockSize = 512 * Math.ceil(h.size / 512);
          if (position + entryBlockSize + 512 > size) {
            return cb2(null, position);
          }
          position += entryBlockSize + 512;
          if (position >= size) {
            return cb2(null, position);
          }
          if (opt.mtimeCache) {
            opt.mtimeCache.set(h.path, h.mtime);
          }
          bufPos = 0;
          fs2.read(fd, headBuf, 0, 512, position, onread);
        };
        fs2.read(fd, headBuf, 0, 512, position, onread);
      };
      const promise = new Promise((resolve, reject) => {
        p.on("error", reject);
        let flag = "r+";
        const onopen = (er, fd) => {
          if (er && er.code === "ENOENT" && flag === "r+") {
            flag = "w+";
            return fs2.open(opt.file, flag, onopen);
          }
          if (er) {
            return reject(er);
          }
          fs2.fstat(fd, (er2, st) => {
            if (er2) {
              return fs2.close(fd, () => reject(er2));
            }
            getPos(fd, st.size, (er3, position) => {
              if (er3) {
                return reject(er3);
              }
              const stream = new fsm.WriteStream(opt.file, {
                fd,
                start: position
              });
              p.pipe(stream);
              stream.on("error", reject);
              stream.on("close", resolve);
              addFilesAsync(p, files);
            });
          });
        };
        fs2.open(opt.file, flag, onopen);
      });
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path2.resolve(p.cwd, file.slice(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else {
          p.add(file);
        }
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path2.resolve(p.cwd, file.slice(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else {
          p.add(file);
        }
      }
      p.end();
    };
  }
});

// node_modules/tar/lib/update.js
var require_update = __commonJS({
  "node_modules/tar/lib/update.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var r = require_replace();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file) {
        throw new TypeError("file is required");
      }
      if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr")) {
        throw new TypeError("cannot append to compressed archives");
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      mtimeFilter(opt);
      return r(opt, files, cb);
    };
    var mtimeFilter = (opt) => {
      const filter2 = opt.filter;
      if (!opt.mtimeCache) {
        opt.mtimeCache = /* @__PURE__ */ new Map();
      }
      opt.filter = filter2 ? (path2, stat) => filter2(path2, stat) && !(opt.mtimeCache.get(path2) > stat.mtime) : (path2, stat) => !(opt.mtimeCache.get(path2) > stat.mtime);
    };
  }
});

// node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS({
  "node_modules/mkdirp/lib/opts-arg.js"(exports2, module2) {
    var { promisify: promisify2 } = require("util");
    var fs2 = require("fs");
    var optsArg = (opts) => {
      if (!opts)
        opts = { mode: 511, fs: fs2 };
      else if (typeof opts === "object")
        opts = { mode: 511, fs: fs2, ...opts };
      else if (typeof opts === "number")
        opts = { mode: opts, fs: fs2 };
      else if (typeof opts === "string")
        opts = { mode: parseInt(opts, 8), fs: fs2 };
      else
        throw new TypeError("invalid options argument");
      opts.mkdir = opts.mkdir || opts.fs.mkdir || fs2.mkdir;
      opts.mkdirAsync = promisify2(opts.mkdir);
      opts.stat = opts.stat || opts.fs.stat || fs2.stat;
      opts.statAsync = promisify2(opts.stat);
      opts.statSync = opts.statSync || opts.fs.statSync || fs2.statSync;
      opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs2.mkdirSync;
      return opts;
    };
    module2.exports = optsArg;
  }
});

// node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS({
  "node_modules/mkdirp/lib/path-arg.js"(exports2, module2) {
    var platform2 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
    var { resolve, parse: parse3 } = require("path");
    var pathArg = (path2) => {
      if (/\0/.test(path2)) {
        throw Object.assign(
          new TypeError("path must be a string without null bytes"),
          {
            path: path2,
            code: "ERR_INVALID_ARG_VALUE"
          }
        );
      }
      path2 = resolve(path2);
      if (platform2 === "win32") {
        const badWinChars = /[*|"<>?:]/;
        const { root } = parse3(path2);
        if (badWinChars.test(path2.substr(root.length))) {
          throw Object.assign(new Error("Illegal characters in path."), {
            path: path2,
            code: "EINVAL"
          });
        }
      }
      return path2;
    };
    module2.exports = pathArg;
  }
});

// node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS({
  "node_modules/mkdirp/lib/find-made.js"(exports2, module2) {
    var { dirname } = require("path");
    var findMade = (opts, parent, path2 = void 0) => {
      if (path2 === parent)
        return Promise.resolve();
      return opts.statAsync(parent).then(
        (st) => st.isDirectory() ? path2 : void 0,
        // will fail later
        (er) => er.code === "ENOENT" ? findMade(opts, dirname(parent), parent) : void 0
      );
    };
    var findMadeSync = (opts, parent, path2 = void 0) => {
      if (path2 === parent)
        return void 0;
      try {
        return opts.statSync(parent).isDirectory() ? path2 : void 0;
      } catch (er) {
        return er.code === "ENOENT" ? findMadeSync(opts, dirname(parent), parent) : void 0;
      }
    };
    module2.exports = { findMade, findMadeSync };
  }
});

// node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS({
  "node_modules/mkdirp/lib/mkdirp-manual.js"(exports2, module2) {
    var { dirname } = require("path");
    var mkdirpManual = (path2, opts, made) => {
      opts.recursive = false;
      const parent = dirname(path2);
      if (parent === path2) {
        return opts.mkdirAsync(path2, opts).catch((er) => {
          if (er.code !== "EISDIR")
            throw er;
        });
      }
      return opts.mkdirAsync(path2, opts).then(() => made || path2, (er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path2, opts, made2));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        return opts.statAsync(path2).then((st) => {
          if (st.isDirectory())
            return made;
          else
            throw er;
        }, () => {
          throw er;
        });
      });
    };
    var mkdirpManualSync = (path2, opts, made) => {
      const parent = dirname(path2);
      opts.recursive = false;
      if (parent === path2) {
        try {
          return opts.mkdirSync(path2, opts);
        } catch (er) {
          if (er.code !== "EISDIR")
            throw er;
          else
            return;
        }
      }
      try {
        opts.mkdirSync(path2, opts);
        return made || path2;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path2, opts, mkdirpManualSync(parent, opts, made));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        try {
          if (!opts.statSync(path2).isDirectory())
            throw er;
        } catch (_) {
          throw er;
        }
      }
    };
    module2.exports = { mkdirpManual, mkdirpManualSync };
  }
});

// node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS({
  "node_modules/mkdirp/lib/mkdirp-native.js"(exports2, module2) {
    var { dirname } = require("path");
    var { findMade, findMadeSync } = require_find_made();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var mkdirpNative = (path2, opts) => {
      opts.recursive = true;
      const parent = dirname(path2);
      if (parent === path2)
        return opts.mkdirAsync(path2, opts);
      return findMade(opts, path2).then((made) => opts.mkdirAsync(path2, opts).then(() => made).catch((er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(path2, opts);
        else
          throw er;
      }));
    };
    var mkdirpNativeSync = (path2, opts) => {
      opts.recursive = true;
      const parent = dirname(path2);
      if (parent === path2)
        return opts.mkdirSync(path2, opts);
      const made = findMadeSync(opts, path2);
      try {
        opts.mkdirSync(path2, opts);
        return made;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path2, opts);
        else
          throw er;
      }
    };
    module2.exports = { mkdirpNative, mkdirpNativeSync };
  }
});

// node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS({
  "node_modules/mkdirp/lib/use-native.js"(exports2, module2) {
    var fs2 = require("fs");
    var version2 = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
    var versArr = version2.replace(/^v/, "").split(".");
    var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
    var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs2.mkdir;
    var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs2.mkdirSync;
    module2.exports = { useNative, useNativeSync };
  }
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "node_modules/mkdirp/index.js"(exports2, module2) {
    var optsArg = require_opts_arg();
    var pathArg = require_path_arg();
    var { mkdirpNative, mkdirpNativeSync } = require_mkdirp_native();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var { useNative, useNativeSync } = require_use_native();
    var mkdirp = (path2, opts) => {
      path2 = pathArg(path2);
      opts = optsArg(opts);
      return useNative(opts) ? mkdirpNative(path2, opts) : mkdirpManual(path2, opts);
    };
    var mkdirpSync = (path2, opts) => {
      path2 = pathArg(path2);
      opts = optsArg(opts);
      return useNativeSync(opts) ? mkdirpNativeSync(path2, opts) : mkdirpManualSync(path2, opts);
    };
    mkdirp.sync = mkdirpSync;
    mkdirp.native = (path2, opts) => mkdirpNative(pathArg(path2), optsArg(opts));
    mkdirp.manual = (path2, opts) => mkdirpManual(pathArg(path2), optsArg(opts));
    mkdirp.nativeSync = (path2, opts) => mkdirpNativeSync(pathArg(path2), optsArg(opts));
    mkdirp.manualSync = (path2, opts) => mkdirpManualSync(pathArg(path2), optsArg(opts));
    module2.exports = mkdirp;
  }
});

// node_modules/chownr/chownr.js
var require_chownr = __commonJS({
  "node_modules/chownr/chownr.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var path2 = require("path");
    var LCHOWN = fs2.lchown ? "lchown" : "chown";
    var LCHOWNSYNC = fs2.lchownSync ? "lchownSync" : "chownSync";
    var needEISDIRHandled = fs2.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
    var lchownSync = (path3, uid, gid) => {
      try {
        return fs2[LCHOWNSYNC](path3, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var chownSync = (path3, uid, gid) => {
      try {
        return fs2.chownSync(path3, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var handleEISDIR = needEISDIRHandled ? (path3, uid, gid, cb) => (er) => {
      if (!er || er.code !== "EISDIR")
        cb(er);
      else
        fs2.chown(path3, uid, gid, cb);
    } : (_, __, ___, cb) => cb;
    var handleEISDirSync = needEISDIRHandled ? (path3, uid, gid) => {
      try {
        return lchownSync(path3, uid, gid);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        chownSync(path3, uid, gid);
      }
    } : (path3, uid, gid) => lchownSync(path3, uid, gid);
    var nodeVersion = process.version;
    var readdir = (path3, options2, cb) => fs2.readdir(path3, options2, cb);
    var readdirSync = (path3, options2) => fs2.readdirSync(path3, options2);
    if (/^v4\./.test(nodeVersion))
      readdir = (path3, options2, cb) => fs2.readdir(path3, cb);
    var chown = (cpath, uid, gid, cb) => {
      fs2[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
        cb(er && er.code !== "ENOENT" ? er : null);
      }));
    };
    var chownrKid = (p, child, uid, gid, cb) => {
      if (typeof child === "string")
        return fs2.lstat(path2.resolve(p, child), (er, stats) => {
          if (er)
            return cb(er.code !== "ENOENT" ? er : null);
          stats.name = child;
          chownrKid(p, stats, uid, gid, cb);
        });
      if (child.isDirectory()) {
        chownr(path2.resolve(p, child.name), uid, gid, (er) => {
          if (er)
            return cb(er);
          const cpath = path2.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        });
      } else {
        const cpath = path2.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      }
    };
    var chownr = (p, uid, gid, cb) => {
      readdir(p, { withFileTypes: true }, (er, children) => {
        if (er) {
          if (er.code === "ENOENT")
            return cb();
          else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
            return cb(er);
        }
        if (er || !children.length)
          return chown(p, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--len === 0)
            return chown(p, uid, gid, cb);
        };
        children.forEach((child) => chownrKid(p, child, uid, gid, then));
      });
    };
    var chownrKidSync = (p, child, uid, gid) => {
      if (typeof child === "string") {
        try {
          const stats = fs2.lstatSync(path2.resolve(p, child));
          stats.name = child;
          child = stats;
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          else
            throw er;
        }
      }
      if (child.isDirectory())
        chownrSync(path2.resolve(p, child.name), uid, gid);
      handleEISDirSync(path2.resolve(p, child.name), uid, gid);
    };
    var chownrSync = (p, uid, gid) => {
      let children;
      try {
        children = readdirSync(p, { withFileTypes: true });
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
          return handleEISDirSync(p, uid, gid);
        else
          throw er;
      }
      if (children && children.length)
        children.forEach((child) => chownrKidSync(p, child, uid, gid));
      return handleEISDirSync(p, uid, gid);
    };
    module2.exports = chownr;
    chownr.sync = chownrSync;
  }
});

// node_modules/tar/lib/mkdir.js
var require_mkdir = __commonJS({
  "node_modules/tar/lib/mkdir.js"(exports2, module2) {
    "use strict";
    var mkdirp = require_mkdirp();
    var fs2 = require("fs");
    var path2 = require("path");
    var chownr = require_chownr();
    var normPath = require_normalize_windows_path();
    var SymlinkError = class extends Error {
      constructor(symlink, path3) {
        super("Cannot extract through symbolic link");
        this.path = path3;
        this.symlink = symlink;
      }
      get name() {
        return "SylinkError";
      }
    };
    var CwdError = class extends Error {
      constructor(path3, code) {
        super(code + ": Cannot cd into '" + path3 + "'");
        this.path = path3;
        this.code = code;
      }
      get name() {
        return "CwdError";
      }
    };
    var cGet = (cache, key) => cache.get(normPath(key));
    var cSet = (cache, key, val) => cache.set(normPath(key), val);
    var checkCwd = (dir, cb) => {
      fs2.stat(dir, (er, st) => {
        if (er || !st.isDirectory()) {
          er = new CwdError(dir, er && er.code || "ENOTDIR");
        }
        cb(er);
      });
    };
    module2.exports = (dir, opt, cb) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd2 = normPath(opt.cwd);
      const done = (er, created) => {
        if (er) {
          cb(er);
        } else {
          cSet(cache, dir, true);
          if (created && doChown) {
            chownr(created, uid, gid, (er2) => done(er2));
          } else if (needChmod) {
            fs2.chmod(dir, mode, cb);
          } else {
            cb();
          }
        }
      };
      if (cache && cGet(cache, dir) === true) {
        return done();
      }
      if (dir === cwd2) {
        return checkCwd(dir, done);
      }
      if (preserve) {
        return mkdirp(dir, { mode }).then((made) => done(null, made), done);
      }
      const sub = normPath(path2.relative(cwd2, dir));
      const parts = sub.split("/");
      mkdir_(cwd2, parts, mode, cache, unlink, cwd2, null, done);
    };
    var mkdir_ = (base, parts, mode, cache, unlink, cwd2, created, cb) => {
      if (!parts.length) {
        return cb(null, created);
      }
      const p = parts.shift();
      const part = normPath(path2.resolve(base + "/" + p));
      if (cGet(cache, part)) {
        return mkdir_(part, parts, mode, cache, unlink, cwd2, created, cb);
      }
      fs2.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd2, created, cb));
    };
    var onmkdir = (part, parts, mode, cache, unlink, cwd2, created, cb) => (er) => {
      if (er) {
        fs2.lstat(part, (statEr, st) => {
          if (statEr) {
            statEr.path = statEr.path && normPath(statEr.path);
            cb(statEr);
          } else if (st.isDirectory()) {
            mkdir_(part, parts, mode, cache, unlink, cwd2, created, cb);
          } else if (unlink) {
            fs2.unlink(part, (er2) => {
              if (er2) {
                return cb(er2);
              }
              fs2.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd2, created, cb));
            });
          } else if (st.isSymbolicLink()) {
            return cb(new SymlinkError(part, part + "/" + parts.join("/")));
          } else {
            cb(er);
          }
        });
      } else {
        created = created || part;
        mkdir_(part, parts, mode, cache, unlink, cwd2, created, cb);
      }
    };
    var checkCwdSync = (dir) => {
      let ok = false;
      let code = "ENOTDIR";
      try {
        ok = fs2.statSync(dir).isDirectory();
      } catch (er) {
        code = er.code;
      } finally {
        if (!ok) {
          throw new CwdError(dir, code);
        }
      }
    };
    module2.exports.sync = (dir, opt) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd2 = normPath(opt.cwd);
      const done = (created2) => {
        cSet(cache, dir, true);
        if (created2 && doChown) {
          chownr.sync(created2, uid, gid);
        }
        if (needChmod) {
          fs2.chmodSync(dir, mode);
        }
      };
      if (cache && cGet(cache, dir) === true) {
        return done();
      }
      if (dir === cwd2) {
        checkCwdSync(cwd2);
        return done();
      }
      if (preserve) {
        return done(mkdirp.sync(dir, mode));
      }
      const sub = normPath(path2.relative(cwd2, dir));
      const parts = sub.split("/");
      let created = null;
      for (let p = parts.shift(), part = cwd2; p && (part += "/" + p); p = parts.shift()) {
        part = normPath(path2.resolve(part));
        if (cGet(cache, part)) {
          continue;
        }
        try {
          fs2.mkdirSync(part, mode);
          created = created || part;
          cSet(cache, part, true);
        } catch (er) {
          const st = fs2.lstatSync(part);
          if (st.isDirectory()) {
            cSet(cache, part, true);
            continue;
          } else if (unlink) {
            fs2.unlinkSync(part);
            fs2.mkdirSync(part, mode);
            created = created || part;
            cSet(cache, part, true);
            continue;
          } else if (st.isSymbolicLink()) {
            return new SymlinkError(part, part + "/" + parts.join("/"));
          }
        }
      }
      return done(created);
    };
  }
});

// node_modules/tar/lib/normalize-unicode.js
var require_normalize_unicode = __commonJS({
  "node_modules/tar/lib/normalize-unicode.js"(exports2, module2) {
    var normalizeCache = /* @__PURE__ */ Object.create(null);
    var { hasOwnProperty: hasOwnProperty4 } = Object.prototype;
    module2.exports = (s) => {
      if (!hasOwnProperty4.call(normalizeCache, s)) {
        normalizeCache[s] = s.normalize("NFD");
      }
      return normalizeCache[s];
    };
  }
});

// node_modules/tar/lib/path-reservations.js
var require_path_reservations = __commonJS({
  "node_modules/tar/lib/path-reservations.js"(exports2, module2) {
    var assert2 = require("assert");
    var normalize = require_normalize_unicode();
    var stripSlashes = require_strip_trailing_slashes();
    var { join } = require("path");
    var platform2 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows2 = platform2 === "win32";
    module2.exports = () => {
      const queues = /* @__PURE__ */ new Map();
      const reservations = /* @__PURE__ */ new Map();
      const getDirs = (path2) => {
        const dirs = path2.split("/").slice(0, -1).reduce((set, path3) => {
          if (set.length) {
            path3 = join(set[set.length - 1], path3);
          }
          set.push(path3 || "/");
          return set;
        }, []);
        return dirs;
      };
      const running = /* @__PURE__ */ new Set();
      const getQueues = (fn) => {
        const res = reservations.get(fn);
        if (!res) {
          throw new Error("function does not have any path reservations");
        }
        return {
          paths: res.paths.map((path2) => queues.get(path2)),
          dirs: [...res.dirs].map((path2) => queues.get(path2))
        };
      };
      const check = (fn) => {
        const { paths, dirs } = getQueues(fn);
        return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
      };
      const run = (fn) => {
        if (running.has(fn) || !check(fn)) {
          return false;
        }
        running.add(fn);
        fn(() => clear(fn));
        return true;
      };
      const clear = (fn) => {
        if (!running.has(fn)) {
          return false;
        }
        const { paths, dirs } = reservations.get(fn);
        const next = /* @__PURE__ */ new Set();
        paths.forEach((path2) => {
          const q = queues.get(path2);
          assert2.equal(q[0], fn);
          if (q.length === 1) {
            queues.delete(path2);
          } else {
            q.shift();
            if (typeof q[0] === "function") {
              next.add(q[0]);
            } else {
              q[0].forEach((fn2) => next.add(fn2));
            }
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          assert2(q[0] instanceof Set);
          if (q[0].size === 1 && q.length === 1) {
            queues.delete(dir);
          } else if (q[0].size === 1) {
            q.shift();
            next.add(q[0]);
          } else {
            q[0].delete(fn);
          }
        });
        running.delete(fn);
        next.forEach((fn2) => run(fn2));
        return true;
      };
      const reserve = (paths, fn) => {
        paths = isWindows2 ? ["win32 parallelization disabled"] : paths.map((p) => {
          return stripSlashes(join(normalize(p))).toLowerCase();
        });
        const dirs = new Set(
          paths.map((path2) => getDirs(path2)).reduce((a, b) => a.concat(b))
        );
        reservations.set(fn, { dirs, paths });
        paths.forEach((path2) => {
          const q = queues.get(path2);
          if (!q) {
            queues.set(path2, [fn]);
          } else {
            q.push(fn);
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          if (!q) {
            queues.set(dir, [/* @__PURE__ */ new Set([fn])]);
          } else if (q[q.length - 1] instanceof Set) {
            q[q.length - 1].add(fn);
          } else {
            q.push(/* @__PURE__ */ new Set([fn]));
          }
        });
        return run(fn);
      };
      return { check, reserve };
    };
  }
});

// node_modules/tar/lib/get-write-flag.js
var require_get_write_flag = __commonJS({
  "node_modules/tar/lib/get-write-flag.js"(exports2, module2) {
    var platform2 = process.env.__FAKE_PLATFORM__ || process.platform;
    var isWindows2 = platform2 === "win32";
    var fs2 = global.__FAKE_TESTING_FS__ || require("fs");
    var { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs2.constants;
    var fMapEnabled = isWindows2 && !!UV_FS_O_FILEMAP;
    var fMapLimit = 512 * 1024;
    var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
    module2.exports = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
  }
});

// node_modules/tar/lib/unpack.js
var require_unpack = __commonJS({
  "node_modules/tar/lib/unpack.js"(exports2, module2) {
    "use strict";
    var assert2 = require("assert");
    var Parser = require_parse2();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var path2 = require("path");
    var mkdir = require_mkdir();
    var wc = require_winchars();
    var pathReservations = require_path_reservations();
    var stripAbsolutePath = require_strip_absolute_path();
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var normalize = require_normalize_unicode();
    var ONENTRY = Symbol("onEntry");
    var CHECKFS = Symbol("checkFs");
    var CHECKFS2 = Symbol("checkFs2");
    var PRUNECACHE = Symbol("pruneCache");
    var ISREUSABLE = Symbol("isReusable");
    var MAKEFS = Symbol("makeFs");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var LINK = Symbol("link");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var UNSUPPORTED = Symbol("unsupported");
    var CHECKPATH = Symbol("checkPath");
    var MKDIR = Symbol("mkdir");
    var ONERROR = Symbol("onError");
    var PENDING = Symbol("pending");
    var PEND = Symbol("pend");
    var UNPEND = Symbol("unpend");
    var ENDED = Symbol("ended");
    var MAYBECLOSE = Symbol("maybeClose");
    var SKIP = Symbol("skip");
    var DOCHOWN = Symbol("doChown");
    var UID = Symbol("uid");
    var GID = Symbol("gid");
    var CHECKED_CWD = Symbol("checkedCwd");
    var crypto4 = require("crypto");
    var getFlag = require_get_write_flag();
    var platform2 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows2 = platform2 === "win32";
    var DEFAULT_MAX_DEPTH = 1024;
    var unlinkFile = (path3, cb) => {
      if (!isWindows2) {
        return fs2.unlink(path3, cb);
      }
      const name2 = path3 + ".DELETE." + crypto4.randomBytes(16).toString("hex");
      fs2.rename(path3, name2, (er) => {
        if (er) {
          return cb(er);
        }
        fs2.unlink(name2, cb);
      });
    };
    var unlinkFileSync = (path3) => {
      if (!isWindows2) {
        return fs2.unlinkSync(path3);
      }
      const name2 = path3 + ".DELETE." + crypto4.randomBytes(16).toString("hex");
      fs2.renameSync(path3, name2);
      fs2.unlinkSync(name2);
    };
    var uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
    var cacheKeyNormalize = (path3) => stripSlash(normPath(normalize(path3))).toLowerCase();
    var pruneCache = (cache, abs) => {
      abs = cacheKeyNormalize(abs);
      for (const path3 of cache.keys()) {
        const pnorm = cacheKeyNormalize(path3);
        if (pnorm === abs || pnorm.indexOf(abs + "/") === 0) {
          cache.delete(path3);
        }
      }
    };
    var dropCache = (cache) => {
      for (const key of cache.keys()) {
        cache.delete(key);
      }
    };
    var Unpack = class extends Parser {
      constructor(opt) {
        if (!opt) {
          opt = {};
        }
        opt.ondone = (_) => {
          this[ENDED] = true;
          this[MAYBECLOSE]();
        };
        super(opt);
        this[CHECKED_CWD] = false;
        this.reservations = pathReservations();
        this.transform = typeof opt.transform === "function" ? opt.transform : null;
        this.writable = true;
        this.readable = false;
        this[PENDING] = 0;
        this[ENDED] = false;
        this.dirCache = opt.dirCache || /* @__PURE__ */ new Map();
        if (typeof opt.uid === "number" || typeof opt.gid === "number") {
          if (typeof opt.uid !== "number" || typeof opt.gid !== "number") {
            throw new TypeError("cannot set owner without number uid and gid");
          }
          if (opt.preserveOwner) {
            throw new TypeError(
              "cannot preserve owner in archive and also set owner explicitly"
            );
          }
          this.uid = opt.uid;
          this.gid = opt.gid;
          this.setOwner = true;
        } else {
          this.uid = null;
          this.gid = null;
          this.setOwner = false;
        }
        if (opt.preserveOwner === void 0 && typeof opt.uid !== "number") {
          this.preserveOwner = process.getuid && process.getuid() === 0;
        } else {
          this.preserveOwner = !!opt.preserveOwner;
        }
        this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
        this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
        this.maxDepth = typeof opt.maxDepth === "number" ? opt.maxDepth : DEFAULT_MAX_DEPTH;
        this.forceChown = opt.forceChown === true;
        this.win32 = !!opt.win32 || isWindows2;
        this.newer = !!opt.newer;
        this.keep = !!opt.keep;
        this.noMtime = !!opt.noMtime;
        this.preservePaths = !!opt.preservePaths;
        this.unlink = !!opt.unlink;
        this.cwd = normPath(path2.resolve(opt.cwd || process.cwd()));
        this.strip = +opt.strip || 0;
        this.processUmask = opt.noChmod ? 0 : process.umask();
        this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
        this.dmode = opt.dmode || 511 & ~this.umask;
        this.fmode = opt.fmode || 438 & ~this.umask;
        this.on("entry", (entry) => this[ONENTRY](entry));
      }
      // a bad or damaged archive is a warning for Parser, but an error
      // when extracting.  Mark those errors as unrecoverable, because
      // the Unpack contract cannot be met.
      warn(code, msg, data = {}) {
        if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT") {
          data.recoverable = false;
        }
        return super.warn(code, msg, data);
      }
      [MAYBECLOSE]() {
        if (this[ENDED] && this[PENDING] === 0) {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
        }
      }
      [CHECKPATH](entry) {
        const p = normPath(entry.path);
        const parts = p.split("/");
        if (this.strip) {
          if (parts.length < this.strip) {
            return false;
          }
          if (entry.type === "Link") {
            const linkparts = normPath(entry.linkpath).split("/");
            if (linkparts.length >= this.strip) {
              entry.linkpath = linkparts.slice(this.strip).join("/");
            } else {
              return false;
            }
          }
          parts.splice(0, this.strip);
          entry.path = parts.join("/");
        }
        if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {
          this.warn("TAR_ENTRY_ERROR", "path excessively deep", {
            entry,
            path: p,
            depth: parts.length,
            maxDepth: this.maxDepth
          });
          return false;
        }
        if (!this.preservePaths) {
          if (parts.includes("..") || isWindows2 && /^[a-z]:\.\.$/i.test(parts[0])) {
            this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
              entry,
              path: p
            });
            return false;
          }
          const [root, stripped] = stripAbsolutePath(p);
          if (root) {
            entry.path = stripped;
            this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute path`, {
              entry,
              path: p
            });
          }
        }
        if (path2.isAbsolute(entry.path)) {
          entry.absolute = normPath(path2.resolve(entry.path));
        } else {
          entry.absolute = normPath(path2.resolve(this.cwd, entry.path));
        }
        if (!this.preservePaths && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd) {
          this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
            entry,
            path: normPath(entry.path),
            resolvedPath: entry.absolute,
            cwd: this.cwd
          });
          return false;
        }
        if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir") {
          return false;
        }
        if (this.win32) {
          const { root: aRoot } = path2.win32.parse(entry.absolute);
          entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));
          const { root: pRoot } = path2.win32.parse(entry.path);
          entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));
        }
        return true;
      }
      [ONENTRY](entry) {
        if (!this[CHECKPATH](entry)) {
          return entry.resume();
        }
        assert2.equal(typeof entry.absolute, "string");
        switch (entry.type) {
          case "Directory":
          case "GNUDumpDir":
            if (entry.mode) {
              entry.mode = entry.mode | 448;
            }
          // eslint-disable-next-line no-fallthrough
          case "File":
          case "OldFile":
          case "ContiguousFile":
          case "Link":
          case "SymbolicLink":
            return this[CHECKFS](entry);
          case "CharacterDevice":
          case "BlockDevice":
          case "FIFO":
          default:
            return this[UNSUPPORTED](entry);
        }
      }
      [ONERROR](er, entry) {
        if (er.name === "CwdError") {
          this.emit("error", er);
        } else {
          this.warn("TAR_ENTRY_ERROR", er, { entry });
          this[UNPEND]();
          entry.resume();
        }
      }
      [MKDIR](dir, mode, cb) {
        mkdir(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode,
          noChmod: this.noChmod
        }, cb);
      }
      [DOCHOWN](entry) {
        return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
      }
      [UID](entry) {
        return uint32(this.uid, entry.uid, this.processUid);
      }
      [GID](entry) {
        return uint32(this.gid, entry.gid, this.processGid);
      }
      [FILE](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.fmode;
        const stream = new fsm.WriteStream(entry.absolute, {
          flags: getFlag(entry.size),
          mode,
          autoClose: false
        });
        stream.on("error", (er) => {
          if (stream.fd) {
            fs2.close(stream.fd, () => {
            });
          }
          stream.write = () => true;
          this[ONERROR](er, entry);
          fullyDone();
        });
        let actions = 1;
        const done = (er) => {
          if (er) {
            if (stream.fd) {
              fs2.close(stream.fd, () => {
              });
            }
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          if (--actions === 0) {
            fs2.close(stream.fd, (er2) => {
              if (er2) {
                this[ONERROR](er2, entry);
              } else {
                this[UNPEND]();
              }
              fullyDone();
            });
          }
        };
        stream.on("finish", (_) => {
          const abs = entry.absolute;
          const fd = stream.fd;
          if (entry.mtime && !this.noMtime) {
            actions++;
            const atime = entry.atime || /* @__PURE__ */ new Date();
            const mtime = entry.mtime;
            fs2.futimes(fd, atime, mtime, (er) => er ? fs2.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            fs2.fchown(fd, uid, gid, (er) => er ? fs2.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
          }
          done();
        });
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => {
            this[ONERROR](er, entry);
            fullyDone();
          });
          entry.pipe(tx);
        }
        tx.pipe(stream);
      }
      [DIRECTORY](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.dmode;
        this[MKDIR](entry.absolute, mode, (er) => {
          if (er) {
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          let actions = 1;
          const done = (_) => {
            if (--actions === 0) {
              fullyDone();
              this[UNPEND]();
              entry.resume();
            }
          };
          if (entry.mtime && !this.noMtime) {
            actions++;
            fs2.utimes(entry.absolute, entry.atime || /* @__PURE__ */ new Date(), entry.mtime, done);
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            fs2.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
          }
          done();
        });
      }
      [UNSUPPORTED](entry) {
        entry.unsupported = true;
        this.warn(
          "TAR_ENTRY_UNSUPPORTED",
          `unsupported entry type: ${entry.type}`,
          { entry }
        );
        entry.resume();
      }
      [SYMLINK](entry, done) {
        this[LINK](entry, entry.linkpath, "symlink", done);
      }
      [HARDLINK](entry, done) {
        const linkpath = normPath(path2.resolve(this.cwd, entry.linkpath));
        this[LINK](entry, linkpath, "link", done);
      }
      [PEND]() {
        this[PENDING]++;
      }
      [UNPEND]() {
        this[PENDING]--;
        this[MAYBECLOSE]();
      }
      [SKIP](entry) {
        this[UNPEND]();
        entry.resume();
      }
      // Check if we can reuse an existing filesystem entry safely and
      // overwrite it, rather than unlinking and recreating
      // Windows doesn't report a useful nlink, so we just never reuse entries
      [ISREUSABLE](entry, st) {
        return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows2;
      }
      // check if a thing is there, and if so, try to clobber it
      [CHECKFS](entry) {
        this[PEND]();
        const paths = [entry.path];
        if (entry.linkpath) {
          paths.push(entry.linkpath);
        }
        this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
      }
      [PRUNECACHE](entry) {
        if (entry.type === "SymbolicLink") {
          dropCache(this.dirCache);
        } else if (entry.type !== "Directory") {
          pruneCache(this.dirCache, entry.absolute);
        }
      }
      [CHECKFS2](entry, fullyDone) {
        this[PRUNECACHE](entry);
        const done = (er) => {
          this[PRUNECACHE](entry);
          fullyDone(er);
        };
        const checkCwd = () => {
          this[MKDIR](this.cwd, this.dmode, (er) => {
            if (er) {
              this[ONERROR](er, entry);
              done();
              return;
            }
            this[CHECKED_CWD] = true;
            start();
          });
        };
        const start = () => {
          if (entry.absolute !== this.cwd) {
            const parent = normPath(path2.dirname(entry.absolute));
            if (parent !== this.cwd) {
              return this[MKDIR](parent, this.dmode, (er) => {
                if (er) {
                  this[ONERROR](er, entry);
                  done();
                  return;
                }
                afterMakeParent();
              });
            }
          }
          afterMakeParent();
        };
        const afterMakeParent = () => {
          fs2.lstat(entry.absolute, (lstatEr, st) => {
            if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
              this[SKIP](entry);
              done();
              return;
            }
            if (lstatEr || this[ISREUSABLE](entry, st)) {
              return this[MAKEFS](null, entry, done);
            }
            if (st.isDirectory()) {
              if (entry.type === "Directory") {
                const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
                const afterChmod = (er) => this[MAKEFS](er, entry, done);
                if (!needChmod) {
                  return afterChmod();
                }
                return fs2.chmod(entry.absolute, entry.mode, afterChmod);
              }
              if (entry.absolute !== this.cwd) {
                return fs2.rmdir(entry.absolute, (er) => this[MAKEFS](er, entry, done));
              }
            }
            if (entry.absolute === this.cwd) {
              return this[MAKEFS](null, entry, done);
            }
            unlinkFile(entry.absolute, (er) => this[MAKEFS](er, entry, done));
          });
        };
        if (this[CHECKED_CWD]) {
          start();
        } else {
          checkCwd();
        }
      }
      [MAKEFS](er, entry, done) {
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        switch (entry.type) {
          case "File":
          case "OldFile":
          case "ContiguousFile":
            return this[FILE](entry, done);
          case "Link":
            return this[HARDLINK](entry, done);
          case "SymbolicLink":
            return this[SYMLINK](entry, done);
          case "Directory":
          case "GNUDumpDir":
            return this[DIRECTORY](entry, done);
        }
      }
      [LINK](entry, linkpath, link, done) {
        fs2[link](linkpath, entry.absolute, (er) => {
          if (er) {
            this[ONERROR](er, entry);
          } else {
            this[UNPEND]();
            entry.resume();
          }
          done();
        });
      }
    };
    var callSync = (fn) => {
      try {
        return [null, fn()];
      } catch (er) {
        return [er, null];
      }
    };
    var UnpackSync = class extends Unpack {
      [MAKEFS](er, entry) {
        return super[MAKEFS](er, entry, () => {
        });
      }
      [CHECKFS](entry) {
        this[PRUNECACHE](entry);
        if (!this[CHECKED_CWD]) {
          const er2 = this[MKDIR](this.cwd, this.dmode);
          if (er2) {
            return this[ONERROR](er2, entry);
          }
          this[CHECKED_CWD] = true;
        }
        if (entry.absolute !== this.cwd) {
          const parent = normPath(path2.dirname(entry.absolute));
          if (parent !== this.cwd) {
            const mkParent = this[MKDIR](parent, this.dmode);
            if (mkParent) {
              return this[ONERROR](mkParent, entry);
            }
          }
        }
        const [lstatEr, st] = callSync(() => fs2.lstatSync(entry.absolute));
        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
          return this[SKIP](entry);
        }
        if (lstatEr || this[ISREUSABLE](entry, st)) {
          return this[MAKEFS](null, entry);
        }
        if (st.isDirectory()) {
          if (entry.type === "Directory") {
            const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
            const [er3] = needChmod ? callSync(() => {
              fs2.chmodSync(entry.absolute, entry.mode);
            }) : [];
            return this[MAKEFS](er3, entry);
          }
          const [er2] = callSync(() => fs2.rmdirSync(entry.absolute));
          this[MAKEFS](er2, entry);
        }
        const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));
        this[MAKEFS](er, entry);
      }
      [FILE](entry, done) {
        const mode = entry.mode & 4095 || this.fmode;
        const oner = (er) => {
          let closeError;
          try {
            fs2.closeSync(fd);
          } catch (e) {
            closeError = e;
          }
          if (er || closeError) {
            this[ONERROR](er || closeError, entry);
          }
          done();
        };
        let fd;
        try {
          fd = fs2.openSync(entry.absolute, getFlag(entry.size), mode);
        } catch (er) {
          return oner(er);
        }
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => this[ONERROR](er, entry));
          entry.pipe(tx);
        }
        tx.on("data", (chunk) => {
          try {
            fs2.writeSync(fd, chunk, 0, chunk.length);
          } catch (er) {
            oner(er);
          }
        });
        tx.on("end", (_) => {
          let er = null;
          if (entry.mtime && !this.noMtime) {
            const atime = entry.atime || /* @__PURE__ */ new Date();
            const mtime = entry.mtime;
            try {
              fs2.futimesSync(fd, atime, mtime);
            } catch (futimeser) {
              try {
                fs2.utimesSync(entry.absolute, atime, mtime);
              } catch (utimeser) {
                er = futimeser;
              }
            }
          }
          if (this[DOCHOWN](entry)) {
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            try {
              fs2.fchownSync(fd, uid, gid);
            } catch (fchowner) {
              try {
                fs2.chownSync(entry.absolute, uid, gid);
              } catch (chowner) {
                er = er || fchowner;
              }
            }
          }
          oner(er);
        });
      }
      [DIRECTORY](entry, done) {
        const mode = entry.mode & 4095 || this.dmode;
        const er = this[MKDIR](entry.absolute, mode);
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        if (entry.mtime && !this.noMtime) {
          try {
            fs2.utimesSync(entry.absolute, entry.atime || /* @__PURE__ */ new Date(), entry.mtime);
          } catch (er2) {
          }
        }
        if (this[DOCHOWN](entry)) {
          try {
            fs2.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
          } catch (er2) {
          }
        }
        done();
        entry.resume();
      }
      [MKDIR](dir, mode) {
        try {
          return mkdir.sync(normPath(dir), {
            uid: this.uid,
            gid: this.gid,
            processUid: this.processUid,
            processGid: this.processGid,
            umask: this.processUmask,
            preserve: this.preservePaths,
            unlink: this.unlink,
            cache: this.dirCache,
            cwd: this.cwd,
            mode
          });
        } catch (er) {
          return er;
        }
      }
      [LINK](entry, linkpath, link, done) {
        try {
          fs2[link + "Sync"](linkpath, entry.absolute);
          done();
          entry.resume();
        } catch (er) {
          return this[ONERROR](er, entry);
        }
      }
    };
    Unpack.Sync = UnpackSync;
    module2.exports = Unpack;
  }
});

// node_modules/tar/lib/extract.js
var require_extract = __commonJS({
  "node_modules/tar/lib/extract.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Unpack = require_unpack();
    var fs2 = require("fs");
    var fsm = require_fs_minipass();
    var path2 = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function") {
        cb = opt_, files = null, opt_ = {};
      } else if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (typeof files === "function") {
        cb = files, files = null;
      }
      if (!files) {
        files = [];
      } else {
        files = Array.from(files);
      }
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      if (files.length) {
        filesFilter(opt, files);
      }
      return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [stripSlash(f), true]));
      const filter2 = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path2.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path2.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter2 ? (file, entry) => filter2(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var extractFileSync = (opt) => {
      const u = new Unpack.Sync(opt);
      const file = opt.file;
      const stat = fs2.statSync(file);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const stream = new fsm.ReadStreamSync(file, {
        readSize,
        size: stat.size
      });
      stream.pipe(u);
    };
    var extractFile = (opt, cb) => {
      const u = new Unpack(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve, reject) => {
        u.on("error", reject);
        u.on("close", resolve);
        fs2.stat(file, (er, stat) => {
          if (er) {
            reject(er);
          } else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(u);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var extractSync = (opt) => new Unpack.Sync(opt);
    var extract = (opt) => new Unpack(opt);
  }
});

// node_modules/tar/index.js
var require_tar = __commonJS({
  "node_modules/tar/index.js"(exports2) {
    "use strict";
    exports2.c = exports2.create = require_create();
    exports2.r = exports2.replace = require_replace();
    exports2.t = exports2.list = require_list();
    exports2.u = exports2.update = require_update();
    exports2.x = exports2.extract = require_extract();
    exports2.Pack = require_pack();
    exports2.Unpack = require_unpack();
    exports2.Parse = require_parse2();
    exports2.ReadEntry = require_read_entry();
    exports2.WriteEntry = require_write_entry();
    exports2.Header = require_header();
    exports2.Pax = require_pax();
    exports2.types = require_types2();
  }
});

// node_modules/traverse/index.js
var require_traverse = __commonJS({
  "node_modules/traverse/index.js"(exports2, module2) {
    module2.exports = Traverse;
    function Traverse(obj) {
      if (!(this instanceof Traverse)) return new Traverse(obj);
      this.value = obj;
    }
    Traverse.prototype.get = function(ps) {
      var node = this.value;
      for (var i = 0; i < ps.length; i++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) {
          node = void 0;
          break;
        }
        node = node[key];
      }
      return node;
    };
    Traverse.prototype.set = function(ps, value) {
      var node = this.value;
      for (var i = 0; i < ps.length - 1; i++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
      }
      node[ps[i]] = value;
      return value;
    };
    Traverse.prototype.map = function(cb) {
      return walk2(this.value, cb, true);
    };
    Traverse.prototype.forEach = function(cb) {
      this.value = walk2(this.value, cb, false);
      return this.value;
    };
    Traverse.prototype.reduce = function(cb, init) {
      var skip = arguments.length === 1;
      var acc = skip ? this.value : init;
      this.forEach(function(x) {
        if (!this.isRoot || !skip) {
          acc = cb.call(this, acc, x);
        }
      });
      return acc;
    };
    Traverse.prototype.deepEqual = function(obj) {
      if (arguments.length !== 1) {
        throw new Error(
          "deepEqual requires exactly one object to compare against"
        );
      }
      var equal = true;
      var node = obj;
      this.forEach(function(y) {
        var notEqual = function() {
          equal = false;
          return void 0;
        }.bind(this);
        if (!this.isRoot) {
          if (typeof node !== "object") return notEqual();
          node = node[this.key];
        }
        var x = node;
        this.post(function() {
          node = x;
        });
        var toS = function(o) {
          return Object.prototype.toString.call(o);
        };
        if (this.circular) {
          if (Traverse(obj).get(this.circular.path) !== x) notEqual();
        } else if (typeof x !== typeof y) {
          notEqual();
        } else if (x === null || y === null || x === void 0 || y === void 0) {
          if (x !== y) notEqual();
        } else if (x.__proto__ !== y.__proto__) {
          notEqual();
        } else if (x === y) {
        } else if (typeof x === "function") {
          if (x instanceof RegExp) {
            if (x.toString() != y.toString()) notEqual();
          } else if (x !== y) notEqual();
        } else if (typeof x === "object") {
          if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
            if (toS(x) !== toS(y)) {
              notEqual();
            }
          } else if (x instanceof Date || y instanceof Date) {
            if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) {
              notEqual();
            }
          } else {
            var kx = Object.keys(x);
            var ky = Object.keys(y);
            if (kx.length !== ky.length) return notEqual();
            for (var i = 0; i < kx.length; i++) {
              var k = kx[i];
              if (!Object.hasOwnProperty.call(y, k)) {
                notEqual();
              }
            }
          }
        }
      });
      return equal;
    };
    Traverse.prototype.paths = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.path);
      });
      return acc;
    };
    Traverse.prototype.nodes = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.node);
      });
      return acc;
    };
    Traverse.prototype.clone = function() {
      var parents = [], nodes = [];
      return function clone(src) {
        for (var i = 0; i < parents.length; i++) {
          if (parents[i] === src) {
            return nodes[i];
          }
        }
        if (typeof src === "object" && src !== null) {
          var dst = copy(src);
          parents.push(src);
          nodes.push(dst);
          Object.keys(src).forEach(function(key) {
            dst[key] = clone(src[key]);
          });
          parents.pop();
          nodes.pop();
          return dst;
        } else {
          return src;
        }
      }(this.value);
    };
    function walk2(root, cb, immutable) {
      var path2 = [];
      var parents = [];
      var alive = true;
      return function walker(node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        var state = {
          node,
          node_,
          path: [].concat(path2),
          parent: parents.slice(-1)[0],
          key: path2.slice(-1)[0],
          isRoot: path2.length === 0,
          level: path2.length,
          circular: null,
          update: function(x) {
            if (!state.isRoot) {
              state.parent.node[state.key] = x;
            }
            state.node = x;
          },
          "delete": function() {
            delete state.parent.node[state.key];
          },
          remove: function() {
            if (Array.isArray(state.parent.node)) {
              state.parent.node.splice(state.key, 1);
            } else {
              delete state.parent.node[state.key];
            }
          },
          before: function(f) {
            modifiers.before = f;
          },
          after: function(f) {
            modifiers.after = f;
          },
          pre: function(f) {
            modifiers.pre = f;
          },
          post: function(f) {
            modifiers.post = f;
          },
          stop: function() {
            alive = false;
          }
        };
        if (!alive) return state;
        if (typeof node === "object" && node !== null) {
          state.isLeaf = Object.keys(node).length == 0;
          for (var i = 0; i < parents.length; i++) {
            if (parents[i].node_ === node_) {
              state.circular = parents[i];
              break;
            }
          }
        } else {
          state.isLeaf = true;
        }
        state.notLeaf = !state.isLeaf;
        state.notRoot = !state.isRoot;
        var ret = cb.call(state, state.node);
        if (ret !== void 0 && state.update) state.update(ret);
        if (modifiers.before) modifiers.before.call(state, state.node);
        if (typeof state.node == "object" && state.node !== null && !state.circular) {
          parents.push(state);
          var keys = Object.keys(state.node);
          keys.forEach(function(key, i2) {
            path2.push(key);
            if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
            var child = walker(state.node[key]);
            if (immutable && Object.hasOwnProperty.call(state.node, key)) {
              state.node[key] = child.node;
            }
            child.isLast = i2 == keys.length - 1;
            child.isFirst = i2 == 0;
            if (modifiers.post) modifiers.post.call(state, child);
            path2.pop();
          });
          parents.pop();
        }
        if (modifiers.after) modifiers.after.call(state, state.node);
        return state;
      }(root).node;
    }
    Object.keys(Traverse.prototype).forEach(function(key) {
      Traverse[key] = function(obj) {
        var args = [].slice.call(arguments, 1);
        var t = Traverse(obj);
        return t[key].apply(t, args);
      };
    });
    function copy(src) {
      if (typeof src === "object" && src !== null) {
        var dst;
        if (Array.isArray(src)) {
          dst = [];
        } else if (src instanceof Date) {
          dst = new Date(src);
        } else if (src instanceof Boolean) {
          dst = new Boolean(src);
        } else if (src instanceof Number) {
          dst = new Number(src);
        } else if (src instanceof String) {
          dst = new String(src);
        } else {
          dst = Object.create(Object.getPrototypeOf(src));
        }
        Object.keys(src).forEach(function(key) {
          dst[key] = src[key];
        });
        return dst;
      } else return src;
    }
  }
});

// node_modules/chainsaw/index.js
var require_chainsaw = __commonJS({
  "node_modules/chainsaw/index.js"(exports2, module2) {
    var Traverse = require_traverse();
    var EventEmitter4 = require("events").EventEmitter;
    module2.exports = Chainsaw;
    function Chainsaw(builder) {
      var saw = Chainsaw.saw(builder, {});
      var r = builder.call(saw.handlers, saw);
      if (r !== void 0) saw.handlers = r;
      saw.record();
      return saw.chain();
    }
    Chainsaw.light = function ChainsawLight(builder) {
      var saw = Chainsaw.saw(builder, {});
      var r = builder.call(saw.handlers, saw);
      if (r !== void 0) saw.handlers = r;
      return saw.chain();
    };
    Chainsaw.saw = function(builder, handlers) {
      var saw = new EventEmitter4();
      saw.handlers = handlers;
      saw.actions = [];
      saw.chain = function() {
        var ch = Traverse(saw.handlers).map(function(node) {
          if (this.isRoot) return node;
          var ps = this.path;
          if (typeof node === "function") {
            this.update(function() {
              saw.actions.push({
                path: ps,
                args: [].slice.call(arguments)
              });
              return ch;
            });
          }
        });
        process.nextTick(function() {
          saw.emit("begin");
          saw.next();
        });
        return ch;
      };
      saw.pop = function() {
        return saw.actions.shift();
      };
      saw.next = function() {
        var action = saw.pop();
        if (!action) {
          saw.emit("end");
        } else if (!action.trap) {
          var node = saw.handlers;
          action.path.forEach(function(key) {
            node = node[key];
          });
          node.apply(saw.handlers, action.args);
        }
      };
      saw.nest = function(cb) {
        var args = [].slice.call(arguments, 1);
        var autonext = true;
        if (typeof cb === "boolean") {
          var autonext = cb;
          cb = args.shift();
        }
        var s = Chainsaw.saw(builder, {});
        var r = builder.call(s.handlers, s);
        if (r !== void 0) s.handlers = r;
        if ("undefined" !== typeof saw.step) {
          s.record();
        }
        cb.apply(s.chain(), args);
        if (autonext !== false) s.on("end", saw.next);
      };
      saw.record = function() {
        upgradeChainsaw(saw);
      };
      ["trap", "down", "jump"].forEach(function(method) {
        saw[method] = function() {
          throw new Error("To use the trap, down and jump features, please call record() first to start recording actions.");
        };
      });
      return saw;
    };
    function upgradeChainsaw(saw) {
      saw.step = 0;
      saw.pop = function() {
        return saw.actions[saw.step++];
      };
      saw.trap = function(name2, cb) {
        var ps = Array.isArray(name2) ? name2 : [name2];
        saw.actions.push({
          path: ps,
          step: saw.step,
          cb,
          trap: true
        });
      };
      saw.down = function(name2) {
        var ps = (Array.isArray(name2) ? name2 : [name2]).join("/");
        var i = saw.actions.slice(saw.step).map(function(x) {
          if (x.trap && x.step <= saw.step) return false;
          return x.path.join("/") == ps;
        }).indexOf(true);
        if (i >= 0) saw.step += i;
        else saw.step = saw.actions.length;
        var act = saw.actions[saw.step - 1];
        if (act && act.trap) {
          saw.step = act.step;
          act.cb();
        } else saw.next();
      };
      saw.jump = function(step) {
        saw.step = step;
        saw.next();
      };
    }
  }
});

// node_modules/buffers/index.js
var require_buffers = __commonJS({
  "node_modules/buffers/index.js"(exports2, module2) {
    module2.exports = Buffers;
    function Buffers(bufs) {
      if (!(this instanceof Buffers)) return new Buffers(bufs);
      this.buffers = bufs || [];
      this.length = this.buffers.reduce(function(size, buf) {
        return size + buf.length;
      }, 0);
    }
    Buffers.prototype.push = function() {
      for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
          throw new TypeError("Tried to push a non-buffer");
        }
      }
      for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.push(buf);
        this.length += buf.length;
      }
      return this.length;
    };
    Buffers.prototype.unshift = function() {
      for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
          throw new TypeError("Tried to unshift a non-buffer");
        }
      }
      for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.unshift(buf);
        this.length += buf.length;
      }
      return this.length;
    };
    Buffers.prototype.copy = function(dst, dStart, start, end) {
      return this.slice(start, end).copy(dst, dStart, 0, end - start);
    };
    Buffers.prototype.splice = function(i, howMany) {
      var buffers = this.buffers;
      var index = i >= 0 ? i : this.length - i;
      var reps = [].slice.call(arguments, 2);
      if (howMany === void 0) {
        howMany = this.length - index;
      } else if (howMany > this.length - index) {
        howMany = this.length - index;
      }
      for (var i = 0; i < reps.length; i++) {
        this.length += reps[i].length;
      }
      var removed = new Buffers();
      var bytes2 = 0;
      var startBytes = 0;
      for (var ii = 0; ii < buffers.length && startBytes + buffers[ii].length < index; ii++) {
        startBytes += buffers[ii].length;
      }
      if (index - startBytes > 0) {
        var start = index - startBytes;
        if (start + howMany < buffers[ii].length) {
          removed.push(buffers[ii].slice(start, start + howMany));
          var orig = buffers[ii];
          var buf0 = new Buffer(start);
          for (var i = 0; i < start; i++) {
            buf0[i] = orig[i];
          }
          var buf1 = new Buffer(orig.length - start - howMany);
          for (var i = start + howMany; i < orig.length; i++) {
            buf1[i - howMany - start] = orig[i];
          }
          if (reps.length > 0) {
            var reps_ = reps.slice();
            reps_.unshift(buf0);
            reps_.push(buf1);
            buffers.splice.apply(buffers, [ii, 1].concat(reps_));
            ii += reps_.length;
            reps = [];
          } else {
            buffers.splice(ii, 1, buf0, buf1);
            ii += 2;
          }
        } else {
          removed.push(buffers[ii].slice(start));
          buffers[ii] = buffers[ii].slice(0, start);
          ii++;
        }
      }
      if (reps.length > 0) {
        buffers.splice.apply(buffers, [ii, 0].concat(reps));
        ii += reps.length;
      }
      while (removed.length < howMany) {
        var buf = buffers[ii];
        var len = buf.length;
        var take = Math.min(len, howMany - removed.length);
        if (take === len) {
          removed.push(buf);
          buffers.splice(ii, 1);
        } else {
          removed.push(buf.slice(0, take));
          buffers[ii] = buffers[ii].slice(take);
        }
      }
      this.length -= removed.length;
      return removed;
    };
    Buffers.prototype.slice = function(i, j) {
      var buffers = this.buffers;
      if (j === void 0) j = this.length;
      if (i === void 0) i = 0;
      if (j > this.length) j = this.length;
      var startBytes = 0;
      for (var si = 0; si < buffers.length && startBytes + buffers[si].length <= i; si++) {
        startBytes += buffers[si].length;
      }
      var target = new Buffer(j - i);
      var ti = 0;
      for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
        var len = buffers[ii].length;
        var start = ti === 0 ? i - startBytes : 0;
        var end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
        buffers[ii].copy(target, ti, start, end);
        ti += end - start;
      }
      return target;
    };
    Buffers.prototype.pos = function(i) {
      if (i < 0 || i >= this.length) throw new Error("oob");
      var l = i, bi = 0, bu = null;
      for (; ; ) {
        bu = this.buffers[bi];
        if (l < bu.length) {
          return { buf: bi, offset: l };
        } else {
          l -= bu.length;
        }
        bi++;
      }
    };
    Buffers.prototype.get = function get(i) {
      var pos = this.pos(i);
      return this.buffers[pos.buf].get(pos.offset);
    };
    Buffers.prototype.set = function set(i, b) {
      var pos = this.pos(i);
      return this.buffers[pos.buf].set(pos.offset, b);
    };
    Buffers.prototype.indexOf = function(needle, offset) {
      if ("string" === typeof needle) {
        needle = new Buffer(needle);
      } else if (needle instanceof Buffer) {
      } else {
        throw new Error("Invalid type for a search string");
      }
      if (!needle.length) {
        return 0;
      }
      if (!this.length) {
        return -1;
      }
      var i = 0, j = 0, match = 0, mstart, pos = 0;
      if (offset) {
        var p = this.pos(offset);
        i = p.buf;
        j = p.offset;
        pos = offset;
      }
      for (; ; ) {
        while (j >= this.buffers[i].length) {
          j = 0;
          i++;
          if (i >= this.buffers.length) {
            return -1;
          }
        }
        var char = this.buffers[i][j];
        if (char == needle[match]) {
          if (match == 0) {
            mstart = {
              i,
              j,
              pos
            };
          }
          match++;
          if (match == needle.length) {
            return mstart.pos;
          }
        } else if (match != 0) {
          i = mstart.i;
          j = mstart.j;
          pos = mstart.pos;
          match = 0;
        }
        j++;
        pos++;
      }
    };
    Buffers.prototype.toBuffer = function() {
      return this.slice();
    };
    Buffers.prototype.toString = function(encoding2, start, end) {
      return this.slice(start, end).toString(encoding2);
    };
  }
});

// node_modules/binary/lib/vars.js
var require_vars = __commonJS({
  "node_modules/binary/lib/vars.js"(exports2, module2) {
    module2.exports = function(store) {
      function getset(name2, value) {
        var node = vars.store;
        var keys = name2.split(".");
        keys.slice(0, -1).forEach(function(k) {
          if (node[k] === void 0) node[k] = {};
          node = node[k];
        });
        var key = keys[keys.length - 1];
        if (arguments.length == 1) {
          return node[key];
        } else {
          return node[key] = value;
        }
      }
      var vars = {
        get: function(name2) {
          return getset(name2);
        },
        set: function(name2, value) {
          return getset(name2, value);
        },
        store: store || {}
      };
      return vars;
    };
  }
});

// node_modules/binary/index.js
var require_binary = __commonJS({
  "node_modules/binary/index.js"(exports2, module2) {
    var Chainsaw = require_chainsaw();
    var EventEmitter4 = require("events").EventEmitter;
    var Buffers = require_buffers();
    var Vars = require_vars();
    var Stream = require("stream").Stream;
    exports2 = module2.exports = function(bufOrEm, eventName) {
      if (Buffer.isBuffer(bufOrEm)) {
        return exports2.parse(bufOrEm);
      }
      var s = exports2.stream();
      if (bufOrEm && bufOrEm.pipe) {
        bufOrEm.pipe(s);
      } else if (bufOrEm) {
        bufOrEm.on(eventName || "data", function(buf) {
          s.write(buf);
        });
        bufOrEm.on("end", function() {
          s.end();
        });
      }
      return s;
    };
    exports2.stream = function(input) {
      if (input) return exports2.apply(null, arguments);
      var pending = null;
      function getBytes(bytes2, cb, skip) {
        pending = {
          bytes: bytes2,
          skip,
          cb: function(buf) {
            pending = null;
            cb(buf);
          }
        };
        dispatch();
      }
      var offset = null;
      function dispatch() {
        if (!pending) {
          if (caughtEnd) done = true;
          return;
        }
        if (typeof pending === "function") {
          pending();
        } else {
          var bytes2 = offset + pending.bytes;
          if (buffers.length >= bytes2) {
            var buf;
            if (offset == null) {
              buf = buffers.splice(0, bytes2);
              if (!pending.skip) {
                buf = buf.slice();
              }
            } else {
              if (!pending.skip) {
                buf = buffers.slice(offset, bytes2);
              }
              offset = bytes2;
            }
            if (pending.skip) {
              pending.cb();
            } else {
              pending.cb(buf);
            }
          }
        }
      }
      function builder(saw) {
        function next() {
          if (!done) saw.next();
        }
        var self = words(function(bytes2, cb) {
          return function(name2) {
            getBytes(bytes2, function(buf) {
              vars.set(name2, cb(buf));
              next();
            });
          };
        });
        self.tap = function(cb) {
          saw.nest(cb, vars.store);
        };
        self.into = function(key, cb) {
          if (!vars.get(key)) vars.set(key, {});
          var parent = vars;
          vars = Vars(parent.get(key));
          saw.nest(function() {
            cb.apply(this, arguments);
            this.tap(function() {
              vars = parent;
            });
          }, vars.store);
        };
        self.flush = function() {
          vars.store = {};
          next();
        };
        self.loop = function(cb) {
          var end = false;
          saw.nest(false, function loop() {
            this.vars = vars.store;
            cb.call(this, function() {
              end = true;
              next();
            }, vars.store);
            this.tap(function() {
              if (end) saw.next();
              else loop.call(this);
            }.bind(this));
          }, vars.store);
        };
        self.buffer = function(name2, bytes2) {
          if (typeof bytes2 === "string") {
            bytes2 = vars.get(bytes2);
          }
          getBytes(bytes2, function(buf) {
            vars.set(name2, buf);
            next();
          });
        };
        self.skip = function(bytes2) {
          if (typeof bytes2 === "string") {
            bytes2 = vars.get(bytes2);
          }
          getBytes(bytes2, function() {
            next();
          });
        };
        self.scan = function find(name2, search) {
          if (typeof search === "string") {
            search = new Buffer(search);
          } else if (!Buffer.isBuffer(search)) {
            throw new Error("search must be a Buffer or a string");
          }
          var taken = 0;
          pending = function() {
            var pos = buffers.indexOf(search, offset + taken);
            var i = pos - offset - taken;
            if (pos !== -1) {
              pending = null;
              if (offset != null) {
                vars.set(
                  name2,
                  buffers.slice(offset, offset + taken + i)
                );
                offset += taken + i + search.length;
              } else {
                vars.set(
                  name2,
                  buffers.slice(0, taken + i)
                );
                buffers.splice(0, taken + i + search.length);
              }
              next();
              dispatch();
            } else {
              i = Math.max(buffers.length - search.length - offset - taken, 0);
            }
            taken += i;
          };
          dispatch();
        };
        self.peek = function(cb) {
          offset = 0;
          saw.nest(function() {
            cb.call(this, vars.store);
            this.tap(function() {
              offset = null;
            });
          });
        };
        return self;
      }
      ;
      var stream = Chainsaw.light(builder);
      stream.writable = true;
      var buffers = Buffers();
      stream.write = function(buf) {
        buffers.push(buf);
        dispatch();
      };
      var vars = Vars();
      var done = false, caughtEnd = false;
      stream.end = function() {
        caughtEnd = true;
      };
      stream.pipe = Stream.prototype.pipe;
      Object.getOwnPropertyNames(EventEmitter4.prototype).forEach(function(name2) {
        stream[name2] = EventEmitter4.prototype[name2];
      });
      return stream;
    };
    exports2.parse = function parse3(buffer) {
      var self = words(function(bytes2, cb) {
        return function(name2) {
          if (offset + bytes2 <= buffer.length) {
            var buf = buffer.slice(offset, offset + bytes2);
            offset += bytes2;
            vars.set(name2, cb(buf));
          } else {
            vars.set(name2, null);
          }
          return self;
        };
      });
      var offset = 0;
      var vars = Vars();
      self.vars = vars.store;
      self.tap = function(cb) {
        cb.call(self, vars.store);
        return self;
      };
      self.into = function(key, cb) {
        if (!vars.get(key)) {
          vars.set(key, {});
        }
        var parent = vars;
        vars = Vars(parent.get(key));
        cb.call(self, vars.store);
        vars = parent;
        return self;
      };
      self.loop = function(cb) {
        var end = false;
        var ender = function() {
          end = true;
        };
        while (end === false) {
          cb.call(self, ender, vars.store);
        }
        return self;
      };
      self.buffer = function(name2, size) {
        if (typeof size === "string") {
          size = vars.get(size);
        }
        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
        offset += size;
        vars.set(name2, buf);
        return self;
      };
      self.skip = function(bytes2) {
        if (typeof bytes2 === "string") {
          bytes2 = vars.get(bytes2);
        }
        offset += bytes2;
        return self;
      };
      self.scan = function(name2, search) {
        if (typeof search === "string") {
          search = new Buffer(search);
        } else if (!Buffer.isBuffer(search)) {
          throw new Error("search must be a Buffer or a string");
        }
        vars.set(name2, null);
        for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {
          for (var j = 0; j < search.length && buffer[offset + i + j] === search[j]; j++) ;
          if (j === search.length) break;
        }
        vars.set(name2, buffer.slice(offset, offset + i));
        offset += i + search.length;
        return self;
      };
      self.peek = function(cb) {
        var was = offset;
        cb.call(self, vars.store);
        offset = was;
        return self;
      };
      self.flush = function() {
        vars.store = {};
        return self;
      };
      self.eof = function() {
        return offset >= buffer.length;
      };
      return self;
    };
    function decodeLEu(bytes2) {
      var acc = 0;
      for (var i = 0; i < bytes2.length; i++) {
        acc += Math.pow(256, i) * bytes2[i];
      }
      return acc;
    }
    function decodeBEu(bytes2) {
      var acc = 0;
      for (var i = 0; i < bytes2.length; i++) {
        acc += Math.pow(256, bytes2.length - i - 1) * bytes2[i];
      }
      return acc;
    }
    function decodeBEs(bytes2) {
      var val = decodeBEu(bytes2);
      if ((bytes2[0] & 128) == 128) {
        val -= Math.pow(256, bytes2.length);
      }
      return val;
    }
    function decodeLEs(bytes2) {
      var val = decodeLEu(bytes2);
      if ((bytes2[bytes2.length - 1] & 128) == 128) {
        val -= Math.pow(256, bytes2.length);
      }
      return val;
    }
    function words(decode) {
      var self = {};
      [1, 2, 4, 8].forEach(function(bytes2) {
        var bits = bytes2 * 8;
        self["word" + bits + "le"] = self["word" + bits + "lu"] = decode(bytes2, decodeLEu);
        self["word" + bits + "ls"] = decode(bytes2, decodeLEs);
        self["word" + bits + "be"] = self["word" + bits + "bu"] = decode(bytes2, decodeBEu);
        self["word" + bits + "bs"] = decode(bytes2, decodeBEs);
      });
      self.word8 = self.word8u = self.word8be;
      self.word8s = self.word8bs;
      return self;
    }
  }
});

// node_modules/unzip-stream/lib/matcher-stream.js
var require_matcher_stream = __commonJS({
  "node_modules/unzip-stream/lib/matcher-stream.js"(exports2, module2) {
    var Transform2 = require("stream").Transform;
    var util = require("util");
    function MatcherStream(patternDesc, matchFn) {
      if (!(this instanceof MatcherStream)) {
        return new MatcherStream();
      }
      Transform2.call(this);
      var p = typeof patternDesc === "object" ? patternDesc.pattern : patternDesc;
      this.pattern = Buffer.isBuffer(p) ? p : Buffer.from(p);
      this.requiredLength = this.pattern.length;
      if (patternDesc.requiredExtraSize) this.requiredLength += patternDesc.requiredExtraSize;
      this.data = new Buffer("");
      this.bytesSoFar = 0;
      this.matchFn = matchFn;
    }
    util.inherits(MatcherStream, Transform2);
    MatcherStream.prototype.checkDataChunk = function(ignoreMatchZero) {
      var enoughData = this.data.length >= this.requiredLength;
      if (!enoughData) {
        return;
      }
      var matchIndex = this.data.indexOf(this.pattern, ignoreMatchZero ? 1 : 0);
      if (matchIndex >= 0 && matchIndex + this.requiredLength > this.data.length) {
        if (matchIndex > 0) {
          var packet = this.data.slice(0, matchIndex);
          this.push(packet);
          this.bytesSoFar += matchIndex;
          this.data = this.data.slice(matchIndex);
        }
        return;
      }
      if (matchIndex === -1) {
        var packetLen = this.data.length - this.requiredLength + 1;
        var packet = this.data.slice(0, packetLen);
        this.push(packet);
        this.bytesSoFar += packetLen;
        this.data = this.data.slice(packetLen);
        return;
      }
      if (matchIndex > 0) {
        var packet = this.data.slice(0, matchIndex);
        this.data = this.data.slice(matchIndex);
        this.push(packet);
        this.bytesSoFar += matchIndex;
      }
      var finished = this.matchFn ? this.matchFn(this.data, this.bytesSoFar) : true;
      if (finished) {
        this.data = new Buffer("");
        return;
      }
      return true;
    };
    MatcherStream.prototype._transform = function(chunk, encoding2, cb) {
      this.data = Buffer.concat([this.data, chunk]);
      var firstIteration = true;
      while (this.checkDataChunk(!firstIteration)) {
        firstIteration = false;
      }
      cb();
    };
    MatcherStream.prototype._flush = function(cb) {
      if (this.data.length > 0) {
        var firstIteration = true;
        while (this.checkDataChunk(!firstIteration)) {
          firstIteration = false;
        }
      }
      if (this.data.length > 0) {
        this.push(this.data);
        this.data = null;
      }
      cb();
    };
    module2.exports = MatcherStream;
  }
});

// node_modules/unzip-stream/lib/entry.js
var require_entry = __commonJS({
  "node_modules/unzip-stream/lib/entry.js"(exports2, module2) {
    "use strict";
    var stream = require("stream");
    var inherits = require("util").inherits;
    function Entry() {
      if (!(this instanceof Entry)) {
        return new Entry();
      }
      stream.PassThrough.call(this);
      this.path = null;
      this.type = null;
      this.isDirectory = false;
    }
    inherits(Entry, stream.PassThrough);
    Entry.prototype.autodrain = function() {
      return this.pipe(new stream.Transform({ transform: function(d, e, cb) {
        cb();
      } }));
    };
    module2.exports = Entry;
  }
});

// node_modules/unzip-stream/lib/unzip-stream.js
var require_unzip_stream = __commonJS({
  "node_modules/unzip-stream/lib/unzip-stream.js"(exports2, module2) {
    "use strict";
    var binary = require_binary();
    var stream = require("stream");
    var util = require("util");
    var zlib = require("zlib");
    var MatcherStream = require_matcher_stream();
    var Entry = require_entry();
    var states = {
      STREAM_START: 0,
      START: 1,
      LOCAL_FILE_HEADER: 2,
      LOCAL_FILE_HEADER_SUFFIX: 3,
      FILE_DATA: 4,
      FILE_DATA_END: 5,
      DATA_DESCRIPTOR: 6,
      CENTRAL_DIRECTORY_FILE_HEADER: 7,
      CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX: 8,
      CDIR64_END: 9,
      CDIR64_END_DATA_SECTOR: 10,
      CDIR64_LOCATOR: 11,
      CENTRAL_DIRECTORY_END: 12,
      CENTRAL_DIRECTORY_END_COMMENT: 13,
      TRAILING_JUNK: 14,
      ERROR: 99
    };
    var FOUR_GIGS = 4294967296;
    var SIG_LOCAL_FILE_HEADER = 67324752;
    var SIG_DATA_DESCRIPTOR = 134695760;
    var SIG_CDIR_RECORD = 33639248;
    var SIG_CDIR64_RECORD_END = 101075792;
    var SIG_CDIR64_LOCATOR_END = 117853008;
    var SIG_CDIR_RECORD_END = 101010256;
    function UnzipStream(options2) {
      if (!(this instanceof UnzipStream)) {
        return new UnzipStream(options2);
      }
      stream.Transform.call(this);
      this.options = options2 || {};
      this.data = new Buffer("");
      this.state = states.STREAM_START;
      this.skippedBytes = 0;
      this.parsedEntity = null;
      this.outStreamInfo = {};
    }
    util.inherits(UnzipStream, stream.Transform);
    UnzipStream.prototype.processDataChunk = function(chunk) {
      var requiredLength;
      switch (this.state) {
        case states.STREAM_START:
        case states.START:
          requiredLength = 4;
          break;
        case states.LOCAL_FILE_HEADER:
          requiredLength = 26;
          break;
        case states.LOCAL_FILE_HEADER_SUFFIX:
          requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength;
          break;
        case states.DATA_DESCRIPTOR:
          requiredLength = 12;
          break;
        case states.CENTRAL_DIRECTORY_FILE_HEADER:
          requiredLength = 42;
          break;
        case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
          requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength + this.parsedEntity.fileCommentLength;
          break;
        case states.CDIR64_END:
          requiredLength = 52;
          break;
        case states.CDIR64_END_DATA_SECTOR:
          requiredLength = this.parsedEntity.centralDirectoryRecordSize - 44;
          break;
        case states.CDIR64_LOCATOR:
          requiredLength = 16;
          break;
        case states.CENTRAL_DIRECTORY_END:
          requiredLength = 18;
          break;
        case states.CENTRAL_DIRECTORY_END_COMMENT:
          requiredLength = this.parsedEntity.commentLength;
          break;
        case states.FILE_DATA:
          return 0;
        case states.FILE_DATA_END:
          return 0;
        case states.TRAILING_JUNK:
          if (this.options.debug) console.log("found", chunk.length, "bytes of TRAILING_JUNK");
          return chunk.length;
        default:
          return chunk.length;
      }
      var chunkLength = chunk.length;
      if (chunkLength < requiredLength) {
        return 0;
      }
      switch (this.state) {
        case states.STREAM_START:
        case states.START:
          var signature = chunk.readUInt32LE(0);
          switch (signature) {
            case SIG_LOCAL_FILE_HEADER:
              this.state = states.LOCAL_FILE_HEADER;
              break;
            case SIG_CDIR_RECORD:
              this.state = states.CENTRAL_DIRECTORY_FILE_HEADER;
              break;
            case SIG_CDIR64_RECORD_END:
              this.state = states.CDIR64_END;
              break;
            case SIG_CDIR64_LOCATOR_END:
              this.state = states.CDIR64_LOCATOR;
              break;
            case SIG_CDIR_RECORD_END:
              this.state = states.CENTRAL_DIRECTORY_END;
              break;
            default:
              var isStreamStart = this.state === states.STREAM_START;
              if (!isStreamStart && (signature & 65535) !== 19280 && this.skippedBytes < 26) {
                var remaining = signature;
                var toSkip = 4;
                for (var i = 1; i < 4 && remaining !== 0; i++) {
                  remaining = remaining >>> 8;
                  if ((remaining & 255) === 80) {
                    toSkip = i;
                    break;
                  }
                }
                this.skippedBytes += toSkip;
                if (this.options.debug) console.log("Skipped", this.skippedBytes, "bytes");
                return toSkip;
              }
              this.state = states.ERROR;
              var errMsg = isStreamStart ? "Not a valid zip file" : "Invalid signature in zip file";
              if (this.options.debug) {
                var sig = chunk.readUInt32LE(0);
                var asString;
                try {
                  asString = chunk.slice(0, 4).toString();
                } catch (e) {
                }
                console.log("Unexpected signature in zip file: 0x" + sig.toString(16), '"' + asString + '", skipped', this.skippedBytes, "bytes");
              }
              this.emit("error", new Error(errMsg));
              return chunk.length;
          }
          this.skippedBytes = 0;
          return requiredLength;
        case states.LOCAL_FILE_HEADER:
          this.parsedEntity = this._readFile(chunk);
          this.state = states.LOCAL_FILE_HEADER_SUFFIX;
          return requiredLength;
        case states.LOCAL_FILE_HEADER_SUFFIX:
          var entry = new Entry();
          var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
          entry.path = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
          var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
          var extra = this._readExtraFields(extraDataBuffer);
          if (extra && extra.parsed) {
            if (extra.parsed.path && !isUtf8) {
              entry.path = extra.parsed.path;
            }
            if (Number.isFinite(extra.parsed.uncompressedSize) && this.parsedEntity.uncompressedSize === FOUR_GIGS - 1) {
              this.parsedEntity.uncompressedSize = extra.parsed.uncompressedSize;
            }
            if (Number.isFinite(extra.parsed.compressedSize) && this.parsedEntity.compressedSize === FOUR_GIGS - 1) {
              this.parsedEntity.compressedSize = extra.parsed.compressedSize;
            }
          }
          this.parsedEntity.extra = extra.parsed || {};
          if (this.options.debug) {
            const debugObj = Object.assign({}, this.parsedEntity, {
              path: entry.path,
              flags: "0x" + this.parsedEntity.flags.toString(16),
              extraFields: extra && extra.debug
            });
            console.log("decoded LOCAL_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
          }
          this._prepareOutStream(this.parsedEntity, entry);
          this.emit("entry", entry);
          this.state = states.FILE_DATA;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_FILE_HEADER:
          this.parsedEntity = this._readCentralDirectoryEntry(chunk);
          this.state = states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
          var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
          var path2 = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
          var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
          var extra = this._readExtraFields(extraDataBuffer);
          if (extra && extra.parsed && extra.parsed.path && !isUtf8) {
            path2 = extra.parsed.path;
          }
          this.parsedEntity.extra = extra.parsed;
          var isUnix = (this.parsedEntity.versionMadeBy & 65280) >> 8 === 3;
          var unixAttrs, isSymlink;
          if (isUnix) {
            unixAttrs = this.parsedEntity.externalFileAttributes >>> 16;
            var fileType = unixAttrs >>> 12;
            isSymlink = (fileType & 10) === 10;
          }
          if (this.options.debug) {
            const debugObj = Object.assign({}, this.parsedEntity, {
              path: path2,
              flags: "0x" + this.parsedEntity.flags.toString(16),
              unixAttrs: unixAttrs && "0" + unixAttrs.toString(8),
              isSymlink,
              extraFields: extra.debug
            });
            console.log("decoded CENTRAL_DIRECTORY_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
          }
          this.state = states.START;
          return requiredLength;
        case states.CDIR64_END:
          this.parsedEntity = this._readEndOfCentralDirectory64(chunk);
          if (this.options.debug) {
            console.log("decoded CDIR64_END_RECORD:", this.parsedEntity);
          }
          this.state = states.CDIR64_END_DATA_SECTOR;
          return requiredLength;
        case states.CDIR64_END_DATA_SECTOR:
          this.state = states.START;
          return requiredLength;
        case states.CDIR64_LOCATOR:
          this.state = states.START;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_END:
          this.parsedEntity = this._readEndOfCentralDirectory(chunk);
          if (this.options.debug) {
            console.log("decoded CENTRAL_DIRECTORY_END:", this.parsedEntity);
          }
          this.state = states.CENTRAL_DIRECTORY_END_COMMENT;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_END_COMMENT:
          if (this.options.debug) {
            console.log("decoded CENTRAL_DIRECTORY_END_COMMENT:", chunk.slice(0, requiredLength).toString());
          }
          this.state = states.TRAILING_JUNK;
          return requiredLength;
        case states.ERROR:
          return chunk.length;
        // discard
        default:
          console.log("didn't handle state #", this.state, "discarding");
          return chunk.length;
      }
    };
    UnzipStream.prototype._prepareOutStream = function(vars, entry) {
      var self = this;
      var isDirectory2 = vars.uncompressedSize === 0 && /[\/\\]$/.test(entry.path);
      entry.path = entry.path.replace(/(?<=^|[/\\]+)[.][.]+(?=[/\\]+|$)/g, ".");
      entry.type = isDirectory2 ? "Directory" : "File";
      entry.isDirectory = isDirectory2;
      var fileSizeKnown = !(vars.flags & 8);
      if (fileSizeKnown) {
        entry.size = vars.uncompressedSize;
      }
      var isVersionSupported = vars.versionsNeededToExtract <= 45;
      this.outStreamInfo = {
        stream: null,
        limit: fileSizeKnown ? vars.compressedSize : -1,
        written: 0
      };
      if (!fileSizeKnown) {
        var pattern = new Buffer(4);
        pattern.writeUInt32LE(SIG_DATA_DESCRIPTOR, 0);
        var zip64Mode = vars.extra.zip64Mode;
        var extraSize = zip64Mode ? 20 : 12;
        var searchPattern = {
          pattern,
          requiredExtraSize: extraSize
        };
        var matcherStream = new MatcherStream(searchPattern, function(matchedChunk, sizeSoFar) {
          var vars2 = self._readDataDescriptor(matchedChunk, zip64Mode);
          var compressedSizeMatches = vars2.compressedSize === sizeSoFar;
          if (!zip64Mode && !compressedSizeMatches && sizeSoFar >= FOUR_GIGS) {
            var overflown = sizeSoFar - FOUR_GIGS;
            while (overflown >= 0) {
              compressedSizeMatches = vars2.compressedSize === overflown;
              if (compressedSizeMatches) break;
              overflown -= FOUR_GIGS;
            }
          }
          if (!compressedSizeMatches) {
            return;
          }
          self.state = states.FILE_DATA_END;
          var sliceOffset = zip64Mode ? 24 : 16;
          if (self.data.length > 0) {
            self.data = Buffer.concat([matchedChunk.slice(sliceOffset), self.data]);
          } else {
            self.data = matchedChunk.slice(sliceOffset);
          }
          return true;
        });
        this.outStreamInfo.stream = matcherStream;
      } else {
        this.outStreamInfo.stream = new stream.PassThrough();
      }
      var isEncrypted = vars.flags & 1 || vars.flags & 64;
      if (isEncrypted || !isVersionSupported) {
        var message = isEncrypted ? "Encrypted files are not supported!" : "Zip version " + Math.floor(vars.versionsNeededToExtract / 10) + "." + vars.versionsNeededToExtract % 10 + " is not supported";
        entry.skip = true;
        setImmediate(() => {
          self.emit("error", new Error(message));
        });
        this.outStreamInfo.stream.pipe(new Entry().autodrain());
        return;
      }
      var isCompressed = vars.compressionMethod > 0;
      if (isCompressed) {
        var inflater = zlib.createInflateRaw();
        inflater.on("error", function(err) {
          self.state = states.ERROR;
          self.emit("error", err);
        });
        this.outStreamInfo.stream.pipe(inflater).pipe(entry);
      } else {
        this.outStreamInfo.stream.pipe(entry);
      }
      if (this._drainAllEntries) {
        entry.autodrain();
      }
    };
    UnzipStream.prototype._readFile = function(data) {
      var vars = binary.parse(data).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
      return vars;
    };
    UnzipStream.prototype._readExtraFields = function(data) {
      var extra = {};
      var result = { parsed: extra };
      if (this.options.debug) {
        result.debug = [];
      }
      var index = 0;
      while (index < data.length) {
        var vars = binary.parse(data).skip(index).word16lu("extraId").word16lu("extraSize").vars;
        index += 4;
        var fieldType = void 0;
        switch (vars.extraId) {
          case 1:
            fieldType = "Zip64 extended information extra field";
            var z64vars = binary.parse(data.slice(index, index + vars.extraSize)).word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offsetToLocalHeader").word32lu("diskStartNumber").vars;
            if (z64vars.uncompressedSize !== null) {
              extra.uncompressedSize = z64vars.uncompressedSize;
            }
            if (z64vars.compressedSize !== null) {
              extra.compressedSize = z64vars.compressedSize;
            }
            extra.zip64Mode = true;
            break;
          case 10:
            fieldType = "NTFS extra field";
            break;
          case 21589:
            fieldType = "extended timestamp";
            var timestampFields = data.readUInt8(index);
            var offset = 1;
            if (vars.extraSize >= offset + 4 && timestampFields & 1) {
              extra.mtime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
            }
            if (vars.extraSize >= offset + 4 && timestampFields & 2) {
              extra.atime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
            }
            if (vars.extraSize >= offset + 4 && timestampFields & 4) {
              extra.ctime = new Date(data.readUInt32LE(index + offset) * 1e3);
            }
            break;
          case 28789:
            fieldType = "Info-ZIP Unicode Path Extra Field";
            var fieldVer = data.readUInt8(index);
            if (fieldVer === 1) {
              var offset = 1;
              var nameCrc32 = data.readUInt32LE(index + offset);
              offset += 4;
              var pathBuffer = data.slice(index + offset);
              extra.path = pathBuffer.toString();
            }
            break;
          case 13:
          case 22613:
            fieldType = vars.extraId === 13 ? "PKWARE Unix" : "Info-ZIP UNIX (type 1)";
            var offset = 0;
            if (vars.extraSize >= 8) {
              var atime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
              var mtime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
              extra.atime = atime;
              extra.mtime = mtime;
              if (vars.extraSize >= 12) {
                var uid = data.readUInt16LE(index + offset);
                offset += 2;
                var gid = data.readUInt16LE(index + offset);
                offset += 2;
                extra.uid = uid;
                extra.gid = gid;
              }
            }
            break;
          case 30805:
            fieldType = "Info-ZIP UNIX (type 2)";
            var offset = 0;
            if (vars.extraSize >= 4) {
              var uid = data.readUInt16LE(index + offset);
              offset += 2;
              var gid = data.readUInt16LE(index + offset);
              offset += 2;
              extra.uid = uid;
              extra.gid = gid;
            }
            break;
          case 30837:
            fieldType = "Info-ZIP New Unix";
            var offset = 0;
            var extraVer = data.readUInt8(index);
            offset += 1;
            if (extraVer === 1) {
              var uidSize = data.readUInt8(index + offset);
              offset += 1;
              if (uidSize <= 6) {
                extra.uid = data.readUIntLE(index + offset, uidSize);
              }
              offset += uidSize;
              var gidSize = data.readUInt8(index + offset);
              offset += 1;
              if (gidSize <= 6) {
                extra.gid = data.readUIntLE(index + offset, gidSize);
              }
            }
            break;
          case 30062:
            fieldType = "ASi Unix";
            var offset = 0;
            if (vars.extraSize >= 14) {
              var crc = data.readUInt32LE(index + offset);
              offset += 4;
              var mode = data.readUInt16LE(index + offset);
              offset += 2;
              var sizdev = data.readUInt32LE(index + offset);
              offset += 4;
              var uid = data.readUInt16LE(index + offset);
              offset += 2;
              var gid = data.readUInt16LE(index + offset);
              offset += 2;
              extra.mode = mode;
              extra.uid = uid;
              extra.gid = gid;
              if (vars.extraSize > 14) {
                var start = index + offset;
                var end = index + vars.extraSize - 14;
                var symlinkName = this._decodeString(data.slice(start, end));
                extra.symlink = symlinkName;
              }
            }
            break;
        }
        if (this.options.debug) {
          result.debug.push({
            extraId: "0x" + vars.extraId.toString(16),
            description: fieldType,
            data: data.slice(index, index + vars.extraSize).inspect()
          });
        }
        index += vars.extraSize;
      }
      return result;
    };
    UnzipStream.prototype._readDataDescriptor = function(data, zip64Mode) {
      if (zip64Mode) {
        var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word64lu("compressedSize").word64lu("uncompressedSize").vars;
        return vars;
      }
      var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
      return vars;
    };
    UnzipStream.prototype._readCentralDirectoryEntry = function(data) {
      var vars = binary.parse(data).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
      return vars;
    };
    UnzipStream.prototype._readEndOfCentralDirectory64 = function(data) {
      var vars = binary.parse(data).word64lu("centralDirectoryRecordSize").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskNumberWithCentralDirectoryStart").word64lu("centralDirectoryEntries").word64lu("totalCentralDirectoryEntries").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
      return vars;
    };
    UnzipStream.prototype._readEndOfCentralDirectory = function(data) {
      var vars = binary.parse(data).word16lu("diskNumber").word16lu("diskStart").word16lu("centralDirectoryEntries").word16lu("totalCentralDirectoryEntries").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
      return vars;
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0 ";
    UnzipStream.prototype._decodeString = function(buffer, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8");
      }
      if (this.options.decodeString) {
        return this.options.decodeString(buffer);
      }
      let result = "";
      for (var i = 0; i < buffer.length; i++) {
        result += cp437[buffer[i]];
      }
      return result;
    };
    UnzipStream.prototype._parseOrOutput = function(encoding2, cb) {
      var consume;
      while ((consume = this.processDataChunk(this.data)) > 0) {
        this.data = this.data.slice(consume);
        if (this.data.length === 0) break;
      }
      if (this.state === states.FILE_DATA) {
        if (this.outStreamInfo.limit >= 0) {
          var remaining = this.outStreamInfo.limit - this.outStreamInfo.written;
          var packet;
          if (remaining < this.data.length) {
            packet = this.data.slice(0, remaining);
            this.data = this.data.slice(remaining);
          } else {
            packet = this.data;
            this.data = new Buffer("");
          }
          this.outStreamInfo.written += packet.length;
          if (this.outStreamInfo.limit === this.outStreamInfo.written) {
            this.state = states.START;
            this.outStreamInfo.stream.end(packet, encoding2, cb);
          } else {
            this.outStreamInfo.stream.write(packet, encoding2, cb);
          }
        } else {
          var packet = this.data;
          this.data = new Buffer("");
          this.outStreamInfo.written += packet.length;
          var outputStream = this.outStreamInfo.stream;
          outputStream.write(packet, encoding2, () => {
            if (this.state === states.FILE_DATA_END) {
              this.state = states.START;
              return outputStream.end(cb);
            }
            cb();
          });
        }
        return;
      }
      cb();
    };
    UnzipStream.prototype.drainAll = function() {
      this._drainAllEntries = true;
    };
    UnzipStream.prototype._transform = function(chunk, encoding2, cb) {
      var self = this;
      if (self.data.length > 0) {
        self.data = Buffer.concat([self.data, chunk]);
      } else {
        self.data = chunk;
      }
      var startDataLength = self.data.length;
      var done = function() {
        if (self.data.length > 0 && self.data.length < startDataLength) {
          startDataLength = self.data.length;
          self._parseOrOutput(encoding2, done);
          return;
        }
        cb();
      };
      self._parseOrOutput(encoding2, done);
    };
    UnzipStream.prototype._flush = function(cb) {
      var self = this;
      if (self.data.length > 0) {
        self._parseOrOutput("buffer", function() {
          if (self.data.length > 0) return setImmediate(function() {
            self._flush(cb);
          });
          cb();
        });
        return;
      }
      if (self.state === states.FILE_DATA) {
        return cb(new Error("Stream finished in an invalid state, uncompression failed"));
      }
      setImmediate(cb);
    };
    module2.exports = UnzipStream;
  }
});

// node_modules/unzip-stream/lib/parser-stream.js
var require_parser_stream = __commonJS({
  "node_modules/unzip-stream/lib/parser-stream.js"(exports2, module2) {
    var Transform2 = require("stream").Transform;
    var util = require("util");
    var UnzipStream = require_unzip_stream();
    function ParserStream(opts) {
      if (!(this instanceof ParserStream)) {
        return new ParserStream(opts);
      }
      var transformOpts = opts || {};
      Transform2.call(this, { readableObjectMode: true });
      this.opts = opts || {};
      this.unzipStream = new UnzipStream(this.opts);
      var self = this;
      this.unzipStream.on("entry", function(entry) {
        self.push(entry);
      });
      this.unzipStream.on("error", function(error) {
        self.emit("error", error);
      });
    }
    util.inherits(ParserStream, Transform2);
    ParserStream.prototype._transform = function(chunk, encoding2, cb) {
      this.unzipStream.write(chunk, encoding2, cb);
    };
    ParserStream.prototype._flush = function(cb) {
      var self = this;
      this.unzipStream.end(function() {
        process.nextTick(function() {
          self.emit("close");
        });
        cb();
      });
    };
    ParserStream.prototype.on = function(eventName, fn) {
      if (eventName === "entry") {
        return Transform2.prototype.on.call(this, "data", fn);
      }
      return Transform2.prototype.on.call(this, eventName, fn);
    };
    ParserStream.prototype.drainAll = function() {
      this.unzipStream.drainAll();
      return this.pipe(new Transform2({ objectMode: true, transform: function(d, e, cb) {
        cb();
      } }));
    };
    module2.exports = ParserStream;
  }
});

// node_modules/unzip-stream/node_modules/mkdirp/index.js
var require_mkdirp2 = __commonJS({
  "node_modules/unzip-stream/node_modules/mkdirp/index.js"(exports2, module2) {
    var path2 = require("path");
    var fs2 = require("fs");
    var _0777 = parseInt("0777", 8);
    module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    function mkdirP(p, opts, f, made) {
      if (typeof opts === "function") {
        f = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs2;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made) made = null;
      var cb = f || /* istanbul ignore next */
      function() {
      };
      p = path2.resolve(p);
      xfs.mkdir(p, mode, function(er) {
        if (!er) {
          made = made || p;
          return cb(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path2.dirname(p) === p) return cb(er);
            mkdirP(path2.dirname(p), opts, function(er2, made2) {
              if (er2) cb(er2, made2);
              else mkdirP(p, opts, cb, made2);
            });
            break;
          // In the case of any other error, just see if there's a dir
          // there already.  If so, then hooray!  If not, then something
          // is borked.
          default:
            xfs.stat(p, function(er2, stat) {
              if (er2 || !stat.isDirectory()) cb(er, made);
              else cb(null, made);
            });
            break;
        }
      });
    }
    mkdirP.sync = function sync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs2;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made) made = null;
      p = path2.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        switch (err0.code) {
          case "ENOENT":
            made = sync(path2.dirname(p), opts, made);
            sync(p, opts, made);
            break;
          // In the case of any other error, just see if there's a dir
          // there already.  If so, then hooray!  If not, then something
          // is borked.
          default:
            var stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0;
            }
            if (!stat.isDirectory()) throw err0;
            break;
        }
      }
      return made;
    };
  }
});

// node_modules/unzip-stream/lib/extract.js
var require_extract2 = __commonJS({
  "node_modules/unzip-stream/lib/extract.js"(exports2, module2) {
    var fs2 = require("fs");
    var path2 = require("path");
    var util = require("util");
    var mkdirp = require_mkdirp2();
    var Transform2 = require("stream").Transform;
    var UnzipStream = require_unzip_stream();
    function Extract(opts) {
      if (!(this instanceof Extract))
        return new Extract(opts);
      Transform2.call(this);
      this.opts = opts || {};
      this.unzipStream = new UnzipStream(this.opts);
      this.unfinishedEntries = 0;
      this.afterFlushWait = false;
      this.createdDirectories = {};
      var self = this;
      this.unzipStream.on("entry", this._processEntry.bind(this));
      this.unzipStream.on("error", function(error) {
        self.emit("error", error);
      });
    }
    util.inherits(Extract, Transform2);
    Extract.prototype._transform = function(chunk, encoding2, cb) {
      this.unzipStream.write(chunk, encoding2, cb);
    };
    Extract.prototype._flush = function(cb) {
      var self = this;
      var allDone = function() {
        process.nextTick(function() {
          self.emit("close");
        });
        cb();
      };
      this.unzipStream.end(function() {
        if (self.unfinishedEntries > 0) {
          self.afterFlushWait = true;
          return self.on("await-finished", allDone);
        }
        allDone();
      });
    };
    Extract.prototype._processEntry = function(entry) {
      var self = this;
      var destPath = path2.join(this.opts.path, entry.path);
      var directory = entry.isDirectory ? destPath : path2.dirname(destPath);
      this.unfinishedEntries++;
      var writeFileFn = function() {
        var pipedStream = fs2.createWriteStream(destPath);
        pipedStream.on("close", function() {
          self.unfinishedEntries--;
          self._notifyAwaiter();
        });
        pipedStream.on("error", function(error) {
          self.emit("error", error);
        });
        entry.pipe(pipedStream);
      };
      if (this.createdDirectories[directory] || directory === ".") {
        return writeFileFn();
      }
      mkdirp(directory, function(err) {
        if (err) return self.emit("error", err);
        self.createdDirectories[directory] = true;
        if (entry.isDirectory) {
          self.unfinishedEntries--;
          self._notifyAwaiter();
          return;
        }
        writeFileFn();
      });
    };
    Extract.prototype._notifyAwaiter = function() {
      if (this.afterFlushWait && this.unfinishedEntries === 0) {
        this.emit("await-finished");
        this.afterFlushWait = false;
      }
    };
    module2.exports = Extract;
  }
});

// node_modules/unzip-stream/unzip.js
var require_unzip = __commonJS({
  "node_modules/unzip-stream/unzip.js"(exports2) {
    "use strict";
    exports2.Parse = require_parser_stream();
    exports2.Extract = require_extract2();
  }
});

// src/model/download.ts
function getEtag(headers) {
  let header = headers["etag"];
  if (typeof header !== "string") return void 0;
  header = header.replace(/^W\//, "");
  if (!header.startsWith('"') || !header.endsWith('"')) return void 0;
  return header.slice(1, -1);
}
function getExtname(dispositionHeader) {
  const contentDisposition = require_content_disposition();
  let disposition = contentDisposition.parse(dispositionHeader);
  let filename = disposition.parameters.filename;
  if (filename) return path.extname(filename);
  return void 0;
}
function download(urlInput, options2, token) {
  let url = toURL(urlInput);
  let { etagAlgorithm } = options2;
  let { dest, onProgress, extract } = options2;
  if (!dest || !path.isAbsolute(dest)) {
    throw new Error(`Invalid dest path: ${dest}`);
  }
  if (!fs.existsSync(dest)) {
    fs.mkdirSync(dest, { recursive: true });
  } else {
    let stat = fs.statSync(dest);
    if (stat && !stat.isDirectory()) {
      throw new Error(`${dest} exists, but not directory!`);
    }
  }
  let mod = getRequestModule(url);
  let opts = resolveRequestOptions(url, options2);
  if (!opts.agent && options2.agent) opts.agent = options2.agent;
  let extname = path.extname(url.pathname);
  return new Promise((resolve, reject) => {
    if (token) {
      let disposable = token.onCancellationRequested(() => {
        disposable.dispose();
        req.destroy(new Error("request aborted"));
      });
    }
    let timer;
    const req = mod.request(opts, (res) => {
      if (res.statusCode >= 200 && res.statusCode < 300 || res.statusCode === 1223) {
        let headers = res.headers;
        let dispositionHeader = headers["content-disposition"];
        let etag = getEtag(headers);
        let checkEtag = etag && typeof etagAlgorithm === "string";
        if (!extname && dispositionHeader) {
          extname = getExtname(dispositionHeader);
        }
        if (extract === true) {
          if (extname === ".zip" || headers["content-type"] == "application/zip") {
            extract = "unzip";
          } else if (extname == ".tgz") {
            extract = "untar";
          } else {
            reject(new Error(`Unable to detect extract method for ${url}`));
            return;
          }
        }
        let total = Number(headers["content-length"]);
        let hasTotal = !isNaN(total);
        let cur = 0;
        res.on("error", (err) => {
          reject(new Error(`Unable to connect ${url}: ${err.message}`));
        });
        let hash = checkEtag ? crypto.createHash(etagAlgorithm) : void 0;
        res.on("data", (chunk) => {
          cur += chunk.length;
          if (hash) hash.update(chunk);
          if (hasTotal) {
            let percent = (cur / total * 100).toFixed(1);
            if (typeof onProgress === "function") {
              onProgress(percent);
            } else {
              logger27.info(`Download ${url} progress ${percent}%`);
            }
          }
        });
        res.on("end", () => {
          clearTimeout(timer);
          timer = void 0;
          logger27.info("Download completed:", url);
        });
        let stream;
        if (extract === "untar") {
          const tar = require_tar();
          stream = res.pipe(tar.x({ strip: options2.strip ?? 1, C: dest }));
        } else if (extract === "unzip") {
          const unzip = require_unzip();
          stream = res.pipe(unzip.Extract({ path: dest }));
        } else {
          dest = path.join(dest, `${v1_default()}${extname}`);
          stream = res.pipe(fs.createWriteStream(dest));
        }
        stream.on("finish", () => {
          if (hash) {
            if (hash.digest("hex") !== etag) {
              reject(new Error(`Etag check failed by ${etagAlgorithm}, content not match.`));
              return;
            }
          }
          logger27.info(`Downloaded ${url} => ${dest}`);
          setTimeout(() => {
            resolve(dest);
          }, 100);
        });
        stream.on("error", reject);
      } else {
        reject(new Error(`Invalid response from ${url}: ${res.statusCode}`));
      }
    });
    req.on("error", (e) => {
      if (opts.agent && e["code"] == "ECONNRESET") {
        timer = setTimeout(() => {
          reject(e);
        }, timeout);
      } else {
        clearTimeout(timer);
        if (opts.agent && opts.agent.proxy) {
          reject(new Error(`Request failed using proxy ${opts.agent.proxy.host}: ${e.message}`));
          return;
        }
        reject(e);
      }
    });
    req.on("timeout", () => {
      req.destroy(new Error(`request timeout after ${options2.timeout}ms`));
    });
    if (typeof options2.timeout === "number" && options2.timeout) {
      req.setTimeout(options2.timeout);
    }
    req.end();
  });
}
var logger27;
var init_download = __esm({
  "src/model/download.ts"() {
    "use strict";
    init_esm_node();
    init_logger();
    init_node();
    init_fetch();
    logger27 = createLogger("model-download");
  }
});

// src/extension/installer.ts
function registryUrl(home = os.homedir()) {
  let res;
  let filepath = path.join(home, ".npmrc");
  if (fs.existsSync(filepath)) {
    try {
      let content = fs.readFileSync(filepath, "utf8");
      let uri;
      for (let line of content.split(/\r?\n/)) {
        if (line.startsWith("#")) continue;
        let ms = line.match(/^(.*?)=(.*)$/);
        if (ms && ms[1] === "coc.nvim:registry") {
          uri = ms[2];
        }
      }
      if (uri) res = new import_url3.URL(uri);
    } catch (e) {
      logger28.debug("Error on parse .npmrc:", e);
    }
  }
  return res ?? new import_url3.URL("https://registry.npmjs.org");
}
function isNpmCommand(exePath) {
  let name2 = path.basename(exePath);
  return name2 === "npm" || name2 === "npm.CMD";
}
function isYarn(exePath) {
  let name2 = path.basename(exePath);
  return ["yarn", "yarn.CMD", "yarnpkg", "yarnpkg.CMD"].includes(name2);
}
function isPnpm(exePath) {
  let name2 = path.basename(exePath);
  return name2 === "pnpm" || name2 === "pnpm.CMD";
}
function isSymbolicLink(folder) {
  if (fs.existsSync(folder)) {
    let stat = fs.lstatSync(folder);
    if (stat.isSymbolicLink()) {
      return true;
    }
  }
  return false;
}
function getDependencies(obj) {
  return Object.keys(obj.dependencies ?? {}).filter((id2) => !local_dependencies.includes(id2));
}
var import_events29, import_url3, logger28, local_dependencies, Installer;
var init_installer = __esm({
  "src/extension/installer.ts"() {
    "use strict";
    import_events29 = require("events");
    import_url3 = require("url");
    init_esm_node();
    init_logger();
    init_download();
    init_fetch();
    init_fs();
    init_node();
    init_string();
    init_workspace();
    logger28 = createLogger("extension-installer");
    local_dependencies = ["coc.nvim", "esbuild", "webpack", "@types/node"];
    Installer = class extends import_events29.EventEmitter {
      constructor(root, npm, def) {
        super();
        this.root = root;
        this.npm = npm;
        this.def = def;
        if (/^https?:/.test(def)) {
          this.url = def;
        } else {
          let ms = def.match(/(.+)@([^/]+)$/);
          if (ms) {
            this.name = ms[1];
            this.version = ms[2];
          } else {
            this.name = def;
          }
        }
      }
      get info() {
        return { name: this.name, version: this.version };
      }
      async getInfo() {
        if (this.url) return await this.getInfoFromUri();
        let registry = registryUrl();
        this.log(`Get info from ${registry}`);
        let buffer = await this.fetch(new import_url3.URL(this.name, registry), { timeout: 1e4, buffer: true });
        let res = JSON.parse(buffer.toString());
        if (!this.version) this.version = res["dist-tags"]["latest"];
        let obj = res["versions"][this.version];
        if (!obj) throw new Error(`${this.def} doesn't exists in ${registry}.`);
        let requiredVersion = obj["engines"] && obj["engines"]["coc"];
        if (!requiredVersion) throw new Error(`${this.def} is not a valid coc extension, "engines" field with coc property required.`);
        return {
          "dist.tarball": obj["dist"]["tarball"],
          "engines.coc": requiredVersion,
          version: obj["version"],
          name: res.name
        };
      }
      async getInfoFromUri() {
        let { url } = this;
        if (!url.startsWith("https://github.com")) {
          throw new Error(`"${url}" is not supported, coc.nvim support github.com only`);
        }
        url = url.replace(/\/$/, "");
        let branch = "master";
        if (url.includes("@")) {
          let idx = url.indexOf("@");
          branch = url.substr(idx + 1);
          url = url.substring(0, idx);
        }
        let fileUrl = url.replace("github.com", "raw.githubusercontent.com") + `/${branch}/package.json`;
        this.log(`Get info from ${fileUrl}`);
        let content = await this.fetch(fileUrl, { timeout: 1e4 });
        let obj = typeof content == "string" ? JSON.parse(content) : content;
        this.name = obj.name;
        return {
          "dist.tarball": `${url}/archive/${branch}.tar.gz`,
          "engines.coc": obj["engines"] ? obj["engines"]["coc"] : null,
          name: obj.name,
          version: obj.version
        };
      }
      log(msg, isProgress = false) {
        this.emit("message", msg, isProgress);
      }
      async install() {
        this.log(`Using npm from: ${this.npm}`);
        let info = await this.getInfo();
        logger28.info(`Fetched info of ${this.def}`, info);
        let { name: name2, version: version2 } = info;
        let required = toText(info["engines.coc"]).replace(/^\^/, ">=");
        if (required && !semver.satisfies(workspace_default.version, required)) {
          throw new Error(`${name2} ${info.version} requires coc.nvim >= ${required}, please update coc.nvim.`);
        }
        let updated = await this.doInstall(info);
        return { name: name2, updated, version: version2, url: this.url, folder: path.join(this.root, info.name) };
      }
      async update(url) {
        if (url) this.url = url;
        let version2;
        if (this.name) {
          let folder = path.join(this.root, this.name);
          if (isSymbolicLink(folder)) {
            this.log(`Skipped update for symbol link`);
            return;
          }
          let obj = loadJson(path.join(folder, "package.json"));
          version2 = obj.version;
        }
        this.log(`Using npm from: ${this.npm}`);
        let info = await this.getInfo();
        if (version2 && info.version && semver.gte(version2, info.version)) {
          this.log(`Current version ${version2} is up to date.`);
          return;
        }
        let required = info["engines.coc"] ? info["engines.coc"].replace(/^\^/, ">=") : "";
        if (required && !semver.satisfies(workspace_default.version, required)) {
          throw new Error(`${info.version} requires coc.nvim ${required}, please update coc.nvim.`);
        }
        let succeed = await this.doInstall(info);
        if (!succeed) return;
        let jsonFile = path.join(this.root, info.name, "package.json");
        this.log(`Updated to v${info.version}`);
        return path.dirname(jsonFile);
      }
      getInstallArguments(exePath, url) {
        let env = "production";
        let args = ["install", "--ignore-scripts", "--no-lockfile"];
        if (url && url.startsWith("https://github.com")) {
          args = ["install"];
          env = "development";
        } else {
          if (isNpmCommand(exePath)) {
            args.push("--omit=dev");
            args.push("--legacy-peer-deps");
            args.push("--no-global");
          }
          if (isYarn(exePath)) {
            args.push("--production");
            args.push("--ignore-engines");
          }
          if (isPnpm(exePath)) {
            args.push("--production");
            args.push("--config.strict-peer-dependencies=false");
          }
        }
        return { env, args };
      }
      readLines(key, stream) {
        const rl = readline.createInterface({
          input: stream
        });
        rl.on("line", (line) => {
          this.log(`${key} ${line}`, true);
        });
      }
      installDependencies(folder, dependencies) {
        if (dependencies.length == 0) return Promise.resolve();
        return new Promise((resolve, reject) => {
          let { env, args } = this.getInstallArguments(this.npm, this.url);
          this.log(`Installing dependencies by: ${this.npm} ${args.join(" ")}.`);
          const cmd = process.platform === "win32" && this.npm.includes(" ") ? `"${this.npm}"` : this.npm;
          const child = child_process.spawn(cmd, args, {
            cwd: folder,
            shell: process.platform === "win32",
            env: Object.assign(process.env, { NODE_ENV: env })
          });
          this.readLines("[npm stdout]", child.stdout);
          this.readLines("[npm stderr]", child.stderr);
          child.stderr.setEncoding("utf8");
          child.stdout.setEncoding("utf8");
          child.on("error", reject);
          child.on("exit", (code) => {
            if (code) {
              reject(new Error(`${this.npm} install exited with ${code}`));
              return;
            }
            resolve();
          });
        });
      }
      async doInstall(info) {
        let dest = path.join(this.root, info.name);
        if (isSymbolicLink(dest)) return false;
        let key = info.name.replace(/\//g, "_");
        let downloadFolder = path.join(this.root, `${key}-${v4_default()}`);
        let url = info["dist.tarball"];
        this.log(`Downloading from ${url}`);
        let etagAlgorithm = url.startsWith("https://registry.npmjs.org") ? "md5" : void 0;
        try {
          await this.download(url, {
            dest: downloadFolder,
            etagAlgorithm,
            extract: "untar",
            onProgress: (p) => this.log(`Download progress ${p}%`, true)
          });
          this.log(`Extension download at ${downloadFolder}`);
          let obj = loadJson(path.join(downloadFolder, "package.json"));
          await this.installDependencies(downloadFolder, getDependencies(obj));
        } catch (e) {
          fs.rmSync(downloadFolder, { recursive: true, force: true });
          throw e;
        }
        this.log(`Download extension ${info.name}@${info.version} at ${downloadFolder}`);
        fs.mkdirSync(path.dirname(dest), { recursive: true });
        if (fs.existsSync(dest)) fs.rmSync(dest, { force: true, recursive: true });
        fs.renameSync(downloadFolder, dest);
        this.log(`Move extension ${info.name}@${info.version} to ${dest}`);
        return true;
      }
      async download(url, options2) {
        return await download(url, options2);
      }
      async fetch(url, options2 = {}) {
        return await fetch(url, options2);
      }
    };
  }
});

// src/model/memos.ts
var Memos;
var init_memos = __esm({
  "src/model/memos.ts"() {
    "use strict";
    init_fs();
    init_node();
    init_object();
    Memos = class {
      constructor(filepath) {
        this.filepath = filepath;
        if (!fs.existsSync(filepath)) {
          fs.writeFileSync(filepath, "{}", "utf8");
        }
      }
      merge(filepath) {
        if (!fs.existsSync(filepath)) return;
        let obj = loadJson(filepath);
        let current = loadJson(this.filepath);
        Object.assign(current, obj);
        writeJson(this.filepath, current);
        fs.unlinkSync(filepath);
      }
      fetchContent(id2, key) {
        let res = loadJson(this.filepath);
        let obj = res[id2];
        if (!obj) return void 0;
        return obj[key];
      }
      async update(id2, key, value) {
        let { filepath } = this;
        let current = loadJson(filepath);
        current[id2] = current[id2] || {};
        if (value !== void 0) {
          current[id2][key] = deepClone(value);
        } else {
          delete current[id2][key];
        }
        writeJson(filepath, current);
      }
      createMemento(id2) {
        return {
          get: (key, defaultValue2) => {
            let res = this.fetchContent(id2, key);
            return res === void 0 ? defaultValue2 : res;
          },
          update: async (key, value) => {
            await this.update(id2, key, value);
          }
        };
      }
    };
  }
});

// src/list/commandTask.ts
var import_events30, spawn, logger29, CommandTask;
var init_commandTask = __esm({
  "src/list/commandTask.ts"() {
    "use strict";
    import_events30 = require("events");
    init_logger();
    init_util();
    init_node();
    init_workspace();
    spawn = child_process.spawn;
    logger29 = createLogger("list-commandTask");
    CommandTask = class extends import_events30.EventEmitter {
      constructor(opt) {
        super();
        this.opt = opt;
        this.disposables = [];
        this.start();
      }
      start() {
        let { cmd, args, cwd: cwd2, onLine } = this.opt;
        let proc = spawn(cmd, args, { cwd: cwd2 || workspace_default.cwd, windowsHide: true, shell: process.platform === "win32" });
        this.disposables.push({
          dispose: () => {
            proc.kill();
          }
        });
        proc.on("error", (e) => {
          this.emit("error", e.message);
        });
        proc.stderr.on("data", (chunk) => {
          logger29.error(`[${cmd} Error]`, chunk.toString("utf8"));
        });
        const rl = readline.createInterface(proc.stdout);
        rl.on("line", (line) => {
          let res = onLine(line);
          if (res) this.emit("data", res);
        });
        rl.on("close", () => {
          this.emit("end");
        });
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/list/configuration.ts
var validKeys, ListConfiguration, configuration_default;
var init_configuration3 = __esm({
  "src/list/configuration.ts"() {
    "use strict";
    init_window();
    init_workspace();
    validKeys = [
      "<esc>",
      "<space>",
      "<tab>",
      "<s-tab>",
      "<bs>",
      "<right>",
      "<left>",
      "<up>",
      "<down>",
      "<home>",
      "<end>",
      "<cr>",
      "<FocusGained>",
      "<FocusLost>",
      "<ScrollWheelUp>",
      "<ScrollWheelDown>",
      "<LeftMouse>",
      "<LeftDrag>",
      "<LeftRelease>",
      "<2-LeftMouse>",
      "<C-space>",
      "<C-_>",
      "<C-a>",
      "<C-b>",
      "<C-c>",
      "<C-d>",
      "<C-e>",
      "<C-f>",
      "<C-g>",
      "<C-h>",
      "<C-i>",
      "<C-j>",
      "<C-k>",
      "<C-l>",
      "<C-m>",
      "<C-n>",
      "<C-o>",
      "<C-p>",
      "<C-q>",
      "<C-r>",
      "<C-s>",
      "<C-t>",
      "<C-u>",
      "<C-v>",
      "<C-w>",
      "<C-x>",
      "<C-y>",
      "<C-z>",
      "<A-a>",
      "<A-b>",
      "<A-c>",
      "<A-d>",
      "<A-e>",
      "<A-f>",
      "<A-g>",
      "<A-h>",
      "<A-i>",
      "<A-j>",
      "<A-k>",
      "<A-l>",
      "<A-m>",
      "<A-n>",
      "<A-o>",
      "<A-p>",
      "<A-q>",
      "<A-r>",
      "<A-s>",
      "<A-t>",
      "<A-u>",
      "<A-v>",
      "<A-w>",
      "<A-x>",
      "<A-y>",
      "<A-z>",
      "<A-bs>"
    ];
    ListConfiguration = class {
      get debounceTime() {
        return this.get("interactiveDebounceTime", 100);
      }
      get extendedSearchMode() {
        return this.get("extendedSearchMode", true);
      }
      get smartcase() {
        return this.get("smartCase", false);
      }
      get signOffset() {
        return this.get("signOffset", 900);
      }
      get(key, defaultValue2) {
        let configuration2 = workspace_default.initialConfiguration;
        return configuration2.get("list." + key, defaultValue2);
      }
      get previousKey() {
        return this.fixKey(this.get("previousKeymap", "<C-j>"));
      }
      get nextKey() {
        return this.fixKey(this.get("nextKeymap", "<C-k>"));
      }
      fixKey(key) {
        if (validKeys.includes(key)) return key;
        let find = validKeys.find((s) => s.toLowerCase() == key.toLowerCase());
        if (find) return find;
        void window_default.showErrorMessage(`Configured key "${key}" not supported.`);
        return null;
      }
    };
    configuration_default = new ListConfiguration();
  }
});

// src/list/basic.ts
function toVimFiletype(filetype) {
  switch (filetype) {
    case "latex":
      return "tex";
    default:
      return filetype;
  }
}
var BasicList;
var init_basic = __esm({
  "src/list/basic.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_util();
    init_fs();
    init_position();
    init_string();
    init_workspace();
    init_commandTask();
    init_configuration3();
    BasicList = class {
      constructor() {
        this.defaultAction = "open";
        this.actions = [];
        this.options = [];
        this.disposables = [];
        this.nvim = workspace_default.nvim;
        this.config = configuration_default;
      }
      get alignColumns() {
        return configuration_default.get("alignColumns", false);
      }
      get floatPreview() {
        return configuration_default.get("floatPreview", false);
      }
      get hlGroup() {
        return configuration_default.get("previewHighlightGroup", "Search");
      }
      get previewHeight() {
        return configuration_default.get("maxPreviewHeight", 12);
      }
      get splitRight() {
        return configuration_default.get("previewSplitRight", false);
      }
      get toplineStyle() {
        return configuration_default.get("previewToplineStyle", "offset");
      }
      get toplineOffset() {
        return configuration_default.get("previewToplineOffset", 3);
      }
      parseArguments(args) {
        if (!this.optionMap) {
          this.optionMap = /* @__PURE__ */ new Map();
          for (let opt of this.options) {
            let parts = opt.name.split(/,\s*/g).map((s) => s.replace(/\s+.*/g, ""));
            let name2 = opt.key ? opt.key : parts[parts.length - 1].replace(/^-+/, "");
            for (let p of parts) {
              this.optionMap.set(p, { name: name2, hasValue: opt.hasValue });
            }
          }
        }
        let res = {};
        for (let i = 0; i < args.length; i++) {
          let arg = args[i];
          let def = this.optionMap.get(arg);
          if (!def) continue;
          let value = true;
          if (def.hasValue) {
            value = toText(args[i + 1]);
            i = i + 1;
          }
          res[def.name] = value;
        }
        return res;
      }
      /**
       * Get configuration of current list
       */
      getConfig() {
        return workspace_default.getConfiguration(`list.source.${this.name}`);
      }
      addAction(name2, fn, options2) {
        this.createAction(Object.assign({
          name: name2,
          execute: fn
        }, options2 || {}));
      }
      addMultipleAction(name2, fn, options2) {
        this.createAction(Object.assign({
          name: name2,
          multiple: true,
          execute: fn
        }, options2 || {}));
      }
      createCommandTask(opt) {
        return new CommandTask(opt);
      }
      addLocationActions() {
        this.createAction({
          name: "preview",
          execute: async (item, context) => {
            let loc = await this.convertLocation(item.location);
            await this.previewLocation(loc, context);
          }
        });
        let { nvim } = this;
        this.createAction({
          name: "quickfix",
          multiple: true,
          execute: async (items) => {
            let quickfixItems = await Promise.all(items.map((item) => this.convertLocation(item.location).then((loc) => workspace_default.getQuickfixItem(loc))));
            await nvim.call("setqflist", [quickfixItems]);
            let openCommand = await nvim.getVar("coc_quickfix_open_command");
            nvim.command(typeof openCommand === "string" ? openCommand : "copen", true);
          }
        });
        for (let name2 of ["open", "tabe", "drop", "vsplit", "split"]) {
          this.createAction({
            name: name2,
            execute: async (item, context) => {
              await this.jumpTo(item.location, name2 == "open" ? null : name2, context);
            },
            tabPersist: name2 === "open"
          });
        }
      }
      async convertLocation(location) {
        if (typeof location == "string") return Location.create(location, Range.create(0, 0, 0, 0));
        if (Location.is(location)) return location;
        let u = URI2.parse(location.uri);
        if (u.scheme != "file") return Location.create(location.uri, Range.create(0, 0, 0, 0));
        return await lineToLocation(u.fsPath, location.line, location.text);
      }
      async jumpTo(location, command, context) {
        if (command == null && context && context.options.position === "tab") {
          command = "tabe";
        }
        if (typeof location == "string") {
          await workspace_default.jumpTo(location, null, command);
          return;
        }
        let { range, uri } = await this.convertLocation(location);
        let position = range.start;
        if (position.line == 0 && position.character == 0 && comparePosition(position, range.end) == 0) {
          position = null;
        }
        await workspace_default.jumpTo(uri, position, command);
      }
      createAction(action) {
        let { name: name2 } = action;
        let idx = this.actions.findIndex((o) => o.name == name2);
        if (idx !== -1) this.actions.splice(idx, 1);
        this.actions.push(action);
      }
      async previewLocation(location, context) {
        let { uri, range } = location;
        let doc = workspace_default.getDocument(location.uri);
        let u = URI2.parse(uri);
        let lines = await workspace_default.documentsManager.getLines(uri);
        let config = {
          bufnr: doc ? doc.bufnr : void 0,
          winid: context.window.id,
          range: emptyRange(range) ? null : range,
          lnum: range.start.line + 1,
          name: u.scheme == "file" ? u.fsPath : uri,
          filetype: toVimFiletype(doc ? doc.languageId : workspace_default.documentsManager.getLanguageId(u.fsPath)),
          position: context.options.position,
          maxHeight: this.previewHeight,
          splitRight: this.splitRight,
          hlGroup: this.hlGroup,
          scheme: u.scheme,
          toplineStyle: this.toplineStyle,
          toplineOffset: this.toplineOffset,
          targetRange: location.targetRange
        };
        await this.openPreview(lines, config);
      }
      async preview(options2, context) {
        let { bufname, filetype, range, lines, lnum } = options2;
        let config = {
          winid: context.window.id,
          lnum: range ? range.start.line + 1 : lnum || 1,
          filetype,
          position: context.options.position,
          maxHeight: this.previewHeight,
          splitRight: this.splitRight,
          hlGroup: this.hlGroup,
          toplineStyle: this.toplineStyle,
          toplineOffset: this.toplineOffset
        };
        if (bufname) config.name = bufname;
        if (range) config.range = range;
        await this.openPreview(lines, config);
      }
      async openPreview(lines, config) {
        let { nvim } = this;
        if (this.floatPreview && config.position !== "tab") {
          await nvim.call("coc#list#float_preview", [lines, config]);
        } else {
          await nvim.call("coc#list#preview", [lines, config]);
        }
        nvim.command("redraw", true);
      }
      doHighlight() {
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/util/fuzzy.ts
function getCharCodes(str) {
  let len = str.length;
  let res = new Uint16Array(len);
  for (let i = 0, l = len; i < l; i++) {
    res[i] = str.charCodeAt(i);
  }
  return res;
}
function caseMatch(input, code, ignorecase = false) {
  if (input === code) return true;
  if (code < ASCII_END) {
    if (input >= 97 && input <= 122 && code + 32 === input) return true;
    if (ignorecase) {
      if (input <= 90 && input + 32 === code) return true;
      if (toLower(input) === code) return true;
    }
  } else {
    let lower = toLower(code);
    if (lower === input || ignorecase && toLower(input) === lower) return true;
  }
  return false;
}
function toLower(code) {
  return String.fromCharCode(code).toLowerCase().charCodeAt(0);
}
function fuzzyMatch(needle, text, ignorecase = false) {
  let totalCount = needle.length;
  let tl = text.length;
  if (totalCount > tl) return false;
  let i = 0;
  let curr = needle[0];
  for (let j = 0; j < tl; j++) {
    let code = text.charCodeAt(j);
    if (caseMatch(curr, code, ignorecase)) {
      i = i + 1;
      curr = needle[i];
      if (i === totalCount) return true;
      continue;
    }
    if (tl - j - 1 < totalCount - i) {
      break;
    }
  }
  return false;
}
var init_fuzzy = __esm({
  "src/util/fuzzy.ts"() {
    "use strict";
    init_constants();
  }
});

// src/list/db.ts
var logger30, DB_PATH, DataBase, db_default;
var init_db2 = __esm({
  "src/list/db.ts"() {
    "use strict";
    init_node();
    init_logger();
    init_string();
    init_constants();
    logger30 = createLogger("list-db");
    DB_PATH = path.join(dataHome, "list_history.dat");
    DataBase = class {
      constructor() {
        this.folders = [];
        this.names = [];
        this.items = [];
        this._changed = false;
        try {
          this.load();
        } catch (e) {
          logger30.error(`Error on load db`, e);
        }
      }
      get currItems() {
        return this.items;
      }
      getHistory(name2, folder) {
        let nameIndex = this.names.indexOf(name2);
        let folderIndex = this.folders.indexOf(folder);
        if (nameIndex == -1 || folderIndex == -1) return [];
        return this.items.reduce((p, c) => {
          if (c[1] == nameIndex && c[2] == folderIndex) {
            p.push(c[0]);
          }
          return p;
        }, []);
      }
      addItem(name2, text, folder) {
        let { folders, names } = this;
        if (byteLength(text) > 255) {
          text = byteSlice(text, 0, 255);
        }
        if (!folders.includes(folder)) {
          folders.push(folder);
        }
        if (!names.includes(name2)) {
          names.push(name2);
        }
        let nameIndex = names.indexOf(name2);
        let folderIndex = folders.indexOf(folder);
        let idx = this.items.findIndex((o) => o[0] == text && o[1] == nameIndex && o[2] == folderIndex);
        if (idx != -1) this.items.splice(idx, 1);
        this.items.push([text, nameIndex, folderIndex]);
        this._changed = true;
      }
      save() {
        let { folders, items, names } = this;
        if (!this._changed) return;
        let bufs = folders.reduce((p, folder) => {
          p.push(Buffer.from(folder, "utf8"), Buffer.alloc(1));
          return p;
        }, []);
        let folderBuf = Buffer.concat(bufs);
        bufs = names.reduce((p, name2) => {
          p.push(Buffer.from(name2, "utf8"), Buffer.alloc(1));
          return p;
        }, []);
        let nameBuf = Buffer.concat(bufs);
        let buf = Buffer.allocUnsafe(9);
        buf.writeUInt8(2, 0);
        buf.writeUInt32BE(folderBuf.byteLength, 1);
        buf.writeUInt32BE(nameBuf.byteLength, 5);
        bufs = items.reduce((p, item) => {
          let b = Buffer.from(item[0], "utf8");
          p.push(Buffer.from([b.byteLength]), b, Buffer.from([item[1], item[2]]));
          return p;
        }, []);
        let resultBuf = Buffer.concat([buf, folderBuf, nameBuf, ...bufs]);
        fs.writeFileSync(DB_PATH, resultBuf);
        this._changed = false;
      }
      load() {
        if (!fs.existsSync(DB_PATH)) return;
        let buffer = fs.readFileSync(DB_PATH);
        let folder_length = buffer.readUInt32BE(1);
        let name_length = buffer.readUInt32BE(5);
        let folderBuf = buffer.slice(9, 9 + folder_length);
        let start = 0;
        let folders = [];
        let names = [];
        for (let i = 0; i < folderBuf.byteLength; i++) {
          if (folderBuf[i] === 0) {
            let text = folderBuf.slice(start, i).toString("utf8");
            folders.push(text);
            start = i + 1;
          }
        }
        let offset = 9 + folder_length;
        let nameBuf = buffer.slice(offset, offset + name_length);
        start = 0;
        for (let i = 0; i < nameBuf.byteLength; i++) {
          if (nameBuf[i] === 0) {
            let text = nameBuf.slice(start, i).toString("utf8");
            names.push(text);
            start = i + 1;
          }
        }
        let itemsBuf = buffer.slice(offset + name_length);
        start = 0;
        let total = itemsBuf.byteLength;
        while (start < total) {
          let len = itemsBuf.readUInt8(start);
          let end = start + 1 + len;
          let text = itemsBuf.slice(start + 1, end).toString("utf8");
          this.items.push([text, itemsBuf.readUInt8(end), itemsBuf.readUInt8(end + 1)]);
          start = end + 2;
        }
        this.names = names;
        this.folders = folders;
      }
    };
    db_default = new DataBase();
  }
});

// src/list/history.ts
var logger31, InputHistory;
var init_history = __esm({
  "src/list/history.ts"() {
    "use strict";
    init_node();
    init_logger();
    init_array();
    init_fuzzy();
    init_db2();
    init_string();
    logger31 = createLogger("list-history");
    InputHistory = class {
      constructor(prompt, name2, db, cwd2) {
        this.prompt = prompt;
        this.name = name2;
        this.db = db;
        this.cwd = cwd2;
        this._index = -1;
        this._filtered = [];
      }
      get loaded() {
        return this.db.getHistory(this.name, this.cwd);
      }
      get filtered() {
        return this._filtered;
      }
      get index() {
        return this._index;
      }
      static migrate(folder) {
        try {
          let files = fs.readdirSync(folder);
          files = files.filter((f) => f.startsWith("list-") && f.endsWith("-history.json") && fs.statSync(path.join(folder, f)).isFile());
          if (files.length === 0) return;
          let db = new DataBase();
          for (let file of files) {
            let name2 = file.match(/^list-(.*)-history.json$/)[1];
            let content = fs.readFileSync(path.join(folder, file), "utf8");
            let obj = JSON.parse(content);
            for (let [key, texts] of Object.entries(obj)) {
              let folder2 = Buffer.from(key, "base64").toString("utf8");
              if (Array.isArray(texts)) {
                texts.forEach((text) => {
                  db.addItem(name2, text, folder2);
                });
              }
            }
          }
          files.forEach((f) => {
            fs.unlinkSync(path.join(folder, f));
          });
          db.save();
        } catch (e) {
          logger31.error(`Error on migrate history:`, e);
        }
      }
      get curr() {
        return this._index == -1 || this._filtered == null ? null : this._filtered[this._index];
      }
      filter() {
        let { input } = this.prompt;
        if (input === this.curr) return;
        this.historyInput = "";
        if (input.length > 0) {
          let codes = getCharCodes(input);
          this._filtered = this.loaded.filter((s) => fuzzyMatch(codes, s));
        } else {
          this._filtered = this.loaded;
        }
        this._index = -1;
      }
      add() {
        let { db, prompt, cwd: cwd2 } = this;
        let { input } = prompt;
        if (!input || input.length < 2 || input == this.historyInput) return;
        db.addItem(this.name, input, cwd2);
      }
      previous() {
        let { _filtered, _index } = this;
        if (isFalsyOrEmpty(_filtered)) return;
        if (_index <= 0) {
          this._index = _filtered.length - 1;
        } else {
          this._index = _index - 1;
        }
        this.historyInput = this.prompt.input = toText(_filtered[this._index]);
      }
      next() {
        let { _filtered, _index } = this;
        if (isFalsyOrEmpty(_filtered)) return;
        if (_index == _filtered.length - 1) {
          this._index = 0;
        } else {
          this._index = _index + 1;
        }
        this.historyInput = this.prompt.input = toText(_filtered[this._index]);
      }
    };
  }
});

// src/list/mappings.ts
var Mappings;
var init_mappings = __esm({
  "src/list/mappings.ts"() {
    "use strict";
    init_window();
    init_configuration3();
    Mappings = class {
      constructor(manager, nvim) {
        this.manager = manager;
        this.nvim = nvim;
        this.insertMappings = /* @__PURE__ */ new Map();
        this.normalMappings = /* @__PURE__ */ new Map();
        this.userInsertMappings = /* @__PURE__ */ new Map();
        this.userNormalMappings = /* @__PURE__ */ new Map();
        this.actions = /* @__PURE__ */ new Map();
        let { prompt } = manager;
        this.addAction("do:switch", async () => {
          await manager.switchMatcher();
        });
        this.addAction("do:selectall", async () => {
          await manager.session?.ui.selectAll();
        });
        this.addAction("do:help", async () => {
          await manager.session?.showHelp();
        });
        this.addAction("do:refresh", async () => {
          await manager.session?.reloadItems();
        });
        this.addAction("do:exit", async () => {
          await manager.cancel();
        });
        this.addAction("do:stop", () => {
          manager.stop();
        });
        this.addAction("do:cancel", async () => {
          await manager.cancel(false);
        });
        this.addAction("do:toggle", async () => {
          await manager.session?.ui.toggleSelection();
        });
        this.addAction("do:jumpback", () => {
          manager.session?.jumpBack();
        });
        this.addAction("do:previous", async () => {
          await this.navigate(true);
        });
        this.addAction("do:next", async () => {
          await this.navigate(false);
        });
        this.addAction("do:defaultaction", async () => {
          await manager.doAction();
        });
        this.addAction("do:chooseaction", async () => {
          await manager.chooseAction();
        });
        this.addAction("do:togglemode", () => {
          manager.toggleMode();
        });
        this.addAction("do:previewtoggle", async () => {
          await manager.togglePreview();
        });
        this.addAction("do:previewup", () => {
          this.scrollPreview("up");
        });
        this.addAction("do:previewdown", () => {
          this.scrollPreview("down");
        });
        this.addAction("do:command", async () => {
          await manager.cancel(false);
          await nvim.eval('feedkeys(":")');
        });
        this.addAction("prompt:previous", () => {
          manager.session?.history.previous();
        });
        this.addAction("prompt:next", () => {
          manager.session?.history.next();
        });
        this.addAction("prompt:start", () => {
          prompt.moveToStart();
        });
        this.addAction("prompt:end", () => {
          prompt.moveToEnd();
        });
        this.addAction("prompt:left", () => {
          prompt.moveLeft();
        });
        this.addAction("prompt:right", () => {
          prompt.moveRight();
        });
        this.addAction("prompt:leftword", () => {
          prompt.moveLeftWord();
        });
        this.addAction("prompt:rightword", () => {
          prompt.moveRightWord();
        });
        this.addAction("prompt:deleteforward", () => {
          prompt.onBackspace();
        });
        this.addAction("prompt:deletebackward", () => {
          prompt.removeNext();
        });
        this.addAction("prompt:removetail", () => {
          prompt.removeTail();
        });
        this.addAction("prompt:removeahead", () => {
          prompt.removeAhead();
        });
        this.addAction("prompt:removeword", () => {
          prompt.removeWord();
        });
        this.addAction("prompt:insertregister", () => {
          prompt.insertRegister();
        });
        this.addAction("prompt:paste", async () => {
          await prompt.paste();
        });
        this.addAction("eval", async (expr) => {
          await prompt.eval(expr);
        });
        this.addAction("command", async (expr) => {
          await manager.command(expr);
        });
        this.addAction("action", async (expr) => {
          await manager.doAction(expr);
        });
        this.addAction("feedkeys", async (expr) => {
          await manager.feedkeys(expr);
        });
        this.addAction("feedkeys!", async (expr) => {
          await manager.feedkeys(expr, false);
        });
        this.addAction("normal", async (expr) => {
          await manager.normal(expr, false);
        });
        this.addAction("normal!", async (expr) => {
          await manager.normal(expr, true);
        });
        this.addAction("call", async (expr) => {
          await manager.call(expr);
        });
        this.addAction("expr", async (expr) => {
          let name2 = await manager.call(expr);
          await manager.doAction(name2);
        });
        this.addKeyMapping("insert", "<C-s>", "do:switch");
        this.addKeyMapping("insert", "<C-n>", "prompt:next");
        this.addKeyMapping("insert", "<C-p>", "prompt:previous");
        this.addKeyMapping("insert", "<C-v>", "prompt:paste");
        this.addKeyMapping("insert", ["<C-m>", "<cr>"], "do:defaultaction");
        this.addKeyMapping("insert", ["<tab>", "<C-i>", "	"], "do:chooseaction");
        this.addKeyMapping("insert", "<C-o>", "do:togglemode");
        this.addKeyMapping("insert", "<C-c>", "do:stop");
        this.addKeyMapping("insert", "<C-l>", "do:refresh");
        this.addKeyMapping("insert", "<left>", "prompt:left");
        this.addKeyMapping("insert", "<right>", "prompt:right");
        this.addKeyMapping("insert", ["<end>", "<C-e>"], "prompt:end");
        this.addKeyMapping("insert", ["<home>", "<C-a>"], "prompt:start");
        this.addKeyMapping("insert", ["<C-h>", "<bs>", "<backspace>"], "prompt:deleteforward");
        this.addKeyMapping("insert", "<C-w>", "prompt:removeword");
        this.addKeyMapping("insert", "<C-u>", "prompt:removeahead");
        this.addKeyMapping("insert", "<C-r>", "prompt:insertregister");
        this.addKeyMapping("normal", "t", "action:tabe");
        this.addKeyMapping("normal", "s", "action:split");
        this.addKeyMapping("normal", "d", "action:drop");
        this.addKeyMapping("normal", ["<cr>", "<C-m>", "\r"], "do:defaultaction");
        this.addKeyMapping("normal", "<C-a>", "do:selectall");
        this.addKeyMapping("normal", " ", "do:toggle");
        this.addKeyMapping("normal", "p", "do:previewtoggle");
        this.addKeyMapping("normal", ["<tab>", "	", "<C-i>"], "do:chooseaction");
        this.addKeyMapping("normal", "<C-c>", "do:stop");
        this.addKeyMapping("normal", "<C-l>", "do:refresh");
        this.addKeyMapping("normal", "<C-o>", "do:jumpback");
        this.addKeyMapping("normal", "<C-e>", "do:previewdown");
        this.addKeyMapping("normal", "<C-y>", "do:previewup");
        this.addKeyMapping("normal", ["i", "I", "o", "O", "a", "A"], "do:togglemode");
        this.addKeyMapping("normal", "?", "do:help");
        this.addKeyMapping("normal", ":", "do:command");
        this.createMappings();
      }
      createMappings() {
        let insertMappings = configuration_default.get("insertMappings", {});
        this.userInsertMappings = this.fixUserMappings(insertMappings, "list.insertMappings");
        let normalMappings = configuration_default.get("normalMappings", {});
        this.userNormalMappings = this.fixUserMappings(normalMappings, "list.normalMappings");
      }
      hasUserMapping(mode, key) {
        let map = mode == "insert" ? this.userInsertMappings : this.userNormalMappings;
        return map.has(key);
      }
      isValidAction(action) {
        if (this.actions.has(action)) return true;
        let [key, expr] = action.split(":", 2);
        if (!expr || !this.actions.has(key)) return false;
        return true;
      }
      fixUserMappings(mappings, entry) {
        let res = /* @__PURE__ */ new Map();
        for (let [key, value] of Object.entries(mappings)) {
          if (!this.isValidAction(value)) {
            void window_default.showWarningMessage(`Invalid configuration - unable to support action "${value}" in "${entry}"`);
            continue;
          }
          if (key.length == 1) {
            res.set(key, value);
          } else if (key.startsWith("<") && key.endsWith(">")) {
            if (key.toLowerCase() == "<space>") {
              res.set(" ", value);
            } else if (key.toLowerCase() == "<backspace>") {
              res.set("<bs>", value);
            } else if (validKeys.includes(key)) {
              res.set(key, value);
            } else {
              let find = false;
              for (let i = 0; i < validKeys.length; i++) {
                if (validKeys[i].toLowerCase() == key.toLowerCase()) {
                  find = true;
                  res.set(validKeys[i], value);
                  break;
                }
              }
              if (!find) void window_default.showWarningMessage(`Invalid configuration - unable to recognize "${key}" in "${entry}"`);
            }
          } else {
            void window_default.showWarningMessage(`Invalid configuration - unable to recognize key "${key}" in "${entry}"`);
          }
        }
        return res;
      }
      async navigate(up) {
        let ui = this.manager.session?.ui;
        if (!ui) return false;
        await ui.moveCursor(up ? -1 : 1);
        return true;
      }
      async doInsertKeymap(key) {
        if (key === configuration_default.nextKey) return await this.navigate(false);
        if (key === configuration_default.previousKey) return await this.navigate(true);
        let expr = this.userInsertMappings.get(key);
        if (expr) {
          let fn = this.getAction(expr);
          await Promise.resolve(fn());
          return true;
        }
        if (this.insertMappings.has(key)) {
          let fn = this.insertMappings.get(key);
          await Promise.resolve(fn());
          return true;
        }
        return false;
      }
      async doNormalKeymap(key) {
        let expr = this.userNormalMappings.get(key);
        if (expr) {
          let fn = this.getAction(expr);
          await Promise.resolve(fn());
          return true;
        }
        if (this.normalMappings.has(key)) {
          let fn = this.normalMappings.get(key);
          await Promise.resolve(fn());
          return true;
        }
        return false;
      }
      addKeyMapping(mode, key, action) {
        let mappings = mode == "insert" ? this.insertMappings : this.normalMappings;
        let fn = this.getAction(action);
        if (Array.isArray(key)) {
          for (let k of key) {
            mappings.set(k, fn);
          }
        } else {
          mappings.set(key, fn);
        }
      }
      addAction(key, fn) {
        this.actions.set(key, fn);
      }
      getAction(action) {
        if (this.actions.has(action)) return () => {
          return this.doAction(action);
        };
        let [key, expr] = action.split(":", 2);
        if (!expr || !this.actions.has(key)) throw new Error(`Invalid action ${action}`);
        return () => {
          return this.doAction(key, expr);
        };
      }
      async doAction(key, expr) {
        let fn = this.actions.get(key);
        if (!fn) throw new Error(`Action ${key} doesn't exist`);
        await Promise.resolve(fn(expr));
      }
      scrollPreview(dir) {
        const floatPreview = configuration_default.get("floatPreview", false);
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.call("coc#list#scroll_preview", [dir, floatPreview], true);
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/prompt.ts
function getLastWordRemovedText(text) {
  let res = text;
  res = res.trimEnd();
  if (res === "") return res;
  const last = getUnicodeClass(res[res.length - 1]);
  while (res !== "" && getUnicodeClass(res[res.length - 1]) === last) {
    res = res.slice(0, res.length - 1);
  }
  return res;
}
var Prompt;
var init_prompt = __esm({
  "src/list/prompt.ts"() {
    "use strict";
    init_protocol();
    init_string();
    init_configuration3();
    Prompt = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.cursorIndex = 0;
        this._input = "";
        this._mode = "insert";
        this.interactive = false;
        this.requestInput = false;
        this._onDidChangeInput = new import_node4.Emitter();
        this.onDidChangeInput = this._onDidChangeInput.event;
      }
      get input() {
        return this._input;
      }
      set input(str) {
        if (this._input == str) return;
        this.cursorIndex = str.length;
        this._input = str;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      get mode() {
        return this._mode;
      }
      set mode(val) {
        if (val == this._mode) return;
        this._mode = val;
        this.drawPrompt();
      }
      set matcher(val) {
        this._matcher = val;
        this.drawPrompt();
      }
      start(opts) {
        if (opts) {
          this.interactive = opts.interactive;
          this.cursorIndex = opts.input.length;
          this._input = opts.input;
          this._mode = opts.mode;
          this._matcher = opts.interactive ? "" : opts.matcher;
        }
        this.nvim.call("coc#prompt#start_prompt", ["list"], true);
        this.drawPrompt();
      }
      cancel() {
        let { nvim } = this;
        nvim.call("coc#prompt#stop_prompt", ["list"], true);
      }
      reset() {
        this._input = "";
        this.cursorIndex = 0;
      }
      drawPrompt() {
        let indicator = configuration_default.get("indicator", ">");
        let { cursorIndex, interactive, input, _matcher } = this;
        let cmds = ['echo ""'];
        if (this.mode == "insert") {
          if (interactive) {
            cmds.push(`echohl MoreMsg | echon 'INTERACTIVE ' | echohl None`);
          } else if (_matcher) {
            cmds.push(`echohl MoreMsg | echon '${_matcher.toUpperCase()} ' | echohl None`);
          }
          cmds.push(`echohl Special | echon '${indicator} ' | echohl None`);
          if (cursorIndex == input.length) {
            cmds.push(`echon '${input.replace(/'/g, "''")}'`);
            cmds.push(`echohl Cursor | echon ' ' | echohl None`);
          } else {
            let pre = input.slice(0, cursorIndex);
            if (pre) cmds.push(`echon '${pre.replace(/'/g, "''")}'`);
            cmds.push(`echohl Cursor | echon '${input[cursorIndex].replace(/'/, "''")}' | echohl None`);
            let post = input.slice(cursorIndex + 1);
            cmds.push(`echon '${post.replace(/'/g, "''")}'`);
          }
        } else {
          cmds.push(`echohl MoreMsg | echo "" | echohl None`);
        }
        cmds.push("redraw");
        let cmd = cmds.join("|");
        this.nvim.command(cmd, true);
      }
      moveLeft() {
        if (this.cursorIndex == 0) return;
        this.cursorIndex = this.cursorIndex - 1;
        this.drawPrompt();
      }
      moveRight() {
        if (this.cursorIndex == this._input.length) return;
        this.cursorIndex = this.cursorIndex + 1;
        this.drawPrompt();
      }
      moveLeftWord() {
        let { cursorIndex, input } = this;
        if (cursorIndex == 0) return;
        let pre = input.slice(0, cursorIndex);
        let remain = getLastWordRemovedText(pre);
        this.cursorIndex = cursorIndex - (pre.length - remain.length);
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      moveRightWord() {
        let { cursorIndex, input } = this;
        if (cursorIndex == input.length) return;
        let post = input.slice(cursorIndex);
        let nextWord = post.match(/[\w$]+ */).at(0) ?? post;
        this.cursorIndex = cursorIndex + nextWord.length;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      moveToEnd() {
        if (this.cursorIndex == this._input.length) return;
        this.cursorIndex = this._input.length;
        this.drawPrompt();
      }
      moveToStart() {
        if (this.cursorIndex == 0) return;
        this.cursorIndex = 0;
        this.drawPrompt();
      }
      onBackspace() {
        let { cursorIndex, input } = this;
        if (cursorIndex == 0) return;
        let pre = input.slice(0, cursorIndex);
        let post = input.slice(cursorIndex);
        this.cursorIndex = cursorIndex - 1;
        this._input = `${pre.slice(0, pre.length - 1)}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeNext() {
        let { cursorIndex, input } = this;
        if (cursorIndex == input.length) return;
        let pre = input.slice(0, cursorIndex);
        let post = input.slice(cursorIndex + 1);
        this._input = `${pre}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeWord() {
        let { cursorIndex, input } = this;
        if (cursorIndex == 0) return;
        let pre = input.slice(0, cursorIndex);
        let post = input.slice(cursorIndex);
        let remain = getLastWordRemovedText(pre);
        this.cursorIndex = cursorIndex - (pre.length - remain.length);
        this._input = `${remain}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeTail() {
        let { cursorIndex, input } = this;
        if (cursorIndex == input.length) return;
        let pre = input.slice(0, cursorIndex);
        this._input = pre;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeAhead() {
        let { cursorIndex, input } = this;
        if (cursorIndex == 0) return;
        let post = input.slice(cursorIndex);
        this.cursorIndex = 0;
        this._input = post;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      async acceptCharacter(ch) {
        if (this.requestInput) {
          this.requestInput = false;
          if (/^[0-9a-z"%#*+/:\-.]$/.test(ch)) {
            let text = await this.nvim.call("getreg", ch);
            text = text.replace(/\n/g, " ");
            this.addText(text);
          }
        } else {
          this.addText(ch);
        }
      }
      insertRegister() {
        this.requestInput = true;
      }
      async paste() {
        let text = await this.nvim.eval("@*");
        text = text.replace(/\n/g, "");
        if (!text) return;
        this.addText(text);
      }
      async eval(expression) {
        let text = await this.nvim.call("eval", [expression]);
        text = text.replace(/\n/g, "");
        this.addText(text);
      }
      addText(text) {
        let { cursorIndex, input } = this;
        this.cursorIndex = cursorIndex + text.length;
        let pre = input.slice(0, cursorIndex);
        let post = input.slice(cursorIndex);
        this._input = `${pre}${text}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
    };
  }
});

// src/util/sequence.ts
var Sequence;
var init_sequence = __esm({
  "src/util/sequence.ts"() {
    "use strict";
    Sequence = class {
      constructor() {
        this._busy = false;
        this._fns = [];
        this._resolves = [];
      }
      run(fn) {
        if (!this._busy) {
          this._busy = true;
          void fn().finally(() => {
            this.next();
          });
        } else {
          this._fns.push(fn);
        }
      }
      waitFinish() {
        if (!this._busy) return Promise.resolve();
        return new Promise((resolve) => {
          this._resolves.push(resolve);
        });
      }
      next() {
        let fn = this._fns.shift();
        if (!fn) {
          this.finish();
        } else {
          void fn().finally(() => {
            this.next();
          });
        }
      }
      finish() {
        this._busy = false;
        let fn;
        while ((fn = this._resolves.pop()) != null) {
          fn();
        }
      }
      cancel() {
        this._fns = [];
        this.finish();
      }
    };
  }
});

// src/list/ui.ts
var debounceTime4, ListUI;
var init_ui2 = __esm({
  "src/list/ui.ts"() {
    "use strict";
    init_events();
    init_util();
    init_array();
    init_node();
    init_protocol();
    init_sequence();
    init_string();
    init_workspace();
    init_configuration3();
    debounceTime4 = getConditionValue(100, 20);
    ListUI = class {
      constructor(nvim, name2, listOptions) {
        this.nvim = nvim;
        this.name = name2;
        this.listOptions = listOptions;
        this.newTab = false;
        this.reversed = false;
        this.currIndex = 0;
        this.items = [];
        this.disposables = [];
        this.selected = /* @__PURE__ */ new Set();
        this.sequence = new Sequence();
        this._onDidChangeLine = new import_node4.Emitter();
        this._onDidOpen = new import_node4.Emitter();
        this._onDidClose = new import_node4.Emitter();
        this._onDidLineChange = new import_node4.Emitter();
        this._onDoubleClick = new import_node4.Emitter();
        this.onDidChangeLine = this._onDidChangeLine.event;
        this.onDidLineChange = this._onDidLineChange.event;
        this.onDidOpen = this._onDidOpen.event;
        this.onDidClose = this._onDidClose.event;
        this.onDidDoubleClick = this._onDoubleClick.event;
        this.newTab = listOptions.position == "tab";
        this.reversed = listOptions.reverse === true;
        events_default.on("BufWinLeave", async (bufnr) => {
          if (bufnr != this.bufnr || this.window == null) return;
          this.window = null;
          this._onDidClose.fire(bufnr);
        }, null, this.disposables);
        events_default.on("CursorMoved", async (bufnr, cursor) => {
          if (bufnr != this.bufnr) return;
          let idx = this.lnumToIndex(cursor[0]);
          this.onLineChange(idx);
        }, null, this.disposables);
        let debounced = debounce(async (bufnr) => {
          if (bufnr != this.bufnr) return;
          let [winid, start, end] = await nvim.eval('[win_getid(),line("w0"),line("w$")]');
          if (end < 300 || winid != this.winid) return;
          let h = end - start + 1;
          let s = this.lnumToIndex(start);
          let e = this.lnumToIndex(start + h * 2);
          nvim.pauseNotification();
          this.doHighlight(s, e);
          nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        }, debounceTime4);
        this.disposables.push({
          dispose: () => {
            debounced.clear();
          }
        });
        events_default.on("CursorMoved", debounced, null, this.disposables);
      }
      onDidChangeItems(ev) {
        if (!ev.append) this.clearSelection();
        this.sequence.run(async () => {
          let { items, reload, append, finished, sorted } = ev;
          if (this.shouldSort && !sorted) {
            items = append ? this.items.concat(items) : items;
            reload = append == true;
            append = false;
            items.sort((a, b) => {
              if (a.score != b.score) return b.score - a.score;
              if (a.sortText > b.sortText) return 1;
              return -1;
            });
          }
          if (append) {
            await this.appendItems(items);
          } else {
            await this.drawItems(items, finished, reload);
          }
        });
      }
      lnumToIndex(lnum) {
        let { reversed, length } = this;
        if (!reversed) return lnum - 1;
        return Math.max(0, length - lnum);
      }
      indexToLnum(index) {
        let { reversed, length } = this;
        if (!reversed) return Math.min(index + 1, length);
        return Math.max(Math.min(length, length - index), 1);
      }
      get bufnr() {
        return this.buffer?.id;
      }
      get winid() {
        return this.window?.id;
      }
      get limitLines() {
        return configuration_default.get("limitLines", Infinity);
      }
      onLineChange(index) {
        if (this.currIndex == index) return;
        this.currIndex = index;
        this._onDidChangeLine.fire(index);
      }
      get index() {
        return this.currIndex;
      }
      getItem(index) {
        return this.items[index];
      }
      get item() {
        let { window: window2 } = this;
        if (!window2) return Promise.resolve(null);
        return window2.cursor.then((cursor) => {
          this.currIndex = this.lnumToIndex(cursor[0]);
          return this.items[this.currIndex];
        });
      }
      async echoMessage(item) {
        let { items } = this;
        let idx = items.indexOf(item);
        let msg = `[${idx + 1}/${items.length}] ${toText(item.label)}`;
        this.nvim.callTimer("coc#ui#echo_lines", [[msg]], true);
      }
      updateItem(item, index) {
        if (!this.buffer || index >= this.length) return;
        let { nvim } = this;
        let lnum = this.indexToLnum(index);
        nvim.pauseNotification();
        this.buffer.setOption("modifiable", true, true);
        nvim.call("setbufline", [this.bufnr, lnum, item.label], true);
        this.doHighlight(index, index + 1);
        this.buffer.setOption("modifiable", false, true);
        nvim.resumeNotification(true, true);
      }
      async getItems() {
        if (this.length == 0 || !this.window) return [];
        let mode = await this.nvim.call("mode");
        if (mode == "v" || mode == "V") {
          let [start, end] = await this.getSelectedRange();
          let res = [];
          for (let i = start; i <= end; i++) {
            let idx = this.lnumToIndex(i);
            let item2 = this.items[idx];
            if (item2) res.push(item2);
          }
          return res;
        }
        let { selectedItems } = this;
        if (selectedItems.length) return selectedItems;
        let item = await this.item;
        return toArray(item);
      }
      async onMouse(event) {
        let { nvim, window: window2 } = this;
        if (!window2) return;
        let [winid, lnum, col] = await nvim.eval(`[v:mouse_winid,v:mouse_lnum,v:mouse_col]`);
        if (event == "mouseDown") {
          this.mouseDown = { winid, lnum, col, current: winid == window2.id };
          return;
        }
        let current = winid == window2.id;
        if (current && event == "doubleClick") {
          this.setCursor(lnum);
          this._onDoubleClick.fire();
        }
        if (current && event == "mouseDrag") {
          if (!this.mouseDown) return;
          await this.selectLines(this.mouseDown.lnum, lnum);
        } else if (current && event == "mouseUp") {
          if (!this.mouseDown) return;
          if (this.mouseDown.lnum == lnum) {
            this.setCursor(lnum);
            nvim.command("redraw", true);
          } else {
            await this.selectLines(this.mouseDown.lnum, lnum);
          }
        } else if (!current && event == "mouseUp") {
          nvim.pauseNotification();
          nvim.call("win_gotoid", winid, true);
          nvim.call("cursor", [lnum, col], true);
          nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        }
      }
      async resume() {
        let { items, selected, nvim } = this;
        await this.drawItems(items, true, true);
        if (!selected.size || !this.buffer) return;
        nvim.pauseNotification();
        for (let lnum of selected) {
          this.buffer.placeSign({ lnum, id: configuration_default.signOffset + lnum, name: "CocSelected", group: "coc-list" });
        }
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      async toggleSelection() {
        let { nvim, reversed } = this;
        await nvim.call("win_gotoid", [this.winid]);
        let lnum = await nvim.call("line", ".");
        let mode = await nvim.call("mode");
        if (mode == "v" || mode == "V") {
          let [start, end] = await this.getSelectedRange();
          let reverse = start > end;
          if (reverse) [start, end] = [end, start];
          for (let i = start; i <= end; i++) {
            this.toggleLine(i);
          }
          this.setCursor(end);
          nvim.command("redraw", true);
          await nvim.resumeNotification();
          return;
        }
        nvim.pauseNotification();
        this.toggleLine(lnum);
        this.setCursor(reversed ? lnum - 1 : lnum + 1);
        nvim.command("redraw", true);
        await nvim.resumeNotification();
      }
      toggleLine(lnum) {
        let { selected, buffer } = this;
        let exists = selected.has(lnum);
        const signOffset2 = configuration_default.signOffset;
        if (!exists) {
          selected.add(lnum);
          buffer.placeSign({ lnum, id: signOffset2 + lnum, name: "CocSelected", group: "coc-list" });
        } else {
          selected.delete(lnum);
          buffer.unplaceSign({ id: signOffset2 + lnum, group: "coc-list" });
        }
      }
      async selectLines(start, end) {
        let { nvim, buffer, length } = this;
        const signOffset2 = configuration_default.signOffset;
        this.clearSelection();
        let { selected } = this;
        nvim.pauseNotification();
        let reverse = start > end;
        if (reverse) [start, end] = [end, start];
        for (let i = start; i <= end; i++) {
          if (i > length) break;
          selected.add(i);
          buffer.placeSign({ lnum: i, id: signOffset2 + i, name: "CocSelected", group: "coc-list" });
        }
        this.setCursor(end);
        nvim.command("redraw", true);
        await nvim.resumeNotification();
      }
      async selectAll() {
        let { length } = this;
        if (length > 0) await this.selectLines(1, length);
      }
      clearSelection() {
        let { selected, buffer } = this;
        if (buffer && selected.size > 0) {
          buffer.unplaceSign({ group: "coc-list" });
          this.selected.clear();
        }
      }
      get ready() {
        if (this.window) return Promise.resolve();
        return new Promise((resolve) => {
          let disposable = this.onDidLineChange(() => {
            disposable.dispose();
            resolve();
          });
        });
      }
      getHeight(len, finished) {
        let { listOptions } = this;
        if (typeof listOptions.height === "number") return listOptions.height;
        let height = configuration_default.get("height", 10);
        if (finished && !listOptions.interactive && listOptions.input.length == 0) {
          height = Math.min(len, height);
        }
        return Math.max(1, height);
      }
      async drawItems(items, finished, reload = false) {
        const { nvim, name: name2, listOptions } = this;
        this.items = items.length > this.limitLines ? items.slice(0, this.limitLines) : items;
        if (!this.window) {
          let height = this.getHeight(items.length, finished);
          let { position, numberSelect } = listOptions;
          let [bufnr, winid, tabnr] = await nvim.call("coc#list#create", [position, height, name2, numberSelect]);
          this.tabnr = tabnr;
          this.height = height;
          this.buffer = nvim.createBuffer(bufnr);
          let win = this.window = nvim.createWindow(winid);
          let statusSegments = configuration_default.get("statusLineSegments");
          if (statusSegments) win.setOption("statusline", statusSegments.join(" "), true);
          this._onDidOpen.fire(this.bufnr);
        }
        const lines = [];
        let selectIndex = 0;
        this.items.forEach((item, idx) => {
          lines.push(item.label);
          if (!reload && selectIndex == 0 && item.preselect) selectIndex = idx;
        });
        let newIndex = reload ? this.currIndex : selectIndex;
        this.setLines(lines, 0, newIndex);
        this._onDidLineChange.fire();
      }
      async appendItems(items) {
        if (!this.window || items.length === 0) return;
        let curr = this.items.length;
        let remain = this.limitLines - curr;
        if (remain > 0) {
          let append = remain < items.length ? items.slice(0, remain) : items;
          this.items = this.items.concat(append);
          this.setLines(append.map((item) => item.label), append.length, this.currIndex);
        }
      }
      get shouldSort() {
        let { matcher, interactive } = this.listOptions;
        if (interactive || matcher !== "fuzzy") return false;
        return true;
      }
      setLines(lines, append, index) {
        let { nvim, buffer, window: window2, reversed, newTab } = this;
        if (!buffer || !window2) return;
        nvim.pauseNotification();
        if (!append) {
          nvim.call("coc#compat#clear_matches", [window2.id], true);
          if (!lines.length) {
            lines = ["No results, press ? on normal mode to get help."];
            nvim.call("coc#compat#matchaddpos", ["Comment", [[1]], 99, window2.id], true);
          }
        }
        buffer.setOption("modifiable", true, true);
        if (reversed) {
          let replacement = lines.reverse();
          if (append) {
            nvim.call("appendbufline", [buffer.id, 0, replacement], true);
          } else {
            buffer.setLines(replacement, { start: 0, end: -1, strictIndexing: false }, true);
          }
        } else {
          buffer.setLines(lines, { start: append ? -1 : 0, end: -1, strictIndexing: false }, true);
        }
        buffer.setOption("modifiable", false, true);
        if (reversed && !newTab) {
          let maxHeight = configuration_default.get("height", 10);
          nvim.call("coc#window#set_height", [window2.id, Math.max(Math.min(maxHeight, this.length), 1)], true);
        }
        if (index > this.items.length - 1) index = 0;
        if (index == 0) {
          if (append == 0) {
            this.doHighlight(0, 299);
          } else {
            let s = this.length - append - 1;
            if (s < 300) this.doHighlight(s, Math.min(299, this.length - 1));
          }
        } else {
          let height = newTab ? workspace_default.env.lines : this.height;
          this.doHighlight(Math.max(0, index - height), Math.min(index + height + 1, this.length - 1));
        }
        if (!append) {
          this.currIndex = index;
          let lnum = this.indexToLnum(index);
          window2.setCursor([lnum, 0], true);
          nvim.call("coc#list#select", [buffer.id, lnum], true);
        }
        if (reversed) nvim.command("normal! zb", true);
        nvim.command("redraws", true);
        nvim.resumeNotification(true, true);
      }
      restoreWindow() {
        if (this.newTab) return;
        let { winid, height } = this;
        if (winid && height) {
          this.nvim.call("coc#window#set_height", [winid, height], true);
        }
      }
      get length() {
        return this.items.length;
      }
      get selectedItems() {
        let { selected, items } = this;
        let res = [];
        for (let i of selected) {
          let idx = this.lnumToIndex(i);
          if (items[i - 1]) res.push(items[idx]);
        }
        return res;
      }
      doHighlight(start, end) {
        let { items, reversed, length, buffer } = this;
        const highlightItems = [];
        const iterate = (i) => {
          let lnum = this.indexToLnum(i) - 1;
          let { ansiHighlights } = items[i];
          if (ansiHighlights) {
            for (let hi of ansiHighlights) {
              let { span, hlGroup } = hi;
              highlightItems.push({ hlGroup, lnum, colStart: span[0], colEnd: span[1] });
            }
          }
        };
        if (reversed) {
          for (let i = Math.min(end, length - 1); i >= start; i--) {
            iterate(i);
          }
        } else {
          for (let i = start; i <= Math.min(end, length - 1); i++) {
            iterate(i);
          }
        }
        start = this.indexToLnum(start) - 1;
        end = this.indexToLnum(end) - 1;
        if (start > end) {
          [start, end] = [end, start];
        }
        if (!buffer || highlightItems.length == 0) return;
        buffer.updateHighlights("list", highlightItems, { start, end: end + 1, priority: 99 });
      }
      setCursor(lnum, col = 0, index) {
        let { items } = this;
        let max = items.length == 0 ? 1 : items.length;
        if (lnum > max) return;
        index = index == null ? this.lnumToIndex(lnum) : index;
        this.onLineChange(index);
        this.window?.setCursor([lnum, col], true);
        this.nvim.call("coc#list#select", [this.bufnr, lnum], true);
      }
      async setIndex(index) {
        if (index < 0 || index >= this.items.length) return;
        let { nvim } = this;
        let lnum = this.indexToLnum(index);
        nvim.pauseNotification();
        this.setCursor(lnum, 0, index);
        nvim.command("redraw", true);
        await nvim.resumeNotification(false);
      }
      async moveCursor(delta) {
        let { index, reversed } = this;
        await this.setIndex(reversed ? index - delta : index + delta);
      }
      async getSelectedRange() {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.eval('feedkeys("\\<esc>", "in")');
        let [, start] = await nvim.call("getpos", "'<");
        let [, end] = await nvim.call("getpos", "'>");
        this.nvim.call("coc#prompt#start_prompt", ["list"], true);
        return [start, end];
      }
      cancel() {
        this.sequence.cancel();
      }
      reset() {
        this.cancel();
        if (this.window) {
          this.window = null;
          this.buffer = null;
          this.tabnr = void 0;
        }
      }
      dispose() {
        disposeAll(this.disposables);
        this.nvim.call("coc#window#close", [defaultValue(this.winid, -1)], true);
        this.reset();
        this.items = [];
        this._onDidChangeLine.dispose();
        this._onDidOpen.dispose();
        this._onDidClose.dispose();
        this._onDidLineChange.dispose();
        this._onDoubleClick.dispose();
      }
    };
  }
});

// src/list/worker.ts
function getFilterLabel(item) {
  return item.filterText != null ? patchLine(item.filterText, item.label) : item.label;
}
function toInputs(input, extendedSearchMode) {
  return extendedSearchMode ? parseInput(input) : [input];
}
function convertItemLabel(item) {
  let { label, converted } = item;
  if (converted) return item;
  if (label.includes("\n")) {
    label = item.label = label.replace(/\r?\n.*/gm, "");
  }
  if (label.includes(controlCode)) {
    let { line, highlights } = parseAnsiHighlights(label);
    item.label = line;
    if (!Array.isArray(item.ansiHighlights)) item.ansiHighlights = highlights;
  }
  item.converted = true;
  return item;
}
function indexOf(label, input, smartcase, ignorecase) {
  if (smartcase) return smartcaseIndex(input, label);
  return ignorecase ? label.toLowerCase().indexOf(input.toLowerCase()) : label.indexOf(input);
}
function parseInput(input) {
  let res = [];
  let startIdx = 0;
  let currIdx = 0;
  let prev = "";
  for (; currIdx < input.length; currIdx++) {
    let ch = input[currIdx];
    if (WHITE_SPACE_CHARS.includes(ch.charCodeAt(0))) {
      if (prev && prev != "\\" && startIdx != currIdx) {
        res.push(input.slice(startIdx, currIdx));
        startIdx = currIdx + 1;
      }
    } else {
    }
    prev = ch;
  }
  if (startIdx != input.length) {
    res.push(input.slice(startIdx, input.length));
  }
  return res.map((s) => s.replace(/\\\s/g, " ").trim()).filter((s) => s.length > 0);
}
var logger32, controlCode, WHITE_SPACE_CHARS, SEARCH_HL_GROUP, Worker;
var init_worker = __esm({
  "src/list/worker.ts"() {
    "use strict";
    init_logger();
    init_util();
    init_ansiparse();
    init_array();
    init_async();
    init_diff();
    init_fuzzy();
    init_mutex();
    init_protocol();
    init_string();
    init_workspace();
    init_configuration3();
    logger32 = createLogger("list-worker");
    controlCode = "\x1B";
    WHITE_SPACE_CHARS = [32, 9];
    SEARCH_HL_GROUP = "CocListSearch";
    Worker = class {
      constructor(list2, prompt, listOptions) {
        this.list = list2;
        this.prompt = prompt;
        this.listOptions = listOptions;
        this._loading = false;
        this._finished = false;
        this.mutex = new Mutex();
        this.totalItems = [];
        this._onDidChangeItems = new import_node4.Emitter();
        this._onDidChangeLoading = new import_node4.Emitter();
        this.onDidChangeItems = this._onDidChangeItems.event;
        this.onDidChangeLoading = this._onDidChangeLoading.event;
        this.fuzzyMatch = workspace_default.createFuzzyMatch();
      }
      set loading(loading) {
        if (this._loading == loading) return;
        this._loading = loading;
        this._onDidChangeLoading.fire(loading);
      }
      get isLoading() {
        return this._loading;
      }
      async loadItems(context, reload = false) {
        this.cancelFilter();
        this.filteredCount = 0;
        this._finished = false;
        let { list: list2, listOptions } = this;
        this.loading = true;
        let { interactive } = listOptions;
        this.tokenSource = new import_node4.CancellationTokenSource();
        let token = this.tokenSource.token;
        let items = await list2.loadItems(context, token);
        if (token.isCancellationRequested) return;
        items = items ?? [];
        if (Array.isArray(items)) {
          this.tokenSource = null;
          this.totalItems = items;
          this.loading = false;
          this._finished = true;
          let filtered;
          if (!interactive) {
            this.filterTokenSource = new import_node4.CancellationTokenSource();
            await this.mutex.use(async () => {
              await this.filterItems(items, { reload }, token);
            });
          } else {
            filtered = this.convertToHighlightItems(items);
            this._onDidChangeItems.fire({
              sorted: true,
              items: filtered,
              reload,
              finished: true
            });
          }
        } else {
          let task = items;
          let totalItems = this.totalItems = [];
          let taken = 0;
          let currInput = context.input;
          this.filterTokenSource = new import_node4.CancellationTokenSource();
          let _onData = async (finished) => {
            await this.mutex.use(async () => {
              let inputChanged = this.input != currInput;
              if (inputChanged) {
                currInput = this.input;
                taken = defaultValue(this.filteredCount, 0);
              }
              if (taken >= totalItems.length) return;
              let append = taken > 0;
              let remain = totalItems.slice(taken);
              taken = totalItems.length;
              if (!interactive) {
                let tokenSource = this.filterTokenSource;
                await this.filterItems(remain, { append, reload }, tokenSource.token);
              } else {
                let items2 = this.convertToHighlightItems(remain);
                this._onDidChangeItems.fire({ items: items2, append, reload, sorted: true, finished });
              }
            });
          };
          let interval2 = setInterval(async () => {
            await _onData();
          }, 50);
          task.on("data", (item) => {
            totalItems.push(item);
          });
          let onEnd = async () => {
            if (task == null) return;
            clearInterval(interval2);
            this.tokenSource = null;
            task = null;
            this.loading = false;
            this._finished = true;
            disposable.dispose();
            if (token.isCancellationRequested) return;
            if (totalItems.length == 0) {
              this._onDidChangeItems.fire({ items: [], append: false, sorted: true, reload, finished: true });
              return;
            }
            await _onData(true);
          };
          let disposable = token.onCancellationRequested(() => {
            this.mutex.reset();
            task?.dispose();
            void onEnd();
          });
          let toDispose = task;
          task.on("error", async (error) => {
            if (task == null) return;
            task = null;
            toDispose.dispose();
            this.tokenSource = null;
            this.loading = false;
            disposable.dispose();
            clearInterval(interval2);
            workspace_default.nvim.call("coc#prompt#stop_prompt", ["list"], true);
            workspace_default.nvim.echoError(`Task error: ${error.toString()}`);
            logger32.error("List task error:", error);
          });
          task.on("end", onEnd);
        }
      }
      /*
       * Draw all items with filter if necessary
       */
      async drawItems() {
        let { totalItems } = this;
        if (totalItems.length === 0) return;
        this.cancelFilter();
        let tokenSource = this.filterTokenSource = new import_node4.CancellationTokenSource();
        let token = tokenSource.token;
        await this.mutex.use(async () => {
          if (token.isCancellationRequested) return;
          let { totalItems: totalItems2 } = this;
          this.filteredCount = totalItems2.length;
          await this.filterItems(totalItems2, {}, tokenSource.token);
        });
      }
      cancelFilter() {
        if (this.filterTokenSource) {
          this.filterTokenSource.cancel();
          this.filterTokenSource = null;
        }
      }
      stop() {
        this.cancelFilter();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
        this.loading = false;
      }
      get length() {
        return this.totalItems.length;
      }
      get input() {
        return this.prompt.input;
      }
      /**
       * Add highlights for interactive list
       */
      convertToHighlightItems(items) {
        let input = toText(this.input);
        if (input.length > 0) this.fuzzyMatch.setPattern(input);
        let res = items.map((item) => {
          convertItemLabel(item);
          let search = input.length > 0 && item.filterText !== "";
          if (search) {
            let filterLabel = getFilterLabel(item);
            let results = this.fuzzyMatch.matchHighlights(filterLabel, SEARCH_HL_GROUP);
            item.ansiHighlights = Array.isArray(item.ansiHighlights) ? item.ansiHighlights.filter((o) => o.hlGroup !== SEARCH_HL_GROUP) : [];
            if (results) item.ansiHighlights.push(...results.highlights);
          }
          return item;
        });
        this.fuzzyMatch.free();
        return res;
      }
      async filterItemsByInclude(input, items, token, onFilter) {
        let { ignorecase } = this.listOptions;
        const smartcase = configuration_default.smartcase;
        let inputs = toInputs(input, configuration_default.extendedSearchMode);
        if (ignorecase) inputs = inputs.map((s) => s.toLowerCase());
        await filter(items, (item) => {
          convertItemLabel(item);
          let spans = [];
          let filterLabel = getFilterLabel(item);
          let byteIndex2 = bytes(filterLabel);
          let curr = 0;
          item.ansiHighlights = toArray(item.ansiHighlights).filter((o) => o.hlGroup !== SEARCH_HL_GROUP);
          for (let input2 of inputs) {
            let label = filterLabel.slice(curr);
            let idx = indexOf(label, input2, smartcase, ignorecase);
            if (idx === -1) break;
            let end = idx + curr + input2.length;
            spans.push([byteIndex2(idx + curr), byteIndex2(end)]);
            curr = end;
          }
          if (spans.length !== inputs.length) return false;
          item.ansiHighlights.push(...spans.map((s) => {
            return { span: s, hlGroup: SEARCH_HL_GROUP };
          }));
          return true;
        }, onFilter, token);
      }
      async filterItemsByRegex(input, items, token, onFilter) {
        let { ignorecase } = this.listOptions;
        let flags = ignorecase ? "iu" : "u";
        let inputs = toInputs(input, configuration_default.extendedSearchMode);
        let regexes = inputs.reduce((p, c) => {
          try {
            p.push(new RegExp(c, flags));
          } catch (e) {
          }
          return p;
        }, []);
        await filter(items, (item) => {
          convertItemLabel(item);
          item.ansiHighlights = toArray(item.ansiHighlights).filter((o) => o.hlGroup !== SEARCH_HL_GROUP);
          let spans = [];
          let filterLabel = getFilterLabel(item);
          let byteIndex2 = bytes(filterLabel);
          let curr = 0;
          for (let regex2 of regexes) {
            let ms = filterLabel.slice(curr).match(regex2);
            if (ms == null) break;
            let end = ms.index + curr + ms[0].length;
            spans.push([byteIndex2(ms.index + curr), byteIndex2(end)]);
            curr = end;
          }
          if (spans.length !== inputs.length) return false;
          item.ansiHighlights.push(...spans.map((s) => {
            return { span: s, hlGroup: SEARCH_HL_GROUP };
          }));
          return true;
        }, onFilter, token);
      }
      async filterItemsByFuzzyMatch(input, items, token, onFilter) {
        let { extendedSearchMode, smartcase } = configuration_default;
        let { sort } = this.listOptions;
        let idx = 0;
        this.fuzzyMatch.setPattern(input, !extendedSearchMode);
        let codes = getCharCodes(input);
        if (extendedSearchMode) codes = codes.filter((c) => !WHITE_SPACE_CHARS.includes(c));
        await filter(items, (item) => {
          convertItemLabel(item);
          let filterLabel = getFilterLabel(item);
          let match = this.fuzzyMatch.matchHighlights(filterLabel, SEARCH_HL_GROUP);
          if (!match || smartcase && !fuzzyMatch(codes, filterLabel)) return false;
          let ansiHighlights = Array.isArray(item.ansiHighlights) ? item.ansiHighlights.filter((o) => o.hlGroup != SEARCH_HL_GROUP) : [];
          ansiHighlights.push(...match.highlights);
          return {
            sortText: typeof item.sortText === "string" ? item.sortText : String.fromCharCode(idx),
            score: match.score,
            ansiHighlights
          };
        }, (items2, done) => {
          onFilter(items2, done, sort);
        }, token);
      }
      async filterItems(arr, opts, token) {
        let { input } = this;
        if (input.length === 0) {
          let items = arr.map((item) => {
            return convertItemLabel(item);
          });
          this._onDidChangeItems.fire({ items, sorted: true, finished: this._finished, ...opts });
          return;
        }
        let called = false;
        let itemsToSort = [];
        const onFilter = (items, done, sort) => {
          let finished = done && this._finished;
          if (token.isCancellationRequested || !finished && items.length == 0) return;
          if (sort) {
            itemsToSort.push(...items);
            if (done) this._onDidChangeItems.fire({ items: itemsToSort, append: false, sorted: false, reload: opts.reload, finished });
          } else {
            let append = opts.append === true || called;
            called = true;
            this._onDidChangeItems.fire({ items, append, sorted: true, reload: opts.reload, finished });
          }
        };
        switch (this.listOptions.matcher) {
          case "strict":
            await this.filterItemsByInclude(input, arr, token, onFilter);
            break;
          case "regex":
            await this.filterItemsByRegex(input, arr, token, onFilter);
            break;
          default:
            await this.filterItemsByFuzzyMatch(input, arr, token, onFilter);
        }
      }
      dispose() {
        this.stop();
      }
    };
  }
});

// src/list/session.ts
var frames2, debounceTime5, ListSession;
var init_session = __esm({
  "src/list/session.ts"() {
    "use strict";
    init_highlighter();
    init_util();
    init_node();
    init_protocol();
    init_window();
    init_workspace();
    init_configuration3();
    init_db2();
    init_history();
    init_ui2();
    init_worker();
    frames2 = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
    debounceTime5 = getConditionValue(50, 1);
    ListSession = class {
      constructor(nvim, prompt, list2, listOptions, listArgs) {
        this.nvim = nvim;
        this.prompt = prompt;
        this.list = list2;
        this.listOptions = listOptions;
        this.listArgs = listArgs;
        this.loadingFrame = "";
        this.hidden = false;
        this.disposables = [];
        /**
         * Original list arguments.
         */
        this.args = [];
        this.ui = new ListUI(nvim, list2.name, listOptions);
        this.history = new InputHistory(prompt, list2.name, db_default, workspace_default.cwd);
        this.worker = new Worker(list2, prompt, listOptions);
        let debouncedChangeLine = debounce(async () => {
          let [previewing, currwin, lnum] = await nvim.eval('[coc#list#has_preview(),win_getid(),line(".")]');
          if (previewing && currwin == this.winid) {
            let idx = this.ui.lnumToIndex(lnum);
            await this.doPreview(idx);
          }
        }, debounceTime5);
        this.disposables.push({
          dispose: () => {
            debouncedChangeLine.clear();
          }
        });
        this.ui.onDidChangeLine(debouncedChangeLine, null, this.disposables);
        this.ui.onDidChangeLine(this.resolveItem, this, this.disposables);
        this.ui.onDidLineChange(this.resolveItem, this, this.disposables);
        let debounced = debounce(async () => {
          this.updateStatus();
          let { autoPreview } = this.listOptions;
          if (!autoPreview) {
            let [previewing, mode] = await nvim.eval("[coc#list#has_preview(),mode()]");
            if (mode != "n" || !previewing) return;
          }
          await this.doAction("preview");
        }, 50);
        this.disposables.push({
          dispose: () => {
            debounced.clear();
          }
        });
        this.ui.onDidLineChange(debounced, null, this.disposables);
        this.ui.onDidOpen(async () => {
          if (typeof this.list.doHighlight == "function") {
            this.list.doHighlight();
          }
          if (this.listOptions.first) {
            await this.doAction();
          }
        }, null, this.disposables);
        this.ui.onDidClose(this.hide, this, this.disposables);
        this.ui.onDidDoubleClick(this.doAction, this, this.disposables);
        this.worker.onDidChangeItems((ev) => {
          if (this.hidden) return;
          this.ui.onDidChangeItems(ev);
        }, null, this.disposables);
        let start = 0;
        let timer;
        let interval2;
        this.disposables.push(import_node4.Disposable.create(() => {
          clearTimeout(timer);
          clearInterval(interval2);
        }));
        this.worker.onDidChangeLoading((loading) => {
          if (this.hidden) return;
          if (timer) clearTimeout(timer);
          if (loading) {
            start = Date.now();
            if (interval2) clearInterval(interval2);
            interval2 = setInterval(() => {
              let idx = Math.floor((Date.now() - start) % 1e3 / 100);
              this.loadingFrame = frames2[idx];
              this.updateStatus();
            }, 100);
          } else {
            timer = setTimeout(() => {
              this.loadingFrame = "";
              if (interval2) clearInterval(interval2);
              interval2 = null;
              this.updateStatus();
            }, Math.max(0, 200 - (Date.now() - start)));
          }
        }, null, this.disposables);
      }
      async start(args) {
        this.args = args;
        this.cwd = workspace_default.cwd;
        this.hidden = false;
        let { listArgs } = this;
        let res = await this.nvim.eval(`[win_getid(),bufnr("%"),${workspace_default.isVim ? 'winheight("%")' : "nvim_win_get_height(0)"}]`);
        this.listArgs = listArgs;
        this.history.filter();
        this.targetWinid = res[0];
        this.targetBufnr = res[1];
        this.savedHeight = res[2];
        await this.worker.loadItems(this.context);
      }
      async reloadItems() {
        if (!this.ui.winid) return;
        await this.worker.loadItems(this.context, true);
      }
      async call(fname) {
        await this.nvim.call("coc#prompt#stop_prompt", ["list"]);
        let targets = await this.ui.getItems();
        let context = {
          name: this.name,
          args: this.listArgs,
          input: this.prompt.input,
          winid: this.targetWinid,
          bufnr: this.targetBufnr,
          targets
        };
        let res = await this.nvim.call(fname, [context]);
        this.prompt.start();
        return res;
      }
      async chooseAction() {
        let { nvim, defaultAction } = this;
        let { actions } = this.list;
        let names = actions.map((o) => o.name);
        let idx = names.indexOf(defaultAction.name);
        if (idx != -1) {
          names.splice(idx, 1);
          names.unshift(defaultAction.name);
        }
        let shortcuts = /* @__PURE__ */ new Set();
        let choices = [];
        let invalids = [];
        let menuAction = workspace_default.env.dialog && configuration_default.get("menuAction", false);
        for (let name2 of names) {
          let i = 0;
          for (let ch of name2) {
            if (!shortcuts.has(ch)) {
              shortcuts.add(ch);
              choices.push(`${name2.slice(0, i)}&${name2.slice(i)}`);
              break;
            }
            i++;
          }
          if (i == name2.length) {
            invalids.push(name2);
          }
        }
        if (invalids.length && !menuAction) {
          names = names.filter((s) => !invalids.includes(s));
        }
        let n;
        if (menuAction) {
          nvim.call("coc#prompt#stop_prompt", ["list"], true);
          n = await window_default.showMenuPicker(names, { title: "Choose action", shortcuts: true });
          n = n + 1;
          this.prompt.start();
        } else {
          await nvim.call("coc#prompt#stop_prompt", ["list"]);
          n = await nvim.call("confirm", ["Choose action:", choices.join("\n")]);
          await wait(10);
          this.prompt.start();
        }
        if (n) await this.doAction(names[n - 1]);
      }
      async doAction(name2) {
        let { list: list2 } = this;
        let action;
        if (name2 != null) {
          action = list2.actions.find((o) => o.name == name2);
          if (!action) {
            void window_default.showErrorMessage(`Action ${name2} not found`);
            return;
          }
        } else {
          action = this.defaultAction;
        }
        let items;
        if (name2 == "preview") {
          let item = await this.ui.item;
          items = item ? [item] : [];
        } else {
          items = await this.ui.getItems();
        }
        if (items.length) await this.doItemAction(items, action);
      }
      async doPreview(index) {
        let item = this.ui.getItem(index);
        let action = this.list.actions.find((o) => o.name == "preview");
        if (!item || !action) return;
        await this.doItemAction([item], action);
      }
      async first() {
        await this.doDefaultAction(0);
      }
      async last() {
        await this.doDefaultAction(this.ui.length - 1);
      }
      async previous() {
        await this.doDefaultAction(this.ui.index - 1);
      }
      async next() {
        await this.doDefaultAction(this.ui.index + 1);
      }
      async doDefaultAction(index) {
        let { ui } = this;
        let item = ui.getItem(index);
        if (!item) return;
        await this.ui.setIndex(index);
        await this.doItemAction([item], this.defaultAction);
        await ui.echoMessage(item);
      }
      /**
       * list name
       */
      get name() {
        return this.list.name;
      }
      /**
       * Window id used by list.
       * @returns {number | undefined}
       */
      get winid() {
        return this.ui.winid;
      }
      get length() {
        return this.ui.length;
      }
      get defaultAction() {
        let { defaultAction, actions, name: name2 } = this.list;
        let config = workspace_default.getConfiguration(`list.source.${name2}`);
        let action;
        if (config.defaultAction) action = actions.find((o) => o.name == config.defaultAction);
        if (!action) action = actions.find((o) => o.name == defaultAction);
        if (!action) action = actions[0];
        if (!action) throw new Error(`default action "${defaultAction}" not found`);
        return action;
      }
      async hide(notify = false, isVim2 = workspace_default.isVim) {
        if (this.hidden) return;
        let { nvim, timer, targetWinid, context } = this;
        let { winid } = this.ui;
        if (timer) clearTimeout(timer);
        this.worker.stop();
        this.history.add();
        this.ui.reset();
        db_default.save();
        this.hidden = true;
        nvim.pauseNotification();
        if (!isVim2) nvim.call("coc#prompt#stop_prompt", ["list"], true);
        if (winid) nvim.call("coc#list#close", [winid, context.options.position, targetWinid, this.savedHeight], true);
        if (notify) return nvim.resumeNotification(true, true);
        await nvim.resumeNotification(false);
        if (isVim2) {
          await wait(10);
          nvim.call("coc#prompt#stop_prompt", ["list"], true);
          nvim.redrawVim();
        }
      }
      toggleMode() {
        let mode = this.prompt.mode == "normal" ? "insert" : "normal";
        this.prompt.mode = mode;
        this.listOptions.mode = mode;
        this.updateStatus();
      }
      stop() {
        this.worker.stop();
      }
      async resolveItem() {
        let index = this.ui.index;
        let item = this.ui.getItem(index);
        if (!item || item.resolved) return;
        let { list: list2 } = this;
        if (typeof list2.resolveItem === "function") {
          let label = item.label;
          let resolved = await Promise.resolve(list2.resolveItem(item));
          if (resolved && index == this.ui.index) {
            Object.assign(item, resolved, { resolved: true });
            if (label == resolved.label) return;
            this.ui.updateItem(item, index);
          }
        }
      }
      async showHelp() {
        await this.hide();
        let { list: list2, nvim } = this;
        nvim.pauseNotification();
        nvim.command(`tabe +setl\\ previewwindow [LIST HELP]`, true);
        nvim.command("setl nobuflisted noswapfile buftype=nofile bufhidden=wipe", true);
        await nvim.resumeNotification();
        let hasOptions = list2.options && list2.options.length;
        let buf = await nvim.buffer;
        let highlighter = new Highlighter();
        highlighter.addLine("NAME", "Label");
        highlighter.addLine(`  ${list2.name} - ${list2.description || ""}
`);
        highlighter.addLine("SYNOPSIS", "Label");
        highlighter.addLine(`  :CocList [LIST OPTIONS] ${list2.name}${hasOptions ? " [ARGUMENTS]" : ""}
`);
        if (list2.detail) {
          highlighter.addLine("DESCRIPTION", "Label");
          let lines = list2.detail.split("\n").map((s) => "  " + s);
          highlighter.addLine(lines.join("\n") + "\n");
        }
        if (hasOptions) {
          highlighter.addLine("ARGUMENTS", "Label");
          highlighter.addLine("");
          for (let opt of list2.options) {
            highlighter.addLine(opt.name, "Special");
            highlighter.addLine(`  ${opt.description}`);
            highlighter.addLine("");
          }
          highlighter.addLine("");
        }
        let config = workspace_default.getConfiguration(`list.source.${list2.name}`);
        if (Object.keys(config).length) {
          highlighter.addLine("CONFIGURATIONS", "Label");
          highlighter.addLine("");
          for (let key of Object.keys(config)) {
            let val = config[key];
            let name2 = `list.source.${list2.name}.${key}`;
            let description = defaultValue(workspace_default.configurations.getDescription(name2), key);
            highlighter.addLine(`  "${name2}"`, "MoreMsg");
            highlighter.addText(` - ${description} current value: `);
            highlighter.addText(JSON.stringify(val), "Special");
          }
          highlighter.addLine("");
        }
        highlighter.addLine("ACTIONS", "Label");
        highlighter.addLine(`  ${list2.actions.map((o) => o.name).join(", ")}`);
        highlighter.addLine("");
        highlighter.addLine(`see ':h coc-list-options' for available list options.`, "Comment");
        nvim.pauseNotification();
        highlighter.render(buf, 0, -1);
        nvim.command("setl nomod", true);
        nvim.command("setl nomodifiable", true);
        nvim.command("normal! gg", true);
        nvim.command("nnoremap <buffer> q :bd!<CR>", true);
        await nvim.resumeNotification();
      }
      async switchMatcher() {
        let { matcher, interactive } = this.listOptions;
        if (interactive) return;
        const list2 = ["fuzzy", "strict", "regex"];
        let idx = list2.indexOf(matcher) + 1;
        if (idx >= list2.length) idx = 0;
        this.listOptions.matcher = list2[idx];
        this.prompt.matcher = list2[idx];
        await this.worker.drawItems();
      }
      updateStatus() {
        let { ui, list: list2, nvim } = this;
        if (!ui.bufnr) return;
        let buf = nvim.createBuffer(ui.bufnr);
        let status = {
          mode: this.prompt.mode.toUpperCase(),
          args: this.args.join(" "),
          name: list2.name,
          cwd: this.cwd,
          loading: this.loadingFrame,
          total: this.worker.length
        };
        buf.setVar("list_status", status, true);
        nvim.command("redraws", true);
      }
      get context() {
        let { winid } = this.ui;
        return {
          options: this.listOptions,
          args: this.listArgs,
          input: this.prompt.input,
          cwd: workspace_default.cwd,
          window: this.window,
          buffer: this.buffer,
          listWindow: winid ? this.nvim.createWindow(winid) : void 0
        };
      }
      get window() {
        return this.targetWinid ? this.nvim.createWindow(this.targetWinid) : void 0;
      }
      get buffer() {
        return this.targetBufnr ? this.nvim.createBuffer(this.targetBufnr) : void 0;
      }
      onMouseEvent(key) {
        switch (key) {
          case "<LeftMouse>":
            return this.ui.onMouse("mouseDown");
          case "<LeftDrag>":
            return this.ui.onMouse("mouseDrag");
          case "<LeftRelease>":
            return this.ui.onMouse("mouseUp");
          case "<2-LeftMouse>":
            return this.ui.onMouse("doubleClick");
        }
      }
      async doNumberSelect(ch) {
        if (!this.listOptions.numberSelect) return false;
        let code = ch.charCodeAt(0);
        if (code >= 48 && code <= 57) {
          let n = Number(ch);
          if (n == 0) n = 10;
          if (this.ui.length >= n) {
            this.nvim.pauseNotification();
            this.ui.setCursor(n);
            await this.nvim.resumeNotification();
            await this.doAction();
            return true;
          }
        }
        return false;
      }
      jumpBack() {
        let { targetWinid, nvim } = this;
        if (targetWinid) {
          nvim.pauseNotification();
          nvim.call("coc#prompt#stop_prompt", ["list"], true);
          this.nvim.call("win_gotoid", [targetWinid], true);
          nvim.resumeNotification(false, true);
        }
      }
      async resume() {
        if (this.winid) await this.hide();
        let res = await this.nvim.eval(`[win_getid(),bufnr("%"),${workspace_default.isVim ? 'winheight("%")' : "nvim_win_get_height(0)"}]`);
        this.hidden = false;
        this.targetWinid = res[0];
        this.targetBufnr = res[1];
        this.savedHeight = res[2];
        this.prompt.start();
        await this.ui.resume();
        if (this.listOptions.autoPreview) {
          await this.doAction("preview");
        }
      }
      async doItemAction(items, action) {
        let { noQuit, position } = this.listOptions;
        let { nvim } = this;
        let persistAction = action.persist === true || action.name == "preview";
        if (position === "tab" && action.tabPersist) persistAction = true;
        let persist = this.winid && (persistAction || noQuit);
        if (persist) {
          if (!persistAction) {
            nvim.pauseNotification();
            nvim.call("coc#prompt#stop_prompt", ["list"], true);
            nvim.call("win_gotoid", [this.context.window.id], true);
            await nvim.resumeNotification();
          }
        } else {
          await this.hide();
        }
        if (action.multiple) {
          await Promise.resolve(action.execute(items, this.context));
        } else if (action.parallel) {
          await Promise.all(items.map((item) => Promise.resolve(action.execute(item, this.context))));
        } else {
          for (let item of items) {
            await Promise.resolve(action.execute(item, this.context));
          }
        }
        if (persist) this.ui.restoreWindow();
        if (action.reload && persist) {
          await this.reloadItems();
        } else if (persist) {
          this.nvim.command("redraw", true);
        }
      }
      onInputChange() {
        if (this.timer) clearTimeout(this.timer);
        this.ui.cancel();
        this.history.filter();
        this.listOptions.input = this.prompt.input;
        if (this.listOptions.interactive) {
          this.worker.stop();
          this.timer = setTimeout(async () => {
            await this.worker.loadItems(this.context);
          }, configuration_default.debounceTime);
        } else {
          void this.worker.drawItems();
        }
      }
      dispose() {
        void this.hide(true);
        disposeAll(this.disposables);
        this.worker.dispose();
        this.ui.dispose();
      }
    };
  }
});

// src/list/formatting.ts
function fixWidth(str, width) {
  if (str.length > width) {
    return str.slice(0, width - 1) + ".";
  }
  return str + " ".repeat(width - str.length);
}
function formatUri(uri, cwd2) {
  if (!uri.startsWith("file:")) return uri;
  let filepath = URI2.parse(uri).fsPath;
  return isParentFolder(cwd2, filepath) ? path.relative(cwd2, filepath) : filepath;
}
function formatListItems(align, list2) {
  if (list2.length === 0) {
    return [];
  }
  let processedList = [];
  if (align) {
    const maxWidths = Array(Math.min(...list2.map((item) => item.label.length))).fill(0);
    for (let item of list2) {
      for (let i = 0; i < maxWidths.length; i++) {
        maxWidths[i] = Math.max(maxWidths[i], item.label[i].length);
      }
    }
    processedList = list2.map((item) => ({
      ...item,
      label: item.label.map((element, idx) => element.padEnd(maxWidths[idx])).join("	")
    }));
  } else {
    processedList = list2.map((item) => ({ ...item, label: item.label.join("	") }));
  }
  return processedList;
}
function formatPath(format3, pathToFormat) {
  if (format3 === "hidden") {
    return "";
  } else if (format3 === "full") {
    return pathToFormat;
  } else if (format3 === "short") {
    const segments = pathToFormat.split(path.sep);
    if (segments.length < 2) {
      return pathToFormat;
    }
    const shortenedInit = segments.slice(0, segments.length - 2).filter((seg) => seg.length > 0).map((seg) => seg[0]);
    return [...shortenedInit, segments[segments.length - 1]].join(path.sep);
  } else {
    const segments = pathToFormat.split(path.sep);
    return toText(segments[segments.length - 1]);
  }
}
var init_formatting = __esm({
  "src/list/formatting.ts"() {
    "use strict";
    init_node();
    init_esm();
    init_fs();
    init_string();
  }
});

// src/list/source/commands.ts
function score2(list2, key) {
  let idx = list2.indexOf(key);
  return idx == -1 ? -1 : list2.length - idx;
}
var extensionRegistry4, CommandsList;
var init_commands2 = __esm({
  "src/list/source/commands.ts"() {
    "use strict";
    init_commands();
    init_extensionRegistry();
    init_registry();
    init_workspace();
    init_basic();
    init_formatting();
    init_string();
    extensionRegistry4 = Registry.as(Extensions.ExtensionContribution);
    CommandsList = class extends BasicList {
      constructor() {
        super();
        this.defaultAction = "run";
        this.description = "registered commands of coc.nvim";
        this.name = "commands";
        this.mru = workspace_default.createMru("commands");
        this.addAction("run", async (item) => {
          await commands_default.fireCommand(item.data.cmd);
        });
        this.addAction("append", async (item) => {
          let { cmd } = item.data;
          await workspace_default.nvim.feedKeys(`:CocCommand ${cmd} `, "n", false);
        });
      }
      async loadItems(_context) {
        let items = [];
        let mruList = await this.mru.load();
        let ids = /* @__PURE__ */ new Set();
        for (const obj of extensionRegistry4.onCommands.concat(commands_default.commandList)) {
          let { id: id2, title } = obj;
          if (ids.has(id2)) continue;
          ids.add(id2);
          let desc = toText(title);
          items.push({
            label: [id2, desc],
            filterText: id2 + " " + desc,
            data: { cmd: id2, score: score2(mruList, id2) }
          });
        }
        items.sort((a, b) => b.data.score - a.data.score);
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocCommandsTitle /\\t.*$/ contained containedin=CocCommandsLine", true);
        nvim.command("highlight default link CocCommandsTitle Comment", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/location.ts
var LocationList;
var init_location = __esm({
  "src/list/source/location.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_commands();
    init_array();
    init_fs();
    init_node();
    init_string();
    init_basic();
    LocationList = class extends BasicList {
      constructor() {
        super();
        this.defaultAction = "open";
        this.description = "show locations saved by g:coc_jump_locations variable";
        this.name = "location";
        this.createAction({
          name: "refactor",
          multiple: true,
          execute: async (items) => {
            let locations = items.map((o) => o.location);
            await commands_default.executeCommand("editor.action.showRefactor", locations);
          }
        });
        this.addLocationActions();
      }
      formatFilepath(file) {
        if (typeof global.formatFilepath === "function") {
          return global.formatFilepath(file) + "";
        }
        return file;
      }
      async loadItems(context, _token) {
        let locs = await this.nvim.getVar("coc_jump_locations");
        locs = toArray(locs);
        let bufnr = context.buffer.id;
        let ignoreFilepath = locs.every((o) => o.bufnr == bufnr);
        let items = locs.map((loc) => {
          let filename = ignoreFilepath ? "" : loc.filename;
          if (filename.length > 0 && path.isAbsolute(filename)) {
            filename = isParentFolder(context.cwd, filename) ? path.relative(context.cwd, filename) : filename;
          }
          return this.createItem(filename, loc);
        });
        return items;
      }
      createItem(filename, loc) {
        let uri = loc.uri ?? URI2.file(loc.filename).toString();
        let label = "";
        const ansiHighlights = [];
        let start = 0;
        filename = this.formatFilepath(filename);
        if (filename.length > 0) {
          label = filename + " ";
          ansiHighlights.push({ span: [start, start + byteLength(filename)], hlGroup: "Directory" });
        }
        start = byteLength(label);
        let lnum = loc.lnum ?? loc.range.start.line + 1;
        let col = loc.col ?? byteLength(loc.text.slice(0, loc.range.start.character)) + 1;
        let position = `|${loc.type ? loc.type + " " : ""}${lnum} Col ${col}|`;
        label += position;
        ansiHighlights.push({ span: [start, start + byteLength(position)], hlGroup: "LineNr" });
        if (loc.type) {
          let hl = loc.type.toLowerCase() === "error" ? "Error" : "WarningMsg";
          ansiHighlights.push({ span: [start + 1, start + byteLength(loc.type)], hlGroup: hl });
        }
        if (loc.range && loc.range.start.line == loc.range.end.line) {
          let len = byteLength(label) + 1;
          let start2 = len + byteLength(loc.text.slice(0, loc.range.start.character));
          let end = len + byteLength(loc.text.slice(0, loc.range.end.character));
          ansiHighlights.push({ span: [start2, end], hlGroup: "Search" });
        }
        label += " " + loc.text;
        let filterText = `${filename}${loc.text.trim()}`;
        let location;
        if (loc.range) {
          location = Location.create(uri, loc.range);
        } else {
          let start2 = Position.create(loc.lnum - 1, loc.col - 1);
          let end = Position.create((loc.end_lnum ?? loc.lnum) - 1, (loc.end_col ?? loc.col) - 1);
          location = Location.create(uri, Range.create(start2, end));
        }
        location.targetRange = loc.targetRange ? loc.targetRange : Range.create(lnum - 1, 0, lnum - 1, 99);
        return {
          label,
          location,
          filterText,
          ansiHighlights
        };
      }
    };
  }
});

// src/list/source/diagnostics.ts
function convertToLabel(item, cwd2, includeCode, pathFormat = "full") {
  const file = isParentFolder(cwd2, item.file) ? path.relative(cwd2, item.file) : item.file;
  const formattedPath = formatPath(pathFormat, file);
  const formattedPosition = pathFormat !== "hidden" ? [`${formattedPath}:${item.lnum}`] : [];
  const source = includeCode ? `[${item.source} ${defaultValue(item.code, "")}]` : item.source;
  return [...formattedPosition, source, item.severity, item.message];
}
var DiagnosticsList;
var init_diagnostics = __esm({
  "src/list/source/diagnostics.ts"() {
    "use strict";
    init_esm();
    init_manager();
    init_util5();
    init_util();
    init_fs();
    init_node();
    init_workspace();
    init_formatting();
    init_location();
    DiagnosticsList = class extends LocationList {
      constructor(manager, event = true) {
        super();
        this.defaultAction = "open";
        this.description = "diagnostics of current workspace";
        this.name = "diagnostics";
        this.options = [{
          name: "--buffer",
          hasValue: false,
          description: "list diagnostics of current buffer only"
        }, {
          name: "--workspace-folder",
          hasValue: false,
          description: "list diagnostics of current workspace folder only"
        }, {
          name: "-l, -level LEVEL",
          hasValue: true,
          description: 'filter diagnostics by diagnostic level, could be "error", "warning" and "information"'
        }];
        if (event) {
          manager_default.onDidRefresh(async () => {
            let session = manager.getSession("diagnostics");
            if (session) await session.reloadItems();
          }, null, this.disposables);
        }
      }
      async filterDiagnostics(parsedArgs) {
        let list2 = await manager_default.getDiagnosticList();
        if (parsedArgs["workspace-folder"]) {
          const folder = workspace_default.getWorkspaceFolder(workspace_default.root);
          if (folder) {
            const normalized = URI2.parse(folder.uri);
            list2 = list2.filter((item) => isParentFolder(normalized.fsPath, item.file));
          }
        } else if (parsedArgs.buffer) {
          const doc = await workspace_default.document;
          const normalized = URI2.parse(doc.uri);
          list2 = list2.filter((item) => item.file === normalized.fsPath);
        }
        if (typeof parsedArgs.level === "string") {
          let level2 = severityLevel(parsedArgs.level);
          list2 = list2.filter((item) => item.level <= level2);
        }
        return list2;
      }
      async loadItems(context) {
        let { cwd: cwd2, args } = context;
        const parsedArgs = this.parseArguments(args);
        let list2 = await this.filterDiagnostics(parsedArgs);
        const config = this.getConfig();
        const includeCode = config.get("includeCode", true);
        const pathFormat = config.get("pathFormat", "full");
        const unformatted = list2.map((item) => {
          return {
            label: convertToLabel(item, cwd2, includeCode, pathFormat),
            location: item.location
          };
        });
        return formatListItems(this.alignColumns, unformatted);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocDiagnosticsFile /\\v^\\s*\\S+/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsError /\\tError\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsWarning /\\tWarning\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsInfo /\\tInformation\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsHint /\\tHint\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("highlight default link CocDiagnosticsFile Comment", true);
        nvim.command("highlight default link CocDiagnosticsError CocErrorSign", true);
        nvim.command("highlight default link CocDiagnosticsWarning CocWarningSign", true);
        nvim.command("highlight default link CocDiagnosticsInfo CocInfoSign", true);
        nvim.command("highlight default link CocDiagnosticsHint CocHintSign", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/extensions.ts
function sortExtensionItem(a, b) {
  if (a.data.priority != b.data.priority) {
    return b.data.priority - a.data.priority;
  }
  return b.data.id > a.data.id ? 1 : -1;
}
function getExtensionPrefix(state) {
  let prefix = "+";
  if (state == "disabled") {
    prefix = "-";
  } else if (state == "activated") {
    prefix = "*";
  } else if (state == "unknown") {
    prefix = "?";
  }
  return prefix;
}
function getExtensionPriority(stat) {
  switch (stat) {
    case "unknown":
      return 2;
    case "activated":
      return 1;
    case "disabled":
      return -1;
    default:
      return 0;
  }
}
var delay2, ExtensionList;
var init_extensions = __esm({
  "src/list/source/extensions.ts"() {
    "use strict";
    init_esm();
    init_extension();
    init_util();
    init_node();
    init_workspace();
    init_basic();
    init_formatting();
    delay2 = getConditionValue(50, 0);
    ExtensionList = class extends BasicList {
      constructor(manager) {
        super();
        this.manager = manager;
        this.defaultAction = "toggle";
        this.description = "manage coc extensions";
        this.name = "extensions";
        this.addAction("toggle", async (item) => {
          let { id: id2, state } = item.data;
          if (state == "disabled") return;
          if (state == "activated") {
            await this.manager.deactivate(id2);
          } else {
            await this.manager.activate(id2);
          }
          await wait(delay2);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("configuration", async (item) => {
          let { root } = item.data;
          let jsonFile = path.join(root, "package.json");
          if (fs.existsSync(jsonFile)) {
            let lines = fs.readFileSync(jsonFile, "utf8").split(/\r?\n/);
            let idx = lines.findIndex((s) => s.includes('"contributes"'));
            await workspace_default.jumpTo(URI2.file(jsonFile), { line: idx == -1 ? 0 : idx, character: 0 });
          }
        });
        this.addAction("open", async (item) => {
          let { root } = item.data;
          workspace_default.nvim.call("coc#ui#open_url", [root], true);
        });
        this.addAction("disable", async (item) => {
          let { id: id2, state } = item.data;
          if (state !== "disabled") await this.manager.toggleExtension(id2);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("enable", async (item) => {
          let { id: id2, state } = item.data;
          if (state == "disabled") await this.manager.toggleExtension(id2);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("lock", async (item) => {
          let { id: id2 } = item.data;
          this.manager.states.setLocked(id2, true);
        }, { persist: true, reload: true });
        this.addAction("help", async (item) => {
          let { root } = item.data;
          let files = fs.readdirSync(root, { encoding: "utf8" });
          let file = files.find((f) => /^readme/i.test(f));
          if (file) await workspace_default.jumpTo(URI2.file(path.join(root, file)));
        });
        this.addAction("reload", async (item) => {
          let { id: id2 } = item.data;
          await this.manager.reloadExtension(id2);
        }, { persist: true, reload: true });
        this.addMultipleAction("uninstall", async (items) => {
          let ids = [];
          for (let item of items) {
            if (item.data.isLocal) continue;
            ids.push(item.data.id);
          }
          await this.manager.uninstallExtensions(ids);
        });
      }
      async loadItems() {
        let items = [];
        let list2 = await extension_default.getExtensionStates();
        for (let stat of list2) {
          let prefix = getExtensionPrefix(stat.state);
          let root = fs.realpathSync(stat.root);
          let locked = stat.isLocked;
          items.push({
            label: [`${prefix} ${stat.id}${locked ? " \uE0A2" : ""}`, ...stat.isLocal ? ["[RTP]"] : [], stat.version, root.replace(os.homedir(), "~")],
            filterText: stat.id,
            data: {
              id: stat.id,
              root,
              state: stat.state,
              isLocal: stat.isLocal,
              priority: getExtensionPriority(stat.state)
            }
          });
        }
        items.sort(sortExtensionItem);
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocExtensionsActivited /\\v^\\*/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsLoaded /\\v^\\+/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsDisabled /\\v^-/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsName /\\v%3c\\S+/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsRoot /\\v\\t[^\\t]*$/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsLocal /\\v\\[RTP\\]/ contained containedin=CocExtensionsLine", true);
        nvim.command("highlight default link CocExtensionsActivited Special", true);
        nvim.command("highlight default link CocExtensionsLoaded Normal", true);
        nvim.command("highlight default link CocExtensionsDisabled Comment", true);
        nvim.command("highlight default link CocExtensionsName String", true);
        nvim.command("highlight default link CocExtensionsLocal MoreMsg", true);
        nvim.command("highlight default link CocExtensionsRoot Comment", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/folders.ts
var FoldList;
var init_folders = __esm({
  "src/list/source/folders.ts"() {
    "use strict";
    init_esm();
    init_fs();
    init_window();
    init_workspace();
    init_basic();
    FoldList = class extends BasicList {
      constructor() {
        super();
        this.defaultAction = "edit";
        this.description = "list of current workspace folders";
        this.name = "folders";
        this.addAction("edit", async (item) => {
          let newPath = await this.nvim.call("input", ["Folder: ", item.label, "dir"]);
          if (!isDirectory(newPath)) {
            void window_default.showWarningMessage(`invalid path: ${newPath}`);
            return;
          }
          workspace_default.workspaceFolderControl.renameWorkspaceFolder(item.label, newPath);
        });
        this.addAction("delete", async (item) => {
          workspace_default.workspaceFolderControl.removeWorkspaceFolder(item.label);
        }, { reload: true, persist: true });
        this.addAction("newfile", async (item, context) => {
          let file = await window_default.requestInput("File name", item.label + "/");
          if (!file) return;
          await workspace_default.createFile(file, { overwrite: false, ignoreIfExists: true });
          await this.jumpTo(URI2.file(file).toString(), null, context);
        });
      }
      async loadItems() {
        return workspace_default.folderPaths.map((p) => ({ label: p }));
      }
    };
  }
});

// src/list/source/links.ts
var LinksList;
var init_links = __esm({
  "src/list/source/links.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_workspace();
    init_basic();
    init_formatting();
    LinksList = class extends BasicList {
      constructor() {
        super();
        this.defaultAction = "open";
        this.description = "links of current buffer";
        this.name = "links";
        this.addAction("open", async (item) => {
          let { target } = item.data;
          await workspace_default.openResource(target);
        });
        this.addAction("jump", async (item) => {
          let { location } = item.data;
          await workspace_default.jumpTo(location.uri, location.range.start);
        });
      }
      async loadItems(context, token) {
        let buf = await context.window.buffer;
        let doc = workspace_default.getAttachedDocument(buf.id);
        let items = [];
        let links2 = await languages_default.getDocumentLinks(doc.textDocument, token);
        if (links2 == null) throw new Error("Links provider not found.");
        for (let link of links2) {
          link = link.target ? link : await languages_default.resolveDocumentLink(link, token);
          if (link.target) {
            items.push({
              label: formatUri(link.target, workspace_default.cwd),
              data: {
                target: link.target,
                location: Location.create(doc.uri, link.range)
              }
            });
          }
        }
        return items;
      }
    };
  }
});

// src/list/source/lists.ts
function mruScore(list2, key) {
  let idx = list2.indexOf(key);
  return idx == -1 ? -1 : list2.length - idx;
}
var ListsList;
var init_lists = __esm({
  "src/list/source/lists.ts"() {
    "use strict";
    init_mru();
    init_string();
    init_basic();
    init_formatting();
    ListsList = class extends BasicList {
      constructor(listMap) {
        super();
        this.listMap = listMap;
        this.name = "lists";
        this.defaultAction = "open";
        this.description = "registered lists of coc.nvim";
        this.mru = new Mru("lists");
        this.addAction("open", async (item) => {
          let { name: name2 } = item.data;
          await this.mru.add(name2);
          setTimeout(() => {
            this.nvim.command(`CocList ${name2}`, true);
          }, 50);
        });
      }
      async loadItems(_context) {
        let items = [];
        let mruList = await this.mru.load();
        for (let list2 of this.listMap.values()) {
          if (list2.name == "lists") continue;
          items.push({
            label: [list2.name, toText(list2.description)],
            data: {
              name: list2.name,
              interactive: list2.interactive,
              score: mruScore(mruList, list2.name)
            }
          });
        }
        items.sort((a, b) => b.data.score - a.data.score);
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocListsDesc /\\t.*$/ contained containedin=CocListsLine", true);
        nvim.command("highlight default link CocListsDesc Comment", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/outline.ts
function symbolsToListItems(symbols, uri, filterKind) {
  let items = [];
  const addSymbols = (symbols2, level2 = 0) => {
    symbols2.sort((a, b) => {
      return compareRangesUsingStarts(a.selectionRange, b.selectionRange);
    });
    for (let s of symbols2) {
      let kind = getSymbolKind(s.kind);
      let location = Location.create(uri, s.selectionRange);
      items.push({
        label: [`${"| ".repeat(level2)}${s.name}`, `[${kind}]`, `${s.range.start.line + 1}`],
        filterText: getFilterText(s, filterKind),
        location,
        data: { kind }
      });
      if (!isFalsyOrEmpty(s.children)) {
        addSymbols(s.children, level2 + 1);
      }
    }
  };
  addSymbols(symbols);
  if (filterKind) {
    items = items.filter((o) => o.data.kind.toLowerCase().indexOf(filterKind) == 0);
  }
  return items;
}
function getFilterText(s, kind) {
  if (typeof kind === "string" && kind.length > 0) return s.name;
  return `${s.name}${getSymbolKind(s.kind)}`;
}
async function loadCtagsSymbols(document2, nvim, token) {
  if (!which.sync("ctags", { nothrow: true })) {
    return [];
  }
  let uri = URI2.parse(document2.uri);
  let extname = path.extname(uri.fsPath);
  let content = "";
  let tempname = await nvim.call("tempname");
  let filepath = `${tempname}.${extname}`;
  let cwd2 = path.dirname(tempname);
  let escaped = await nvim.call("fnameescape", filepath);
  await writeFile(escaped, document2.getDocumentContent());
  try {
    content = await runCommand(`ctags -f - --excmd=number --language-force=${document2.filetype} ${escaped}`, { cwd: cwd2 }, token);
  } catch (e) {
  }
  if (!content.trim().length) {
    content = await runCommand(`ctags -f - --excmd=number ${escaped}`, { cwd: cwd2 }, token);
  }
  content = content.trim();
  if (!content) return [];
  return contentToItems(content, document2);
}
function contentToItems(content, document2) {
  let lines = content.split(/\r?\n/);
  let items = [];
  for (let line of lines) {
    let parts = line.split("	");
    if (parts.length < 4) continue;
    let lnum = Number(parts[2].replace(/;"$/, ""));
    let text = document2.getline(lnum - 1);
    let idx = text.indexOf(parts[0]);
    let start = idx == -1 ? 0 : idx;
    let range = Range.create(lnum - 1, start, lnum - 1, start + parts[0].length);
    items.push({
      label: `${parts[0]} [${parts[3]}] ${lnum}`,
      filterText: parts[0],
      location: Location.create(document2.uri, range),
      data: { line: lnum }
    });
  }
  items.sort((a, b) => a.data.line - b.data.line);
  return items;
}
var Outline;
var init_outline = __esm({
  "src/list/source/outline.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_languages();
    init_array();
    init_convert();
    init_fs();
    init_node();
    init_position();
    init_processes();
    init_workspace();
    init_formatting();
    init_location();
    Outline = class extends LocationList {
      constructor() {
        super(...arguments);
        this.description = "symbols of current document";
        this.name = "outline";
        this.options = [{
          name: "-k, -kind KIND",
          hasValue: true,
          description: "filter symbol by kind"
        }];
      }
      async loadItems(context, token) {
        let document2 = workspace_default.getAttachedDocument(context.buffer.id);
        let config = this.getConfig();
        let ctagsFiletypes = config.get("ctagsFiletypes", []);
        let symbols;
        let args = this.parseArguments(context.args);
        let filterKind = args.kind ? args.kind.toString().toLowerCase() : null;
        if (!ctagsFiletypes.includes(document2.filetype)) {
          symbols = await languages_default.getDocumentSymbol(document2.textDocument, token);
        }
        if (token.isCancellationRequested) return [];
        if (!symbols) return await loadCtagsSymbols(document2, this.nvim, token);
        if (isFalsyOrEmpty(symbols)) return [];
        let items = symbolsToListItems(symbols, document2.uri, filterKind);
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocOutlineName /\\v\\s?[^\\t]+\\s/ contained containedin=CocOutlineLine", true);
        nvim.command("syntax match CocOutlineIndentLine /\\v\\|/ contained containedin=CocOutlineLine,CocOutlineName", true);
        nvim.command("syntax match CocOutlineKind /\\[\\w\\+\\]/ contained containedin=CocOutlineLine", true);
        nvim.command("syntax match CocOutlineLine /\\d\\+$/ contained containedin=CocOutlineLine", true);
        nvim.command("highlight default link CocOutlineName Normal", true);
        nvim.command("highlight default link CocOutlineIndentLine Comment", true);
        nvim.command("highlight default link CocOutlineKind Typedef", true);
        nvim.command("highlight default link CocOutlineLine Comment", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/language-client/utils/uuid.ts
function generateUuid() {
  return v4_default();
}
var init_uuid = __esm({
  "src/language-client/utils/uuid.ts"() {
    "use strict";
    init_esm_node();
  }
});

// src/language-client/features.ts
function ensure(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var LSPCancellationError, BaseFeature, StaticFeature, DynamicFeature, DynamicDocumentFeature, TextDocumentEventFeature, TextDocumentLanguageFeature;
var init_features = __esm({
  "src/language-client/features.ts"() {
    "use strict";
    init_errors();
    init_is();
    init_protocol();
    init_workspace();
    init_uuid();
    LSPCancellationError = class extends CancellationError {
      constructor(data) {
        super();
        this.data = data;
      }
    };
    BaseFeature = class {
      constructor(client) {
        this._client = client;
      }
      sendRequest(type, params, token, defaultValue2) {
        return this._client.sendRequest(type, params, token).then((res) => {
          return token.isCancellationRequested || res == null ? defaultValue2 ?? null : res;
        }, (error) => {
          return this._client.handleFailedRequest(type, token, error, defaultValue2 ?? null);
        });
      }
    };
    ((StaticFeature4) => {
      function is(value) {
        return value !== void 0 && value !== null && func(value.fillClientCapabilities) && func(value.initialize) && func(value.dispose) && (value.fillInitializeParams === void 0 || func(value.fillInitializeParams)) && value.registrationType === void 0;
      }
      StaticFeature4.is = is;
    })(StaticFeature || (StaticFeature = {}));
    ((DynamicFeature8) => {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && func(candidate.fillClientCapabilities) && func(candidate.initialize) && func(candidate.dispose) && (candidate.fillInitializeParams === void 0 || func(candidate.fillInitializeParams)) && func(candidate.register) && func(candidate.unregister) && candidate.registrationType !== void 0;
      }
      DynamicFeature8.is = is;
    })(DynamicFeature || (DynamicFeature = {}));
    DynamicDocumentFeature = class extends BaseFeature {
      constructor(client) {
        super(client);
      }
      /**
       * Returns the state the feature is in.
       */
      getState() {
        const selectors = this.getDocumentSelectors();
        let count = 0;
        for (const selector of selectors) {
          count++;
          for (const document2 of workspace_default.textDocuments) {
            if (workspace_default.match(selector, document2) > 0) {
              return { kind: "document", id: this.registrationType.method, registrations: true, matches: true };
            }
          }
        }
        const registrations = count > 0;
        return { kind: "document", id: this.registrationType.method, registrations, matches: false };
      }
    };
    TextDocumentEventFeature = class extends DynamicDocumentFeature {
      static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
          if (workspace_default.match(selector, textDocument) > 0) {
            return true;
          }
        }
        return false;
      }
      constructor(client, event, type, middleware, createParams, selectorFilter) {
        super(client);
        this._event = event;
        this._type = type;
        this._middleware = middleware;
        this._createParams = createParams;
        this._selectorFilter = selectorFilter;
        this._selectors = /* @__PURE__ */ new Map();
        this._onNotificationSent = new import_node4.Emitter();
      }
      getDocumentSelectors() {
        return this._selectors.values();
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = this._event((data2) => {
            this.callback(data2).catch((error) => {
              this._client.error(`Sending document notification ${this._type.method} failed.`, error);
            });
          });
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
      }
      async callback(data) {
        if (!this.matches(data)) return;
        const doSend = async (data2) => {
          const params = this._createParams(data2);
          await this._client.sendNotification(this._type, params).catch();
          this.notificationSent(data2, this._type, params);
        };
        const middleware = this._client.middleware[this._middleware];
        return Promise.resolve(middleware ? middleware(data, (data2) => doSend(data2)) : doSend(data));
      }
      matches(data) {
        return !this._selectorFilter || this._selectorFilter(this._selectors.values(), data);
      }
      get onNotificationSent() {
        return this._onNotificationSent.event;
      }
      notificationSent(data, type, params) {
        this._onNotificationSent.fire({ original: data, type, params });
      }
      unregister(id2) {
        this._selectors.delete(id2);
      }
      dispose() {
        this._selectors.clear();
        this._onNotificationSent.dispose();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document2) {
        for (const selector of this.getDocumentSelectors()) {
          if (workspace_default.match(selector, document2) > 0) {
            return {
              send: (data) => {
                return this.callback(data);
              }
            };
          }
        }
        return void 0;
      }
    };
    TextDocumentLanguageFeature = class extends DynamicDocumentFeature {
      constructor(client, registrationType) {
        super(client);
        this._registrationType = registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      *getDocumentSelectors() {
        for (const registration of this._registrations.values()) {
          const selector = registration.data.registerOptions.documentSelector;
          if (selector === null) {
            continue;
          }
          yield selector;
        }
      }
      get registrationType() {
        return this._registrationType;
      }
      get registrationLength() {
        return this._registrations.size;
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions, data.id);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
      }
      unregister(id2) {
        let registration = this._registrations.get(id2);
        if (registration !== void 0) {
          registration.disposable.dispose();
        }
      }
      dispose() {
        this._registrations.forEach((value) => {
          value.disposable.dispose();
        });
        this._registrations.clear();
      }
      getRegistration(documentSelector, capability) {
        if (!capability) return [void 0, void 0];
        if (boolean(capability) && capability === true) {
          return [generateUuid(), { documentSelector }];
        }
        if (import_node4.TextDocumentRegistrationOptions.is(capability)) {
          const id2 = import_node4.StaticRegistrationOptions.hasId(capability) ? capability.id : generateUuid();
          const selector = capability.documentSelector ?? documentSelector;
          return [id2, Object.assign({}, capability, { documentSelector: selector })];
        }
        if (import_node4.WorkDoneProgressOptions.is(capability)) {
          const id2 = import_node4.StaticRegistrationOptions.hasId(capability) ? capability.id : generateUuid();
          return [id2, Object.assign({}, capability, { documentSelector })];
        }
        return [void 0, void 0];
      }
      getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
          return void 0;
        }
        return boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
      }
      getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
          let selector = registration.data.registerOptions.documentSelector;
          if (selector !== null && workspace_default.match(selector, textDocument) > 0) {
            return registration.provider;
          }
        }
        return void 0;
      }
      getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
          result.push(item.provider);
        }
        return result;
      }
    };
  }
});

// src/language-client/callHierarchy.ts
var CallHierarchyFeature;
var init_callHierarchy = __esm({
  "src/language-client/callHierarchy.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    CallHierarchyFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.CallHierarchyPrepareRequest.type);
      }
      fillClientCapabilities(cap) {
        const capabilities = cap;
        const capability = ensure(ensure(capabilities, "textDocument"), "callHierarchy");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id2, options2] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
        if (!id2 || !options2) {
          return;
        }
        this.register({ id: id2, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          prepareCallHierarchy: (document2, position, token) => {
            const client = this._client;
            const prepareCallHierarchy = (document3, position2, token2) => {
              const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2);
              return this.sendRequest(import_node4.CallHierarchyPrepareRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.prepareCallHierarchy ? middleware.prepareCallHierarchy(document2, position, token, prepareCallHierarchy) : prepareCallHierarchy(document2, position, token);
          },
          provideCallHierarchyIncomingCalls: (item, token) => {
            const client = this._client;
            const provideCallHierarchyIncomingCalls = (item2, token2) => {
              return this.sendRequest(import_node4.CallHierarchyIncomingCallsRequest.type, { item: item2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideCallHierarchyIncomingCalls ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls) : provideCallHierarchyIncomingCalls(item, token);
          },
          provideCallHierarchyOutgoingCalls: (item, token) => {
            const client = this._client;
            const provideCallHierarchyOutgoingCalls = (item2, token2) => {
              return this.sendRequest(import_node4.CallHierarchyOutgoingCallsRequest.type, { item: item2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideCallHierarchyOutgoingCalls ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls) : provideCallHierarchyOutgoingCalls(item, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerCallHierarchyProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/codeAction.ts
var CodeActionFeature;
var init_codeAction = __esm({
  "src/language-client/codeAction.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_languages();
    init_protocol();
    init_features();
    init_uuid();
    CodeActionFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.CodeActionRequest.type);
        this.disposables = [];
      }
      fillClientCapabilities(capabilities) {
        const cap = ensure(ensure(capabilities, "textDocument"), "codeAction");
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.disabledSupport = true;
        cap.dataSupport = true;
        cap.honorsChangeAnnotations = false;
        cap.resolveSupport = {
          properties: ["edit"]
        };
        cap.codeActionLiteralSupport = {
          codeActionKind: {
            valueSet: [
              CodeActionKind.Empty,
              CodeActionKind.QuickFix,
              CodeActionKind.Refactor,
              CodeActionKind.RefactorExtract,
              CodeActionKind.RefactorInline,
              CodeActionKind.RefactorRewrite,
              CodeActionKind.Source,
              CodeActionKind.SourceOrganizeImports
            ]
          }
        };
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const registerCommand = (id2) => {
          const client = this._client;
          const executeCommand = (command, args) => {
            const params = {
              command,
              arguments: args
            };
            return client.sendRequest(import_node4.ExecuteCommandRequest.type, params);
          };
          const middleware = client.middleware;
          this.disposables.push(commands_default.registerCommand(id2, (...args) => {
            return middleware.executeCommand ? middleware.executeCommand(id2, args, executeCommand) : executeCommand(id2, args);
          }, null, true));
        };
        const provider = {
          provideCodeActions: (document2, range, context, token) => {
            const client = this._client;
            const _provideCodeActions = (document3, range2, context2, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                range: range2,
                context: context2
              };
              return this.sendRequest(import_node4.CodeActionRequest.type, params, token2).then(
                (values) => {
                  if (!values) return void 0;
                  values.forEach((val) => {
                    let cmd = Command.is(val) ? val.command : val.command?.command;
                    if (cmd && !commands_default.has(cmd)) registerCommand(cmd);
                  });
                  return values;
                }
              );
            };
            const middleware = client.middleware;
            return middleware.provideCodeActions ? middleware.provideCodeActions(document2, range, context, token, _provideCodeActions) : _provideCodeActions(document2, range, context, token);
          },
          resolveCodeAction: options2.resolveProvider ? (item, token) => {
            const middleware = this._client.middleware;
            const resolveCodeAction = (item2, token2) => {
              return this.sendRequest(import_node4.CodeActionResolveRequest.type, item2, token2, item2);
            };
            return middleware.resolveCodeAction ? middleware.resolveCodeAction(item, token, resolveCodeAction) : resolveCodeAction(item, token);
          } : void 0
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerCodeActionProvider(options2.documentSelector, provider, this._client.id, options2.codeActionKinds), provider];
      }
      dispose() {
        this.disposables.forEach((o) => {
          o.dispose();
        });
        this.disposables = [];
        super.dispose();
      }
    };
  }
});

// src/language-client/codeLens.ts
var CodeLensFeature;
var init_codeLens = __esm({
  "src/language-client/codeLens.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_uuid();
    CodeLensFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.CodeLensRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "codeLens").dynamicRegistration = true;
        ensure(ensure(capabilities, "workspace"), "codeLens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(import_node4.CodeLensRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeCodeLensEmitter.fire();
          }
        });
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options2) return;
        this.register({ id: generateUuid(), registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const emitter = new import_node4.Emitter();
        const provider = {
          onDidChangeCodeLenses: emitter.event,
          provideCodeLenses: (document2, token) => {
            const client = this._client;
            const provideCodeLenses = (document3, token2) => {
              return this.sendRequest(
                import_node4.CodeLensRequest.type,
                client.code2ProtocolConverter.asCodeLensParams(document3),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideCodeLenses ? middleware.provideCodeLenses(document2, token, provideCodeLenses) : provideCodeLenses(document2, token);
          },
          resolveCodeLens: options2.resolveProvider ? (codeLens, token) => {
            const client = this._client;
            const resolveCodeLens = (codeLens2, token2) => {
              return this.sendRequest(
                import_node4.CodeLensResolveRequest.type,
                codeLens2,
                token2,
                codeLens2
              );
            };
            const middleware = client.middleware;
            return middleware.resolveCodeLens ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens) : resolveCodeLens(codeLens, token);
          } : void 0
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerCodeLensProvider(options2.documentSelector, provider), { provider, onDidChangeCodeLensEmitter: emitter }];
      }
    };
  }
});

// src/language-client/colorProvider.ts
var ColorProviderFeature;
var init_colorProvider = __esm({
  "src/language-client/colorProvider.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    ColorProviderFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.DocumentColorRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "colorProvider").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id2, options2] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id2 || !options2) {
          return;
        }
        this.register({ id: id2, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideColorPresentations: (color, context, token) => {
            const client = this._client;
            const provideColorPresentations = (color2, context2, token2) => {
              const requestParams = {
                color: color2,
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context2.document),
                range: context2.range
              };
              return this.sendRequest(import_node4.ColorPresentationRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideColorPresentations ? middleware.provideColorPresentations(color, context, token, provideColorPresentations) : provideColorPresentations(color, context, token);
          },
          provideDocumentColors: (document2, token) => {
            const client = this._client;
            const provideDocumentColors = (document3, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3)
              };
              return this.sendRequest(import_node4.DocumentColorRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideDocumentColors ? middleware.provideDocumentColors(document2, token, provideDocumentColors) : provideDocumentColors(document2, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerDocumentColorProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/completion.ts
var SupportedCompletionItemKinds, CompletionItemFeature;
var init_completion = __esm({
  "src/language-client/completion.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_protocol();
    init_features();
    init_uuid();
    SupportedCompletionItemKinds = [
      CompletionItemKind.Text,
      CompletionItemKind.Method,
      CompletionItemKind.Function,
      CompletionItemKind.Constructor,
      CompletionItemKind.Field,
      CompletionItemKind.Variable,
      CompletionItemKind.Class,
      CompletionItemKind.Interface,
      CompletionItemKind.Module,
      CompletionItemKind.Property,
      CompletionItemKind.Unit,
      CompletionItemKind.Value,
      CompletionItemKind.Enum,
      CompletionItemKind.Keyword,
      CompletionItemKind.Snippet,
      CompletionItemKind.Color,
      CompletionItemKind.File,
      CompletionItemKind.Reference,
      CompletionItemKind.Folder,
      CompletionItemKind.EnumMember,
      CompletionItemKind.Constant,
      CompletionItemKind.Struct,
      CompletionItemKind.Event,
      CompletionItemKind.Operator,
      CompletionItemKind.TypeParameter
    ];
    CompletionItemFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.CompletionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let snippetSupport = this._client.clientOptions.disableSnippetCompletion !== true;
        let completion = ensure(ensure(capabilities, "textDocument"), "completion");
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
          snippetSupport,
          commitCharactersSupport: true,
          documentationFormat: this._client.supportedMarkupKind,
          deprecatedSupport: true,
          preselectSupport: true,
          insertReplaceSupport: true,
          tagSupport: { valueSet: [CompletionItemTag.Deprecated] },
          resolveSupport: { properties: ["documentation", "detail", "additionalTextEdits"] },
          labelDetailsSupport: true,
          insertTextModeSupport: { valueSet: [InsertTextMode.asIs, InsertTextMode.adjustIndentation] }
        };
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
        completion.insertTextMode = InsertTextMode.adjustIndentation;
        completion.completionList = {
          itemDefaults: [
            "commitCharacters",
            "editRange",
            "insertTextFormat",
            "insertTextMode"
          ]
        };
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options2) return;
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2, id2) {
        let triggerCharacters = options2.triggerCharacters || [];
        let allCommitCharacters = options2.allCommitCharacters || [];
        const provider = {
          provideCompletionItems: (document2, position, token, context) => {
            const middleware = this._client.middleware;
            const provideCompletionItems = (document3, position2, context2, token2) => {
              return this.sendRequest(
                import_node4.CompletionRequest.type,
                this._client.code2ProtocolConverter.asCompletionParams(document3, position2, context2),
                token2,
                []
              );
            };
            return middleware.provideCompletionItem ? middleware.provideCompletionItem(document2, position, context, token, provideCompletionItems) : provideCompletionItems(document2, position, context, token);
          },
          resolveCompletionItem: options2.resolveProvider ? (item, token) => {
            const middleware = this._client.middleware;
            const resolveCompletionItem = (item2, token2) => {
              return this.sendRequest(
                import_node4.CompletionResolveRequest.type,
                item2,
                token2,
                item2
              );
            };
            return middleware.resolveCompletionItem ? middleware.resolveCompletionItem(item, token, resolveCompletionItem) : resolveCompletionItem(item, token);
          } : void 0
        };
        this._client.attachExtensionName(provider);
        let name2 = this._client.id + (this.registrationLength == 0 ? "" : "-" + id2);
        const disposable = languages_default.registerCompletionItemProvider(
          name2,
          "LS",
          options2.documentSelector,
          provider,
          triggerCharacters,
          options2.priority,
          allCommitCharacters
        );
        return [disposable, provider];
      }
    };
  }
});

// src/language-client/configuration.ts
var PullConfigurationFeature, SyncConfigurationFeature;
var init_configuration4 = __esm({
  "src/language-client/configuration.ts"() {
    "use strict";
    init_util2();
    init_is();
    init_protocol();
    init_workspace();
    init_features();
    init_uuid();
    PullConfigurationFeature = class {
      constructor(_client) {
        this._client = _client;
      }
      get method() {
        return import_node4.ConfigurationRequest.method;
      }
      fillClientCapabilities(capabilities) {
        ensure(capabilities, "workspace").configuration = true;
      }
      getState() {
        return { kind: "static" };
      }
      initialize() {
        let client = this._client;
        let { configuredSection } = client;
        client.onRequest(import_node4.ConfigurationRequest.type, (params, token) => {
          let configuration2 = (params2) => {
            let result = [];
            for (let item of params2.items) {
              let section2 = configuredSection ? configuredSection + (item.section ? `.${item.section}` : "") : item.section;
              result.push(this.getConfiguration(item.scopeUri, section2));
            }
            return result;
          };
          let middleware = client.middleware.workspace;
          return middleware?.configuration ? middleware.configuration(params, token, configuration2) : configuration2(params, token);
        });
      }
      getConfiguration(resource, section2) {
        let result = null;
        if (section2) {
          let index = section2.lastIndexOf(".");
          if (index === -1) {
            result = toJSONObject(workspace_default.getConfiguration(void 0, resource).get(section2));
          } else {
            let config = workspace_default.getConfiguration(section2.substr(0, index), resource);
            result = toJSONObject(mergeConfigProperties(config))[section2.substr(index + 1)];
          }
        } else {
          let config = workspace_default.getConfiguration(section2, resource);
          result = {};
          for (let key of Object.keys(config)) {
            if (config.has(key)) {
              result[key] = toJSONObject(config.get(key));
            }
          }
        }
        return result ?? null;
      }
      dispose() {
      }
    };
    SyncConfigurationFeature = class _SyncConfigurationFeature {
      constructor(_client) {
        this._client = _client;
        this._listeners = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
      }
      get registrationType() {
        return import_node4.DidChangeConfigurationNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "didChangeConfiguration").dynamicRegistration = true;
      }
      initialize() {
        let section2 = this._client.clientOptions.synchronize?.configurationSection;
        if (section2 !== void 0) {
          let id2 = this.configuredUID = generateUuid();
          this.register({
            id: id2,
            registerOptions: {
              section: section2
            }
          });
        }
      }
      register(data) {
        if (this._client.configuredSection && data.id !== this.configuredUID) return;
        let { section: section2 } = data.registerOptions;
        let disposable = workspace_default.onDidChangeConfiguration((event) => {
          this.onDidChangeConfiguration(section2, event);
        });
        this._listeners.set(data.id, disposable);
        if (section2 !== void 0) {
          this.onDidChangeConfiguration(section2, void 0);
        }
      }
      unregister(id2) {
        let disposable = this._listeners.get(id2);
        if (disposable) {
          this._listeners.delete(id2);
          disposable.dispose();
        }
      }
      dispose() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
      onDidChangeConfiguration(configurationSection, event) {
        let { configuredSection } = this._client;
        let sections;
        if (string(configurationSection)) {
          sections = [configurationSection];
        } else {
          sections = configurationSection;
        }
        if (sections != null && event != null) {
          let keys = sections.map((s) => s.startsWith("languageserver.") ? "languageserver" : s);
          let affected = keys.some((section2) => event.affectsConfiguration(section2));
          if (!affected) return;
        }
        let didChangeConfiguration = (sections2) => {
          if (sections2 == null) {
            return this._client.sendNotification(import_node4.DidChangeConfigurationNotification.type, { settings: null });
          }
          let workspaceFolder = this._client.clientOptions.workspaceFolder;
          let settings = configuredSection ? _SyncConfigurationFeature.getConfiguredSettings(configuredSection, workspaceFolder) : _SyncConfigurationFeature.extractSettingsInformation(sections2, workspaceFolder);
          return this._client.sendNotification(import_node4.DidChangeConfigurationNotification.type, { settings });
        };
        let middleware = this._client.middleware.workspace?.didChangeConfiguration;
        let promise = middleware ? Promise.resolve(middleware(sections, didChangeConfiguration)) : didChangeConfiguration(sections);
        promise.catch((error) => {
          this._client.error(`Sending notification ${import_node4.DidChangeConfigurationNotification.type.method} failed`, error);
        });
      }
      static getConfiguredSettings(key, workspaceFolder) {
        let len = ".settings".length;
        let config = workspace_default.getConfiguration(key.slice(0, -len), workspaceFolder);
        return mergeConfigProperties(toJSONObject(config.get("settings", {})));
      }
      static extractSettingsInformation(keys, workspaceFolder) {
        function ensurePath(config, path2) {
          let current = config;
          for (let i = 0; i < path2.length - 1; i++) {
            let obj = current[path2[i]];
            if (!obj) {
              obj = /* @__PURE__ */ Object.create(null);
              current[path2[i]] = obj;
            }
            current = obj;
          }
          return current;
        }
        let result = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < keys.length; i++) {
          let key = keys[i];
          let index = key.indexOf(".");
          let config;
          if (index >= 0) {
            config = workspace_default.getConfiguration(key.substr(0, index), workspaceFolder).get(key.substr(index + 1));
          } else {
            config = workspace_default.getConfiguration(key, workspaceFolder);
          }
          let path2 = keys[i].split(".");
          ensurePath(result, path2)[path2[path2.length - 1]] = config;
        }
        return result;
      }
    };
  }
});

// src/language-client/declaration.ts
var DeclarationFeature;
var init_declaration = __esm({
  "src/language-client/declaration.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    DeclarationFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.DeclarationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let declarationSupport = ensure(ensure(capabilities, "textDocument"), "declaration");
        declarationSupport.dynamicRegistration = true;
        declarationSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const [id2, options2] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id2 || !options2) {
          return;
        }
        this.register({ id: id2, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDeclaration: (document2, position, token) => {
            const client = this._client;
            const provideDeclaration = (document3, position2, token2) => this.sendRequest(import_node4.DeclarationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2);
            const middleware = client.middleware;
            return middleware.provideDeclaration ? middleware.provideDeclaration(document2, position, token, provideDeclaration) : provideDeclaration(document2, position, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerDeclarationProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/definition.ts
var DefinitionFeature;
var init_definition = __esm({
  "src/language-client/definition.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_uuid();
    DefinitionFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.DefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let definitionSupport = ensure(ensure(capabilities, "textDocument"), "definition");
        definitionSupport.dynamicRegistration = true;
        definitionSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDefinition: (document2, position, token) => {
            const client = this._client;
            const provideDefinition = (document3, position2, token2) => {
              return this.sendRequest(
                import_node4.DefinitionRequest.type,
                client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideDefinition ? middleware.provideDefinition(document2, position, token, provideDefinition) : provideDefinition(document2, position, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerDefinitionProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/diagnostic.ts
var DiagnosticPullMode, DocumentOrUri, workdpacePullDebounce, DocumentPullStateTracker, DiagnosticRequestor, timeoutDebounce, BackgroundScheduler, DiagnosticFeatureProviderImpl, DiagnosticFeature;
var init_diagnostic = __esm({
  "src/language-client/diagnostic.ts"() {
    "use strict";
    init_esm_node();
    init_esm();
    init_languages();
    init_util();
    init_errors();
    init_map();
    init_node();
    init_protocol();
    init_window();
    init_workspace();
    init_features();
    DiagnosticPullMode = /* @__PURE__ */ ((DiagnosticPullMode2) => {
      DiagnosticPullMode2["onType"] = "onType";
      DiagnosticPullMode2["onSave"] = "onSave";
      DiagnosticPullMode2["onFocus"] = "onFocus";
      return DiagnosticPullMode2;
    })(DiagnosticPullMode || {});
    ((DocumentOrUri2) => {
      function asKey(document2) {
        return document2 instanceof URI2 ? document2.toString() : document2.uri;
      }
      DocumentOrUri2.asKey = asKey;
    })(DocumentOrUri || (DocumentOrUri = {}));
    workdpacePullDebounce = getConditionValue(3e3, 10);
    DocumentPullStateTracker = class {
      constructor() {
        this.documentPullStates = /* @__PURE__ */ new Map();
        this.workspacePullStates = /* @__PURE__ */ new Map();
      }
      track(kind, document2, arg1) {
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version2] = document2 instanceof URI2 ? [document2.toString(), document2, arg1] : [document2.uri.toString(), URI2.parse(document2.uri), document2.version];
        let state = states.get(key);
        if (state === void 0) {
          state = { document: uri, pulledVersion: version2, resultId: void 0 };
          states.set(key, state);
        }
        return state;
      }
      update(kind, document2, arg1, arg2) {
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version2, resultId] = document2 instanceof URI2 ? [document2.toString(), document2, arg1, arg2] : [document2.uri, URI2.parse(document2.uri), document2.version, arg1];
        let state = states.get(key);
        if (state === void 0) {
          state = { document: uri, pulledVersion: version2, resultId };
          states.set(key, state);
        } else {
          state.pulledVersion = version2;
          state.resultId = resultId;
        }
      }
      unTrack(kind, document2) {
        const key = document2 instanceof URI2 ? document2.toString() : document2.uri;
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        states.delete(key);
      }
      tracks(kind, document2) {
        const key = document2 instanceof URI2 ? document2.toString() : document2.uri;
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        return states.has(key);
      }
      trackingDocuments() {
        return Array.from(this.documentPullStates.keys());
      }
      getResultId(kind, document2) {
        const key = document2 instanceof URI2 ? document2.toString() : document2.uri;
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        return states.get(key)?.resultId;
      }
      getAllResultIds() {
        const result = [];
        for (let [uri, value] of this.workspacePullStates) {
          if (this.documentPullStates.has(uri)) {
            value = this.documentPullStates.get(uri);
          }
          if (value.resultId !== void 0) {
            result.push({ uri, value: value.resultId });
          }
        }
        return result;
      }
    };
    DiagnosticRequestor = class extends BaseFeature {
      constructor(client, options2) {
        super(client);
        this.client = client;
        this.options = options2;
        this.enableWorkspace = options2.workspaceDiagnostics && this.client.clientOptions.diagnosticPullOptions?.workspace !== false;
        this.isDisposed = false;
        this.onDidChangeDiagnosticsEmitter = new import_node4.Emitter();
        this.provider = this.createProvider();
        this.diagnostics = languages_default.createDiagnosticCollection(options2.identifier ? options2.identifier : client.id);
        this.openRequests = /* @__PURE__ */ new Map();
        this.documentStates = new DocumentPullStateTracker();
        this.workspaceErrorCounter = 0;
      }
      knows(kind, textDocument) {
        return this.documentStates.tracks(kind, textDocument);
      }
      trackingDocuments() {
        return this.documentStates.trackingDocuments();
      }
      forget(kind, document2) {
        this.documentStates.unTrack(kind, document2);
      }
      pull(document2, cb) {
        this.pullAsync(document2).then(() => {
          if (cb) {
            cb();
          }
        }, (error) => {
          this.client.error(`Document pull failed for text document ${document2.uri}`, error);
        });
      }
      async pullAsync(document2) {
        if (this.isDisposed) return;
        const uri = document2.uri;
        const version2 = document2.version;
        const currentRequestState = this.openRequests.get(uri);
        const documentState = this.documentStates.track(1 /* document */, document2);
        if (currentRequestState === void 0) {
          const tokenSource = new import_node4.CancellationTokenSource();
          this.openRequests.set(uri, { state: "open" /* active */, document: document2, version: version2, tokenSource });
          let report;
          let afterState;
          try {
            report = await this.provider.provideDiagnostics(document2, documentState.resultId, tokenSource.token) ?? { kind: import_node4.DocumentDiagnosticReportKind.Full, items: [] };
          } catch (error) {
            if (error instanceof LSPCancellationError && error.data && import_node4.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
              afterState = { state: "drop" /* outDated */, document: document2 };
            }
            if (afterState === void 0 && error instanceof CancellationError) {
              afterState = { state: "reschedule" /* reschedule */, document: document2 };
            } else {
              throw error;
            }
          }
          afterState = afterState ?? this.openRequests.get(uri);
          if (afterState === void 0) {
            this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${uri}`);
            this.diagnostics.delete(uri);
            return;
          }
          this.openRequests.delete(uri);
          const visible = window_default.visibleTextEditors.some((editor) => editor.document.uri === uri);
          if (!visible) {
            this.documentStates.unTrack(1 /* document */, document2);
            return;
          }
          if (afterState.state === "drop" /* outDated */) return;
          if (report !== void 0) {
            if (report.kind === import_node4.DocumentDiagnosticReportKind.Full) {
              this.diagnostics.set(uri, report.items);
            }
            documentState.pulledVersion = version2;
            documentState.resultId = report.resultId;
          }
          if (afterState.state === "reschedule" /* reschedule */) {
            this.pull(document2);
          }
        } else {
          if (currentRequestState.state === "open" /* active */) {
            currentRequestState.tokenSource.cancel();
            this.openRequests.set(uri, { state: "reschedule" /* reschedule */, document: currentRequestState.document });
          } else if (currentRequestState.state === "drop" /* outDated */) {
            this.openRequests.set(uri, { state: "reschedule" /* reschedule */, document: currentRequestState.document });
          }
        }
      }
      forgetDocument(document2) {
        const uri = document2.uri;
        const request2 = this.openRequests.get(uri);
        if (this.enableWorkspace) {
          if (request2 !== void 0) {
            this.openRequests.set(uri, { state: "reschedule" /* reschedule */, document: document2 });
          } else {
            this.pull(document2, () => {
              this.forget(1 /* document */, document2);
            });
          }
        } else {
          if (request2 !== void 0) {
            if (request2.state === "open" /* active */) {
              request2.tokenSource.cancel();
            }
            this.openRequests.delete(uri);
          }
          this.diagnostics.delete(uri.toString());
          this.forget(1 /* document */, document2);
        }
      }
      pullWorkspace() {
        if (!this.enableWorkspace) return;
        this.pullWorkspaceAsync().then(() => {
          this.workspaceTimeout = (0, import_node4.RAL)().timer.setTimeout(() => {
            this.pullWorkspace();
          }, workdpacePullDebounce);
        }, (error) => {
          if (!(error instanceof LSPCancellationError) && !import_node4.DiagnosticServerCancellationData.is(error.data)) {
            this.client.error(`Workspace diagnostic pull failed.`, error);
            this.workspaceErrorCounter++;
          }
          if (this.workspaceErrorCounter <= 5) {
            this.workspaceTimeout = (0, import_node4.RAL)().timer.setTimeout(() => {
              this.pullWorkspace();
            }, workdpacePullDebounce);
          }
        });
      }
      async pullWorkspaceAsync() {
        if (!this.provider.provideWorkspaceDiagnostics) {
          return;
        }
        if (this.workspaceCancellation !== void 0) {
          this.workspaceCancellation.cancel();
          this.workspaceCancellation = void 0;
        }
        this.workspaceCancellation = new import_node4.CancellationTokenSource();
        const previousResultIds = this.documentStates.getAllResultIds();
        await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, (chunk) => {
          if (!chunk || this.isDisposed) {
            return;
          }
          for (const item of chunk.items) {
            if (item.kind === import_node4.DocumentDiagnosticReportKind.Full) {
              if (!this.documentStates.tracks(1 /* document */, URI2.parse(item.uri))) {
                this.diagnostics.set(item.uri.toString(), item.items);
              }
            }
            this.documentStates.update(2 /* workspace */, URI2.parse(item.uri), item.version ?? void 0, item.resultId);
          }
        });
      }
      createProvider() {
        const provider = {
          onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
          provideDiagnostics: (document2, previousResultId, token) => {
            const middleware = this.client.middleware;
            const client = this._client;
            const provideDiagnostics = (document3, previousResultId2, token2) => {
              const uri = client.code2ProtocolConverter.asUri(document3 instanceof URI2 ? document3 : URI2.parse(document3.uri));
              const params = {
                identifier: this.options.identifier,
                textDocument: { uri },
                previousResultId: previousResultId2
              };
              return this.sendRequest(import_node4.DocumentDiagnosticRequest.type, params, token2, { kind: import_node4.DocumentDiagnosticReportKind.Full, items: [] }).then(async (result) => {
                if (result === void 0 || result === null || this.isDisposed) {
                  return { kind: import_node4.DocumentDiagnosticReportKind.Full, items: [] };
                }
                if (middleware.handleDiagnostics && result.kind == import_node4.DocumentDiagnosticReportKind.Full) {
                  middleware.handleDiagnostics(uri, result.items, (_, diagnostics) => {
                    result.items = diagnostics;
                  });
                }
                return result;
              });
            };
            return middleware.provideDiagnostics ? middleware.provideDiagnostics(document2, previousResultId, token, provideDiagnostics) : provideDiagnostics(document2, previousResultId, token);
          }
        };
        if (this.options.workspaceDiagnostics) {
          provider.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
            const provideWorkspaceDiagnostics = (resultIds2, token2, resultReporter2) => {
              const partialResultToken = v4_default();
              const disposable = this.client.onProgress(import_node4.WorkspaceDiagnosticRequest.partialResult, partialResultToken, (partialResult) => {
                if (partialResult == void 0) {
                  resultReporter2(null);
                  return;
                }
                resultReporter2(partialResult);
              });
              const params = {
                identifier: this.options.identifier,
                previousResultIds: resultIds2,
                partialResultToken
              };
              return this.sendRequest(import_node4.WorkspaceDiagnosticRequest.type, params, token2, { items: [] }).then(async (result) => {
                resultReporter2(result);
                return { items: [] };
              }).finally(() => {
                disposable.dispose();
              });
            };
            const middleware = this.client.middleware;
            return middleware.provideWorkspaceDiagnostics ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideWorkspaceDiagnostics) : provideWorkspaceDiagnostics(resultIds, token, resultReporter);
          };
        }
        return provider;
      }
      dispose() {
        this.isDisposed = true;
        this.workspaceCancellation?.cancel();
        this.workspaceTimeout?.dispose();
        for (const request2 of this.openRequests.values()) {
          if (request2.state === "open" /* active */) {
            request2.tokenSource.cancel();
          }
        }
        this.openRequests.clear();
      }
    };
    timeoutDebounce = getConditionValue(500, 10);
    BackgroundScheduler = class {
      constructor(client, diagnosticRequestor) {
        this.client = client;
        this.diagnosticRequestor = diagnosticRequestor;
        this.documents = new LinkedMap();
        this.isDisposed = false;
      }
      add(document2) {
        if (this.isDisposed === true) {
          return;
        }
        const key = document2.uri;
        if (this.documents.has(key)) {
          return;
        }
        this.documents.set(key, document2, Touch.AsNew);
        this.lastDocumentToPull = document2;
      }
      remove(document2) {
        const key = document2.uri;
        if (this.documents.has(key)) {
          this.documents.delete(key);
          this.diagnosticRequestor.pull(document2);
        }
        if (this.documents.size === 0) {
          this.stop();
          return;
        }
        if (document2.uri === this.lastDocumentToPullKey()) {
          const before = this.documents.before(key);
          if (before === void 0) {
            this.stop();
          } else {
            this.lastDocumentToPull = before;
          }
        }
      }
      trigger() {
        this.lastDocumentToPull = this.documents.last;
        this.runLoop();
      }
      runLoop() {
        if (this.isDisposed === true) {
          return;
        }
        if (this.documents.size === 0) {
          this.stop();
          return;
        }
        if (this.lastDocumentToPull === void 0) {
          return;
        }
        if (this.timeoutHandle !== void 0) {
          return;
        }
        this.timeoutHandle = (0, import_node4.RAL)().timer.setTimeout(() => {
          const document2 = this.documents.first;
          if (document2 === void 0) {
            return;
          }
          const key = DocumentOrUri.asKey(document2);
          this.diagnosticRequestor.pullAsync(document2).catch((error) => {
            this.client.error(`Document pull failed for text document ${key}`, error, false);
          }).finally(() => {
            this.timeoutHandle = void 0;
            this.documents.set(key, document2, Touch.Last);
            if (key !== this.lastDocumentToPullKey()) {
              this.runLoop();
            }
          });
        }, timeoutDebounce);
      }
      dispose() {
        this.stop();
        this.documents.clear();
        this.lastDocumentToPull = void 0;
      }
      stop() {
        this.timeoutHandle?.dispose();
        this.timeoutHandle = void 0;
        this.lastDocumentToPull = void 0;
      }
      lastDocumentToPullKey() {
        return this.lastDocumentToPull !== void 0 ? DocumentOrUri.asKey(this.lastDocumentToPull) : void 0;
      }
    };
    DiagnosticFeatureProviderImpl = class {
      constructor(client, options2) {
        const diagnosticPullOptions = Object.assign({ onChange: false, onSave: false, onFocus: false }, client.clientOptions.diagnosticPullOptions);
        const selector = options2.documentSelector ?? [];
        const disposables = [];
        const ignored = diagnosticPullOptions.ignored ?? [];
        const matches = (document2) => {
          if (diagnosticPullOptions.match !== void 0) {
            return diagnosticPullOptions.match(selector, URI2.parse(document2.uri));
          }
          if (workspace_default.match(selector, document2) <= 0) return false;
          const visible = window_default.visibleTextEditors.some((editor) => editor.document.uri === document2.uri);
          if (!visible) return false;
          if (ignored.length > 0 && ignored.some((p) => minimatch(URI2.parse(document2.uri).fsPath, p, { dot: true }))) return false;
          return true;
        };
        const isActiveDocument = (document2) => {
          return document2.uri === this.activeTextDocument?.uri;
        };
        const considerDocument = (textDocument, mode) => {
          return (diagnosticPullOptions.filter === void 0 || !diagnosticPullOptions.filter(textDocument, mode)) && this.diagnosticRequestor.knows(1 /* document */, textDocument);
        };
        this.diagnosticRequestor = new DiagnosticRequestor(client, options2);
        this.backgroundScheduler = new BackgroundScheduler(client, this.diagnosticRequestor);
        const addToBackgroundIfNeeded = (document2) => {
          if (!matches(document2) || !options2.interFileDependencies || isActiveDocument(document2) || diagnosticPullOptions.onChange === false) return;
          this.backgroundScheduler.add(document2);
        };
        this.activeTextDocument = window_default.activeTextEditor?.document.textDocument;
        window_default.onDidChangeActiveTextEditor((editor) => {
          const oldActive = this.activeTextDocument;
          let textDocument = this.activeTextDocument = editor?.document.textDocument;
          if (oldActive !== void 0) {
            addToBackgroundIfNeeded(oldActive);
          }
          if (textDocument != null) {
            this.backgroundScheduler.remove(textDocument);
            if (diagnosticPullOptions.onFocus === true && matches(this.activeTextDocument) && considerDocument(this.activeTextDocument, "onFocus" /* onFocus */)) {
              this.diagnosticRequestor.pull(textDocument);
            }
          }
        }, null, disposables);
        const openFeature = client.getFeature(import_node4.DidOpenTextDocumentNotification.method);
        disposables.push(openFeature.onNotificationSent((event) => {
          const textDocument = event.original;
          if (matches(textDocument)) {
            this.diagnosticRequestor.pull(textDocument, () => {
              addToBackgroundIfNeeded(textDocument);
            });
          }
        }));
        for (const textDocument of workspace_default.textDocuments) {
          if (matches(textDocument)) {
            this.diagnosticRequestor.pull(textDocument, () => {
              addToBackgroundIfNeeded(textDocument);
            });
          }
        }
        if (diagnosticPullOptions.onChange === true) {
          const changeFeature = client.getFeature(import_node4.DidChangeTextDocumentNotification.method);
          disposables.push(changeFeature.onNotificationSent(async (event) => {
            const textDocument = workspace_default.getDocument(event.original.bufnr).textDocument;
            if (considerDocument(textDocument, "onType" /* onType */)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                this.backgroundScheduler.trigger();
              });
            }
          }));
        }
        if (diagnosticPullOptions.onSave === true) {
          const saveFeature = client.getFeature(import_node4.DidSaveTextDocumentNotification.method);
          disposables.push(saveFeature.onNotificationSent((event) => {
            const textDocument = event.original;
            if (considerDocument(textDocument, "onSave" /* onSave */)) {
              this.diagnosticRequestor.pull(event.original);
            }
          }));
        }
        const closeFeature = client.getFeature(import_node4.DidCloseTextDocumentNotification.method);
        disposables.push(closeFeature.onNotificationSent((event) => {
          this.cleanUpDocument(event.original);
        }));
        this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
          for (const textDocument of workspace_default.textDocuments) {
            if (matches(textDocument)) {
              this.diagnosticRequestor.pull(textDocument);
            }
          }
        });
        window_default.onDidChangeVisibleTextEditors((editors) => {
          const handled = /* @__PURE__ */ new Set();
          const tracking = this.diagnosticRequestor.trackingDocuments();
          editors.forEach((editor) => {
            let { uri, textDocument } = editor.document;
            if (handled.has(uri)) return;
            handled.add(uri);
            if (matches(textDocument) && !tracking.includes(uri)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                addToBackgroundIfNeeded(textDocument);
              });
            }
          });
          tracking.forEach((uri) => {
            if (handled.has(uri)) return;
            let doc = workspace_default.getDocument(uri);
            if (doc && doc.attached) this.cleanUpDocument(doc.textDocument);
          });
        }, null, disposables);
        if (options2.workspaceDiagnostics === true && options2.identifier !== "da348dc5-c30a-4515-9d98-31ff3be38d14") {
          this.diagnosticRequestor.pullWorkspace();
        }
        this.disposable = import_node4.Disposable.create(() => [...disposables, this.backgroundScheduler, this.diagnosticRequestor].forEach((d) => d.dispose()));
      }
      get onDidChangeDiagnosticsEmitter() {
        return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
      }
      get diagnostics() {
        return this.diagnosticRequestor.provider;
      }
      knows(kind, textDocument) {
        return this.diagnosticRequestor.knows(kind, textDocument);
      }
      forget(document2) {
        this.cleanUpDocument(document2);
      }
      cleanUpDocument(document2) {
        this.backgroundScheduler.remove(document2);
        if (this.diagnosticRequestor.knows(1 /* document */, document2)) {
          this.diagnosticRequestor.forgetDocument(document2);
        }
      }
    };
    DiagnosticFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.DocumentDiagnosticRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "diagnostic");
        capability.dynamicRegistration = true;
        capability.relatedDocumentSupport = true;
        ensure(ensure(capabilities, "workspace"), "diagnostics").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(import_node4.DiagnosticRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeDiagnosticsEmitter.fire();
          }
        });
        let [id2, options2] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
        if (!id2 || !options2) return;
        this.register({ id: id2, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = new DiagnosticFeatureProviderImpl(this._client, options2);
        return [provider.disposable, provider];
      }
      refresh() {
        for (const provider of this.getAllProviders()) {
          provider.onDidChangeDiagnosticsEmitter.fire();
        }
      }
    };
  }
});

// src/language-client/documentHighlight.ts
var DocumentHighlightFeature;
var init_documentHighlight = __esm({
  "src/language-client/documentHighlight.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_uuid();
    DocumentHighlightFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.DocumentHighlightRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(
          ensure(capabilities, "textDocument"),
          "documentHighlight"
        ).dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDocumentHighlights: (document2, position, token) => {
            const client = this._client;
            const _provideDocumentHighlights = (document3, position2, token2) => {
              return this.sendRequest(
                import_node4.DocumentHighlightRequest.type,
                client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideDocumentHighlights ? middleware.provideDocumentHighlights(document2, position, token, _provideDocumentHighlights) : _provideDocumentHighlights(document2, position, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerDocumentHighlightProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/documentLink.ts
var DocumentLinkFeature;
var init_documentLink = __esm({
  "src/language-client/documentLink.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_uuid();
    DocumentLinkFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.DocumentLinkRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const documentLinkCapabilities = ensure(ensure(capabilities, "textDocument"), "documentLink");
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDocumentLinks: (document2, token) => {
            const client = this._client;
            const provideDocumentLinks = (document3, token2) => {
              return this.sendRequest(
                import_node4.DocumentLinkRequest.type,
                client.code2ProtocolConverter.asDocumentLinkParams(document3),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideDocumentLinks ? middleware.provideDocumentLinks(document2, token, provideDocumentLinks) : provideDocumentLinks(document2, token);
          },
          resolveDocumentLink: options2.resolveProvider ? (link, token) => {
            const client = this._client;
            let resolveDocumentLink = (link2, token2) => {
              return this.sendRequest(import_node4.DocumentLinkResolveRequest.type, link2, token2, link2);
            };
            const middleware = client.middleware;
            return middleware.resolveDocumentLink ? middleware.resolveDocumentLink(link, token, resolveDocumentLink) : resolveDocumentLink(link, token);
          } : void 0
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerDocumentLinkProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/documentSymbol.ts
var SupportedSymbolKinds, SupportedSymbolTags, DocumentSymbolFeature;
var init_documentSymbol = __esm({
  "src/language-client/documentSymbol.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_protocol();
    init_features();
    init_uuid();
    SupportedSymbolKinds = [
      SymbolKind.File,
      SymbolKind.Module,
      SymbolKind.Namespace,
      SymbolKind.Package,
      SymbolKind.Class,
      SymbolKind.Method,
      SymbolKind.Property,
      SymbolKind.Field,
      SymbolKind.Constructor,
      SymbolKind.Enum,
      SymbolKind.Interface,
      SymbolKind.Function,
      SymbolKind.Variable,
      SymbolKind.Constant,
      SymbolKind.String,
      SymbolKind.Number,
      SymbolKind.Boolean,
      SymbolKind.Array,
      SymbolKind.Object,
      SymbolKind.Key,
      SymbolKind.Null,
      SymbolKind.EnumMember,
      SymbolKind.Struct,
      SymbolKind.Event,
      SymbolKind.Operator,
      SymbolKind.TypeParameter
    ];
    SupportedSymbolTags = [
      SymbolTag.Deprecated
    ];
    DocumentSymbolFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.DocumentSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, "textDocument"), "documentSymbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
          valueSet: SupportedSymbolTags
        };
        symbolCapabilities.labelSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          meta: options2.label ? { label: options2.label } : void 0,
          provideDocumentSymbols: (document2, token) => {
            const client = this._client;
            const _provideDocumentSymbols = (document3, token2) => {
              return this.sendRequest(
                import_node4.DocumentSymbolRequest.type,
                client.code2ProtocolConverter.asDocumentSymbolParams(document3),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideDocumentSymbols ? middleware.provideDocumentSymbols(document2, token, _provideDocumentSymbols) : _provideDocumentSymbols(document2, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerDocumentSymbolProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/executeCommand.ts
var ExecuteCommandFeature;
var init_executeCommand = __esm({
  "src/language-client/executeCommand.ts"() {
    "use strict";
    init_protocol();
    init_features();
    init_commands();
    init_uuid();
    ExecuteCommandFeature = class extends BaseFeature {
      constructor(client) {
        super(client);
        this._commands = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._commands.size > 0 };
      }
      get registrationType() {
        return import_node4.ExecuteCommandRequest.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "executeCommand").dynamicRegistration = true;
      }
      initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
      }
      register(data) {
        const client = this._client;
        const middleware = client.middleware;
        const executeCommand = (command, args) => {
          const params = {
            command,
            arguments: args
          };
          return this.sendRequest(import_node4.ExecuteCommandRequest.type, params, import_node4.CancellationToken.None);
        };
        if (data.registerOptions.commands) {
          let disposables = [];
          for (const command of data.registerOptions.commands) {
            disposables.push(commands_default.registerCommand(command, (...args) => {
              return middleware.executeCommand ? middleware.executeCommand(command, args, executeCommand) : executeCommand(command, args);
            }, null, true));
          }
          this._commands.set(data.id, disposables);
        }
      }
      unregister(id2) {
        let disposables = this._commands.get(id2);
        if (disposables) {
          disposables.forEach((disposable) => disposable.dispose());
        }
      }
      dispose() {
        this._commands.forEach((value) => {
          value.forEach((disposable) => disposable.dispose());
        });
        this._commands.clear();
      }
    };
  }
});

// src/language-client/fileOperations.ts
function access(target, key) {
  return target[key];
}
function assign(target, key, value) {
  target[key] = value;
}
var FileOperationFeature, NotificationFileOperationFeature, DidCreateFilesFeature, DidRenameFilesFeature, DidDeleteFilesFeature, RequestFileOperationFeature, WillCreateFilesFeature, WillRenameFilesFeature, WillDeleteFilesFeature;
var init_fileOperations = __esm({
  "src/language-client/fileOperations.ts"() {
    "use strict";
    init_node();
    init_fs();
    init_protocol();
    init_workspace();
    init_features();
    init_uuid();
    FileOperationFeature = class _FileOperationFeature extends BaseFeature {
      constructor(client, event, registrationType, clientCapability, serverCapability) {
        super(client);
        this._filters = /* @__PURE__ */ new Map();
        this._event = event;
        this._registrationType = registrationType;
        this._clientCapability = clientCapability;
        this._serverCapability = serverCapability;
      }
      getState() {
        return { kind: "workspace", id: this._registrationType.method, registrations: this._filters.size > 0 };
      }
      get registrationType() {
        return this._registrationType;
      }
      fillClientCapabilities(capabilities) {
        const value = ensure(ensure(capabilities, "workspace"), "fileOperations");
        assign(value, "dynamicRegistration", true);
        assign(value, this._clientCapability, true);
      }
      initialize(capabilities) {
        const options2 = capabilities.workspace?.fileOperations;
        const capability = options2 !== void 0 ? access(options2, this._serverCapability) : void 0;
        if (capability?.filters !== void 0) {
          try {
            this.register({
              id: generateUuid(),
              registerOptions: { filters: capability.filters }
            });
          } catch (e) {
            this._client.warn(
              `Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`
            );
          }
        }
      }
      register(data) {
        if (!this._listener) {
          this._listener = this._event(this.send, this);
        }
        const minimatchFilter = data.registerOptions.filters.map((filter2) => {
          const matcher = new minimatch.Minimatch(
            filter2.pattern.glob,
            _FileOperationFeature.asMinimatchOptions(filter2.pattern.options)
          );
          if (!matcher.makeRe()) {
            throw new Error(`Invalid pattern ${filter2.pattern.glob}!`);
          }
          return { scheme: filter2.scheme, matcher, kind: filter2.pattern.matches };
        });
        this._filters.set(data.id, minimatchFilter);
      }
      unregister(id2) {
        this._filters.delete(id2);
      }
      dispose() {
        this._filters.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      async filter(event, prop) {
        const fileMatches = await Promise.all(
          event.files.map(async (item) => {
            const uri = prop(item);
            const path2 = uri.fsPath.replace(/\\/g, "/");
            for (const filters of this._filters.values()) {
              for (const filter2 of filters) {
                if (filter2.scheme !== void 0 && filter2.scheme !== uri.scheme) {
                  continue;
                }
                if (filter2.matcher.match(path2)) {
                  if (filter2.kind === void 0) {
                    return true;
                  }
                  const fileType = await getFileType(uri.fsPath);
                  if (fileType === void 0) {
                    this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                    return true;
                  }
                  if (fileType === 1 /* File */ && filter2.kind === import_node4.FileOperationPatternKind.file || fileType === 2 /* Directory */ && filter2.kind === import_node4.FileOperationPatternKind.folder) {
                    return true;
                  }
                } else if (filter2.kind === import_node4.FileOperationPatternKind.folder) {
                  const fileType = await getFileType(uri.fsPath);
                  if (fileType === 2 /* Directory */ && filter2.matcher.match(`${path2}/`)) {
                    return true;
                  }
                }
              }
            }
            return false;
          })
        );
        const files = event.files.filter((_, index) => fileMatches[index]);
        return { ...event, files };
      }
      static asMinimatchOptions(options2) {
        if (options2 === void 0) {
          return void 0;
        }
        if (options2.ignoreCase === true) {
          return { nocase: true };
        }
        return void 0;
      }
    };
    NotificationFileOperationFeature = class extends FileOperationFeature {
      constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, notificationType, clientCapability, serverCapability);
        this._notificationType = notificationType;
        this._accessUri = accessUri;
        this._createParams = createParams;
      }
      async send(originalEvent) {
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          const next = async (event) => {
            if (!this._client.isRunning()) return;
            return this._client.sendNotification(
              this._notificationType,
              this._createParams(event)
            );
          };
          let promise = this.doSend(filteredEvent, next);
          if (promise) {
            await promise.catch((e) => {
              this._client.error(`Sending notification ${this.registrationType.method} failed`, e);
            });
          }
        }
      }
    };
    DidCreateFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onDidCreateFiles,
          import_node4.DidCreateFilesNotification.type,
          "didCreate",
          "didCreate",
          (i) => i,
          client.code2ProtocolConverter.asDidCreateFilesParams
        );
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.didCreateFiles ? middleware.didCreateFiles(event, next) : next(event);
      }
    };
    DidRenameFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onDidRenameFiles,
          import_node4.DidRenameFilesNotification.type,
          "didRename",
          "didRename",
          (i) => i.oldUri,
          client.code2ProtocolConverter.asDidRenameFilesParams
        );
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.didRenameFiles ? middleware.didRenameFiles(event, next) : next(event);
      }
    };
    DidDeleteFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onDidDeleteFiles,
          import_node4.DidDeleteFilesNotification.type,
          "didDelete",
          "didDelete",
          (i) => i,
          client.code2ProtocolConverter.asDidDeleteFilesParams
        );
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.didDeleteFiles ? middleware.didDeleteFiles(event, next) : next(event);
      }
    };
    RequestFileOperationFeature = class extends FileOperationFeature {
      constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, requestType, clientCapability, serverCapability);
        this._requestType = requestType;
        this._accessUri = accessUri;
        this._createParams = createParams;
      }
      async send(originalEvent) {
        const waitUntil = this.waitUntil(originalEvent);
        originalEvent.waitUntil(waitUntil);
      }
      async waitUntil(originalEvent) {
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          const next = (event) => {
            return this.sendRequest(this._requestType, this._createParams(event), import_node4.CancellationToken.None);
          };
          return this.doSend(filteredEvent, next);
        } else {
          return void 0;
        }
      }
    };
    WillCreateFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onWillCreateFiles,
          import_node4.WillCreateFilesRequest.type,
          "willCreate",
          "willCreate",
          (i) => i,
          client.code2ProtocolConverter.asWillCreateFilesParams
        );
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willCreateFiles ? middleware.willCreateFiles(event, next) : next(event);
      }
    };
    WillRenameFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onWillRenameFiles,
          import_node4.WillRenameFilesRequest.type,
          "willRename",
          "willRename",
          (i) => i.oldUri,
          client.code2ProtocolConverter.asWillRenameFilesParams
        );
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willRenameFiles ? middleware.willRenameFiles(event, next) : next(event);
      }
    };
    WillDeleteFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onWillDeleteFiles,
          import_node4.WillDeleteFilesRequest.type,
          "willDelete",
          "willDelete",
          (i) => i,
          client.code2ProtocolConverter.asWillDeleteFilesParams
        );
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willDeleteFiles ? middleware.willDeleteFiles(event, next) : next(event);
      }
    };
  }
});

// src/model/relativePattern.ts
var RelativePattern2;
var init_relativePattern = __esm({
  "src/model/relativePattern.ts"() {
    "use strict";
    init_esm();
    init_errors();
    RelativePattern2 = class {
      constructor(base, pattern) {
        if (typeof base !== "string") {
          if (!base || !URI2.isUri(base) && typeof base.uri !== "string") {
            throw illegalArgument("base");
          }
        }
        if (typeof pattern !== "string") {
          throw illegalArgument("pattern");
        }
        if (typeof base === "string") {
          this.baseUri = URI2.file(base);
        } else if (URI2.isUri(base)) {
          this.baseUri = base;
        } else {
          this.baseUri = URI2.parse(base.uri);
        }
        this.pattern = pattern;
      }
      toJSON() {
        return {
          pattern: this.pattern,
          baseUri: this.baseUri.toJSON()
        };
      }
    };
  }
});

// src/language-client/fileSystemWatcher.ts
function asRelativePattern(rp) {
  let { baseUri, pattern } = rp;
  if (typeof baseUri === "string") {
    return new RelativePattern2(URI2.parse(baseUri), pattern);
  }
  return new RelativePattern2(baseUri, pattern);
}
var debounceTime6, FileSystemWatcherFeature;
var init_fileSystemWatcher2 = __esm({
  "src/language-client/fileSystemWatcher.ts"() {
    "use strict";
    init_util();
    init_is();
    init_node();
    init_protocol();
    init_workspace();
    init_features();
    init_uuid();
    init_relativePattern();
    init_esm();
    debounceTime6 = getConditionValue(200, 20);
    FileSystemWatcherFeature = class {
      constructor(_client) {
        this._client = _client;
        this._watchers = /* @__PURE__ */ new Map();
        this._fileEventsMap = /* @__PURE__ */ new Map();
        this.debouncedFileNotify = debounce(() => {
          void this._notifyFileEvent();
        }, debounceTime6);
      }
      async _notifyFileEvent() {
        let map = this._fileEventsMap;
        if (map.size == 0) return;
        await this._client.forceDocumentSync();
        this._client.sendNotification(import_node4.DidChangeWatchedFilesNotification.type, { changes: Array.from(map.values()) }).catch((error) => {
          this._client.error(`Notify file events failed.`, error);
        });
        map.clear();
      }
      notifyFileEvent(event) {
        let self = this;
        function didChangeWatchedFile(event2) {
          self._fileEventsMap.set(event2.uri, event2);
          self.debouncedFileNotify();
        }
        const workSpaceMiddleware = this._client.middleware.workspace;
        if (workSpaceMiddleware?.didChangeWatchedFile) {
          void workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile);
        } else {
          didChangeWatchedFile(event);
        }
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._watchers.size > 0 };
      }
      get registrationType() {
        return import_node4.DidChangeWatchedFilesNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "didChangeWatchedFiles").dynamicRegistration = true;
        ensure(ensure(capabilities, "workspace"), "didChangeWatchedFiles").relativePatternSupport = true;
      }
      initialize(_capabilities, _documentSelector) {
        let fileEvents = this._client.clientOptions.synchronize?.fileEvents;
        if (!fileEvents) return;
        let watchers = Array.isArray(fileEvents) ? fileEvents : [fileEvents];
        let disposables = [];
        for (let fileSystemWatcher of watchers) {
          disposables.push(fileSystemWatcher);
          this.hookListeners(
            fileSystemWatcher,
            !fileSystemWatcher.ignoreCreateEvents,
            !fileSystemWatcher.ignoreChangeEvents,
            !fileSystemWatcher.ignoreDeleteEvents,
            disposables
          );
        }
        this._watchers.set(generateUuid(), disposables);
      }
      register(data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
          return;
        }
        let disposables = [];
        for (let watcher of data.registerOptions.watchers) {
          let globPattern;
          if (string(watcher.globPattern)) {
            globPattern = watcher.globPattern;
          } else if (import_node4.RelativePattern.is(watcher.globPattern)) {
            globPattern = asRelativePattern(watcher.globPattern);
          } else {
            continue;
          }
          let watchCreate = true;
          let watchChange = true;
          let watchDelete = true;
          if (watcher.kind != null) {
            watchCreate = (watcher.kind & import_node4.WatchKind.Create) !== 0;
            watchChange = (watcher.kind & import_node4.WatchKind.Change) !== 0;
            watchDelete = (watcher.kind & import_node4.WatchKind.Delete) !== 0;
          }
          let fileSystemWatcher = workspace_default.createFileSystemWatcher(
            globPattern,
            !watchCreate,
            !watchChange,
            !watchDelete
          );
          this.hookListeners(
            fileSystemWatcher,
            watchCreate,
            watchChange,
            watchDelete,
            disposables
          );
          disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
      }
      hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        const client = this._client;
        if (watchCreate) {
          fileSystemWatcher.onDidCreate(
            (resource) => this.notifyFileEvent({
              uri: client.code2ProtocolConverter.asUri(resource),
              type: import_node4.FileChangeType.Created
            }),
            null,
            listeners
          );
        }
        if (watchChange) {
          fileSystemWatcher.onDidChange(
            (resource) => this.notifyFileEvent({
              uri: client.code2ProtocolConverter.asUri(resource),
              type: import_node4.FileChangeType.Changed
            }),
            null,
            listeners
          );
        }
        if (watchDelete) {
          fileSystemWatcher.onDidDelete(
            (resource) => this.notifyFileEvent({
              uri: client.code2ProtocolConverter.asUri(resource),
              type: import_node4.FileChangeType.Deleted
            }),
            null,
            listeners
          );
        }
      }
      unregister(id2) {
        let disposables = this._watchers.get(id2);
        if (disposables) {
          for (let disposable of disposables) {
            disposable.dispose();
          }
          this._watchers.delete(id2);
        }
      }
      dispose() {
        this._fileEventsMap.clear();
        this.debouncedFileNotify.clear();
        this._watchers.forEach((disposables) => {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        });
        this._watchers.clear();
      }
    };
  }
});

// src/language-client/foldingRange.ts
var FoldingRangeFeature;
var init_foldingRange = __esm({
  "src/language-client/foldingRange.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    FoldingRangeFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.FoldingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "foldingRange");
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5e3;
        capability.lineFoldingOnly = true;
        capability.foldingRangeKind = { valueSet: [import_node4.FoldingRangeKind.Comment, import_node4.FoldingRangeKind.Imports, import_node4.FoldingRangeKind.Region] };
        capability.foldingRange = { collapsedText: false };
      }
      initialize(capabilities, documentSelector) {
        const [id2, options2] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id2 || !options2) {
          return;
        }
        this.register({ id: id2, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideFoldingRanges: (document2, context, token) => {
            const client = this._client;
            const provideFoldingRanges = (document3, _, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3)
              };
              return this.sendRequest(import_node4.FoldingRangeRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideFoldingRanges ? middleware.provideFoldingRanges(document2, context, token, provideFoldingRanges) : provideFoldingRanges(document2, context, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerFoldingRangeProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/formatting.ts
var DocumentFormattingFeature, DocumentRangeFormattingFeature, DocumentOnTypeFormattingFeature;
var init_formatting2 = __esm({
  "src/language-client/formatting.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_uuid();
    DocumentFormattingFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.DocumentFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(
          ensure(capabilities, "textDocument"),
          "formatting"
        ).dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDocumentFormattingEdits: (document2, options3, token) => {
            const client = this._client;
            const provideDocumentFormattingEdits = (document3, options4, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                options: options4
              };
              return this.sendRequest(import_node4.DocumentFormattingRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideDocumentFormattingEdits ? middleware.provideDocumentFormattingEdits(document2, options3, token, provideDocumentFormattingEdits) : provideDocumentFormattingEdits(document2, options3, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [
          languages_default.registerDocumentFormatProvider(options2.documentSelector, provider, this._client.clientOptions.formatterPriority),
          provider
        ];
      }
    };
    DocumentRangeFormattingFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.DocumentRangeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(
          ensure(capabilities, "textDocument"),
          "rangeFormatting"
        ).dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDocumentRangeFormattingEdits: (document2, range, options3, token) => {
            const client = this._client;
            const provideDocumentRangeFormattingEdits = (document3, range2, options4, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                range: range2,
                options: options4
              };
              return this.sendRequest(import_node4.DocumentRangeFormattingRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideDocumentRangeFormattingEdits ? middleware.provideDocumentRangeFormattingEdits(document2, range, options3, token, provideDocumentRangeFormattingEdits) : provideDocumentRangeFormattingEdits(document2, range, options3, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [
          languages_default.registerDocumentRangeFormatProvider(options2.documentSelector, provider, void 0),
          provider
        ];
      }
    };
    DocumentOnTypeFormattingFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.DocumentOnTypeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "onTypeFormatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideOnTypeFormattingEdits: (document2, position, ch, options3, token) => {
            const client = this._client;
            const provideOnTypeFormattingEdits = (document3, position2, ch2, options4, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asVersionedTextDocumentIdentifier(document3),
                position: position2,
                ch: ch2,
                options: options4
              };
              return this.sendRequest(import_node4.DocumentOnTypeFormattingRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideOnTypeFormattingEdits ? middleware.provideOnTypeFormattingEdits(document2, position, ch, options3, token, provideOnTypeFormattingEdits) : provideOnTypeFormattingEdits(document2, position, ch, options3, token);
          }
        };
        this._client.attachExtensionName(provider);
        const moreTriggerCharacter = options2.moreTriggerCharacter || [];
        const characters = [options2.firstTriggerCharacter, ...moreTriggerCharacter];
        return [languages_default.registerOnTypeFormattingEditProvider(options2.documentSelector, provider, characters), provider];
      }
    };
  }
});

// src/language-client/hover.ts
var HoverFeature;
var init_hover = __esm({
  "src/language-client/hover.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_uuid();
    HoverFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.HoverRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const hoverCapability = ensure(
          ensure(capabilities, "textDocument"),
          "hover"
        );
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = this._client.supportedMarkupKind;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideHover: (document2, position, token) => {
            const client = this._client;
            const provideHover = (document3, position2, token2) => {
              return this.sendRequest(
                import_node4.HoverRequest.type,
                client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideHover ? middleware.provideHover(document2, position, token, provideHover) : provideHover(document2, position, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerHoverProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/implementation.ts
var ImplementationFeature;
var init_implementation = __esm({
  "src/language-client/implementation.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    ImplementationFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.ImplementationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const implementationSupport = ensure(ensure(capabilities, "textDocument"), "implementation");
        implementationSupport.dynamicRegistration = true;
        implementationSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const [id2, options2] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id2 || !options2) {
          return;
        }
        this.register({ id: id2, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideImplementation: (document2, position, token) => {
            const client = this._client;
            const provideImplementation = (document3, position2, token2) => this.sendRequest(import_node4.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2);
            const middleware = client.middleware;
            return middleware.provideImplementation ? middleware.provideImplementation(document2, position, token, provideImplementation) : provideImplementation(document2, position, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerImplementationProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/inlayHint.ts
var InlayHintsFeature;
var init_inlayHint = __esm({
  "src/language-client/inlayHint.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    InlayHintsFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.InlayHintRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const inlayHint = ensure(ensure(capabilities, "textDocument"), "inlayHint");
        inlayHint.dynamicRegistration = true;
        inlayHint.resolveSupport = {
          properties: ["tooltip", "textEdits", "label.tooltip", "label.location", "label.command"]
        };
        ensure(ensure(capabilities, "workspace"), "inlayHint").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        this._client.onRequest(import_node4.InlayHintRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeInlayHints.fire();
          }
        });
        const [id2, options2] = this.getRegistration(documentSelector, capabilities.inlayHintProvider);
        if (!id2 || !options2) {
          return;
        }
        this.register({ id: id2, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const eventEmitter = new import_node4.Emitter();
        const provider = {
          onDidChangeInlayHints: eventEmitter.event,
          provideInlayHints: (document2, range, token) => {
            const client = this._client;
            const provideInlayHints = (document3, range2, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                range: range2
              };
              return this.sendRequest(import_node4.InlayHintRequest.type, requestParams, token2, null);
            };
            const middleware = client.middleware;
            return middleware.provideInlayHints ? middleware.provideInlayHints(document2, range, token, provideInlayHints) : provideInlayHints(document2, range, token);
          }
        };
        provider.resolveInlayHint = options2.resolveProvider === true ? (hint, token) => {
          const client = this._client;
          const resolveInlayHint = (item, token2) => {
            return this.sendRequest(import_node4.InlayHintResolveRequest.type, item, token2);
          };
          const middleware = client.middleware;
          return middleware.resolveInlayHint ? middleware.resolveInlayHint(hint, token, resolveInlayHint) : resolveInlayHint(hint, token);
        } : void 0;
        const selector = options2.documentSelector;
        this._client.attachExtensionName(provider);
        return [languages_default.registerInlayHintsProvider(selector, provider), { provider, onDidChangeInlayHints: eventEmitter }];
      }
    };
  }
});

// src/language-client/inlineValue.ts
var InlineValueFeature;
var init_inlineValue = __esm({
  "src/language-client/inlineValue.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    InlineValueFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.InlineValueRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "inlineValue").dynamicRegistration = true;
        ensure(ensure(capabilities, "workspace"), "inlineValue").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        this._client.onRequest(import_node4.InlineValueRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeInlineValues.fire();
          }
        });
        const [id2, options2] = this.getRegistration(documentSelector, capabilities.inlineValueProvider);
        if (!id2 || !options2) {
          return;
        }
        this.register({ id: id2, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const eventEmitter = new import_node4.Emitter();
        const provider = {
          onDidChangeInlineValues: eventEmitter.event,
          provideInlineValues: (document2, viewPort, context, token) => {
            const client = this._client;
            const provideInlineValues = (document3, range, context2, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                range,
                context: context2
              };
              return this.sendRequest(import_node4.InlineValueRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideInlineValues ? middleware.provideInlineValues(document2, viewPort, context, token, provideInlineValues) : provideInlineValues(document2, viewPort, context, token);
          }
        };
        this._client.attachExtensionName(provider);
        const selector = options2.documentSelector;
        return [languages_default.registerInlineValuesProvider(selector, provider), { provider, onDidChangeInlineValues: eventEmitter }];
      }
    };
  }
});

// src/language-client/linkedEditingRange.ts
var LinkedEditingFeature;
var init_linkedEditingRange = __esm({
  "src/language-client/linkedEditingRange.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    LinkedEditingFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.LinkedEditingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const linkedEditingSupport = ensure(ensure(capabilities, "textDocument"), "linkedEditingRange");
        linkedEditingSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id2, options2] = this.getRegistration(documentSelector, capabilities.linkedEditingRangeProvider);
        if (!id2 || !options2) {
          return;
        }
        this.register({ id: id2, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideLinkedEditingRanges: (document2, position, token) => {
            const client = this._client;
            const provideLinkedEditing = (document3, position2, token2) => {
              const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2);
              return this.sendRequest(import_node4.LinkedEditingRangeRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideLinkedEditingRange ? middleware.provideLinkedEditingRange(document2, position, token, provideLinkedEditing) : provideLinkedEditing(document2, position, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerLinkedEditingRangeProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/progressPart.ts
function validPercent(n) {
  if (typeof n !== "number") return false;
  return n >= 0 && n <= 100;
}
var ProgressPart;
var init_progressPart = __esm({
  "src/language-client/progressPart.ts"() {
    "use strict";
    init_util();
    init_protocol();
    init_window();
    ProgressPart = class {
      constructor(client, token, done) {
        this.client = client;
        this.token = token;
        this.disposables = [];
        this._cancelled = false;
        this._percent = 0;
        this._started = false;
        this.disposables.push(client.onProgress(import_node4.WorkDoneProgress.type, this.token, (value) => {
          switch (value.kind) {
            case "begin":
              this.begin(value);
              break;
            case "report":
              this.report(value);
              break;
            case "end":
              this.done(value.message);
              if (done) {
                done(this);
              }
              break;
          }
        }));
      }
      begin(params) {
        if (this._started || this._cancelled) return false;
        this._started = true;
        void window_default.withProgress({
          source: `language-client-${this.client.id}`,
          cancellable: params.cancellable,
          title: params.title
        }, (progress, token) => {
          this.progress = progress;
          this.report(params);
          if (this._cancelled) return Promise.resolve();
          this.disposables.push(token.onCancellationRequested(() => {
            this.client.sendNotification(import_node4.WorkDoneProgressCancelNotification.type, { token: this.token });
            this.cancel();
          }));
          return new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
          });
        });
        return true;
      }
      report(params) {
        if (!this.progress) return;
        let msg = {};
        if (params.message) msg.message = params.message;
        if (validPercent(params.percentage)) {
          msg.increment = Math.round(params.percentage) - this._percent;
          this._percent = Math.round(params.percentage);
        }
        if (Object.keys(msg).length > 0) {
          this.progress.report(msg);
        }
      }
      cancel() {
        if (this._cancelled) return;
        this.cleanUp();
        if (this._reject !== void 0) {
          this._reject();
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
      done(message) {
        if (this.progress) {
          let msg = {};
          if (message) msg.message = message;
          if (typeof this._percent === "number" && this._percent > 0) msg.increment = 100 - this._percent;
          this.progress.report(msg);
        }
        this.cleanUp();
        if (this._resolve) {
          this._resolve();
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
      cleanUp() {
        this._cancelled = true;
        this.progress = void 0;
        disposeAll(this.disposables);
      }
    };
  }
});

// src/language-client/progress.ts
var ProgressFeature;
var init_progress2 = __esm({
  "src/language-client/progress.ts"() {
    "use strict";
    init_protocol();
    init_features();
    init_progressPart();
    ProgressFeature = class {
      constructor(_client) {
        this._client = _client;
        this.activeParts = /* @__PURE__ */ new Set();
      }
      get method() {
        return import_node4.WorkDoneProgressCreateRequest.method;
      }
      fillClientCapabilities(capabilities) {
        ensure(capabilities, "window").workDoneProgress = true;
      }
      getState() {
        return { kind: "window", id: import_node4.WorkDoneProgressCreateRequest.method, registrations: this.activeParts.size > 0 };
      }
      initialize() {
        let client = this._client;
        const deleteHandler = (part) => {
          this.activeParts.delete(part);
        };
        const createHandler = (params) => {
          this.activeParts.add(new ProgressPart(this._client, params.token, deleteHandler));
        };
        client.onRequest(import_node4.WorkDoneProgressCreateRequest.type, createHandler);
      }
      dispose() {
        for (const part of this.activeParts) {
          part.done();
        }
        this.activeParts.clear();
      }
    };
  }
});

// src/language-client/reference.ts
var ReferencesFeature;
var init_reference = __esm({
  "src/language-client/reference.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_uuid();
    ReferencesFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.ReferencesRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(
          ensure(capabilities, "textDocument"),
          "references"
        ).dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideReferences: (document2, position, options3, token) => {
            const client = this._client;
            const _providerReferences = (document3, position2, options4, token2) => {
              return this.sendRequest(
                import_node4.ReferencesRequest.type,
                client.code2ProtocolConverter.asReferenceParams(document3, position2, options4),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideReferences ? middleware.provideReferences(document2, position, options3, token, _providerReferences) : _providerReferences(document2, position, options3, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerReferencesProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/rename.ts
var RenameFeature;
var init_rename = __esm({
  "src/language-client/rename.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_is();
    init_protocol();
    init_features();
    init_uuid();
    RenameFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.RenameRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let rename = ensure(ensure(capabilities, "textDocument"), "rename");
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
        rename.honorsChangeAnnotations = true;
        rename.prepareSupportDefaultBehavior = import_node4.PrepareSupportDefaultBehavior.Identifier;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options2) {
          return;
        }
        if (boolean(capabilities.renameProvider)) {
          options2.prepareProvider = false;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideRenameEdits: (document2, position, newName, token) => {
            const client = this._client;
            const provideRenameEdits = (document3, position2, newName2, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                position: position2,
                newName: newName2
              };
              return this.sendRequest(import_node4.RenameRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideRenameEdits ? middleware.provideRenameEdits(document2, position, newName, token, provideRenameEdits) : provideRenameEdits(document2, position, newName, token);
          },
          prepareRename: options2.prepareProvider ? (document2, position, token) => {
            const client = this._client;
            const prepareRename = (document3, position2, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                position: position2
              };
              return this.sendRequest(import_node4.PrepareRenameRequest.type, params, token2).then((result) => {
                if (!result) return null;
                if (Range.is(result)) {
                  return result;
                } else if (this.isDefaultBehavior(result)) {
                  return result.defaultBehavior === true ? null : Promise.reject(new Error(`The element can't be renamed.`));
                } else if (result && Range.is(result.range)) {
                  return {
                    range: result.range,
                    placeholder: result.placeholder
                  };
                }
              });
            };
            const middleware = client.middleware;
            return middleware.prepareRename ? middleware.prepareRename(document2, position, token, prepareRename) : prepareRename(document2, position, token);
          } : void 0
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerRenameProvider(options2.documentSelector, provider), provider];
      }
      isDefaultBehavior(value) {
        const candidate = value;
        return candidate && boolean(candidate.defaultBehavior);
      }
    };
  }
});

// src/language-client/selectionRange.ts
var SelectionRangeFeature;
var init_selectionRange = __esm({
  "src/language-client/selectionRange.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    SelectionRangeFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.SelectionRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "selectionRange");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id2, options2] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
        if (!id2 || !options2) {
          return;
        }
        this.register({ id: id2, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideSelectionRanges: (document2, positions, token) => {
            const client = this._client;
            const provideSelectionRanges = (document3, positions2, token2) => {
              const requestParams = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                positions: positions2
              };
              return this.sendRequest(import_node4.SelectionRangeRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideSelectionRanges ? middleware.provideSelectionRanges(document2, positions, token, provideSelectionRanges) : provideSelectionRanges(document2, positions, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerSelectionRangeProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/semanticTokens.ts
var SemanticTokensFeature;
var init_semanticTokens = __esm({
  "src/language-client/semanticTokens.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_is();
    init_protocol();
    init_features();
    SemanticTokensFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.SemanticTokensRegistrationType.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = ensure(ensure(capabilities, "textDocument"), "semanticTokens");
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
          SemanticTokenTypes.namespace,
          SemanticTokenTypes.type,
          SemanticTokenTypes.class,
          SemanticTokenTypes.enum,
          SemanticTokenTypes.interface,
          SemanticTokenTypes.struct,
          SemanticTokenTypes.typeParameter,
          SemanticTokenTypes.parameter,
          SemanticTokenTypes.variable,
          SemanticTokenTypes.property,
          SemanticTokenTypes.enumMember,
          SemanticTokenTypes.event,
          SemanticTokenTypes.function,
          SemanticTokenTypes.method,
          SemanticTokenTypes.macro,
          SemanticTokenTypes.keyword,
          SemanticTokenTypes.modifier,
          SemanticTokenTypes.comment,
          SemanticTokenTypes.string,
          SemanticTokenTypes.number,
          SemanticTokenTypes.regexp,
          SemanticTokenTypes.decorator,
          SemanticTokenTypes.operator
        ];
        capability.tokenModifiers = [
          SemanticTokenModifiers.declaration,
          SemanticTokenModifiers.definition,
          SemanticTokenModifiers.readonly,
          SemanticTokenModifiers.static,
          SemanticTokenModifiers.deprecated,
          SemanticTokenModifiers.abstract,
          SemanticTokenModifiers.async,
          SemanticTokenModifiers.modification,
          SemanticTokenModifiers.documentation,
          SemanticTokenModifiers.defaultLibrary
        ];
        capability.formats = [import_node4.TokenFormat.Relative];
        capability.requests = {
          range: true,
          full: {
            delta: true
          }
        };
        capability.multilineTokenSupport = false;
        capability.overlappingTokenSupport = false;
        capability.serverCancelSupport = true;
        capability.augmentsSyntaxTokens = true;
        ensure(ensure(capabilities, "workspace"), "semanticTokens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(import_node4.SemanticTokensRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeSemanticTokensEmitter.fire();
          }
        });
        const [id2, options2] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        if (!id2 || !options2) {
          return;
        }
        this.register({ id: id2, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const fullProvider = boolean(options2.full) ? options2.full : options2.full !== void 0;
        const hasEditProvider = options2.full !== void 0 && typeof options2.full !== "boolean" && options2.full.delta === true;
        const eventEmitter = new import_node4.Emitter();
        const documentProvider = fullProvider ? {
          onDidChangeSemanticTokens: eventEmitter.event,
          provideDocumentSemanticTokens: (document2, token) => {
            const client = this._client;
            const middleware = client.middleware;
            const provideDocumentSemanticTokens = (document3, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3)
              };
              return this.sendRequest(import_node4.SemanticTokensRequest.type, params, token2);
            };
            return middleware.provideDocumentSemanticTokens ? middleware.provideDocumentSemanticTokens(document2, token, provideDocumentSemanticTokens) : provideDocumentSemanticTokens(document2, token);
          },
          provideDocumentSemanticTokensEdits: hasEditProvider ? (document2, previousResultId, token) => {
            const client = this._client;
            const middleware = client.middleware;
            const provideDocumentSemanticTokensEdits = (document3, previousResultId2, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                previousResultId: previousResultId2
              };
              return this.sendRequest(import_node4.SemanticTokensDeltaRequest.type, params, token2);
            };
            return middleware.provideDocumentSemanticTokensEdits ? middleware.provideDocumentSemanticTokensEdits(document2, previousResultId, token, provideDocumentSemanticTokensEdits) : provideDocumentSemanticTokensEdits(document2, previousResultId, token);
          } : void 0
        } : void 0;
        const hasRangeProvider = options2.range === true;
        const rangeProvider = hasRangeProvider ? {
          provideDocumentRangeSemanticTokens: (document2, range, token) => {
            const client = this._client;
            const middleware = client.middleware;
            const provideDocumentRangeSemanticTokens = (document3, range2, token2) => {
              const params = {
                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document3),
                range: range2
              };
              return this.sendRequest(import_node4.SemanticTokensRangeRequest.type, params, token2);
            };
            return middleware.provideDocumentRangeSemanticTokens ? middleware.provideDocumentRangeSemanticTokens(document2, range, token, provideDocumentRangeSemanticTokens) : provideDocumentRangeSemanticTokens(document2, range, token);
          }
        } : void 0;
        const disposables = [];
        if (documentProvider !== void 0) {
          this._client.attachExtensionName(documentProvider);
          disposables.push(languages_default.registerDocumentSemanticTokensProvider(options2.documentSelector, documentProvider, options2.legend));
        }
        if (rangeProvider !== void 0) {
          this._client.attachExtensionName(rangeProvider);
          disposables.push(languages_default.registerDocumentRangeSemanticTokensProvider(options2.documentSelector, rangeProvider, options2.legend));
        }
        return [import_node4.Disposable.create(() => disposables.forEach((item) => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
      }
    };
  }
});

// src/language-client/signatureHelp.ts
var SignatureHelpFeature;
var init_signatureHelp = __esm({
  "src/language-client/signatureHelp.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    init_uuid();
    SignatureHelpFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.SignatureHelpRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let config = ensure(ensure(capabilities, "textDocument"), "signatureHelp");
        config.dynamicRegistration = true;
        config.contextSupport = true;
        config.signatureInformation = {
          documentationFormat: this._client.supportedMarkupKind,
          activeParameterSupport: true,
          parameterInformation: {
            labelOffsetSupport: true
          }
        };
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options2) return;
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideSignatureHelp: (document2, position, token, context) => {
            const client = this._client;
            const providerSignatureHelp = (document3, position2, context2, token2) => {
              return this.sendRequest(
                import_node4.SignatureHelpRequest.type,
                client.code2ProtocolConverter.asSignatureHelpParams(document3, position2, context2),
                token2
              );
            };
            const middleware = client.middleware;
            return middleware.provideSignatureHelp ? middleware.provideSignatureHelp(document2, position, context, token, providerSignatureHelp) : providerSignatureHelp(document2, position, context, token);
          }
        };
        this._client.attachExtensionName(provider);
        const disposable = languages_default.registerSignatureHelpProvider(options2.documentSelector, provider, options2.triggerCharacters);
        return [disposable, provider];
      }
    };
  }
});

// src/language-client/textSynchronization.ts
var DidOpenTextDocumentFeature, DidCloseTextDocumentFeature, DidChangeTextDocumentFeature, WillSaveFeature, WillSaveWaitUntilFeature, DidSaveTextDocumentFeature;
var init_textSynchronization = __esm({
  "src/language-client/textSynchronization.ts"() {
    "use strict";
    init_protocol();
    init_workspace();
    init_features();
    init_uuid();
    DidOpenTextDocumentFeature = class extends TextDocumentEventFeature {
      constructor(client, _syncedDocuments) {
        super(
          client,
          workspace_default.onDidOpenTextDocument,
          import_node4.DidOpenTextDocumentNotification.type,
          "didOpen",
          (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument),
          TextDocumentEventFeature.textDocumentFilter
        );
        this._syncedDocuments = _syncedDocuments;
      }
      get registrationType() {
        return import_node4.DidOpenTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      get openDocuments() {
        return this._syncedDocuments.values();
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector) return;
        workspace_default.textDocuments.forEach((textDocument) => {
          let uri = textDocument.uri;
          if (this._syncedDocuments.has(uri)) return;
          void this.callback(textDocument);
        });
      }
      notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
      }
    };
    DidCloseTextDocumentFeature = class extends TextDocumentEventFeature {
      constructor(client, _syncedDocuments) {
        super(
          client,
          workspace_default.onDidCloseTextDocument,
          import_node4.DidCloseTextDocumentNotification.type,
          "didClose",
          (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument),
          TextDocumentEventFeature.textDocumentFilter
        );
        this._syncedDocuments = _syncedDocuments;
      }
      get registrationType() {
        return import_node4.DidCloseTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(
          ensure(capabilities, "textDocument"),
          "synchronization"
        ).dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.delete(textDocument.uri.toString());
      }
      unregister(id2) {
        let selector = this._selectors.get(id2);
        if (!selector) return;
        super.unregister(id2);
        let selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
          if (workspace_default.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument)) {
            let middleware = this._client.middleware;
            let didClose = (textDocument2) => {
              return this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            this._syncedDocuments.delete(textDocument.uri.toString());
            let promise = middleware.didClose ? middleware.didClose(textDocument, didClose) : didClose(textDocument);
            if (promise) {
              promise.catch((error) => {
                this._client.error(`Sending document notification ${this._type.method} failed`, error);
              });
            }
          }
        });
      }
    };
    DidChangeTextDocumentFeature = class extends DynamicDocumentFeature {
      constructor(client) {
        super(client);
        this._changeData = /* @__PURE__ */ new Map();
        this._onNotificationSent = new import_node4.Emitter();
      }
      *getDocumentSelectors() {
        for (const data of this._changeData.values()) {
          yield data.documentSelector;
        }
      }
      get registrationType() {
        return import_node4.DidChangeTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== import_node4.TextDocumentSyncKind.None) {
          this.register({
            id: generateUuid(),
            registerOptions: Object.assign(
              {},
              { documentSelector },
              { syncKind: textDocumentSyncOptions.change }
            )
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector) return;
        if (!this._listener) {
          this._listener = workspace_default.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
          documentSelector: data.registerOptions.documentSelector,
          syncKind: data.registerOptions.syncKind
        });
      }
      callback(event) {
        if (event.contentChanges.length === 0) {
          return;
        }
        let doc = workspace_default.getDocument(event.textDocument.uri);
        let { textDocument } = doc;
        const promises = [];
        for (const changeData of this._changeData.values()) {
          if (workspace_default.match(changeData.documentSelector, textDocument) > 0) {
            let middleware = this._client.middleware;
            let promise;
            let didChange;
            const client = this._client;
            if (changeData.syncKind === import_node4.TextDocumentSyncKind.Incremental) {
              didChange = async (event2) => {
                const params = client.code2ProtocolConverter.asChangeTextDocumentParams(event2);
                await this._client.sendNotification(import_node4.DidChangeTextDocumentNotification.type, params);
                this.notificationSent(event2, import_node4.DidChangeTextDocumentNotification.type, params);
              };
            } else if (changeData.syncKind === import_node4.TextDocumentSyncKind.Full) {
              didChange = async (event2) => {
                const params = client.code2ProtocolConverter.asFullChangeTextDocumentParams(textDocument);
                await this._client.sendNotification(import_node4.DidChangeTextDocumentNotification.type, params);
                this.notificationSent(event2, import_node4.DidChangeTextDocumentNotification.type, params);
              };
            } else {
              didChange = () => Promise.resolve(void 0);
            }
            promise = middleware.didChange ? middleware.didChange(event, didChange) : didChange(event);
            if (promise) promises.push(promise);
          }
        }
        return Promise.all(promises).then(void 0, (error) => {
          this._client.error(`Sending document notification ${import_node4.DidChangeTextDocumentNotification.type.method} failed`, error);
          throw error;
        });
      }
      get onNotificationSent() {
        return this._onNotificationSent.event;
      }
      notificationSent(changeEvent, type, params) {
        this._onNotificationSent.fire({ original: changeEvent, type, params });
      }
      unregister(id2) {
        this._changeData.delete(id2);
      }
      dispose() {
        this._changeData.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document2) {
        for (const changeData of this._changeData.values()) {
          if (workspace_default.match(changeData.documentSelector, document2) > 0) {
            return {
              send: (event) => {
                return this.callback(event);
              }
            };
          }
        }
        return void 0;
      }
    };
    WillSaveFeature = class extends TextDocumentEventFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onWillSaveTextDocument,
          import_node4.WillSaveTextDocumentNotification.type,
          "willSave",
          (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent),
          (selectors, willSaveEvent) => TextDocumentEventFeature.textDocumentFilter(selectors, willSaveEvent.document)
        );
      }
      get registrationType() {
        return import_node4.WillSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
        value.willSave = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
    };
    WillSaveWaitUntilFeature = class extends DynamicDocumentFeature {
      constructor(client) {
        super(client);
        this._selectors = /* @__PURE__ */ new Map();
      }
      getDocumentSelectors() {
        return this._selectors.values();
      }
      get registrationType() {
        return import_node4.WillSaveTextDocumentWaitUntilRequest.type;
      }
      fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
        value.willSaveWaitUntil = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && documentSelector.length > 0 && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = workspace_default.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
      }
      callback(event) {
        if (TextDocumentEventFeature.textDocumentFilter(
          this._selectors.values(),
          event.document
        )) {
          const client = this._client;
          let middleware = this._client.middleware;
          let willSaveWaitUntil = (event2) => {
            return this.sendRequest(
              import_node4.WillSaveTextDocumentWaitUntilRequest.type,
              client.code2ProtocolConverter.asWillSaveTextDocumentParams(event2),
              import_node4.CancellationToken.None
            );
          };
          event.waitUntil(
            middleware.willSaveWaitUntil ? middleware.willSaveWaitUntil(event, willSaveWaitUntil) : willSaveWaitUntil(event)
          );
        }
      }
      unregister(id2) {
        this._selectors.delete(id2);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._selectors.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
    };
    DidSaveTextDocumentFeature = class extends TextDocumentEventFeature {
      constructor(client) {
        super(
          client,
          workspace_default.onDidSaveTextDocument,
          import_node4.DidSaveTextDocumentNotification.type,
          "didSave",
          (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText),
          TextDocumentEventFeature.textDocumentFilter
        );
        this._includeText = false;
      }
      get registrationType() {
        return import_node4.DidSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").didSave = true;
      }
      initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
          const saveOptions = typeof textDocumentSyncOptions.save === "boolean" ? { includeText: false } : { includeText: !!textDocumentSyncOptions.save.includeText };
          this.register({
            id: generateUuid(),
            registerOptions: Object.assign({}, { documentSelector }, saveOptions)
          });
        }
      }
      register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
      }
    };
  }
});

// src/language-client/typeDefinition.ts
var TypeDefinitionFeature;
var init_typeDefinition = __esm({
  "src/language-client/typeDefinition.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    TypeDefinitionFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.TypeDefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const typeDefinitionSupport = ensure(ensure(capabilities, "textDocument"), "typeDefinition");
        typeDefinitionSupport.dynamicRegistration = true;
        typeDefinitionSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const [id2, options2] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id2 || !options2) {
          return;
        }
        this.register({ id: id2, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideTypeDefinition: (document2, position, token) => {
            const client = this._client;
            const provideTypeDefinition = (document3, position2, token2) => this.sendRequest(import_node4.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2), token2);
            const middleware = client.middleware;
            return middleware.provideTypeDefinition ? middleware.provideTypeDefinition(document2, position, token, provideTypeDefinition) : provideTypeDefinition(document2, position, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerTypeDefinitionProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/typeHierarchy.ts
var TypeHierarchyFeature;
var init_typeHierarchy = __esm({
  "src/language-client/typeHierarchy.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_features();
    TypeHierarchyFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_node4.TypeHierarchyPrepareRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = ensure(ensure(capabilities, "textDocument"), "typeHierarchy");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id2, options2] = this.getRegistration(documentSelector, capabilities.typeHierarchyProvider);
        if (!id2 || !options2) {
          return;
        }
        this.register({ id: id2, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const client = this._client;
        const selector = options2.documentSelector;
        const provider = {
          prepareTypeHierarchy: (document2, position, token) => {
            const prepareTypeHierarchy = (document3, position2, token2) => {
              const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document3, position2);
              return this.sendRequest(import_node4.TypeHierarchyPrepareRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.prepareTypeHierarchy ? middleware.prepareTypeHierarchy(document2, position, token, prepareTypeHierarchy) : prepareTypeHierarchy(document2, position, token);
          },
          provideTypeHierarchySupertypes: (item, token) => {
            const provideTypeHierarchySupertypes = (item2, token2) => {
              return this.sendRequest(import_node4.TypeHierarchySupertypesRequest.type, { item: item2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideTypeHierarchySupertypes ? middleware.provideTypeHierarchySupertypes(item, token, provideTypeHierarchySupertypes) : provideTypeHierarchySupertypes(item, token);
          },
          provideTypeHierarchySubtypes: (item, token) => {
            const provideTypeHierarchySubtypes = (item2, token2) => {
              return this.sendRequest(import_node4.TypeHierarchySubtypesRequest.type, { item: item2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideTypeHierarchySubtypes ? middleware.provideTypeHierarchySubtypes(item, token, provideTypeHierarchySubtypes) : provideTypeHierarchySubtypes(item, token);
          }
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerTypeHierarchyProvider(selector, provider), provider];
      }
    };
  }
});

// src/language-client/utils/index.ts
function getLocale() {
  const lang = process.env.LANG;
  if (!lang) return "en";
  return lang.split(".")[0];
}
function toMethod(type) {
  return string(type) ? type : type.method;
}
function currentTimeStamp() {
  return (/* @__PURE__ */ new Date()).toLocaleTimeString();
}
function getTraceMessage(data) {
  if (data.isLSPMessage && data.type) {
    return `[LSP   - ${currentTimeStamp()}] `;
  }
  return `[Trace - ${currentTimeStamp()}] `;
}
function data2String(data, color = false) {
  if (data instanceof import_node4.ResponseError) {
    const responseError = data;
    return `  Message: ${responseError.message}
  Code: ${responseError.code} ${responseError.data ? "\n" + responseError.data.toString() : ""}`;
  }
  if (data instanceof Error) {
    if (string(data.stack)) {
      return data.stack;
    }
    return data.message;
  }
  if (string(data)) {
    return data;
  }
  return (0, import_util.inspect)(data, false, null, color);
}
function parseTraceData(data) {
  if (typeof data !== "string") return data2String(data);
  let prefixes = ["Params: ", "Result: "];
  for (let prefix of prefixes) {
    if (data.startsWith(prefix)) {
      try {
        let obj = JSON.parse(data.slice(prefix.length));
        return prefix + data2String(obj, true);
      } catch (_e) {
        return data;
      }
    }
  }
  return data;
}
var init_utils = __esm({
  "src/language-client/utils/index.ts"() {
    "use strict";
    init_is();
    init_node();
    init_protocol();
  }
});

// src/language-client/utils/codeConverter.ts
function createConverter(uriConverter) {
  uriConverter = uriConverter || ((value) => value.toString());
  function asUri(value) {
    if (URI2.isUri(value)) {
      return uriConverter(value);
    } else {
      return uriConverter(URI2.parse(value));
    }
  }
  function asTextDocumentItem(textDocument) {
    return {
      uri: asUri(textDocument.uri),
      languageId: textDocument.languageId,
      version: textDocument.version,
      text: textDocument.getText()
    };
  }
  function asTextDocumentIdentifier(textDocument) {
    return {
      uri: asUri(textDocument.uri)
    };
  }
  function asVersionedTextDocumentIdentifier(textDocument) {
    return {
      uri: asUri(textDocument.uri),
      version: textDocument.version
    };
  }
  function asOpenTextDocumentParams(textDocument) {
    return {
      textDocument: asTextDocumentItem(textDocument)
    };
  }
  function asChangeTextDocumentParams(event) {
    let { textDocument, contentChanges } = event;
    let result = {
      textDocument: {
        uri: asUri(textDocument.uri),
        version: textDocument.version
      },
      contentChanges: contentChanges.slice()
    };
    return result;
  }
  function asFullChangeTextDocumentParams(textDocument) {
    return {
      textDocument: asVersionedTextDocumentIdentifier(textDocument),
      contentChanges: [{ text: textDocument.getText() }]
    };
  }
  function asCloseTextDocumentParams(textDocument) {
    return {
      textDocument: asTextDocumentIdentifier(textDocument)
    };
  }
  function asSaveTextDocumentParams(textDocument, includeText = false) {
    let result = {
      textDocument: asVersionedTextDocumentIdentifier(textDocument)
    };
    if (includeText) {
      result.text = textDocument.getText();
    }
    return result;
  }
  function asWillSaveTextDocumentParams(event) {
    return {
      textDocument: asTextDocumentIdentifier(event.document),
      reason: event.reason
    };
  }
  function asDidCreateFilesParams(event) {
    return {
      files: event.files.map((file) => ({ uri: asUri(file) }))
    };
  }
  function asDidRenameFilesParams(event) {
    return {
      files: event.files.map(
        (file) => ({ oldUri: asUri(file.oldUri), newUri: asUri(file.newUri) })
      )
    };
  }
  function asDidDeleteFilesParams(event) {
    return {
      files: event.files.map((file) => ({ uri: asUri(file) }))
    };
  }
  function asWillCreateFilesParams(event) {
    return {
      files: event.files.map((file) => ({ uri: asUri(file) }))
    };
  }
  function asWillRenameFilesParams(event) {
    return {
      files: event.files.map((file) => ({ oldUri: asUri(file.oldUri), newUri: asUri(file.newUri) }))
    };
  }
  function asWillDeleteFilesParams(event) {
    return {
      files: event.files.map((file) => ({ uri: asUri(file) }))
    };
  }
  function asTextDocumentPositionParams(textDocument, position) {
    return {
      textDocument: asTextDocumentIdentifier(textDocument),
      position
    };
  }
  function asCompletionParams(textDocument, position, context) {
    return {
      textDocument: asTextDocumentIdentifier(textDocument),
      position,
      context: omit(context, ["option"])
    };
  }
  function asSignatureHelpParams(textDocument, position, context) {
    return {
      textDocument: asTextDocumentIdentifier(textDocument),
      position,
      context
    };
  }
  function asReferenceParams(textDocument, position, options2) {
    return {
      textDocument: asTextDocumentIdentifier(textDocument),
      position,
      context: { includeDeclaration: options2.includeDeclaration }
    };
  }
  function asDocumentSymbolParams(textDocument) {
    return {
      textDocument: asTextDocumentIdentifier(textDocument)
    };
  }
  function asCodeLensParams(textDocument) {
    return {
      textDocument: asTextDocumentIdentifier(textDocument)
    };
  }
  function asDocumentLinkParams(textDocument) {
    return {
      textDocument: asTextDocumentIdentifier(textDocument)
    };
  }
  return {
    asUri,
    asTextDocumentItem,
    asTextDocumentIdentifier,
    asVersionedTextDocumentIdentifier,
    asOpenTextDocumentParams,
    asChangeTextDocumentParams,
    asFullChangeTextDocumentParams,
    asCloseTextDocumentParams,
    asSaveTextDocumentParams,
    asWillSaveTextDocumentParams,
    asDidCreateFilesParams,
    asDidRenameFilesParams,
    asDidDeleteFilesParams,
    asWillCreateFilesParams,
    asWillRenameFilesParams,
    asWillDeleteFilesParams,
    asTextDocumentPositionParams,
    asCompletionParams,
    asSignatureHelpParams,
    asReferenceParams,
    asDocumentSymbolParams,
    asCodeLensParams,
    asDocumentLinkParams
  };
}
var init_codeConverter = __esm({
  "src/language-client/utils/codeConverter.ts"() {
    "use strict";
    init_esm();
    init_lodash();
  }
});

// src/language-client/utils/errorHandler.ts
var CloseAction, ErrorAction, DefaultErrorHandler;
var init_errorHandler = __esm({
  "src/language-client/utils/errorHandler.ts"() {
    "use strict";
    CloseAction = /* @__PURE__ */ ((CloseAction2) => {
      CloseAction2[CloseAction2["DoNotRestart"] = 1] = "DoNotRestart";
      CloseAction2[CloseAction2["Restart"] = 2] = "Restart";
      return CloseAction2;
    })(CloseAction || {});
    ErrorAction = /* @__PURE__ */ ((ErrorAction2) => {
      ErrorAction2[ErrorAction2["Continue"] = 1] = "Continue";
      ErrorAction2[ErrorAction2["Shutdown"] = 2] = "Shutdown";
      return ErrorAction2;
    })(ErrorAction || {});
    DefaultErrorHandler = class {
      constructor(name2, maxRestartCount) {
        this.name = name2;
        this.maxRestartCount = maxRestartCount;
        this.milliseconds = 3 * 60 * 1e3;
        this.restarts = [];
      }
      error(_error, _message, count) {
        if (count && count <= 3) {
          return 1 /* Continue */;
        }
        return 2 /* Shutdown */;
      }
      closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length < this.maxRestartCount) {
          return 2 /* Restart */;
        } else {
          let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
          if (diff <= this.milliseconds) {
            console.error(`The "${this.name}" server crashed ${this.maxRestartCount} times in the last 3 minutes. The server will not be restarted.`);
            return 1 /* DoNotRestart */;
          } else {
            this.restarts.shift();
            return 2 /* Restart */;
          }
        }
      }
    };
  }
});

// src/language-client/utils/logger.ts
var logger33, ConsoleLogger, NullLogger;
var init_logger2 = __esm({
  "src/language-client/utils/logger.ts"() {
    "use strict";
    init_logger();
    logger33 = createLogger("language-client");
    ConsoleLogger = class {
      error(message) {
        logger33.error(message);
      }
      warn(message) {
        logger33.warn(message);
      }
      info(message) {
        logger33.info(message);
      }
      log(message) {
        logger33.log(message);
      }
    };
    NullLogger = class {
      error(_message) {
      }
      warn(_message) {
      }
      info(_message) {
      }
      log(_message) {
      }
    };
  }
});

// src/language-client/workspaceFolders.ts
function access2(target, key) {
  if (target === void 0) {
    return void 0;
  }
  return target[key];
}
function arrayDiff(left, right) {
  return left.filter((element) => !right.includes(element));
}
var WorkspaceFoldersFeature;
var init_workspaceFolders = __esm({
  "src/language-client/workspaceFolders.ts"() {
    "use strict";
    init_esm();
    init_fs();
    init_protocol();
    init_workspace();
    init_uuid();
    WorkspaceFoldersFeature = class {
      constructor(_client) {
        this._client = _client;
        this._listeners = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
      }
      get registrationType() {
        return import_node4.DidChangeWorkspaceFoldersNotification.type;
      }
      getValidWorkspaceFolders() {
        let { workspaceFolders } = workspace_default;
        if (!workspaceFolders || workspaceFolders.length == 0) return void 0;
        let ignoredRootPaths = this._client.clientOptions.ignoredRootPaths ?? [];
        let arr = workspaceFolders.filter((o) => {
          let fsPath2 = URI2.parse(o.uri).fsPath;
          return ignoredRootPaths.every((p) => !sameFile(p, fsPath2));
        });
        return arr.length ? arr : void 0;
      }
      fillInitializeParams(params) {
        const folders = this.getValidWorkspaceFolders();
        this.initializeWithFolders(folders);
        if (folders === void 0) {
          this._client.warn(`No valid workspaceFolder exists`);
          params.workspaceFolders = null;
        } else {
          params.workspaceFolders = folders.map((folder) => this.asProtocol(folder));
        }
      }
      initializeWithFolders(currentWorkspaceFolders) {
        this._initialFolders = currentWorkspaceFolders;
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
      }
      initialize(capabilities) {
        let client = this._client;
        client.onRequest(import_node4.WorkspaceFoldersRequest.type, (token) => {
          let workspaceFolders = () => {
            let folders = this.getValidWorkspaceFolders();
            if (folders === void 0) {
              return null;
            }
            let result = folders.map((folder) => this.asProtocol(folder));
            return result;
          };
          const middleware = client.middleware.workspace;
          return middleware?.workspaceFolders ? middleware.workspaceFolders(token, workspaceFolders) : workspaceFolders(token);
        });
        const value = access2(access2(access2(capabilities, "workspace"), "workspaceFolders"), "changeNotifications");
        let id2;
        if (typeof value === "string") {
          id2 = value;
        } else if (value) {
          id2 = generateUuid();
        }
        if (id2) {
          this.register({
            id: id2,
            registerOptions: void 0
          });
        }
      }
      doSendEvent(addedFolders, removedFolders) {
        let params = {
          event: {
            added: addedFolders.map((folder) => this.asProtocol(folder)),
            removed: removedFolders.map((folder) => this.asProtocol(folder))
          }
        };
        return this._client.sendNotification(import_node4.DidChangeWorkspaceFoldersNotification.type, params);
      }
      sendInitialEvent(currentWorkspaceFolders) {
        let promise;
        if (this._initialFolders && currentWorkspaceFolders) {
          const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
          const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
          if (added.length > 0 || removed.length > 0) {
            promise = this.doSendEvent(added, removed);
          }
        } else if (this._initialFolders) {
          promise = this.doSendEvent([], this._initialFolders);
        } else if (currentWorkspaceFolders) {
          promise = this.doSendEvent(currentWorkspaceFolders, []);
        }
        if (promise) {
          promise.catch((error) => {
            this._client.error(`Sending notification ${import_node4.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
          });
        }
      }
      register(data) {
        let id2 = data.id;
        let client = this._client;
        if (this._listeners.size > 0) return;
        let disposable = workspace_default.onDidChangeWorkspaceFolders((event) => {
          let didChangeWorkspaceFolders = (e) => {
            return this.doSendEvent(e.added, e.removed);
          };
          let middleware = client.middleware.workspace;
          const promise = middleware?.didChangeWorkspaceFolders ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders) : didChangeWorkspaceFolders(event);
          if (promise) {
            promise.catch((error) => {
              this._client.error(`Sending notification ${import_node4.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
            });
          }
        });
        this._listeners.set(id2, disposable);
        let workspaceFolders = this.getValidWorkspaceFolders();
        this.sendInitialEvent(workspaceFolders);
      }
      unregister(id2) {
      }
      dispose() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
      asProtocol(workspaceFolder) {
        if (workspaceFolder == null) return null;
        return { uri: this._client.code2ProtocolConverter.asUri(URI2.parse(workspaceFolder.uri)), name: workspaceFolder.name };
      }
    };
  }
});

// src/language-client/workspaceSymbol.ts
var WorkspaceFeature, WorkspaceSymbolFeature;
var init_workspaceSymbol = __esm({
  "src/language-client/workspaceSymbol.ts"() {
    "use strict";
    init_languages();
    init_protocol();
    init_documentSymbol();
    init_features();
    init_uuid();
    WorkspaceFeature = class extends BaseFeature {
      constructor(_client, _registrationType) {
        super(_client);
        this._registrationType = _registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      getState() {
        const registrations = this._registrations.size > 0;
        return { kind: "workspace", id: this._registrationType.method, registrations };
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
      }
      unregister(id2) {
        const registration = this._registrations.get(id2);
        if (registration) registration.disposable.dispose();
      }
      dispose() {
        this._registrations.forEach((value) => {
          value.disposable.dispose();
        });
        this._registrations.clear();
      }
      getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
          result.push(registration.provider);
        }
        return result;
      }
    };
    WorkspaceSymbolFeature = class extends WorkspaceFeature {
      constructor(client) {
        super(client, import_node4.WorkspaceSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, "workspace"), "symbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
          valueSet: SupportedSymbolTags
        };
        symbolCapabilities.resolveSupport = { properties: ["location.range"] };
      }
      initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideWorkspaceSymbols: (query, token) => {
            const client = this._client;
            const provideWorkspaceSymbols = (query2, token2) => {
              return this.sendRequest(import_node4.WorkspaceSymbolRequest.type, { query: query2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideWorkspaceSymbols ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols) : provideWorkspaceSymbols(query, token);
          },
          resolveWorkspaceSymbol: options2.resolveProvider === true ? (item, token) => {
            const client = this._client;
            const resolveWorkspaceSymbol = (item2, token2) => {
              return this.sendRequest(import_node4.WorkspaceSymbolResolveRequest.type, item2, token2);
            };
            const middleware = client.middleware;
            return middleware.resolveWorkspaceSymbol ? middleware.resolveWorkspaceSymbol(item, token, resolveWorkspaceSymbol) : resolveWorkspaceSymbol(item, token);
          } : void 0
        };
        this._client.attachExtensionName(provider);
        return [languages_default.registerWorkspaceSymbolProvider(provider), provider];
      }
    };
  }
});

// src/language-client/client.ts
function createConnection(input, output, errorHandler, closeHandler, options2) {
  let logger60 = new ConsoleLogger();
  let connection = (0, import_node4.createProtocolConnection)(input, output, logger60, options2);
  connection.onError((data) => {
    errorHandler(data[0], data[1], data[2]);
  });
  connection.onClose(closeHandler);
  let result = {
    id: "",
    hasPendingResponse: () => connection.hasPendingResponse(),
    listen: () => connection.listen(),
    sendRequest: (type, ...params) => {
      return connection.sendRequest(toMethod(type), ...params);
    },
    onRequest: (type, handler) => connection.onRequest(toMethod(type), handler),
    sendNotification: (type, params) => {
      return connection.sendNotification(toMethod(type), params);
    },
    onNotification: (type, handler) => connection.onNotification(toMethod(type), handler),
    onProgress: connection.onProgress,
    sendProgress: connection.sendProgress,
    trace: (value, tracer, sendNotificationOrTraceOptions) => {
      return connection.trace(value, tracer, sendNotificationOrTraceOptions);
    },
    initialize: (params) => {
      return connection.sendRequest(import_node4.InitializeRequest.type, params);
    },
    shutdown: () => {
      return connection.sendRequest(import_node4.ShutdownRequest.type, void 0);
    },
    exit: () => {
      return connection.sendNotification(import_node4.ExitNotification.type);
    },
    end: () => connection.end(),
    dispose: () => connection.dispose()
  };
  return result;
}
var logger34, redOpen, redClose, RevealOutputChannelOn, State, ClientState, MessageTransports, BaseLanguageClient, ProposedFeatures;
var init_client = __esm({
  "src/language-client/client.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_languages();
    init_logger();
    init_util();
    init_array();
    init_errors();
    init_extensionRegistry();
    init_fs();
    init_is();
    init_node();
    init_position();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    init_callHierarchy();
    init_codeAction();
    init_codeLens();
    init_colorProvider();
    init_completion();
    init_configuration4();
    init_declaration();
    init_definition();
    init_diagnostic();
    init_documentHighlight();
    init_documentLink();
    init_documentSymbol();
    init_executeCommand();
    init_features();
    init_fileOperations();
    init_fileSystemWatcher2();
    init_foldingRange();
    init_formatting2();
    init_hover();
    init_implementation();
    init_inlayHint();
    init_inlineValue();
    init_linkedEditingRange();
    init_progress2();
    init_progressPart();
    init_reference();
    init_rename();
    init_selectionRange();
    init_semanticTokens();
    init_signatureHelp();
    init_textSynchronization();
    init_typeDefinition();
    init_typeHierarchy();
    init_utils();
    init_codeConverter();
    init_errorHandler();
    init_logger2();
    init_uuid();
    init_workspaceFolders();
    init_workspaceSymbol();
    logger34 = createLogger("language-client-client");
    redOpen = "\x1B[31m";
    redClose = "\x1B[39m";
    RevealOutputChannelOn = /* @__PURE__ */ ((RevealOutputChannelOn2) => {
      RevealOutputChannelOn2[RevealOutputChannelOn2["Info"] = 1] = "Info";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Warn"] = 2] = "Warn";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Error"] = 3] = "Error";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Never"] = 4] = "Never";
      return RevealOutputChannelOn2;
    })(RevealOutputChannelOn || {});
    State = /* @__PURE__ */ ((State2) => {
      State2[State2["Stopped"] = 1] = "Stopped";
      State2[State2["Running"] = 2] = "Running";
      State2[State2["Starting"] = 3] = "Starting";
      return State2;
    })(State || {});
    ClientState = /* @__PURE__ */ ((ClientState2) => {
      ClientState2[ClientState2["Initial"] = 0] = "Initial";
      ClientState2[ClientState2["Starting"] = 1] = "Starting";
      ClientState2[ClientState2["StartFailed"] = 2] = "StartFailed";
      ClientState2[ClientState2["Running"] = 3] = "Running";
      ClientState2[ClientState2["Stopping"] = 4] = "Stopping";
      ClientState2[ClientState2["Stopped"] = 5] = "Stopped";
      return ClientState2;
    })(ClientState || {});
    ((MessageTransports2) => {
      function is(value) {
        let candidate = value;
        return candidate && import_node4.MessageReader.is(value.reader) && import_node4.MessageWriter.is(value.writer);
      }
      MessageTransports2.is = is;
    })(MessageTransports || (MessageTransports = {}));
    BaseLanguageClient = class _BaseLanguageClient {
      constructor(id2, name2, clientOptions) {
        this._consoleDebug = false;
        this._features = [];
        this._dynamicFeatures = /* @__PURE__ */ new Map();
        this._id = id2;
        this._name = name2;
        if (clientOptions.outputChannel) {
          this._outputChannel = clientOptions.outputChannel;
        } else {
          this._outputChannel = void 0;
        }
        this._clientOptions = this.resolveClientOptions(clientOptions);
        this.$state = 0 /* Initial */;
        this._connection = void 0;
        this._initializeResult = void 0;
        this._listeners = [];
        this._diagnostics = void 0;
        this._notificationHandlers = /* @__PURE__ */ new Map();
        this._pendingNotificationHandlers = /* @__PURE__ */ new Map();
        this._notificationDisposables = /* @__PURE__ */ new Map();
        this._requestHandlers = /* @__PURE__ */ new Map();
        this._pendingRequestHandlers = /* @__PURE__ */ new Map();
        this._requestDisposables = /* @__PURE__ */ new Map();
        this._progressHandlers = /* @__PURE__ */ new Map();
        this._pendingProgressHandlers = /* @__PURE__ */ new Map();
        this._progressDisposables = /* @__PURE__ */ new Map();
        this._ignoredRegistrations = /* @__PURE__ */ new Set();
        this._onStop = void 0;
        this._stateChangeEmitter = new import_node4.Emitter();
        this._trace = import_node4.Trace.Off;
        this._tracer = {
          log: (messageOrDataObject, data) => {
            if (string(messageOrDataObject)) {
              this.logTrace(messageOrDataObject, data);
            } else {
              this.logObjectTrace(messageOrDataObject);
            }
          }
        };
        this._c2p = createConverter(clientOptions.uriConverter ? clientOptions.uriConverter.code2Protocol : void 0);
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this.registerBuiltinFeatures();
        Error.captureStackTrace(this);
      }
      switchConsole() {
        this._consoleDebug = !this._consoleDebug;
        if (!this._consoleDebug) {
          this.enableVerboseTrace();
        }
      }
      resolveClientOptions(clientOptions) {
        const markdown = { isTrusted: false, supportHtml: false };
        if (clientOptions.markdown != null) {
          markdown.isTrusted = clientOptions.markdown.isTrusted === true;
          markdown.supportHtml = clientOptions.markdown.supportHtml === true;
        }
        let disableSnippetCompletion = clientOptions.disableSnippetCompletion;
        let disableMarkdown = clientOptions.disableMarkdown;
        if (disableMarkdown === void 0) {
          disableMarkdown = workspace_default.initialConfiguration.get("coc.preferences.enableMarkdown") === false;
        }
        const pullConfig = workspace_default.getConfiguration("pullDiagnostic", clientOptions.workspaceFolder);
        let pullOption = clientOptions.diagnosticPullOptions ?? {};
        if (pullOption.onChange === void 0) pullOption.onChange = pullConfig.get("onChange");
        if (pullOption.onSave === void 0) pullOption.onSave = pullConfig.get("onSave");
        if (pullOption.workspace === void 0) pullOption.workspace = pullConfig.get("workspace");
        pullOption.ignored = pullConfig.get("ignored", []).concat(pullOption.ignored ?? []);
        let disabledFeatures = clientOptions.disabledFeatures ?? [];
        for (let key of ["disableCompletion", "disableWorkspaceFolders", "disableDiagnostics"]) {
          if (typeof clientOptions[key] === "boolean") {
            let stack = "\n" + Error().stack.split("\n").slice(2, 4).join("\n");
            logger34.warn(`${key} in the client options is deprecated. use disabledFeatures instead.`, stack);
            if (clientOptions[key] === true) {
              let s = key.slice(7);
              disabledFeatures.push(s[0].toLowerCase() + s.slice(1));
            }
          }
        }
        return {
          disabledFeatures,
          disableMarkdown,
          disableSnippetCompletion,
          diagnosticPullOptions: pullOption,
          rootPatterns: clientOptions.rootPatterns ?? [],
          requireRootPattern: clientOptions.requireRootPattern,
          disableDynamicRegister: clientOptions.disableDynamicRegister,
          formatterPriority: clientOptions.formatterPriority ?? 0,
          ignoredRootPaths: clientOptions.ignoredRootPaths ?? [],
          documentSelector: clientOptions.documentSelector ?? [],
          synchronize: clientOptions.synchronize ?? {},
          diagnosticCollectionName: clientOptions.diagnosticCollectionName,
          outputChannelName: clientOptions.outputChannelName ?? this._id,
          revealOutputChannelOn: clientOptions.revealOutputChannelOn ?? 4 /* Never */,
          stdioEncoding: clientOptions.stdioEncoding ?? "utf8",
          initializationOptions: clientOptions.initializationOptions,
          initializationFailedHandler: clientOptions.initializationFailedHandler,
          progressOnInitialization: clientOptions.progressOnInitialization === true,
          errorHandler: clientOptions.errorHandler ?? this.createDefaultErrorHandler(clientOptions.connectionOptions?.maxRestartCount),
          middleware: clientOptions.middleware ?? {},
          workspaceFolder: clientOptions.workspaceFolder,
          connectionOptions: clientOptions.connectionOptions,
          markdown
        };
      }
      get supportedMarkupKind() {
        if (!this.clientOptions.disableMarkdown) return [MarkupKind.Markdown, MarkupKind.PlainText];
        return [MarkupKind.PlainText];
      }
      get state() {
        return this.getPublicState();
      }
      get $state() {
        return this._state;
      }
      set $state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
          this._stateChangeEmitter.fire({ oldState, newState });
        }
      }
      get id() {
        return this._id;
      }
      get name() {
        return this._name;
      }
      get middleware() {
        return this._clientOptions.middleware;
      }
      get code2ProtocolConverter() {
        return this._c2p;
      }
      getPublicState() {
        if (this.$state === 3 /* Running */) {
          return 2 /* Running */;
        } else if (this.$state === 1 /* Starting */) {
          return 3 /* Starting */;
        } else {
          return 1 /* Stopped */;
        }
      }
      get initializeResult() {
        return this._initializeResult;
      }
      async sendRequest(type, ...params) {
        this.checkState();
        try {
          const connection = await this.$start();
          return await connection.sendRequest(type, ...params);
        } catch (error) {
          this.error(`Sending request ${toMethod(type)} failed.`, error);
          throw error;
        }
      }
      onRequest(type, handler) {
        const method = toMethod(type);
        this._requestHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== void 0) {
          this._requestDisposables.set(method, connection.onRequest(type, handler));
          disposable = {
            dispose: () => {
              const disposable2 = this._requestDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._requestDisposables.delete(method);
              }
            }
          };
        } else {
          this._pendingRequestHandlers.set(method, handler);
          disposable = {
            dispose: () => {
              this._pendingRequestHandlers.delete(method);
              const disposable2 = this._requestDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._requestDisposables.delete(method);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._requestHandlers.delete(method);
            disposable.dispose();
          }
        };
      }
      async sendNotification(type, params) {
        if (this.$state === 2 /* StartFailed */ || this.$state === 4 /* Stopping */ || this.$state === 5 /* Stopped */) {
          return;
        }
        try {
          const connection = await this.$start();
          return await connection.sendNotification(type, params);
        } catch (error) {
          this.error(`Sending notification ${toMethod(type)} failed.`, error);
          throw error;
        }
      }
      onNotification(type, handler) {
        const method = toMethod(type);
        this._notificationHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== void 0) {
          this._notificationDisposables.set(method, connection.onNotification(type, handler));
          disposable = {
            dispose: () => {
              const disposable2 = this._notificationDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._notificationDisposables.delete(method);
              }
            }
          };
        } else {
          this._pendingNotificationHandlers.set(method, handler);
          disposable = {
            dispose: () => {
              this._pendingNotificationHandlers.delete(method);
              const disposable2 = this._notificationDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._notificationDisposables.delete(method);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._notificationHandlers.delete(method);
            disposable.dispose();
          }
        };
      }
      onProgress(type, token, handler) {
        this._progressHandlers.set(token, { type, handler });
        const connection = this.activeConnection();
        let disposable;
        const handleWorkDoneProgress = this._clientOptions.middleware.handleWorkDoneProgress;
        const realHandler = import_node4.WorkDoneProgress.is(type) && handleWorkDoneProgress !== void 0 ? (params) => {
          handleWorkDoneProgress(token, params, () => handler(params));
        } : handler;
        if (connection !== void 0) {
          this._progressDisposables.set(token, connection.onProgress(type, token, realHandler));
          disposable = {
            dispose: () => {
              const disposable2 = this._progressDisposables.get(token);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._progressDisposables.delete(token);
              }
            }
          };
        } else {
          this._pendingProgressHandlers.set(token, { type, handler });
          disposable = {
            dispose: () => {
              this._pendingProgressHandlers.delete(token);
              const disposable2 = this._progressDisposables.get(token);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._progressDisposables.delete(token);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._progressHandlers.delete(token);
            disposable.dispose();
          }
        };
      }
      async sendProgress(type, token, value) {
        this.checkState();
        try {
          const connection = await this.$start();
          await connection.sendProgress(type, token, value);
        } catch (error) {
          this.error(`Sending progress for token ${token} failed.`, error);
          throw error;
        }
      }
      /**
       * languageserver.xxx.settings or undefined
       */
      get configuredSection() {
        let section2 = this._clientOptions.synchronize?.configurationSection;
        return typeof section2 === "string" && section2.startsWith("languageserver.") ? section2 : void 0;
      }
      get clientOptions() {
        return this._clientOptions;
      }
      get onDidChangeState() {
        return this._stateChangeEmitter.event;
      }
      get outputChannel() {
        if (!this._outputChannel) {
          let { outputChannelName } = this._clientOptions;
          this._outputChannel = window_default.createOutputChannel(defaultValue(outputChannelName, this._name));
        }
        return this._outputChannel;
      }
      get diagnostics() {
        return this._diagnostics;
      }
      createDefaultErrorHandler(maxRestartCount) {
        return new DefaultErrorHandler(this._id, maxRestartCount ?? 4);
      }
      set trace(value) {
        this._trace = value;
        const connection = this.activeConnection();
        if (connection !== void 0) {
          void connection.trace(this._trace, this._tracer, {
            sendNotification: false,
            traceFormat: this._traceFormat
          });
        }
      }
      logObjectTrace(data) {
        this.outputChannel.append(getTraceMessage(data));
        this.traceData(data);
      }
      traceData(data, error = false) {
        this.outputChannel.appendLine(data2String(data));
        if (this._consoleDebug) error ? console.error(redOpen + data2String(data) + redClose) : console.log(parseTraceData(data));
      }
      consoleMessage(prefix, message, error = false) {
        if (this._consoleDebug) {
          let msg = prefix + " " + message;
          error ? console.error(redOpen + msg + redClose) : console.log(msg);
        }
      }
      info(message, data, showNotification = true) {
        let prefix = `[Info  - ${currentTimeStamp()}]`;
        this.outputChannel.appendLine(`${prefix} ${message}`);
        this.consoleMessage(prefix, message);
        if (data != null) this.traceData(data);
        if (showNotification && this._clientOptions.revealOutputChannelOn <= 1 /* Info */) {
          this.showNotificationMessage(import_node4.MessageType.Info, message);
        }
      }
      warn(message, data, showNotification = true) {
        let prefix = `[Warn  - ${currentTimeStamp()}]`;
        this.outputChannel.appendLine(`${prefix} ${message}`);
        this.consoleMessage(prefix, message);
        if (data != null) this.traceData(data);
        if (showNotification && this._clientOptions.revealOutputChannelOn <= 2 /* Warn */) {
          this.showNotificationMessage(import_node4.MessageType.Warning, message);
        }
      }
      error(message, data, showNotification = true) {
        let prefix = `[Error - ${currentTimeStamp()}]`;
        this.outputChannel.appendLine(`${prefix} ${message}`);
        this.consoleMessage(prefix, message, true);
        if (data != null) this.traceData(data, true);
        if (showNotification === "force" || showNotification && this._clientOptions.revealOutputChannelOn <= 3 /* Error */) {
          this.showNotificationMessage(import_node4.MessageType.Error, message);
        }
      }
      logTrace(message, data) {
        let prefix = `[Trace - ${currentTimeStamp()}]`;
        this.outputChannel.appendLine(`${prefix} ${message}`);
        this.consoleMessage(prefix, message);
        if (data != null) this.traceData(data);
      }
      showNotificationMessage(type, message) {
        const messageFunc = type === import_node4.MessageType.Error ? window_default.showErrorMessage.bind(window_default) : type === import_node4.MessageType.Warning ? window_default.showWarningMessage.bind(window_default) : window_default.showInformationMessage.bind(window_default);
        void messageFunc(message);
      }
      needsStart() {
        return this.$state === 0 /* Initial */ || this.$state === 4 /* Stopping */ || this.$state === 5 /* Stopped */;
      }
      needsStop() {
        return this.$state === 1 /* Starting */ || this.$state === 3 /* Running */;
      }
      activeConnection() {
        return this.$state === 3 /* Running */ && this._connection !== void 0 ? this._connection : void 0;
      }
      get hasPendingResponse() {
        return this._connection?.hasPendingResponse();
      }
      onReady() {
        if (this._onStart) return this._onStart;
        return new Promise((resolve) => {
          let disposable = this.onDidChangeState((e) => {
            if (e.newState === 2 /* Running */) {
              disposable.dispose();
              resolve();
            }
          });
        });
      }
      get started() {
        return this.$state != 0 /* Initial */;
      }
      isRunning() {
        return this.$state === 3 /* Running */;
      }
      async _start() {
        if (this._disposed === "disposing" || this._disposed === "disposed") {
          throw new Error(`Client got disposed and can't be restarted.`);
        }
        if (this.$state === 4 /* Stopping */) {
          throw new Error(`Client is currently stopping. Can only restart a full stopped client`);
        }
        if (this._onStart !== void 0) {
          return this._onStart;
        }
        this._rootPath = this.resolveRootPath();
        const [promise, resolve, reject] = this.createOnStartPromise();
        this._onStart = promise;
        if (this._diagnostics === void 0) {
          let opts = this._clientOptions;
          let name2 = opts.diagnosticCollectionName ? opts.diagnosticCollectionName : this._id;
          if (!opts.disabledFeatures.includes("diagnostics")) {
            this._diagnostics = languages_default.createDiagnosticCollection(name2);
          }
        }
        for (const [method, handler] of this._notificationHandlers) {
          if (!this._pendingNotificationHandlers.has(method)) {
            this._pendingNotificationHandlers.set(method, handler);
          }
        }
        for (const [method, handler] of this._requestHandlers) {
          if (!this._pendingRequestHandlers.has(method)) {
            this._pendingRequestHandlers.set(method, handler);
          }
        }
        for (const [token, data] of this._progressHandlers) {
          if (!this._pendingProgressHandlers.has(token)) {
            this._pendingProgressHandlers.set(token, data);
          }
        }
        this.$state = 1 /* Starting */;
        try {
          const connection = await this.createConnection();
          this.handleConnectionEvents(connection);
          connection.listen();
          await this.initialize(connection);
          resolve();
        } catch (error) {
          this.$state = 2 /* StartFailed */;
          this.error(`${this._name} client: couldn't create connection to server.`, error, "force");
          reject(error);
        }
        return this._onStart;
      }
      start() {
        let p = this._start();
        p.dispose = () => {
          if (this.needsStop()) {
            void this.stop();
          }
        };
        return p;
      }
      async $start() {
        if (this.$state === 2 /* StartFailed */) {
          throw new Error(`Previous start failed. Can't restart server.`);
        }
        await this._start();
        const connection = this.activeConnection();
        if (connection === void 0) {
          throw new Error(`Starting server failed`);
        }
        return connection;
      }
      handleConnectionEvents(connection) {
        connection.onNotification(import_node4.LogMessageNotification.type, (message) => {
          switch (message.type) {
            case import_node4.MessageType.Error:
              this.error(message.message);
              break;
            case import_node4.MessageType.Warning:
              this.warn(message.message);
              break;
            case import_node4.MessageType.Info:
              this.info(message.message);
              break;
            default:
              this.outputChannel.appendLine(message.message);
          }
        });
        connection.onNotification(import_node4.ShowMessageNotification.type, (message) => {
          switch (message.type) {
            case import_node4.MessageType.Error:
              void window_default.showErrorMessage(message.message);
              break;
            case import_node4.MessageType.Warning:
              void window_default.showWarningMessage(message.message);
              break;
            case import_node4.MessageType.Info:
              void window_default.showInformationMessage(message.message);
              break;
            default:
              void window_default.showInformationMessage(message.message);
          }
        });
        connection.onRequest(import_node4.ShowMessageRequest.type, (params) => {
          let messageFunc;
          switch (params.type) {
            case import_node4.MessageType.Error:
              messageFunc = window_default.showErrorMessage.bind(window_default);
              break;
            case import_node4.MessageType.Warning:
              messageFunc = window_default.showWarningMessage.bind(window_default);
              break;
            case import_node4.MessageType.Info:
              messageFunc = window_default.showInformationMessage.bind(window_default);
              break;
            default:
              messageFunc = window_default.showInformationMessage.bind(window_default);
          }
          let actions = toArray(params.actions);
          return messageFunc(params.message, ...actions).then((res) => {
            return res == null ? null : res;
          });
        });
        connection.onRequest(import_node4.ShowDocumentRequest.type, async (params) => {
          const showDocument = async (params2) => {
            try {
              if (params2.external === true || /^https?:\/\//.test(params2.uri)) {
                await workspace_default.openResource(params2.uri);
                return { success: true };
              } else {
                let { selection, takeFocus } = params2;
                if (takeFocus === false) {
                  await workspace_default.loadFile(params2.uri);
                } else {
                  await workspace_default.jumpTo(params2.uri, selection?.start);
                  if (selection && comparePosition(selection.start, selection.end) != 0) {
                    await window_default.selectRange(selection);
                  }
                }
                return { success: true };
              }
            } catch (error) {
              return { success: false };
            }
          };
          const middleware = this._clientOptions.middleware.window?.showDocument;
          if (middleware !== void 0) {
            return middleware(params, showDocument);
          } else {
            return showDocument(params);
          }
        });
      }
      createOnStartPromise() {
        let resolve;
        let reject;
        const promise = new Promise((_resolve, _reject) => {
          resolve = _resolve;
          reject = _reject;
        });
        return [promise, resolve, reject];
      }
      resolveRootPath() {
        if (this._clientOptions.workspaceFolder) {
          return URI2.parse(this._clientOptions.workspaceFolder.uri).fsPath;
        }
        let { ignoredRootPaths, rootPatterns, requireRootPattern } = this._clientOptions;
        let resolved;
        if (!isFalsyOrEmpty(rootPatterns)) {
          resolved = workspace_default.documentsManager.resolveRoot(rootPatterns, requireRootPattern);
        }
        let rootPath = resolved || workspace_default.rootPath;
        if (sameFile(rootPath, os.homedir()) || ignoredRootPaths.some((p) => sameFile(rootPath, p))) {
          this.warn(`Ignored rootPath ${rootPath} of client "${this._id}"`);
          return null;
        }
        return rootPath;
      }
      initialize(connection) {
        let { initializationOptions, workspaceFolder, progressOnInitialization } = this._clientOptions;
        this.refreshTrace(connection, false);
        let rootPath = this._rootPath;
        let initParams = {
          processId: process.pid,
          rootPath: rootPath ? rootPath : null,
          rootUri: rootPath ? this.code2ProtocolConverter.asUri(URI2.file(rootPath)) : null,
          capabilities: this.computeClientCapabilities(),
          initializationOptions: func(initializationOptions) ? initializationOptions() : initializationOptions,
          trace: import_node4.Trace.toString(this._trace),
          workspaceFolders: workspaceFolder ? [workspaceFolder] : null,
          locale: getLocale(),
          clientInfo: {
            name: "coc.nvim",
            version: workspace_default.version
          }
        };
        this.fillInitializeParams(initParams);
        if (progressOnInitialization) {
          const token = generateUuid();
          initParams.workDoneToken = token;
          connection.id = this._id;
          const part = new ProgressPart(connection, token);
          part.begin({ title: `Initializing ${this.id}`, kind: "begin" });
          return this.doInitialize(connection, initParams).then((result) => {
            part.done();
            return result;
          }, (error) => {
            part.done();
            return Promise.reject(error);
          });
        } else {
          return this.doInitialize(connection, initParams);
        }
      }
      async doInitialize(connection, initParams) {
        try {
          const result = await connection.initialize(initParams);
          if (result.capabilities.positionEncoding !== void 0 && result.capabilities.positionEncoding !== import_node4.PositionEncodingKind.UTF16) {
            await connection.shutdown();
            await connection.exit();
            connection.end();
            connection.dispose();
            throw new Error(`Unsupported position encoding (${result.capabilities.positionEncoding}) received from server ${this.name}`);
          }
          this._initializeResult = result;
          this.$state = 3 /* Running */;
          let textDocumentSyncOptions;
          if (number(result.capabilities.textDocumentSync)) {
            if (result.capabilities.textDocumentSync === import_node4.TextDocumentSyncKind.None) {
              textDocumentSyncOptions = {
                openClose: false,
                change: import_node4.TextDocumentSyncKind.None,
                save: void 0
              };
            } else {
              textDocumentSyncOptions = {
                openClose: true,
                change: result.capabilities.textDocumentSync,
                save: {
                  includeText: false
                }
              };
            }
          } else if (result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null) {
            textDocumentSyncOptions = result.capabilities.textDocumentSync;
          }
          this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
          connection.onNotification(import_node4.PublishDiagnosticsNotification.type, (params) => this.handleDiagnostics(params));
          connection.onRequest(import_node4.RegistrationRequest.type, (params) => this.handleRegistrationRequest(params));
          connection.onRequest("client/registerFeature", (params) => this.handleRegistrationRequest(params));
          connection.onRequest(import_node4.UnregistrationRequest.type, (params) => this.handleUnregistrationRequest(params));
          connection.onRequest("client/unregisterFeature", (params) => this.handleUnregistrationRequest(params));
          connection.onRequest(import_node4.ApplyWorkspaceEditRequest.type, (params) => this.handleApplyWorkspaceEdit(params));
          for (const [method, handler] of this._pendingNotificationHandlers) {
            this._notificationDisposables.set(method, connection.onNotification(method, handler));
          }
          this._pendingNotificationHandlers.clear();
          for (const [method, handler] of this._pendingRequestHandlers) {
            this._requestDisposables.set(method, connection.onRequest(method, handler));
          }
          this._pendingRequestHandlers.clear();
          for (const [token, data] of this._pendingProgressHandlers) {
            this._progressDisposables.set(token, connection.onProgress(data.type, token, data.handler));
          }
          this._pendingProgressHandlers.clear();
          await connection.sendNotification(import_node4.InitializedNotification.type, {});
          this.hookConfigurationChanged(connection);
          this.initializeFeatures(connection);
          return result;
        } catch (error) {
          let cb = (retry) => {
            if (retry) {
              this.initialize(connection).catch(() => {
              });
            } else {
              this.stop().catch(() => {
              });
            }
          };
          if (this._clientOptions.initializationFailedHandler) {
            cb(this._clientOptions.initializationFailedHandler(error));
          } else if (error instanceof import_node4.ResponseError && error.data && error.data.retry) {
            if (this._connection) {
              let connection2 = this._connection;
              connection2.end();
              this._connection.dispose();
              this._connection = null;
            }
            void window_default.showErrorMessage(error.message, { title: "Retry", id: "retry" }).then((item) => {
              cb(item && item.id === "retry");
            });
          } else {
            void window_default.showErrorMessage(toText(error.message));
            this.error("Server initialization failed.", error);
            logger34.error(`Server ${this.id} initialization failed.`, error);
            cb(false);
          }
          throw error;
        }
      }
      stop(timeout2 = 2e3) {
        return this.shutdown("stop", timeout2);
      }
      async shutdown(mode, timeout2) {
        if (this.$state === 5 /* Stopped */ || this.$state === 0 /* Initial */) {
          return;
        }
        if (this.$state === 4 /* Stopping */) {
          return this._onStop;
        }
        const connection = this.activeConnection();
        if (connection === void 0 || this.$state !== 3 /* Running */ && this.$state !== 1 /* Starting */) {
          throw new Error(`Client is not running and can't be stopped. It's current state is: ${this.$state}`);
        }
        this._initializeResult = void 0;
        this.$state = 4 /* Stopping */;
        this.cleanUp(mode);
        let tm;
        const tp = new Promise((c) => {
          tm = setTimeout(c, timeout2);
        });
        const shutdown = (async (connection2) => {
          await connection2.shutdown();
          await connection2.exit();
          return connection2;
        })(connection);
        return this._onStop = Promise.race([tp, shutdown]).then((connection2) => {
          if (tm) clearTimeout(tm);
          if (connection2 !== void 0) {
            connection2.end();
            connection2.dispose();
          } else {
            this.error(`Stopping server timed out`, void 0);
            throw new Error(`Stopping the server timed out`);
          }
        }, (error) => {
          this.error(`Stopping server failed`, error);
          throw error;
        }).finally(() => {
          this.$state = 5 /* Stopped */;
          if (mode === "stop") {
            this.cleanUpChannel();
          }
          this._onStart = void 0;
          this._onStop = void 0;
          this._connection = void 0;
          this._ignoredRegistrations.clear();
        });
      }
      dispose(timeout2 = 2e3) {
        if (this._disposed) return;
        try {
          this._disposed = "disposing";
          if (!this.needsStop()) return;
          return this.stop(timeout2);
        } finally {
          this._disposed = "disposed";
        }
      }
      cleanUp(mode) {
        if (this._listeners) {
          this._listeners.forEach((listener) => listener.dispose());
          this._listeners = [];
        }
        if (this._syncedDocuments) {
          this._syncedDocuments.clear();
        }
        for (let feature of this._features.values()) {
          if (typeof feature.dispose === "function") {
            feature.dispose();
          }
        }
        if (mode === "stop" && this._diagnostics) {
          this._diagnostics.dispose();
          this._diagnostics = void 0;
        }
      }
      cleanUpChannel() {
        if (this._outputChannel) {
          this._outputChannel.dispose();
          this._outputChannel = void 0;
        }
      }
      async forceDocumentSync() {
        let textDocuments = Array.from(this._syncedDocuments.values());
        await Promise.all(textDocuments.map((textDocument) => {
          let doc = workspace_default.getDocument(textDocument.uri);
          return doc ? doc.synchronize() : null;
        }));
      }
      handleDiagnostics(params) {
        let { uri, diagnostics, version: version2 } = params;
        if (number(version2) && !workspace_default.hasDocument(uri, version2)) return;
        let middleware = this.clientOptions.middleware.handleDiagnostics;
        if (middleware) {
          middleware(
            uri,
            diagnostics,
            (uri2, diagnostics2) => this.setDiagnostics(uri2, diagnostics2)
          );
        } else {
          this.setDiagnostics(uri, diagnostics);
        }
      }
      async createConnection() {
        let errorHandler = (error, message, count) => {
          this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
          this.handleConnectionClosed();
        };
        const transports = await this.createMessageTransports(defaultValue(this._clientOptions.stdioEncoding, "utf8"));
        this._connection = createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        return this._connection;
      }
      handleConnectionClosed() {
        if (this.$state === 5 /* Stopped */) {
          logger34.debug(`client ${this._id} normal closed`);
          return;
        }
        try {
          if (this._connection) {
            this._connection.dispose();
          }
        } catch (error) {
        }
        let action = 1 /* DoNotRestart */;
        if (this.$state !== 4 /* Stopping */ && this._clientOptions.errorHandler) {
          try {
            action = this._clientOptions.errorHandler.closed();
          } catch (error) {
          }
        }
        this._connection = void 0;
        if (action === 1 /* DoNotRestart */) {
          this.error("Connection to server got closed. Server will not be restarted.", void 0, "force");
          this.cleanUp("stop");
          if (this.$state === 1 /* Starting */) {
            this.$state = 2 /* StartFailed */;
          } else {
            this.$state = 5 /* Stopped */;
          }
          this._onStop = Promise.resolve();
          this._onStart = void 0;
        } else if (action === 2 /* Restart */) {
          this.info("Connection to server got closed. Server will restart.");
          this.cleanUp("restart");
          this.$state = 0 /* Initial */;
          this._onStop = Promise.resolve();
          this._onStart = void 0;
          this.start().catch(this.error.bind(this, `Restarting server failed`));
        }
      }
      checkState() {
        if (this.$state === 2 /* StartFailed */ || this.$state === 4 /* Stopping */ || this.$state === 5 /* Stopped */) {
          throw new import_node4.ResponseError(import_node4.ErrorCodes.ConnectionInactive, `Client is not running`);
        }
      }
      handleConnectionError(error, message, count) {
        let action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === 2 /* Shutdown */) {
          this.error(`Connection to server ${this._name} is erroring, ${error.message}. Shutting down server.`, error, "force");
          this.stop().catch(this.error.bind(this, `Stopping server failed`));
        }
      }
      hookConfigurationChanged(connection) {
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration(this._id)) {
            this.refreshTrace(connection, true);
          }
        }, null, this._listeners);
      }
      refreshTrace(connection, sendNotification) {
        let config = workspace_default.getConfiguration(this._id, this.clientOptions.workspaceFolder);
        let trace = import_node4.Trace.Off;
        let traceFormat = import_node4.TraceFormat.Text;
        if (config) {
          const traceConfig = config.get("trace.server", "off");
          if (typeof traceConfig === "string") {
            trace = import_node4.Trace.fromString(traceConfig);
          } else {
            trace = import_node4.Trace.fromString(config.get("trace.server.verbosity", "off"));
            traceFormat = import_node4.TraceFormat.fromString(config.get("trace.server.format", "text"));
          }
        }
        if (sendNotification && this._trace == trace && this._traceFormat == traceFormat) {
          return;
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
          sendNotification,
          traceFormat: this._traceFormat
        }).catch(this.error.bind(this, `Updating trace failed with error`));
      }
      enableVerboseTrace() {
        this._trace = import_node4.Trace.Verbose;
        this._traceFormat = import_node4.TraceFormat.Text;
        this._connection.trace(this._trace, this._tracer, {
          sendNotification: true,
          traceFormat: this._traceFormat
        }).catch(this.error.bind(this, `Updating trace failed with error`));
      }
      registerFeatures(features) {
        for (let feature of features) {
          this.registerFeature(feature, "");
        }
      }
      registerFeature(feature, name2) {
        let { disabledFeatures } = this._clientOptions;
        if (disabledFeatures.length > 0 && disabledFeatures.includes(name2)) return;
        this._features.push(feature);
        if (DynamicFeature.is(feature)) {
          const registrationType = feature.registrationType;
          this._dynamicFeatures.set(registrationType.method, feature);
        }
      }
      getStaticFeature(method) {
        return this._features.find((o) => StaticFeature.is(o) && o.method == method);
      }
      getFeature(request2) {
        return this._dynamicFeatures.get(request2);
      }
      registerBuiltinFeatures() {
        this.registerFeature(new SyncConfigurationFeature(this), "configuration");
        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments), "document");
        this.registerFeature(new DidChangeTextDocumentFeature(this), "document");
        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments), "document");
        this.registerFeature(new WillSaveFeature(this), "willSave");
        this.registerFeature(new WillSaveWaitUntilFeature(this), "willSaveWaitUntil");
        this.registerFeature(new DidSaveTextDocumentFeature(this), "didSave");
        this.registerFeature(new FileSystemWatcherFeature(this), "fileSystemWatcher");
        this.registerFeature(new CompletionItemFeature(this), "completion");
        this.registerFeature(new HoverFeature(this), "hover");
        this.registerFeature(new SignatureHelpFeature(this), "signatureHelp");
        this.registerFeature(new ReferencesFeature(this), "references");
        this.registerFeature(new DefinitionFeature(this), "definition");
        this.registerFeature(new DocumentHighlightFeature(this), "documentHighlight");
        this.registerFeature(new DocumentSymbolFeature(this), "documentSymbol");
        this.registerFeature(new CodeActionFeature(this), "codeAction");
        this.registerFeature(new CodeLensFeature(this), "codeLens");
        this.registerFeature(new DocumentFormattingFeature(this), "documentFormatting");
        this.registerFeature(new DocumentRangeFormattingFeature(this), "documentRangeFormatting");
        this.registerFeature(new DocumentOnTypeFormattingFeature(this), "documentOnTypeFormatting");
        this.registerFeature(new RenameFeature(this), "rename");
        this.registerFeature(new DocumentLinkFeature(this), "documentLink");
        this.registerFeature(new ExecuteCommandFeature(this), "executeCommand");
        this.registerFeature(new PullConfigurationFeature(this), "pullConfiguration");
        this.registerFeature(new TypeDefinitionFeature(this), "typeDefinition");
        this.registerFeature(new ImplementationFeature(this), "implementation");
        this.registerFeature(new DeclarationFeature(this), "declaration");
        this.registerFeature(new ColorProviderFeature(this), "colorProvider");
        this.registerFeature(new FoldingRangeFeature(this), "foldingRange");
        this.registerFeature(new SelectionRangeFeature(this), "selectionRange");
        this.registerFeature(new CallHierarchyFeature(this), "callHierarchy");
        this.registerFeature(new ProgressFeature(this), "progress");
        this.registerFeature(new LinkedEditingFeature(this), "linkedEditing");
        this.registerFeature(new DidCreateFilesFeature(this), "fileEvents");
        this.registerFeature(new DidRenameFilesFeature(this), "fileEvents");
        this.registerFeature(new DidDeleteFilesFeature(this), "fileEvents");
        this.registerFeature(new WillCreateFilesFeature(this), "fileEvents");
        this.registerFeature(new WillRenameFilesFeature(this), "fileEvents");
        this.registerFeature(new WillDeleteFilesFeature(this), "fileEvents");
        this.registerFeature(new SemanticTokensFeature(this), "semanticTokens");
        this.registerFeature(new InlayHintsFeature(this), "inlayHint");
        this.registerFeature(new InlineValueFeature(this), "inlineValue");
        this.registerFeature(new DiagnosticFeature(this), "pullDiagnostic");
        this.registerFeature(new TypeHierarchyFeature(this), "typeHierarchy");
        this.registerFeature(new WorkspaceSymbolFeature(this), "workspaceSymbol");
        if (this.clientOptions.workspaceFolder === void 0) {
          this.registerFeature(new WorkspaceFoldersFeature(this), "workspaceFolders");
        }
      }
      registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
      }
      fillInitializeParams(params) {
        for (let feature of this._features) {
          if (func(feature.fillInitializeParams)) {
            feature.fillInitializeParams(params);
          }
        }
      }
      computeClientCapabilities() {
        const result = {};
        ensure(result, "workspace").applyEdit = true;
        const workspaceEdit = ensure(ensure(result, "workspace"), "workspaceEdit");
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [import_node4.ResourceOperationKind.Create, import_node4.ResourceOperationKind.Rename, import_node4.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = import_node4.FailureHandlingKind.Undo;
        workspaceEdit.normalizesLineEndings = true;
        workspaceEdit.changeAnnotationSupport = {
          groupsOnLabel: false
        };
        const diagnostics = ensure(ensure(result, "textDocument"), "publishDiagnostics");
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = true;
        diagnostics.tagSupport = { valueSet: [DiagnosticTag.Unnecessary, DiagnosticTag.Deprecated] };
        diagnostics.codeDescriptionSupport = true;
        diagnostics.dataSupport = true;
        const windowCapabilities = ensure(result, "window");
        const showMessage = ensure(windowCapabilities, "showMessage");
        showMessage.messageActionItem = { additionalPropertiesSupport: true };
        const showDocument = ensure(windowCapabilities, "showDocument");
        showDocument.support = true;
        const generalCapabilities = ensure(result, "general");
        generalCapabilities.regularExpressions = { engine: "ECMAScript", version: "ES2020" };
        generalCapabilities.markdown = { parser: "marked", version: "7.0.5" };
        generalCapabilities.positionEncodings = ["utf-16"];
        generalCapabilities.staleRequestSupport = {
          cancel: true,
          retryOnContentModified: Array.from(_BaseLanguageClient.RequestsToCancelOnContentModified)
        };
        for (let feature of this._features) {
          feature.fillClientCapabilities(result);
        }
        return result;
      }
      initializeFeatures(_connection) {
        let documentSelector = this._clientOptions.documentSelector;
        for (let feature of this._features) {
          if (func(feature.preInitialize)) {
            feature.preInitialize(this._capabilities, documentSelector);
          }
        }
        for (let feature of this._features) {
          feature.initialize(this._capabilities, documentSelector);
        }
      }
      handleRegistrationRequest(params) {
        if (this.clientOptions.disableDynamicRegister) return;
        if (!this.isRunning()) {
          for (const registration of params.registrations) {
            this._ignoredRegistrations.add(registration.id);
          }
          return;
        }
        for (const registration of params.registrations) {
          const feature = this._dynamicFeatures.get(registration.method);
          if (!feature) {
            this.error(`No feature implementation for ${registration.method} found. Registration failed.`);
            return;
          }
          const options2 = registration.registerOptions ?? {};
          options2.documentSelector = options2.documentSelector ?? this._clientOptions.documentSelector;
          const data = {
            id: registration.id,
            registerOptions: options2
          };
          feature.register(data);
        }
      }
      handleUnregistrationRequest(params) {
        return new Promise((resolve) => {
          for (let unregistration of params.unregisterations) {
            if (this._ignoredRegistrations.has(unregistration.id)) continue;
            const feature = this._dynamicFeatures.get(unregistration.method);
            if (feature) feature.unregister(unregistration.id);
          }
          resolve();
        });
      }
      setDiagnostics(uri, diagnostics) {
        if (!this._diagnostics) return;
        this._diagnostics.set(uri, diagnostics);
      }
      handleApplyWorkspaceEdit(params) {
        let workspaceEdit = params.edit;
        let openTextDocuments = /* @__PURE__ */ new Map();
        workspace_default.textDocuments.forEach((document2) => openTextDocuments.set(document2.uri.toString(), document2));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
          for (const change of workspaceEdit.documentChanges) {
            if (TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
              let textDocument = openTextDocuments.get(change.textDocument.uri);
              if (textDocument && textDocument.version !== change.textDocument.version) {
                versionMismatch = true;
                break;
              }
            }
          }
        }
        if (versionMismatch) {
          return Promise.resolve({ applied: false });
        }
        return workspace_default.applyEdit(params.edit).then((value) => {
          return { applied: value };
        });
      }
      static {
        this.RequestsToCancelOnContentModified = /* @__PURE__ */ new Set([
          import_node4.InlayHintRequest.method,
          import_node4.SemanticTokensRequest.method,
          import_node4.SemanticTokensRangeRequest.method,
          import_node4.SemanticTokensDeltaRequest.method
        ]);
      }
      handleFailedRequest(type, token, error, defaultValue2) {
        if (token && token.isCancellationRequested) return defaultValue2;
        if (error instanceof import_node4.ResponseError) {
          if (error.code === import_node4.ErrorCodes.PendingResponseRejected || error.code === import_node4.ErrorCodes.ConnectionInactive) {
            return defaultValue2;
          }
          if (error.code === import_node4.LSPErrorCodes.RequestCancelled || error.code === import_node4.LSPErrorCodes.ServerCancelled) {
            if (error.data != null) {
              throw new LSPCancellationError(error.data);
            } else {
              throw new CancellationError();
            }
          } else if (error.code === import_node4.LSPErrorCodes.ContentModified) {
            if (_BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method)) {
              throw new CancellationError();
            } else {
              return defaultValue2;
            }
          }
        }
        this.error(`Request ${type.method} failed.`, error);
        throw error;
      }
      // Should be keeped
      logFailedRequest(type, error) {
        if (error instanceof import_node4.ResponseError && error.code === import_node4.LSPErrorCodes.RequestCancelled) {
          return;
        }
        this.error(`Request ${type.method} failed.`, error);
      }
      /**
       * Return extension name or id.
       */
      getExtensionName() {
        if (this.__extensionName) return this.__extensionName;
        let name2 = parseExtensionName(toText(this["stack"]));
        if (name2 && name2 !== "coc.nvim") {
          this.__extensionName = name2;
          return name2;
        }
        return this._id;
      }
      /**
       * Add __extensionName property to provider
       */
      attachExtensionName(provider) {
        if (!provider.hasOwnProperty("__extensionName")) {
          Object.defineProperty(provider, "__extensionName", {
            get: () => this.getExtensionName(),
            enumerable: true
          });
        }
      }
    };
    ProposedFeatures = {
      createAll: (_client) => {
        let result = [];
        return result;
      }
    };
  }
});

// src/language-client/index.ts
function getRuntimePath(runtime, serverWorkingDirectory) {
  if (path.isAbsolute(runtime)) {
    return runtime;
  }
  const mainRootPath = mainGetRootPath();
  if (mainRootPath !== void 0) {
    const result = path.join(mainRootPath, runtime);
    if (fs.existsSync(result)) {
      return result;
    }
  }
  if (serverWorkingDirectory !== void 0) {
    const result = path.join(serverWorkingDirectory, runtime);
    if (fs.existsSync(result)) {
      return result;
    }
  }
  return runtime;
}
function mainGetRootPath() {
  let folders = workspace_default.workspaceFolders;
  if (!folders || folders.length === 0) {
    return void 0;
  }
  let folder = folders[0];
  return folder.uri;
}
function getServerWorkingDir(options2) {
  let cwd2 = options2 && options2.cwd;
  if (cwd2 && !path.isAbsolute(cwd2)) cwd2 = path.join(workspace_default.cwd, cwd2);
  if (!cwd2) cwd2 = workspace_default.cwd;
  return new Promise((s) => {
    fs.lstat(cwd2, (err, stats) => {
      s(!err && stats.isDirectory() ? cwd2 : void 0);
    });
  });
}
function startedInDebugMode(args) {
  if (args) {
    return args.some((arg) => {
      return debugStartWith.some((value) => arg.startsWith(value)) || debugEquals.some((value) => arg === value);
    });
  }
  return false;
}
var logger35, debugStartWith, debugEquals, STOP_TIMEOUT, Executable, TransportKind, Transport, NodeModule, StreamInfo, ChildProcessInfo, LanguageClient, SettingMonitor;
var init_language_client = __esm({
  "src/language-client/index.ts"() {
    "use strict";
    init_logger();
    init_util();
    init_is();
    init_node();
    init_processes();
    init_protocol();
    init_workspace();
    init_client();
    init_client();
    logger35 = createLogger("language-client-index");
    debugStartWith = ["--debug=", "--debug-brk=", "--inspect=", "--inspect-brk="];
    debugEquals = ["--debug", "--debug-brk", "--inspect", "--inspect-brk"];
    STOP_TIMEOUT = getConditionValue(2e3, 100);
    ((Executable3) => {
      function is(value) {
        return string(value.command);
      }
      Executable3.is = is;
    })(Executable || (Executable = {}));
    TransportKind = /* @__PURE__ */ ((TransportKind2) => {
      TransportKind2[TransportKind2["stdio"] = 0] = "stdio";
      TransportKind2[TransportKind2["ipc"] = 1] = "ipc";
      TransportKind2[TransportKind2["pipe"] = 2] = "pipe";
      TransportKind2[TransportKind2["socket"] = 3] = "socket";
      return TransportKind2;
    })(TransportKind || {});
    ((Transport3) => {
      function isSocket(value) {
        let candidate = value;
        return candidate && candidate.kind === 3 /* socket */ && number(candidate.port);
      }
      Transport3.isSocket = isSocket;
    })(Transport || (Transport = {}));
    ((NodeModule2) => {
      function is(value) {
        return string(value.module);
      }
      NodeModule2.is = is;
    })(NodeModule || (NodeModule = {}));
    ((StreamInfo2) => {
      function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;
      }
      StreamInfo2.is = is;
    })(StreamInfo || (StreamInfo = {}));
    ((ChildProcessInfo2) => {
      function is(value) {
        let candidate = value;
        return candidate && candidate.process !== void 0 && typeof candidate.detached === "boolean";
      }
      ChildProcessInfo2.is = is;
    })(ChildProcessInfo || (ChildProcessInfo = {}));
    LanguageClient = class extends BaseLanguageClient {
      constructor(arg1, arg2, arg3, arg4, arg5) {
        let id2;
        let name2;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (string(arg2)) {
          id2 = arg1;
          name2 = arg2;
          serverOptions = arg3;
          clientOptions = arg4;
          forceDebug = !!arg5;
        } else {
          id2 = arg1.toLowerCase();
          name2 = arg1;
          serverOptions = arg2;
          clientOptions = arg3;
          forceDebug = arg4;
        }
        super(id2, name2, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = !!forceDebug;
        this._isInDebugMode = !!forceDebug;
      }
      stop(timeout2 = STOP_TIMEOUT) {
        return super.stop(timeout2).then(() => {
          if (this._serverProcess) {
            let toCheck = this._serverProcess;
            this._serverProcess = void 0;
            if (this._isDetached === void 0 || !this._isDetached) {
              this.checkProcessDied(toCheck);
            }
            this._isDetached = void 0;
          }
        }, (err) => {
          if (this._serverProcess && err.message.includes("timed out")) {
            this._serverProcess.kill("SIGKILL");
            this._serverProcess = void 0;
            return;
          }
          throw err;
        });
      }
      get serviceState() {
        return this._state;
      }
      checkProcessDied(childProcess) {
        if (!childProcess || childProcess.pid === void 0) return;
        setTimeout(() => {
          try {
            process.kill(childProcess.pid, 0);
            terminate(childProcess);
          } catch (error) {
          }
        }, STOP_TIMEOUT);
      }
      handleConnectionClosed() {
        this._serverProcess = void 0;
        super.handleConnectionClosed();
      }
      get isInDebugMode() {
        return this._isInDebugMode;
      }
      async restart() {
        await this.stop();
        if (this.isInDebugMode) {
          await new Promise((resolve) => setTimeout(resolve, 1e3));
          await this._start();
        } else {
          await this._start();
        }
      }
      createMessageTransports(encoding2) {
        function getEnvironment(env, fork) {
          if (!env && !fork) {
            return void 0;
          }
          let result = /* @__PURE__ */ Object.create(null);
          Object.keys(process.env).forEach((key) => result[key] = process.env[key]);
          if (env) {
            Object.keys(env).forEach((key) => result[key] = env[key]);
          }
          return result;
        }
        function assertStdio(process2) {
          if (process2.stdin === null || process2.stdout === null || process2.stderr === null) {
            throw new Error("Process created without stdio streams");
          }
        }
        let server = this._serverOptions;
        const logMessage = this.logMessage.bind(this);
        if (func(server)) {
          return server().then((result) => {
            if (MessageTransports.is(result)) {
              this._isDetached = !!result.detached;
              return result;
            } else if (StreamInfo.is(result)) {
              this._isDetached = !!result.detached;
              return {
                reader: new import_node4.StreamMessageReader(result.reader),
                writer: new import_node4.StreamMessageWriter(result.writer)
              };
            } else {
              let cp;
              if (ChildProcessInfo.is(result)) {
                cp = result.process;
                this._isDetached = result.detached;
              } else {
                cp = result;
                this._isDetached = false;
              }
              cp.stderr.on("data", logMessage);
              return {
                reader: new import_node4.StreamMessageReader(cp.stdout),
                writer: new import_node4.StreamMessageWriter(cp.stdin)
              };
            }
          });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
          if (typeof v8debug === "object" || this._forceDebug || startedInDebugMode(process.execArgv)) {
            json = runDebug.debug;
            this._isInDebugMode = true;
          } else {
            json = runDebug.run;
            this._isInDebugMode = false;
          }
        } else {
          json = server;
        }
        return getServerWorkingDir(json.options).then((serverWorkingDir) => {
          if (NodeModule.is(json) && json.module) {
            let node = json;
            let transport = node.transport || 0 /* stdio */;
            let pipeName;
            let runtime = node.runtime ? getRuntimePath(node.runtime, serverWorkingDir) : void 0;
            return new Promise((resolve, _reject) => {
              let args = node.args && node.args.slice() || [];
              if (transport === 1 /* ipc */) {
                args.push("--node-ipc");
              } else if (transport === 0 /* stdio */) {
                args.push("--stdio");
              } else if (transport === 2 /* pipe */) {
                pipeName = (0, import_node4.generateRandomPipeName)();
                args.push(`--pipe=${pipeName}`);
              } else if (Transport.isSocket(transport)) {
                args.push(`--socket=${transport.port}`);
              }
              args.push(`--clientProcessId=${process.pid}`);
              let options2 = node.options || /* @__PURE__ */ Object.create(null);
              options2.env = getEnvironment(options2.env, true);
              options2.execArgv = options2.execArgv || [];
              options2.cwd = serverWorkingDir;
              options2.silent = true;
              if (runtime) options2.execPath = runtime;
              if (transport === 1 /* ipc */ || transport === 0 /* stdio */) {
                let sp = child_process.fork(node.module, args || [], options2);
                assertStdio(sp);
                this._serverProcess = sp;
                logger35.info(`Language server "${this.id}" started with ${sp.pid}`);
                sp.stderr.on("data", logMessage);
                if (transport === 1 /* ipc */) {
                  sp.stdout.on("data", logMessage);
                  resolve({ reader: new import_node4.IPCMessageReader(this._serverProcess), writer: new import_node4.IPCMessageWriter(this._serverProcess) });
                } else {
                  resolve({ reader: new import_node4.StreamMessageReader(sp.stdout), writer: new import_node4.StreamMessageWriter(sp.stdin) });
                }
              } else if (transport === 2 /* pipe */) {
                return (0, import_node4.createClientPipeTransport)(pipeName).then((transport2) => {
                  let sp = child_process.fork(node.module, args || [], options2);
                  assertStdio(sp);
                  logger35.info(`Language server "${this.id}" started with ${sp.pid}`);
                  this._serverProcess = sp;
                  sp.stderr.on("data", logMessage);
                  sp.stdout.on("data", logMessage);
                  void transport2.onConnected().then((protocol2) => {
                    resolve({ reader: protocol2[0], writer: protocol2[1] });
                  });
                });
              } else if (Transport.isSocket(transport)) {
                return (0, import_node4.createClientSocketTransport)(transport.port).then((transport2) => {
                  let sp = child_process.fork(node.module, args || [], options2);
                  assertStdio(sp);
                  this._serverProcess = sp;
                  logger35.info(`Language server "${this.id}" started with ${sp.pid}`);
                  sp.stderr.on("data", logMessage);
                  sp.stdout.on("data", logMessage);
                  void transport2.onConnected().then((protocol2) => {
                    resolve({ reader: protocol2[0], writer: protocol2[1] });
                  });
                });
              }
            });
          } else if (Executable.is(json) && json.command) {
            let command = json;
            let args = command.args || [];
            let options2 = Object.assign({}, command.options);
            options2.env = options2.env ? Object.assign({}, process.env, options2.env) : process.env;
            options2.cwd = options2.cwd || serverWorkingDir;
            options2.shell = process.platform === "win32" || !!options2.shell;
            let cmd = workspace_default.expand(json.command);
            let serverProcess = child_process.spawn(cmd, args, options2);
            serverProcess.on("error", (e) => {
              this.error(e.message, e);
            });
            if (!serverProcess || !serverProcess.pid) {
              return Promise.reject(new Error(`Launching server "${this.id}" using command ${command.command} failed.`));
            }
            logger35.info(`Language server "${this.id}" started with ${serverProcess.pid}`);
            serverProcess.on("exit", (code) => {
              if (code != 0) this.error(`${command.command} exited with code: ${code}`);
            });
            serverProcess.stderr.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding2)));
            this._serverProcess = serverProcess;
            this._isDetached = !!options2.detached;
            return Promise.resolve({ reader: new import_node4.StreamMessageReader(serverProcess.stdout), writer: new import_node4.StreamMessageWriter(serverProcess.stdin) });
          }
          return Promise.reject(new Error(`Unsupported server configuration ${JSON.stringify(server, null, 2)}`));
        });
      }
      logMessage(data) {
        let encoding2 = this.clientOptions.stdioEncoding;
        this.outputChannel.append(string(data) ? data : data.toString(encoding2));
      }
    };
    SettingMonitor = class {
      constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
      }
      start() {
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration(this._setting)) {
            this.onDidChangeConfiguration();
          }
        }, null, this._listeners);
        this.onDidChangeConfiguration();
        return {
          dispose: () => {
            disposeAll(this._listeners);
            void this._client.dispose();
          }
        };
      }
      onDidChangeConfiguration() {
        let index = this._setting.indexOf(".");
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : void 0;
        let enabled = rest ? workspace_default.getConfiguration(primary).get(rest, true) : workspace_default.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
          this._client.start().catch((error) => this._client.error("Start failed after configuration change", error, "force"));
        } else if (!enabled && this._client.needsStop()) {
          this._client.stop().catch((error) => this._client.error("Stop failed after configuration change", error, "force"));
        }
      }
    };
  }
});

// src/services.ts
function documentSelectorToLanguageIds(documentSelector) {
  let res = documentSelector.map((filter2) => {
    if (typeof filter2 == "string") {
      return filter2;
    }
    return filter2.language;
  });
  res = res.filter((s) => typeof s == "string");
  return Array.from(new Set(res));
}
function getLanguageServerOptions(id2, name2, config, folder) {
  let { command, module: module2, port, args, filetypes } = config;
  args = args || [];
  if (!filetypes) {
    void window_default.showErrorMessage(`Wrong configuration of LS "${name2}", filetypes not found`);
    return null;
  }
  if (!command && !module2 && !port) {
    void window_default.showErrorMessage(`Wrong configuration of LS "${name2}", no command or module specified.`);
    return null;
  }
  let serverOptions;
  if (module2) {
    module2 = workspace_default.expand(module2);
    if (!fs.existsSync(module2)) {
      void window_default.showErrorMessage(`Module file "${module2}" not found for LS "${name2}"`);
      return null;
    }
    serverOptions = {
      module: module2,
      runtime: config.runtime ?? process.execPath,
      args,
      transport: getTransportKind(config),
      options: getForkOptions(config)
    };
  } else if (command) {
    serverOptions = {
      command,
      args,
      options: getSpawnOptions(config)
    };
  } else {
    serverOptions = () => new Promise((resolve, reject) => {
      let client = new net.Socket();
      let host = config.host ?? "127.0.0.1";
      logger36.info(`languageserver "${id2}" connecting to ${host}:${port}`);
      client.connect(port, host, () => {
        resolve({
          reader: client,
          writer: client
        });
      });
      client.on("error", (e) => {
        reject(new Error(`Connection error for ${id2}: ${e.message}`));
      });
    });
  }
  let disabledFeatures = Array.from(config.disabledFeatures || []);
  for (let key of ["disableWorkspaceFolders", "disableCompletion", "disableDiagnostics"]) {
    if (config[key] === true) {
      logger36.warn(`Language server config "${key}" is deprecated, use "disabledFeatures" instead.`);
      let s = key.slice(7);
      disabledFeatures.push(s[0].toLowerCase() + s.slice(1));
    }
  }
  let disableSnippetCompletion = !!config.disableSnippetCompletion;
  let ignoredRootPaths = toArray(config.ignoredRootPaths);
  let clientOptions = {
    workspaceFolder: folder == null ? void 0 : { name: path.basename(folder.fsPath), uri: folder.toString() },
    rootPatterns: config.rootPatterns,
    requireRootPattern: config.requireRootPattern,
    ignoredRootPaths: ignoredRootPaths.map((s) => workspace_default.expand(s)),
    disableSnippetCompletion,
    disableDynamicRegister: !!config.disableDynamicRegister,
    disabledFeatures,
    formatterPriority: config.formatterPriority,
    documentSelector: getDocumentSelector(config.filetypes, config.additionalSchemes),
    revealOutputChannelOn: getRevealOutputChannelOn(config.revealOutputChannelOn),
    synchronize: {
      configurationSection: `${id2}.settings`
    },
    diagnosticCollectionName: name2,
    outputChannelName: id2,
    stdioEncoding: config.stdioEncoding,
    progressOnInitialization: config.progressOnInitialization === true,
    initializationOptions: config.initializationOptions ?? {}
  };
  if (config.maxRestartCount) {
    clientOptions.connectionOptions = { maxRestartCount: config.maxRestartCount };
  }
  return [clientOptions, serverOptions];
}
function isValidServerConfig(key, config) {
  let errors = [];
  let fields = ["module", "command", "transport"];
  for (let field of fields) {
    let val = config[field];
    if (val && typeof val !== "string") {
      errors.push(`"${field}" field of languageserver ${key} should be string`);
    }
  }
  if (config.transportPort != null && typeof config.transportPort !== "number") {
    errors.push(`"transportPort" field of languageserver ${key} should be number`);
  }
  if (!Array.isArray(config.filetypes) || !config.filetypes.every((s) => typeof s === "string")) {
    errors.push(`"filetypes" field of languageserver ${key} should be array of string`);
  }
  if (config.additionalSchemes && (!Array.isArray(config.additionalSchemes) || config.additionalSchemes.some((s) => typeof s !== "string"))) {
    errors.push(`"additionalSchemes" field of languageserver ${key} should be array of string`);
  }
  if (errors.length) {
    logger36.error(`Invalid language server configuration for ${key}`, errors.join("\n"));
    return false;
  }
  return true;
}
function getRevealOutputChannelOn(revealOn) {
  switch (revealOn) {
    case "info":
      return 1 /* Info */;
    case "warn":
      return 2 /* Warn */;
    case "error":
      return 3 /* Error */;
    case "never":
      return 4 /* Never */;
    default:
      return 4 /* Never */;
  }
}
function getDocumentSelector(filetypes, additionalSchemes) {
  let documentSelector = [];
  let schemes = ["file", "untitled"].concat(additionalSchemes || []);
  if (!filetypes) return schemes.map((s) => ({ scheme: s }));
  filetypes.forEach((filetype) => {
    documentSelector.push(...schemes.map((scheme) => ({ language: filetype, scheme })));
  });
  return documentSelector;
}
function getTransportKind(config) {
  let { transport, transportPort } = config;
  if (!transport || transport == "ipc") return 1 /* ipc */;
  if (transport == "stdio") return 0 /* stdio */;
  if (transport == "pipe") return 2 /* pipe */;
  return { kind: 3 /* socket */, port: transportPort };
}
function getForkOptions(config) {
  return {
    cwd: config.cwd,
    execArgv: config.execArgv ?? [],
    env: config.env ?? void 0
  };
}
function getSpawnOptions(config) {
  return {
    cwd: config.cwd,
    detached: !!config.detached,
    shell: !!config.shell,
    env: config.env ?? void 0
  };
}
function convertState(state) {
  switch (state) {
    case 2 /* Running */:
      return 3 /* Running */;
    case 3 /* Starting */:
      return 1 /* Starting */;
    case 1 /* Stopped */:
      return 5 /* Stopped */;
    default:
      return void 0;
  }
}
function stateString(state) {
  switch (state) {
    case 2 /* Running */:
      return "running";
    case 3 /* Starting */:
      return "starting";
    case 1 /* Stopped */:
      return "stopped";
    default:
      return "unknown";
  }
}
function getStateName(state) {
  switch (state) {
    case 0 /* Initial */:
      return "init";
    case 3 /* Running */:
      return "running";
    case 1 /* Starting */:
      return "starting";
    case 2 /* StartFailed */:
      return "startFailed";
    case 4 /* Stopping */:
      return "stopping";
    case 5 /* Stopped */:
      return "stopped";
    default:
      return "unknown";
  }
}
var logger36, ServiceStat, ServiceManager, services_default;
var init_services = __esm({
  "src/services.ts"() {
    "use strict";
    init_esm();
    init_events();
    init_language_client();
    init_logger();
    init_util();
    init_array();
    init_node();
    init_object();
    init_protocol();
    init_window();
    init_workspace();
    logger36 = createLogger("services");
    ServiceStat = /* @__PURE__ */ ((ServiceStat2) => {
      ServiceStat2[ServiceStat2["Initial"] = 0] = "Initial";
      ServiceStat2[ServiceStat2["Starting"] = 1] = "Starting";
      ServiceStat2[ServiceStat2["StartFailed"] = 2] = "StartFailed";
      ServiceStat2[ServiceStat2["Running"] = 3] = "Running";
      ServiceStat2[ServiceStat2["Stopping"] = 4] = "Stopping";
      ServiceStat2[ServiceStat2["Stopped"] = 5] = "Stopped";
      return ServiceStat2;
    })(ServiceStat || {});
    ServiceManager = class {
      constructor() {
        this.registered = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.pendingNotifications = /* @__PURE__ */ new Map();
        this.registLanguageClient = this.registerLanguageClient.bind(this);
        this.regist = this.register.bind(this);
      }
      init() {
        workspace_default.onDidOpenTextDocument((document2) => {
          void this.start(document2);
        }, null, this.disposables);
        const iterate = (folders) => {
          for (let folder of folders) {
            this.registerClientsFromFolder(folder);
          }
        };
        workspace_default.onDidChangeWorkspaceFolders((e) => {
          iterate(e.added);
        }, null, this.disposables);
        let lspConfig = workspace_default.initialConfiguration.get("languageserver", {});
        this.registerClientsByConfig(lspConfig);
        iterate(workspace_default.workspaceFolders);
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("languageserver")) {
            let lspConfig2 = workspace_default.getConfiguration("languageserver", null);
            this.registerClientsByConfig(lspConfig2);
          }
        }, null, this.disposables);
      }
      registerClientsFromFolder(workspaceFolder) {
        let uri = URI2.parse(workspaceFolder.uri);
        let lspConfig = workspace_default.getConfiguration(void 0, uri);
        let config = lspConfig.inspect("languageserver").workspaceFolderValue;
        this.registerClientsByConfig(config, uri);
      }
      register(service) {
        let { id: id2 } = service;
        if (this.registered.get(id2)) return;
        this.registered.set(id2, service);
        this.tryStartService(service);
        service.onServiceReady(() => {
          logger36.info(`service ${id2} started`);
        }, null, this.disposables);
        return import_node4.Disposable.create(() => {
          if (!this.registered.has(id2)) return;
          service.dispose();
          this.registered.delete(id2);
        });
      }
      tryStartService(service) {
        if (!events_default.ready) {
          let disposable = events_default.on("ready", () => {
            disposable.dispose();
            if (this.shouldStart(service)) {
              void service.start();
            }
          });
        } else if (this.shouldStart(service)) {
          void service.start();
        }
      }
      getService(id2) {
        let service = this.registered.get(id2);
        if (!service) service = this.registered.get(`languageserver.${id2}`);
        return service;
      }
      shouldStart(service) {
        if (service.state != 0 /* Initial */) return false;
        let selector = service.selector;
        for (let doc of workspace_default.documents) {
          if (workspace_default.match(selector, doc.textDocument)) {
            return true;
          }
        }
        return false;
      }
      async start(document2) {
        let services = [];
        for (let service of this.registered.values()) {
          if (service.state == 0 /* Initial */ && workspace_default.match(service.selector, document2) > 0) {
            services.push(service);
          }
        }
        await Promise.allSettled(services.map((service) => {
          return service.start();
        }));
      }
      stop(id2) {
        let service = this.registered.get(id2);
        if (service) return Promise.resolve(service.stop());
      }
      async toggle(id2) {
        let service = this.registered.get(id2);
        if (!service) throw new Error(`Service ${id2} not found`);
        let { state } = service;
        if (state == 3 /* Running */) {
          await Promise.resolve(service.stop());
        } else if (state == 0 /* Initial */ || state == 2 /* StartFailed */) {
          await service.start();
        } else if (state == 5 /* Stopped */) {
          await service.restart();
        }
      }
      getServiceStats() {
        let res = [];
        for (let [id2, service] of this.registered) {
          res.push({
            id: id2,
            languageIds: documentSelectorToLanguageIds(service.selector),
            state: getStateName(service.state)
          });
        }
        return res;
      }
      registerClientsByConfig(lspConfig, folder) {
        for (let key of Object.keys(toObject(lspConfig))) {
          let config = lspConfig[key];
          if (!isValidServerConfig(key, config)) {
            continue;
          }
          this.registerLanguageClient(key, config, folder);
        }
      }
      async getLanguageClient(id2) {
        let service = this.getService(id2);
        if (!service) await wait(100);
        service = this.getService(id2);
        if (!service || !service.client) {
          throw new Error(`Language server ${id2} not found`);
        }
        return service.client;
      }
      async sendNotification(id2, method, params) {
        let client = await this.getLanguageClient(id2);
        await Promise.resolve(client.sendNotification(method, params));
      }
      async sendRequest(id2, method, params, token) {
        let client = await this.getLanguageClient(id2);
        token = token ?? import_node4.CancellationToken.None;
        return await Promise.resolve(client.sendRequest(method, params, token));
      }
      registerNotification(id2, method) {
        let service = this.getService(id2);
        if (service && service.client) {
          service.client.onNotification(method, async (result) => {
            this.sendNotificationVim(id2, method, result);
          });
        }
        let arr = this.pendingNotifications.get(id2) ?? [];
        arr.push({ id: id2, method });
        this.pendingNotifications.set(id2, arr);
      }
      getRegisteredNotifications(id2) {
        id2 = id2.startsWith("languageserver") ? id2.slice("languageserver.".length) : id2;
        return this.pendingNotifications.get(id2) ?? [];
      }
      sendNotificationVim(id2, method, result) {
        workspace_default.nvim.call("coc#do_notify", [id2, method, result], true);
      }
      registerLanguageClient(name2, config, folder) {
        let id2 = typeof name2 === "string" ? `languageserver.${name2}` : name2.id;
        let disposables = [];
        let onDidServiceReady = new import_node4.Emitter();
        let client = typeof name2 === "string" ? null : name2;
        if (this.registered.has(id2)) return import_node4.Disposable.create(() => {
        });
        if (client && typeof client.dispose === "function") disposables.push(client);
        let created = false;
        let service = {
          id: id2,
          client,
          name: typeof name2 === "string" ? name2 : name2.name,
          selector: typeof name2 === "string" ? getDocumentSelector(config.filetypes, config.additionalSchemes) : name2.clientOptions.documentSelector,
          state: client && client.state === 2 /* Running */ ? 3 /* Running */ : 0 /* Initial */,
          onServiceReady: onDidServiceReady.event,
          start: async () => {
            if (!created) {
              if (typeof name2 == "string" && !client) {
                let config2 = workspace_default.getConfiguration(void 0, folder).get(`languageserver.${name2}`, {});
                let opts = getLanguageServerOptions(id2, name2, config2, folder);
                if (!opts || config2.enable === false) return;
                client = new LanguageClient(id2, name2, opts[1], opts[0]);
                service.selector = opts[0].documentSelector;
                service.client = client;
                disposables.push(client);
              }
              created = true;
              for (let item of this.getRegisteredNotifications(id2)) {
                service.client.onNotification(item.method, async (result) => {
                  this.sendNotificationVim(item.id, item.method, result);
                });
              }
              client.onDidChangeState((changeEvent) => {
                let { oldState, newState } = changeEvent;
                service.state = convertState(newState);
                let oldStr = stateString(oldState);
                let newStr = stateString(newState);
                logger36.info(`LanguageClient ${client.name} state change: ${oldStr} => ${newStr}`);
              }, null, disposables);
            }
            try {
              if (!client.needsStart()) {
                service.state = convertState(client.state);
              } else {
                service.state = 1 /* Starting */;
                logger36.debug(`starting service: ${id2}`);
                await client.start();
                onDidServiceReady.fire(void 0);
              }
            } catch (e) {
              void window_default.showErrorMessage(`Server ${id2} failed to start: ${e}`);
              logger36.error(`Server ${id2} failed to start:`, e);
              service.state = 2 /* StartFailed */;
            }
          },
          dispose: async () => {
            onDidServiceReady.dispose();
            disposeAll(disposables);
          },
          stop: async () => {
            if (!client || !client.needsStop()) return;
            await Promise.resolve(client.stop());
          },
          restart: async () => {
            if (client) {
              service.state = 1 /* Starting */;
              await client.restart();
            } else {
              await service.start();
            }
          }
        };
        return this.register(service);
      }
      dispose() {
        disposeAll(this.disposables);
        for (let service of this.registered.values()) {
          service.dispose();
        }
        this.registered.clear();
      }
    };
    services_default = new ServiceManager();
  }
});

// src/list/source/services.ts
var ServicesList;
var init_services2 = __esm({
  "src/list/source/services.ts"() {
    "use strict";
    init_services();
    init_util();
    init_basic();
    init_formatting();
    ServicesList = class extends BasicList {
      constructor() {
        super();
        this.defaultAction = "toggle";
        this.description = "registered services of coc.nvim";
        this.name = "services";
        this.addAction("toggle", async (item) => {
          let { id: id2 } = item.data;
          await services_default.toggle(id2);
          await wait(50);
        }, { persist: true, reload: true });
      }
      async loadItems(_context) {
        let stats = services_default.getServiceStats();
        return formatListItems(this.alignColumns, stats.map((stat) => {
          let prefix = stat.state == "running" ? "*" : " ";
          return {
            label: [prefix, stat.id, `[${stat.state}]`, stat.languageIds.join(", ")],
            data: { id: stat.id }
          };
        }));
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocServicesPrefix /\\v^./ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesName /\\v%3c\\S+/ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesStat /\\v\\t\\[\\w+\\]/ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesLanguages /\\v(\\])@<=.*$/ contained containedin=CocServicesLine", true);
        nvim.command("highlight default link CocServicesPrefix Special", true);
        nvim.command("highlight default link CocServicesName Type", true);
        nvim.command("highlight default link CocServicesStat Statement", true);
        nvim.command("highlight default link CocServicesLanguages Comment", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/sources.ts
var SourcesList;
var init_sources = __esm({
  "src/list/source/sources.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_sources2();
    init_basic();
    init_formatting();
    SourcesList = class extends BasicList {
      constructor() {
        super();
        this.defaultAction = "toggle";
        this.description = "registered completion sources";
        this.name = "sources";
        this.addAction("toggle", async (item) => {
          let { name: name2 } = item.data;
          sources_default.toggleSource(name2);
        }, { persist: true, reload: true });
        this.addAction("refresh", async (item) => {
          let { name: name2 } = item.data;
          await sources_default.refresh(name2);
        }, { persist: true, reload: true });
        this.addAction("open", async (item, context) => {
          let { location } = item;
          if (location) await this.jumpTo(location, null, context);
        });
      }
      async loadItems() {
        let stats = sources_default.sourceStats();
        return stats.map((stat) => {
          let prefix = stat.disabled ? " " : "*";
          let location;
          if (stat.filepath) {
            location = Location.create(URI2.file(stat.filepath).toString(), Range.create(0, 0, 0, 0));
          }
          return {
            label: `${prefix} ${fixWidth(stat.name, 22)} ${fixWidth("[" + stat.shortcut + "]", 10)} ${fixWidth(stat.triggerCharacters.join(""), 10)} ${fixWidth(stat.priority.toString(), 3)} ${stat.filetypes.join(",")}`,
            location,
            data: { name: stat.name }
          };
        });
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocSourcesPrefix /\\v^./ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesName /\\v%3c\\S+/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesType /\\v%25v.*%36v/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesPriority /\\v%46v.*%52v/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesFileTypes /\\v\\S+$/ contained containedin=CocSourcesLine", true);
        nvim.command("highlight default link CocSourcesPrefix Special", true);
        nvim.command("highlight default link CocSourcesName Type", true);
        nvim.command("highlight default link CocSourcesPriority Number", true);
        nvim.command("highlight default link CocSourcesFileTypes Comment", true);
        nvim.command("highlight default link CocSourcesType Statement", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/symbols.ts
function toTargetLocation(location) {
  if (!Location.is(location)) {
    return Location.create(location.uri, Range.create(0, 0, 0, 0));
  }
  let loc = Location.create(location.uri, Range.create(location.range.start, location.range.start));
  loc.targetRange = location.range;
  return loc;
}
function sortSymbolItems(a, b) {
  if (a.data.score != b.data.score) {
    return b.data.score - a.data.score;
  }
  if (a.data.kind != b.data.kind) {
    return a.data.kind - b.data.kind;
  }
  return a.data.file.length - b.data.file.length;
}
var Symbols;
var init_symbols = __esm({
  "src/list/source/symbols.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_array();
    init_convert();
    init_node();
    init_protocol();
    init_string();
    init_workspace();
    init_formatting();
    init_location();
    Symbols = class extends LocationList {
      constructor() {
        super(...arguments);
        this.interactive = true;
        this.description = "search workspace symbols";
        this.detail = "Symbols list is provided by server, it works on interactive mode only.";
        this.fuzzyMatch = workspace_default.createFuzzyMatch();
        this.name = "symbols";
        this.options = [{
          name: "-k, -kind KIND",
          description: "Filter symbols by kind.",
          hasValue: true
        }];
      }
      async loadItems(context, token) {
        let { input } = context;
        let args = this.parseArguments(context.args);
        let filterKind = args.kind ? args.kind.toString().toLowerCase() : "";
        if (!languages_default.hasProvider("workspaceSymbols" /* WorkspaceSymbols */, { uri: "file:///1", languageId: "" })) {
          throw new Error("No workspace symbols provider registered");
        }
        let symbols = await languages_default.getWorkspaceSymbols(input, token);
        if (token.isCancellationRequested) return [];
        let config = this.getConfig();
        let excludes = config.get("excludes", []);
        let items = [];
        this.fuzzyMatch.setPattern(input, true);
        for (let s of symbols) {
          let kind = getSymbolKind(s.kind);
          if (filterKind && kind.toLowerCase() != filterKind) {
            continue;
          }
          let file = formatUri(s.location.uri, workspace_default.cwd);
          if (excludes.some((p) => minimatch(file, p))) {
            continue;
          }
          let item = this.createListItem(input, s, kind, file);
          items.push(item);
        }
        this.fuzzyMatch.free();
        items.sort(sortSymbolItems);
        return items;
      }
      async resolveItem(item) {
        let symbolItem = item.data.original;
        if (!symbolItem || Location.is(symbolItem.location)) return null;
        let tokenSource = new import_node4.CancellationTokenSource();
        let resolved = await languages_default.resolveWorkspaceSymbol(symbolItem, tokenSource.token);
        if (!resolved) return null;
        if (Location.is(resolved.location)) {
          symbolItem.location = resolved.location;
          item.location = toTargetLocation(resolved.location);
        }
        return item;
      }
      createListItem(input, item, kind, file) {
        let { name: name2 } = item;
        let label = "";
        let ansiHighlights = [];
        let parts = [name2, `[${kind}]`, this.formatFilepath(file)];
        let highlights = ["Normal", "Typedef", "Comment"];
        for (let index = 0; index < parts.length; index++) {
          const text = parts[index];
          let start = byteLength(label);
          label += text;
          let end = byteLength(label);
          if (index != parts.length - 1) {
            label += " ";
          }
          ansiHighlights.push({ span: [start, end], hlGroup: highlights[index] });
          if (index === 0 && toArray(item.tags).includes(SymbolTag.Deprecated) || item["deprecated"]) {
            ansiHighlights.push({ span: [start, end], hlGroup: "CocDeprecatedHighlight" });
          }
        }
        let score3 = 0;
        if (input.length > 0) {
          let result = this.fuzzyMatch.matchHighlights(name2, "CocListSearch");
          if (result) {
            score3 = result.score;
            ansiHighlights.push(...result.highlights);
          }
        }
        return {
          label,
          filterText: "",
          ansiHighlights,
          location: toTargetLocation(item.location),
          data: {
            original: item,
            input,
            kind: item.kind,
            file,
            score: score3
          }
        };
      }
    };
  }
});

// src/list/manager.ts
function createConfigurationNode(name2, interactive, id2) {
  let properties = {};
  properties[`list.source.${name2}.defaultAction`] = {
    type: "string",
    default: null,
    description: `Default action of "${name2}" list.`
  };
  properties[`list.source.${name2}.defaultOptions`] = {
    type: "array",
    default: interactive ? ["--interactive"] : [],
    description: `Default list options of "${name2}" list, only used when both list option and argument are empty.`,
    uniqueItems: true,
    items: {
      type: "string",
      enum: [
        "--top",
        "--normal",
        "--no-sort",
        "--input",
        "--height",
        "--tab",
        "--strict",
        "--regex",
        "--ignore-case",
        "--number-select",
        "--reverse",
        "--interactive",
        "--auto-preview",
        "--first",
        "--no-quit"
      ]
    }
  };
  properties[`list.source.${name2}.defaultArgs`] = {
    type: "array",
    default: [],
    description: `Default argument list of "${name2}" list, only used when list argument is empty.`,
    uniqueItems: true,
    items: { type: "string" }
  };
  let node = {
    scope: 1 /* APPLICATION */,
    properties
  };
  if (id2) node.extensionInfo = { id: id2 };
  return node;
}
var logger37, mouseKeys, winleaveDalay, ListManager, manager_default2;
var init_manager3 = __esm({
  "src/list/manager.ts"() {
    "use strict";
    init_registry2();
    init_types();
    init_events();
    init_extension();
    init_logger();
    init_util();
    init_constants();
    init_errors();
    init_extensionRegistry();
    init_node();
    init_protocol();
    init_registry();
    init_string();
    init_window();
    init_workspace();
    init_configuration3();
    init_history();
    init_mappings();
    init_prompt();
    init_session();
    init_commands2();
    init_diagnostics();
    init_extensions();
    init_folders();
    init_links();
    init_lists();
    init_location();
    init_outline();
    init_services2();
    init_sources();
    init_symbols();
    logger37 = createLogger("list-manager");
    mouseKeys = ["<LeftMouse>", "<LeftDrag>", "<LeftRelease>", "<2-LeftMouse>"];
    winleaveDalay = isVim ? 50 : 0;
    ListManager = class {
      constructor() {
        this.plugTs = 0;
        this.sessionsMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.listMap = /* @__PURE__ */ new Map();
        InputHistory.migrate(dataHome);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      init(nvim) {
        this.prompt = new Prompt(nvim);
        this.mappings = new Mappings(this, nvim);
        let signText = configuration_default.get("selectedSignText", "*");
        nvim.command(`sign define CocSelected text=${signText} texthl=CocSelectedText linehl=CocSelectedLine`, true);
        events_default.on("InputChar", this.onInputChar, this, this.disposables);
        events_default.on("FocusGained", async () => {
          let session = await this.getCurrentSession();
          if (session) this.prompt.drawPrompt();
        }, null, this.disposables);
        events_default.on("WinEnter", (winid) => {
          let session = this.getSessionByWinid(winid);
          if (session) this.prompt.start(session.listOptions);
        }, null, this.disposables);
        let timer;
        events_default.on("WinLeave", (winid) => {
          clearTimeout(timer);
          let session = this.getSessionByWinid(winid);
          if (session) {
            timer = setTimeout(() => {
              this.prompt.cancel();
            }, winleaveDalay);
          }
        }, null, this.disposables);
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.source !== 0 /* Default */ && e.affectsConfiguration("list")) {
            this.mappings.createMappings();
          }
        }, null, this.disposables);
        this.prompt.onDidChangeInput(() => {
          this.session?.onInputChange();
        });
      }
      registerLists() {
        this.registerList(new LinksList(), true);
        this.registerList(new LocationList(), true);
        this.registerList(new Symbols(), true);
        this.registerList(new Outline(), true);
        this.registerList(new CommandsList(), true);
        this.registerList(new ExtensionList(extension_default.manager), true);
        this.registerList(new DiagnosticsList(this), true);
        this.registerList(new SourcesList(), true);
        this.registerList(new ServicesList(), true);
        this.registerList(new ListsList(this.listMap), true);
        this.registerList(new FoldList(), true);
      }
      async start(args) {
        let res = this.parseArgs(args);
        if (!res) return;
        let { name: name2 } = res.list;
        let curr = this.sessionsMap.get(name2);
        if (curr) curr.dispose();
        this.prompt.start(res.options);
        let session = new ListSession(this.nvim, this.prompt, res.list, res.options, res.listArgs);
        this.sessionsMap.set(name2, session);
        this.lastSession = session;
        try {
          await session.start(args);
        } catch (e) {
          this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
          this.nvim.command(`echo ""`, true);
          if (isCancellationError(e)) return;
          void window_default.showErrorMessage(`Error on "CocList ${name2}": ${toErrorText(e)}`);
          this.nvim.redrawVim();
          logger37.error(`Error on load ${name2} list:`, e);
        }
      }
      getSessionByWinid(winid) {
        for (let session of this.sessionsMap.values()) {
          if (session && session.winid == winid) {
            this.lastSession = session;
            return session;
          }
        }
        return null;
      }
      async getCurrentSession() {
        let { id: id2 } = await this.nvim.window;
        for (let session of this.sessionsMap.values()) {
          if (session && session.winid == id2) {
            this.lastSession = session;
            return session;
          }
        }
        return null;
      }
      async resume(name2) {
        if (!name2) {
          await this.session?.resume();
        } else {
          let session = this.sessionsMap.get(name2);
          if (!session) {
            void window_default.showWarningMessage(`Can't find exists ${name2} list`);
            return;
          }
          this.lastSession = session;
          await session.resume();
        }
      }
      async doAction(name2) {
        let lastSession = this.lastSession;
        if (!lastSession) return;
        await lastSession.doAction(name2);
      }
      async first(name2) {
        let s = this.getSession(name2);
        if (s) await s.first();
      }
      async last(name2) {
        let s = this.getSession(name2);
        if (s) await s.last();
      }
      async previous(name2) {
        let s = this.getSession(name2);
        if (s) await s.previous();
      }
      async next(name2) {
        let s = this.getSession(name2);
        if (s) await s.next();
      }
      getSession(name2) {
        if (!name2) return this.session;
        return this.sessionsMap.get(name2);
      }
      async cancel(close = true) {
        this.prompt.cancel();
        if (!close) return;
        if (this.session) await this.session.hide();
      }
      /**
       * Clear all list sessions
       */
      reset() {
        this.prompt.cancel();
        this.lastSession = void 0;
        for (let session of this.sessionsMap.values()) {
          session.dispose();
        }
        this.sessionsMap.clear();
        this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
      }
      async switchMatcher() {
        await this.session?.switchMatcher();
      }
      async togglePreview() {
        let { nvim } = this;
        let winid = await nvim.call("coc#list#get_preview", [0]);
        if (winid != -1) {
          await nvim.call("coc#list#close_preview", []);
          await nvim.command("redraw");
        } else {
          await this.doAction("preview");
        }
      }
      async chooseAction() {
        let { lastSession } = this;
        if (lastSession) await lastSession.chooseAction();
      }
      parseArgs(args) {
        let options2 = [];
        let interactive = false;
        let autoPreview = false;
        let numberSelect = false;
        let noQuit = false;
        let first = false;
        let reverse = false;
        let name2;
        let input = "";
        let matcher = "fuzzy";
        let position = "bottom";
        let listArgs = [];
        let listOptions = [];
        let height;
        for (let arg of args) {
          if (!name2 && arg.startsWith("-")) {
            listOptions.push(arg);
          } else if (!name2) {
            if (!/^\w+$/.test(arg)) {
              void window_default.showErrorMessage(`Invalid list option: "${arg}"`);
              return null;
            }
            name2 = arg;
          } else {
            listArgs.push(arg);
          }
        }
        name2 = name2 || "lists";
        let config = workspace_default.initialConfiguration.get(`list.source.${name2}`);
        if (!listOptions.length && !listArgs.length) listOptions = defaultValue(config?.defaultOptions, []);
        if (!listArgs.length) listArgs = defaultValue(config?.defaultArgs, []);
        for (let opt of listOptions) {
          if (opt.startsWith("--input=")) {
            input = opt.slice(8);
          } else if (opt.startsWith("--height=")) {
            height = toInteger(opt.slice(9));
          } else if (opt == "--number-select" || opt == "-N") {
            numberSelect = true;
          } else if (opt == "--auto-preview" || opt == "-A") {
            autoPreview = true;
          } else if (opt == "--regex" || opt == "-R") {
            matcher = "regex";
          } else if (opt == "--strict" || opt == "-S") {
            matcher = "strict";
          } else if (opt == "--interactive" || opt == "-I") {
            interactive = true;
          } else if (opt == "--top") {
            position = "top";
          } else if (opt == "--tab") {
            position = "tab";
          } else if (opt == "--ignore-case" || opt == "--normal" || opt == "--no-sort") {
            options2.push(opt.slice(2));
          } else if (opt == "--first") {
            first = true;
          } else if (opt == "--reverse") {
            reverse = true;
          } else if (opt == "--no-quit") {
            noQuit = true;
          } else {
            void window_default.showErrorMessage(`Invalid option "${opt}" of list`);
            return null;
          }
        }
        let list2 = this.listMap.get(name2);
        if (!list2) {
          void window_default.showErrorMessage(`List ${name2} not found`);
          return null;
        }
        if (interactive && !list2.interactive) {
          void window_default.showErrorMessage(`Interactive mode of "${name2}" list not supported`);
          return null;
        }
        return {
          list: list2,
          listArgs,
          options: {
            numberSelect,
            autoPreview,
            height,
            reverse,
            noQuit,
            first,
            input,
            interactive,
            matcher,
            position,
            ignorecase: options2.includes("ignore-case") ? true : false,
            mode: !options2.includes("normal") ? "insert" : "normal",
            sort: !options2.includes("no-sort") ? true : false
          }
        };
      }
      async onInputChar(session, ch, charmod) {
        if (!ch || session != "list") return;
        let { mode } = this.prompt;
        let now = Date.now();
        if (ch == "<plug>" || this.plugTs && now - this.plugTs < 20) {
          this.plugTs = now;
          return;
        }
        if (ch == "<esc>") {
          await this.cancel();
          return;
        }
        if (mode == "insert") {
          await this.onInsertInput(ch, charmod);
        } else {
          await this.onNormalInput(ch, charmod);
        }
      }
      async onInsertInput(ch, charmod) {
        let { session } = this;
        if (mouseKeys.includes(ch)) {
          await this.onMouseEvent(ch);
          return;
        }
        if (!session) return;
        let n = await session.doNumberSelect(ch);
        if (n) return;
        let done = await this.mappings.doInsertKeymap(ch);
        if (done || charmod) return;
        if (ch.startsWith("<") && ch.endsWith(">")) {
          await this.feedkeys(ch, false);
          return;
        }
        for (let s of ch) {
          let code = s.codePointAt(0);
          if (code == 65533) return;
          if (code < 32 || code >= 127 && code <= 159) return;
          await this.prompt.acceptCharacter(s);
        }
      }
      async onNormalInput(ch, _charmod) {
        if (mouseKeys.includes(ch)) {
          await this.onMouseEvent(ch);
          return;
        }
        let used = await this.mappings.doNormalKeymap(ch);
        if (!used) await this.feedkeys(ch);
      }
      onMouseEvent(key) {
        return this.session?.onMouseEvent(key);
      }
      async feedkeys(key, remap = true) {
        let { nvim } = this;
        key = key.startsWith("<") && key.endsWith(">") ? `\\${key}` : key;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.call("eval", [`feedkeys("${key}", "${remap ? "i" : "in"}")`]);
        this.triggerCursorMoved();
        this.prompt.start();
      }
      async command(command) {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.command(command);
        this.triggerCursorMoved();
        this.prompt.start();
      }
      async normal(command, bang) {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.command(`normal${bang ? "!" : ""} ${command}`);
        this.triggerCursorMoved();
        this.prompt.start();
      }
      triggerCursorMoved() {
        if (this.nvim.isVim) this.nvim.command("doautocmd <nomodeline> CursorMoved", true);
        this.nvim.call("coc#util#do_autocmd", ["CocListMoved"], true);
      }
      async call(fname) {
        if (this.session) return await this.session.call(fname);
      }
      get session() {
        return this.lastSession;
      }
      registerList(list2, internal = false) {
        let { name: name2, interactive } = list2;
        let id2;
        if (!internal) id2 = getConditionValue(parseExtensionName(Error().stack), void 0);
        let removed = this.deregisterList(name2);
        this.listMap.set(name2, list2);
        const configNode = createConfigurationNode(name2, interactive, id2);
        if (!removed) workspace_default.configurations.updateConfigurations([configNode]);
        return import_node4.Disposable.create(() => {
          this.deregisterList(name2);
          const configurationRegistry3 = Registry.as(Extensions3.Configuration);
          configurationRegistry3.deregisterConfigurations([configNode]);
        });
      }
      deregisterList(name2) {
        let exists = this.listMap.get(name2);
        if (exists) {
          if (typeof exists.dispose == "function") {
            exists.dispose();
          }
          this.listMap.delete(name2);
          return true;
        }
        return false;
      }
      get names() {
        return Array.from(this.listMap.keys());
      }
      get descriptions() {
        let d = {};
        for (let name2 of this.listMap.keys()) {
          let list2 = this.listMap.get(name2);
          d[name2] = list2.description;
        }
        return d;
      }
      /**
       * Get items of {name} list
       * @param {string} name
       * @returns {Promise<any>}
       */
      async loadItems(name2) {
        let args = [name2];
        let res = this.parseArgs(args);
        if (!res || !name2) return;
        let { list: list2, options: options2, listArgs } = res;
        let source = new import_node4.CancellationTokenSource();
        let token = source.token;
        let arr = await this.nvim.eval('[win_getid(),bufnr("%")]');
        let items = await list2.loadItems({
          options: options2,
          args: listArgs,
          input: "",
          cwd: workspace_default.cwd,
          window: this.nvim.createWindow(arr[0]),
          buffer: this.nvim.createBuffer(arr[1]),
          listWindow: null
        }, token);
        if (!items || Array.isArray(items)) {
          return items;
        }
        let task = items;
        let newItems = await new Promise((resolve, reject) => {
          let items2 = [];
          task.on("data", (item) => {
            item.label = stripAnsi(item.label);
            items2.push(item);
          });
          task.on("end", () => {
            resolve(items2);
          });
          task.on("error", (msg) => {
            reject(msg instanceof Error ? msg : new Error(msg));
            task.dispose();
          });
        });
        return newItems;
      }
      toggleMode() {
        let lastSession = this.lastSession;
        if (lastSession) lastSession.toggleMode();
      }
      get isActivated() {
        return this.session?.winid != null;
      }
      stop() {
        let lastSession = this.lastSession;
        if (lastSession) lastSession.stop();
      }
      dispose() {
        for (let session of this.sessionsMap.values()) {
          session.dispose();
        }
        this.sessionsMap.clear();
        this.lastSession = void 0;
        disposeAll(this.disposables);
      }
    };
    manager_default2 = new ListManager();
  }
});

// src/snippets/snippet.ts
function getNextPlaceholder(marker, forward, nested = false) {
  if (!marker) return void 0;
  let { snippet } = marker;
  let idx = marker.index;
  if (idx < 0 || !snippet) return void 0;
  let arr = [];
  let min_index;
  let max_index;
  if (idx > 0) {
    snippet.walk((m) => {
      if (m instanceof Placeholder && !m.transform) {
        if (forward && (m.index > idx || m.isFinalTabstop) || !forward && (m.index < idx && !m.isFinalTabstop)) {
          arr.push(m);
          if (!m.isFinalTabstop) {
            min_index = min_index === void 0 ? m.index : Math.min(min_index, m.index);
          }
          max_index = max_index === void 0 ? m.index : Math.max(max_index, m.index);
        }
      }
      return true;
    }, true);
    if (arr.length > 0) {
      arr.sort((a, b) => {
        if (b.primary && !a.primary) return 1;
        if (a.primary && !b.primary) return -1;
        return 0;
      });
      if (forward) return min_index === void 0 ? arr[0] : arr.find((o) => o.index === min_index);
      return arr.find((o) => o.index === max_index);
    }
  }
  if (snippet.parent instanceof Placeholder) {
    return getNextPlaceholder(snippet.parent, forward, true);
  }
  if (nested) return marker;
  return void 0;
}
function getUltiSnipActionCodes(marker, action) {
  if (!marker) return void 0;
  const snip = marker instanceof TextmateSnippet ? marker : marker.snippet;
  if (!snip) return void 0;
  let context = snip.related.context;
  let code = getAction(context, action);
  if (!code) return void 0;
  return [code, getResetPythonCode(context)];
}
var CocSnippet;
var init_snippet = __esm({
  "src/snippets/snippet.ts"() {
    "use strict";
    init_main();
    init_textdocument();
    init_util();
    init_position();
    init_protocol();
    init_eval();
    init_parser3();
    init_util3();
    CocSnippet = class {
      constructor(snippet, position, nvim, resolver2) {
        this.snippet = snippet;
        this.position = position;
        this.nvim = nvim;
        this.resolver = resolver2;
        // placeholders and snippets from top to bottom
        this._markerSeuqence = [];
        this._placeholders = [];
        // from upper to lower
        this._snippets = [];
      }
      get tmSnippet() {
        return this._tmSnippet;
      }
      get snippets() {
        return this._snippets.map((o) => o.marker);
      }
      getSnippet(marker) {
        return marker instanceof TextmateSnippet ? marker : marker.snippet;
      }
      deactivateSnippet(snip) {
        if (!snip) return;
        let marker = snip.parent;
        if (marker) {
          let text = new Text(snip.toString());
          snip.replaceWith(text);
          this.synchronize();
        }
      }
      getUltiSnipOption(marker, key) {
        let snip = this.getSnippet(marker);
        if (!snip) return void 0;
        let context = snip.related.context;
        if (!context) return void 0;
        return context[key];
      }
      async init(ultisnip) {
        if (typeof this.snippet === "string") {
          const parser2 = new SnippetParser(!!ultisnip);
          const snippet = parser2.parse(this.snippet, true);
          this._tmSnippet = snippet;
        } else {
          this._tmSnippet = this.snippet;
        }
        await this.resolve(this._tmSnippet, ultisnip);
        this.synchronize();
      }
      async resolve(snippet, ultisnip) {
        let { resolver: resolver2, nvim } = this;
        if (resolver2) await snippet.resolveVariables(resolver2);
        if (ultisnip) {
          let pyCodes = [];
          snippet.related.context = ultisnip;
          if (ultisnip.noPython !== true) {
            if (snippet.hasPythonBlock) {
              pyCodes = getPyBlockCode(ultisnip);
            } else if (hasPython(ultisnip)) {
              pyCodes = getResetPythonCode(ultisnip);
            }
            if (pyCodes.length > 0) {
              snippet.related.codes = pyCodes;
            }
          }
          await snippet.evalCodeBlocks(nvim, pyCodes);
        }
      }
      getPlaceholderOnJump(current, forward) {
        const p = getNextPlaceholder(current, forward);
        return p ? this.getPlaceholderByMarker(p) : void 0;
      }
      /**
       * Same index and in same snippet only
       */
      getRanges(marker) {
        if (marker.toString().length === 0 || !marker.snippet) return [];
        let tmSnippet = marker.snippet;
        let placeholders = this._placeholders.filter((o) => o.index == marker.index && o.marker.snippet === tmSnippet);
        return placeholders.map((o) => o.range).filter((r) => !emptyRange(r));
      }
      /**
       * Find the most possible marker contains range, throw error when not found
       */
      findParent(range, current) {
        const isInsert = emptyRange(range);
        let marker;
        let markerRange;
        const { _snippets, _placeholders, _markerSeuqence } = this;
        const seq = _markerSeuqence.filter((o) => o !== current);
        if (current && _markerSeuqence.includes(current)) seq.push(current);
        const list2 = seq.map((m) => {
          return m instanceof TextmateSnippet ? _snippets.find((o) => o.marker === m) : _placeholders.find((o) => o.marker === m);
        });
        for (let index = list2.length - 1; index >= 0; index--) {
          const o = list2[index];
          if (rangeInRange(range, o.range)) {
            if (isInsert && o.marker instanceof Placeholder && (o.marker.choice || o.marker.index === 0) && o.marker !== current && adjacentPosition(range.start, o.range)) {
              continue;
            }
            marker = o.marker;
            markerRange = o.range;
            break;
          }
        }
        if (!marker) throw new Error(`Unable to find parent marker in range ${JSON.stringify(range, null, 2)}`);
        return { marker, range: markerRange };
      }
      /**
       * The change must happens with same marker parents, return the changed marker
       */
      replaceWithMarker(range, marker, current) {
        const isInsert = emptyRange(range);
        const result = this.findParent(range, current);
        let parentMarker = result.marker;
        let parentRange = result.range;
        const children = parentMarker.children;
        let pos = parentRange.start;
        let startIdx = 0;
        let deleteCount = 0;
        const { start, end } = range;
        let startMarker;
        let endMarker;
        let preText = "";
        let afterText = "";
        let len = children.length;
        for (let i = 0; i < len; i++) {
          let child = children[i];
          let value = child.toString();
          let s = Position.create(pos.line, pos.character);
          let e = getEnd(s, value);
          let r = Range.create(s, e);
          if (startMarker === void 0 && positionInRange(start, r) === 0 && !samePosition(start, e)) {
            startMarker = child;
            startIdx = i;
            preText = getTextBefore(Range.create(s, e), value, start);
            if (isInsert && samePosition(end, s)) {
              endMarker = child;
              break;
            }
          }
          if (startMarker != null) {
            let val = positionInRange(end, r);
            if (val === 0) {
              endMarker = child;
              afterText = getTextAfter(Range.create(s, e), value, end);
            }
            deleteCount += 1;
          } else if (i == len - 1 && samePosition(start, e)) {
            startIdx = len;
          }
          if (endMarker != null) break;
          pos = e;
        }
        if (marker instanceof Text) {
          let newText = new Text(preText + marker.value + afterText);
          parentMarker.children.splice(startIdx, deleteCount, newText);
          newText.parent = parentMarker;
          mergeTexts(parentMarker, 0);
          if (parentMarker instanceof Placeholder && parentMarker.children[0] instanceof Text) {
            let text = parentMarker.children[0];
            if (text.value.startsWith("\n")) {
              text.replaceWith(new Text(text.value.slice(1)));
              parentMarker.insertBefore("\n");
            }
          }
        } else {
          let markers = [];
          if (preText) markers.push(new Text(preText));
          if (parentMarker instanceof TextmateSnippet) {
            let p = new Placeholder((current ? current.index : 0) + Math.random());
            p.appendChild(marker);
            p.primary = true;
            markers.push(p);
          } else {
            markers.push(marker);
          }
          if (afterText) markers.push(new Text(afterText));
          children.splice(startIdx, deleteCount, ...markers);
          markers.forEach((m) => m.parent = parentMarker);
          if (preText.length > 0 || afterText.length > 0) {
            mergeTexts(parentMarker, 0);
          }
        }
        if (parentMarker instanceof Placeholder && !parentMarker.primary) {
          let first = parentMarker.children[0];
          if (parentMarker.children.length === 1 && first instanceof Text) {
            parentMarker.replaceWith(first);
            return first;
          }
          if (Number.isInteger(parentMarker.index)) {
            parentMarker.index += 0.1;
          }
        }
        return parentMarker;
      }
      /**
       * Replace range with text, return new Cursor position when cursor provided
       *
       * Get new Cursor position for synchronize update only.
       * The cursor position should already adjusted before call this function.
       */
      async replaceWithText(range, text, token, current, cursor) {
        let cloned = this._tmSnippet.clone();
        let marker = this.replaceWithMarker(range, new Text(text), current);
        let snippetText = this._tmSnippet.toString();
        if (marker === this._tmSnippet) {
          this.synchronize();
          return { snippetText, marker };
        }
        let sp = this.getMarkerPosition(marker);
        let changeCharacter = cursor && sp.line === cursor.line;
        const reset = () => {
          this._tmSnippet = cloned;
          this.synchronize();
        };
        token.onCancellationRequested(reset);
        await this.onMarkerUpdate(marker, token);
        if (token.isCancellationRequested) return void 0;
        let ep = this.getMarkerPosition(marker);
        let delta;
        if (cursor && sp && ep) {
          let lc = ep.line - sp.line;
          let cc = changeCharacter ? ep.character - sp.character : 0;
          if (lc != 0 || cc != 0) delta = Position.create(lc, cc);
        }
        return { snippetText, marker, delta };
      }
      async replaceWithSnippet(range, text, current, ultisnip) {
        let snippet = new SnippetParser(!!ultisnip).parse(text, true);
        let marker = this.replaceWithMarker(range, snippet, current);
        await this.resolve(snippet, ultisnip);
        await this.onMarkerUpdate(marker, import_node4.CancellationToken.None);
        return snippet;
      }
      /**
       * Get placeholder or snippet start position in current document
       */
      getMarkerPosition(marker) {
        if (marker instanceof Placeholder) {
          let p = this._placeholders.find((o2) => o2.marker === marker);
          return p ? p.range.start : void 0;
        }
        let o = this._snippets.find((o2) => o2.marker === marker);
        return o ? o.range.start : void 0;
      }
      getSnippetRange(marker) {
        let snip = marker.snippet;
        if (!snip) return void 0;
        let info = this._snippets.find((o) => o.marker === snip);
        return info ? info.range : void 0;
      }
      /**
       * Get TabStops of same snippet.
       */
      getSnippetTabstops(marker) {
        let snip = marker.snippet;
        if (!snip) return [];
        let res = [];
        this._placeholders.forEach((p) => {
          const { start, end } = p.range;
          if (p.marker.snippet === snip && (p.primary || p.index === 0)) {
            res.push({
              index: p.index,
              range: [start.line, start.character, end.line, end.character],
              text: p.value
            });
          }
        });
        return res;
      }
      async onMarkerUpdate(marker, token) {
        let ts = Date.now();
        while (marker != null) {
          if (marker instanceof Placeholder) {
            let snip = marker.snippet;
            if (!snip) break;
            await snip.update(this.nvim, marker, token);
            if (token.isCancellationRequested) return;
            marker = snip.parent;
          } else {
            marker = marker.parent;
          }
        }
        await waitWithToken(Math.max(0, 16 - Date.now() + ts), token);
        if (token.isCancellationRequested) return;
        this.synchronize();
      }
      usePython(snip) {
        return snip.hasCodeBlock || hasPython(snip.related.context);
      }
      get hasPython() {
        for (const info of this._snippets) {
          let snip = info.marker;
          if (this.usePython(snip)) return true;
        }
        return false;
      }
      resetStartPosition(pos) {
        this.position = pos;
        this.synchronize();
      }
      get start() {
        return Position.create(this.position.line, this.position.character);
      }
      get range() {
        let end = getEnd(this.position, this._text);
        return Range.create(this.position, end);
      }
      get text() {
        return this._text;
      }
      get hasBeginningPlaceholder() {
        let { position } = this;
        return this._placeholders.find((o) => o.index !== 0 && comparePosition(o.range.start, position) === 0) != null;
      }
      get hasEndPlaceholder() {
        let position = this._snippets[0].range.end;
        return this._placeholders.find((o) => o.index !== 0 && comparePosition(o.range.end, position) === 0) != null;
      }
      getPlaceholderByMarker(marker) {
        return this._placeholders.find((o) => o.marker === marker);
      }
      getPlaceholderByIndex(index) {
        let filtered = this._placeholders.filter((o) => o.index == index && !o.marker.transform);
        let find = filtered.find((o) => o.primary);
        return defaultValue(find, filtered[0]);
      }
      getPlaceholderById(id2, index) {
        let p = this._tmSnippet.placeholders.find((o) => o.id === id2);
        if (p) return p;
        let placeholder = this.getPlaceholderByIndex(index);
        return placeholder ? placeholder.marker : void 0;
      }
      /**
       * Should be used after snippet resolved.
       */
      synchronize() {
        const snippet = this._tmSnippet;
        const snippetStr = snippet.toString();
        const document2 = new LinesTextDocument("/", "", 0, snippetStr.split(/\n/), 0, false);
        const placeholders = [];
        const snippets = [];
        const markerSeuqence = [];
        const { start } = this;
        snippets.push({ range: Range.create(start, getEnd(start, snippetStr)), marker: snippet, value: snippetStr });
        markerSeuqence.push(snippet);
        let offset = 0;
        snippet.walk((marker) => {
          if (marker instanceof Placeholder && marker.transform == null) {
            markerSeuqence.push(marker);
            const position = document2.positionAt(offset);
            const value = marker.toString();
            placeholders.push({
              index: marker.index,
              value,
              marker,
              range: getNewRange(start, position, value),
              primary: marker.primary === true
            });
          } else if (marker instanceof TextmateSnippet) {
            markerSeuqence.push(marker);
            const position = document2.positionAt(offset);
            const value = marker.toString();
            snippets.push({
              range: getNewRange(start, position, value),
              marker,
              value
            });
          }
          offset += marker.len();
          return true;
        }, false);
        this._snippets = snippets;
        this._text = snippetStr;
        this._placeholders = placeholders;
        this._markerSeuqence = markerSeuqence;
      }
    };
  }
});

// src/snippets/variableResolve.ts
function padZero(n) {
  return n < 10 ? "0" + n : n.toString();
}
function parseComments(comments) {
  let start;
  let end;
  let single;
  let parts = comments.split(",");
  for (let s of parts) {
    if (start && end && single) break;
    if (!s.includes(":")) continue;
    let [flag, str] = s.split(":");
    if (flag.includes("s")) {
      start = str;
    } else if (flag.includes("e")) {
      end = str;
    } else if (!single && flag == "") {
      single = str;
    }
  }
  return { start, end, single };
}
function parseCommentstring(commentstring) {
  if (commentstring.endsWith("%s")) return commentstring.slice(0, -2).trim();
  return void 0;
}
var SnippetVariableResolver;
var init_variableResolve = __esm({
  "src/snippets/variableResolve.ts"() {
    "use strict";
    init_esm_node();
    init_esm();
    init_node();
    init_object();
    SnippetVariableResolver = class {
      constructor(nvim, workspaceFolder) {
        this.nvim = nvim;
        this.workspaceFolder = workspaceFolder;
        this._variableToValue = {};
        const currentDate = /* @__PURE__ */ new Date();
        const fullyear = currentDate.getFullYear().toString();
        Object.assign(this._variableToValue, {
          CURRENT_YEAR: fullyear,
          CURRENT_YEAR_SHORT: fullyear.slice(-2),
          CURRENT_MONTH: padZero(currentDate.getMonth() + 1),
          CURRENT_DATE: padZero(currentDate.getDate()),
          CURRENT_HOUR: padZero(currentDate.getHours()),
          CURRENT_MINUTE: padZero(currentDate.getMinutes()),
          CURRENT_SECOND: padZero(currentDate.getSeconds()),
          CURRENT_DAY_NAME: currentDate.toLocaleString("en-US", { weekday: "long" }),
          CURRENT_DAY_NAME_SHORT: currentDate.toLocaleString("en-US", { weekday: "short" }),
          CURRENT_MONTH_NAME: currentDate.toLocaleString("en-US", { month: "long" }),
          CURRENT_MONTH_NAME_SHORT: currentDate.toLocaleString("en-US", { month: "short" }),
          TM_FILENAME: null,
          TM_FILENAME_BASE: null,
          TM_DIRECTORY: null,
          TM_FILEPATH: null,
          YANK: null,
          TM_LINE_INDEX: null,
          TM_LINE_NUMBER: null,
          TM_CURRENT_LINE: null,
          TM_CURRENT_WORD: null,
          TM_SELECTED_TEXT: null,
          VISUAL: null,
          CLIPBOARD: null,
          RELATIVE_FILEPATH: null,
          RANDOM: null,
          RANDOM_HEX: null,
          UUID: null,
          BLOCK_COMMENT_START: null,
          BLOCK_COMMENT_END: null,
          LINE_COMMENT: null,
          WORKSPACE_NAME: null,
          WORKSPACE_FOLDER: null
        });
      }
      async resolveValue(name2) {
        let { nvim } = this;
        if (["TM_FILENAME", "TM_FILENAME_BASE", "TM_DIRECTORY", "TM_FILEPATH"].includes(name2)) {
          let filepath = await nvim.call("coc#util#get_fullpath");
          if (name2 === "TM_FILENAME") return path.basename(filepath);
          if (name2 === "TM_FILENAME_BASE") return path.basename(filepath, path.extname(filepath));
          if (name2 === "TM_DIRECTORY") return path.dirname(filepath);
          if (name2 === "TM_FILEPATH") return filepath;
        }
        if (name2 === "YANK") {
          return await nvim.call("getreg", ['""']);
        }
        if (name2 === "TM_LINE_INDEX") {
          let lnum = await nvim.call("line", ["."]);
          return (lnum - 1).toString();
        }
        if (name2 === "TM_LINE_NUMBER") {
          let lnum = await nvim.call("line", ["."]);
          return lnum.toString();
        }
        if (name2 === "TM_CURRENT_LINE") {
          return await nvim.call("getline", ["."]);
        }
        if (name2 === "TM_CURRENT_WORD") {
          return await nvim.eval(`expand('<cword>')`);
        }
        if (name2 === "TM_SELECTED_TEXT" || name2 == "VISUAL") {
          return await nvim.eval(`get(g:,'coc_selected_text', v:null)`);
        }
        if (name2 === "CLIPBOARD") {
          return await nvim.eval("@*");
        }
        if (name2 === "RANDOM") {
          return Math.random().toString().slice(-6);
        }
        if (name2 === "RANDOM_HEX") {
          return Math.random().toString(16).slice(-6);
        }
        if (name2 === "UUID") {
          return v4_default();
        }
        if (["RELATIVE_FILEPATH", "WORKSPACE_NAME", "WORKSPACE_FOLDER"].includes(name2)) {
          let filepath = await nvim.call("coc#util#get_fullpath");
          let folder = this.workspaceFolder.getWorkspaceFolder(URI2.file(filepath));
          if (name2 === "RELATIVE_FILEPATH") return this.workspaceFolder.getRelativePath(filepath);
          if (name2 === "WORKSPACE_NAME") return folder.name;
          if (name2 === "WORKSPACE_FOLDER") return URI2.parse(folder.uri).fsPath;
        }
        if (name2 === "LINE_COMMENT") {
          let commentstring = await nvim.eval("&commentstring");
          let s = parseCommentstring(commentstring);
          if (s) return s;
          let comments = await nvim.eval("&comments");
          let { single } = parseComments(comments);
          return single;
        }
        if (["BLOCK_COMMENT_START", "BLOCK_COMMENT_END"].includes(name2)) {
          let comments = await nvim.eval("&comments");
          let { start, end } = parseComments(comments);
          if (name2 === "BLOCK_COMMENT_START") return start;
          if (name2 === "BLOCK_COMMENT_END") return end;
        }
      }
      async resolve(variable) {
        const name2 = variable.name;
        let resolved = this._variableToValue[name2];
        if (resolved != null) return resolved.toString();
        if (hasOwnProperty2(this._variableToValue, name2)) {
          let value = await this.resolveValue(name2);
          if (!value && variable.children.length) {
            return variable.toString();
          }
          return value == null ? "" : value.toString();
        }
        if (variable.children.length) return variable.toString();
        return void 0;
      }
    };
  }
});

// src/snippets/session.ts
var logger38, NAME_SPACE2, SnippetSession;
var init_session2 = __esm({
  "src/snippets/session.ts"() {
    "use strict";
    init_main();
    init_events();
    init_logger();
    init_util();
    init_diff();
    init_errors();
    init_lodash();
    init_mutex();
    init_object();
    init_position();
    init_protocol();
    init_string();
    init_textedit();
    init_window();
    init_workspace();
    init_eval();
    init_parser3();
    init_snippet();
    init_util3();
    init_variableResolve();
    logger38 = createLogger("snippets-session");
    NAME_SPACE2 = "snippets";
    SnippetSession = class {
      constructor(nvim, document2, config) {
        this.nvim = nvim;
        this.document = document2;
        this.config = config;
        this.mutex = new Mutex();
        this._applying = false;
        this._paused = false;
        this.snippet = null;
        this._onActiveChange = new import_node4.Emitter();
        this._selected = false;
        this.onActiveChange = this._onActiveChange.event;
      }
      get selected() {
        return this._selected;
      }
      async insertSnippetEdits(edits) {
        if (edits.length === 0) return this.isActive;
        if (edits.length === 1) return await this.start(toSnippetString(edits[0].snippet), edits[0].range, false);
        const textDocument = this.document.textDocument;
        const textEdits = filterSortEdits(textDocument, edits.map((e) => TextEdit.replace(e.range, toSnippetString(e.snippet))));
        const len = textEdits.length;
        const snip = new TextmateSnippet();
        for (let i = 0; i < len; i++) {
          let range = textEdits[i].range;
          let placeholder = new Placeholder(i + 1);
          placeholder.appendChild(new Text(textDocument.getText(range)));
          snip.appendChild(placeholder);
          if (i != len - 1) {
            let r = Range.create(range.end, textEdits[i + 1].range.start);
            snip.appendChild(new Text(textDocument.getText(r)));
          }
        }
        this.deactivate();
        const resolver2 = new SnippetVariableResolver(this.nvim, workspace_default.workspaceFolderControl);
        let snippet = new CocSnippet(snip, textEdits[0].range.start, this.nvim, resolver2);
        await snippet.init();
        this.activate(snippet);
        for (let i = len - 1; i >= 0; i--) {
          let idx = i + 1;
          this.current = snip.placeholders.find((o) => o.index === idx);
          let edit2 = textEdits[i];
          await this.start(edit2.newText, edit2.range, false);
        }
        return this.isActive;
      }
      async start(inserted, range, select = true, context) {
        let { document: document2, snippet } = this;
        this._paused = false;
        const edits = [];
        let textmateSnippet;
        if (inserted.length === 0) return this.isActive;
        if (snippet && rangeInRange(range, snippet.range)) {
          let oldRange = snippet.range;
          let previous = snippet.text;
          textmateSnippet = await this.snippet.replaceWithSnippet(range, inserted, this.current, context);
          let edit2 = reduceTextEdit({
            range: oldRange,
            newText: this.snippet.text
          }, previous);
          edits.push(edit2);
        } else {
          this.deactivate();
          const resolver2 = new SnippetVariableResolver(this.nvim, workspace_default.workspaceFolderControl);
          snippet = new CocSnippet(inserted, range.start, this.nvim, resolver2);
          await snippet.init(context);
          textmateSnippet = snippet.tmSnippet;
          edits.push(TextEdit.replace(range, snippet.text));
          if (inserted.replace(/\$0$/, "").endsWith("\n")) {
            const currentLine = document2.getline(range.start.line);
            const remain = currentLine.slice(range.end.character);
            if (remain.length) {
              let s = range.end.character;
              let l = remain.match(/^\s*/)[0].length;
              let r = Range.create(range.end.line, s, range.end.line, s + l);
              edits.push(TextEdit.replace(r, currentLine.match(/^\s*/)[0]));
            }
          }
        }
        this.current = textmateSnippet.first;
        this.nvim.call("coc#compat#del_var", ["coc_selected_text"], true);
        await this.applyEdits(edits);
        this.activate(snippet);
        if (context) await this.tryPostExpand(textmateSnippet);
        let { placeholder } = this;
        if (select && placeholder) await this.selectPlaceholder(placeholder, true);
        return this.isActive;
      }
      async tryPostExpand(textmateSnippet) {
        let result = getUltiSnipActionCodes(textmateSnippet, "postExpand");
        if (!result) return;
        const { start, end } = this.snippet.range;
        const [code, resetCodes] = result;
        let pos = `[${start.line},${start.character},${end.line},${end.character}]`;
        let codes = [...resetCodes, `snip = coc_ultisnips_dict["PostExpandContext"](${pos})`, code];
        this.cancel();
        await executePythonCode(this.nvim, codes);
        await this.forceSynchronize();
      }
      async tryPostJump(code, resetCodes, info, bufnr) {
        await waitNextTick();
        this.nvim.setVar("coc_ultisnips_tabstops", info.tabstops, true);
        const { snippet_start, snippet_end } = info;
        let pos = `[${snippet_start.line},${snippet_start.character},${snippet_end.line},${snippet_end.character}]`;
        let codes = [...resetCodes, `snip = coc_ultisnips_dict["PostJumpContext"](${pos},${info.index},${info.forward ? 1 : 0})`, code];
        this.cancel();
        await executePythonCode(this.nvim, codes);
        await this.forceSynchronize();
        void events_default.fire("PlaceholderJump", [bufnr, info]);
      }
      async removeWhiteSpaceBefore(placeholder) {
        if (!emptyRange(placeholder.range)) return;
        let pos = placeholder.range.start;
        let line = this.document.getline(pos.line);
        let ms = line.match(/\s+$/);
        if (ms && line.length === pos.character) {
          let startCharacter = pos.character - ms[0].length;
          let textEdit = TextEdit.del(Range.create(pos.line, startCharacter, pos.line, pos.character));
          await this.document.applyEdits([textEdit]);
          await this.forceSynchronize();
        }
      }
      async applyEdits(edits, joinundo = false) {
        let { document: document2 } = this;
        this._applying = true;
        await document2.applyEdits(edits, joinundo);
        this._applying = false;
        this.textDocument = document2.textDocument;
      }
      async nextPlaceholder() {
        await this.forceSynchronize();
        if (!this.current) return;
        let marker = this.current;
        if (this.snippet.getUltiSnipOption(marker, "removeWhiteSpace")) {
          let { placeholder } = this;
          if (placeholder) await this.removeWhiteSpaceBefore(placeholder);
        }
        const p = this.snippet.getPlaceholderOnJump(marker, true);
        await this.selectPlaceholder(p, true);
      }
      async previousPlaceholder() {
        await this.forceSynchronize();
        if (!this.current) return;
        const p = this.snippet.getPlaceholderOnJump(this.current, false);
        await this.selectPlaceholder(p, true, false);
      }
      async selectCurrentPlaceholder(triggerAutocmd = true) {
        await this.forceSynchronize();
        let { placeholder } = this;
        if (placeholder) await this.selectPlaceholder(placeholder, triggerAutocmd);
      }
      async selectPlaceholder(placeholder, triggerAutocmd = true, forward = true) {
        let { nvim, document: document2 } = this;
        if (!document2 || !placeholder) return;
        this._selected = true;
        let { start, end } = placeholder.range;
        const line = document2.getline(start.line);
        const marker = this.current = placeholder.marker;
        const range = this.snippet.getSnippetRange(marker);
        const tabstops = this.snippet.getSnippetTabstops(marker);
        if (marker instanceof Placeholder && marker.choice && marker.choice.options.length) {
          const col = byteIndex(line, start.character) + 1;
          wordsSource.words = marker.choice.options.map((o) => o.value);
          wordsSource.startcol = col - 1;
          nvim.call("coc#snippet#show_choices", [start.line + 1, col, end, placeholder.value], true);
        } else {
          await this.select(placeholder);
          this.highlights();
        }
        if (triggerAutocmd) nvim.call("coc#util#do_autocmd", ["CocJumpPlaceholder"], true);
        let info = {
          forward,
          tabstops,
          snippet_start: range.start,
          snippet_end: range.end,
          index: placeholder.index,
          range: placeholder.range,
          charbefore: start.character == 0 ? "" : line.slice(start.character - 1, start.character)
        };
        let result = getUltiSnipActionCodes(marker, "postJump");
        if (result) {
          this.tryPostJump(result[0], result[1], info, document2.bufnr).catch(onUnexpectedError);
        } else {
          void events_default.fire("PlaceholderJump", [document2.bufnr, info]);
        }
        this.checkFinalPlaceholder();
      }
      checkFinalPlaceholder() {
        let current = this.current;
        if (current && current.index === 0) {
          const { snippet } = current;
          if (snippet === this.snippet.tmSnippet) {
            logger38.info("Jump to final placeholder, cancelling snippet session");
            this.deactivate();
          } else {
            let marker = snippet.parent;
            this.snippet.deactivateSnippet(snippet);
            if (marker instanceof Placeholder) {
              this.current = marker;
            }
          }
        }
      }
      highlights() {
        let { current, config } = this;
        if (!current || !config.highlight || events_default.bufnr !== this.bufnr) return;
        let buf = this.document.buffer;
        this.nvim.pauseNotification();
        buf.clearNamespace(NAME_SPACE2);
        let ranges = this.snippet.getRanges(current);
        buf.highlightRanges(NAME_SPACE2, "CocSnippetVisual", ranges);
        this.nvim.resumeNotification(true, true);
      }
      async select(placeholder) {
        let { range, value } = placeholder;
        let { nvim } = this;
        if (value.length > 0) {
          await nvim.call("coc#snippet#select", [range.start, range.end, value]);
        } else {
          await nvim.call("coc#snippet#move", [range.start]);
        }
        nvim.redrawVim();
      }
      async checkPosition() {
        if (!this.isActive) return;
        let position = await window_default.getCursorPosition();
        if (this.snippet && positionInRange(position, this.snippet.range) != 0) {
          logger38.info("Cursor insert out of range, cancelling snippet session");
          this.deactivate();
        }
      }
      onTextChange() {
        this.cancel();
      }
      onChange(e) {
        if (this._applying || !this.isActive || this._paused) return;
        let changes = e.contentChanges;
        this.cancel();
        this.synchronize({ version: e.textDocument.version, change: changes[0] }).catch(onUnexpectedError);
      }
      async synchronize(change) {
        const { document: document2, isActive } = this;
        this._paused = false;
        if (!isActive) return;
        await this.mutex.use(() => {
          if (!document2.attached || document2.dirty || !this.snippet || !this.textDocument || document2.version === this.version) return Promise.resolve();
          if (change && (change.version - this.version !== 1 || document2.version != change.version)) {
            change = void 0;
          }
          return this._synchronize(change);
        });
      }
      async _synchronize(documentChange) {
        let { document: document2, textDocument, current, snippet } = this;
        const newDocument = document2.textDocument;
        if (equals(textDocument.lines, newDocument.lines)) {
          this.textDocument = newDocument;
          return;
        }
        const startTs = Date.now();
        let tokenSource = this.tokenSource = new import_node4.CancellationTokenSource();
        const cursor = events_default.bufnr == document2.bufnr ? await window_default.getCursorPosition() : void 0;
        if (tokenSource.token.isCancellationRequested) return;
        let change = documentChange?.change;
        if (!change) {
          let edit2 = getTextEdit(textDocument.lines, newDocument.lines, cursor, events_default.insertMode);
          change = { range: edit2.range, text: edit2.newText };
        }
        const { range, start } = snippet;
        let c = comparePosition(change.range.start, range.end);
        let insertEnd = emptyRange(change.range) && snippet.hasEndPlaceholder;
        if (c > 0 || c === 0 && !insertEnd) {
          logger38.info("Content change after snippet");
          this.textDocument = newDocument;
          return;
        }
        c = comparePosition(change.range.end, range.start);
        let insertBeginning = emptyRange(change.range) && !change.text.endsWith("\n") && snippet.hasBeginningPlaceholder;
        if (c < 0 || c === 0 && !insertBeginning) {
          let changeEnd = change.range.end;
          let checkCharacter = range.start.line === changeEnd.line;
          let newLines = change.text.split(/\n/);
          let lc = newLines.length - (change.range.start.line - changeEnd.line + 1);
          let cc = 0;
          if (checkCharacter) {
            if (newLines.length > 1) {
              cc = newLines[newLines.length - 1].length - changeEnd.character;
            } else {
              cc = change.range.start.character + change.text.length - changeEnd.character;
            }
          }
          this.snippet.resetStartPosition(Position.create(start.line + lc, start.character + cc));
          this.textDocument = newDocument;
          logger38.info("Content change before snippet, reset snippet position");
          return;
        }
        if (!rangeInRange(change.range, range)) {
          logger38.info("Before and snippet body changed, cancel snippet session");
          this.deactivate();
          return;
        }
        const nextPlaceholder = getNextPlaceholder(current, true);
        const id2 = getPlaceholderId(current);
        const res = await this.snippet.replaceWithText(change.range, change.text, tokenSource.token, current, cursor);
        this.tokenSource = void 0;
        if (!res) {
          if (this.snippet) {
            let marker = this.snippet.getPlaceholderById(id2, current.index);
            this.current = defaultValue(marker, this.snippet.tmSnippet.first);
          }
          return;
        }
        this.textDocument = newDocument;
        let { snippetText, delta } = res;
        let changedRange = Range.create(start, getEnd(start, snippetText));
        const expected = newDocument.getText(changedRange);
        if (expected !== snippetText) {
          logger38.error(`Something went wrong with the snippet implementation`, change, snippetText, expected);
          this.deactivate();
          return;
        }
        let newText = this.snippet.text;
        if (newText !== snippetText) {
          let edit2 = reduceTextEdit({ range: changedRange, newText }, snippetText);
          await this.applyEdits([edit2], true);
          if (delta) {
            this.nvim.call(`coc#cursor#move_to`, [cursor.line + delta.line, cursor.character + delta.character], true);
          }
        }
        this.highlights();
        logger38.debug("update cost:", Date.now() - startTs, res.delta);
        this.trySelectNextOnDelete(current, nextPlaceholder).catch(onUnexpectedError);
        return;
      }
      async trySelectNextOnDelete(curr, next) {
        if (!this.config.nextOnDelete || !this.snippet || !curr || curr.snippet != null && curr.toString() != "" || !next) return;
        let p = this.snippet.getPlaceholderByMarker(next);
        if (p) await this.selectPlaceholder(p, true);
      }
      async forceSynchronize() {
        if (this.isActive) {
          this._paused = false;
          await this.document.patchChange();
          await this.synchronize();
        } else {
          await this.document.patchChange();
        }
      }
      async onCompleteDone() {
        if (this.isActive) {
          this._paused = false;
          this.document._forceSync();
          await this.synchronize();
        }
      }
      get version() {
        return this.textDocument ? this.textDocument.version : -1;
      }
      get isActive() {
        return this.snippet != null;
      }
      get bufnr() {
        return this.document.bufnr;
      }
      activate(snippet) {
        if (this.isActive) return;
        this.snippet = snippet;
        this.nvim.call("coc#snippet#enable", [this.bufnr, this.config.preferComplete ? 1 : 0], true);
        this._onActiveChange.fire(true);
      }
      deactivate() {
        this.cancel();
        if (!this.isActive) return;
        this.snippet = null;
        this.current = null;
        this.nvim.call("coc#snippet#disable", [this.bufnr], true);
        if (this.config.highlight) this.nvim.call("coc#highlight#clear_highlight", [this.bufnr, NAME_SPACE2, 0, -1], true);
        this._onActiveChange.fire(false);
        logger38.debug(`session ${this.bufnr} deactivate`);
      }
      get placeholder() {
        if (!this.snippet || !this.current) return void 0;
        return this.snippet.getPlaceholderByMarker(this.current);
      }
      cancel(pause = false) {
        if (!this.isActive) return;
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource.dispose();
          this.tokenSource = null;
        }
        if (pause) this._paused = true;
      }
      dispose() {
        this.cancel();
        this._onActiveChange.dispose();
        this.snippet = null;
        this.current = null;
        this.textDocument = void 0;
      }
      async resolveSnippet(nvim, snippetString, ultisnip) {
        let context;
        if (ultisnip) {
          ultisnip = omit(ultisnip, ["actions"]);
          context = Object.assign({
            range: Range.create(0, 0, 0, 0),
            line: ""
          }, ultisnip, { id: generateContextId(events_default.bufnr) });
          if (ultisnip.noPython !== true && snippetString.includes("`!p")) {
            await executePythonCode(nvim, getInitialPythonCode(context));
          }
        }
        const resolver2 = new SnippetVariableResolver(nvim, workspace_default.workspaceFolderControl);
        const snippet = new CocSnippet(snippetString, Position.create(0, 0), nvim, resolver2);
        await snippet.init(context);
        return snippet.text;
      }
    };
  }
});

// src/snippets/manager.ts
var SnippetManager, manager_default3;
var init_manager4 = __esm({
  "src/snippets/manager.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_events();
    init_util();
    init_object();
    init_position();
    init_window();
    init_workspace();
    init_eval();
    init_session2();
    init_util3();
    SnippetManager = class {
      constructor() {
        this.disposables = [];
      }
      init() {
        this.synchronizeConfig();
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("snippet") || e.affectsConfiguration("suggest")) {
            this.synchronizeConfig();
          }
        }, null, this.disposables);
        events_default.on(["InsertCharPre", "Enter"], () => {
          let session = this.session;
          if (session) session.cancel();
        }, null, this.disposables);
        events_default.on("CompleteDone", async (_item, _line, bufnr) => {
          let session = this.bufferSync.getItem(bufnr);
          if (session) await session.onCompleteDone();
        }, null, this.disposables);
        events_default.on("CompleteStart", async (opt) => {
          let session = this.bufferSync.getItem(opt.bufnr);
          if (session) session.cancel(true);
        }, null, this.disposables);
        events_default.on("InsertEnter", async (bufnr) => {
          let session = this.bufferSync.getItem(bufnr);
          if (session) await session.checkPosition();
        }, null, this.disposables);
        this.bufferSync = workspace_default.registerBufferSync((doc) => {
          let session = new SnippetSession(this.nvim, doc, this.config);
          session.onActiveChange((isActive) => {
            if (events_default.bufnr !== session.bufnr) return;
            this.statusItem[isActive ? "show" : "hide"]();
          });
          return session;
        });
        this.disposables.push(this.bufferSync);
        window_default.onDidChangeActiveTextEditor(async (e) => {
          let session = this.bufferSync.getItem(e.bufnr);
          if (session && session.isActive) {
            this.statusItem.show();
            if (!session.selected) {
              await session.selectCurrentPlaceholder();
            }
          } else {
            this.statusItem.hide();
          }
        }, null, this.disposables);
        commands_default.register({
          id: "editor.action.insertSnippet",
          execute: async (edit2, ultisnip) => {
            const opts = ultisnip === true ? {} : ultisnip;
            return await this.insertSnippet(edit2.newText, true, edit2.range, InsertTextMode.adjustIndentation, opts ? opts : void 0);
          }
        }, true);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      get statusItem() {
        if (this._statusItem) return this._statusItem;
        const snippetConfig = workspace_default.initialConfiguration.get("snippet");
        const statusItem = this._statusItem = window_default.createStatusBarItem(0);
        statusItem.text = defaultValue(snippetConfig.statusText, "");
        return this._statusItem;
      }
      synchronizeConfig() {
        const snippetConfig = workspace_default.getConfiguration("snippet", null);
        const suggest = workspace_default.getConfiguration("suggest", null);
        let obj = {
          highlight: defaultValue(snippetConfig.inspect("highlight").globalValue, false),
          nextOnDelete: defaultValue(snippetConfig.inspect("nextPlaceholderOnDelete").globalValue, false),
          preferComplete: suggest.get("preferCompleteThanJumpPlaceholder", false)
        };
        if (this.config) {
          Object.assign(this.config, obj);
        } else {
          this.config = obj;
        }
      }
      async toRange(range) {
        if (range) return toValidRange(range);
        let pos = await window_default.getCursorPosition();
        return Range.create(pos, pos);
      }
      async insertBufferSnippets(bufnr, edits, select = false) {
        let document2 = workspace_default.getAttachedDocument(bufnr);
        const session = this.bufferSync.getItem(bufnr);
        session.cancel(true);
        let snippetEdit = [];
        for (const edit2 of edits) {
          let currentLine = document2.getline(edit2.range.start.line);
          let inserted = await this.normalizeInsertText(bufnr, toSnippetString(edit2.snippet), currentLine, InsertTextMode.asIs);
          snippetEdit.push({ range: edit2.range, snippet: inserted });
        }
        await session.synchronize();
        let isActive = await session.insertSnippetEdits(edits);
        if (isActive && select && workspace_default.bufnr === bufnr) {
          await session.selectCurrentPlaceholder();
        }
        return isActive;
      }
      /**
       * Insert snippet to specific buffer, ultisnips not supported, and the placeholder is not selected
       */
      async insertBufferSnippet(bufnr, snippet, range, insertTextMode) {
        let document2 = workspace_default.getAttachedDocument(bufnr);
        const session = this.bufferSync.getItem(bufnr);
        session.cancel(true);
        range = toValidRange(range);
        const line = document2.getline(range.start.line);
        const snippetStr = toSnippetString(snippet);
        const inserted = await this.normalizeInsertText(document2.bufnr, snippetStr, line, insertTextMode);
        await session.synchronize();
        return await session.start(inserted, range, false);
      }
      /**
       * Insert snippet at current cursor position
       */
      async insertSnippet(snippet, select = true, range, insertTextMode, ultisnip) {
        let { nvim } = workspace_default;
        let document2 = workspace_default.getAttachedDocument(workspace_default.bufnr);
        const session = this.bufferSync.getItem(document2.bufnr);
        let context;
        session.cancel(true);
        range = await this.toRange(range);
        const currentLine = document2.getline(range.start.line);
        const snippetStr = toSnippetString(snippet);
        const inserted = await this.normalizeInsertText(document2.bufnr, snippetStr, currentLine, insertTextMode, ultisnip);
        if (ultisnip != null) {
          const usePy = hasPython(ultisnip) || inserted.includes("`!p");
          const bufnr = document2.bufnr;
          context = Object.assign({ range: deepClone(range), line: currentLine }, ultisnip, { id: generateContextId(bufnr) });
          if (usePy) {
            if (session.placeholder) {
              let { start, end } = session.placeholder.range;
              let last = {
                current_text: session.placeholder.value,
                start: { line: start.line, col: start.character },
                end: { line: end.line, col: end.character }
              };
              this.nvim.setVar("coc_last_placeholder", last, true);
            } else {
              this.nvim.call("coc#compat#del_var", ["coc_last_placeholder"], true);
            }
            const codes = getInitialPythonCode(context);
            let preExpand = getAction(ultisnip, "preExpand");
            if (preExpand) {
              nvim.call("coc#cursor#move_to", [range.end.line, range.end.character], true);
              await executePythonCode(nvim, codes.concat(['snip = coc_ultisnips_dict["PreExpandContext"]()', preExpand]));
              const [valid, pos] = await nvim.call("pyxeval", "snip.getResult()");
              if (valid) {
                let count = range.end.character - range.start.character;
                range = Range.create(pos[0], Math.max(0, pos[1] - count), pos[0], pos[1]);
              } else {
                range = Range.create(pos[0], pos[1], pos[0], pos[1]);
              }
            } else {
              await executePythonCode(nvim, codes);
            }
          }
        }
        const noMove = ultisnip == null && !session.isActive;
        if (!noMove) {
          const { start } = range;
          nvim.call("coc#cursor#move_to", [start.line, start.character], true);
          if (!emptyRange(range)) {
            await document2.applyEdits([TextEdit.del(range)]);
          }
          if (session.isActive) {
            await session.synchronize();
            let pos = await window_default.getCursorPosition();
            range = Range.create(pos, pos);
          } else {
            range.end = Position.create(start.line, start.character);
          }
        }
        await session.start(inserted, range, select, context);
        return session.isActive;
      }
      async selectCurrentPlaceholder(triggerAutocmd = true) {
        let { session } = this;
        if (session) return await session.selectCurrentPlaceholder(triggerAutocmd);
      }
      async nextPlaceholder() {
        let { session } = this;
        if (session) {
          await session.nextPlaceholder();
        } else {
          this.nvim.call("coc#snippet#disable", [], true);
        }
        return "";
      }
      async previousPlaceholder() {
        let { session } = this;
        if (session) {
          await session.previousPlaceholder();
        } else {
          this.nvim.call("coc#snippet#disable", [], true);
        }
        return "";
      }
      cancel() {
        let session = this.bufferSync.getItem(workspace_default.bufnr);
        if (session) return session.deactivate();
        this.nvim.call("coc#snippet#disable", [], true);
        this.statusItem.hide();
      }
      get session() {
        return this.bufferSync.getItem(workspace_default.bufnr);
      }
      /**
       * exported method
       */
      getSession(bufnr) {
        let session = this.bufferSync.getItem(bufnr);
        return session && session.isActive ? session : void 0;
      }
      isActivated(bufnr) {
        let session = this.bufferSync.getItem(bufnr);
        return session && session.isActive;
      }
      jumpable() {
        let { session } = this;
        if (!session) return false;
        return session.placeholder != null && session.placeholder.index != 0;
      }
      /**
       * Exposed for snippet preview
       */
      async resolveSnippet(snippetString, ultisnip) {
        let session = this.bufferSync.getItem(workspace_default.bufnr);
        if (!session) return;
        return await session.resolveSnippet(this.nvim, snippetString, ultisnip);
      }
      async normalizeInsertText(bufnr, snippetString, currentLine, insertTextMode, ultisnip) {
        let inserted = "";
        if (insertTextMode === InsertTextMode.asIs || !shouldFormat(snippetString)) {
          inserted = snippetString;
        } else {
          const currentIndent = currentLine.match(/^\s*/)[0];
          let formatOptions;
          if (bufnr == window_default.activeTextEditor?.bufnr) {
            formatOptions = window_default.activeTextEditor.options;
          } else {
            formatOptions = await workspace_default.getFormatOptions(bufnr);
          }
          let opts = ultisnip ?? {};
          formatOptions.trimTrailingWhitespace = opts.trimTrailingWhitespace !== false;
          if (opts.noExpand) formatOptions.noExpand = true;
          inserted = normalizeSnippetString(snippetString, currentIndent, formatOptions);
        }
        return inserted;
      }
      dispose() {
        this.cancel();
        disposeAll(this.disposables);
      }
    };
    manager_default3 = new SnippetManager();
  }
});

// src/model/line.ts
var LineBuilder;
var init_line = __esm({
  "src/model/line.ts"() {
    "use strict";
    init_string();
    LineBuilder = class {
      constructor(addSpace = false) {
        this.addSpace = addSpace;
        this._label = "";
        this._len = 0;
        this._highlights = [];
      }
      append(text, hlGroup, nested) {
        if (text.length == 0) return;
        let space = this._len > 0 && this.addSpace ? " " : "";
        let start = this._len + space.length;
        this._label = this._label + space + text;
        this._len = this._len + byteLength(text) + space.length;
        if (hlGroup) {
          this._highlights.push({
            hlGroup,
            span: [start, start + byteLength(text)]
          });
        }
        if (nested) {
          for (let item of nested) {
            let s = start + byteIndex(text, item.offset);
            let e = start + byteIndex(text, item.offset + item.length);
            this._highlights.push({
              hlGroup: item.hlGroup,
              span: [s, e]
            });
          }
        }
      }
      appendBuilder(builder) {
        let space = this._len > 0 && this.addSpace ? " " : "";
        let curr = this._len + space.length;
        this._label = this._label + space + builder.label;
        this._len = this._len + byteLength(builder.label) + space.length;
        this._highlights.push(...builder.highlights.map((item) => {
          return {
            hlGroup: item.hlGroup,
            span: item.span.map((v) => {
              return curr + v;
            })
          };
        }));
      }
      get label() {
        return this._label;
      }
      get highlights() {
        return this._highlights;
      }
    };
  }
});

// src/model/semanticTokensBuilder.ts
function isStringArray(value) {
  return Array.isArray(value) && value.every((elem) => typeof elem === "string");
}
function isStrArrayOrUndefined(arg) {
  return typeof arg === "undefined" || isStringArray(arg);
}
var SemanticTokensBuilder;
var init_semanticTokensBuilder = __esm({
  "src/model/semanticTokensBuilder.ts"() {
    "use strict";
    init_main();
    SemanticTokensBuilder = class _SemanticTokensBuilder {
      constructor(legend) {
        this._prevLine = 0;
        this._prevChar = 0;
        this._dataIsSortedAndDeltaEncoded = true;
        this._data = [];
        this._dataLen = 0;
        this._tokenTypeStrToInt = /* @__PURE__ */ new Map();
        this._tokenModifierStrToInt = /* @__PURE__ */ new Map();
        this._hasLegend = false;
        if (legend) {
          this._hasLegend = true;
          for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {
            this._tokenTypeStrToInt.set(legend.tokenTypes[i], i);
          }
          for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {
            this._tokenModifierStrToInt.set(legend.tokenModifiers[i], i);
          }
        }
      }
      push(arg0, arg1, arg2, arg3, arg4) {
        if (typeof arg0 === "number" && typeof arg1 === "number" && typeof arg2 === "number" && typeof arg3 === "number" && (typeof arg4 === "number" || typeof arg4 === "undefined")) {
          if (typeof arg4 === "undefined") {
            arg4 = 0;
          }
          return this._pushEncoded(arg0, arg1, arg2, arg3, arg4);
        }
        if (Range.is(arg0) && typeof arg1 === "string" && isStrArrayOrUndefined(arg2)) {
          return this._push(arg0, arg1, arg2);
        }
        throw new Error("Illegal argument");
      }
      _push(range, tokenType, tokenModifiers) {
        if (!this._hasLegend) {
          throw new Error("Legend must be provided in constructor");
        }
        if (range.start.line !== range.end.line) {
          throw new Error("`range` cannot span multiple lines");
        }
        if (!this._tokenTypeStrToInt.has(tokenType)) {
          throw new Error("`tokenType` is not in the provided legend");
        }
        const line = range.start.line;
        const char = range.start.character;
        const length = range.end.character - range.start.character;
        const nTokenType = this._tokenTypeStrToInt.get(tokenType);
        let nTokenModifiers = 0;
        if (tokenModifiers) {
          for (const tokenModifier of tokenModifiers) {
            if (!this._tokenModifierStrToInt.has(tokenModifier)) {
              throw new Error("`tokenModifier` is not in the provided legend");
            }
            const nTokenModifier = this._tokenModifierStrToInt.get(tokenModifier);
            nTokenModifiers |= 1 << nTokenModifier >>> 0;
          }
        }
        this._pushEncoded(line, char, length, nTokenType, nTokenModifiers);
      }
      _pushEncoded(line, char, length, tokenType, tokenModifiers) {
        if (this._dataIsSortedAndDeltaEncoded && (line < this._prevLine || line === this._prevLine && char < this._prevChar)) {
          this._dataIsSortedAndDeltaEncoded = false;
          const tokenCount = this._data.length / 5 | 0;
          let prevLine = 0;
          let prevChar = 0;
          for (let i = 0; i < tokenCount; i++) {
            let line2 = this._data[5 * i];
            let char2 = this._data[5 * i + 1];
            if (line2 === 0) {
              line2 = prevLine;
              char2 += prevChar;
            } else {
              line2 += prevLine;
            }
            this._data[5 * i] = line2;
            this._data[5 * i + 1] = char2;
            prevLine = line2;
            prevChar = char2;
          }
        }
        let pushLine = line;
        let pushChar = char;
        if (this._dataIsSortedAndDeltaEncoded && this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      static _sortAndDeltaEncode(data) {
        let pos = [];
        const tokenCount = data.length / 5 | 0;
        for (let i = 0; i < tokenCount; i++) {
          pos[i] = i;
        }
        pos.sort((a, b) => {
          const aLine = data[5 * a];
          const bLine = data[5 * b];
          if (aLine === bLine) {
            const aChar = data[5 * a + 1];
            const bChar = data[5 * b + 1];
            return aChar - bChar;
          }
          return aLine - bLine;
        });
        const result = new Array(data.length);
        let prevLine = 0;
        let prevChar = 0;
        for (let i = 0; i < tokenCount; i++) {
          const srcOffset = 5 * pos[i];
          const line = data[srcOffset + 0];
          const char = data[srcOffset + 1];
          const length = data[srcOffset + 2];
          const tokenType = data[srcOffset + 3];
          const tokenModifiers = data[srcOffset + 4];
          const pushLine = line - prevLine;
          const pushChar = pushLine === 0 ? char - prevChar : char;
          const dstOffset = 5 * i;
          result[dstOffset + 0] = pushLine;
          result[dstOffset + 1] = pushChar;
          result[dstOffset + 2] = length;
          result[dstOffset + 3] = tokenType;
          result[dstOffset + 4] = tokenModifiers;
          prevLine = line;
          prevChar = char;
        }
        return result;
      }
      /**
       * Finish and create a `SemanticTokens` instance.
       */
      build(resultId) {
        if (!this._dataIsSortedAndDeltaEncoded) {
          return { data: _SemanticTokensBuilder._sortAndDeltaEncode(this._data), resultId };
        }
        return { data: this._data, resultId };
      }
    };
  }
});

// src/tree/index.ts
var init_tree = __esm({
  "src/tree/index.ts"() {
    "use strict";
    init_TreeItem();
  }
});

// src/index.ts
var require_src3 = __commonJS({
  "src/index.ts"(exports2, module2) {
    "use strict";
    init_main();
    init_esm();
    init_commands();
    init_manager();
    init_events();
    init_extension();
    init_languages();
    init_basic();
    init_manager3();
    init_download();
    init_fetch();
    init_floatFactory();
    init_highlighter();
    init_mru();
    init_relativePattern();
    init_services();
    init_manager4();
    init_string2();
    init_sources2();
    init_ansiparse();
    init_errors();
    init_mutex();
    init_protocol();
    init_window();
    init_workspace();
    init_language_client();
    init_line();
    init_semanticTokensBuilder();
    init_tree();
    init_util();
    init_fs();
    init_processes();
    init_types();
    init_types2();
    init_workspaceFolder();
    module2.exports = {
      get nvim() {
        return workspace_default.nvim;
      },
      Uri: URI2,
      LineBuilder,
      NullLogger,
      SettingMonitor,
      LanguageClient,
      CancellationTokenSource: import_node4.CancellationTokenSource,
      ProgressType: import_node4.ProgressType,
      RequestType: import_node4.RequestType,
      RequestType0: import_node4.RequestType0,
      NotificationType: import_node4.NotificationType,
      NotificationType0: import_node4.NotificationType0,
      ProtocolRequestType: import_node4.ProtocolRequestType,
      ProtocolRequestType0: import_node4.ProtocolRequestType0,
      ProtocolNotificationType: import_node4.ProtocolNotificationType,
      ProtocolNotificationType0: import_node4.ProtocolNotificationType0,
      Highlighter,
      Mru,
      Emitter: import_node4.Emitter,
      SnippetString,
      BasicList,
      Mutex,
      TreeItem,
      SemanticTokensBuilder,
      FloatFactory: FloatFactoryImpl,
      RelativePattern: RelativePattern2,
      CancellationError,
      WorkspaceChange,
      ResponseError: import_node4.ResponseError,
      Trace: import_node4.Trace,
      DocumentUri,
      WorkspaceFolder,
      InlineValueText,
      InlineValueVariableLookup,
      InlineValueEvaluatableExpression,
      InlineValueContext,
      InlayHintKind,
      InlayHintLabelPart,
      InlayHint,
      DiagnosticRelatedInformation,
      SemanticTokens,
      SemanticTokenTypes,
      SemanticTokenModifiers,
      AnnotatedTextEdit,
      ChangeAnnotation,
      SymbolTag,
      Command,
      Color,
      CodeDescription,
      ColorInformation,
      ColorPresentation,
      TextDocumentEdit,
      TextDocumentIdentifier,
      VersionedTextDocumentIdentifier,
      TextDocumentItem,
      DocumentHighlight,
      SelectionRange,
      DocumentLink,
      CodeLens,
      FormattingOptions,
      CodeAction,
      CodeActionContext,
      DocumentSymbol,
      WorkspaceSymbol,
      CreateFile,
      RenameFile,
      WorkspaceEdit,
      InsertReplaceEdit,
      InsertTextMode,
      CompletionItem,
      CompletionList,
      Hover,
      ParameterInformation,
      SignatureInformation,
      SymbolInformation,
      MarkupContent,
      ErrorCodes: import_node4.ErrorCodes,
      CompletionItemTag,
      integer,
      uinteger,
      FoldingRangeKind,
      FoldingRange,
      ChangeAnnotationIdentifier,
      DeleteFile,
      OptionalVersionedTextDocumentIdentifier,
      CompletionItemLabelDetails,
      MarkedString,
      ProviderName,
      DocumentDiagnosticReportKind: import_node4.DocumentDiagnosticReportKind,
      UniquenessLevel: import_node4.UniquenessLevel,
      MonikerKind: import_node4.MonikerKind,
      PatternType,
      SourceType,
      ConfigurationTarget: ConfigurationUpdateTarget,
      ServiceStat,
      FileType,
      State,
      ClientState,
      CloseAction,
      ErrorAction,
      TransportKind,
      MessageTransports,
      RevealOutputChannelOn,
      MarkupKind,
      DiagnosticTag,
      DocumentHighlightKind,
      SymbolKind,
      SignatureHelpTriggerKind: import_node4.SignatureHelpTriggerKind,
      FileChangeType: import_node4.FileChangeType,
      CodeActionKind,
      Diagnostic,
      DiagnosticSeverity,
      CompletionItemKind,
      InsertTextFormat,
      Location,
      LocationLink,
      CancellationToken: import_node4.CancellationToken,
      Position,
      Range,
      TextEdit,
      Disposable: import_node4.Disposable,
      Event: import_node4.Event,
      workspace: workspace_default,
      window: window_default,
      CodeActionTriggerKind,
      CompletionTriggerKind: import_node4.CompletionTriggerKind,
      snippetManager: manager_default3,
      events: events_default,
      services: services_default,
      commands: commands_default,
      sources: sources_default,
      languages: languages_default,
      diagnosticManager: manager_default,
      extensions: extension_default,
      listManager: manager_default2,
      TreeItemCollapsibleState,
      DiagnosticPullMode,
      terminate,
      fetch,
      download,
      ansiparse,
      disposeAll,
      concurrent,
      watchFile,
      wait,
      runCommand,
      isRunning,
      executable
    };
  }
});

// src/util/factory.ts
function removedGlobalStub(name2) {
  return () => {
    throw new Error(`process.${name2}() is not allowed in extension sandbox`);
  };
}
function makeRequireFunction(cocExports) {
  const req = (p) => {
    if (p === "coc.nvim") {
      return toObject(cocExports);
    }
    return this.require(p);
  };
  req.resolve = (request2, options2) => Module._resolveFilename(request2, this, false, options2);
  req.main = mainModule;
  req.extensions = Module._extensions;
  req.cache = Module._cache;
  return req;
}
function compileInSandbox(sandbox, cocExports) {
  return function(content, filename) {
    const require2 = makeRequireFunction.call(this, cocExports);
    const dirname = path.dirname(filename);
    const newContent = content.startsWith("#!") ? content.replace(/^#!.*/, "") : content;
    const wrapper = Module.wrap(newContent);
    const compiledWrapper = vm.runInContext(wrapper, sandbox, { filename });
    const args = [this.exports, require2, this, filename, dirname];
    return compiledWrapper.apply(this.exports, args);
  };
}
function getProtoWithCompile(mod) {
  if (hasOwnProperty2(mod.prototype, "_compile")) return mod.prototype;
  if (hasOwnProperty2(mod.prototype.__proto__, "_compile")) return mod.prototype.__proto__;
  throw new Error("_compile not found");
}
function copyGlobalProperties(sandbox, globalObj) {
  for (const key of Object.keys(globalObj)) {
    const value = sandbox[key];
    if (value === void 0) {
      sandbox[key] = globalObj[key];
    }
  }
  return sandbox;
}
function createConsole(con, logger60) {
  let result = {};
  let methods2 = ["debug", "log", "info", "error", "warn"];
  for (let key of Object.keys(con)) {
    if (methods2.includes(key)) {
      result[key] = (...args) => {
        logger60[key].apply(logger60, args);
      };
    } else {
      let fn = con[key];
      if (typeof fn === "function") {
        result[key] = () => {
          logger60.warn(`function console.${key} not supported`);
        };
      } else {
        result[key] = fn;
      }
    }
  }
  return result;
}
function createSandbox(filename, logger60, name2, noExport = false) {
  const module2 = new Module(filename);
  module2.paths = Module._nodeModulePaths(filename);
  const sandbox = vm.createContext({
    module: module2,
    Buffer,
    URL: globalThis.URL,
    WebAssembly: globalThis.WebAssembly,
    console: createConsole(console, logger60)
  }, { name: name2 });
  copyGlobalProperties(sandbox, global);
  let cocExports = noExport ? void 0 : require_src3();
  sandbox.require = function sandboxRequire(p) {
    const oldCompile = ModuleProto._compile;
    ModuleProto._compile = compileInSandbox(sandbox, cocExports);
    const moduleExports = sandbox.module.require(p);
    ModuleProto._compile = oldCompile;
    return moduleExports;
  };
  sandbox.process = new process.constructor();
  for (let key of Reflect.ownKeys(process)) {
    if (typeof key === "string" && key.startsWith("_")) {
      continue;
    }
    sandbox.process[key] = process[key];
  }
  REMOVED_GLOBALS.forEach((name3) => {
    sandbox.process[name3] = removedGlobalStub(name3);
  });
  sandbox.process["chdir"] = () => {
  };
  sandbox.process.umask = (mask) => {
    if (typeof mask !== "undefined") {
      throw new Error("Cannot use process.umask() to change mask (read-only)");
    }
    return process.umask();
  };
  return sandbox;
}
function getLogger(useConsole, id2) {
  return useConsole ? consoleLogger : createLogger(`extension:${id2}`);
}
function createExtension(id2, filename, isEmpty2) {
  if (isEmpty2 || !fs.existsSync(filename)) return {
    activate: () => {
    },
    deactivate: null
  };
  const logger60 = getLogger(!global.__isMain && true, id2);
  const sandbox = createSandbox(filename, logger60, id2);
  delete Module._cache[require.resolve(filename)];
  const defaultImport = sandbox.require(filename);
  const activate = defaultImport && defaultImport.activate || defaultImport;
  if (typeof activate !== "function") return { activate: () => {
  } };
  return typeof defaultImport === "function" ? { activate } : Object.assign({}, defaultImport);
}
var consoleLogger, Module, mainModule, REMOVED_GLOBALS, ModuleProto;
var init_factory = __esm({
  "src/util/factory.ts"() {
    "use strict";
    init_logger();
    init_node();
    init_object();
    consoleLogger = {
      category: "",
      log: console.log.bind(console),
      debug: console.debug.bind(console),
      error: console.error.bind(console),
      warn: console.warn.bind(console),
      info: console.info.bind(console),
      trace: console.log.bind(console),
      fatal: console.error.bind(console),
      mark: console.log.bind(console)
    };
    Module = require("module");
    mainModule = require.main;
    REMOVED_GLOBALS = [
      "reallyExit",
      "abort",
      "umask",
      "setuid",
      "setgid",
      "setgroups",
      "_fatalException",
      "exit",
      "kill"
    ];
    ModuleProto = getProtoWithCompile(Module);
  }
});

// src/util/timing.ts
function createTiming(name2, timeout2) {
  let start;
  let timer;
  let _label;
  return {
    start(label) {
      _label = label;
      start = Date.now();
      clearTimeout(timer);
      if (timeout2) {
        timer = setTimeout(() => {
          logger39.error(`${name2} timeout after ${timeout2}ms`);
        }, timeout2);
        timer.unref();
      }
    },
    stop() {
      clearTimeout(timer);
      logger39.trace(`${name2}${_label ? ` ${_label}` : ""} cost:`, Date.now() - start);
    }
  };
}
var logger39;
var init_timing = __esm({
  "src/util/timing.ts"() {
    "use strict";
    init_logger();
    logger39 = createLogger("timing");
  }
});

// src/extension/stat.ts
function toInterval(opt) {
  return opt === "daily" ? ONE_DAY : ONE_DAY * 7;
}
function validExtensionFolder(folder, version2) {
  let errors = [];
  let res = loadExtensionJson(folder, version2, errors);
  return res != null && errors.length == 0;
}
function getEntryFile(main) {
  if (!main) return "index.js";
  if (!main.endsWith(".js")) return main + ".js";
  return main;
}
async function loadGlobalJsonAsync(folder, version2) {
  let jsonFile = path.join(folder, "package.json");
  let content = await readFile(jsonFile, "utf8");
  let packageJSON = JSON.parse(content);
  let { engines } = packageJSON;
  let main = getEntryFile(packageJSON.main);
  if (!engines || typeof engines.coc !== "string" && typeof engines.vscode !== "string") throw new Error("Invalid engines field");
  let keys = Object.keys(engines);
  if (keys.includes("coc") && !semver.satisfies(version2, engines["coc"].replace(/^\^/, ">="))) {
    throw new Error(`coc.nvim version not match, required ${engines["coc"]}`);
  }
  if (!engines.vscode && !fs.existsSync(path.join(folder, main))) {
    throw new Error(`main file ${main} not found, you may need to build the project.`);
  }
  return packageJSON;
}
function loadExtensionJson(folder, version2, errors) {
  let jsonFile = path.join(folder, "package.json");
  if (!fs.existsSync(jsonFile)) {
    errors.push(`package.json not found in ${folder}`);
    return void 0;
  }
  let packageJSON = loadJson2(jsonFile);
  let { name: name2, engines } = packageJSON;
  let main = getEntryFile(packageJSON.main);
  if (!name2) errors.push(`can't find name in package.json`);
  if (!engines || !objectLiteral(engines)) {
    errors.push(`invalid engines in ${jsonFile}`);
  }
  if (engines && !engines.vscode && !fs.existsSync(path.join(folder, main))) {
    errors.push(`main file ${main} not found, you may need to build the project.`);
  }
  if (engines) {
    let keys = Object.keys(engines);
    if (!keys.includes("coc") && !keys.includes("vscode")) {
      errors.push(`Engines in package.json doesn't have coc or vscode`);
    }
    if (keys.includes("coc")) {
      let required = engines["coc"].replace(/^\^/, ">=");
      if (!semver.satisfies(version2, required)) {
        errors.push(`Please update coc.nvim, ${packageJSON.name} requires coc.nvim ${engines["coc"]}`);
      }
    }
  }
  return packageJSON;
}
function getExtensionName(def) {
  if (/^https?:/.test(def)) return def;
  if (!def.includes("@")) return def;
  return def.replace(/@[\d.]+$/, "");
}
function checkExtensionRoot(root) {
  try {
    if (!fs.existsSync(root)) {
      fs.mkdirSync(root, { recursive: true });
    }
    let stat = fs.statSync(root);
    if (!stat.isDirectory()) {
      logger40.info(`Trying to delete ${root}`);
      fs.unlinkSync(root);
      fs.mkdirSync(root, { recursive: true });
    }
    let jsonFile = path.join(root, "package.json");
    if (!fs.existsSync(jsonFile)) {
      fs.writeFileSync(jsonFile, '{"dependencies":{}}', "utf8");
    }
  } catch (e) {
    console.error(`Unexpected error when check data home ${root}: ${e}`);
    return false;
  }
  return true;
}
async function getJsFiles(folder) {
  if (!fs.existsSync(folder)) return [];
  let files = await (0, import_util.promisify)(fs.readdir)(folder);
  return files.filter((f) => f.endsWith(".js"));
}
function loadJson2(filepath) {
  try {
    let text = fs.readFileSync(filepath, "utf8");
    let data = JSON.parse(text);
    return toObject(data);
  } catch (e) {
    logger40.error(`Error on parse json file ${filepath}`, e);
    return {};
  }
}
var logger40, ONE_DAY, DISABLE_PROMPT_KEY, ExtensionStat;
var init_stat = __esm({
  "src/extension/stat.ts"() {
    "use strict";
    init_logger();
    init_array();
    init_fs();
    init_is();
    init_node();
    init_object();
    logger40 = createLogger("extension-stat");
    ONE_DAY = 24 * 60 * 60 * 1e3;
    DISABLE_PROMPT_KEY = "disablePrompt";
    ExtensionStat = class {
      constructor(folder) {
        this.folder = folder;
        this.disabled = /* @__PURE__ */ new Set();
        this.locked = /* @__PURE__ */ new Set();
        this.extensions = /* @__PURE__ */ new Set();
        this.localExtensions = /* @__PURE__ */ new Map();
        try {
          this.migrate();
        } catch (e) {
          logger40.error(`Error on update package.json at ${folder}`, e);
        }
      }
      migrate() {
        let curr = loadJson2(this.jsonFile);
        let db = path.join(this.folder, "db.json");
        let changed = false;
        if (fs.existsSync(db)) {
          let obj = loadJson2(db);
          let def = obj.extension ?? {};
          for (let [key, o] of Object.entries(def)) {
            if (o.disabled) this.disabled.add(key);
            if (o.locked) this.locked.add(key);
          }
          curr.disabled = Array.from(this.disabled);
          curr.locked = Array.from(this.locked);
          curr.lastUpdate = obj.lastUpdate;
          fs.unlinkSync(db);
          changed = true;
        } else {
          this.disabled = new Set(curr.disabled ?? []);
          this.locked = new Set(curr.locked ?? []);
        }
        if (changed) writeJson(this.jsonFile, curr);
        let ids = Object.keys(curr.dependencies ?? {});
        this.extensions = new Set(ids);
      }
      addNoPromptFolder(uri) {
        let curr = loadJson2(this.jsonFile);
        curr[DISABLE_PROMPT_KEY] = curr[DISABLE_PROMPT_KEY] ?? [];
        curr[DISABLE_PROMPT_KEY].push(uri);
        writeJson(this.jsonFile, curr);
      }
      shouldPrompt(uri) {
        let curr = loadJson2(this.jsonFile);
        let arr = curr[DISABLE_PROMPT_KEY] ?? [];
        return !arr.includes(uri);
      }
      reset() {
        writeJson(this.jsonFile, {});
      }
      *activated() {
        let { disabled } = this;
        for (let key of Object.keys(this.dependencies)) {
          if (!disabled.has(key)) {
            yield key;
          }
        }
      }
      addLocalExtension(name2, folder) {
        this.localExtensions.set(name2, folder);
      }
      getFolder(name2) {
        if (this.extensions.has(name2)) return path.join(this.folder, "node_modules", name2);
        return this.localExtensions.get(name2);
      }
      getExtensionsStat() {
        let res = {};
        for (let id2 of this.extensions) {
          if (this.disabled.has(id2)) {
            res[id2] = 1 /* Disabled */;
          } else if (this.locked.has(id2)) {
            res[id2] = 2 /* Locked */;
          } else {
            res[id2] = 0 /* Normal */;
          }
        }
        return res;
      }
      hasExtension(id2) {
        return this.extensions.has(id2);
      }
      addExtension(id2, val) {
        let curr = loadJson2(this.jsonFile);
        curr.dependencies = curr.dependencies ?? {};
        curr.dependencies[id2] = val;
        this.extensions.add(id2);
        writeJson(this.jsonFile, curr);
      }
      removeExtension(id2) {
        let curr = loadJson2(this.jsonFile);
        if (curr.disabled) curr.disabled = curr.disabled.filter((key) => key !== id2);
        if (curr.locked) curr.locked = curr.locked.filter((key) => key !== id2);
        curr.dependencies = curr.dependencies ?? {};
        delete curr.dependencies[id2];
        this.extensions.delete(id2);
        writeJson(this.jsonFile, curr);
      }
      isDisabled(id2) {
        return this.disabled.has(id2);
      }
      get lockedExtensions() {
        return Array.from(this.locked);
      }
      get disabledExtensions() {
        return Array.from(this.disabled);
      }
      get dependencies() {
        let curr = loadJson2(this.jsonFile);
        return curr.dependencies ?? {};
      }
      setDisable(id2, disable) {
        if (disable) {
          this.disabled.add(id2);
        } else {
          this.disabled.delete(id2);
        }
        this.update("disabled", Array.from(this.disabled));
      }
      setLocked(id2, locked) {
        if (locked) {
          this.locked.add(id2);
        } else {
          this.locked.delete(id2);
        }
        this.update("locked", Array.from(this.disabled));
      }
      setLastUpdate() {
        this.update("lastUpdate", Date.now());
      }
      shouldUpdate(opt) {
        if (opt === "never") return false;
        let interval2 = toInterval(opt);
        let curr = loadJson2(this.jsonFile);
        return curr.lastUpdate == null || Date.now() - curr.lastUpdate > interval2;
      }
      get globalIds() {
        let curr = loadJson2(this.jsonFile);
        return Object.keys(curr.dependencies ?? {});
      }
      /**
       * Filter out global extensions that needs install
       */
      filterGlobalExtensions(names) {
        let disabledExtensions = this.disabledExtensions;
        let dependencies = this.dependencies;
        let map = /* @__PURE__ */ new Map();
        toArray(names).forEach((def) => {
          if (!def || typeof def !== "string") return;
          let name2 = getExtensionName(def);
          map.set(name2, def);
        });
        let currentUrls = [];
        let exists = [];
        for (let [key, val] of Object.entries(dependencies)) {
          if (fs.existsSync(path.join(this.folder, "node_modules", key, "package.json"))) {
            exists.push(key);
            if (typeof val === "string" && /^https?:/.test(val)) {
              currentUrls.push(val);
            }
          }
        }
        for (let name2 of map.keys()) {
          if (disabledExtensions.includes(name2) || this.extensions.has(name2)) {
            map.delete(name2);
            continue;
          }
          if (/^https?:/.test(name2) && currentUrls.some((url) => url.startsWith(name2)) || exists.includes(name2)) {
            map.delete(name2);
          }
        }
        return Array.from(map.values());
      }
      update(key, value) {
        let curr = loadJson2(this.jsonFile);
        curr[key] = value;
        writeJson(this.jsonFile, curr);
      }
      get jsonFile() {
        return path.join(this.folder, "package.json");
      }
    };
  }
});

// src/extension/manager.ts
function getEvents(activationEvents) {
  let res = [];
  for (let ev of toArray(activationEvents)) {
    let [name2] = ev.split(":", 2);
    if (name2 && !res.includes(name2)) res.push(name2);
  }
  return res;
}
function getOnCommandList(activationEvents) {
  let res = [];
  for (let ev of toArray(activationEvents)) {
    let [name2, command] = ev.split(":", 2);
    if (name2 === "onCommand" /* OnCommand */ && command) res.push(command);
  }
  return res;
}
function checkLanguageId(document2, activationEvents) {
  for (let eventName of activationEvents) {
    let parts = eventName.split(":");
    let ev = parts[0];
    if (ev == "onLanguage" /* OnLanguage */ && (document2.languageId == parts[1] || document2.filetype == parts[1])) {
      return true;
    }
  }
  return false;
}
function checkCommand(command, activationEvents) {
  for (let eventName of activationEvents) {
    let parts = eventName.split(":");
    let ev = parts[0];
    if (ev == "onCommand" /* OnCommand */ && command == parts[1]) {
      return true;
    }
  }
  return false;
}
function checkFileSystem(uri, activationEvents) {
  let scheme = URI2.parse(uri).scheme;
  for (let eventName of activationEvents) {
    let parts = eventName.split(":");
    let ev = parts[0];
    if (ev == "onFileSystem" /* OnFileSystem */ && scheme == parts[1]) {
      return true;
    }
  }
  return false;
}
function getActivationEvents(json) {
  return toArray(json.activationEvents).filter((key) => typeof key === "string" && key.length > 0);
}
function toWorkspaceContainsPatterns(activationEvents) {
  let patterns = [];
  for (let eventName of activationEvents) {
    let parts = eventName.split(":");
    if (parts[0] == "workspaceContains" /* WorkspaceContains */ && parts[1]) {
      patterns.push(parts[1]);
    }
  }
  return patterns;
}
var logger41, extensionRegistry5, memos, configurationRegistry2, ExtensionManager;
var init_manager5 = __esm({
  "src/extension/manager.ts"() {
    "use strict";
    init_esm();
    init_registry2();
    init_types();
    init_events();
    init_logger();
    init_memos();
    init_util();
    init_array();
    init_constants();
    init_extensionRegistry();
    init_factory();
    init_fs();
    init_is();
    init_lodash();
    init_node();
    init_object();
    init_protocol();
    init_registry();
    init_timing();
    init_window();
    init_workspace();
    init_stat();
    logger41 = createLogger("extensions-manager");
    extensionRegistry5 = Registry.as(Extensions.ExtensionContribution);
    memos = new Memos(path.resolve(dataHome, "memos.json"));
    memos.merge(path.resolve(dataHome, "../memos.json"));
    configurationRegistry2 = Registry.as(Extensions3.Configuration);
    ExtensionManager = class {
      constructor(states, folder) {
        this.states = states;
        this.folder = folder;
        this.activated = false;
        this.disposables = [];
        this.configurationNodes = [];
        this.extensions = /* @__PURE__ */ new Map();
        this._onDidLoadExtension = new import_node4.Emitter();
        this._onDidActiveExtension = new import_node4.Emitter();
        this._onDidUnloadExtension = new import_node4.Emitter();
        this.singleExtensionsRoot = path.join(configHome, "coc-extensions");
        this.onDidLoadExtension = this._onDidLoadExtension.event;
        this.onDidActiveExtension = this._onDidActiveExtension.event;
        this.onDidUnloadExtension = this._onDidUnloadExtension.event;
        this.modulesFolder = path.join(this.folder, "node_modules");
      }
      activateExtensions() {
        this.activated = true;
        if (process.env.COC_NO_PLUGINS == "1") return;
        configurationRegistry2.registerConfigurations(this.configurationNodes);
        this.attachEvents();
        let promises = [];
        for (let key of this.extensions.keys()) {
          const { extension } = this.extensions.get(key);
          const activationEvents = extension.packageJSON.activationEvents;
          if (!activationEvents || activationEvents.includes("*")) {
            promises.push(void extension.activate());
          } else {
            void this.autoActivate(key, extension);
          }
        }
        return Promise.allSettled(promises);
      }
      async loadFileExtensions() {
        let folder = this.singleExtensionsRoot;
        let files = await getJsFiles(folder);
        await Promise.allSettled(files.map((file) => {
          return this.loadExtensionFile(path.join(folder, file));
        }));
      }
      attachEvents() {
        workspace_default.onDidRuntimePathChange(async (paths) => {
          let folders = paths.filter((p) => p && validExtensionFolder(p, workspace_default.version));
          let outputChannel = window_default.createOutputChannel("extensions");
          await Promise.allSettled(folders.map((folder) => {
            outputChannel.appendLine(`Loading extension from runtimepath: ${folder}`);
            return this.loadExtension(folder);
          }));
        }, null, this.disposables);
        workspace_default.onDidOpenTextDocument((document2) => {
          let doc = workspace_default.getDocument(document2.bufnr);
          this.tryActivateExtensions("onLanguage" /* OnLanguage */, (events) => {
            return checkLanguageId(doc, events);
          });
          this.tryActivateExtensions("onFileSystem" /* OnFileSystem */, (events) => {
            return checkFileSystem(doc.uri, events);
          });
        }, null, this.disposables);
        events_default.on("Command", async (command) => {
          let fired = false;
          this.tryActivateExtensions("onCommand" /* OnCommand */, (events) => {
            let result = checkCommand(command, events);
            if (result) fired = true;
            return result;
          });
          if (fired) await wait(50);
        }, null, this.disposables);
        workspace_default.onDidChangeWorkspaceFolders((e) => {
          if (e.added.length > 0) {
            this.tryActivateExtensions("workspaceContains" /* WorkspaceContains */, (events) => {
              let patterns = toWorkspaceContainsPatterns(events);
              return workspace_default.checkPatterns(patterns, e.added);
            });
          }
        }, null, this.disposables);
      }
      /**
       * Unload & remove all global extensions, return removed extensions.
       */
      async cleanExtensions() {
        let { globalIds } = this.states;
        await remove(this.modulesFolder);
        return globalIds.filter((id2) => !this.states.isDisabled(id2));
      }
      tryActivateExtensions(event, check) {
        for (let item of this.extensions.values()) {
          if (item.extension.isActive) continue;
          let events = item.events;
          if (!events.includes(event)) continue;
          let { extension } = item;
          let activationEvents = getActivationEvents(extension.packageJSON);
          void Promise.resolve(check(activationEvents)).then((checked) => {
            if (checked) void Promise.resolve(extension.activate());
          });
        }
      }
      async checkAutoActivate(packageJSON) {
        let activationEvents = getActivationEvents(packageJSON);
        if (activationEvents.length === 0 || activationEvents.includes("*")) {
          return true;
        }
        let patterns = [];
        for (let eventName of activationEvents) {
          let parts = eventName.split(":");
          let ev = parts[0];
          if (ev === "onLanguage" /* OnLanguage */) {
            if (workspace_default.languageIds.has(parts[1]) || workspace_default.filetypes.has(parts[1])) {
              return true;
            }
          } else if (ev === "workspaceContains" /* WorkspaceContains */ && parts[1]) {
            patterns.push(parts[1]);
          } else if (ev === "onFileSystem" /* OnFileSystem */) {
            for (let doc of workspace_default.documents) {
              let u = URI2.parse(doc.uri);
              if (u.scheme == parts[1]) {
                return true;
              }
            }
          }
        }
        if (patterns.length > 0) {
          let res = await workspace_default.checkPatterns(patterns);
          if (res) return true;
        }
        return false;
      }
      has(id2) {
        return this.extensions.has(id2);
      }
      getExtension(id2) {
        return this.extensions.get(id2);
      }
      get loadedExtensions() {
        return Array.from(this.extensions.keys());
      }
      get all() {
        return Array.from(this.extensions.values()).map((o) => o.extension);
      }
      /**
       * Activate extension, throw error if disabled or doesn't exist.
       * Returns true if extension successfully activated.
       */
      async activate(id2) {
        let item = this.extensions.get(id2);
        if (!item) throw new Error(`Extension ${id2} not registered!`);
        let { extension } = item;
        if (extension.isActive) return true;
        await Promise.resolve(extension.activate());
        return extension.isActive === true;
      }
      async deactivate(id2) {
        let item = this.extensions.get(id2);
        if (!item || !item.extension.isActive) return;
        await Promise.resolve(item.deactivate());
      }
      /**
       * Load extension from folder, folder should contains coc extension.
       */
      async loadExtension(folder, noActive = false) {
        if (Array.isArray(folder)) {
          let results = await Promise.allSettled(folder.map((f) => {
            return this.loadExtension(f, noActive);
          }));
          results.forEach((res) => {
            if (res.status === "rejected") throw new Error(`Error on loadExtension ${res.reason}`);
          });
          return true;
        }
        let errors = [];
        let obj = loadExtensionJson(folder, workspace_default.version, errors);
        if (errors.length > 0) throw new Error(errors[0]);
        let { name: name2 } = obj;
        if (this.states.isDisabled(name2)) return false;
        await this.unloadExtension(name2);
        let isLocal = !this.states.hasExtension(name2);
        if (isLocal) this.states.addLocalExtension(name2, folder);
        await this.registerExtension(folder, Object.freeze(obj), isLocal ? 1 /* Local */ : 0 /* Global */, noActive);
        return true;
      }
      /**
       * Deactivate & unregist extension
       */
      async unloadExtension(id2) {
        let item = this.extensions.get(id2);
        if (item) {
          await this.deactivate(id2);
          this.extensions.delete(id2);
          this._onDidUnloadExtension.fire(id2);
        }
      }
      async reloadExtension(id2) {
        let item = this.extensions.get(id2);
        if (!item || item.type == 3 /* Internal */) {
          throw new Error(`Extension ${id2} not registered`);
        }
        if (item.type == 2 /* SingleFile */) {
          await this.loadExtensionFile(item.filepath);
        } else {
          await this.loadExtension(item.directory);
        }
      }
      async call(id2, method, args) {
        let item = this.extensions.get(id2);
        if (!item) throw new Error(`extension ${id2} not registered`);
        let { extension } = item;
        if (!extension.isActive) {
          await this.activate(id2);
        }
        let { exports: exports2 } = extension;
        if (!exports2 || typeof exports2[method] !== "function") {
          throw new Error(`method ${method} not found on extension ${id2}`);
        }
        return await Promise.resolve(exports2[method].apply(null, args));
      }
      registContribution(id2, packageJSON, directory, filepath) {
        let { contributes, activationEvents } = packageJSON;
        let { configuration: configuration2, rootPatterns, commands } = contributes ?? {};
        let definitions;
        let props = getProperties(configuration2 ?? {});
        if (!isEmpty(props)) {
          let properties = convertProperties(props, 2 /* WINDOW */);
          if (objectLiteral(configuration2.definitions)) {
            let prefix = id2.replace(/[^\w]/g, "");
            const addPrefix = (obj, key) => {
              if (key == "$ref") {
                let val = obj[key];
                if (string(val) && val.startsWith("#/definitions/")) {
                  obj[key] = val.slice(0, 14) + prefix + "." + val.slice(14);
                }
              }
            };
            deepIterate(properties, addPrefix);
            definitions = {};
            Object.entries(deepClone(configuration2.definitions)).forEach(([key, val]) => {
              if (objectLiteral(val)) {
                definitions[prefix + "." + key] = val;
                deepIterate(val, addPrefix);
              }
            });
          }
          let node = { properties, extensionInfo: { id: id2, displayName: packageJSON.displayName } };
          this.configurationNodes.push(node);
          if (this.activated) {
            let toRemove = [];
            let idx = this.configurationNodes.findIndex((o) => o.extensionInfo.id === id2);
            if (idx !== -1) {
              toRemove.push(this.configurationNodes[idx]);
              this.configurationNodes.splice(idx, 1);
            }
            workspace_default.configurations.updateConfigurations([node], toRemove);
          }
        }
        extensionRegistry5.registerExtension(id2, {
          name: id2,
          directory,
          filepath,
          commands,
          definitions,
          rootPatterns,
          onCommands: getOnCommandList(activationEvents)
        });
      }
      getExtensionState(id2) {
        let disabled = this.states.isDisabled(id2);
        if (disabled) return "disabled";
        let item = this.getExtension(id2);
        if (!item) return "unknown";
        let { extension } = item;
        return extension.isActive ? "activated" : "loaded";
      }
      async autoActivate(id2, extension) {
        try {
          let checked = await this.checkAutoActivate(extension.packageJSON);
          if (checked) await Promise.resolve(extension.activate());
        } catch (e) {
          logger41.error(`Error on activate ${id2}`, e);
        }
      }
      async loadExtensionFile(filepath, noActive = false) {
        let stat = await statAsync(filepath);
        if (!stat || !stat.isFile()) return;
        let filename = path.basename(filepath);
        let basename = path.basename(filepath, ".js");
        let name2 = "single-" + basename;
        let root = path.dirname(filepath);
        let packageJSON = { name: name2, main: filename, engines: { coc: ">=0.0.82" } };
        let confpath = path.join(root, basename + ".json");
        let obj = loadJson(confpath);
        for (const attr of ["activationEvents", "contributes"]) {
          packageJSON[attr] = obj[attr];
        }
        await this.unloadExtension(name2);
        await this.registerExtension(root, packageJSON, 2 /* SingleFile */, noActive);
        return name2;
      }
      registerExtensions(stats) {
        for (let stat of stats) {
          try {
            let extensionType = stat.isLocal ? 1 /* Local */ : 0 /* Global */;
            void this.registerExtension(stat.root, stat.packageJSON, extensionType);
          } catch (e) {
            logger41.error(`Error on regist extension from ${stat.root}: `, e);
          }
        }
      }
      async registerExtension(root, packageJSON, extensionType, noActive = false) {
        let id2 = packageJSON.name;
        if (this.states.isDisabled(id2)) return;
        let isActive = false;
        let result;
        let filename = path.join(root, packageJSON.main || "index.js");
        let extensionPath = extensionType === 2 /* SingleFile */ ? filename : root;
        let exports2;
        let ext;
        let subscriptions = [];
        const timing = createTiming(`activate ${id2}`, 5e3);
        let extension = {
          activate: () => {
            if (result) return result;
            result = new Promise(async (resolve, reject) => {
              timing.start();
              try {
                let isEmpty2 = typeof packageJSON.engines.coc === "undefined";
                ext = createExtension(id2, filename, isEmpty2);
                let context = {
                  subscriptions,
                  extensionPath,
                  globalState: memos.createMemento(`${id2}|global`),
                  workspaceState: memos.createMemento(`${id2}|${workspace_default.rootPath}`),
                  asAbsolutePath: (relativePath) => path.join(root, relativePath),
                  storagePath: path.join(this.folder, `${id2}-data`),
                  logger: createLogger(`extension:${id2}`)
                };
                let res = await Promise.resolve(ext.activate(context));
                isActive = true;
                exports2 = res;
                this._onDidActiveExtension.fire(extension);
                timing.stop();
                resolve(res);
              } catch (e) {
                logger41.error(`Error on active extension ${id2}:`, e);
                reject(e);
              }
            });
            return result;
          },
          id: id2,
          packageJSON,
          extensionPath,
          extensionUri: URI2.parse(extensionPath),
          get isActive() {
            return isActive;
          },
          get module() {
            return ext;
          },
          get exports() {
            if (!isActive) throw new Error(`Invalid access to exports, extension "${id2}" not activated`);
            return exports2;
          }
        };
        Object.freeze(extension);
        this.extensions.set(id2, {
          id: id2,
          type: extensionType,
          isLocal: extensionType == 1 /* Local */,
          extension,
          directory: root,
          filepath: filename,
          events: getEvents(packageJSON.activationEvents),
          deactivate: async () => {
            if (!isActive) return;
            isActive = false;
            result = void 0;
            exports2 = void 0;
            disposeAll(subscriptions);
            if (ext && typeof ext.deactivate === "function") {
              try {
                await Promise.resolve(ext.deactivate());
                ext = void 0;
              } catch (e) {
                logger41.error(`Error on ${id2} deactivate: `, e);
              }
            }
          }
        });
        this.registContribution(id2, packageJSON, root, filename);
        this._onDidLoadExtension.fire(extension);
        if (this.activated && !noActive) await this.autoActivate(id2, extension);
      }
      unregistContribution(id2) {
        let idx = this.configurationNodes.findIndex((o) => o.extensionInfo.id === id2);
        extensionRegistry5.unregistExtension(id2);
        if (idx !== -1) {
          let node = this.configurationNodes[idx];
          this.configurationNodes.splice(idx, 1);
          configurationRegistry2.deregisterConfigurations([node]);
        }
      }
      async registerInternalExtension(extension, deactivate) {
        let { id: id2, packageJSON } = extension;
        this.extensions.set(id2, {
          id: id2,
          directory: __dirname,
          type: 3 /* Internal */,
          events: getEvents(packageJSON.activationEvents),
          extension,
          deactivate,
          isLocal: true
        });
        this.registContribution(id2, packageJSON, __dirname);
        this._onDidLoadExtension.fire(extension);
        await this.autoActivate(id2, extension);
      }
      /**
       * Only global extensions can be uninstalled
       */
      async uninstallExtensions(ids) {
        let [globals, filtered] = splitArray(ids, (id2) => this.states.hasExtension(id2));
        for (let id2 of globals) {
          await this.unloadExtension(id2);
          this.states.removeExtension(id2);
          extensionRegistry5.unregistExtension(id2);
          await remove(path.join(this.modulesFolder, id2));
        }
        if (filtered.length > 0) {
          void window_default.showWarningMessage(`Global extensions ${filtered.join(", ")} not found`);
        }
        if (globals.length > 0) {
          void window_default.showInformationMessage(`Removed extensions: ${globals.join(" ")}`);
        }
      }
      async toggleExtension(id2) {
        let state = this.getExtensionState(id2);
        if (state == "activated") await this.deactivate(id2);
        if (state != "disabled") {
          this.states.setDisable(id2, true);
          this.unregistContribution(id2);
          await this.unloadExtension(id2);
        } else {
          this.states.setDisable(id2, false);
          if (id2.startsWith("single-")) {
            let filepath = path.join(this.singleExtensionsRoot, `${id2.replace(/^single-/, "")}.js`);
            await this.loadExtensionFile(filepath);
          } else {
            let folder = this.states.getFolder(id2);
            if (folder) {
              await this.loadExtension(folder);
            } else {
              void window_default.showWarningMessage(`Extension ${id2} not found`);
            }
          }
        }
      }
      async watchExtension(id2) {
        let item = this.getExtension(id2);
        if (!item) throw new Error(`extension ${id2} not found`);
        if (id2.startsWith("single-")) {
          void window_default.showInformationMessage(`watching ${item.filepath}`);
          this.disposables.push(watchFile(item.filepath, async () => {
            await this.loadExtensionFile(item.filepath);
            void window_default.showInformationMessage(`reloaded ${id2}`);
          }, false));
        } else {
          let client = await workspace_default.fileSystemWatchers.createClient(item.directory, true);
          if (!client) throw new Error("watchman not found");
          void window_default.showInformationMessage(`watching ${item.directory}`);
          await client.subscribe("**/*.js", async () => {
            await this.reloadExtension(id2);
            void window_default.showInformationMessage(`reloaded ${id2}`);
          });
        }
      }
      /**
       * load extension in folder or file
       */
      async load(filepath, active) {
        let name2;
        if (isDirectory(filepath)) {
          let obj = loadJson(path.join(filepath, "package.json"));
          name2 = obj.name;
          await this.loadExtension(filepath, true);
        } else {
          name2 = await this.loadExtensionFile(filepath, true);
        }
        if (!name2) throw new Error(`Unable to load extension at ${filepath}`);
        let disabled = this.states.isDisabled(name2);
        if (disabled) throw new Error(`extension ${name2} is disabled`);
        let item = this.getExtension(name2);
        if (active) await item.extension.activate();
        return {
          get isActive() {
            return item.extension.isActive;
          },
          get name() {
            return name2;
          },
          get api() {
            return item.extension.exports;
          },
          get exports() {
            let module2 = item.extension.module ?? {};
            return omit(module2, ["activate"]);
          },
          unload: () => {
            return this.unloadExtension(name2);
          }
        };
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/extension/ui.ts
var interval, InstallChannel, debounceTime7, InstallBuffer;
var init_ui3 = __esm({
  "src/extension/ui.ts"() {
    "use strict";
    init_events();
    init_status();
    init_util();
    init_node();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    interval = getConditionValue(100, 1);
    InstallChannel = class {
      constructor(settings, channel) {
        this.settings = settings;
        this.channel = channel;
      }
      get isUpdate() {
        return this.settings.isUpdate;
      }
      getText() {
        return this.isUpdate ? "update" : "install";
      }
      start(names) {
        this.channel.appendLine(`${this.isUpdate ? "Updating" : "Installing"} ${names.join(", ")}`);
      }
      addMessage(name2, msg, isProgress) {
        if (!isProgress) {
          this.channel.appendLine(`${name2} - ${msg}`);
        }
      }
      startProgress(name2) {
        this.channel.appendLine(`Start ${this.getText()} ${name2}`);
      }
      finishProgress(name2, succeed) {
        if (succeed) {
          this.channel.appendLine(`${name2} ${this.getText()} succeed!`);
        } else {
          this.channel.appendLine(`${name2} ${this.getText()} failed!`);
        }
      }
    };
    debounceTime7 = getConditionValue(500, 10);
    InstallBuffer = class {
      constructor(settings) {
        this.settings = settings;
        this.statMap = /* @__PURE__ */ new Map();
        this.updated = /* @__PURE__ */ new Set();
        this.messagesMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.names = [];
        let floatFactory4 = window_default.createFloatFactory({ modes: ["n"] });
        this.disposables.push(floatFactory4);
        let fn = debounce(async (bufnr, cursor) => {
          if (bufnr == this.bufnr) {
            let msgs = this.getMessages(cursor[0] - 1);
            let docs = msgs.length > 0 ? [{ content: msgs.join("\n"), filetype: "txt" }] : [];
            await floatFactory4.show(docs);
          }
        }, debounceTime7);
        this.disposables.push(import_node4.Disposable.create(() => {
          fn.clear();
        }));
        events_default.on("CursorMoved", fn, this.disposables);
        events_default.on("BufUnload", (bufnr) => {
          if (bufnr === this.bufnr) {
            this.dispose();
          }
        }, null, this.disposables);
      }
      async start(names) {
        this.statMap.clear();
        this.names = names;
        for (let name2 of names) {
          this.statMap.set(name2, 0 /* Waiting */);
        }
        await this.show();
      }
      addMessage(name2, msg) {
        let lines = this.messagesMap.get(name2) || [];
        this.messagesMap.set(name2, lines.concat(msg.trim().split(/\r?\n/)));
        if (msg.startsWith("Updated to") || msg.startsWith("Installed extension")) {
          this.updated.add(name2);
        }
      }
      startProgress(name2) {
        this.statMap.set(name2, 2 /* Progressing */);
      }
      finishProgress(name2, succeed) {
        this.statMap.set(name2, succeed ? 3 /* Success */ : 1 /* Failed */);
      }
      get remains() {
        let count = 0;
        for (let name2 of this.names) {
          let stat = this.statMap.get(name2);
          if (![3 /* Success */, 1 /* Failed */].includes(stat)) {
            count = count + 1;
          }
        }
        return count;
      }
      getLinesAndHighlights(start) {
        let lines = [];
        let highlights = [];
        for (let name2 of this.names) {
          let state = this.statMap.get(name2);
          let processText = "*";
          let hlGroup;
          let lnum = start + lines.length;
          switch (state) {
            case 2 /* Progressing */: {
              let d = /* @__PURE__ */ new Date();
              let idx = Math.floor(d.getMilliseconds() / 100);
              processText = frames[idx];
              hlGroup = void 0;
              break;
            }
            case 1 /* Failed */:
              processText = "\u2717";
              hlGroup = "ErrorMsg";
              break;
            case 3 /* Success */:
              processText = "\u2713";
              hlGroup = this.updated.has(name2) ? "MoreMsg" : "Comment";
              break;
          }
          let msgs = this.messagesMap.get(name2) || [];
          let pre = `- ${processText} `;
          let len = byteLength(pre);
          if (hlGroup) {
            highlights.push({ hlGroup, lnum, colStart: len, colEnd: len + byteLength(name2) });
          }
          lines.push(`${pre}${name2} ${msgs.length ? msgs[msgs.length - 1] : ""}`);
        }
        return { lines, highlights };
      }
      getMessages(line) {
        let name2 = this.names[line - 2];
        return this.messagesMap.get(name2) ?? [];
      }
      get stopped() {
        return this.interval == null;
      }
      get isUpdate() {
        return this.settings.isUpdate;
      }
      // draw frame
      draw() {
        let { remains, bufnr } = this;
        let { nvim } = workspace_default;
        if (!bufnr) return;
        let buffer = nvim.createBuffer(bufnr);
        let first = remains == 0 ? `${this.isUpdate ? "Update" : "Install"} finished` : `Installing, ${remains} remaining...`;
        let { lines, highlights } = this.getLinesAndHighlights(2);
        nvim.pauseNotification();
        buffer.setLines([first, "", ...lines], { start: 0, end: -1, strictIndexing: false }, true);
        buffer.updateHighlights("coc-extensions", highlights, { priority: 99 });
        if (remains == 0 && this.interval) {
          clearInterval(this.interval);
          this.interval = null;
        }
        nvim.resumeNotification(true, true);
      }
      highlight() {
        let { nvim } = workspace_default;
        nvim.call("matchadd", ["CocListFgCyan", "^\\-\\s\\zs\\*"], true);
        nvim.call("matchadd", ["CocListFgGreen", "^\\-\\s\\zs\u2713"], true);
        nvim.call("matchadd", ["CocListFgRed", "^\\-\\s\\zs\u2717"], true);
      }
      async show() {
        let isSync = events_default.requesting === true;
        let { nvim } = workspace_default;
        nvim.pauseNotification();
        nvim.command(isSync ? "enew" : this.settings.updateUIInTab ? "tabnew" : "vs +enew", true);
        nvim.call("bufnr", ["%"], true);
        nvim.command("setl buftype=nofile bufhidden=wipe noswapfile nobuflisted wrap undolevels=-1", true);
        if (!isSync) nvim.command("nnoremap <silent><nowait><buffer> q :q<CR>", true);
        this.highlight();
        let res = await nvim.resumeNotification();
        this.bufnr = res[0][1];
        this.interval = setInterval(() => {
          this.draw();
        }, interval);
      }
      dispose() {
        this.bufnr = void 0;
        this.messagesMap.clear();
        this.statMap.clear();
        disposeAll(this.disposables);
        clearInterval(this.interval);
        this.interval = null;
      }
    };
  }
});

// src/extension/index.ts
function toUrl(val) {
  return isUrl(val) ? val.replace(/\.git(#master|#main)?$/, "") : "";
}
var logger42, EXTENSIONS_FOLDER, Extensions4, extension_default;
var init_extension = __esm({
  "src/extension/index.ts"() {
    "use strict";
    init_commands();
    init_types();
    init_events();
    init_logger();
    init_util();
    init_array();
    init_constants();
    init_is();
    init_node();
    init_object();
    init_processes();
    init_window();
    init_workspace();
    init_installer();
    init_manager5();
    init_stat();
    init_ui3();
    logger42 = createLogger("extensions-index");
    EXTENSIONS_FOLDER = path.join(dataHome, "extensions");
    Extensions4 = class {
      constructor() {
        this.modulesFolder = path.join(EXTENSIONS_FOLDER, "node_modules");
        checkExtensionRoot(EXTENSIONS_FOLDER);
        this.states = new ExtensionStat(EXTENSIONS_FOLDER);
        this.manager = new ExtensionManager(this.states, EXTENSIONS_FOLDER);
        commands_default.register({
          id: "extensions.forceUpdateAll",
          execute: async () => {
            let arr = await this.manager.cleanExtensions();
            logger42.info(`Force update extensions: ${arr}`);
            await this.installExtensions(arr);
          }
        }, false, "remove all global extensions and install them");
        this.globalPromise = this.globalExtensions();
        commands_default.register({
          id: "extensions.toggleAutoUpdate",
          execute: async () => {
            let settings = this.getUpdateSettings();
            let target = 1 /* Global */;
            let config = workspace_default.getConfiguration(null, null);
            if (settings.updateCheck == "never") {
              await config.update("extensions.updateCheck", "daily", target);
              void window_default.showInformationMessage("Extension auto update enabled.");
            } else {
              await config.update("extensions.updateCheck", "never", target);
              void window_default.showInformationMessage("Extension auto update disabled.");
            }
            await config.update("coc.preferences.extensionUpdateCheck", void 0, target);
          }
        }, false, "toggle auto update of extensions.");
        events_default.once("ready", () => {
          void this.checkRecommendation(workspace_default.workspaceFolders[0]);
          workspace_default.onDidChangeWorkspaceFolders((e) => {
            void this.checkRecommendation(e.added[0]);
          });
        });
      }
      async checkRecommendation(workspaceFolder) {
        if (!workspaceFolder) return;
        let config = workspace_default.getConfiguration("extensions", workspaceFolder);
        let recommendations = toArray(config.inspect("recommendations").workspaceFolderValue);
        const unInstalled = recommendations.filter((name2) => !this.states.hasExtension(name2));
        let uri = workspaceFolder.uri;
        if (!this.manager.states.shouldPrompt(uri) || unInstalled.length === 0) return;
        let items = [{
          title: `Install ${unInstalled.join(", ")}`,
          index: 1
        }, {
          title: "Don't show again",
          isCloseAffordance: true,
          index: 2
        }];
        const item = await window_default.showInformationMessage(`Install recommend extensions?`, ...items);
        if (!item) return;
        if (item.index === 1) {
          await this.installExtensions(unInstalled);
        } else {
          this.manager.states.addNoPromptFolder(uri);
        }
      }
      getUpdateSettings() {
        let config = workspace_default.getConfiguration(null, null);
        let extensionsConfig = toObject(config.inspect("extensions").globalValue);
        return {
          updateCheck: extensionsConfig.updateCheck ?? config.get("coc.preferences.extensionUpdateCheck", "never"),
          updateUIInTab: extensionsConfig.updateUIInTab ?? config.get("coc.preferences.extensionUpdateUIInTab", false),
          silentAutoupdate: extensionsConfig.silentAutoupdate ?? config.get("coc.preferences.silentAutoupdate", true)
        };
      }
      async init(runtimepath) {
        if (process.env.COC_NO_PLUGINS == "1") return;
        let stats = await this.globalPromise;
        this.manager.registerExtensions(stats);
        let localStats = this.runtimeExtensionStats(runtimepath.split(","));
        this.manager.registerExtensions(localStats);
        void this.manager.loadFileExtensions();
      }
      async activateExtensions() {
        await this.manager.activateExtensions();
        if (process.env.COC_NO_PLUGINS == "1") {
          logger42.warn("Extensions disabled by env COC_NO_PLUGINS");
          return;
        }
        let names = this.states.filterGlobalExtensions(workspace_default.env.globalExtensions);
        void this.installExtensions(names);
        let settings = this.getUpdateSettings();
        if (this.states.shouldUpdate(settings.updateCheck)) {
          this.outputChannel.appendLine("Start auto update...");
          this.updateExtensions(settings.silentAutoupdate, settings.updateUIInTab).catch((e) => {
            this.outputChannel.appendLine(`Error on updateExtensions ${e}`);
          });
        }
      }
      get onDidLoadExtension() {
        return this.manager.onDidLoadExtension;
      }
      get onDidActiveExtension() {
        return this.manager.onDidActiveExtension;
      }
      get onDidUnloadExtension() {
        return this.manager.onDidUnloadExtension;
      }
      get outputChannel() {
        return window_default.createOutputChannel("extensions");
      }
      /**
       * Get all loaded extensions.
       */
      get all() {
        return this.manager.all;
      }
      has(id2) {
        return this.manager.has(id2);
      }
      getExtension(id2) {
        return this.manager.getExtension(id2);
      }
      getExtensionById(extensionId) {
        let item = this.manager.getExtension(extensionId);
        return item ? item.extension : void 0;
      }
      /**
       * @deprecated Used by old version coc-json.
       */
      get schemes() {
        return {};
      }
      /**
       * @deprecated Used by old version coc-json.
       */
      addSchemeProperty(key, def) {
      }
      /**
       * @public Get state of extension
       */
      getExtensionState(id2) {
        return this.manager.getExtensionState(id2);
      }
      isActivated(id2) {
        let item = this.manager.getExtension(id2);
        return item != null && item.extension.isActive;
      }
      async call(id2, method, args) {
        return await this.manager.call(id2, method, args);
      }
      get npm() {
        let npm = workspace_default.initialConfiguration.get("npm.binPath");
        npm = workspace_default.expand(npm);
        for (let exe of [npm, "npm"]) {
          if (executable(exe)) return which.sync(exe);
        }
        void window_default.showErrorMessage(`Can't find ${npm} or npm in your $PATH`);
        return null;
      }
      createInstallerUI(isUpdate, silent, updateUIInTab) {
        return silent ? new InstallChannel({ isUpdate }, this.outputChannel) : new InstallBuffer({ isUpdate, updateUIInTab });
      }
      createInstaller(npm, def) {
        return new Installer(this.modulesFolder, npm, def);
      }
      /**
       * Install extensions, can be called without initialize.
       */
      async installExtensions(list2) {
        if (isFalsyOrEmpty(list2) || !this.npm) return;
        let { npm } = this;
        list2 = distinct(list2);
        let installBuffer = this.createInstallerUI(false, false, false);
        await Promise.resolve(installBuffer.start(list2));
        let fn = async (key) => {
          try {
            installBuffer.startProgress(key);
            let installer = this.createInstaller(npm, key);
            installer.on("message", (msg, isProgress) => {
              installBuffer.addMessage(key, msg, isProgress);
            });
            let result = await installer.install();
            installBuffer.finishProgress(key, true);
            this.states.addExtension(result.name, result.url ? result.url : `>=${result.version}`);
            let ms = key.match(/@[\d.]+$/);
            if (ms != null) this.states.setLocked(result.name, true);
            await this.manager.loadExtension(result.folder);
          } catch (err) {
            installBuffer.addMessage(key, err.message);
            installBuffer.finishProgress(key, false);
            void window_default.showErrorMessage(`Error on install ${key}: ${err}`);
            logger42.error(`Error on install ${key}`, err);
          }
        };
        await concurrent(list2, fn);
      }
      /**
       * Update global extensions
       */
      async updateExtensions(silent = false, updateUIInTab = false) {
        let { npm } = this;
        if (!npm) return;
        let stats = this.globalExtensionStats();
        stats = stats.filter((s) => {
          if (s.isLocked || s.state === "disabled") {
            this.outputChannel.appendLine(`Skipped update for ${s.isLocked ? "locked" : "disabled"} extension "${s.id}"`);
            return false;
          }
          return true;
        });
        this.states.setLastUpdate();
        this.cleanModulesFolder();
        let installBuffer = this.createInstallerUI(true, silent, updateUIInTab);
        await Promise.resolve(installBuffer.start(stats.map((o) => o.id)));
        let fn = async (stat) => {
          let { id: id2 } = stat;
          try {
            installBuffer.startProgress(id2);
            let url = stat.exotic ? stat.uri : null;
            let installer = this.createInstaller(npm, id2);
            installer.on("message", (msg, isProgress) => {
              installBuffer.addMessage(id2, msg, isProgress);
            });
            let directory = await installer.update(url);
            installBuffer.finishProgress(id2, true);
            if (directory) await this.manager.loadExtension(directory);
          } catch (err) {
            installBuffer.addMessage(id2, err.message);
            installBuffer.finishProgress(id2, false);
            void window_default.showErrorMessage(`Error on update ${id2}: ${err}`);
            logger42.error(`Error on update ${id2}`, err);
          }
        };
        await concurrent(stats, fn, silent ? 1 : 3);
      }
      /**
       * Get all extension states
       */
      async getExtensionStates() {
        let runtimepaths = await workspace_default.nvim.runtimePaths;
        let localStats = this.runtimeExtensionStats(runtimepaths);
        let globalStats = this.globalExtensionStats();
        return localStats.concat(globalStats);
      }
      async globalExtensions() {
        if (process.env.COC_NO_PLUGINS == "1") return [];
        let res = [];
        for (let key of this.states.activated()) {
          let root = path.join(this.modulesFolder, key);
          try {
            let json = await loadGlobalJsonAsync(root, VERSION);
            res.push({ root, isLocal: false, packageJSON: json });
          } catch (err) {
            logger42.error(`Error on load package.json of ${key}`, err);
          }
        }
        return res;
      }
      globalExtensionStats() {
        let dependencies = this.states.dependencies;
        let lockedExtensions = this.states.lockedExtensions;
        let infos = [];
        Object.entries(dependencies).map(([key, val]) => {
          let root = path.join(this.modulesFolder, key);
          let errors = [];
          let obj = loadExtensionJson(root, VERSION, errors);
          if (errors.length > 0) {
            this.outputChannel.appendLine(`Error on load ${key} at ${root}: ${errors.join("\n")}`);
            return;
          }
          obj.name = key;
          infos.push({
            id: key,
            root,
            isLocal: false,
            version: obj.version,
            description: obj.description ?? "",
            isLocked: lockedExtensions.includes(key),
            exotic: /^https?:/.test(val),
            uri: toUrl(val),
            state: this.getExtensionState(key),
            packageJSON: obj
          });
        });
        logger42.debug("globalExtensionStats:", infos.length);
        return infos;
      }
      runtimeExtensionStats(runtimepaths) {
        let lockedExtensions = this.states.lockedExtensions;
        let infos = [];
        let localIds = /* @__PURE__ */ new Set();
        runtimepaths.map((root) => {
          let errors = [];
          let obj = loadExtensionJson(root, workspace_default.version, errors);
          if (errors.length > 0) return;
          let { name: name2 } = obj;
          if (!name2 || this.states.hasExtension(name2) || localIds.has(name2)) return;
          this.states.addLocalExtension(name2, root);
          localIds.add(name2);
          infos.push({
            id: obj.name,
            isLocal: true,
            isLocked: lockedExtensions.includes(name2),
            version: obj.version,
            description: obj.description ?? "",
            exotic: false,
            root,
            state: this.getExtensionState(obj.name),
            packageJSON: Object.freeze(obj)
          });
        });
        return infos;
      }
      /**
       * Remove unnecessary folders in node_modules
       */
      cleanModulesFolder() {
        let globalIds = this.states.globalIds;
        let folders = globalIds.map((s) => s.replace(/\/.*$/, ""));
        if (!fs.existsSync(this.modulesFolder)) return;
        let files = fs.readdirSync(this.modulesFolder);
        for (let file of files) {
          if (folders.includes(file)) continue;
          let p = path.join(this.modulesFolder, file);
          let stat = fs.lstatSync(p);
          if (stat.isSymbolicLink()) {
            fs.unlinkSync(p);
          } else if (stat.isDirectory()) {
            fs.rmSync(p, { recursive: true, force: true });
          }
        }
      }
      dispose() {
        this.manager.dispose();
      }
    };
    extension_default = new Extensions4();
  }
});

// src/completion/keywords.ts
var KeywordsBuffer;
var init_keywords = __esm({
  "src/completion/keywords.ts"() {
    "use strict";
    init_esm();
    init_events();
    init_async();
    init_fs();
    init_protocol();
    KeywordsBuffer = class {
      constructor(doc, segmenterLocales) {
        this.doc = doc;
        this.segmenterLocales = segmenterLocales;
        this.lineWords = [];
        this._gitIgnored = false;
        this.minimalCharacterLen = 2;
        void this.parseWords(segmenterLocales);
        let uri = URI2.parse(doc.uri);
        if (uri.scheme === "file") {
          void isGitIgnored(uri.fsPath).then((ignored) => {
            this._gitIgnored = ignored;
          });
        }
      }
      getWords() {
        let res = [];
        for (let words of this.lineWords) {
          words.forEach((word) => {
            if (!res.includes(word)) {
              res.push(word);
            }
          });
        }
        return res;
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = void 0;
        }
      }
      async parseWords(segmenterLocales) {
        let { lineWords, doc, minimalCharacterLen } = this;
        let { chars } = doc;
        let tokenSource = this.tokenSource = new import_node4.CancellationTokenSource();
        let token = tokenSource.token;
        await forEach(doc.textDocument.lines, (line) => {
          let words = chars.matchLine(line, segmenterLocales, minimalCharacterLen);
          lineWords.push(words);
        }, token, { yieldAfter: 20 });
      }
      get bufnr() {
        return this.doc.bufnr;
      }
      get gitIgnored() {
        return this._gitIgnored;
      }
      onCompleteDone(idx) {
        let { doc, segmenterLocales, minimalCharacterLen } = this;
        let line = doc.getline(idx);
        this.lineWords[idx] = doc.chars.matchLine(line, segmenterLocales, minimalCharacterLen);
      }
      onChange(e) {
        if (events_default.completing || e.contentChanges.length == 0) return;
        let { lineWords, doc, segmenterLocales, minimalCharacterLen } = this;
        let { range, text } = e.contentChanges[0];
        let { start, end } = range;
        let sl = start.line;
        let el = end.line;
        let del = el - sl;
        let newLines = doc.textDocument.lines.slice(sl, sl + text.split(/\n/).length);
        let arr = newLines.map((line) => doc.chars.matchLine(line, segmenterLocales, minimalCharacterLen));
        lineWords.splice(sl, del + 1, ...arr);
      }
      *matchWords(line) {
        let { lineWords } = this;
        if (line >= lineWords.length) line = lineWords.length - 1;
        for (let i = 0; i < lineWords.length; i++) {
          let idx = i < line ? line - i - 1 : i;
          let words = lineWords[idx];
          for (let word of words) {
            yield word;
          }
        }
      }
      dispose() {
        this.cancel();
        this.lineWords = [];
      }
    };
  }
});

// src/completion/source.ts
function firstMatchFuzzy(firstCode, ascii, word) {
  let ch = word[0];
  if (ascii && !WORD_PREFIXES_CODE.includes(firstCode) && WORD_PREFIXES.includes(ch)) ch = word[1];
  if (ascii && ch.charCodeAt(0) > ASCII_END) ch = unidecode(ch);
  return caseMatch(firstCode, ch.charCodeAt(0));
}
var WORD_PREFIXES, WORD_PREFIXES_CODE, MAX_DURATION, MAX_COUNT, Source;
var init_source = __esm({
  "src/completion/source.ts"() {
    "use strict";
    init_events();
    init_util();
    init_array();
    init_constants();
    init_fuzzy();
    init_is();
    init_node();
    init_string();
    init_workspace();
    init_types2();
    WORD_PREFIXES = ["_", "$", "-"];
    WORD_PREFIXES_CODE = [95, 36, 45];
    MAX_DURATION = getConditionValue(80, 20);
    MAX_COUNT = 50;
    Source = class {
      constructor(option) {
        /**
         * Words that not match during session
         * The word that not match previous input would not match further input
         */
        this.noMatchWords = /* @__PURE__ */ new Set();
        this.disposables = [];
        this._disabled = false;
        this.name = option.name;
        this.filepath = option.filepath || "";
        this.sourceType = option.sourceType || 0 /* Native */;
        this.isSnippet = !!option.isSnippet;
        this.defaults = option;
        this.documentSelector = option.documentSelector;
        const key = `coc.source.${option.name}`;
        this.config = defaultValue(workspace_default.initialConfiguration.get(key), {});
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration(key)) {
            this.config = defaultValue(workspace_default.initialConfiguration.get(key), {});
          }
        }, null, this.disposables);
        events_default.on("CompleteDone", () => {
          this.noMatchWords.clear();
        }, null, this.disposables);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      /**
       * Priority of source, higher priority makes items lower index.
       */
      get priority() {
        return this.getConfig("priority", 1);
      }
      get triggerPatterns() {
        let patterns = this.getConfig("triggerPatterns", null);
        if (isFalsyOrEmpty(patterns)) return null;
        return patterns.map((s) => string(s) ? new RegExp(s + "$") : s);
      }
      /**
       * When triggerOnly is true, not trigger completion on keyword character insert.
       */
      get triggerOnly() {
        let triggerOnly = this.defaults["triggerOnly"];
        if (boolean(triggerOnly)) return triggerOnly;
        return Array.isArray(this.triggerPatterns) && this.triggerPatterns.length > 0;
      }
      get triggerCharacters() {
        return toArray(this.getConfig("triggerCharacters", []));
      }
      get firstMatch() {
        return this.getConfig("firstMatch", true);
      }
      get remoteFns() {
        return toArray(this.defaults.remoteFns);
      }
      get shortcut() {
        let shortcut = this.getConfig("shortcut", "");
        return shortcut ? shortcut : this.name.slice(0, 3);
      }
      get enable() {
        if (this._disabled) return false;
        return this.getConfig("enable", true);
      }
      get filetypes() {
        return this.getConfig("filetypes", null);
      }
      get disableSyntaxes() {
        return this.getConfig("disableSyntaxes", []);
      }
      getConfig(key, defaultValue2) {
        let val = this.config[key];
        if (func(val) || val == null) return defaultValue2 ?? null;
        return val;
      }
      toggle() {
        this._disabled = !this._disabled;
      }
      get menu() {
        return "";
      }
      async checkComplete(opt) {
        let { disableSyntaxes } = this;
        if (!isFalsyOrEmpty(disableSyntaxes) && opt.synname) {
          let synname = opt.synname.toLowerCase();
          if (disableSyntaxes.findIndex((s) => synname.includes(s.toLowerCase())) !== -1) {
            return false;
          }
        }
        let fn = this.defaults["shouldComplete"];
        if (func(fn)) return !!await Promise.resolve(fn.call(this, opt));
        return true;
      }
      async refresh() {
        let fn = this.defaults["refresh"];
        if (func(fn)) await Promise.resolve(fn.call(this));
      }
      async onCompleteDone(item, opt) {
        let fn = this.defaults["onCompleteDone"];
        if (func(fn)) await Promise.resolve(fn.call(this, item, opt));
      }
      async doComplete(opt, token) {
        let shouldRun = await this.checkComplete(opt);
        if (!shouldRun || token.isCancellationRequested) return null;
        let fn = this.defaults["doComplete"];
        return await Promise.resolve(fn.call(this, opt, token));
      }
      async onCompleteResolve(item, opt, token) {
        let fn = this.defaults["onCompleteResolve"];
        if (func(fn)) await Promise.resolve(fn.call(this, item, opt, token));
      }
      /**
       * Add words to items with timer.
       */
      async getResults(iterables, input, exclude, items, token) {
        let { firstMatch, noMatchWords } = this;
        let start = Date.now();
        let prev = start;
        let len = input.length;
        let firstCode = input.charCodeAt(0);
        let codes = getCharCodes(input);
        let ascii = isAlphabet(firstCode);
        let i = 0;
        for (let iterable of iterables) {
          for (let w of iterable) {
            i++;
            if (i % 100 === 0) {
              let curr = Date.now();
              if (curr - prev > 15) {
                await waitImmediate();
                prev = curr;
              }
              if (token.isCancellationRequested || curr - start > MAX_DURATION) return true;
            }
            if (w.length <= 1 && w.charCodeAt(0) < 255 || w === exclude || items.has(w) || noMatchWords.has(w)) continue;
            if (firstMatch && !firstMatchFuzzy(firstCode, ascii, w)) {
              noMatchWords.add(w);
              continue;
            }
            if (len > 1) {
              let matched = fuzzyMatch(codes, ascii && w[0].charCodeAt(0) > ASCII_END ? unidecode(w) : w);
              if (!matched) {
                noMatchWords.add(w);
                continue;
              }
            }
            items.add(w);
            if (items.size == MAX_COUNT) return true;
          }
        }
        return false;
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/completion/source-language.ts
function getUltisnipOption(item) {
  let opts = item.data?.ultisnip === true ? {} : item.data?.ultisnip;
  return opts ? opts : void 0;
}
function fixIndent(line, currline, range) {
  let oldIndent = line.match(/^\s*/)[0];
  let newIndent = currline.match(/^\s*/)[0];
  if (oldIndent === newIndent) return 0;
  let d = newIndent.length - oldIndent.length;
  range.start.character += d;
  range.end.character += d;
  return d;
}
function fixTextEdit(character, edit2) {
  if (TextEdit.is(edit2)) {
    if (character < edit2.range.start.character) {
      edit2.range.start.character = character;
    }
  }
  if (InsertReplaceEdit.is(edit2)) {
    if (character < edit2.insert.start.character) {
      edit2.insert.start.character = character;
    }
    if (character < edit2.replace.start.character) {
      edit2.replace.start.character = character;
    }
  }
  return edit2;
}
var logger43, LanguageSource;
var init_source_language = __esm({
  "src/completion/source-language.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_ui();
    init_logger();
    init_manager4();
    init_util();
    init_array();
    init_errors();
    init_is();
    init_object();
    init_protocol();
    init_string();
    init_workspace();
    init_types2();
    init_util4();
    logger43 = createLogger("source-language");
    LanguageSource = class {
      constructor(name2, shortcut, provider, documentSelector, triggerCharacters, allCommitCharacters, priority) {
        this.name = name2;
        this.shortcut = shortcut;
        this.provider = provider;
        this.documentSelector = documentSelector;
        this.triggerCharacters = triggerCharacters;
        this.allCommitCharacters = allCommitCharacters;
        this.priority = priority;
        this.sourceType = 2 /* Service */;
        this._enabled = true;
        this.itemDefaults = {};
        // Kept Promise for resolve
        this.resolving = /* @__PURE__ */ new WeakMap();
      }
      get enable() {
        return this._enabled;
      }
      toggle() {
        this._enabled = !this._enabled;
      }
      shouldCommit(item, character) {
        if (this.allCommitCharacters.includes(character)) return true;
        let commitCharacters = toArray(item.commitCharacters ?? this.itemDefaults.commitCharacters);
        return commitCharacters.includes(character);
      }
      async doComplete(option, token) {
        let { triggerCharacter, bufnr, position } = option;
        let triggerKind = this.getTriggerKind(option);
        this.triggerContext = { lnum: position.line, character: position.character, line: option.line };
        let context = { triggerKind, option };
        if (triggerKind == import_node4.CompletionTriggerKind.TriggerCharacter) context.triggerCharacter = triggerCharacter;
        let textDocument = workspace_default.getDocument(bufnr).textDocument;
        await waitImmediate();
        let result = await Promise.resolve(this.provider.provideCompletionItems(textDocument, position, token, context));
        if (!result || token.isCancellationRequested) return null;
        let completeItems = Array.isArray(result) ? result : result.items;
        if (!completeItems || completeItems.length == 0) return null;
        let itemDefaults = this.itemDefaults = toObject(result["itemDefaults"]);
        let isIncomplete = isCompletionList(result) ? result.isIncomplete === true : false;
        this.hasDefaultRange = isEditRange(itemDefaults.editRange);
        return { isIncomplete, items: completeItems, itemDefaults };
      }
      onCompleteResolve(item, opt, token) {
        let hasResolve = func(this.provider.resolveCompletionItem);
        if (!hasResolve) return;
        let promise = this.resolving.get(item);
        if (promise) return promise;
        let invalid = false;
        promise = new Promise(async (resolve, reject) => {
          let disposable = token.onCancellationRequested(() => {
            this.resolving.delete(item);
            reject(new CancellationError());
          });
          try {
            let resolved = await Promise.resolve(this.provider.resolveCompletionItem(item, token));
            disposable.dispose();
            if (!token.isCancellationRequested) {
              if (!resolved) {
                invalid = true;
                this.resolving.delete(item);
              } else {
                if (resolved.textEdit) {
                  let character = characterIndex(opt.line, opt.col);
                  resolved.textEdit = fixTextEdit(character, resolved.textEdit);
                }
                Object.assign(item, resolved);
              }
            }
            resolve();
          } catch (e) {
            invalid = true;
            this.resolving.delete(item);
            reject(e);
          }
        });
        if (!invalid) {
          this.resolving.set(item, promise);
        }
        return promise;
      }
      async onCompleteDone(item, opt) {
        let doc = workspace_default.getDocument(opt.bufnr);
        await doc.patchChange();
        let additionalEdits = !isFalsyOrEmpty(item.additionalTextEdits);
        let version2 = doc.version;
        let isSnippet = await this.applyTextEdit(doc, additionalEdits, item, opt);
        if (additionalEdits) {
          await doc.applyEdits(item.additionalTextEdits, doc.version != version2, !isSnippet);
          if (isSnippet) await manager_default3.selectCurrentPlaceholder();
        }
        if (item.command) {
          if (commands_default.has(item.command.command)) {
            void commands_default.execute(item.command);
          } else {
            logger43.warn(`Command "${item.command.command}" not registered to coc.nvim`);
          }
        }
      }
      async applyTextEdit(doc, additionalEdits, item, option) {
        let { linenr, col } = option;
        let { character, line } = this.triggerContext;
        let pos = await getLineAndPosition(workspace_default.nvim);
        if (pos.line != linenr - 1) return;
        let { textEdit, textEditText, insertText, label } = item;
        let range = getReplaceRange(item, this.itemDefaults?.editRange, void 0, option.insertMode);
        if (!range) {
          let end = character + (option.insertMode == "insert" /* Insert */ ? 0 : option.followWord.length);
          range = Range.create(pos.line, characterIndex(line, col), pos.line, end);
        }
        if (range.end.character < character) range.end.character = character;
        let newText = textEdit ? textEdit.newText : (textEditText && this.hasDefaultRange ? textEditText : insertText) ?? label;
        let indentCount = fixIndent(line, pos.text, range);
        let delta = pos.character - character - indentCount;
        if (delta !== 0) range.end.character += delta;
        let next = pos.text[range.end.character];
        if (next && newText.endsWith(next) && pariedCharacters.get(newText[0]) === next) {
          range.end.character += 1;
        }
        if (option.snippetsSupport !== false && isSnippetItem(item, this.itemDefaults)) {
          let opts = getUltisnipOption(item);
          let insertTextMode = item.insertTextMode ?? this.itemDefaults.insertTextMode;
          return await manager_default3.insertSnippet(newText, !additionalEdits, range, insertTextMode, opts);
        }
        await doc.applyEdits([TextEdit.replace(range, newText)], false, pos);
        return false;
      }
      getTriggerKind(opt) {
        let { triggerCharacters } = this;
        let isTrigger = triggerCharacters.includes(opt.triggerCharacter);
        let triggerKind = import_node4.CompletionTriggerKind.Invoked;
        if (opt.triggerForInComplete) {
          triggerKind = import_node4.CompletionTriggerKind.TriggerForIncompleteCompletions;
        } else if (isTrigger) {
          triggerKind = import_node4.CompletionTriggerKind.TriggerCharacter;
        }
        return triggerKind;
      }
    };
  }
});

// src/completion/source-vim.ts
function getMethodName(name2, names) {
  if (names.includes(name2)) return name2;
  let key = name2[0].toUpperCase() + name2.slice(1);
  if (names.includes(key)) return key;
  throw new Error(`${name2} not exists`);
}
function checkInclude(name2, fns) {
  if (fns.includes(name2)) return true;
  let key = name2[0].toUpperCase() + name2.slice(1);
  return fns.includes(key);
}
var VimSource;
var init_source_vim = __esm({
  "src/completion/source-vim.ts"() {
    "use strict";
    init_main();
    init_ui();
    init_manager4();
    init_string();
    init_workspace();
    init_source();
    init_is();
    VimSource = class extends Source {
      async callOptionalFunc(fname, args, isNotify = false) {
        let exists = checkInclude(fname, this.remoteFns);
        if (!exists) return null;
        let name2 = `coc#source#${this.name}#${getMethodName(fname, this.remoteFns)}`;
        if (isNotify) return this.nvim.call(name2, args, true);
        return await this.nvim.call(name2, args);
      }
      async checkComplete(opt) {
        let shouldRun = await super.checkComplete(opt);
        if (!shouldRun) return false;
        if (!checkInclude("should_complete", this.remoteFns)) return true;
        let res = await this.callOptionalFunc("should_complete", [opt]);
        return !!res;
      }
      async refresh() {
        await this.callOptionalFunc("refresh", []);
      }
      async insertSnippet(insertText, opt) {
        let pos = await getLineAndPosition(this.nvim);
        let { line, col } = opt;
        let oldIndent = line.match(/^\s*/)[0];
        let newIndent = pos.text.match(/^\s*/)[0];
        let range = Range.create(pos.line, characterIndex(line, col) + newIndent.length - oldIndent.length, pos.line, pos.character);
        await manager_default3.insertSnippet(insertText, true, range);
      }
      async onCompleteDone(item, opt) {
        if (checkInclude("on_complete", this.remoteFns)) {
          await this.callOptionalFunc("on_complete", [item], true);
        } else if (item.isSnippet && item.insertText) {
          await this.insertSnippet(item.insertText, opt);
        }
      }
      onEnter(bufnr) {
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !checkInclude("on_enter", this.remoteFns)) return;
        let { filetypes } = this;
        if (filetypes && !filetypes.includes(doc.filetype)) return;
        void this.callOptionalFunc("on_enter", [{
          bufnr,
          uri: doc.uri,
          languageId: doc.filetype
        }], true);
      }
      async doComplete(opt, token) {
        let shouldRun = await this.checkComplete(opt);
        if (!shouldRun) return null;
        let startcol = await this.callOptionalFunc("get_startcol", [opt]);
        if (token.isCancellationRequested) return null;
        let { col, input, line, colnr } = opt;
        if (number(startcol) && startcol >= 0 && startcol !== col) {
          input = byteSlice(line, startcol, colnr - 1);
          opt = Object.assign({}, opt, {
            col: startcol,
            changed: col - startcol,
            input
          });
        }
        const vim9 = this.remoteFns.includes("Complete");
        let vimItems = await this.nvim.callAsync("coc#_do_complete", [this.name, { ...opt, vim9 }]);
        if (!vimItems || vimItems.length == 0 || token.isCancellationRequested) return null;
        let checkFirst = this.firstMatch && input.length > 0;
        let inputFirst = checkFirst ? input[0].toLowerCase() : "";
        let items = [];
        vimItems.forEach((item) => {
          let obj = string(item) ? { word: item } : item;
          if (checkFirst) {
            let ch = (obj.filterText ?? obj.word)[0];
            if (inputFirst && ch.toLowerCase() !== inputFirst) return;
          }
          if (this.isSnippet) obj.isSnippet = true;
          items.push(obj);
        });
        return { items, startcol: number(startcol) ? startcol : void 0 };
      }
    };
  }
});

// src/completion/native/around.ts
var around_exports = {};
__export(around_exports, {
  Around: () => Around,
  register: () => register
});
function register(sourceMap, keywords) {
  let source = new Around(keywords);
  sourceMap.set("around", source);
}
var Around;
var init_around = __esm({
  "src/completion/native/around.ts"() {
    "use strict";
    init_util();
    init_source();
    Around = class extends Source {
      constructor(keywords) {
        super({ name: "around", filepath: __filename });
        this.keywords = keywords;
      }
      async doComplete(opt, token) {
        const shouldRun = await this.checkComplete(opt);
        if (!shouldRun) return null;
        let { bufnr, input, word, linenr, triggerForInComplete } = opt;
        if (input.length === 0) return null;
        await waitImmediate();
        let buf = this.keywords.getItem(bufnr);
        if (!buf) return null;
        if (!triggerForInComplete) this.noMatchWords = /* @__PURE__ */ new Set();
        if (token.isCancellationRequested) return null;
        let iterable = buf.matchWords(linenr - 1);
        let items = /* @__PURE__ */ new Set();
        let isIncomplete = await this.getResults([iterable], input, word, items, token);
        return {
          isIncomplete,
          items: Array.from(items, (word2) => ({ word: word2 }))
        };
      }
    };
  }
});

// src/completion/native/buffer.ts
var buffer_exports = {};
__export(buffer_exports, {
  Buffer: () => Buffer2,
  register: () => register2
});
function register2(sourceMap, keywords) {
  let source = new Buffer2(keywords);
  sourceMap.set("buffer", source);
}
var Buffer2;
var init_buffer2 = __esm({
  "src/completion/native/buffer.ts"() {
    "use strict";
    init_util();
    init_source();
    Buffer2 = class extends Source {
      constructor(keywords) {
        super({ name: "buffer", filepath: __filename });
        this.keywords = keywords;
      }
      get ignoreGitignore() {
        return this.getConfig("ignoreGitignore", true);
      }
      async doComplete(opt, token) {
        const shouldRun = await this.checkComplete(opt);
        if (!shouldRun) return null;
        let { bufnr, input, word, triggerForInComplete } = opt;
        if (input.length === 0) return null;
        await waitImmediate();
        if (!triggerForInComplete) this.noMatchWords = /* @__PURE__ */ new Set();
        if (token.isCancellationRequested) return null;
        let iterables = [];
        for (let buf of this.keywords.items) {
          if (buf.bufnr === bufnr || this.ignoreGitignore && buf.gitIgnored) continue;
          iterables.push(buf.matchWords(0));
        }
        let items = /* @__PURE__ */ new Set();
        let isIncomplete = await this.getResults(iterables, input, word, items, token);
        return {
          isIncomplete,
          items: Array.from(items).map((s) => {
            return { word: s };
          })
        };
      }
    };
  }
});

// src/completion/native/file.ts
var file_exports = {};
__export(file_exports, {
  File: () => File,
  filterFiles: () => filterFiles,
  getDirectory: () => getDirectory,
  getFileItem: () => getFileItem,
  getItemsFromRoot: () => getItemsFromRoot,
  getLastPart: () => getLastPart,
  register: () => register3,
  resolveEnvVariables: () => resolveEnvVariables
});
function resolveEnvVariables(str, env = process.env) {
  let replaced = str;
  replaced = replaced.replace(/%([^%]+)%/g, (m, n) => env[n] ?? m);
  replaced = replaced.replace(
    /\$([A-Z_]+[A-Z0-9_]*)|\${([A-Z0-9_]*)}/gi,
    (m, a, b) => env[a || b] ?? m
  );
  return replaced;
}
function getLastPart(text) {
  let begin = text.length - 1;
  while (begin >= 0) {
    let curr = text[begin];
    if (invalid_characters.has(curr)) {
      begin++;
      break;
    }
    if (curr == " " && text[begin - 1] !== "\\") {
      begin++;
      break;
    }
    if (begin == 0) break;
    begin--;
  }
  if (begin >= text.length) return null;
  return text.slice(begin);
}
async function getFileItem(root, filename) {
  let f = path.join(root, filename);
  let stat = await statAsync(f);
  if (stat) {
    let dir = stat.isDirectory();
    let abbr = dir ? filename + "/" : filename;
    let word = filename;
    return { word, abbr, kind: dir ? CompletionItemKind.Folder : CompletionItemKind.File };
  }
  return null;
}
function filterFiles(files, ignoreHidden, ignorePatterns = []) {
  return files.filter((f) => {
    if (!f || ignoreHidden && f.startsWith(".")) return false;
    for (let p of ignorePatterns) {
      if (minimatch(f, p, { dot: true })) return false;
    }
    return true;
  });
}
function getDirectory(pathstr, root) {
  let part = /[\\/]$/.test(pathstr) ? pathstr : path.dirname(pathstr);
  return path.isAbsolute(pathstr) ? part : path.join(root, part);
}
async function getItemsFromRoot(pathstr, root, ignoreHidden, ignorePatterns) {
  let res = [];
  let dir = getDirectory(pathstr, root);
  let stat = await statAsync(dir);
  if (stat && stat.isDirectory()) {
    let files = await (0, import_util.promisify)(fs.readdir)(dir);
    files = filterFiles(files, ignoreHidden, ignorePatterns);
    let items = await Promise.all(files.map((filename) => getFileItem(dir, filename)));
    res = res.concat(items);
  }
  res = res.filter((item) => item != null);
  return res;
}
function register3(sourceMap) {
  sourceMap.set("file", new File(isWindows));
}
var pathRe, invalid_characters, File;
var init_file = __esm({
  "src/completion/native/file.ts"() {
    "use strict";
    init_main();
    init_fs();
    init_node();
    init_platform();
    init_string();
    init_workspace();
    init_source();
    pathRe = /(?:\.{0,2}|~|\$HOME|([\w]+)|[a-zA-Z]:|)(\/|\\+)(?:[\u4E00-\u9FA5\u00A0-\u024F\w .@()-]+(\/|\\+))*(?:[\u4E00-\u9FA5\u00A0-\u024F\w .@()-])*$/;
    invalid_characters = /* @__PURE__ */ new Set(["#", "<", "$", "+", "%", ">", "!", "`", "&", "*", "'", "|", "{", "?", '"', "=", "}", "@"]);
    File = class extends Source {
      constructor(isWindows2) {
        super({
          name: "file",
          filepath: __filename
        });
        this.isWindows = isWindows2;
      }
      get triggerCharacters() {
        let characters = this.getConfig("triggerCharacters", []);
        return this.isWindows ? characters : characters.filter((s) => s != "\\");
      }
      getPathOption(opt) {
        let { line, colnr } = opt;
        let part = resolveEnvVariables(byteSlice(line, 0, colnr - 1));
        let filepath = getLastPart(part);
        if (!filepath || filepath.endsWith("//")) return null;
        let ms = part.match(pathRe);
        if (ms && ms.length) {
          const pathstr = workspace_default.expand(ms[0]);
          let input = ms[0].match(/[^/\\]*$/)[0];
          return { pathstr, part: ms[1], startcol: colnr - input.length - 1, input };
        }
        return null;
      }
      shouldTrim(ext) {
        let trimSameExts = this.getConfig("trimSameExts", []);
        return trimSameExts.includes(ext);
      }
      async getRoot(pathstr, part, filepath, cwd2) {
        let root;
        let dirname = filepath ? path.dirname(filepath) : "";
        if (pathstr.startsWith(".")) {
          root = filepath ? dirname : cwd2;
        } else if (this.isWindows && /^\w+:/.test(pathstr)) {
          root = /[\\/]$/.test(pathstr) ? pathstr : path.win32.dirname(pathstr);
        } else if (!this.isWindows && pathstr.startsWith("/")) {
          root = pathstr.endsWith("/") ? pathstr : path.posix.dirname(pathstr);
        } else if (part) {
          let exists = await (0, import_util.promisify)(fs.exists)(path.join(dirname, part));
          if (exists) {
            root = dirname;
          } else {
            exists = await (0, import_util.promisify)(fs.exists)(path.join(cwd2, part));
            if (exists) root = cwd2;
          }
        } else {
          root = cwd2;
        }
        return root;
      }
      async doComplete(opt, token) {
        const shouldRun = await this.checkComplete(opt);
        if (!shouldRun) return null;
        let { filepath } = opt;
        let option = this.getPathOption(opt);
        if (!option || option.startcol < opt.col) return null;
        let { pathstr, part, startcol } = option;
        let startPart = opt.col == startcol ? "" : byteSlice(opt.line, opt.col, startcol);
        let ext = path.extname(path.basename(filepath));
        let cwd2 = await this.nvim.call("getcwd", []);
        let root = await this.getRoot(pathstr, part, filepath, cwd2);
        if (!root || token.isCancellationRequested) return null;
        let items = await getItemsFromRoot(pathstr, root, this.getConfig("ignoreHidden", true), this.getConfig("ignorePatterns", []));
        let trimExt = this.shouldTrim(ext);
        return {
          items: items.map((item) => {
            let ex = path.extname(item.word);
            item.word = trimExt && ex === ext ? item.word.replace(ext, "") : item.word;
            return {
              word: `${startPart}${item.word}`,
              abbr: `${startPart}${item.abbr}`,
              menu: this.menu
            };
          })
        };
      }
    };
  }
});

// src/completion/sources.ts
var sources_exports = {};
__export(sources_exports, {
  Sources: () => Sources,
  default: () => sources_default,
  getSourceType: () => getSourceType,
  logError: () => logError
});
function logError(err) {
  logger44.error("Error on source create", err);
}
function getSourceType(sourceType) {
  if (sourceType === 0 /* Native */) return "native";
  if (sourceType === 1 /* Remote */) return "remote";
  return "service";
}
var logger44, Sources, sources_default;
var init_sources2 = __esm({
  "src/completion/sources.ts"() {
    "use strict";
    init_events();
    init_extension();
    init_logger();
    init_util();
    init_array();
    init_fs();
    init_is();
    init_node();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    init_keywords();
    init_source();
    init_source_language();
    init_source_vim();
    init_types2();
    init_util4();
    logger44 = createLogger("sources");
    Sources = class {
      constructor() {
        this.sourceMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.remoteSourcePaths = [];
      }
      init() {
        this.keywords = workspace_default.registerBufferSync((doc) => {
          const segmenterLocales = workspace_default.getConfiguration("suggest", doc).get("segmenterLocales");
          return new KeywordsBuffer(doc, segmenterLocales);
        });
        this.createNativeSources();
        this.createRemoteSources();
        events_default.on("BufEnter", this.onDocumentEnter, this, this.disposables);
        events_default.on("CompleteDone", (_item, linenr, bufnr) => {
          let item = this.keywords.getItem(bufnr);
          if (item) item.onCompleteDone(linenr - 1);
        }, null, this.disposables);
        workspace_default.onDidRuntimePathChange((newPaths) => {
          for (let p of newPaths) {
            this.createVimSources(p).catch(logError);
          }
        }, null, this.disposables);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      getKeywordsBuffer(bufnr) {
        return this.keywords.getItem(bufnr);
      }
      createNativeSources() {
        void Promise.all([
          Promise.resolve().then(() => (init_util3(), util_exports)).then((m) => this.sourceMap.set(m.wordsSource.name, m.wordsSource)),
          Promise.resolve().then(() => (init_around(), around_exports)).then((module2) => {
            module2.register(this.sourceMap, this.keywords);
          }),
          Promise.resolve().then(() => (init_buffer2(), buffer_exports)).then((module2) => {
            module2.register(this.sourceMap, this.keywords);
          }),
          Promise.resolve().then(() => (init_file(), file_exports)).then((module2) => {
            module2.register(this.sourceMap);
          })
        ]);
      }
      createLanguageSource(name2, shortcut, selector, provider, triggerCharacters, priority, allCommitCharacters) {
        let source = new LanguageSource(
          name2,
          shortcut,
          provider,
          selector,
          toArray(triggerCharacters),
          toArray(allCommitCharacters),
          priority
        );
        logger44.trace("created service source", name2);
        this.sourceMap.set(name2, source);
        return {
          dispose: () => {
            this.sourceMap.delete(name2);
          }
        };
      }
      async createVimSourceExtension(filepath) {
        let { nvim } = this;
        try {
          let name2 = path.basename(filepath, ".vim");
          await nvim.command(`source ${filepath}`);
          let fns = await nvim.call("coc#_remote_fns", name2);
          let lowercased = fns.map((fn) => fn[0].toLowerCase() + fn.slice(1));
          for (let fn of ["init", "complete"]) {
            if (!lowercased.includes(fn)) {
              throw new Error(`function "coc#source#${name2}#${fn}" not found`);
            }
          }
          let props = await nvim.call(`coc#source#${name2}#${getMethodName("init", fns)}`, []);
          let packageJSON = {
            name: `coc-vim-source-${name2}`,
            engines: {
              coc: ">= 0.0.1"
            },
            activationEvents: props.filetypes ? props.filetypes.map((f) => `onLanguage:${f}`) : ["*"],
            contributes: {
              configuration: {
                properties: {
                  [`coc.source.${name2}.enable`]: {
                    type: "boolean",
                    default: true
                  },
                  [`coc.source.${name2}.firstMatch`]: {
                    type: "boolean",
                    default: !!props.firstMatch
                  },
                  [`coc.source.${name2}.triggerCharacters`]: {
                    type: "number",
                    default: props.triggerCharacters ?? []
                  },
                  [`coc.source.${name2}.priority`]: {
                    type: "number",
                    default: props.priority ?? 9
                  },
                  [`coc.source.${name2}.shortcut`]: {
                    type: "string",
                    default: props.shortcut ?? name2.slice(0, 3).toUpperCase(),
                    description: "Shortcut text shown in complete menu."
                  },
                  [`coc.source.${name2}.disableSyntaxes`]: {
                    type: "array",
                    default: [],
                    items: {
                      type: "string"
                    }
                  },
                  [`coc.source.${name2}.filetypes`]: {
                    type: "array",
                    default: props.filetypes || null,
                    description: "Enabled filetypes.",
                    items: {
                      type: "string"
                    }
                  }
                }
              }
            }
          };
          let isActive = false;
          let extension = {
            id: packageJSON.name,
            packageJSON,
            exports: void 0,
            extensionPath: filepath,
            activate: () => {
              isActive = true;
              let source = new VimSource({
                name: name2,
                filepath,
                isSnippet: props.isSnippet,
                sourceType: 1 /* Remote */,
                triggerOnly: !!props.triggerOnly,
                remoteFns: fns
              });
              this.addSource(source);
              return Promise.resolve();
            }
          };
          Object.defineProperty(extension, "isActive", {
            get: () => isActive
          });
          await extension_default.manager.registerInternalExtension(extension, () => {
            isActive = false;
            this.removeSource(name2);
          });
        } catch (e) {
          if (!this.nvim.isVim) {
            let lines = await readFileLines(filepath, 0, 1);
            if (lines.length > 0 && lines[0].startsWith("vim9script")) return;
          }
          void window_default.showErrorMessage(`Error on create vim source from ${filepath}: ${e}`);
          logger44.error(`Error on create vim source from ${filepath}`, e);
        }
      }
      createRemoteSources() {
        let paths = workspace_default.env.runtimepath.split(",");
        for (let path2 of paths) {
          this.createVimSources(path2).catch(logError);
        }
      }
      async createVimSources(pluginPath) {
        if (this.remoteSourcePaths.includes(pluginPath) || !pluginPath) return;
        this.remoteSourcePaths.push(pluginPath);
        let folder = path.join(pluginPath, "autoload/coc/source");
        let stat = await statAsync(folder);
        if (stat && stat.isDirectory()) {
          let arr = await (0, import_util.promisify)(fs.readdir)(folder);
          let files = arr.filter((s) => s.endsWith(".vim")).map((s) => path.join(folder, s));
          await Promise.allSettled(files.map((p) => this.createVimSourceExtension(p)));
        }
      }
      get names() {
        return Array.from(this.sourceMap.keys());
      }
      get sources() {
        return Array.from(this.sourceMap.values());
      }
      has(name2) {
        return this.names.findIndex((o) => o == name2) != -1;
      }
      getSource(name2) {
        return this.sourceMap.get(name2) ?? null;
      }
      shouldCommit(source, item, commitCharacter) {
        if (!item || source == null || commitCharacter.length === 0) return false;
        if (func(source.shouldCommit)) {
          return source.shouldCommit(item, commitCharacter);
        }
        return false;
      }
      getSources(opt) {
        let { source } = opt;
        if (source) return toArray(this.getSource(source));
        let uri = workspace_default.getUri(opt.bufnr);
        return this.getNormalSources(opt.filetype, uri);
      }
      /**
       * Get sources should be used without trigger.
       * @param {string} filetype
       * @returns {ISource[]}
       */
      getNormalSources(filetype, uri) {
        let languageIds = filetype.split(".");
        let res = this.sources.filter((source) => {
          let { filetypes, triggerOnly, documentSelector, enable } = source;
          if (!enable || triggerOnly || filetypes && !intersect(filetypes, languageIds)) return false;
          if (documentSelector && languageIds.every((filetype2) => workspace_default.match(documentSelector, { uri, languageId: filetype2 }) == 0)) return false;
          return true;
        });
        return res;
      }
      checkTrigger(source, pre, character) {
        let { triggerCharacters, triggerPatterns } = source;
        if (!isFalsyOrEmpty(triggerCharacters) && triggerCharacters.includes(character)) {
          return true;
        }
        if (!isFalsyOrEmpty(triggerPatterns) && triggerPatterns.findIndex((p) => p.test(pre)) !== -1) {
          return true;
        }
        return false;
      }
      shouldTrigger(pre, filetype, uri) {
        return this.getTriggerSources(pre, filetype, uri).length > 0;
      }
      getTriggerSources(pre, filetype, uri, disabled = []) {
        if (!pre) return [];
        let character = pre[pre.length - 1];
        let languageIds = filetype.split(".");
        return this.sources.filter((source) => {
          let { filetypes, enable, documentSelector, name: name2 } = source;
          if (disabled.includes(name2)) return false;
          if (!enable || Array.isArray(filetypes) && !intersect(filetypes, languageIds)) return false;
          if (documentSelector && languageIds.every((languageId) => workspace_default.match(documentSelector, { uri, languageId }) == 0)) {
            return false;
          }
          return this.checkTrigger(source, pre, character);
        });
      }
      addSource(source) {
        let { name: name2 } = source;
        if (this.names.includes(name2)) {
          logger44.warn(`Recreate source ${name2}`);
        }
        this.sourceMap.set(name2, source);
        return import_node4.Disposable.create(() => {
          this.removeSource(source);
        });
      }
      removeSource(source) {
        let name2 = typeof source == "string" ? source : source.name;
        let obj = typeof source === "string" ? this.sourceMap.get(source) : source;
        if (obj && typeof obj.dispose === "function") obj.dispose();
        this.sourceMap.delete(name2);
      }
      async refresh(name2) {
        for (let source of this.sources) {
          if (!name2 || source.name == name2) {
            if (typeof source.refresh === "function") {
              await Promise.resolve(source.refresh());
            }
          }
        }
      }
      toggleSource(name2) {
        let source = this.getSource(name2);
        if (source && typeof source.toggle === "function") {
          source.toggle();
        }
      }
      sourceStats() {
        let stats = [];
        let languageSourcePriority = workspace_default.initialConfiguration.get("suggest.languageSourcePriority");
        for (let item of this.sourceMap.values()) {
          if (item.name === "$words") continue;
          stats.push({
            name: item.name,
            priority: getPriority(item, languageSourcePriority),
            triggerCharacters: toArray(item.triggerCharacters),
            shortcut: toText(item.shortcut),
            filetypes: toArray(item.filetypes ?? item.documentSelector?.map((o) => string(o) ? o : o.language)),
            filepath: toText(item.filepath),
            type: getSourceType(item.sourceType),
            disabled: !item.enable
          });
        }
        return stats;
      }
      onDocumentEnter(bufnr) {
        let { sources } = this;
        for (let s of sources) {
          if (s.enable && func(s.onEnter)) {
            s.onEnter(bufnr);
          }
        }
      }
      createSource(config) {
        if (typeof config.name !== "string" || typeof config.doComplete !== "function") {
          logger44.error(`Bad config for createSource:`, config);
          throw new TypeError(`name and doComplete required for createSource`);
        }
        let source = new Source(Object.assign({ sourceType: 2 /* Service */ }, config));
        return this.addSource(source);
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
    sources_default = new Sources();
  }
});

// src/languages.ts
var eventDebounce, ProviderName, Languages, languages_default;
var init_languages = __esm({
  "src/languages.ts"() {
    "use strict";
    init_main();
    init_manager();
    init_callHierarchyManager();
    init_codeActionManager();
    init_codeLensManager();
    init_declarationManager();
    init_definitionManager();
    init_documentColorManager();
    init_documentHighlightManager();
    init_documentLinkManager();
    init_documentSymbolManager();
    init_foldingRangeManager();
    init_formatManager();
    init_formatRangeManager();
    init_hoverManager();
    init_implementationManager();
    init_inlayHintManager();
    init_inlineValueManager();
    init_linkedEditingRangeManager();
    init_onTypeFormatManager();
    init_referenceManager();
    init_renameManager();
    init_selectionRangeManager();
    init_semanticTokensManager();
    init_semanticTokensRangeManager();
    init_signatureManager();
    init_typeDefinitionManager();
    init_typeHierarchyManager();
    init_workspaceSymbolsManager();
    init_util();
    init_is();
    init_protocol();
    init_string();
    eventDebounce = getConditionValue(100, 10);
    ProviderName = /* @__PURE__ */ ((ProviderName3) => {
      ProviderName3["FormatOnType"] = "formatOnType";
      ProviderName3["Rename"] = "rename";
      ProviderName3["OnTypeEdit"] = "onTypeEdit";
      ProviderName3["DocumentLink"] = "documentLink";
      ProviderName3["DocumentColor"] = "documentColor";
      ProviderName3["FoldingRange"] = "foldingRange";
      ProviderName3["Format"] = "format";
      ProviderName3["CodeAction"] = "codeAction";
      ProviderName3["FormatRange"] = "formatRange";
      ProviderName3["Hover"] = "hover";
      ProviderName3["Signature"] = "signature";
      ProviderName3["WorkspaceSymbols"] = "workspaceSymbols";
      ProviderName3["DocumentSymbol"] = "documentSymbol";
      ProviderName3["DocumentHighlight"] = "documentHighlight";
      ProviderName3["Definition"] = "definition";
      ProviderName3["Declaration"] = "declaration";
      ProviderName3["TypeDefinition"] = "typeDefinition";
      ProviderName3["Reference"] = "reference";
      ProviderName3["Implementation"] = "implementation";
      ProviderName3["CodeLens"] = "codeLens";
      ProviderName3["SelectionRange"] = "selectionRange";
      ProviderName3["CallHierarchy"] = "callHierarchy";
      ProviderName3["SemanticTokens"] = "semanticTokens";
      ProviderName3["SemanticTokensRange"] = "semanticTokensRange";
      ProviderName3["LinkedEditing"] = "linkedEditing";
      ProviderName3["InlayHint"] = "inlayHint";
      ProviderName3["InlineValue"] = "inlineValue";
      ProviderName3["TypeHierarchy"] = "typeHierarchy";
      return ProviderName3;
    })(ProviderName || {});
    Languages = class {
      constructor() {
        this._onDidSemanticTokensRefresh = new import_node4.Emitter();
        this._onDidInlayHintRefresh = new import_node4.Emitter();
        this._onDidCodeLensRefresh = new import_node4.Emitter();
        this._onDidColorsRefresh = new import_node4.Emitter();
        this._onDidLinksRefresh = new import_node4.Emitter();
        this.onDidSemanticTokensRefresh = this._onDidSemanticTokensRefresh.event;
        this.onDidInlayHintRefresh = this._onDidInlayHintRefresh.event;
        this.onDidCodeLensRefresh = this._onDidCodeLensRefresh.event;
        this.onDidColorsRefresh = this._onDidColorsRefresh.event;
        this.onDidLinksRefresh = this._onDidLinksRefresh.event;
        this.onTypeFormatManager = new OnTypeFormatManager();
        this.documentLinkManager = new DocumentLinkManager();
        this.documentColorManager = new DocumentColorManager();
        this.foldingRangeManager = new FoldingRangeManager();
        this.renameManager = new RenameManager();
        this.formatManager = new FormatManager();
        this.codeActionManager = new CodeActionManager();
        this.workspaceSymbolsManager = new WorkspaceSymbolManager();
        this.formatRangeManager = new FormatRangeManager();
        this.hoverManager = new HoverManager();
        this.signatureManager = new SignatureManager();
        this.documentSymbolManager = new DocumentSymbolManager();
        this.documentHighlightManager = new DocumentHighlightManager();
        this.definitionManager = new DefinitionManager();
        this.declarationManager = new DeclarationManager();
        this.typeDefinitionManager = new TypeDefinitionManager();
        this.typeHierarchyManager = new TypeHierarchyManager();
        this.referenceManager = new ReferenceManager();
        this.implementationManager = new ImplementationManager();
        this.codeLensManager = new CodeLensManager();
        this.selectionRangeManager = new SelectionRangeManager();
        this.callHierarchyManager = new CallHierarchyManager();
        this.semanticTokensManager = new SemanticTokensManager();
        this.semanticTokensRangeManager = new SemanticTokensRangeManager();
        this.linkedEditingManager = new LinkedEditingRangeManager();
        this.inlayHintManager = new InlayHintManger();
        this.inlineValueManager = new InlineValueManager();
        this.registerReferenceProvider = this.registerReferencesProvider;
        this.registerDocumentRangeFormattingEditProvider = this.registerDocumentRangeFormatProvider;
        this.registerDocumentFormattingEditProvider = this.registerDocumentFormatProvider;
      }
      hasFormatProvider(doc) {
        if (this.formatManager.hasProvider(doc)) {
          return true;
        }
        if (this.formatRangeManager.hasProvider(doc)) {
          return true;
        }
        return false;
      }
      registerOnTypeFormattingEditProvider(selector, provider, triggerCharacters) {
        return this.onTypeFormatManager.register(selector, provider, triggerCharacters);
      }
      registerCompletionItemProvider(name2, shortcut, selector, provider, triggerCharacters = [], priority, allCommitCharacters) {
        selector = string(selector) ? [{ language: selector }] : selector;
        let sources = (init_sources2(), __toCommonJS(sources_exports)).default;
        sources.removeSource(name2);
        return sources.createLanguageSource(name2, shortcut, selector, provider, triggerCharacters, priority, allCommitCharacters);
      }
      registerCodeActionProvider(selector, provider, clientId, codeActionKinds) {
        return this.codeActionManager.register(selector, provider, clientId, codeActionKinds);
      }
      registerHoverProvider(selector, provider) {
        return this.hoverManager.register(selector, provider);
      }
      registerSelectionRangeProvider(selector, provider) {
        return this.selectionRangeManager.register(selector, provider);
      }
      registerSignatureHelpProvider(selector, provider, triggerCharacters) {
        return this.signatureManager.register(selector, provider, triggerCharacters);
      }
      registerDocumentSymbolProvider(selector, provider, metadata) {
        if (metadata) provider.meta = metadata;
        return this.documentSymbolManager.register(selector, provider);
      }
      registerFoldingRangeProvider(selector, provider) {
        return this.foldingRangeManager.register(selector, provider);
      }
      registerDocumentHighlightProvider(selector, provider) {
        return this.documentHighlightManager.register(selector, provider);
      }
      registerDocumentLinkProvider(selector, provider) {
        this._onDidLinksRefresh.fire(selector);
        let disposable = this.documentLinkManager.register(selector, provider);
        return import_node4.Disposable.create(() => {
          disposable.dispose();
          this._onDidLinksRefresh.fire(selector);
        });
      }
      registerDocumentColorProvider(selector, provider) {
        this._onDidColorsRefresh.fire(selector);
        let disposable = this.documentColorManager.register(selector, provider);
        return import_node4.Disposable.create(() => {
          disposable.dispose();
          this._onDidColorsRefresh.fire(selector);
        });
      }
      registerDefinitionProvider(selector, provider) {
        return this.definitionManager.register(selector, provider);
      }
      registerDeclarationProvider(selector, provider) {
        return this.declarationManager.register(selector, provider);
      }
      registerTypeDefinitionProvider(selector, provider) {
        return this.typeDefinitionManager.register(selector, provider);
      }
      registerTypeHierarchyProvider(selector, provider) {
        return this.typeHierarchyManager.register(selector, provider);
      }
      registerImplementationProvider(selector, provider) {
        return this.implementationManager.register(selector, provider);
      }
      registerReferencesProvider(selector, provider) {
        return this.referenceManager.register(selector, provider);
      }
      registerRenameProvider(selector, provider) {
        return this.renameManager.register(selector, provider);
      }
      registerWorkspaceSymbolProvider(provider) {
        if (arguments.length > 1 && func(arguments[1].provideWorkspaceSymbols)) {
          provider = arguments[1];
        }
        return this.workspaceSymbolsManager.register(provider);
      }
      registerDocumentFormatProvider(selector, provider, priority = 0) {
        return this.formatManager.register(selector, provider, priority);
      }
      registerDocumentRangeFormatProvider(selector, provider, priority = 0) {
        return this.formatRangeManager.register(selector, provider, priority);
      }
      registerCallHierarchyProvider(selector, provider) {
        return this.callHierarchyManager.register(selector, provider);
      }
      registerCodeLensProvider(selector, provider) {
        return this.registerProviderWithEvent(selector, provider, "onDidChangeCodeLenses", this.codeLensManager, this._onDidCodeLensRefresh);
      }
      registerDocumentSemanticTokensProvider(selector, provider, legend) {
        return this.registerProviderWithEvent(selector, provider, "onDidChangeSemanticTokens", this.semanticTokensManager, this._onDidSemanticTokensRefresh, legend);
      }
      registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {
        let timer = setTimeout(() => {
          this._onDidSemanticTokensRefresh.fire(selector);
        }, eventDebounce);
        let disposable = this.semanticTokensRangeManager.register(selector, provider, legend);
        return import_node4.Disposable.create(() => {
          clearTimeout(timer);
          disposable.dispose();
          this._onDidSemanticTokensRefresh.fire(selector);
        });
      }
      registerInlayHintsProvider(selector, provider) {
        return this.registerProviderWithEvent(selector, provider, "onDidChangeInlayHints", this.inlayHintManager, this._onDidInlayHintRefresh);
      }
      registerInlineValuesProvider(selector, provider) {
        return this.inlineValueManager.register(selector, provider);
      }
      registerLinkedEditingRangeProvider(selector, provider) {
        return this.linkedEditingManager.register(selector, provider);
      }
      shouldTriggerSignatureHelp(document2, triggerCharacter) {
        return this.signatureManager.shouldTrigger(document2, triggerCharacter);
      }
      async getHover(document2, position, token) {
        return await this.hoverManager.provideHover(document2, position, token);
      }
      async getSignatureHelp(document2, position, token, context) {
        return await this.signatureManager.provideSignatureHelp(document2, position, token, context);
      }
      async getDefinition(document2, position, token) {
        return await this.definitionManager.provideDefinition(document2, position, token);
      }
      async getDefinitionLinks(document2, position, token) {
        return await this.definitionManager.provideDefinitionLinks(document2, position, token);
      }
      async getDeclaration(document2, position, token) {
        return await this.declarationManager.provideDeclaration(document2, position, token);
      }
      async getTypeDefinition(document2, position, token) {
        return await this.typeDefinitionManager.provideTypeDefinition(document2, position, token);
      }
      async getImplementation(document2, position, token) {
        return await this.implementationManager.provideImplementations(document2, position, token);
      }
      async getReferences(document2, context, position, token) {
        return await this.referenceManager.provideReferences(document2, position, context, token);
      }
      async getDocumentSymbol(document2, token) {
        return await this.documentSymbolManager.provideDocumentSymbols(document2, token);
      }
      getDocumentSymbolMetadata(document2) {
        return this.documentSymbolManager.getMetaData(document2);
      }
      async getSelectionRanges(document2, positions, token) {
        return await this.selectionRangeManager.provideSelectionRanges(document2, positions, token);
      }
      async getWorkspaceSymbols(query, token) {
        return await this.workspaceSymbolsManager.provideWorkspaceSymbols(toText(query), token);
      }
      async resolveWorkspaceSymbol(symbol, token) {
        return await this.workspaceSymbolsManager.resolveWorkspaceSymbol(symbol, token);
      }
      async prepareRename(document2, position, token) {
        return await this.renameManager.prepareRename(document2, position, token);
      }
      async provideRenameEdits(document2, position, newName, token) {
        return await this.renameManager.provideRenameEdits(document2, position, newName, token);
      }
      async provideDocumentFormattingEdits(document2, options2, token) {
        let res = await this.formatManager.provideDocumentFormattingEdits(document2, options2, token);
        if (res == null) {
          let hasRangeFormatter = this.formatRangeManager.hasProvider(document2);
          if (!hasRangeFormatter) return null;
          let end = document2.positionAt(document2.getText().length);
          let range = Range.create(Position.create(0, 0), end);
          return await this.provideDocumentRangeFormattingEdits(document2, range, options2, token);
        }
        return res;
      }
      async provideDocumentRangeFormattingEdits(document2, range, options2, token) {
        return await this.formatRangeManager.provideDocumentRangeFormattingEdits(document2, range, options2, token);
      }
      async getCodeActions(document2, range, context, token) {
        return await this.codeActionManager.provideCodeActions(document2, range, context, token);
      }
      async getDocumentHighLight(document2, position, token) {
        return await this.documentHighlightManager.provideDocumentHighlights(document2, position, token);
      }
      async getDocumentLinks(document2, token) {
        return await this.documentLinkManager.provideDocumentLinks(document2, token);
      }
      async resolveDocumentLink(link, token) {
        return await this.documentLinkManager.resolveDocumentLink(link, token);
      }
      async provideDocumentColors(document2, token) {
        return await this.documentColorManager.provideDocumentColors(document2, token);
      }
      async provideFoldingRanges(document2, context, token) {
        return await this.foldingRangeManager.provideFoldingRanges(document2, context, token);
      }
      async provideColorPresentations(color, document2, token) {
        return await this.documentColorManager.provideColorPresentations(color, document2, token);
      }
      async getCodeLens(document2, token) {
        return await this.codeLensManager.provideCodeLenses(document2, token);
      }
      async resolveCodeLens(codeLens, token) {
        return await this.codeLensManager.resolveCodeLens(codeLens, token);
      }
      async resolveCodeAction(codeAction, token) {
        return await this.codeActionManager.resolveCodeAction(codeAction, token);
      }
      async provideDocumentOnTypeEdits(character, document2, position, token) {
        return this.onTypeFormatManager.onCharacterType(character, document2, position, token);
      }
      canFormatOnType(character, document2) {
        return this.onTypeFormatManager.couldTrigger(document2, character) != null;
      }
      async prepareCallHierarchy(document2, position, token) {
        return this.callHierarchyManager.prepareCallHierarchy(document2, position, token);
      }
      async provideIncomingCalls(document2, item, token) {
        return this.callHierarchyManager.provideCallHierarchyIncomingCalls(document2, item, token);
      }
      async provideOutgoingCalls(document2, item, token) {
        return this.callHierarchyManager.provideCallHierarchyOutgoingCalls(document2, item, token);
      }
      getLegend(document2, range) {
        if (range) return this.semanticTokensRangeManager.getLegend(document2);
        return this.semanticTokensManager.getLegend(document2);
      }
      hasSemanticTokensEdits(document2) {
        return this.semanticTokensManager.hasSemanticTokensEdits(document2);
      }
      async provideDocumentSemanticTokens(document2, token) {
        return this.semanticTokensManager.provideDocumentSemanticTokens(document2, token);
      }
      async provideDocumentSemanticTokensEdits(document2, previousResultId, token) {
        return this.semanticTokensManager.provideDocumentSemanticTokensEdits(document2, previousResultId, token);
      }
      async provideDocumentRangeSemanticTokens(document2, range, token) {
        return this.semanticTokensRangeManager.provideDocumentRangeSemanticTokens(document2, range, token);
      }
      async provideInlayHints(document2, range, token) {
        return this.inlayHintManager.provideInlayHints(document2, range, token);
      }
      async resolveInlayHint(hint, token) {
        return this.inlayHintManager.resolveInlayHint(hint, token);
      }
      async provideLinkedEdits(document2, position, token) {
        return this.linkedEditingManager.provideLinkedEditingRanges(document2, position, token);
      }
      async provideInlineValues(document2, viewPort, context, token) {
        return this.inlineValueManager.provideInlineValues(document2, viewPort, context, token);
      }
      async prepareTypeHierarchy(document2, position, token) {
        return this.typeHierarchyManager.prepareTypeHierarchy(document2, position, token);
      }
      async provideTypeHierarchySupertypes(item, token) {
        return this.typeHierarchyManager.provideTypeHierarchySupertypes(item, token);
      }
      async provideTypeHierarchySubtypes(item, token) {
        return this.typeHierarchyManager.provideTypeHierarchySubtypes(item, token);
      }
      createDiagnosticCollection(owner) {
        return manager_default.create(owner);
      }
      registerProviderWithEvent(selector, provider, key, manager, emitter, extra) {
        let disposables = [];
        let timer = setTimeout(() => {
          emitter.fire(selector);
        }, eventDebounce);
        disposables.push(import_node4.Disposable.create(() => {
          clearTimeout(timer);
        }));
        if (func(provider[key])) {
          disposables.push(provider[key](() => {
            clearTimeout(timer);
            emitter.fire(selector);
          }));
        }
        disposables.push(manager.register(selector, provider, extra));
        return import_node4.Disposable.create(() => {
          disposeAll(disposables);
          emitter.fire(selector);
        });
      }
      hasProvider(id2, document2) {
        switch (id2) {
          case "onTypeEdit" /* OnTypeEdit */:
          case "formatOnType" /* FormatOnType */:
            return this.onTypeFormatManager.hasProvider(document2);
          case "rename" /* Rename */:
            return this.renameManager.hasProvider(document2);
          case "documentLink" /* DocumentLink */:
            return this.documentLinkManager.hasProvider(document2);
          case "documentColor" /* DocumentColor */:
            return this.documentColorManager.hasProvider(document2);
          case "foldingRange" /* FoldingRange */:
            return this.foldingRangeManager.hasProvider(document2);
          case "format" /* Format */:
            return this.formatManager.hasProvider(document2) || this.formatRangeManager.hasProvider(document2);
          case "codeAction" /* CodeAction */:
            return this.codeActionManager.hasProvider(document2);
          case "workspaceSymbols" /* WorkspaceSymbols */:
            return this.workspaceSymbolsManager.hasProvider();
          case "formatRange" /* FormatRange */:
            return this.formatRangeManager.hasProvider(document2);
          case "hover" /* Hover */:
            return this.hoverManager.hasProvider(document2);
          case "signature" /* Signature */:
            return this.signatureManager.hasProvider(document2);
          case "documentSymbol" /* DocumentSymbol */:
            return this.documentSymbolManager.hasProvider(document2);
          case "documentHighlight" /* DocumentHighlight */:
            return this.documentHighlightManager.hasProvider(document2);
          case "definition" /* Definition */:
            return this.definitionManager.hasProvider(document2);
          case "declaration" /* Declaration */:
            return this.declarationManager.hasProvider(document2);
          case "typeDefinition" /* TypeDefinition */:
            return this.typeDefinitionManager.hasProvider(document2);
          case "reference" /* Reference */:
            return this.referenceManager.hasProvider(document2);
          case "implementation" /* Implementation */:
            return this.implementationManager.hasProvider(document2);
          case "codeLens" /* CodeLens */:
            return this.codeLensManager.hasProvider(document2);
          case "selectionRange" /* SelectionRange */:
            return this.selectionRangeManager.hasProvider(document2);
          case "callHierarchy" /* CallHierarchy */:
            return this.callHierarchyManager.hasProvider(document2);
          case "semanticTokens" /* SemanticTokens */:
            return this.semanticTokensManager.hasProvider(document2);
          case "semanticTokensRange" /* SemanticTokensRange */:
            return this.semanticTokensRangeManager.hasProvider(document2);
          case "linkedEditing" /* LinkedEditing */:
            return this.linkedEditingManager.hasProvider(document2);
          case "inlayHint" /* InlayHint */:
            return this.inlayHintManager.hasProvider(document2);
          case "inlineValue" /* InlineValue */:
            return this.inlineValueManager.hasProvider(document2);
          case "typeHierarchy" /* TypeHierarchy */:
            return this.typeHierarchyManager.hasProvider(document2);
          default:
            return false;
        }
      }
    };
    languages_default = new Languages();
  }
});

// src/completion/wordDistance.ts
var WordDistance;
var init_wordDistance = __esm({
  "src/completion/wordDistance.ts"() {
    "use strict";
    init_main();
    init_events();
    init_languages();
    init_array();
    init_object();
    init_is();
    init_position();
    init_workspace();
    init_util();
    WordDistance = class _WordDistance {
      static {
        this.None = new class extends _WordDistance {
          distance() {
            return 0;
          }
        }();
      }
      static async create(localityBonus, opt, token) {
        let { position } = opt;
        let cursor = [opt.linenr, opt.colnr];
        if (!localityBonus) return _WordDistance.None;
        let doc = workspace_default.getDocument(opt.bufnr);
        const selectionRanges = await languages_default.getSelectionRanges(doc.textDocument, [position], token);
        if (!selectionRanges || token.isCancellationRequested) return _WordDistance.None;
        let ranges = [];
        const iterate = (r) => {
          if (r && r.range.end.line - r.range.start.line < 2e3) {
            ranges.unshift(r.range);
            iterate(r.parent);
          }
        };
        iterate(toArray(selectionRanges)[0]);
        let wordRanges = ranges.length > 0 ? await Promise.race([waitWithToken(100, token), workspace_default.computeWordRanges(opt.bufnr, ranges[0], token)]) : void 0;
        if (!objectLiteral(wordRanges)) return _WordDistance.None;
        delete wordRanges[opt.word];
        return new class extends _WordDistance {
          // Unlike VSCode, word insert position is used here
          distance(anchor, item) {
            if (!equals([events_default.cursor.lnum, events_default.cursor.col], cursor)) {
              return 0;
            }
            if (item.kind === CompletionItemKind.Keyword || toObject(item.source)["name"] === "snippets") {
              return 2 << 20;
            }
            const wordLines = wordRanges[item.word];
            if (isFalsyOrEmpty(wordLines)) {
              return 2 << 20;
            }
            const idx = binarySearch(wordLines, Range.create(anchor, anchor), compareRangesUsingStarts);
            const bestWordRange = idx >= 0 ? wordLines[idx] : wordLines[Math.max(0, ~idx - 1)];
            let blockDistance = ranges.length;
            for (const range of ranges) {
              if (!rangeInRange(bestWordRange, range)) {
                break;
              }
              blockDistance -= 1;
            }
            return blockDistance;
          }
        }();
      }
    };
  }
});

// src/completion/complete.ts
function sortItems(emptyInput, defaultSortMethod, a, b) {
  let sa = a.sortText;
  let sb = b.sortText;
  if (a.score !== b.score) return b.score - a.score;
  if (a.priority !== b.priority) return b.priority - a.priority;
  if (a.source === b.source && sa !== sb) return sa < sb ? -1 : 1;
  if (a.localBonus !== b.localBonus) return b.localBonus - a.localBonus;
  if (emptyInput) return b.character - a.character;
  switch (defaultSortMethod) {
    case "none" /* None */:
      return 0;
    case "alphabetical" /* Alphabetical */:
      return a.filterText.localeCompare(b.filterText);
    case "length" /* Length */:
    default:
      return a.filterText.length - b.filterText.length;
  }
}
var logger45, MAX_DISTANCE, MIN_TIMEOUT, MAX_TIMEOUT, MAX_TRIGGER_WAIT, WORD_SOURCES, Complete;
var init_complete = __esm({
  "src/completion/complete.ts"() {
    "use strict";
    init_main();
    init_logger();
    init_util();
    init_array();
    init_filter();
    init_is();
    init_numbers();
    init_protocol();
    init_string();
    init_workspace();
    init_types2();
    init_util4();
    init_wordDistance();
    logger45 = createLogger("completion-complete");
    MAX_DISTANCE = 2 << 20;
    MIN_TIMEOUT = 50;
    MAX_TIMEOUT = 15e3;
    MAX_TRIGGER_WAIT = 200;
    WORD_SOURCES = /* @__PURE__ */ new Set(["buffer", "around", "word"]);
    Complete = class {
      constructor(option, document2, config, sources) {
        this.option = option;
        this.document = document2;
        this.config = config;
        this.sources = sources;
        // identify this complete
        this.results = /* @__PURE__ */ new Map();
        this._input = "";
        this._completing = false;
        this.names = [];
        this.cid = 0;
        this.minCharacter = Number.MAX_SAFE_INTEGER;
        this.completingSources = /* @__PURE__ */ new Set();
        this._onDidRefresh = new import_node4.Emitter();
        this.tokenSources = /* @__PURE__ */ new Set();
        this.tokensInfo = /* @__PURE__ */ new WeakMap();
        this.itemsMap = /* @__PURE__ */ new WeakMap();
        this.onDidRefresh = this._onDidRefresh.event;
        this.inputStart = characterIndex(option.line, option.col);
        this.timeout = clamp(this.config.timeout, MIN_TIMEOUT, MAX_TIMEOUT);
        sources.sort((a, b) => (b.priority ?? 99) - (a.priority ?? 99));
        this.names = sources.map((o) => o.name);
        this.asciiMatch = config.asciiMatch && useAscii(option.input);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      // trigger texts starts at character
      getTrigger(character) {
        let { linenr, col } = this.option;
        let line = this.document.getline(linenr - 1);
        let pre = line.slice(0, characterIndex(line, col)) + this.input;
        return pre.slice(character);
      }
      fireRefresh(waitTime) {
        clearTimeout(this.timer);
        if (!waitTime) {
          process.nextTick(() => {
            this._onDidRefresh.fire();
          });
        } else {
          this.timer = setTimeout(() => {
            this._onDidRefresh.fire();
          }, waitTime);
        }
      }
      get totalLength() {
        let len = 0;
        for (let result of this.results.values()) {
          len += result.items.length;
        }
        return len;
      }
      resolveItem(item) {
        if (!item) return void 0;
        return { source: item.source, item: this.itemsMap.get(item) };
      }
      get isCompleting() {
        return this._completing;
      }
      get input() {
        return this._input;
      }
      get isEmpty() {
        return this.results.size === 0;
      }
      get hasInComplete() {
        for (let result of this.results.values()) {
          if (result.isIncomplete) return true;
        }
        return false;
      }
      getIncompleteSources() {
        return this.sources.filter((s) => {
          let res = this.results.get(s.name);
          return res && res.isIncomplete === true;
        });
      }
      async doComplete() {
        let tokenSource = this.createTokenSource(false);
        let token = tokenSource.token;
        let res = await Promise.all([
          this.nvim.call("coc#util#synname", []),
          this.nvim.call("coc#_suggest_variables", []),
          this.document.patchChange()
        ]);
        if (token.isCancellationRequested) return;
        this.option.synname = res[0];
        let variables = res[1];
        if (variables.disable) {
          logger45.warn("suggest cancelled by b:coc_suggest_disable");
          return true;
        }
        if (!isFalsyOrEmpty(variables.disabled_sources)) {
          this.sources = this.sources.filter((s) => !variables.disabled_sources.includes(s.name));
          if (this.sources.length === 0) {
            logger45.warn("suggest cancelled by b:coc_disabled_sources");
            return true;
          }
        }
        if (!isFalsyOrEmpty(variables.blacklist) && variables.blacklist.includes(this.option.input)) {
          logger45.warn("suggest cancelled by b:coc_suggest_blacklist");
          return true;
        }
        void WordDistance.create(this.config.localityBonus, this.option, token).then((instance2) => {
          this.wordDistance = instance2;
        });
        await waitWithToken(clamp(this.config.triggerCompletionWait, 0, MAX_TRIGGER_WAIT), tokenSource.token);
        await this.completeSources(this.sources, tokenSource, this.cid);
      }
      async completeSources(sources, tokenSource, cid) {
        const token = tokenSource.token;
        if (token.isCancellationRequested) return;
        this._completing = true;
        const remains = new Set(sources.map((s) => s.name));
        let timer;
        let disposable;
        let tp = new Promise((resolve) => {
          disposable = token.onCancellationRequested(() => {
            clearTimeout(timer);
            resolve();
          });
          timer = setTimeout(() => {
            let names = Array.from(remains);
            disposable.dispose();
            tokenSource.cancel();
            logger45.warn(`Completion timeout after ${this.timeout}ms`, names);
            this.nvim.setVar(`coc_timeout_sources`, names, true);
            resolve();
          }, this.timeout);
        });
        const range = this.getDefaultRange();
        let promises = sources.map((s) => this.completeSource(s, range, token).then((added) => {
          remains.delete(s.name);
          if (token.isCancellationRequested) return;
          if (this.completingSources.size === 0) {
            this.fireRefresh(0);
          } else if (added) {
            this.fireRefresh(16);
          }
        }));
        await Promise.race([tp, Promise.allSettled(promises)]);
        this.tokenSources.delete(tokenSource);
        disposable.dispose();
        clearTimeout(timer);
        if (cid === this.cid) this._completing = false;
      }
      async completeSource(source, range, token) {
        let opt = Object.assign({}, this.option);
        let { asciiMatch } = this;
        const insertMode = this.config.insertMode;
        const sourceName = source.name;
        let added = false;
        this.completingSources.add(sourceName);
        try {
          if (func(source.shouldComplete)) {
            let shouldRun = await Promise.resolve(source.shouldComplete(opt));
            if (!shouldRun || token.isCancellationRequested) return;
          }
          const start = Date.now();
          const map = this.itemsMap;
          await new Promise((resolve, reject) => {
            Promise.resolve(source.doComplete(opt, token)).then((result) => {
              if (token.isCancellationRequested) {
                resolve(void 0);
                return;
              }
              let len = result ? result.items.length : 0;
              logger45.debug(`Source "${sourceName}" finished with ${len} items ms cost:`, Date.now() - start);
              if (len > 0) {
                if (number(result.startcol)) {
                  let line = opt.linenr - 1;
                  range = Range.create(line, characterIndex(opt.line, result.startcol), line, range.end.character);
                }
                const priority = getPriority(source, this.config.languageSourcePriority);
                const option = { source, insertMode, priority, asciiMatch, itemDefaults: result.itemDefaults, range };
                const converter = new Converter(this.inputStart, option, opt);
                const items = result.items.reduce((items2, item) => {
                  let completeItem = converter.convertToDurationItem(item);
                  if (!completeItem) {
                    logger45.error(`Unexpected completion item from ${sourceName}:`, item);
                    return items2;
                  }
                  map.set(completeItem, item);
                  items2.push(completeItem);
                  return items2;
                }, []);
                this.minCharacter = Math.min(this.minCharacter, converter.minCharacter);
                this.results.set(sourceName, { items, isIncomplete: result.isIncomplete === true });
                added = true;
              } else {
                this.results.delete(sourceName);
              }
              resolve();
            }, (err) => {
              reject(err);
            });
          });
        } catch (err) {
          logger45.error("Complete error:", source.name, err);
        }
        this.completingSources.delete(sourceName);
        return added;
      }
      async completeInComplete(resumeInput) {
        let { document: document2 } = this;
        this.cancelInComplete();
        let tokenSource = this.createTokenSource(true);
        await document2.patchChange();
        let { input, colnr, linenr, followWord, position } = this.option;
        Object.assign(this.option, {
          word: resumeInput + followWord,
          input: resumeInput,
          line: document2.getline(linenr - 1),
          position: { line: position.line, character: position.character + resumeInput.length - input.length },
          colnr: colnr + (resumeInput.length - input.length),
          triggerCharacter: void 0,
          triggerForInComplete: true
        });
        this.cid++;
        const sources = this.getIncompleteSources();
        await this.completeSources(sources, tokenSource, this.cid);
      }
      filterItems(input) {
        let { results, names, option, inputStart } = this;
        this._input = input;
        let len = input.length;
        let { maxItemCount, defaultSortMethod, removeDuplicateItems, removeCurrentWord } = this.config;
        let arr = [];
        let words = /* @__PURE__ */ new Set();
        const emptyInput = len == 0;
        const lowInput = input.toLowerCase();
        const scoreFn = !this.config.filterGraceful || this.totalLength > 2e3 ? fuzzyScore : fuzzyScoreGracefulAggressive;
        const scoreOption = { boostFullMatch: true, firstMatchCanBeWeak: false };
        const anchor = Position.create(option.linenr - 1, inputStart);
        for (let name2 of names) {
          let result = results.get(name2);
          if (!result) continue;
          let isWord = WORD_SOURCES.has(name2);
          let items = result.items;
          for (let idx = 0; idx < items.length; idx++) {
            let item = items[idx];
            let { word, filterText, dup } = item;
            if (dup !== true && words.has(word)) continue;
            if (removeCurrentWord && isWord && word === input) continue;
            if (removeDuplicateItems && item.isSnippet !== true && words.has(word)) continue;
            let fuzzyResult;
            if (!emptyInput) {
              scoreOption.firstMatchCanBeWeak = item.delta === 0 && item.character !== inputStart;
              if (item.delta > 0) {
                let prev = filterText.slice(0, item.delta);
                fuzzyResult = scoreFn(prev + input, prev.toLowerCase() + lowInput, 0, filterText, filterText.toLowerCase(), 0, scoreOption);
              } else {
                fuzzyResult = scoreFn(input, lowInput, 0, filterText, filterText.toLowerCase(), 0, scoreOption);
              }
              if (fuzzyResult == null) continue;
              item.score = fuzzyResult[0];
              item.positions = fuzzyResult;
              if (this.wordDistance) item.localBonus = MAX_DISTANCE - this.wordDistance.distance(anchor, item);
            } else if (item.character < inputStart) {
              let trigger = option.line.slice(item.character, inputStart);
              scoreOption.firstMatchCanBeWeak = true;
              fuzzyResult = anyScore(trigger, trigger.toLowerCase(), 0, filterText, filterText.toLowerCase(), 0, scoreOption);
              item.score = fuzzyResult[0];
              item.positions = fuzzyResult;
            } else {
              item.score = 0;
              item.positions = void 0;
            }
            words.add(word);
            arr.push(item);
          }
        }
        arr.sort(sortItems.bind(null, emptyInput, defaultSortMethod));
        return this.limitCompleteItems(arr.slice(0, maxItemCount));
      }
      async filterResults(input) {
        if (input.length > this.option.input.length && this.hasInComplete) {
          this.fireRefresh(30);
          void this.completeInComplete(input);
          return void 0;
        }
        clearTimeout(this.timer);
        return this.filterItems(input);
      }
      limitCompleteItems(items) {
        let { highPrioritySourceLimit, lowPrioritySourceLimit } = this.config;
        if (!highPrioritySourceLimit && !lowPrioritySourceLimit) return items;
        let counts = /* @__PURE__ */ new Map();
        return items.filter((item) => {
          let { priority, source } = item;
          let isLow = priority < 90;
          let curr = counts.get(source) || 0;
          if (lowPrioritySourceLimit && isLow && curr == lowPrioritySourceLimit || highPrioritySourceLimit && !isLow && curr == highPrioritySourceLimit) {
            return false;
          }
          counts.set(source, curr + 1);
          return true;
        });
      }
      getDefaultRange() {
        let { insertMode } = this.config;
        let { linenr, followWord, position } = this.option;
        let line = linenr - 1;
        let end = position.character + (insertMode == "replace" /* Replace */ ? followWord.length : 0);
        return Range.create(line, this.inputStart, line, end);
      }
      createTokenSource(isIncomplete) {
        let tokenSource = new import_node4.CancellationTokenSource();
        this.tokenSources.add(tokenSource);
        tokenSource.token.onCancellationRequested(() => {
          this.tokenSources.delete(tokenSource);
        });
        this.tokensInfo.set(tokenSource, isIncomplete);
        return tokenSource;
      }
      cancelInComplete() {
        let { tokenSources, tokensInfo } = this;
        for (let tokenSource of Array.from(tokenSources)) {
          if (tokensInfo.get(tokenSource) === true) {
            tokenSource.cancel();
          }
        }
      }
      cancel() {
        let { tokenSources, timer } = this;
        clearTimeout(timer);
        for (let tokenSource of Array.from(tokenSources)) {
          tokenSource.cancel();
        }
        tokenSources.clear();
        this._completing = false;
      }
      dispose() {
        this.cancel();
        this.results.clear();
        this._onDidRefresh.dispose();
      }
    };
  }
});

// src/completion/floating.ts
var logger46, RESOLVE_TIMEOUT, Floating;
var init_floating = __esm({
  "src/completion/floating.ts"() {
    "use strict";
    init_logger();
    init_markdown();
    init_util();
    init_errors();
    init_is();
    init_protocol();
    init_workspace();
    init_util4();
    logger46 = createLogger("completion-floating");
    RESOLVE_TIMEOUT = getConditionValue(500, 50);
    Floating = class {
      constructor(config) {
        this.config = config;
      }
      async resolveItem(source, item, opt, showDocs, detailRendered = false) {
        this.cancel();
        if (func(source.onCompleteResolve)) {
          try {
            await this.requestWithToken((token) => {
              return Promise.resolve(source.onCompleteResolve(item, opt, token));
            });
          } catch (e) {
            if (isCancellationError(e)) return;
            logger46.error(`Error on resolve complete item from ${source.name}:`, item, e);
          }
        }
        if (showDocs) {
          this.show(getDocumentaions(item, opt.filetype, detailRendered));
        }
      }
      show(docs) {
        let config = this.config.floatConfig;
        docs = docs.filter((o) => o.content.trim().length > 0);
        if (docs.length === 0) {
          this.close();
        } else {
          const markdownPreference = workspace_default.configurations.markdownPreference;
          let { lines, codes, highlights } = parseDocuments(docs, markdownPreference);
          let opts = {
            codes,
            highlights,
            highlight: config.highlight ?? "CocFloating",
            maxWidth: config.maxWidth || 80,
            rounded: config.rounded ? 1 : 0,
            focusable: config.focusable === true ? 1 : 0
          };
          if (string(config.title)) opts.title = config.title;
          if (config.shadow) opts.shadow = 1;
          if (config.border) opts.border = [1, 1, 1, 1];
          if (config.borderhighlight) opts.borderhighlight = config.borderhighlight;
          if (typeof config.winblend === "number") opts.winblend = config.winblend;
          let { nvim } = workspace_default;
          nvim.call("coc#dialog#create_pum_float", [lines, opts], true);
          nvim.redrawVim();
        }
      }
      close() {
        workspace_default.nvim.call("coc#pum#close_detail", [], true);
        workspace_default.nvim.redrawVim();
      }
      cancel() {
        if (this.resolveTokenSource) {
          this.resolveTokenSource.cancel();
          this.resolveTokenSource = void 0;
        }
      }
      requestWithToken(fn) {
        let tokenSource = this.resolveTokenSource = new import_node4.CancellationTokenSource();
        return new Promise((resolve, reject) => {
          let called = false;
          let onFinish = (err) => {
            if (called) return;
            called = true;
            disposable.dispose();
            clearTimeout(timer);
            if (this.resolveTokenSource === tokenSource) {
              this.resolveTokenSource = void 0;
            }
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          };
          let timer = setTimeout(() => {
            tokenSource.cancel();
          }, RESOLVE_TIMEOUT);
          let disposable = tokenSource.token.onCancellationRequested(() => {
            onFinish(new CancellationError());
          });
          fn(tokenSource.token).then(() => {
            onFinish();
          }, (e) => {
            onFinish(e);
          });
        });
      }
    };
  }
});

// src/completion/pum.ts
function positionHighlights(hls, label, positions, pre, line, max) {
  for (let span of matchSpansReverse(label, positions, 2, max)) {
    hls.push({
      hlGroup: "CocPumSearch" /* PumSearch */,
      lnum: line,
      colStart: pre + span[0],
      colEnd: pre + span[1]
    });
  }
}
function getInsertWord(word, codes, start) {
  if (codes.length === 0) return word;
  for (let i = start; i < word.length; i++) {
    if (codes.includes(word.charCodeAt(i))) {
      return word.slice(0, i);
    }
  }
  return word;
}
function prefixWord(word, character, line, minCharacter) {
  return minCharacter < character ? line.slice(minCharacter, character) + word : word;
}
var PopupMenu;
var init_pum = __esm({
  "src/completion/pum.ts"() {
    "use strict";
    init_fuzzyMatch();
    init_array();
    init_filter();
    init_is();
    init_numbers();
    init_string();
    init_workspace();
    init_util4();
    PopupMenu = class {
      constructor(config, mruLoader) {
        this.config = config;
        this.mruLoader = mruLoader;
        this._search = "";
      }
      get nvim() {
        return workspace_default.nvim;
      }
      get search() {
        return this._search;
      }
      reset() {
        this._search = "";
        this._pumConfig = void 0;
      }
      get pumConfig() {
        if (this._pumConfig) return this._pumConfig;
        let { floatConfig, pumFloatConfig, reversePumAboveCursor } = this.config;
        if (!pumFloatConfig) pumFloatConfig = floatConfig;
        let obj = {};
        if (pumFloatConfig.border) {
          obj.border = [1, 1, 1, 1];
          obj.rounded = pumFloatConfig.rounded ? 1 : 0;
          obj.borderhighlight = pumFloatConfig.borderhighlight ?? "CocFloatBorder";
        }
        if (string(pumFloatConfig.highlight)) obj.highlight = pumFloatConfig.highlight;
        if (number(pumFloatConfig.winblend)) obj.winblend = pumFloatConfig.winblend;
        if (string(pumFloatConfig.title)) obj.title = pumFloatConfig.title;
        obj.shadow = pumFloatConfig.shadow === true;
        obj.reverse = reversePumAboveCursor === true;
        this._pumConfig = obj;
        return obj;
      }
      stringWidth(text, cache = false) {
        return workspace_default.getDisplayWidth(text, cache);
      }
      show(items, search, option) {
        this._search = search;
        let { noselect, enablePreselect, invalidInsertCharacters, selection, virtualText, kindMap, defaultKindText } = this.config;
        const invalidInsertCodes = invalidInsertCharacters.map((ch) => ch.charCodeAt(0));
        let selectedIndex = enablePreselect ? items.findIndex((o) => o.preselect) : -1;
        let maxMru = -1;
        let abbrWidth = 0;
        let menuWidth = 0;
        let kindWidth = 0;
        let shortcutWidth = 0;
        let checkMru = selectedIndex == -1 && !noselect && selection !== "first" /* First */;
        let labels = [];
        let baseCharacter = characterIndex(option.line, option.col);
        let minCharacter = baseCharacter;
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          if (checkMru) {
            let n = this.mruLoader.getScore(search, item, selection);
            if (n > maxMru) {
              maxMru = n;
              selectedIndex = i;
            }
          }
          if (number(item.character) && item.character < minCharacter) {
            minCharacter = item.character;
          }
          let label = this.getLabel(item);
          labels.push(label);
          abbrWidth = Math.max(this.stringWidth(label.text, true), abbrWidth);
          if (item.kind) kindWidth = Math.max(this.stringWidth(getKindText(item.kind, kindMap, defaultKindText), true), kindWidth);
          if (item.menu) menuWidth = Math.max(this.stringWidth(item.menu, true), menuWidth);
          if (item.shortcut) shortcutWidth = Math.max(this.stringWidth(item.shortcut, true) + 2, shortcutWidth);
        }
        if (selectedIndex !== -1 && search.length > 0) {
          let item = items[selectedIndex];
          if (!item.word.startsWith(search) && !item.filterText.startsWith(search)) {
            selectedIndex = -1;
          }
        }
        if (!noselect) {
          selectedIndex = selectedIndex == -1 ? 0 : selectedIndex;
        } else {
          if (selectedIndex > 0) {
            let [item] = items.splice(selectedIndex, 1);
            items.unshift(item);
            let [label] = labels.splice(selectedIndex, 1);
            labels.unshift(label);
          }
          selectedIndex = -1;
        }
        let opt = {
          input: search,
          index: selectedIndex,
          bufnr: option.bufnr,
          line: option.linenr,
          // col for pum
          col: option.col,
          // col for word insert
          startcol: byteIndex(option.line, minCharacter),
          virtualText,
          words: items.map((o) => {
            let character = o.character;
            let start = Math.max(1, option.position.character - character + 1);
            let word = getInsertWord(o.word, invalidInsertCodes, start);
            return prefixWord(word, character, option.line, minCharacter);
          })
        };
        let pumConfig = this.pumConfig;
        let lines = [];
        let highlights = [];
        let width = 0;
        let buildConfig = { border: !!pumConfig.border, menuWidth, abbrWidth, kindWidth, shortcutWidth };
        this.adjustAbbrWidth(buildConfig);
        let lowInput = search.toLowerCase();
        for (let index = 0; index < items.length; index++) {
          let [displayWidth, text] = this.buildItem(search, lowInput, items[index], labels[index], highlights, index, buildConfig);
          width = Math.max(width, displayWidth);
          lines.push(text);
        }
        let config = Object.assign({ width, highlights }, pumConfig);
        this.nvim.call("coc#pum#create", [lines, opt, config], true);
        this.nvim.redrawVim();
      }
      getLabel(item) {
        let { labelDetails, detail } = item;
        let { snippetIndicator, labelMaxLength, detailField, detailMaxLength } = this.config;
        let label = item.abbr;
        let hls = [];
        if (item.isSnippet && !label.endsWith(snippetIndicator)) {
          label = label + snippetIndicator;
        }
        if (detailField === "abbr" && detail && !labelDetails && detail.length < detailMaxLength) {
          labelDetails = { detail: " " + detail.replace(/\r?\n\s*/g, " ") };
        }
        if (labelDetails) {
          let added = (labelDetails.detail ?? "") + (labelDetails.description ? ` ${labelDetails.description}` : "");
          if (label.length + added.length <= labelMaxLength) {
            let start = byteLength(label);
            hls.push({ start, end: start + byteLength(added), hlGroup: "CocPumDetail" /* PumDetail */ });
            label = label + added;
            item.detailRendered = true;
          }
        }
        if (label.length > labelMaxLength) {
          label = label.slice(0, labelMaxLength - 1) + ".";
        }
        return { text: label, highlights: hls };
      }
      adjustAbbrWidth(config) {
        let { formatItems } = this.config;
        let pumwidth = toNumber(workspace_default.env.pumwidth, 15);
        let len = 0;
        for (const item of formatItems) {
          if (item == "abbr" /* Abbr */) {
            len += config.abbrWidth + 1;
          } else if (item == "menu" /* Menu */ && config.menuWidth) {
            len += config.menuWidth + 1;
          } else if (item == "kind" /* Kind */ && config.kindWidth) {
            len += config.kindWidth + 1;
          } else if (item == "shortcut" /* Shortcut */ && config.shortcutWidth) {
            len += config.shortcutWidth + 1;
          }
        }
        if (len < pumwidth) {
          config.abbrWidth = config.abbrWidth + pumwidth - len;
        }
      }
      buildItem(input, lowInput, item, label, hls, index, config) {
        let { labelMaxLength, formatItems, kindMap, defaultKindText } = this.config;
        let text = config.border ? "" : " ";
        let len = byteLength(text);
        let displayWidth = text.length;
        let append = (str, width) => {
          let s = this.fillWidth(str, width);
          displayWidth += width;
          len += byteLength(s);
          text += s;
        };
        for (const name2 of formatItems) {
          switch (name2) {
            case "abbr": {
              if (!isFalsyOrEmpty(item.positions)) {
                let pre = highlightOffset(len, item);
                if (pre != -1) {
                  positionHighlights(hls, item.abbr, item.positions, pre, index, labelMaxLength);
                } else {
                  let score3 = anyScore(input, lowInput, 0, item.abbr, item.abbr.toLowerCase(), 0);
                  positionHighlights(hls, item.abbr, score3, 0, index, labelMaxLength);
                }
              }
              let abbr = label.text;
              let start = len;
              append(abbr, config.abbrWidth + 1);
              label.highlights.forEach((hl) => {
                hls.push({
                  hlGroup: hl.hlGroup,
                  lnum: index,
                  colStart: start + hl.start,
                  colEnd: start + hl.end
                });
              });
              if (item.deprecated) {
                hls.push({
                  hlGroup: "CocPumDeprecated" /* PumDeprecated */,
                  lnum: index,
                  colStart: start,
                  colEnd: len - 1
                });
              }
              break;
            }
            case "menu": {
              if (config.menuWidth > 0) {
                let colStart = len;
                append(toText(item.menu), config.menuWidth + 1);
                if (item.menu) {
                  hls.push({
                    hlGroup: "CocPumMenu" /* PumMenu */,
                    lnum: index,
                    colStart,
                    colEnd: colStart + byteLength(item.menu)
                  });
                }
              }
              break;
            }
            case "kind":
              if (config.kindWidth > 0) {
                let { kind } = item;
                let kindText = getKindText(kind, kindMap, defaultKindText);
                let colStart = len;
                append(toText(kindText), config.kindWidth + 1);
                if (kindText) {
                  hls.push({
                    hlGroup: getKindHighlight(kind),
                    lnum: index,
                    colStart,
                    colEnd: colStart + byteLength(kindText)
                  });
                }
              }
              break;
            case "shortcut":
              if (config.shortcutWidth > 0) {
                let colStart = len;
                let shortcut = item.shortcut;
                append(shortcut ? `[${shortcut}]` : "", config.shortcutWidth + 1);
                if (shortcut) {
                  hls.push({
                    hlGroup: "CocPumShortcut" /* PumShortcut */,
                    lnum: index,
                    colStart,
                    colEnd: colStart + byteLength(shortcut) + 2
                  });
                }
              }
              break;
          }
        }
        return [displayWidth, text];
      }
      fillWidth(text, width) {
        let n = width - this.stringWidth(text);
        return text + " ".repeat(Math.max(n, 0));
      }
    };
  }
});

// src/completion/index.ts
var logger47, TRIGGER_TIMEOUT, CURSORMOVE_DEBOUNCE, Completion, completion_default;
var init_completion2 = __esm({
  "src/completion/index.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_commands();
    init_events();
    init_logger();
    init_util();
    init_array();
    init_errors();
    init_is();
    init_node();
    init_numbers();
    init_object();
    init_string();
    init_window();
    init_workspace();
    init_complete();
    init_floating();
    init_pum();
    init_sources2();
    init_types2();
    init_util4();
    logger47 = createLogger("completion");
    TRIGGER_TIMEOUT = getConditionValue(200, 20);
    CURSORMOVE_DEBOUNCE = getConditionValue(20, 20);
    Completion = class {
      constructor() {
        this.disposables = [];
        this.complete = null;
        // Ordered items shown in the pum
        this.activeItems = [];
      }
      get nvim() {
        return workspace_default.nvim;
      }
      init() {
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        window_default.onDidChangeActiveTextEditor((e) => {
          this.loadLocalConfig(e.document);
        }, null, this.disposables);
        this._mru = new MruLoader();
        this.pum = new PopupMenu(this.staticConfig, this._mru);
        this.floating = new Floating(this.staticConfig);
        this._debounced = debounce(this.onCursorMovedI.bind(this), CURSORMOVE_DEBOUNCE);
        events_default.on("BufEnter", () => {
          this._debounced.clear();
        }, null, this.disposables);
        events_default.on("CursorMoved", () => {
          this.cancelAndClose();
        }, null, this.disposables);
        events_default.on("PumNavigate", () => {
          this.complete?.cancel();
        }, null, this.disposables);
        events_default.on("CursorMovedI", this._debounced, this, this.disposables);
        events_default.on("CursorMovedI", () => {
          clearTimeout(this.triggerTimer);
        }, null, this.disposables);
        events_default.on("InsertEnter", this.onInsertEnter, this, this.disposables);
        events_default.on("TextChangedI", this.onTextChangedI, this, this.disposables);
        events_default.on("MenuPopupChanged", async (ev) => {
          if (this.complete == null) return;
          this.popupEvent = ev;
          if (ev.inserted) this.complete.cancel();
          let selectedItem = this.activeItems[ev.index];
          let resolved = this.complete.resolveItem(selectedItem);
          if (!resolved || !ev.move && this.complete.isCompleting) return;
          let detailRendered = selectedItem.detailRendered;
          let showDocs = this.config.enableFloat;
          await this.floating.resolveItem(resolved.source, resolved.item, this.option, showDocs, detailRendered);
        }, null, this.disposables);
        this.nvim.call("coc#ui#check_pum_keymappings", [this.config.autoTrigger], true);
        commands_default.registerCommand("editor.action.triggerSuggest", async (source) => {
          await this.startCompletion({ source });
        }, this, true);
      }
      get mru() {
        return this._mru;
      }
      onCursorMovedI(bufnr, cursor, hasInsert) {
        if (hasInsert || !this.option || bufnr !== this.option.bufnr) return;
        let { linenr, col } = this.option;
        if (this.selectedItem && linenr === cursor[0] && col + byteLength(this.selectedItem.word) + 1 == cursor[1]) {
          return;
        }
        if (linenr === cursor[0] && cursor[1] === byteLength(toText(this.pretext)) + 1) {
          return;
        }
        this.cancelAndClose();
      }
      get option() {
        if (!this.complete) return null;
        return this.complete.option;
      }
      get isActivated() {
        return this.complete != null;
      }
      get selectedItem() {
        if (!this.popupEvent) return void 0;
        return this.activeItems[this.popupEvent.index];
      }
      /**
       * Configuration for current document
       */
      loadLocalConfig(doc) {
        let suggest = workspace_default.getConfiguration("suggest", doc);
        this.config = {
          autoTrigger: suggest.get("autoTrigger", "always"),
          insertMode: suggest.get("insertMode", "replace" /* Replace */),
          filterGraceful: suggest.get("filterGraceful", true),
          enableFloat: suggest.get("enableFloat", true),
          languageSourcePriority: suggest.get("languageSourcePriority", 99),
          snippetsSupport: suggest.get("snippetsSupport", true),
          defaultSortMethod: suggest.get("defaultSortMethod", "length" /* Length */),
          removeDuplicateItems: suggest.get("removeDuplicateItems", false),
          removeCurrentWord: suggest.get("removeCurrentWord", false),
          acceptSuggestionOnCommitCharacter: suggest.get("acceptSuggestionOnCommitCharacter", false),
          triggerCompletionWait: suggest.get("triggerCompletionWait", 0),
          triggerAfterInsertEnter: suggest.get("triggerAfterInsertEnter", false),
          maxItemCount: suggest.get("maxCompleteItemCount", 256),
          timeout: suggest.get("timeout", 500),
          minTriggerInputLength: suggest.get("minTriggerInputLength", 1),
          localityBonus: suggest.get("localityBonus", true),
          highPrioritySourceLimit: suggest.get("highPrioritySourceLimit", null),
          lowPrioritySourceLimit: suggest.get("lowPrioritySourceLimit", null),
          ignoreRegexps: suggest.get("ignoreRegexps", []),
          asciiMatch: suggest.get("asciiMatch", true),
          asciiCharactersOnly: suggest.get("asciiCharactersOnly", false)
        };
      }
      loadConfiguration(e) {
        if (e && !e.affectsConfiguration("suggest")) return;
        if (e) this.pum.reset();
        let suggest = workspace_default.initialConfiguration.get("suggest");
        let labels = defaultValue(suggest.completionItemKindLabels, {});
        this.staticConfig = Object.assign(this.staticConfig ?? {}, {
          kindMap: createKindMap(labels),
          defaultKindText: toText(labels["default"]),
          detailField: suggest.detailField,
          detailMaxLength: toNumber(suggest.detailMaxLength, 100),
          invalidInsertCharacters: toArray(suggest.invalidInsertCharacters),
          formatItems: suggest.formatItems,
          filterOnBackspace: suggest.filterOnBackspace,
          floatConfig: toObject(suggest.floatConfig),
          pumFloatConfig: suggest.pumFloatConfig,
          labelMaxLength: suggest.labelMaxLength,
          reTriggerAfterIndent: !!suggest.reTriggerAfterIndent,
          reversePumAboveCursor: !!suggest.reversePumAboveCursor,
          snippetIndicator: toText(suggest.snippetIndicator),
          noselect: !!suggest.noselect,
          enablePreselect: !!suggest.enablePreselect,
          virtualText: !!suggest.virtualText,
          selection: suggest.selection
        });
        let doc = workspace_default.getDocument(workspace_default.bufnr);
        this.loadLocalConfig(doc);
      }
      async startCompletion(opt) {
        clearTimeout(this.triggerTimer);
        let sourceList;
        if (string(opt.source)) {
          sourceList = toArray(sources_default.getSource(opt.source));
        }
        let doc = workspace_default.getAttachedDocument(events_default.bufnr);
        let info = await this.nvim.call("coc#util#change_info");
        info.pre = byteSlice(info.line, 0, info.col - 1);
        const option = this.getCompleteOption(doc, info, true, opt.col);
        await this._startCompletion(option, sourceList);
      }
      async _startCompletion(option, sourceList) {
        this._debounced.clear();
        let doc = workspace_default.getAttachedDocument(option.bufnr);
        option.filetype = doc.filetype;
        logger47.debug("trigger completion with", option);
        this.cancelAndClose();
        sourceList = sourceList ?? sources_default.getSources(option);
        if (isFalsyOrEmpty(sourceList)) return;
        this.pretext = byteSlice(option.line, 0, option.colnr - 1);
        let complete = this.complete = new Complete(
          option,
          doc,
          this.config,
          sourceList
        );
        events_default.completing = true;
        void events_default.fire("CompleteStart", [option]);
        complete.onDidRefresh(async () => {
          clearTimeout(this.triggerTimer);
          if (complete.isEmpty) {
            this.cancelAndClose(false);
            return;
          }
          await this.filterResults();
        });
        let shouldStop2 = await complete.doComplete();
        if (shouldStop2) this.cancelAndClose(false);
      }
      hasIndentChange(info) {
        let { option, pretext } = this;
        if (!option || option.linenr != info.lnum) return false;
        let previous = pretext.match(/^\s*/)[0];
        let current = info.pre.match(/^\s*/)[0];
        if (previous == current || pretext.slice(previous.length) !== info.pre.slice(current.length)) return false;
        return true;
      }
      async onTextChangedI(bufnr, info) {
        const doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached) return;
        this._debounced.clear();
        const { option, staticConfig } = this;
        const filterOnBackspace = this.staticConfig.filterOnBackspace;
        if (option != null) {
          if (!info.insertChar) {
            let pre = byteSlice(option.line, 0, option.col);
            if (this.selectedItem) {
              let { word, startcol } = this.popupEvent;
              if (byteSlice(option.line, 0, startcol) + word == info.pre) {
                this.pretext = info.pre;
                return;
              }
            } else if (pre + this.pum.search == info.pre) {
              this.pretext = info.pre;
              return;
            }
          }
          if (staticConfig.reTriggerAfterIndent && this.hasIndentChange(info)) {
            this.cancelAndClose();
            await this.triggerCompletion(doc, info);
            return;
          }
          if (shouldStop(bufnr, info, option) || filterOnBackspace === false && info.pre.length < this.pretext.length) {
            this.cancelAndClose();
          }
        }
        if (info.pre === this.pretext) return;
        clearTimeout(this.triggerTimer);
        let pretext = this.pretext = info.pre;
        if (!info.insertChar) {
          if (this.complete) await this.filterResults();
          return;
        }
        if (this.config.acceptSuggestionOnCommitCharacter && this.selectedItem) {
          let last = pretext.slice(-1);
          let resolvedItem = this.selectedItem;
          let result = this.complete.resolveItem(resolvedItem);
          if (result && sources_default.shouldCommit(result.source, result.item, last)) {
            logger47.debug(`commit by commit character: ${last}`);
            let startcol = byteIndex(this.option.line, resolvedItem.character) + 1;
            let delta = deltaCount(info);
            await this.nvim.call("coc#pum#replace", [startcol, resolvedItem.word, delta]);
            await this.stop("confirm" /* Confirm */, true);
            let res = await this.nvim.evalVim(`[getline('.'),col('.'),mode()]`);
            let currentPre = byteSlice(res[0], 0, res[1] - 1);
            if (res[2] != "i" || currentPre[currentPre.length - 1] == last) return;
            if (pariedCharacters.has(last) && currentPre.slice(-2) == `${last}${pariedCharacters.get(last)}`) return;
            this.nvim.call("feedkeys", [last, "n"], true);
            return;
          }
        }
        if (!doc.chars.isKeywordChar(info.insertChar)) {
          let triggerSources = this.getTriggerSources(doc, pretext);
          if (triggerSources.length > 0) {
            await this.triggerCompletion(doc, info, triggerSources);
            return;
          }
        }
        if (!this.complete) {
          await this.triggerCompletion(doc, info);
          return;
        }
        if (this.complete.isEmpty) {
          this.triggerTimer = setTimeout(async () => {
            await this.triggerCompletion(doc, info);
          }, TRIGGER_TIMEOUT);
          return;
        }
        await this.filterResults(info);
      }
      getTriggerSources(doc, pretext) {
        let disabled = doc.getVar("disabled_sources", []);
        if (this.config.autoTrigger === "none") return [];
        return sources_default.getTriggerSources(pretext, doc.filetype, doc.uri, disabled);
      }
      async triggerCompletion(doc, info, sources) {
        let { minTriggerInputLength, autoTrigger } = this.config;
        let { pre } = info;
        if (autoTrigger === "none") return false;
        if (!sources && !this.shouldTrigger(doc, pre)) return false;
        const option = this.getCompleteOption(doc, info);
        if (sources == null && option.input.length < minTriggerInputLength) {
          logger47.trace(`Suggest not triggered with input "${option.input}", minimal trigger input length: ${minTriggerInputLength}`);
          return false;
        }
        if (checkIgnoreRegexps(this.config.ignoreRegexps, option.input)) return false;
        await this._startCompletion(option, sources);
        return true;
      }
      getCompleteOption(doc, info, manual = false, col) {
        let { pre } = info;
        let input;
        if (number(col)) {
          input = byteSlice(info.line, col - 1, info.col - 1);
        } else {
          input = getInput(doc.chars, info.pre, this.config.asciiCharactersOnly);
        }
        let followWord = doc.getStartWord(info.line.slice(info.pre.length));
        return {
          input,
          position: Position.create(info.lnum - 1, info.pre.length),
          line: info.line,
          followWord,
          filetype: doc.filetype,
          linenr: info.lnum,
          col: info.col - 1 - byteLength(input),
          colnr: info.col,
          bufnr: doc.bufnr,
          word: input + followWord,
          changedtick: info.changedtick,
          synname: "",
          filepath: doc.schema === "file" ? URI2.parse(doc.uri).fsPath : "",
          triggerCharacter: manual ? void 0 : toText(pre[pre.length - 1])
        };
      }
      addMruItem() {
        let { selectedItem, complete } = this;
        if (!selectedItem) return;
        let character = selectedItem.character;
        this._mru.add(complete.getTrigger(character), selectedItem);
      }
      cancelAndClose(close = true) {
        clearTimeout(this.triggerTimer);
        if (!this.complete) return;
        const { linenr, bufnr } = this.complete.option;
        this._onFinish("" /* Normal */, close);
        events_default.fire("CompleteDone", [{}, linenr, bufnr]).catch(onUnexpectedError);
      }
      _onFinish(kind, close) {
        this.floating.cancel();
        let inserted = kind === "confirm" /* Confirm */ || this.popupEvent?.inserted;
        if (inserted) this.addMruItem();
        let doc = this.complete.document;
        events_default.completing = false;
        this.cancel();
        doc._forceSync();
        if (close) this.nvim.call("coc#pum#_close", [], true);
      }
      async stop(kind, close = false) {
        let { complete } = this;
        if (complete == null) return;
        const item = this.selectedItem;
        const resolved = complete.resolveItem(item);
        const option = complete.option;
        this._onFinish(kind, close);
        if (resolved && kind == "confirm" /* Confirm */) {
          await this.confirmCompletion(resolved.source, resolved.item, option);
        }
        events_default.fire("CompleteDone", [toCompleteDoneItem(item, resolved?.item), option.linenr, option.bufnr]).catch(onUnexpectedError);
      }
      async confirmCompletion(source, item, option) {
        await this.floating.resolveItem(source, item, option, false);
        if (!func(source.onCompleteDone)) return;
        let { insertMode, snippetsSupport } = this.config;
        let opt = Object.assign({ insertMode, snippetsSupport }, option);
        await Promise.resolve(source.onCompleteDone(item, opt));
      }
      async onInsertEnter(bufnr) {
        if (!this.config.triggerAfterInsertEnter || this.config.autoTrigger !== "always") return;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached) return;
        let change = await this.nvim.call("coc#util#change_info");
        change.pre = byteSlice(change.line, 0, change.col - 1);
        await this.triggerCompletion(doc, change);
      }
      shouldTrigger(doc, pre) {
        let { autoTrigger } = this.config;
        if (autoTrigger == "none") return false;
        if (sources_default.shouldTrigger(pre, doc.filetype, doc.uri)) return true;
        if (autoTrigger !== "always") return false;
        return true;
      }
      async filterResults(info) {
        let { complete, option, pretext } = this;
        let search = getResumeInput(option, pretext);
        if (search == null || !complete) {
          this.cancelAndClose();
          return;
        }
        let items = await complete.filterResults(search);
        if (items === void 0 || !this.option) return;
        let doc = workspace_default.getDocument(option.bufnr);
        if (info && info.insertChar && items.length == 0) {
          let triggerSources = this.getTriggerSources(doc, pretext);
          if (triggerSources.length > 0) {
            await this.triggerCompletion(doc, info, triggerSources);
            return;
          }
        }
        if (items.length == 0) {
          let last = search.slice(-1);
          if (!complete.isCompleting || last.length === 0 || !doc.chars.isKeywordChar(last)) {
            this.cancelAndClose();
          }
          return;
        }
        this.activeItems = items;
        this.pum.show(items, search, this.option);
      }
      cancel() {
        if (this.complete != null) {
          this.complete.dispose();
          this.complete = null;
        }
        if (this.triggerTimer != null) {
          clearTimeout(this.triggerTimer);
          this.triggerTimer = null;
        }
        this.pretext = void 0;
        this.activeItems = [];
        this.popupEvent = void 0;
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
    completion_default = new Completion();
  }
});

// src/cursors/util.ts
function splitRange(doc, range) {
  let splited = [];
  for (let i = range.start.line; i <= range.end.line; i++) {
    let curr = doc.getline(i) || "";
    let sc = i == range.start.line ? range.start.character : 0;
    let ec = i == range.end.line ? range.end.character : curr.length;
    if (sc == ec) continue;
    splited.push(Range.create(i, sc, i, ec));
  }
  return splited;
}
function getVisualRanges(doc, range) {
  let { start, end } = getWellformedRange2(range);
  let sc = start.character < end.character ? start.character : end.character;
  let ec = start.character < end.character ? end.character : start.character;
  let ranges = [];
  for (let i = start.line; i <= end.line; i++) {
    let line = doc.getline(i);
    ranges.push(Range.create(i, sc, i, Math.min(line.length, ec)));
  }
  return ranges;
}
function isSurrondChange(change) {
  return Array.isArray(change["prepend"]) && Array.isArray(change["append"]);
}
function getDelta(change) {
  if (isSurrondChange(change)) {
    return change.append[1].length + change.prepend[1].length - change.append[0] - change.prepend[0];
  }
  return change.insert.length - change.remove;
}
function getChange(r, range, newText) {
  let text = r.text;
  if (equals(r.range, range)) {
    let idx = text.indexOf(newText);
    if (idx !== -1) {
      let prepend = [idx, ""];
      let append = [text.length - newText.length - idx, ""];
      return { prepend, append };
    }
    idx = newText.indexOf(text);
    if (idx !== -1) {
      let prepend = [0, newText.slice(0, idx)];
      let append = [0, newText.slice(-(newText.length - text.length - idx))];
      return { prepend, append };
    }
  }
  if (equals(r.range.end, range.end)) {
    let remove3 = range.end.character - range.start.character;
    return { offset: remove3, remove: remove3, insert: newText, fromEnd: true };
  }
  let remove2 = range.end.character - range.start.character;
  let offset = range.start.character - r.range.start.character;
  return { offset, remove: remove2, insert: newText };
}
function getBeforeCount(textRange, ranges, exclude) {
  let n = 0;
  for (let idx = 0; idx < ranges.length; idx++) {
    const r = ranges[idx];
    if (r.position.line < textRange.position.line || r === exclude) continue;
    if (r.isBefore(textRange)) {
      n++;
      continue;
    }
    break;
  }
  return n;
}
var init_util6 = __esm({
  "src/cursors/util.ts"() {
    "use strict";
    init_main();
    init_object();
    init_textedit();
  }
});

// src/cursors/textRange.ts
var TextRange;
var init_textRange = __esm({
  "src/cursors/textRange.ts"() {
    "use strict";
    init_main();
    init_position();
    init_textedit();
    init_util6();
    TextRange = class {
      constructor(line, character, text) {
        this.start = Position.create(line, character);
        this._text = text;
        this.end = getEnd(this.start, this._text);
      }
      get position() {
        return this.start;
      }
      get line() {
        return this.start.line;
      }
      get text() {
        return this._text;
      }
      get range() {
        return Range.create(this.start, this.end);
      }
      get textEdit() {
        return {
          range: this.range,
          newText: this.text
        };
      }
      applyChange(change) {
        if (isSurrondChange(change)) {
          this.applySurrondChange(change);
        } else {
          this.applyTextChange(change);
        }
      }
      applySurrondChange(change) {
        let { prepend, append } = change;
        let len = this._text.length;
        let text = this._text.substring(prepend[0], len - append[0]);
        this._text = `${prepend[1]}${text}${append[1]}`;
      }
      applyTextChange(change) {
        let { text } = this;
        let { offset, remove: remove2, fromEnd, insert } = change;
        if (fromEnd) offset = -offset;
        let pre = text.slice(0, fromEnd && offset == 0 ? text.length : offset);
        let after = text.slice(pre.length);
        if (remove2) after = after.slice(remove2);
        this._text = `${pre}${insert || ""}${after}`;
      }
      /**
       * Adjust range
       */
      move(delta) {
        if (delta != 0) {
          let { line, character } = this.start;
          this.start = Position.create(line, character + delta);
        }
        this.end = getEnd(this.start, this._text);
      }
      adjustFromEdit(edit2) {
        let changed = getChangedPosition(this.start, edit2);
        if (changed.line || changed.character) {
          let { line, character } = this.start;
          this.start = Position.create(line + changed.line, character + changed.character);
          this.end = getEnd(this.start, this._text);
        }
        return changed.character;
      }
      isBefore(range) {
        let { position } = range;
        let { line, character } = this.start;
        return position.line == line && position.character > character;
      }
    };
  }
});

// src/cursors/session.ts
function surrondChanges(changes, len) {
  if (changes.length != 2 || changes[0].offset != 0) return false;
  let end = changes[1].offset + (changes[1].remove ? changes[1].remove.length : 0);
  if (end !== len) return false;
  return true;
}
var logger48, CursorSession;
var init_session3 = __esm({
  "src/cursors/session.ts"() {
    "use strict";
    init_main3();
    init_main();
    init_logger();
    init_util();
    init_node();
    init_position();
    init_protocol();
    init_textedit();
    init_window();
    init_workspace();
    init_textRange();
    init_util6();
    logger48 = createLogger("cursors-session");
    CursorSession = class {
      constructor(nvim, doc, config) {
        this.nvim = nvim;
        this.doc = doc;
        this.config = config;
        this._onDidCancel = new import_node4.Emitter();
        this._onDidUpdate = new import_node4.Emitter();
        this.onDidCancel = this._onDidCancel.event;
        this.onDidUpdate = this._onDidUpdate.event;
        this.disposables = [];
        this.ranges = [];
        this.activated = true;
        this.changing = false;
        let { bufnr } = doc;
        doc.buffer.setVar("coc_cursors_activated", 1, true);
        let { cancelKey, nextKey, previousKey } = this.config;
        this.disposables.push(workspace_default.registerLocalKeymap(bufnr, "n", cancelKey, () => {
          this.cancel();
        }));
        this.disposables.push(workspace_default.registerLocalKeymap(bufnr, "n", nextKey, async () => {
          let ranges = this.ranges.map((o) => o.range);
          let curr = await window_default.getCursorPosition();
          for (let r of ranges) {
            if (comparePosition(r.start, curr) > 0) {
              await window_default.moveTo(r.start);
              return;
            }
          }
          let wrap = this.config.wrapscan;
          if (ranges.length && wrap) await window_default.moveTo(ranges[0].start);
        }));
        this.disposables.push(workspace_default.registerLocalKeymap(bufnr, "n", previousKey, async () => {
          let ranges = this.ranges.map((o) => o.range);
          let curr = await window_default.getCursorPosition();
          for (let i = ranges.length - 1; i >= 0; i--) {
            let r = ranges[i];
            if (comparePosition(r.end, curr) < 0) {
              await window_default.moveTo(r.start);
              return;
            }
          }
          let wrap = this.config.wrapscan;
          if (ranges.length && wrap) await window_default.moveTo(ranges[ranges.length - 1].start);
        }));
        this.doc.onDocumentChange(async (e) => {
          await this.onChange(e);
          if (this.activated && !this.changing) {
            this._onDidUpdate.fire();
          }
        }, this, this.disposables);
      }
      /**
       * Add or remove range.
       */
      addRange(range) {
        let { ranges } = this;
        let idx = ranges.findIndex((o) => rangeIntersect(o.range, range));
        if (idx !== -1) {
          ranges.splice(idx, 1);
        } else {
          this.createRange(range);
          ranges.sort((a, b) => comparePosition(a.range.start, b.range.start));
        }
        if (this.ranges.length == 0) {
          this.cancel();
        } else {
          this.doHighlights();
        }
      }
      addRanges(ranges) {
        this.doc._forceSync();
        this.ranges = this.ranges.filter((r) => {
          return !ranges.some((range) => rangeOverlap(range, r.range));
        });
        for (let range of ranges) {
          this.createRange(range);
        }
        this.ranges.sort((a, b) => comparePosition(a.range.start, b.range.start));
        this.doHighlights();
        return true;
      }
      createRange(range) {
        let { textDocument } = this.doc;
        let { line, character } = range.start;
        let text = textDocument.getText(range);
        this.ranges.push(new TextRange(line, character, text));
      }
      async onChange(e) {
        if (!this.activated || this.changing) return;
        if (e.contentChanges.length === 0) {
          this.doHighlights();
          return;
        }
        let change = e.contentChanges[0];
        let { text, range } = change;
        let affected = this.ranges.filter((r) => {
          if (!rangeIntersect(range, r.range)) return false;
          if (rangeAdjacent(range, r.range)) {
            if (text.includes("\n") || !emptyRange(range)) return false;
          }
          return true;
        });
        if (emptyRange(range) && affected.length > 0) {
          affected = affected.slice(0, 1);
        }
        if (affected.length == 0) {
          logger48.debug("no affected ranges");
          this.ranges.forEach((r) => {
            r.adjustFromEdit({ range, newText: text });
          });
          this.doHighlights();
        } else if (affected.length == 1 && rangeInRange(range, affected[0].range)) {
          logger48.debug("affected single range");
          if (text.includes("\n")) {
            this.cancel();
            return;
          }
          await this.applySingleEdit(affected[0], { range, newText: text });
        } else if (!text.length || !this.validChange(range, text)) {
          logger48.debug("filter affected ranges.");
          let ranges = this.ranges.filter((r) => !affected.includes(r));
          if (ranges.length > 0) {
            this.ranges = ranges;
            ranges.forEach((r) => {
              r.adjustFromEdit({ range, newText: text });
            });
            this.doHighlights();
          } else {
            this.cancel();
          }
        } else {
          logger48.debug("Check undo & redo");
          let first = this.ranges[0];
          let last = this.ranges[this.ranges.length - 1];
          let originalLines = e.originalLines.slice(first.line, last.line + 1);
          let newLines = this.doc.textDocument.lines.slice(first.line, last.line + 1);
          this.applyComposedEdit(originalLines, newLines);
        }
      }
      validChange(range, text) {
        if (lineCountChange(TextEdit.replace(range, text)) != 0) return false;
        if (!rangeInRange(range, this.range)) return false;
        let first = this.ranges[0];
        let last = this.ranges[this.ranges.length - 1];
        if (range.start.line != first.position.line || range.end.line != last.position.line) return false;
        return true;
      }
      get range() {
        let first = this.ranges[0];
        let last = this.ranges[this.ranges.length - 1];
        return Range.create(first.position, last.range.end);
      }
      doHighlights() {
        let { nvim, ranges, doc } = this;
        let buffer = doc.buffer;
        let items = [];
        ranges.forEach((r) => {
          doc.addHighlights(items, "CocCursorRange", r.range, {
            combine: false,
            start_incl: true,
            end_incl: true
          });
        });
        items.sort((a, b) => {
          if (a.lnum != b.lnum) return a.lnum - b.lnum;
          if (a.colStart != b.colStart) return a.colStart - b.colStart;
          return 0;
        });
        buffer.updateHighlights("cursors", items, { priority: 4096 });
        nvim.redrawVim();
      }
      get currentRanges() {
        return this.ranges.map((r) => r.range);
      }
      /**
       * Cancel session and highlights
       */
      cancel() {
        if (!this.activated) return;
        logger48.debug("cursors cancel");
        let buffer = this.doc.buffer;
        this.activated = false;
        this.ranges = [];
        buffer.clearNamespace("cursors");
        buffer.setVar("coc_cursors_activated", 0, true);
        this._onDidUpdate.fire();
        this._onDidCancel.fire();
      }
      /**
       * Called on buffer unload or cancel
       */
      dispose() {
        if (!this.doc) return;
        this._onDidCancel.dispose();
        this._onDidUpdate.dispose();
        disposeAll(this.disposables);
        this.ranges = [];
        this.doc = null;
      }
      async applySingleEdit(textRange, edit2) {
        let { doc, ranges } = this;
        let after = ranges.filter((r) => r !== textRange && r.position.line == textRange.position.line);
        after.forEach((r) => r.adjustFromEdit(edit2));
        let change = getChange(textRange, edit2.range, edit2.newText);
        let delta = getDelta(change);
        ranges.forEach((r) => r.applyChange(change));
        let edits = ranges.filter((r) => r !== textRange).map((o) => o.textEdit);
        this.changing = true;
        await doc.applyEdits(edits, true, true);
        this.changing = false;
        if (delta != 0) {
          for (let r of ranges) {
            let n = getBeforeCount(r, this.ranges, textRange);
            r.move(n * delta);
          }
        }
        this.doHighlights();
      }
      applyComposedEdit(originalLines, newLines) {
        let diffs = fastDiff(originalLines[0], newLines[0]);
        let first = this.ranges[0];
        let s = first.position.character;
        let firstLine = first.position.line;
        let len = first.text.length;
        let diff = diffs[0];
        if (s > 0 && (diff[0] != fastDiff.EQUAL || !diff[1].startsWith(originalLines[0].slice(0, s)))) {
          this.cancel();
          return false;
        }
        let used = 0;
        let invalid = false;
        let changes = [];
        for (let i = 0; i < diffs.length; i++) {
          let [kind, text] = diffs[i];
          if (i == 0 && s > 0) {
            text = text.slice(s);
          }
          if (kind == fastDiff.EQUAL) {
            used += text.length;
            if (used > len) break;
          } else if (kind == fastDiff.DELETE) {
            let offset = used;
            used += text.length;
            if (used > len) {
              invalid = true;
              break;
            }
            changes.push({ offset, remove: text });
          } else {
            let prev = diffs[i - 1];
            if (prev && prev[0] == fastDiff.DELETE) {
              changes[changes.length - 1].add = text;
            } else {
              changes.push({ offset: used, add: text });
            }
          }
        }
        if (invalid || !changes.length) {
          this.cancel();
          return false;
        }
        let doc = TextDocument2.create("file:///1", "", 0, originalLines.join("\n"));
        let change;
        if (changes.length == 1) {
          change = {
            offset: changes[0].offset,
            remove: changes[0].remove ? changes[0].remove.length : 0,
            insert: changes[0].add ?? ""
          };
        } else if (surrondChanges(changes, len)) {
          change = {
            prepend: [changes[0].remove ? changes[0].remove.length : 0, changes[0].add ?? ""],
            append: [changes[1].remove ? changes[1].remove.length : 0, changes[1].add ?? ""]
          };
        } else {
          let text = first.text;
          let oldText = "";
          let newText = "";
          let offset = changes[0].offset;
          for (let c of changes) {
            if (c.offset > offset + oldText.length) {
              let s2 = text.slice(offset + oldText.length, c.offset);
              oldText += s2;
              newText += s2;
            }
            if (c.add) {
              newText += c.add;
            }
            if (c.remove) {
              oldText += c.remove;
            }
          }
          change = {
            offset,
            remove: oldText.length,
            insert: newText
          };
        }
        let edits = this.ranges.map((o) => {
          let line = o.position.line - firstLine;
          let { start, end } = o.range;
          let range = Range.create(line, start.character, line, end.character);
          o.applyChange(change);
          return TextEdit.replace(range, o.text);
        });
        let content = TextDocument2.applyEdits(doc, edits);
        if (content !== newLines.join("\n")) {
          this.cancel();
          return false;
        }
        let delta = getDelta(change);
        if (delta != 0) {
          for (let r of this.ranges) {
            let n = getBeforeCount(r, this.ranges);
            r.move(n * delta);
          }
        }
        this.doHighlights();
        return true;
      }
    };
  }
});

// src/cursors/index.ts
var Cursors;
var init_cursors = __esm({
  "src/cursors/index.ts"() {
    "use strict";
    init_main();
    init_window();
    init_workspace();
    init_commands();
    init_session3();
    init_util6();
    Cursors = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.sessionsMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        workspace_default.onDidCloseTextDocument((e) => {
          let session = this.getSession(e.bufnr);
          if (!session) return;
          this.sessionsMap.delete(e.bufnr);
          session.dispose();
        }, null, this.disposables);
        this.disposables.push(commands_default.registerCommand("editor.action.addRanges", async (ranges) => {
          await this.addRanges(ranges);
        }, null, true));
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("cursors")) {
          let config = workspace_default.initialConfiguration;
          this.config = config.get("cursors");
        }
      }
      cancel(uri) {
        let doc = workspace_default.getDocument(uri);
        if (!doc) return;
        let session = this.getSession(doc.bufnr);
        if (session) session.cancel();
      }
      getSession(bufnr) {
        return this.sessionsMap.get(bufnr);
      }
      async isActivated() {
        let bufnr = await this.nvim.call("bufnr", ["%"]);
        return this.sessionsMap.get(bufnr) != null;
      }
      async select(bufnr, kind, mode) {
        let doc = workspace_default.getAttachedDocument(bufnr);
        let { nvim } = this;
        let session = this.createSession(doc);
        let range;
        if (kind == "operator") {
          let res = await nvim.eval(`[getpos("'["),getpos("']")]`);
          if (mode == "char") {
            let start = doc.getPosition(res[0][1], res[0][2]);
            let end = doc.getPosition(res[1][1], res[1][2] + 1);
            let ranges = splitRange(doc, Range.create(start, end));
            session.addRanges(ranges);
          } else {
            let ranges = [];
            for (let i = res[0][1] - 1; i <= res[1][1] - 1; i++) {
              let line = doc.getline(i);
              ranges.push(Range.create(i, 0, i, line.length));
            }
            session.addRanges(ranges);
          }
        } else if (kind == "word") {
          let pos = await window_default.getCursorPosition();
          range = doc.getWordRangeAtPosition(pos);
          if (!range) {
            let line = doc.getline(pos.line);
            if (pos.character == line.length) {
              range = Range.create(pos.line, Math.max(0, line.length - 1), pos.line, line.length);
            } else {
              range = Range.create(pos.line, pos.character, pos.line, pos.character + 1);
            }
          }
          session.addRange(range);
          await nvim.command(`silent! call repeat#set("\\<Plug>(coc-cursors-${kind})", -1)`);
        } else if (kind == "position") {
          let pos = await window_default.getCursorPosition();
          let line = doc.getline(pos.line);
          if (pos.character >= line.length) {
            range = Range.create(pos.line, line.length - 1, pos.line, line.length);
          } else {
            range = Range.create(pos.line, pos.character, pos.line, pos.character + 1);
          }
          session.addRange(range);
          await nvim.command(`silent! call repeat#set("\\<Plug>(coc-cursors-${kind})", -1)`);
        } else if (kind == "range") {
          await nvim.call("eval", 'feedkeys("\\<esc>", "in")');
          let range2 = await window_default.getSelectedRange(mode);
          if (!range2) return;
          let ranges = mode == "" ? getVisualRanges(doc, range2) : splitRange(doc, range2);
          for (let r of ranges) {
            session.addRange(r);
          }
        } else {
          throw new Error(`select kind "${kind}" not supported`);
        }
      }
      createSession(doc) {
        let { bufnr } = doc;
        let session = this.getSession(bufnr);
        if (session) return session;
        session = new CursorSession(this.nvim, doc, this.config);
        this.sessionsMap.set(bufnr, session);
        session.onDidCancel(() => {
          session.dispose();
          this.sessionsMap.delete(bufnr);
        });
        return session;
      }
      // Add ranges to current document
      async addRanges(ranges) {
        let { nvim } = this;
        let bufnr = await nvim.call("bufnr", ["%"]);
        let doc = workspace_default.getAttachedDocument(bufnr);
        let session = this.createSession(doc);
        return session.addRanges(ranges);
      }
      reset() {
        for (let session of this.sessionsMap.values()) {
          session.cancel();
        }
        this.sessionsMap.clear();
      }
    };
  }
});

// src/tree/LocationsDataProvider.ts
function addChildren(el, children, token) {
  if (!Array.isArray(children) || token && token.isCancellationRequested) return;
  children.forEach((item) => item.parent = el);
  el.children = children;
}
var LocationsDataProvider;
var init_LocationsDataProvider = __esm({
  "src/tree/LocationsDataProvider.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_commands();
    init_node();
    init_protocol();
    init_workspace();
    init_TreeItem();
    LocationsDataProvider = class _LocationsDataProvider {
      constructor(meta, winid, config, commandId, rootItems, getIcon, resolveChildren) {
        this.meta = meta;
        this.winid = winid;
        this.config = config;
        this.commandId = commandId;
        this.rootItems = rootItems;
        this.getIcon = getIcon;
        this.resolveChildren = resolveChildren;
        this._onDidChangeTreeData = new import_node4.Emitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
        this.actions = [];
        this.addAction("Open in new tab", async (element) => {
          await commands_default.executeCommand(this.commandId, winid, element, "tabe");
        });
        this.addAction("Dismiss", async (element) => {
          if (element.parent == null) {
            let els = this.rootItems.filter((o) => o !== element);
            this.reset(els);
          } else {
            let parentElement = element.parent;
            let idx = parentElement.children.findIndex((o) => o === element);
            parentElement.children.splice(idx, 1);
            this._onDidChangeTreeData.fire(parentElement);
          }
        });
      }
      static {
        this.rangesHighlight = "CocSelectedRange";
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = void 0;
        }
      }
      reset(rootItems) {
        this.rootItems = rootItems;
        this._onDidChangeTreeData.fire(void 0);
      }
      addAction(title, handler) {
        this.actions.push({ title, handler });
      }
      async getChildren(element) {
        this.cancel();
        this.tokenSource = new import_node4.CancellationTokenSource();
        let { token } = this.tokenSource;
        if (!element) {
          for (let o of this.rootItems) {
            let children = await this.resolveChildren(o, this.meta, token);
            addChildren(o, children, token);
          }
          return this.rootItems;
        }
        if (element.children) return element.children;
        let items = await this.resolveChildren(element, this.meta, token);
        this.tokenSource = void 0;
        addChildren(element, items, token);
        return items;
      }
      getTreeItem(element) {
        let item = new TreeItem(element.name, element.children ? 2 /* Expanded */ : 1 /* Collapsed */);
        if (this.config.enableTooltip) {
          item.tooltip = path.relative(workspace_default.cwd, URI2.parse(element.uri).fsPath);
        }
        item.description = element.detail;
        item.deprecated = element.tags?.includes(SymbolTag.Deprecated);
        item.icon = this.getIcon(element.kind);
        item.command = {
          command: this.commandId,
          title: "open location",
          arguments: [this.winid, element, this.config.openCommand]
        };
        return item;
      }
      resolveActions() {
        return this.actions;
      }
      dispose() {
        this.cancel();
        let win = workspace_default.nvim.createWindow(this.winid);
        win.clearMatchGroup(_LocationsDataProvider.rangesHighlight);
      }
    };
  }
});

// src/handler/callHierarchy.ts
function toCallHierarchyItem(item) {
  return omit(item, ["children", "parent", "ranges", "sourceUri"]);
}
function isCallHierarchyItem(item) {
  if (item && typeof item.name === "string" && item.kind && Range.is(item.range)) return true;
  return false;
}
function getTitle(kind) {
  return `${kind.toUpperCase()} CALLS`;
}
var HIGHLIGHT_GROUP, CallHierarchyHandler;
var init_callHierarchy2 = __esm({
  "src/handler/callHierarchy.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_events();
    init_languages();
    init_LocationsDataProvider();
    init_TreeView();
    init_util();
    init_array();
    init_lodash();
    init_protocol();
    init_window();
    init_workspace();
    HIGHLIGHT_GROUP = "CocSelectedRange";
    CallHierarchyHandler = class _CallHierarchyHandler {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.highlightWinids = /* @__PURE__ */ new Set();
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        this.disposables.push(commands_default.registerCommand(_CallHierarchyHandler.commandId, async (winid, item, openCommand) => {
          let { nvim: nvim2 } = this;
          await nvim2.call("win_gotoid", [winid]);
          await workspace_default.jumpTo(item.uri, item.selectionRange.start, openCommand);
          let win = await nvim2.window;
          win.clearMatchGroup(HIGHLIGHT_GROUP);
          win.highlightRanges(HIGHLIGHT_GROUP, [item.selectionRange], 10, true);
          if (isFalsyOrEmpty(item.ranges)) return;
          if (item.sourceUri) {
            let doc = workspace_default.getDocument(item.sourceUri);
            if (!doc) return;
            let winid2 = await nvim2.call("coc#compat#buf_win_id", [doc.bufnr]);
            if (winid2 == -1) return;
            if (winid2 != win.id) {
              win = nvim2.createWindow(winid2);
              win.clearMatchGroup(HIGHLIGHT_GROUP);
            }
          }
          win.highlightRanges(HIGHLIGHT_GROUP, item.ranges, 100, true);
          this.highlightWinids.add(win.id);
        }, null, true));
        events_default.on("BufWinEnter", (_, winid) => {
          if (this.highlightWinids.has(winid)) {
            this.highlightWinids.delete(winid);
            let win = nvim.createWindow(winid);
            win.clearMatchGroup(HIGHLIGHT_GROUP);
          }
        }, null, this.disposables);
        commands_default.register({
          id: "document.showIncomingCalls",
          execute: async () => {
            await this.showCallHierarchyTree("incoming");
          }
        }, false, "show incoming calls in tree view.");
        commands_default.register({
          id: "document.showOutgoingCalls",
          execute: async () => {
            await this.showCallHierarchyTree("outgoing");
          }
        }, false, "show outgoing calls in tree view.");
      }
      static {
        this.commandId = "callHierarchy.reveal";
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("callHierarchy")) {
          let c = workspace_default.getConfiguration("callHierarchy", null);
          this.config = {
            splitCommand: c.get("splitCommand"),
            openCommand: c.get("openCommand"),
            enableTooltip: c.get("enableTooltip")
          };
        }
      }
      createProvider(rootItems, doc, winid, kind) {
        let provider = new LocationsDataProvider(
          kind,
          winid,
          this.config,
          _CallHierarchyHandler.commandId,
          rootItems,
          (kind2) => this.handler.getIcon(kind2),
          (el, meta, token) => this.getChildren(doc, el, meta, token)
        );
        for (let kind2 of ["incoming", "outgoing"]) {
          let name2 = kind2 === "incoming" ? "Show Incoming Calls" /* Incoming */ : "Show Outgoing Calls" /* Outgoing */;
          provider.addAction(name2, (el) => {
            provider.meta = kind2;
            let rootItems2 = [toCallHierarchyItem(el)];
            provider.reset(rootItems2);
          });
        }
        return provider;
      }
      async getChildren(doc, item, kind, token) {
        let items = [];
        let callHierarchyItem = toCallHierarchyItem(item);
        if (kind == "incoming") {
          let res = await languages_default.provideIncomingCalls(doc, callHierarchyItem, token);
          if (res) items = res.map((o) => Object.assign(o.from, { ranges: o.fromRanges }));
        } else {
          let res = await languages_default.provideOutgoingCalls(doc, callHierarchyItem, token);
          if (res) items = res.map((o) => Object.assign(o.to, { ranges: o.fromRanges, sourceUri: item.uri }));
        }
        return items;
      }
      async prepare(doc, position, token) {
        this.handler.checkProvider("callHierarchy" /* CallHierarchy */, doc);
        const res = await languages_default.prepareCallHierarchy(doc, position, token);
        return isCallHierarchyItem(res) ? [res] : res;
      }
      async getCallHierarchyItems(item, kind) {
        const { doc, position } = await this.handler.getCurrentState();
        const source = new import_node4.CancellationTokenSource();
        if (!item) {
          await doc.synchronize();
          let res = await this.prepare(doc.textDocument, position, source.token);
          item = res ? res[0] : void 0;
          if (!res) throw new Error("Unable to getCallHierarchyItem at current position");
        }
        let method = kind == "incoming" ? "provideIncomingCalls" : "provideOutgoingCalls";
        return await languages_default[method](doc.textDocument, item, source.token);
      }
      async getIncoming(item) {
        return await this.getCallHierarchyItems(item, "incoming");
      }
      async getOutgoing(item) {
        return await this.getCallHierarchyItems(item, "outgoing");
      }
      async showCallHierarchyTree(kind) {
        const { doc, position, winid } = await this.handler.getCurrentState();
        await doc.synchronize();
        if (!languages_default.hasProvider("callHierarchy" /* CallHierarchy */, doc.textDocument)) {
          void window_default.showErrorMessage(`CallHierarchy provider not found for current document, it's not supported by your languageserver`);
          return;
        }
        const res = await languages_default.prepareCallHierarchy(doc.textDocument, position, import_node4.CancellationToken.None);
        const rootItems = isCallHierarchyItem(res) ? [res] : res;
        if (isFalsyOrEmpty(rootItems)) {
          void window_default.showWarningMessage("Unable to get CallHierarchyItem at cursor position.");
          return;
        }
        let provider = this.createProvider(rootItems, doc.textDocument, winid, kind);
        let treeView = new BasicTreeView("CALLS", { treeDataProvider: provider });
        treeView.title = getTitle(kind);
        provider.onDidChangeTreeData((e) => {
          if (!e) treeView.title = getTitle(provider.meta);
        });
        treeView.onDidChangeVisibility((e) => {
          if (!e.visible) provider.dispose();
        });
        this.disposables.push(treeView);
        await treeView.show(this.config.splitCommand);
      }
      dispose() {
        this.highlightWinids.clear();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/codeActions.ts
function shouldAutoApply(only) {
  if (!only) return false;
  if (typeof only === "string" || only[0] === CodeActionKind.QuickFix || only[0] === CodeActionKind.SourceFixAll) {
    return workspace_default.initialConfiguration.get("coc.preferences.autoApplySingleQuickfix", true);
  }
  return false;
}
function isQuickfix(codeAction) {
  return codeAction.kind && codeAction.kind.startsWith("quickfix");
}
var logger49, CodeActions;
var init_codeActions = __esm({
  "src/handler/codeActions.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_manager();
    init_languages();
    init_logger();
    init_array();
    init_numbers();
    init_protocol();
    init_timing();
    init_window();
    init_workspace();
    logger49 = createLogger("handler-codeActions");
    CodeActions = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        handler.addDisposable(commands_default.registerCommand("editor.action.organizeImport", async () => {
          let succeed = await this.organizeImport();
          if (!succeed) void window_default.showWarningMessage(`Organize import action not found`);
        }));
        commands_default.titles.set("editor.action.organizeImport", "Run organize import code action, show warning when not exists");
        handler.addDisposable(commands_default.registerCommand("editor.action.executeCodeActions", async (doc, range, actionKinds, timeout2) => {
          await this.executeCodeActions(doc, range, actionKinds, timeout2);
        }, this, true));
      }
      async executeCodeActions(doc, range, actionKinds, timeout2) {
        let timing = createTiming("Execute code action", timeout2);
        let applied = [];
        for (const kind of actionKinds) {
          let codeActions = await this.getCodeActions(doc, range, [kind]);
          let codeAction = codeActions.find((o) => !o.disabled);
          if (codeAction) {
            logger49.info(`Apply code action "${kind}" to buffer ${doc.bufnr}`);
            timing.start(`"${kind}"`);
            let tokenSource = new import_node4.CancellationTokenSource();
            let timer;
            let _resolve;
            const tp = new Promise((c) => {
              timer = setTimeout(() => {
                logger49.warn(`Apply code action "${kind}" timeout after ${timeout2}ms`);
                tokenSource.cancel();
                c(void 0);
              }, timeout2);
              _resolve = c;
            });
            await Promise.race([tp, this.applyCodeAction(codeAction, tokenSource.token)]);
            if (!tokenSource.token.isCancellationRequested) {
              applied.push(kind);
            }
            timing.stop();
            clearTimeout(timer);
            _resolve(void 0);
            tokenSource.dispose();
            await doc.synchronize();
          }
        }
        return applied;
      }
      async codeActionRange(start, end, only) {
        let { doc } = await this.handler.getCurrentState();
        await doc.synchronize();
        let line = doc.getline(end - 1);
        let range = Range.create(start - 1, 0, end - 1, line.length);
        let codeActions = await this.getCodeActions(doc, range, only ? [only] : null);
        codeActions = codeActions.filter((o) => !o.disabled);
        if (!codeActions || codeActions.length == 0) {
          void window_default.showWarningMessage(`No${only ? " " + only : ""} code action available`);
          return;
        }
        let idx = await window_default.showMenuPicker(codeActions.map((o) => o.title), "Choose action");
        let action = codeActions[idx];
        if (action) await this.applyCodeAction(action);
      }
      async organizeImport() {
        let { doc } = await this.handler.getCurrentState();
        await doc.synchronize();
        let actions = await this.getCodeActions(doc, void 0, [CodeActionKind.SourceOrganizeImports]);
        if (actions && actions.length) {
          await this.applyCodeAction(actions[0]);
          return true;
        }
        return false;
      }
      async getCodeActions(doc, range, only) {
        let excludeSourceAction = range !== null && (!only || only.findIndex((o) => o.startsWith(CodeActionKind.Source)) == -1);
        range = range ?? Range.create(0, 0, doc.lineCount, 0);
        let diagnostics = manager_default.getDiagnosticsInRange(doc.textDocument, range);
        let context = { diagnostics, triggerKind: CodeActionTriggerKind.Invoked };
        if (!isFalsyOrEmpty(only)) context.only = only;
        let tokenSource = new import_node4.CancellationTokenSource();
        let codeActions = await languages_default.getCodeActions(doc.textDocument, range, context, tokenSource.token);
        if (!codeActions || codeActions.length == 0) return [];
        if (excludeSourceAction) {
          codeActions = codeActions.filter((o) => !o.kind || !o.kind.startsWith(CodeActionKind.Source));
        }
        codeActions.sort((a, b) => {
          if (a.disabled && !b.disabled) return 1;
          if (b.disabled && !a.disabled) return -1;
          if (a.isPreferred != b.isPreferred) return boolToNumber(b.isPreferred) - boolToNumber(a.isPreferred);
          if (!only) {
            if (isQuickfix(a) && !isQuickfix(b)) return -1;
            if (isQuickfix(b) && !isQuickfix(a)) return 1;
          }
          return 0;
        });
        return codeActions;
      }
      get floatActions() {
        return workspace_default.initialConfiguration.get("coc.preferences.floatActions", true);
      }
      async doCodeAction(mode, only, showDisable = false) {
        let { doc } = await this.handler.getCurrentState();
        let range;
        if (mode) range = await window_default.getSelectedRange(mode);
        await doc.synchronize();
        let codeActions = await this.getCodeActions(doc, range, Array.isArray(only) ? only : null);
        if (typeof only == "string") {
          codeActions = codeActions.filter((o) => o.title == only || o.command && o.command.title == only);
        } else if (Array.isArray(only)) {
          codeActions = codeActions.filter((o) => only.some((k) => o.kind && o.kind.startsWith(k)));
        }
        if (!this.floatActions || !showDisable) codeActions = codeActions.filter((o) => !o.disabled);
        if (!codeActions || codeActions.length == 0) {
          void window_default.showWarningMessage(`No${only ? " " + only : ""} code action available`);
          return;
        }
        if (codeActions.length == 1 && !codeActions[0].disabled && shouldAutoApply(only)) {
          await this.applyCodeAction(codeActions[0]);
          return;
        }
        let idx = this.floatActions ? await window_default.showMenuPicker(
          codeActions.map((o) => {
            return { text: o.title, disabled: o.disabled };
          }),
          "Choose action"
        ) : await window_default.requestInputList("Choose action by number", codeActions.map((o) => o.title));
        let action = codeActions[idx];
        if (action) await this.applyCodeAction(action);
      }
      /**
       * Get current codeActions
       */
      async getCurrentCodeActions(mode, only) {
        let { doc } = await this.handler.getCurrentState();
        let range;
        if (mode) range = await window_default.getSelectedRange(mode);
        let codeActions = await this.getCodeActions(doc, range, only);
        return codeActions.filter((o) => !o.disabled);
      }
      /**
       * Invoke preferred quickfix at current position
       */
      async doQuickfix() {
        let actions = await this.getCurrentCodeActions("currline", [CodeActionKind.QuickFix]);
        if (!actions || actions.length == 0) {
          void window_default.showWarningMessage(`No quickfix action available`);
          return;
        }
        await this.applyCodeAction(actions[0]);
        this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-fix-current)", -1)`, true);
      }
      async applyCodeAction(action, token) {
        if (action.disabled) {
          throw new Error(`Action "${action.title}" is disabled: ${action.disabled.reason}`);
        }
        token = token == null ? import_node4.CancellationToken.None : token;
        let resolved = await languages_default.resolveCodeAction(action, token);
        if (!resolved || token.isCancellationRequested) return;
        let { edit: edit2, command } = resolved;
        if (edit2) await workspace_default.applyEdit(edit2);
        if (command) await commands_default.execute(command);
      }
    };
  }
});

// src/handler/codelens/buffer.ts
function getTextAlign(position) {
  if (position == "top") return "above" /* Above */;
  if (position == "eol") return "after" /* After */;
  if (position === "right_align") return "right" /* Right */;
  return "above" /* Above */;
}
function getCommands(line, codeLenses) {
  if (!codeLenses?.length) return [];
  let commands = [];
  for (let codeLens of codeLenses) {
    let { range, command } = codeLens;
    if (!isCommand(command)) continue;
    if (line == range.start.line) {
      commands.push(command);
    }
  }
  return commands;
}
var logger50, srcId, debounceTime8, CODELENS_HL, NORMAL_HL, CodeLensBuffer;
var init_buffer3 = __esm({
  "src/handler/codelens/buffer.ts"() {
    "use strict";
    init_commands();
    init_languages();
    init_logger();
    init_util();
    init_array();
    init_errors();
    init_is();
    init_node();
    init_protocol();
    init_window();
    init_workspace();
    logger50 = createLogger("codelens-buffer");
    debounceTime8 = getConditionValue(200, 20);
    CODELENS_HL = "CocCodeLens";
    NORMAL_HL = "Normal";
    CodeLensBuffer = class {
      constructor(nvim, document2) {
        this.nvim = nvim;
        this.document = document2;
        this.resolveCodeLens = debounce(() => {
          this._resolveCodeLenses().catch(onUnexpectedError);
        }, debounceTime8);
        this.debounceFetch = debounce(() => {
          this.fetchCodeLenses().catch(onUnexpectedError);
        }, debounceTime8);
        if (this.hasProvider) this.debounceFetch();
      }
      get config() {
        if (this._config) return this._config;
        this.loadConfiguration();
        return this._config;
      }
      loadConfiguration() {
        let config = workspace_default.getConfiguration("codeLens", this.document);
        this._config = {
          enabled: config.get("enable", false),
          display: config.get("display", true),
          position: config.get("position", "top"),
          separator: config.get("separator", ""),
          subseparator: config.get("subseparator", " ")
        };
      }
      async toggleDisplay() {
        if (!this.hasProvider || !this.config.enabled) return;
        if (this.config.display) {
          this.config.display = false;
          this.clear();
        } else {
          this.config.display = true;
          this.resolveCodeLens.clear();
          await this._resolveCodeLenses();
        }
      }
      get bufnr() {
        return this.document.bufnr;
      }
      onChange(e) {
        if (e.contentChanges.length === 0 && this.codeLenses != null) {
          this.resolveCodeLens.clear();
          this._resolveCodeLenses().catch(onUnexpectedError);
        } else {
          this.cancel();
          this.debounceFetch();
        }
      }
      get currentCodeLens() {
        return this.codeLenses?.codeLenses;
      }
      get hasProvider() {
        return languages_default.hasProvider("codeLens" /* CodeLens */, this.document);
      }
      async forceFetch() {
        if (!this.config.enabled || !this.hasProvider) return;
        await this.document.synchronize();
        this.cancel();
        await this.fetchCodeLenses();
      }
      async fetchCodeLenses() {
        if (!this.hasProvider || !this.config.enabled) return;
        let noFetch = this.codeLenses?.version == this.document.version;
        if (!noFetch) {
          let empty = this.codeLenses == null;
          let { textDocument } = this.document;
          let version2 = textDocument.version;
          this.cancelFetch();
          let tokenSource = this.tokenSource = new import_node4.CancellationTokenSource();
          let token = tokenSource.token;
          if (!srcId) srcId = await this.nvim.createNamespace("coc-codelens");
          let codeLenses = await languages_default.getCodeLens(textDocument, token);
          if (token.isCancellationRequested) return;
          codeLenses = defaultValue(codeLenses, []);
          codeLenses = codeLenses.filter((o) => o != null);
          if (isFalsyOrEmpty(codeLenses)) {
            this.clear();
            return;
          }
          this.codeLenses = { version: version2, codeLenses };
          if (empty) this.setVirtualText(codeLenses);
        }
        this.resolveCodeLens.clear();
        await this._resolveCodeLenses();
      }
      /**
       * Resolve visible codeLens
       */
      async _resolveCodeLenses() {
        if (!this.codeLenses || this.isChanged) return;
        let { codeLenses } = this.codeLenses;
        let [bufnr, start, end, total] = await this.nvim.eval(`[bufnr('%'),line('w0'),line('w$'),line('$')]`);
        if (this.isChanged || bufnr != this.bufnr) return;
        this.cancel();
        codeLenses = codeLenses.filter((o) => {
          let lnum = o.range.start.line + 1;
          return lnum >= start && lnum <= end;
        });
        if (codeLenses.length) {
          let tokenSource = this.resolveTokenSource = new import_node4.CancellationTokenSource();
          let token = tokenSource.token;
          await Promise.all(codeLenses.map((codeLens) => {
            if (isCommand(codeLens.command)) return Promise.resolve();
            codeLens.command = void 0;
            return languages_default.resolveCodeLens(codeLens, token);
          }));
          this.resolveTokenSource = void 0;
          if (token.isCancellationRequested || this.isChanged) return;
        }
        if (end == total) end = -1;
        this.nvim.pauseNotification();
        this.clear();
        this.setVirtualText(codeLenses);
        this.nvim.resumeNotification(true, true);
      }
      get isChanged() {
        if (!this.codeLenses || this.document.dirty) return true;
        let { version: version2 } = this.codeLenses;
        return this.document.textDocument.version !== version2;
      }
      /**
       * Attach resolved codeLens
       */
      setVirtualText(codeLenses) {
        let { document: document2 } = this;
        if (!srcId || !document2 || !codeLenses.length || !this.config.display) return;
        let top = this.config.position === "top";
        let list2 = /* @__PURE__ */ new Map();
        for (let codeLens of codeLenses) {
          let { line } = codeLens.range.start;
          let curr = list2.get(line) ?? [];
          curr.push(codeLens);
          list2.set(line, curr);
        }
        for (let lnum of list2.keys()) {
          let codeLenses2 = list2.get(lnum);
          let commands = codeLenses2.reduce((p, c) => {
            if (c && c.command && c.command.title) p.push(c.command.title.replace(/\s+/g, " "));
            return p;
          }, []);
          let chunks = [];
          let len = commands.length;
          for (let i = 0; i < len; i++) {
            let title = commands[i];
            chunks.push([title, CODELENS_HL]);
            if (i != len - 1) {
              chunks.push([this.config.subseparator, CODELENS_HL]);
            }
          }
          if (chunks.length > 0 && this.config.separator) {
            chunks.unshift([`${this.config.separator} `, CODELENS_HL]);
          }
          if (top && chunks.length == 0) {
            chunks.push([" ", NORMAL_HL]);
          }
          if (chunks.length > 0) {
            document2.buffer.setVirtualText(srcId, lnum, chunks, {
              text_align: getTextAlign(this.config.position),
              indent: true
            });
          }
        }
      }
      clear(start = 0, end = -1) {
        if (!srcId) return;
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.clearNamespace(srcId, start, end);
      }
      async doAction(line) {
        let commands = getCommands(line, this.codeLenses?.codeLenses);
        if (commands.length == 1) {
          await commands_default.execute(commands[0]);
        } else if (commands.length > 1) {
          let res = await window_default.showMenuPicker(commands.map((c) => c.title));
          if (res != -1) await commands_default.execute(commands[res]);
        }
      }
      cancelFetch() {
        this.debounceFetch.clear();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      cancelResolve() {
        if (this.resolveTokenSource) {
          this.resolveTokenSource.cancel();
          this.resolveTokenSource = null;
        }
      }
      cancel() {
        this.resolveCodeLens.clear();
        this.cancelResolve();
        this.cancelFetch();
      }
      abandonResult() {
        this.codeLenses = void 0;
      }
      dispose() {
        this.cancel();
        this.codeLenses = void 0;
      }
    };
  }
});

// src/handler/codelens/index.ts
var debounceTime9, CodeLensManager2;
var init_codelens = __esm({
  "src/handler/codelens/index.ts"() {
    "use strict";
    init_node();
    init_commands();
    init_events();
    init_languages();
    init_util();
    init_protocol();
    init_window();
    init_workspace();
    init_buffer3();
    debounceTime9 = getConditionValue(200, 0);
    CodeLensManager2 = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("codeLens")) {
            for (let item of this.buffers.items) {
              item.loadConfiguration();
            }
          }
        }, this, this.disposables);
        this.buffers = workspace_default.registerBufferSync((doc) => {
          if (doc.buftype != "") return void 0;
          return new CodeLensBuffer(nvim, doc);
        });
        this.disposables.push(this.buffers);
        events_default.on("CursorHold", async (bufnr) => {
          let item = this.buffers.getItem(bufnr);
          if (item && item.config.enabled && !item.currentCodeLens) await item.forceFetch();
        }, null, this.disposables);
        events_default.on("CursorMoved", (bufnr) => {
          let buf = this.buffers.getItem(bufnr);
          if (buf) buf.resolveCodeLens();
        }, null, this.disposables);
        let debounced = debounce(async (selector) => {
          for (let item of this.buffers.items) {
            if (!workspace_default.match(selector, item.document)) continue;
            item.abandonResult();
            await item.forceFetch();
          }
        }, debounceTime9);
        this.disposables.push(import_node4.Disposable.create(() => {
          debounced.clear();
        }));
        languages_default.onDidCodeLensRefresh(debounced, null, this.disposables);
        commands_default.register({
          id: "document.toggleCodeLens",
          execute: () => {
            return this.toggle(workspace_default.bufnr);
          }
        }, false, "toggle codeLens display of current buffer");
      }
      async toggle(bufnr) {
        let item = this.buffers.getItem(bufnr);
        try {
          workspace_default.getAttachedDocument(bufnr);
          await item.toggleDisplay();
        } catch (e) {
          void window_default.showErrorMessage(e.message);
        }
      }
      /**
       * Check provider for buf that not fetched
       */
      async checkProvider() {
        for (let buf of this.buffers.items) {
          await buf.forceFetch();
        }
      }
      async doAction() {
        let [bufnr, line] = await this.nvim.eval(`[bufnr("%"),line(".")-1]`);
        let buf = this.buffers.getItem(bufnr);
        if (buf) await buf.doAction(line);
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/util/color.ts
function pad(str) {
  return str.length == 1 ? `0${str}` : str;
}
function toHexString(color) {
  let c = toHexColor(color);
  return `${pad(c.red.toString(16))}${pad(c.green.toString(16))}${pad(c.blue.toString(16))}`;
}
function toHexColor(color) {
  let { red, green, blue: blue2 } = color;
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue2 * 255)
  };
}
function isDark(color) {
  let rgb = [color.red, color.green, color.blue];
  let lum = [];
  for (let i = 0; i < rgb.length; i++) {
    let chan = rgb[i];
    lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
  }
  let luma = 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
  return luma <= 0.5;
}
var init_color = __esm({
  "src/util/color.ts"() {
    "use strict";
  }
});

// src/handler/colors/colorBuffer.ts
function getHighlightGroup2(color) {
  return `BG${toHexString(color)}`;
}
var NAMESPACE2, debounceTime10, ColorBuffer;
var init_colorBuffer = __esm({
  "src/handler/colors/colorBuffer.ts"() {
    "use strict";
    init_languages();
    init_util();
    init_color();
    init_is();
    init_node();
    init_position();
    init_protocol();
    init_window();
    init_workspace();
    NAMESPACE2 = "color";
    debounceTime10 = getConditionValue(200, 10);
    ColorBuffer = class {
      // last highlight version
      constructor(nvim, doc, config, usedColors) {
        this.nvim = nvim;
        this.doc = doc;
        this.config = config;
        this.usedColors = usedColors;
        this._colors = [];
        this.highlight = debounce(() => {
          void this.doHighlight();
        }, debounceTime10);
        if (this.hasProvider) this.highlight();
      }
      get enable() {
        if (boolean(this._enable)) return this._enable;
        this._enable = workspace_default.getConfiguration("colors", this.doc).get("enable", false);
        return this._enable;
      }
      updateDocumentConfig() {
        let enable = this.enabled;
        this._enable = workspace_default.getConfiguration("colors", this.doc).get("enable", false);
        if (enable != this.enabled) {
          if (enable) {
            this.clearHighlight();
          } else {
            void this.doHighlight();
          }
        }
      }
      toggle() {
        if (this._enable) {
          this._enable = false;
          this.clearHighlight();
        } else {
          this._enable = true;
          void this.doHighlight();
        }
      }
      get hasProvider() {
        return languages_default.hasProvider("documentColor" /* DocumentColor */, this.doc);
      }
      get enabled() {
        let { filetypes } = this.config;
        let { filetype } = this.doc;
        if (!this.hasProvider) return false;
        if (Array.isArray(filetypes) && (filetypes.includes("*") || filetypes.includes(filetype))) return true;
        return this.enable;
      }
      onChange() {
        this.cancel();
        this.highlight();
      }
      get buffer() {
        return this.doc.buffer;
      }
      get colors() {
        return this._colors;
      }
      hasColor() {
        return this._colors.length > 0;
      }
      async doHighlight() {
        if (!this.enabled) return;
        let { nvim, doc } = this;
        this.tokenSource = new import_node4.CancellationTokenSource();
        let { token } = this.tokenSource;
        let colors;
        colors = await languages_default.provideDocumentColors(doc.textDocument, token);
        if (token.isCancellationRequested) return;
        colors = colors || [];
        colors.sort((a, b) => comparePosition(a.range.start, b.range.start));
        this._colors = colors;
        let items = [];
        colors.forEach((o) => {
          let hlGroup = getHighlightGroup2(o.color);
          doc.addHighlights(items, hlGroup, o.range, { combine: false });
        });
        let diff = await window_default.diffHighlights(doc.bufnr, NAMESPACE2, items);
        if (token.isCancellationRequested || !diff) return;
        nvim.pauseNotification();
        this.defineColors(colors);
        nvim.resumeNotification(false, true);
        await window_default.applyDiffHighlights(doc.bufnr, NAMESPACE2, this.config.highlightPriority, diff, true);
      }
      defineColors(colors) {
        for (let color of colors) {
          let hex = toHexString(color.color);
          if (!this.usedColors.has(hex)) {
            this.nvim.command(`hi BG${hex} guibg=#${hex} guifg=#${isDark(color.color) ? "ffffff" : "000000"}`, true);
            this.usedColors.add(hex);
          }
        }
      }
      hasColorAtPosition(position) {
        return this.colors.some((o) => positionInRange(position, o.range) == 0);
      }
      clearHighlight() {
        this.highlight.clear();
        this._colors = [];
        this.buffer.clearNamespace("color");
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      dispose() {
        this._colors = [];
        this.highlight.clear();
        this.cancel();
      }
    };
  }
});

// src/handler/colors/index.ts
var Colors;
var init_colors = __esm({
  "src/handler/colors/index.ts"() {
    "use strict";
    init_commands();
    init_events();
    init_languages();
    init_util();
    init_color();
    init_protocol();
    init_window();
    init_workspace();
    init_colorBuffer();
    Colors = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        let usedColors = /* @__PURE__ */ new Set();
        this.highlighters = workspace_default.registerBufferSync((doc) => {
          return new ColorBuffer(this.nvim, doc, this.config, usedColors);
        });
        events_default.on("ColorScheme", () => {
          usedColors.clear();
          for (let item of this.highlighters.items) {
            item.cancel();
            void item.doHighlight();
          }
        }, null, this.disposables);
        languages_default.onDidColorsRefresh((selector) => {
          for (let item of this.highlighters.items) {
            if (workspace_default.match(selector, item.doc)) {
              item.highlight();
            }
          }
        });
        commands_default.register({
          id: "editor.action.pickColor",
          execute: async () => {
            await this.pickColor();
          }
        }, false, "pick color from system color picker when possible.");
        commands_default.register({
          id: "editor.action.colorPresentation",
          execute: async () => {
            await this.pickPresentation();
          }
        }, false, "change color presentation.");
        commands_default.register({
          id: "document.toggleColors",
          execute: async () => {
            let bufnr = await nvim.call("bufnr", ["%"]);
            let item = this.highlighters.getItem(bufnr);
            workspace_default.getAttachedDocument(bufnr);
            item.toggle();
          }
        }, false, "toggle colors for current buffer");
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("colors")) {
          let c = workspace_default.initialConfiguration.get("colors");
          this.config = Object.assign(this.config ?? {}, {
            filetypes: c.filetypes,
            highlightPriority: defaultValue(c.highlightPriority, 1e3)
          });
          if (e) {
            for (let item of this.highlighters.items) {
              item.updateDocumentConfig();
            }
          }
        }
      }
      async pickPresentation() {
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvider("documentColor" /* DocumentColor */, doc.textDocument);
        let info = await this.getColorInformation(doc.bufnr);
        if (!info) return void window_default.showWarningMessage("Color not found at current position");
        let tokenSource = new import_node4.CancellationTokenSource();
        let presentations = await languages_default.provideColorPresentations(info, doc.textDocument, tokenSource.token);
        if (!presentations?.length) return void window_default.showWarningMessage("No color presentations found");
        let res = await window_default.showMenuPicker(presentations.map((o) => o.label), "Choose color:");
        if (res == -1) return;
        let presentation = presentations[res];
        let { textEdit, additionalTextEdits, label } = presentation;
        if (!textEdit) textEdit = { range: info.range, newText: label };
        await doc.applyEdits([textEdit]);
        if (additionalTextEdits) await doc.applyEdits(additionalTextEdits);
      }
      async pickColor() {
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvider("documentColor" /* DocumentColor */, doc.textDocument);
        let info = await this.getColorInformation(doc.bufnr);
        if (!info) return void window_default.showWarningMessage("Color not found at current position");
        let { color } = info;
        let colorArr = [(color.red * 255).toFixed(0), (color.green * 255).toFixed(0), (color.blue * 255).toFixed(0)];
        let res = await this.nvim.call("coc#color#pick_color", [colorArr]);
        if (!res) return;
        let hex = toHexString({
          red: res[0] / 65535,
          green: res[1] / 65535,
          blue: res[2] / 65535,
          alpha: 1
        });
        await doc.applyEdits([{
          range: info.range,
          newText: `#${hex}`
        }]);
      }
      isEnabled(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        return highlighter != null && highlighter.enabled === true;
      }
      clearHighlight(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (highlighter) highlighter.clearHighlight();
      }
      hasColor(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter) return false;
        return highlighter.hasColor();
      }
      hasColorAtPosition(bufnr, position) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter) return false;
        return highlighter.hasColorAtPosition(position);
      }
      highlightAll() {
        for (let buf of this.highlighters.items) {
          buf.highlight();
        }
      }
      async doHighlight(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (highlighter) await highlighter.doHighlight();
      }
      async getColorInformation(bufnr) {
        let highlighter = this.highlighters.getItem(bufnr);
        if (!highlighter) return null;
        let position = await window_default.getCursorPosition();
        for (let info of highlighter.colors) {
          let { range } = info;
          let { start, end } = range;
          if (position.line == start.line && position.character >= start.character && position.character <= end.character) {
            return info;
          }
        }
        return null;
      }
      dispose() {
        this.highlighters.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/commands.ts
function validCommand(command) {
  return command && string(command.id) && string(command.cmd) && command.id.length > 0 && command.cmd.length > 0;
}
var Commands;
var init_commands3 = __esm({
  "src/handler/commands.ts"() {
    "use strict";
    init_commands();
    init_manager3();
    init_workspace();
    init_is();
    Commands = class {
      constructor(nvim) {
        this.nvim = nvim;
        for (let item of workspace_default.env.vimCommands) {
          this.addVimCommand(item);
        }
      }
      addVimCommand(cmd) {
        if (!validCommand(cmd)) return;
        let id2 = `vim.${cmd.id}`;
        commands_default.registerCommand(id2, () => {
          this.nvim.command(cmd.cmd, true);
          this.nvim.redrawVim();
        });
        if (cmd.title) commands_default.titles.set(id2, cmd.title);
      }
      getCommandList() {
        return commands_default.commandList.map((o) => o.id);
      }
      async repeat() {
        await commands_default.repeatCommand();
      }
      async runCommand(id2, ...args) {
        if (id2) return await commands_default.fireCommand(id2, ...args);
        await manager_default2.start(["commands"]);
      }
    };
  }
});

// src/handler/fold.ts
var FoldHandler;
var init_fold = __esm({
  "src/handler/fold.ts"() {
    "use strict";
    init_languages();
    FoldHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
      }
      async fold(kind) {
        let { doc, winid } = await this.handler.getCurrentState();
        this.handler.checkProvider("foldingRange" /* FoldingRange */, doc.textDocument);
        await doc.synchronize();
        let win = this.nvim.createWindow(winid);
        let foldlevel = await this.nvim.eval("&foldlevel");
        let ranges = await this.handler.withRequestToken("foldingrange", (token) => {
          return languages_default.provideFoldingRanges(doc.textDocument, {}, token);
        }, true);
        if (!ranges || !ranges.length) return false;
        if (kind) ranges = ranges.filter((o) => o.kind == kind);
        ranges.sort((a, b) => b.startLine - a.startLine);
        this.nvim.pauseNotification();
        win.setOption("foldmethod", "manual", true);
        this.nvim.command("normal! zE", true);
        for (let range of ranges) {
          let { startLine, endLine } = range;
          let cmd = `${startLine + 1}, ${endLine + 1}fold`;
          this.nvim.command(cmd, true);
        }
        win.setOption("foldenable", true, true);
        win.setOption("foldlevel", foldlevel, true);
        await this.nvim.resumeNotification(true);
        return true;
      }
    };
  }
});

// src/handler/format.ts
var logger51, FormatHandler;
var init_format2 = __esm({
  "src/handler/format.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_events();
    init_languages();
    init_logger();
    init_array();
    init_util();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    logger51 = createLogger("handler-format");
    FormatHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.setConfiguration();
        handler.addDisposable(workspace_default.onDidChangeConfiguration(this.setConfiguration, this));
        handler.addDisposable(window_default.onDidChangeActiveTextEditor(() => {
          this.setConfiguration();
        }));
        handler.addDisposable(workspace_default.onWillSaveTextDocument((event) => {
          if (this.shouldFormatOnSave(event.document)) {
            let willSaveWaitUntil = async () => {
              if (!languages_default.hasFormatProvider(event.document)) {
                logger51.warn(`Format provider not found for ${event.document.uri}`);
                return void 0;
              }
              let options2 = await workspace_default.getFormatOptions(event.document.uri);
              let formatOnSaveTimeout = workspace_default.getConfiguration("coc.preferences", event.document).get("formatOnSaveTimeout", 500);
              let timer;
              let tokenSource = new import_node4.CancellationTokenSource();
              const tp = new Promise((c) => {
                timer = setTimeout(() => {
                  logger51.warn(`Format on save timeout after ${formatOnSaveTimeout}ms`, event.document.uri);
                  tokenSource.cancel();
                  c(void 0);
                }, formatOnSaveTimeout);
              });
              const provideEdits = languages_default.provideDocumentFormattingEdits(event.document, options2, tokenSource.token);
              let textEdits = await Promise.race([tp, provideEdits]);
              clearTimeout(timer);
              this.logProvider(event.bufnr, textEdits);
              return Array.isArray(textEdits) ? textEdits : void 0;
            };
            event.waitUntil(willSaveWaitUntil());
          }
        }));
        handler.addDisposable(events_default.on("Enter", async (bufnr) => {
          let res = await events_default.race(["CursorMovedI"], 100);
          if (res.args && res.args[0] === bufnr) {
            await this.handleEnter(bufnr);
          }
        }));
        handler.addDisposable(events_default.on("TextInsert", async (bufnr, _info, character) => {
          let doc = workspace_default.getDocument(bufnr);
          if (!events_default.completing && doc && doc.attached) await this.tryFormatOnType(character, doc);
        }));
        handler.addDisposable(commands_default.registerCommand("editor.action.formatDocument", async (uri) => {
          const doc = uri ? workspace_default.getDocument(uri) : (await this.handler.getCurrentState()).doc;
          await this.documentFormat(doc);
        }));
        commands_default.titles.set("editor.action.formatDocument", "Format Document");
      }
      shouldFormatOnSave(doc) {
        let { languageId, uri } = doc;
        let document2 = workspace_default.getDocument(doc.uri);
        if (!document2 || document2.getVar("disable_autoformat", 0)) return false;
        let config = workspace_default.getConfiguration("coc.preferences", { uri, languageId });
        let filetypes = config.get("formatOnSaveFiletypes", null);
        if (Array.isArray(filetypes)) return filetypes.includes("*") || filetypes.includes(languageId);
        let formatOnSave = config.get("formatOnSave", false);
        return formatOnSave;
      }
      setConfiguration(e) {
        if (!e || e.affectsConfiguration("coc.preferences")) {
          let doc = window_default.activeTextEditor?.document;
          let config = workspace_default.getConfiguration("coc.preferences", doc);
          this.preferences = {
            formatOnType: config.get("formatOnType", false),
            formatOnTypeFiletypes: config.get("formatOnTypeFiletypes", null),
            bracketEnterImprove: config.get("bracketEnterImprove", true)
          };
        }
      }
      shouldFormatOnType(filetype) {
        const filetypes = this.preferences.formatOnTypeFiletypes;
        return isFalsyOrEmpty(filetypes) || filetypes.includes(filetype) || filetypes.includes("*");
      }
      async tryFormatOnType(ch, doc) {
        if (doc.getVar("disable_autoformat", 0)) return false;
        if (!this.preferences.formatOnType) return false;
        if (!ch || isAlphabet(ch.charCodeAt(0))) return false;
        if (!this.shouldFormatOnType(doc.filetype)) return false;
        if (!languages_default.hasProvider("formatOnType" /* FormatOnType */, doc.textDocument)) {
          logger51.warn(`Format on type provider not found for buffer: ${doc.uri}`);
          return false;
        }
        if (!languages_default.canFormatOnType(ch, doc.textDocument)) return false;
        let position;
        let edits = await this.handler.withRequestToken("Format on type", async (token) => {
          position = await window_default.getCursorPosition();
          await doc.synchronize();
          return await languages_default.provideDocumentOnTypeEdits(ch, doc.textDocument, position, token);
        });
        if (edits == null || events_default.completing) return false;
        if (edits.length === 0) return true;
        await doc.applyEdits(edits, false, true);
        this.logProvider(doc.bufnr, edits);
        return true;
      }
      async formatCurrentBuffer() {
        let { doc } = await this.handler.getCurrentState();
        return await this.documentFormat(doc);
      }
      async formatCurrentRange(mode) {
        let { doc } = await this.handler.getCurrentState();
        return await this.documentRangeFormat(doc, mode);
      }
      async documentFormat(doc) {
        await doc.synchronize();
        if (!languages_default.hasFormatProvider(doc.textDocument)) {
          throw new Error(`Format provider not found for buffer: ${doc.bufnr}`);
        }
        let options2 = await workspace_default.getFormatOptions(doc.uri);
        let textEdits = await this.handler.withRequestToken("format", (token) => {
          return languages_default.provideDocumentFormattingEdits(doc.textDocument, options2, token);
        });
        if (textEdits && textEdits.length > 0) {
          await doc.applyEdits(textEdits, false, true);
          this.logProvider(doc.bufnr, textEdits);
          return true;
        }
        return false;
      }
      async handleEnter(bufnr) {
        let { nvim } = this;
        let { bracketEnterImprove } = this.preferences;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached) return;
        await this.tryFormatOnType("\n", doc);
        if (bracketEnterImprove) {
          let line = await nvim.call("line", ".") - 1;
          await doc.patchChange();
          let pre = doc.getline(line - 1);
          let curr = doc.getline(line);
          let firstLine = doc.getline(0);
          let prevChar = pre[pre.length - 1];
          if (prevChar && pariedCharacters.has(prevChar)) {
            let nextChar = curr.trim()[0];
            if (nextChar && pariedCharacters.get(prevChar) == nextChar) {
              let edits = [];
              let pos = Position.create(line - 1, pre.length);
              if (doc.filetype == "vim" && !firstLine.startsWith("vim9script")) {
                let opts = await workspace_default.getFormatOptions(doc.uri);
                let space = opts.insertSpaces ? " ".repeat(opts.tabSize) : "	";
                let currIndent = curr.match(/^\s*/)[0];
                let newText = "\n" + currIndent + space;
                edits.push({ range: Range.create(line, currIndent.length, line, currIndent.length), newText: "  \\ " });
                newText = newText + "\\ ";
                edits.push({ range: Range.create(pos, pos), newText });
                await doc.applyEdits(edits);
                await window_default.moveTo(Position.create(line, newText.length - 1));
              } else {
                await nvim.eval(`feedkeys("\\<Esc>O", 'in')`);
              }
            }
          }
        }
      }
      logProvider(bufnr, edits) {
        if (!Array.isArray(edits) || edits.length === 0) return;
        let extensionName = edits["__extensionName"];
        if (extensionName) logger51.info(`Format buffer ${bufnr} by ${extensionName}`);
      }
      async documentRangeFormat(doc, mode) {
        this.handler.checkProvider("formatRange" /* FormatRange */, doc.textDocument);
        await doc.synchronize();
        let range;
        if (mode) {
          range = await window_default.getSelectedRange(mode);
          if (!range) return -1;
        } else {
          let [lnum, count, mode2] = await this.nvim.eval("[v:lnum,v:count,mode()]");
          if (count == 0 || mode2 == "i" || mode2 == "R") return -1;
          range = Range.create(lnum - 1, 0, lnum - 1 + count, 0);
        }
        let options2 = await workspace_default.getFormatOptions(doc.uri);
        let textEdits = await this.handler.withRequestToken("Format range", (token) => {
          return languages_default.provideDocumentRangeFormattingEdits(doc.textDocument, range, options2, token);
        });
        if (!isFalsyOrEmpty(textEdits)) {
          await doc.applyEdits(textEdits, false, true);
          this.logProvider(doc.bufnr, textEdits);
          return 0;
        }
        return -1;
      }
    };
  }
});

// src/handler/highlights.ts
var Highlights2;
var init_highlights2 = __esm({
  "src/handler/highlights.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_events();
    init_languages();
    init_util();
    init_position();
    init_protocol();
    init_window();
    init_workspace();
    Highlights2 = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.highlights = /* @__PURE__ */ new Map();
        events_default.on(["CursorMoved", "CursorMovedI"], () => {
          this.cancel();
          this.clearHighlights();
        }, null, this.disposables);
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        window_default.onDidChangeActiveTextEditor(() => {
          this.loadConfiguration();
        }, null, this.disposables);
        commands_default.register({
          id: "document.jumpToNextSymbol",
          execute: async () => {
            await this.jumpSymbol("next");
          }
        }, false, "Jump to next symbol highlight position.");
        commands_default.register({
          id: "document.jumpToPrevSymbol",
          execute: async () => {
            await this.jumpSymbol("previous");
          }
        }, false, "Jump to previous symbol highlight position.");
      }
      loadConfiguration(e) {
        let config = workspace_default.getConfiguration("documentHighlight", this.handler.uri);
        if (!e || e.affectsConfiguration("documentHighlight")) {
          this.config = Object.assign(this.config || {}, {
            limit: config.get("limit", 200),
            priority: config.get("priority", -1),
            timeout: config.get("timeout", 300)
          });
        }
      }
      isEnabled(bufnr, cursors) {
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached || cursors) return false;
        if (!languages_default.hasProvider("documentHighlight" /* DocumentHighlight */, doc.textDocument)) return false;
        return true;
      }
      clearHighlights() {
        if (this.highlights.size == 0) return;
        for (let winid of this.highlights.keys()) {
          let win = this.nvim.createWindow(winid);
          win.clearMatchGroup("^CocHighlight");
        }
        this.highlights.clear();
      }
      async highlight() {
        let { nvim } = this;
        this.cancel();
        let [bufnr, winid, pos, cursors] = await nvim.eval(`[bufnr("%"),win_getid(),coc#cursor#position(),get(b:,'coc_cursors_activated',0)]`);
        if (!this.isEnabled(bufnr, cursors)) return;
        let doc = workspace_default.getDocument(bufnr);
        let highlights = await this.getHighlights(doc, Position.create(pos[0], pos[1]));
        if (!highlights) return;
        let groups = {};
        for (let hl of highlights) {
          if (!Range.is(hl.range)) continue;
          let hlGroup = hl.kind == DocumentHighlightKind.Text ? "CocHighlightText" : hl.kind == DocumentHighlightKind.Read ? "CocHighlightRead" : "CocHighlightWrite";
          groups[hlGroup] = groups[hlGroup] || [];
          groups[hlGroup].push(hl.range);
        }
        let win = nvim.createWindow(winid);
        nvim.pauseNotification();
        win.clearMatchGroup("^CocHighlight");
        for (let [hlGroup, ranges] of Object.entries(groups)) {
          win.highlightRanges(hlGroup, ranges, 999, true);
        }
        nvim.resumeNotification(true, true);
        this.highlights.set(winid, highlights);
      }
      async jumpSymbol(direction) {
        let ranges = await this.getSymbolsRanges();
        if (!ranges) return;
        let pos = await window_default.getCursorPosition();
        if (direction == "next") {
          for (let i = 0; i <= ranges.length - 1; i++) {
            if (comparePosition(ranges[i].start, pos) > 0) {
              await window_default.moveTo(ranges[i].start);
              return;
            }
          }
          await window_default.moveTo(ranges[0].start);
        } else {
          for (let i = ranges.length - 1; i >= 0; i--) {
            if (comparePosition(ranges[i].end, pos) < 0) {
              await window_default.moveTo(ranges[i].start);
              return;
            }
          }
          await window_default.moveTo(ranges[ranges.length - 1].start);
        }
      }
      async getSymbolsRanges() {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("documentHighlight" /* DocumentHighlight */, doc.textDocument);
        let highlights = await this.getHighlights(doc, position);
        if (!highlights) return null;
        return highlights.filter((o) => Range.is(o.range)).map((o) => o.range).sort((a, b) => {
          return compareRangesUsingStarts(a, b);
        });
      }
      hasHighlights(winid) {
        return this.highlights.get(winid) != null;
      }
      async getHighlights(doc, position) {
        let line = doc.getline(position.line);
        let ch = line[position.character];
        if (!ch || !doc.isWord(ch)) return null;
        await doc.synchronize();
        this.cancel();
        let source = this.tokenSource = new import_node4.CancellationTokenSource();
        let timer = this.timer = setTimeout(() => {
          source.cancel();
        }, this.config.timeout);
        let highlights = await languages_default.getDocumentHighLight(doc.textDocument, position, source.token);
        clearTimeout(timer);
        if (source.token.isCancellationRequested) return null;
        return highlights;
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource.dispose();
          this.tokenSource = null;
        }
      }
      dispose() {
        if (this.timer) clearTimeout(this.timer);
        this.cancel();
        this.highlights.clear();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/hover.ts
async function addDefinitions(hovers, definitions, filetype) {
  for (const def of definitions) {
    if (!def?.targetRange) continue;
    const { start, end } = def.targetRange;
    const endLine = end.line - start.line >= 100 ? start.line + 100 : end.character == 0 ? end.line - 1 : end.line;
    let lines = await readLines(def.targetUri, start.line, endLine);
    if (lines.length) {
      let indent = lines[0].match(/^\s*/)[0];
      if (indent) lines = lines.map((l) => l.startsWith(indent) ? l.substring(indent.length) : l);
      hovers.push({ content: lines.join("\n"), filetype });
    }
  }
}
function addDocument(docs, text, filetype, isPreview = false) {
  let content = text.trim();
  if (!content.length) return;
  if (isPreview && filetype !== "markdown") {
    content = "``` " + filetype + "\n" + content + "\n```";
  }
  docs.push({ content, filetype });
}
function isDocumentation(obj) {
  if (!obj) return false;
  return typeof obj.filetype === "string" && typeof obj.content === "string";
}
async function readLines(uri, start, end) {
  let doc = workspace_default.getDocument(uri);
  if (doc) return doc.getLines(start, end + 1);
  let fsPath2 = URI2.parse(uri).fsPath;
  if (!fs.existsSync(fsPath2)) return [];
  return await readFileLines(fsPath2, start, end);
}
var highlightDelay, HoverHandler;
var init_hover2 = __esm({
  "src/handler/hover.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_languages();
    init_util();
    init_array();
    init_fs();
    init_is();
    init_node();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    highlightDelay = getConditionValue(500, 10);
    HoverHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.documentLines = [];
        this.hasProvider = false;
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        this.hoverFactory = window_default.createFloatFactory({
          modes: ["n"],
          autoHide: this.config.autoHide
        });
        this.disposables.push(this.hoverFactory);
        window_default.onDidChangeActiveTextEditor(() => {
          this.loadConfiguration();
        }, null, this.disposables);
      }
      registerProvider() {
        if (this.hasProvider) return;
        this.hasProvider = true;
        let { nvim } = this;
        let provider = {
          onDidChange: null,
          provideTextDocumentContent: async () => {
            nvim.pauseNotification();
            nvim.command("setlocal conceallevel=2 nospell nofoldenable wrap", true);
            nvim.command("setlocal bufhidden=wipe nobuflisted", true);
            nvim.command("setfiletype markdown", true);
            nvim.command(`if winnr('j') != winnr('k') | exe "normal! z${Math.min(this.documentLines.length, this.config.previewMaxHeight)}\\<cr>" | endif`, true);
            await nvim.resumeNotification();
            return this.documentLines.join("\n");
          }
        };
        this.disposables.push(workspace_default.registerTextDocumentContentProvider("coc", provider));
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("hover")) {
          let config = workspace_default.getConfiguration("hover", this.handler.uri);
          this.config = {
            floatConfig: config.get("floatConfig", {}),
            autoHide: config.get("autoHide", true),
            target: config.get("target", "float"),
            previewMaxHeight: config.get("previewMaxHeight", 12)
          };
          if (this.config.target == "preview") {
            this.registerProvider();
          }
        }
      }
      async onHover(hoverTarget) {
        let { doc, position, winid } = await this.handler.getCurrentState();
        if (hoverTarget == "preview") this.registerProvider();
        this.handler.checkProvider("hover" /* Hover */, doc.textDocument);
        await doc.synchronize();
        let hovers = await this.handler.withRequestToken("hover", (token) => {
          return languages_default.getHover(doc.textDocument, position, token);
        }, true);
        if (hovers == null || !hovers.length) return false;
        let hover = hovers.find((o) => Range.is(o.range));
        if (hover?.range) {
          let win = this.nvim.createWindow(winid);
          win.highlightRanges("CocHoverRange", [hover.range], 99, true);
          this.timer = setTimeout(() => {
            win.clearMatchGroup("CocHoverRange");
            this.nvim.redrawVim();
          }, 500);
        }
        await this.previewHover(hovers, hoverTarget);
        return true;
      }
      async definitionHover(hoverTarget) {
        const { doc, position, winid } = await this.handler.getCurrentState();
        if (hoverTarget == "preview") this.registerProvider();
        this.handler.checkProvider("hover" /* Hover */, doc.textDocument);
        await doc.synchronize();
        const hovers = await this.handler.withRequestToken("hover", (token) => {
          return languages_default.getHover(doc.textDocument, position, token);
        }, true);
        if (isFalsyOrEmpty(hovers)) return false;
        const defs = await this.handler.withRequestToken("definitionHover", (token) => {
          return languages_default.getDefinitionLinks(doc.textDocument, position, token);
        }, false);
        if (defs == null) return false;
        await addDefinitions(hovers, defs, doc.filetype);
        let hover = hovers.find((o) => Hover.is(o) && Range.is(o.range));
        if (hover?.range) {
          let win = this.nvim.createWindow(winid);
          win.highlightRanges("CocHoverRange", [hover.range], 99, true);
          this.timer = setTimeout(() => {
            win.clearMatchGroup("CocHoverRange");
            this.nvim.redrawVim();
          }, highlightDelay);
        }
        await this.previewHover(hovers, hoverTarget);
        return true;
      }
      async previewHover(hovers, target) {
        let docs = [];
        target = target ?? this.config.target;
        let isPreview = target === "preview";
        for (let hover of hovers) {
          if (isDocumentation(hover)) {
            docs.push(hover);
            continue;
          }
          let { contents } = hover;
          if (Array.isArray(contents)) {
            for (let item of contents) {
              if (typeof item === "string") {
                addDocument(docs, item, "markdown", isPreview);
              } else {
                addDocument(docs, item.value, item.language, isPreview);
              }
            }
          } else if (MarkedString.is(contents)) {
            if (typeof contents == "string") {
              addDocument(docs, contents, "markdown", isPreview);
            } else {
              addDocument(docs, contents.value, contents.language, isPreview);
            }
          } else if (MarkupContent.is(contents)) {
            addDocument(docs, contents.value, isMarkdown(contents) ? "markdown" : "txt", isPreview);
          }
        }
        if (target == "float") {
          await this.hoverFactory.show(docs, this.config.floatConfig);
          return;
        }
        let lines = docs.reduce((p, c) => {
          let arr = c.content.split(/\r?\n/);
          if (p.length > 0) p.push("");
          p.push(...arr);
          return p;
        }, []);
        if (target == "echo") {
          const msg = lines.join("\n").trim();
          await this.nvim.call("coc#ui#echo_hover", [msg]);
        } else {
          this.documentLines = lines;
          await this.nvim.command(`noswapfile pedit coc://document`);
        }
      }
      /**
       * Get hover text array
       */
      async getHover(loc) {
        let result = [];
        let doc;
        let position;
        if (!loc) {
          let state = await this.handler.getCurrentState();
          doc = state.doc;
          position = state.position;
        } else {
          doc = loc.bufnr ? workspace_default.getAttachedDocument(loc.bufnr) : await workspace_default.document;
          let line = doc.getline(loc.line - 1);
          let character = characterIndex(line, loc.col - 1);
          position = Position.create(loc.line - 1, character);
        }
        this.handler.checkProvider("hover" /* Hover */, doc.textDocument);
        await doc.synchronize();
        let tokenSource = new import_node4.CancellationTokenSource();
        let hovers = await languages_default.getHover(doc.textDocument, position, tokenSource.token);
        for (let h of hovers) {
          let { contents } = h;
          if (Array.isArray(contents)) {
            contents.forEach((c) => {
              result.push(typeof c === "string" ? c : c.value);
            });
          } else if (MarkupContent.is(contents)) {
            result.push(contents.value);
          } else {
            result.push(typeof contents === "string" ? contents : contents.value);
          }
        }
        result = result.filter((s) => s != null && s.length > 0);
        return result;
      }
      dispose() {
        if (this.timer) clearTimeout(this.timer);
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/inlayHint/buffer.ts
function getHighlightGroup3(kind) {
  switch (kind) {
    case InlayHintKind.Parameter:
      return "CocInlayHintParameter";
    case InlayHintKind.Type:
      return "CocInlayHintType";
    default:
      return "CocInlayHint";
  }
}
var logger52, srcId2, debounceInterval, requestDelay, InlayHintBuffer;
var init_buffer4 = __esm({
  "src/handler/inlayHint/buffer.ts"() {
    "use strict";
    init_main();
    init_events();
    init_languages();
    init_logger();
    init_regions();
    init_inlayHintManager();
    init_util();
    init_errors();
    init_position();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    logger52 = createLogger("inlayHint-buffer");
    debounceInterval = getConditionValue(150, 10);
    requestDelay = getConditionValue(500, 10);
    InlayHintBuffer = class {
      constructor(nvim, doc) {
        this.nvim = nvim;
        this.doc = doc;
        this.regions = new Regions();
        this._dirty = false;
        // Saved for resolve and TextEdits in the future.
        this.currentHints = [];
        this._onDidRefresh = new import_node4.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this.render().catch(onUnexpectedError);
      }
      get config() {
        if (this._config) return this._config;
        this.loadConfiguration();
        return this._config;
      }
      loadConfiguration() {
        let config = workspace_default.getConfiguration("inlayHint", this.doc);
        let changeEnable = this._config && this._config.enable !== config.enable;
        let changeDisplay = this._config && this._config.display !== config.display;
        this._config = {
          enable: config.get("enable"),
          position: config.get("position"),
          display: config.get("display", true),
          filetypes: config.get("filetypes"),
          refreshOnInsertMode: config.get("refreshOnInsertMode"),
          enableParameter: config.get("enableParameter"),
          maximumLength: config.get("maximumLength", 0)
        };
        if (changeEnable || changeDisplay) {
          let { enable, display } = this._config;
          if (enable && display) {
            this.render(void 0, 0).catch(onUnexpectedError);
          } else {
            this.clearCache();
            this.clearVirtualText();
          }
        }
      }
      onInsertLeave() {
        if (this.config.refreshOnInsertMode || this.doc.changedtick === this._changedtick) return;
        this.render().catch(onUnexpectedError);
      }
      onInsertEnter() {
        this._changedtick = this.doc.changedtick;
        if (this.config.refreshOnInsertMode) return;
        this.cancel();
      }
      get current() {
        return this.currentHints;
      }
      get enabled() {
        if (!this.config.display || !this.configEnabled) return false;
        return this.hasProvider;
      }
      get hasProvider() {
        return languages_default.hasProvider("inlayHint" /* InlayHint */, this.doc);
      }
      get configEnabled() {
        let { filetypes, enable } = this.config;
        if (Array.isArray(filetypes)) return filetypes.includes("*") || filetypes.includes(this.doc.filetype);
        return enable === true;
      }
      enable() {
        this.checkState();
        this.config.display = true;
        this.render(void 0, 0).catch(onUnexpectedError);
      }
      disable() {
        this.checkState();
        this.config.display = false;
        this.clearCache();
        this.clearVirtualText();
      }
      checkState() {
        if (!languages_default.hasProvider("inlayHint" /* InlayHint */, this.doc.textDocument)) throw new Error("Inlay hint provider not found for current document");
        if (!this.configEnabled) throw new Error(`Filetype "${this.doc.filetype}" not enabled by inlayHint configuration, see ':h coc-config-inlayHint'`);
      }
      toggle() {
        if (this.config.display) {
          this.disable();
        } else {
          this.enable();
        }
      }
      clearCache() {
        this.cancel();
        this.currentHints = [];
        this.regions.clear();
      }
      onTextChange() {
        this.clearCache();
      }
      onChange() {
        this.render().catch(onUnexpectedError);
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      onVisible(winid, region) {
        if (!this._dirty) return;
        this.render({
          winid,
          region: [region[0], region[1]]
        }, 0).catch(onUnexpectedError);
      }
      async render(config, delay3) {
        if (!this.enabled) return;
        if (!this.config.refreshOnInsertMode && events_default.bufnr === this.doc.bufnr && events_default.insertMode) return;
        this.cancel();
        this.tokenSource = new import_node4.CancellationTokenSource();
        let token = this.tokenSource.token;
        await waitWithToken(typeof delay3 === "number" ? delay3 : debounceInterval, token);
        if (!srcId2) srcId2 = await this.nvim.createNamespace("coc-inlayHint");
        if (token.isCancellationRequested || this.doc.dirty) return;
        if (!this._dirty) {
          await this.renderAll(token);
        } else if (config) {
          let region = config.region;
          await this.renderRange([region[0] - 1, region[1] - 1], token);
        } else {
          const spans = await window_default.getVisibleRanges(this.doc.bufnr);
          for (const [topline, botline] of spans) {
            if (token.isCancellationRequested) break;
            await this.renderRange([topline - 1, botline - 1], token);
          }
        }
      }
      async renderAll(token) {
        const lineCount = this.doc.lineCount;
        const range = Range.create(0, 0, lineCount, 0);
        const inlayHints = await this.request(range, token);
        if (!inlayHints) return;
        this.currentHints = inlayHints;
        this.setVirtualText(range, inlayHints);
        this.regions.add(0, lineCount);
        this._dirty = true;
      }
      /**
       * 0 based startLine and endLine
       */
      async renderRange(lines, token) {
        let span = this.regions.toUncoveredSpan(lines, workspace_default.env.lines, this.doc.lineCount);
        if (!span) return;
        const [startLine, endLine] = span;
        const range = this.doc.textDocument.intersectWith(Range.create(startLine, 0, endLine + 1, 0));
        const inlayHints = await this.request(range, token);
        if (!inlayHints) return;
        this.currentHints = this.currentHints.filter((o) => positionInRange(o.position, range) !== 0);
        this.currentHints.push(...inlayHints);
        this.setVirtualText(range, inlayHints);
        this.regions.add(startLine, endLine);
      }
      async request(range, token) {
        let inlayHints;
        try {
          inlayHints = await languages_default.provideInlayHints(this.doc.textDocument, range, token);
        } catch (e) {
          if (!token.isCancellationRequested && e instanceof CancellationError) {
            this.render(void 0, requestDelay).catch(onUnexpectedError);
            return;
          }
        }
        if (inlayHints == null || token.isCancellationRequested) return;
        if (!this.config.enableParameter) {
          inlayHints = inlayHints.filter((o) => o.kind !== InlayHintKind.Parameter);
        }
        return inlayHints;
      }
      setVirtualText(range, inlayHints) {
        let { nvim, doc } = this;
        let buffer = doc.buffer;
        const { maximumLength } = this.config;
        nvim.pauseNotification();
        const end = range.end.line >= doc.lineCount ? -1 : range.end.line + 1;
        buffer.clearNamespace(srcId2, range.start.line, end);
        let lineInfo = { lineNum: 0, totalLineLen: 0 };
        const vitems = [];
        for (const item of inlayHints) {
          const blocks = [];
          let { position } = item;
          if (lineInfo.lineNum !== position.line) {
            lineInfo = { lineNum: position.line, totalLineLen: 0 };
          }
          if (maximumLength > 0 && lineInfo.totalLineLen > maximumLength) {
            logger52.warn(`Inlay hint of ${lineInfo.lineNum} too long, max length: ${maximumLength}, current line total length: ${lineInfo.totalLineLen}`);
            continue;
          }
          let line = this.doc.getline(position.line);
          let col = byteIndex(line, position.character) + 1;
          let label = getLabel(item);
          lineInfo.totalLineLen += label.length;
          const over = maximumLength > 0 ? lineInfo.totalLineLen - maximumLength : 0;
          if (over > 0) {
            label = label.slice(0, -over) + "\u2026";
          }
          if (item.paddingLeft) blocks.push([" ", "Normal"]);
          blocks.push([label, getHighlightGroup3(item.kind)]);
          if (item.paddingRight) blocks.push([" ", "Normal"]);
          if (this.config.position == "eol" /* Eol */) {
            col = 0;
          }
          let opts = { line: position.line, blocks, col, hl_mode: "replace" };
          if (item.kind == InlayHintKind.Parameter) {
            opts.right_gravity = false;
          }
          vitems.push(opts);
        }
        nvim.call("coc#vtext#set", [buffer.id, srcId2, vitems, false, 200], true);
        nvim.resumeNotification(true, true);
        this._onDidRefresh.fire();
      }
      clearVirtualText() {
        if (srcId2) this.doc.buffer.clearNamespace(srcId2);
      }
      dispose() {
        this.clearCache();
      }
    };
  }
});

// src/handler/inlayHint/index.ts
var InlayHintHandler;
var init_inlayHint2 = __esm({
  "src/handler/inlayHint/index.ts"() {
    "use strict";
    init_commands();
    init_events();
    init_languages();
    init_util();
    init_protocol();
    init_window();
    init_workspace();
    init_buffer4();
    InlayHintHandler = class {
      constructor(nvim, handler) {
        this.disposables = [];
        this.buffers = workspace_default.registerBufferSync((doc) => {
          return new InlayHintBuffer(nvim, doc);
        });
        this.disposables.push(this.buffers);
        workspace_default.onDidChangeConfiguration((e) => {
          for (let item of this.buffers.items) {
            if (e.affectsConfiguration("inlayHint", item.doc)) {
              item.loadConfiguration();
            }
          }
        }, null, this.disposables);
        languages_default.onDidInlayHintRefresh(async (e) => {
          for (let item of this.buffers.items) {
            if (workspace_default.match(e, item.doc.textDocument)) {
              item.clearCache();
              if (languages_default.hasProvider("inlayHint" /* InlayHint */, item.doc.textDocument)) {
                await item.render();
              } else {
                item.clearVirtualText();
              }
            }
          }
        }, null, this.disposables);
        events_default.on("InsertLeave", (bufnr) => {
          let item = this.buffers.getItem(bufnr);
          if (item) item.onInsertLeave();
        }, null, this.disposables);
        events_default.on("InsertEnter", (bufnr) => {
          let item = this.buffers.getItem(bufnr);
          if (item) item.onInsertEnter();
        }, null, this.disposables);
        commands_default.register({
          id: "document.toggleInlayHint",
          execute: (bufnr) => {
            this.setState("toggle", bufnr);
          }
        }, false, "Toggle inlayHint display of current buffer");
        commands_default.register({
          id: "document.enableInlayHint",
          execute: (bufnr) => {
            this.setState("enable", bufnr);
          }
        }, false, "Enable inlayHint display of current buffer");
        commands_default.register({
          id: "document.disableInlayHint",
          execute: (bufnr) => {
            this.setState("disable", bufnr);
          }
        }, false, "Disable inlayHint display of current buffer");
        handler.addDisposable(import_node4.Disposable.create(() => {
          disposeAll(this.disposables);
        }));
      }
      setState(method, bufnr) {
        try {
          bufnr = bufnr ?? workspace_default.bufnr;
          workspace_default.getAttachedDocument(bufnr);
          let item = this.getItem(bufnr);
          item[method]();
        } catch (e) {
          void window_default.showErrorMessage(e.message);
        }
      }
      getItem(bufnr) {
        return this.buffers.getItem(bufnr);
      }
    };
  }
});

// src/handler/linkedEditing.ts
var debounceTime11, LinkedEditingHandler;
var init_linkedEditing = __esm({
  "src/handler/linkedEditing.ts"() {
    "use strict";
    init_main();
    init_textRange();
    init_util6();
    init_events();
    init_languages();
    init_util();
    init_node();
    init_position();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    debounceTime11 = getConditionValue(200, 10);
    LinkedEditingHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.changing = false;
        this.checkPosition = debounce(this._checkPosition, debounceTime11);
        handler.addDisposable(events_default.on("CursorMoved", (bufnr, cursor) => {
          this.cancel();
          this.checkPosition(bufnr, [cursor[0], cursor[1]]);
        }));
        handler.addDisposable(events_default.on("CursorMovedI", (bufnr, cursor) => {
          this.cancel();
          this.checkPosition(bufnr, [cursor[0], cursor[1]]);
        }));
        handler.addDisposable(window_default.onDidChangeActiveTextEditor(() => {
          this.cancel();
          this.cancelEdit();
        }));
        handler.addDisposable(events_default.on("InsertCharPre", (character, bufnr) => {
          if (bufnr !== this.bufnr) return;
          let doc = workspace_default.getDocument(bufnr);
          if (!this.wordPattern) {
            if (!doc.isWord(character) && character !== "-") this.cancelEdit();
          } else {
            let r = new RegExp(this.wordPattern);
            if (!r.test(character)) this.cancelEdit();
          }
        }));
        handler.addDisposable(workspace_default.onDidChangeTextDocument(async (e) => {
          await this.onChange(e);
        }));
      }
      cancelEdit() {
        this.window?.clearMatchGroup("^CocLinkedEditing");
        this.ranges = void 0;
        this.window = void 0;
        this.bufnr = void 0;
      }
      async onChange(e) {
        if (e.bufnr !== this.bufnr || this.changing || !this.ranges) return;
        if (e.contentChanges.length === 0) {
          this.doHighlights();
          return;
        }
        let change = e.contentChanges[0];
        let { text, range } = change;
        let affected = this.ranges.filter((r) => {
          if (!rangeIntersect(range, r.range)) return false;
          if (rangeAdjacent(range, r.range)) {
            if (text.includes("\n") || !emptyRange(range)) return false;
          }
          return true;
        });
        if (affected.length == 1 && rangeInRange(range, affected[0].range)) {
          if (text.includes("\n")) {
            this.cancelEdit();
            return;
          }
          await this.applySingleEdit(affected[0], { range, newText: text });
        } else {
          this.cancelEdit();
        }
      }
      async applySingleEdit(textRange, edit2) {
        let { bufnr, ranges } = this;
        let doc = workspace_default.getDocument(bufnr);
        let after = ranges.filter((r) => r !== textRange && r.position.line == textRange.position.line);
        after.forEach((r) => r.adjustFromEdit(edit2));
        let change = getChange(textRange, edit2.range, edit2.newText);
        let delta = getDelta(change);
        ranges.forEach((r) => r.applyChange(change));
        let edits = ranges.filter((r) => r !== textRange).map((o) => o.textEdit);
        this.changing = true;
        await doc.applyEdits(edits, true, true);
        this.changing = false;
        if (delta != 0) {
          for (let r of ranges) {
            let n = getBeforeCount(r, this.ranges, textRange);
            r.move(n * delta);
          }
        }
        this.doHighlights();
      }
      doHighlights() {
        let { window: window2, ranges, nvim } = this;
        if (window2 && ranges) {
          nvim.pauseNotification();
          window2.clearMatchGroup("^CocLinkedEditing");
          window2.highlightRanges("CocLinkedEditing", ranges.map((o) => o.range), 99, true);
          nvim.resumeNotification(true, true);
        }
      }
      _checkPosition(bufnr, cursor) {
        if (events_default.completing || !workspace_default.isAttached(bufnr)) return;
        let doc = workspace_default.getDocument(bufnr);
        let config = workspace_default.getConfiguration("coc.preferences", doc);
        let enabled = config.get("enableLinkedEditing", false);
        if (!enabled || !languages_default.hasProvider("linkedEditing" /* LinkedEditing */, doc.textDocument)) return;
        let character = characterIndex(doc.getline(cursor[0] - 1), cursor[1] - 1);
        let position = Position.create(cursor[0] - 1, character);
        if (this.ranges) {
          if (this.ranges.some((r) => positionInRange(position, r.range) == 0)) {
            return;
          }
          this.cancelEdit();
        }
        void this.enable(doc, position);
      }
      async enable(doc, position) {
        let textDocument = doc.textDocument;
        let tokenSource = this.tokenSource = new import_node4.CancellationTokenSource();
        let token = tokenSource.token;
        let win = await this.nvim.window;
        let linkedRanges = await languages_default.provideLinkedEdits(textDocument, position, token);
        if (token.isCancellationRequested || !linkedRanges || linkedRanges.ranges.length == 0) return;
        let ranges = linkedRanges.ranges.map((o) => new TextRange(o.start.line, o.start.character, textDocument.getText(o)));
        this.wordPattern = linkedRanges.wordPattern;
        this.bufnr = doc.bufnr;
        this.window = win;
        this.ranges = ranges;
        this.doHighlights();
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
    };
  }
});

// src/handler/links.ts
function sameLinks(links2, other) {
  if (links2.length != other.length) return false;
  for (let i = 0; i < links2.length; i++) {
    if (!equals(links2[i].range, other[i].range)) {
      return false;
    }
  }
  return true;
}
var import_debounce, floatFactory2, debounceTime12, NAMESPACE3, highlightGroup, Links, LinkBuffer;
var init_links2 = __esm({
  "src/handler/links.ts"() {
    "use strict";
    import_debounce = __toESM(require_debounce());
    init_main();
    init_events();
    init_languages();
    init_util();
    init_array();
    init_object();
    init_position();
    init_protocol();
    init_window();
    init_workspace();
    debounceTime12 = getConditionValue(200, 10);
    NAMESPACE3 = "links";
    highlightGroup = "CocLink";
    Links = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.setConfiguration();
        workspace_default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);
        events_default.on("CursorHold", async () => {
          await this.showTooltip();
        }, null, this.disposables);
        events_default.on(["CursorMoved", "InsertEnter"], () => {
          this.cancel();
        }, null, this.disposables);
        this.buffers = workspace_default.registerBufferSync((doc) => {
          return new LinkBuffer(doc);
        });
        this.disposables.push(this.buffers);
        languages_default.onDidLinksRefresh((selector) => {
          for (let item of this.buffers.items) {
            if (workspace_default.match(selector, item.doc)) {
              item.fetchLinks();
            }
          }
        }, null, this.disposables);
      }
      setConfiguration(e) {
        if (!e || e.affectsConfiguration("links")) {
          this.tooltip = workspace_default.initialConfiguration.get("links.tooltip", false);
          if (e) {
            for (let item of this.buffers.items) {
              item.updateDocumentConfig();
            }
          }
        }
      }
      async showTooltip() {
        if (!this.tooltip) return;
        let link = await this.getCurrentLink();
        if (!link || !link.target) return;
        let text = link.target;
        if (link.tooltip) text += " " + link.tooltip;
        let doc = { content: text, filetype: "txt" };
        if (!floatFactory2) floatFactory2 = window_default.createFloatFactory({});
        await floatFactory2.show([doc]);
      }
      async getLinks() {
        let { doc } = await this.handler.getCurrentState();
        let buf = this.buffers.getItem(doc.bufnr);
        await buf.getLinks();
        return toArray(buf.links);
      }
      async getCurrentLink() {
        let links2 = await this.getLinks();
        let pos = await window_default.getCursorPosition();
        if (links2 && links2.length) {
          for (let link2 of links2) {
            if (positionInRange(pos, link2.range) == 0) {
              if (!link2.target) {
                let tokenSource = this.tokenSource = this.tokenSource || new import_node4.CancellationTokenSource();
                link2 = await languages_default.resolveDocumentLink(link2, this.tokenSource.token);
                this.tokenSource = void 0;
                if (!link2.target || tokenSource.token.isCancellationRequested) continue;
              }
              return link2;
            }
          }
        }
        let line = await this.nvim.call("getline", ["."]);
        let regex2 = /\w+?:\/\/[-a-zA-Z0-9@:%._\\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b[-a-zA-Z0-9()@:%_\\+.~#?&//=]*/gi;
        let arr;
        let link;
        while ((arr = regex2.exec(line)) !== null) {
          let start = arr.index;
          if (start <= pos.character && start + arr[0].length >= pos.character) {
            link = DocumentLink.create(Range.create(pos.line, start, pos.line, start + arr[0].length), arr[0]);
            break;
          }
        }
        return link;
      }
      async openCurrentLink() {
        let link = await this.getCurrentLink();
        if (link) {
          await this.openLink(link);
          return true;
        }
        return false;
      }
      async openLink(link) {
        if (!link.target) throw new Error(`Failed to resolve link target`);
        await workspace_default.openResource(link.target);
      }
      getBuffer(bufnr) {
        return this.buffers.getItem(bufnr);
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
    LinkBuffer = class {
      // last highlight version
      constructor(doc) {
        this.doc = doc;
        this.currentVersion = -1;
        this.links = [];
        this.fetchLinks = (0, import_debounce.default)(() => {
          void this.getLinks();
        }, debounceTime12);
        if (this.hasProvider) this.fetchLinks();
      }
      get config() {
        if (this._config) return this._config;
        this.updateDocumentConfig();
        return this._config;
      }
      get hasProvider() {
        return languages_default.hasProvider("documentLink" /* DocumentLink */, this.doc);
      }
      updateDocumentConfig() {
        let configuration2 = workspace_default.getConfiguration("links", this.doc);
        this._config = {
          enable: configuration2.get("enable", true),
          highlight: configuration2.get("highlight", false)
        };
      }
      onChange(e) {
        if (e.contentChanges.length == 0) {
          this.highlight();
        } else {
          this.cancel();
          this.fetchLinks();
        }
      }
      highlight() {
        if (!this.config.highlight || !this.links) return;
        let { links: links2, doc } = this;
        if (isFalsyOrEmpty(links2)) {
          this.clearHighlight();
        } else {
          let highlights = [];
          links2.forEach((link) => {
            doc.addHighlights(highlights, highlightGroup, link.range);
          });
          this.doc.buffer.updateHighlights(NAMESPACE3, highlights, { priority: 2048 });
        }
      }
      clearHighlight() {
        this.buffer.clearNamespace(NAMESPACE3);
      }
      get buffer() {
        return this.doc.buffer;
      }
      cancel() {
        this.fetchLinks.clear();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      async getLinks() {
        if (!this.hasProvider || !this.config.enable || this.currentVersion === this.doc.version) return;
        this.currentVersion = this.doc.version;
        this.cancel();
        let tokenSource = this.tokenSource = new import_node4.CancellationTokenSource();
        let token = tokenSource.token;
        let links2 = await languages_default.getDocumentLinks(this.doc.textDocument, token);
        this.tokenSource = void 0;
        if (token.isCancellationRequested || sameLinks(toArray(this.links), toArray(links2))) return;
        this.links = toArray(links2);
        this.highlight();
      }
      dispose() {
        this.cancel();
      }
    };
  }
});

// src/handler/locations.ts
var LocationsHandler;
var init_locations = __esm({
  "src/handler/locations.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_languages();
    init_services();
    init_object();
    init_protocol();
    init_workspace();
    init_array();
    LocationsHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
      }
      async request(method, fn) {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider(method, doc.textDocument);
        await doc.synchronize();
        return await this.handler.withRequestToken(method, (token) => {
          return fn(doc.textDocument, position, token);
        }, true);
      }
      async definitions() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("definition" /* Definition */, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_node4.CancellationTokenSource();
        return languages_default.getDefinition(doc.textDocument, position, tokenSource.token);
      }
      async declarations() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("declaration" /* Declaration */, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_node4.CancellationTokenSource();
        return languages_default.getDeclaration(doc.textDocument, position, tokenSource.token);
      }
      async typeDefinitions() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("typeDefinition" /* TypeDefinition */, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_node4.CancellationTokenSource();
        return languages_default.getTypeDefinition(doc.textDocument, position, tokenSource.token);
      }
      async implementations() {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("implementation" /* Implementation */, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_node4.CancellationTokenSource();
        return languages_default.getImplementation(doc.textDocument, position, tokenSource.token);
      }
      async references(excludeDeclaration) {
        const { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("reference" /* Reference */, doc.textDocument);
        await doc.synchronize();
        const tokenSource = new import_node4.CancellationTokenSource();
        return languages_default.getReferences(doc.textDocument, { includeDeclaration: !excludeDeclaration }, position, tokenSource.token);
      }
      async gotoDefinition(openCommand) {
        let definition = await this.request("definition" /* Definition */, (doc, position, token) => {
          return languages_default.getDefinition(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return !isFalsyOrEmpty(definition);
      }
      async gotoDeclaration(openCommand) {
        let definition = await this.request("declaration" /* Declaration */, (doc, position, token) => {
          return languages_default.getDeclaration(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return !isFalsyOrEmpty(definition);
      }
      async gotoTypeDefinition(openCommand) {
        let definition = await this.request("typeDefinition" /* TypeDefinition */, (doc, position, token) => {
          return languages_default.getTypeDefinition(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return !isFalsyOrEmpty(definition);
      }
      async gotoImplementation(openCommand) {
        let definition = await this.request("implementation" /* Implementation */, (doc, position, token) => {
          return languages_default.getImplementation(doc, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return !isFalsyOrEmpty(definition);
      }
      async gotoReferences(openCommand, includeDeclaration = true) {
        let definition = await this.request("reference" /* Reference */, (doc, position, token) => {
          return languages_default.getReferences(doc, { includeDeclaration }, position, token);
        });
        await this.handleLocations(definition, openCommand);
        return !isFalsyOrEmpty(definition);
      }
      async getTagList() {
        let { doc, position } = await this.handler.getCurrentState();
        let word = await this.nvim.call("expand", "<cword>");
        if (!word) return null;
        if (!languages_default.hasProvider("definition" /* Definition */, doc.textDocument)) return null;
        let tokenSource = new import_node4.CancellationTokenSource();
        let definitions = [];
        try {
          let timeout2 = workspace_default.initialConfiguration.get("coc.preferences.tagDefinitionTimeout", 0);
          if (timeout2 > 0) {
            const abort = new Promise((_, rej) => setTimeout(() => rej(new Error("timeout")), timeout2));
            definitions = await Promise.race([languages_default.getDefinition(doc.textDocument, position, tokenSource.token), abort]);
          } else {
            definitions = await languages_default.getDefinition(doc.textDocument, position, tokenSource.token);
          }
        } catch (e) {
          return null;
        }
        if (!definitions || !definitions.length) return null;
        return definitions.map((location) => {
          let parsedURI = URI2.parse(location.uri);
          const filename = parsedURI.scheme == "file" ? parsedURI.fsPath : parsedURI.toString();
          return {
            name: word,
            cmd: `silent keepjumps call coc#cursor#move_to(${location.range.start.line}, ${location.range.start.character})`,
            filename
          };
        });
      }
      /**
       * Send custom request for locations to services.
       */
      async findLocations(id2, method, params, openCommand = false) {
        let { doc, position } = await this.handler.getCurrentState();
        params = params || {};
        Object.assign(params, {
          textDocument: { uri: doc.uri },
          position
        });
        let res = await services_default.sendRequest(id2, method, params);
        let locations = this.toLocations(res);
        await this.handleLocations(locations, openCommand);
        return locations.length > 0;
      }
      toLocations(location) {
        let res = [];
        if (location && hasOwnProperty2(location, "location") && hasOwnProperty2(location, "children")) {
          let getLocation2 = (item) => {
            if (!item) return;
            if (Location.is(item.location)) {
              res.push(item.location);
            } else if (LocationLink.is(item.location)) {
              let loc = item.location;
              res.push({
                uri: loc.targetUri,
                range: loc.targetSelectionRange,
                targetRange: loc.targetRange
              });
            }
            if (item.children && item.children.length) {
              for (let loc of item.children) {
                getLocation2(loc);
              }
            }
          };
          getLocation2(location);
          return res;
        }
        if (Location.is(location)) {
          res.push(location);
        } else if (LocationLink.is(location)) {
          res.push({
            uri: location.targetUri,
            range: location.targetSelectionRange,
            targetRange: location.targetRange
          });
        } else if (Array.isArray(location)) {
          for (let loc of location) {
            if (Location.is(loc)) {
              res.push(loc);
            } else if (loc && typeof loc.targetUri === "string") {
              res.push({
                uri: loc.targetUri,
                range: loc.targetSelectionRange,
                targetRange: loc.targetRange
              });
            }
          }
        }
        return res;
      }
      async handleLocations(locations, openCommand) {
        if (!locations) return;
        let len = locations.length;
        if (len == 0) return;
        if (len == 1 && openCommand !== false) {
          let { uri, range } = locations[0];
          await workspace_default.jumpTo(uri, range.start, openCommand);
        } else {
          await workspace_default.showLocations(locations);
        }
      }
    };
  }
});

// src/handler/refactor/changes.ts
var Changes;
var init_changes = __esm({
  "src/handler/refactor/changes.ts"() {
    "use strict";
    init_object();
    Changes = class {
      constructor() {
        this.stack = [];
      }
      add(infos) {
        let map = /* @__PURE__ */ new Map();
        for (let info of infos) {
          map.set(info.lnum, info);
        }
        this.stack.push(map);
      }
      checkInsert(lnums) {
        if (!this.stack.length) return void 0;
        let last = this.stack[this.stack.length - 1];
        let arr = Array.from(last.keys()).sort((a, b) => a - b);
        if (!equals(arr, lnums)) return void 0;
        this.stack.pop();
        return Array.from(last.values());
      }
    };
  }
});

// src/handler/refactor/buffer.ts
function adjustRange(range, offset) {
  let { start, end } = range;
  return Range.create(start.line - offset, start.character, end.line - offset, end.character);
}
function fixChangeParams(e) {
  let { contentChanges, bufnr, textDocument, original, originalLines, document: document2 } = e;
  let { range, text } = contentChanges[0];
  let changes = [{ range, text }];
  if (!original) {
    if (emptyRange(range) && range.start.character != 0) {
      let lines = text.split(/\r?\n/);
      let last = lines[lines.length - 1];
      let before = originalLines[range.start.line].slice(0, range.start.character);
      if (last.startsWith(SEPARATOR) && before == last) {
        changes[0].text = before + lines.slice(0, -1).join("\n") + "\n";
        let { start, end } = range;
        changes[0].range = Range.create(start.line, 0, end.line, 0);
      }
    }
  } else {
    let lines = original.split(/\r?\n/);
    let last = lines[lines.length - 1];
    if (last.startsWith(SEPARATOR)) {
      let before = originalLines[range.start.line].slice(0, range.start.character);
      if (before == last) {
        original = before + lines.slice(0, -1).join("\n") + "\n";
        let { start, end } = range;
        changes[0].range = Range.create(start.line, 0, end.line, 0);
      }
    }
    let prev = originalLines[range.start.line - 1];
    let nest = lines.length > 1 ? lines[lines.length - 2] : "";
    if (last == "" && nest.startsWith(SEPARATOR) && prev == nest && range.start.character == 0 && range.end.character == 0) {
      original = prev + "\n" + lines.slice(0, -2).join("\n") + "\n";
      let { start, end } = range;
      changes[0].range = Range.create(start.line - 1, 0, end.line - 1, 0);
    }
  }
  return { contentChanges: changes, bufnr, textDocument, document: document2, original, originalLines };
}
var logger53, SEPARATOR, RefactorBuffer;
var init_buffer5 = __esm({
  "src/handler/refactor/buffer.ts"() {
    "use strict";
    init_main3();
    init_main();
    init_esm();
    init_logger();
    init_highlighter();
    init_util();
    init_fs();
    init_lodash();
    init_mutex();
    init_node();
    init_object();
    init_position();
    init_string();
    init_textedit();
    init_window();
    init_workspace();
    init_changes();
    logger53 = createLogger("handler-refactorBuffer");
    SEPARATOR = "\u3000";
    RefactorBuffer = class {
      constructor(bufnr, srcId4, nvim, config, opts) {
        this.bufnr = bufnr;
        this.srcId = srcId4;
        this.nvim = nvim;
        this.config = config;
        this.opts = opts;
        this._disposed = false;
        this._fileItems = [];
        this.mutex = new Mutex();
        this.disposables = [];
        this.matchIds = /* @__PURE__ */ new Set();
        this.changing = false;
        this.changes = new Changes();
        this.disposables.push(workspace_default.registerLocalKeymap(bufnr, "n", "<CR>", this.splitOpen.bind(this), true));
        if (config.showMenu) {
          this.disposables.push(workspace_default.registerLocalKeymap(bufnr, "n", config.showMenu, this.showMenu.bind(this), true));
        }
        workspace_default.onDidChangeTextDocument(this.onDocumentChange, this, this.disposables);
      }
      async showMenu() {
        let res = await window_default.showMenuPicker(["Tab open", "Remove block"]);
        if (res == -1) return;
        let fileRange = await this.searchCurrentRange();
        if (!fileRange) return;
        if (res == 0) {
          let before = await this.nvim.eval(`strpart(getline('.'), 0 ,col('.') - 1)`);
          let character = before.length;
          let bufname = this.getAbsolutePath(fileRange.filepath);
          this.nvim.call("coc#util#jump", ["tabe", bufname, [fileRange.line, character]], true);
        }
        if (res == 1) {
          let range = this.getDeleteRange(fileRange);
          await this.document.applyEdits([TextEdit.del(range)]);
        }
      }
      get fileItems() {
        return this._fileItems;
      }
      getFileItem(uri) {
        let filepath = URI2.parse(uri).fsPath;
        return this._fileItems.find((o) => sameFile(o.filepath, filepath));
      }
      getFileRange(lnum) {
        for (let item of this._fileItems) {
          for (let r of item.ranges) {
            if (r.lnum == lnum) {
              return Object.assign(omit(r, ["highlights"]), { filepath: item.filepath });
            }
          }
        }
        throw new Error(`File range not found at lnum: ${lnum}`);
      }
      onChange(e) {
        if (this.changing) return;
        if (e.contentChanges.length === 0) {
          this.highlightLineNr();
          this.nvim.redrawVim();
          return;
        }
        let { nvim } = this;
        e = fixChangeParams(e);
        let change = e.contentChanges[0];
        let { original } = e;
        if (change.range.end.line > 2) {
          nvim.call("setbufvar", [e.bufnr, "&modified", 1], true);
        }
        let { range, text } = change;
        let lineChange = lineCountChange(TextEdit.replace(range, text));
        if (lineChange == 0) return;
        let edits = [TextEdit.replace(range, text)];
        let addRanges = [];
        if (!emptyRange(range) && !text.includes("\u3000")) {
          let sl = range.start.line;
          let lnums = [];
          let lines = original.split(/\r?\n/);
          for (let i = 0; i < lines.length; i++) {
            let line = lines[i];
            if (line.length > 1 && line.includes("\u3000")) {
              lnums.push(sl + i + 1);
            }
          }
          if (lnums.length) {
            let infos = lnums.map((lnum) => {
              return this.getFileRange(lnum);
            });
            for (let item of this._fileItems) {
              item.ranges = item.ranges.filter((o) => !lnums.includes(o.lnum));
            }
            this.changes.add(infos);
          }
        } else if (emptyRange(range) && text.includes("\u3000")) {
          let lines = text.split(/\r?\n/);
          let lnums = [];
          let sl = range.start.line;
          for (let i = 0; i < lines.length; i++) {
            let line = lines[i];
            if (line.length > 1 && line.includes("\u3000")) {
              lnums.push(sl + i + 1);
            }
          }
          if (lnums.length) {
            let res = this.changes.checkInsert(lnums);
            if (res) addRanges = res;
          }
        } else if (text.includes("\u3000")) {
          edits = this.diffChanges(original, text);
          edits.forEach((e2) => {
            e2.range = adjustRangePosition(e2.range, range.start);
          });
        }
        this.adjustLnums(edits);
        nvim.pauseNotification();
        this.highlightLineNr();
        nvim.resumeNotification(true, true);
        if (addRanges.length) {
          addRanges.forEach((info) => {
            let item = this._fileItems.find((o) => o.filepath == info.filepath);
            item.ranges.push(info);
          });
        }
      }
      diffChanges(original, text) {
        let edits = [];
        let diffs = fastDiff(original, text);
        let offset = 0;
        let orig = TextDocument2.create("file:///1", "", 0, original);
        for (let i = 0; i < diffs.length; i++) {
          let diff = diffs[i];
          let pos = orig.positionAt(offset);
          if (diff[0] == fastDiff.EQUAL) {
            offset = offset + diff[1].length;
          } else if (diff[0] == fastDiff.DELETE) {
            let end = orig.positionAt(offset + diff[1].length);
            if (diffs[i + 1] && diffs[i + 1][0] == fastDiff.INSERT) {
              let text2 = diffs[i + 1][1];
              edits.push(TextEdit.replace(Range.create(pos, end), text2));
              i = i + 1;
            } else {
              edits.push(TextEdit.replace(Range.create(pos, end), ""));
            }
            offset = offset + diff[1].length;
          } else if (diff[0] == fastDiff.INSERT) {
            edits.push(TextEdit.insert(pos, diff[1]));
          }
        }
        return edits;
      }
      /**
       * Handle changes of other buffers.
       */
      async onDocumentChange(e) {
        if (this.changing || e.contentChanges.length === 0) return;
        let { uri } = e.textDocument;
        let fileItem = this.getFileItem(uri);
        if (!fileItem) return;
        let { range, text } = e.contentChanges[0];
        let lineChange = lineCountChange(TextEdit.replace(range, text));
        let edits = [];
        let deleteIndexes = [];
        for (let i = 0; i < fileItem.ranges.length; i++) {
          let r = fileItem.ranges[i];
          if (range.start.line >= r.start + r.lines.length) continue;
          if (range.end.line < r.start) {
            r.start = r.start + lineChange;
            continue;
          }
          let textDocument = workspace_default.getDocument(uri).textDocument;
          let end = r.start + r.lines.length + lineChange;
          let newLines = textDocument.lines.slice(r.start, end);
          if (!newLines.length) {
            deleteIndexes.push(i);
            let replaceRange = this.getDeleteRange(r);
            edits.push(TextEdit.replace(replaceRange, ""));
          } else {
            r.lines = newLines;
            let replaceRange = this.getReplaceRange(r);
            edits.push(TextEdit.replace(replaceRange, newLines.join("\n")));
          }
        }
        if (deleteIndexes.length) {
          fileItem.ranges = fileItem.ranges.filter((_, i) => !deleteIndexes.includes(i));
        }
        this._fileItems = this._fileItems.filter((o) => o.ranges && o.ranges.length > 0);
        if (edits.length) {
          this.adjustLnums(edits);
          this.changing = true;
          await this.document.applyEdits(edits);
          this.changing = false;
        }
        this.nvim.pauseNotification();
        this.highlightLineNr();
        this.buffer.setOption("modified", false, true);
        await this.nvim.resumeNotification(true);
      }
      adjustLnums(edits) {
        for (let item of this._fileItems) {
          for (let fileRange of item.ranges) {
            let line = fileRange.lnum - 1;
            fileRange.lnum += getChangedLineCount(Position.create(line, 0), edits);
          }
        }
      }
      /**
       * Current changed file ranges
       */
      async getFileChanges() {
        let changes = [];
        let lines = await this.buffer.lines;
        lines.push(SEPARATOR);
        let arr = [];
        let fsPath2;
        let lnum;
        for (let i = 0; i < lines.length; i++) {
          let line = lines[i];
          if (line.startsWith(SEPARATOR)) {
            if (fsPath2) {
              changes.push({
                filepath: fsPath2,
                lines: arr.slice(),
                lnum
              });
              fsPath2 = void 0;
              arr = [];
            }
            if (line.length > 1) {
              let ms = line.match(/^\u3000(.*)/);
              if (ms) {
                fsPath2 = this.getAbsolutePath(ms[1].replace(/\s+$/, ""));
                lnum = i + 1;
                arr = [];
              }
            }
          } else {
            arr.push(line);
          }
        }
        return changes;
      }
      /**
       * Open line under cursor in split window
       */
      async splitOpen() {
        let { nvim } = this;
        let win = nvim.createWindow(this.opts.fromWinid);
        let valid = await win.valid;
        let before = await nvim.eval(`strpart(getline('.'), 0 ,col('.') - 1)`);
        let character = before.length;
        let fileRange = await this.searchCurrentRange();
        if (fileRange) {
          let bufname = this.getAbsolutePath(fileRange.filepath);
          nvim.pauseNotification();
          if (valid) {
            nvim.call("win_gotoid", [this.opts.fromWinid], true);
            this.nvim.call("coc#util#jump", ["edit", bufname, [fileRange.line, character]], true);
          } else {
            this.nvim.call("coc#util#jump", ["belowright vs", bufname, [fileRange.line, character]], true);
          }
          nvim.command("normal! zz", true);
          await nvim.resumeNotification(true);
          if (!valid) {
            this.opts.fromWinid = await nvim.call("win_getid");
          }
        }
      }
      async searchCurrentRange() {
        let { nvim } = this;
        let lines = await nvim.eval('getline(1,line("."))');
        let len = lines.length;
        for (let i = 0; i < len; i++) {
          let line = lines[len - i - 1];
          let ms = line.match(/^\u3000(.+)/);
          if (ms) {
            let r = this.getFileRange(len - i);
            return Object.assign({ line: r.start + (i == 0 ? 1 : i) - 1 }, r);
          }
        }
        return void 0;
      }
      /**
       * Add FileItem to refactor buffer.
       */
      async addFileItems(items) {
        if (this._disposed) return;
        let { cwd: cwd2 } = this.opts;
        let { document: document2 } = this;
        const release = await this.mutex.acquire();
        try {
          await document2.synchronize();
          let count = document2.lineCount;
          let highlighter = new Highlighter();
          let hlRanges = [];
          for (let item of items) {
            let ranges = [];
            for (let range of item.ranges) {
              highlighter.addLine(SEPARATOR);
              highlighter.addLine(SEPARATOR);
              let lnum = count + highlighter.length;
              highlighter.addText(`${isParentFolder(cwd2, item.filepath) ? path.relative(cwd2, item.filepath) : item.filepath}`);
              let n = String(range.start + 1).length + String(range.end).length + 4;
              if (!this.srcId) highlighter.addText(" ".repeat(n));
              let base = 0 - highlighter.length - count;
              if (range.highlights) {
                hlRanges.push(...range.highlights.map((r) => adjustRange(r, base)));
              }
              let { lines, start, end, highlights } = range;
              if (!lines) {
                lines = await this.getLines(item.filepath, start, end);
              }
              ranges.push({ lines, lnum, start, highlights });
              highlighter.addLines(lines);
            }
            if (ranges.length) {
              let newItem = { filepath: item.filepath, ranges };
              let fileItem = this._fileItems.find((o) => o.filepath == item.filepath);
              if (fileItem) {
                fileItem.ranges.push(...newItem.ranges);
              } else {
                this._fileItems.push(newItem);
              }
            }
          }
          let { nvim, buffer } = this;
          this.changing = true;
          nvim.pauseNotification();
          highlighter.render(buffer, count);
          this.highlightLineNr();
          buffer.setOption("modified", false, true);
          buffer.setOption("undolevels", 1e3, true);
          if (count == 2 && hlRanges.length) {
            let pos = hlRanges[0].start;
            nvim.call("coc#cursor#move_to", [pos.line, pos.character], true);
          }
          await nvim.resumeNotification(true);
          await document2.patchChange();
          this.changing = false;
          await window_default.cursors.addRanges(hlRanges);
        } catch (e) {
          this.changing = false;
          logger53.error(`Error on add file item:`, e);
        }
        release();
      }
      findRange(filepath, lnum) {
        let item = this.fileItems.find((o) => sameFile(this.getAbsolutePath(o.filepath), filepath));
        let range = item.ranges.find((o) => o.lnum == lnum);
        if (!range) throw new Error(`File range not found at lnum: ${lnum}`);
        return range;
      }
      /**
       * Save changes to buffers/files, return false when no change made.
       */
      async save() {
        let { nvim } = this;
        let doc = this.document;
        let { buffer } = doc;
        await doc.patchChange();
        let changes = await this.getFileChanges();
        if (!changes) return;
        changes.sort((a, b) => a.lnum - b.lnum);
        let fileChanges = [];
        for (let i = 0; i < changes.length; i++) {
          let change = changes[i];
          let range = this.findRange(change.filepath, change.lnum);
          if (equals(range.lines, change.lines)) continue;
          fileChanges.push(Object.assign({ start: range.start, end: range.start + range.lines.length }, change));
          range.lines = change.lines;
        }
        if (fileChanges.length == 0) {
          await window_default.showInformationMessage("No change.");
          await buffer.setOption("modified", false);
          return false;
        }
        let changeMap = {};
        for (let change of fileChanges) {
          let uri = URI2.file(change.filepath).toString();
          let edits = changeMap[uri] || [];
          edits.push({
            range: Range.create(change.start, 0, change.end, 0),
            newText: change.lines.join("\n") + "\n"
          });
          changeMap[uri] = edits;
        }
        this.changing = true;
        await workspace_default.applyEdit({ changes: changeMap });
        this.changing = false;
        for (let item of this.fileItems) {
          let uri = URI2.file(this.getAbsolutePath(item.filepath)).toString();
          let edits = changeMap[uri];
          if (edits && edits.length > 0) {
            item.ranges.forEach((r) => {
              r.start += getChangedLineCount(Position.create(r.start, 0), edits);
            });
          }
        }
        nvim.pauseNotification();
        buffer.setOption("modified", false, true);
        if (this.config.saveToFile) {
          nvim.command("silent noa wa", true);
        }
        this.highlightLineNr();
        await nvim.resumeNotification();
        return true;
      }
      async getLines(fsPath2, start, end) {
        let uri = URI2.file(fsPath2).toString();
        let doc = workspace_default.getDocument(uri);
        if (doc) return doc.getLines(start, end);
        return await readFileLines(fsPath2, start, end - 1);
      }
      getAbsolutePath(filepath) {
        if (path.isAbsolute(filepath)) return filepath;
        return path.join(this.opts.cwd, filepath);
      }
      /**
       * Use conceal/virtual text to add lineNr
       */
      highlightLineNr() {
        let { fileItems, nvim, srcId: srcId4, bufnr } = this;
        let { winid, cwd: cwd2 } = this.opts;
        let info = {};
        if (srcId4) {
          nvim.call("nvim_buf_clear_namespace", [bufnr, srcId4, 0, -1], true);
          for (let item of fileItems) {
            for (let range of item.ranges) {
              let end = range.start + range.lines.length;
              let text = `${range.start + 1}:${end}`;
              info[range.lnum] = [range.start + 1, end];
              nvim.call("nvim_buf_set_virtual_text", [bufnr, srcId4, range.lnum - 1, [[text, "LineNr"]], {}], true);
            }
          }
        } else {
          if (this.matchIds.size) {
            nvim.call("coc#highlight#clear_matches", [winid, Array.from(this.matchIds)], true);
            this.matchIds.clear();
          }
          let id2 = 2e3;
          for (let item of fileItems) {
            let filename = `${cwd2 ? path.relative(cwd2, item.filepath) : item.filepath}`;
            let col = byteLength(filename) + 1;
            for (let range of item.ranges) {
              let end = range.start + range.lines.length;
              let text = `:${range.start + 1}:${end}`;
              for (let i = 0; i < text.length; i++) {
                let ch = text[i];
                this.matchIds.add(id2);
                info[range.lnum] = [range.start + 1, end];
                nvim.call("matchaddpos", ["Conceal", [[range.lnum, col + i]], 99, id2, { conceal: ch, window: winid }], true);
                id2++;
              }
            }
          }
        }
        this.buffer.setVar("line_infos", info, true);
      }
      getDeleteRange(r) {
        let { document: document2 } = this;
        let start = r.lnum - 1;
        let end;
        let total = document2.lineCount;
        for (let i = start; i < total; i++) {
          if (i + 1 == total) {
            end = Position.create(total, 0);
            break;
          }
          let line = document2.getline(i);
          if (line === SEPARATOR) {
            end = Position.create(i + 1, 0);
            break;
          }
          if (i != start && line.startsWith(SEPARATOR)) {
            end = Position.create(i, 0);
            break;
          }
        }
        return Range.create(Position.create(start, 0), end);
      }
      getReplaceRange(r) {
        let { document: document2 } = this;
        let start = r.lnum;
        let end;
        let total = document2.lineCount;
        for (let i = start; i < total; i++) {
          let line = document2.getline(i);
          if (i + 1 == total) {
            end = Position.create(i, line.length);
            break;
          }
          let next = document2.getline(i + 1);
          if (next.startsWith("\u3000")) {
            end = Position.create(i, line.length);
            break;
          }
        }
        return Range.create(Position.create(start, 0), end);
      }
      get valid() {
        return this.buffer.valid;
      }
      get buffer() {
        return this.nvim.createBuffer(this.bufnr);
      }
      get document() {
        return workspace_default.getDocument(this.bufnr);
      }
      dispose() {
        this._disposed = true;
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/refactor/search.ts
function getPathFromArgs(args) {
  if (args.length < 2) return void 0;
  let len = args.length;
  if (args[len - 1].startsWith("-")) return void 0;
  if (args[len - 2].startsWith("-")) return void 0;
  return args[len - 1];
}
var import_events53, spawn2, logger54, defaultArgs, controlCode2, Task2, Search;
var init_search = __esm({
  "src/handler/refactor/search.ts"() {
    "use strict";
    import_events53 = require("events");
    init_main();
    init_logger();
    init_highlighter();
    init_ansiparse();
    init_mutex();
    init_node();
    init_window();
    ({ spawn: spawn2 } = child_process);
    logger54 = createLogger("handler-search");
    defaultArgs = ["--color", "ansi", "--colors", "path:fg:black", "--colors", "line:fg:green", "--colors", "match:fg:red", "--no-messages", "--heading", "-n"];
    controlCode2 = "\x1B";
    Task2 = class extends import_events53.EventEmitter {
      start(cmd, args, cwd2) {
        this.process = spawn2(cmd, args, { cwd: cwd2, shell: process.platform === "win32" });
        this.process.on("error", (e) => {
          this.emit("error", e.message);
        });
        const rl = readline.createInterface(this.process.stdout);
        let start;
        let fileItem;
        let lines = [];
        let highlights = [];
        let create = true;
        rl.on("line", (content) => {
          if (content.includes(controlCode2)) {
            let items = ansiparse(content);
            if (items.length == 0) return;
            if (items[0].foreground == "black") {
              fileItem = { filepath: path.join(cwd2, items[0].text), ranges: [] };
              return;
            }
            let normalLine = items[0].foreground == "green";
            if (normalLine) {
              let lnum = parseInt(items[0].text, 10) - 1;
              let padlen2 = items[0].text.length + 1;
              if (create) {
                start = lnum;
                create = false;
              }
              let line = "";
              for (let item of items) {
                if (item.foreground == "red") {
                  let l = lnum - start;
                  let c = line.length - padlen2;
                  highlights.push(Range.create(l, c, l, c + item.text.length));
                }
                line += item.text;
              }
              let currline = line.slice(padlen2);
              lines.push(currline);
            }
          } else {
            let fileEnd = content.trim().length == 0;
            if (fileItem && (fileEnd || content.trim() == "--")) {
              fileItem.ranges.push({ lines, highlights, start });
            }
            if (fileEnd) {
              this.emit("item", fileItem);
              fileItem = null;
            }
            lines = [];
            highlights = [];
            create = true;
          }
        });
        rl.on("close", () => {
          if (fileItem) {
            if (lines.length) {
              fileItem.ranges.push({ lines, highlights, start });
            }
            this.emit("item", fileItem);
          }
          lines = highlights = fileItem = null;
          this.emit("end");
        });
      }
      dispose() {
        if (this.process) {
          this.process.kill();
        }
      }
    };
    Search = class {
      constructor(nvim, cmd = "rg") {
        this.nvim = nvim;
        this.cmd = cmd;
      }
      run(args, cwd2, refactorBuf) {
        let { nvim, cmd } = this;
        let { afterContext, beforeContext } = refactorBuf.config;
        let argList = ["-A", afterContext.toString(), "-B", beforeContext.toString()].concat(defaultArgs, args);
        let p = getPathFromArgs(args);
        if (p) argList.pop();
        argList.push("--", p ? path.isAbsolute(p) ? p : `./${p.replace(/^\.\//, "")}` : "./");
        this.task = new Task2();
        this.task.start(cmd, argList, cwd2);
        let mutex = new Mutex();
        let files = 0;
        let matches = 0;
        let start = Date.now();
        let fileItems = [];
        const addFileItems = async () => {
          if (fileItems.length == 0) return;
          let items = fileItems.slice();
          fileItems = [];
          const release = await mutex.acquire();
          try {
            await refactorBuf.addFileItems(items);
          } catch (e) {
            logger54.error(e);
          }
          release();
        };
        return new Promise((resolve, reject) => {
          let interval2 = setInterval(addFileItems, 300);
          this.task.on("item", async (fileItem) => {
            files++;
            matches = matches + fileItem.ranges.reduce((p2, r) => p2 + r.highlights.length, 0);
            fileItems.push(fileItem);
          });
          this.task.on("error", (message) => {
            clearInterval(interval2);
            void window_default.showErrorMessage(`Error on command "${cmd}": ${message}`);
            this.task = null;
            reject(new Error(message));
          });
          this.task.on("end", async () => {
            clearInterval(interval2);
            try {
              await addFileItems();
              const release = await mutex.acquire();
              release();
              this.task.removeAllListeners();
              this.task = null;
              let buf = refactorBuf.buffer;
              if (buf) {
                nvim.pauseNotification();
                if (files == 0) {
                  buf.setLines(["No match found"], { start: 1, end: 2, strictIndexing: false }, true);
                  buf.addHighlight({ line: 1, srcId: -1, colEnd: -1, colStart: 0, hlGroup: "Error" });
                  buf.setOption("modified", false, true);
                } else {
                  let highlighter = new Highlighter();
                  highlighter.addText("Files", "MoreMsg");
                  highlighter.addText(": ");
                  highlighter.addText(`${files} `, "Number");
                  highlighter.addText("Matches", "MoreMsg");
                  highlighter.addText(": ");
                  highlighter.addText(`${matches} `, "Number");
                  highlighter.addText("Duration", "MoreMsg");
                  highlighter.addText(": ");
                  highlighter.addText(`${Date.now() - start}ms`, "Number");
                  highlighter.render(buf, 1, 2);
                }
                buf.setOption("modified", false, true);
                nvim.resumeNotification(false, true);
              }
            } catch (e) {
              reject(e);
              return;
            }
            resolve();
          });
        });
      }
      abort() {
        this.task?.dispose();
      }
    };
  }
});

// src/handler/refactor/index.ts
function adjustRange2(range, offset) {
  let { start, end } = range;
  return Range.create(start.line - offset, start.character, end.line - offset, end.character);
}
var name, refactorId, srcId3, Refactor;
var init_refactor = __esm({
  "src/handler/refactor/index.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_events();
    init_languages();
    init_util();
    init_fs();
    init_protocol();
    init_textedit();
    init_workspace();
    init_buffer5();
    init_search();
    name = "__coc_refactor__";
    refactorId = 0;
    Refactor = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.buffers = /* @__PURE__ */ new Map();
        this.disposables = [];
        this._onCreate = new import_node4.Emitter();
        this.onCreate = this._onCreate.event;
        this.setConfiguration();
        workspace_default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);
        events_default.on("BufUnload", (bufnr) => {
          let buf = this.buffers.get(bufnr);
          if (buf) {
            buf.dispose();
            this.buffers.delete(bufnr);
          }
        }, null, this.disposables);
        workspace_default.onDidChangeTextDocument((e) => {
          let buf = this.buffers.get(e.bufnr);
          if (buf) buf.onChange(e);
        }, null, this.disposables);
      }
      has(bufnr) {
        return this.buffers.has(bufnr);
      }
      setConfiguration(e) {
        if (e && !e.affectsConfiguration("refactor")) return;
        let config = workspace_default.getConfiguration("refactor", null);
        this.config = Object.assign(this.config || {}, {
          afterContext: config.get("afterContext", 3),
          beforeContext: config.get("beforeContext", 3),
          openCommand: config.get("openCommand", "vsplit"),
          saveToFile: config.get("saveToFile", true),
          showMenu: config.get("showMenu", "<Tab>")
        });
      }
      /**
       * Refactor of current symbol
       */
      async doRefactor() {
        let { doc, position } = await this.handler.getCurrentState();
        if (!languages_default.hasProvider("rename" /* Rename */, doc.textDocument)) {
          throw new Error(`Rename provider not found for current buffer`);
        }
        await doc.synchronize();
        let edit2 = await this.handler.withRequestToken("refactor", async (token) => {
          let res = await languages_default.prepareRename(doc.textDocument, position, token);
          if (token.isCancellationRequested) return null;
          if (res === false) throw new Error(`Provider returns null on prepare, unable to rename at current position`);
          let edit3 = await languages_default.provideRenameEdits(doc.textDocument, position, "NewName", token);
          if (token.isCancellationRequested) return null;
          if (!edit3) throw new Error("Provider returns null for rename edits.");
          return edit3;
        });
        if (edit2) {
          await this.fromWorkspaceEdit(edit2, doc.filetype);
        }
      }
      /**
       * Search by rg
       */
      async search(args) {
        let buf = await this.createRefactorBuffer();
        let cwd2 = await this.nvim.call("getcwd", []);
        let search = new Search(this.nvim);
        await search.run(args, cwd2, buf);
      }
      async save(bufnr) {
        let buf = this.buffers.get(bufnr);
        if (buf) return await buf.save();
      }
      getBuffer(bufnr) {
        return this.buffers.get(bufnr);
      }
      /**
       * Create initialized refactor buffer
       */
      async createRefactorBuffer(filetype, conceal = false) {
        let { nvim } = this;
        let [fromWinid, cwd2] = await nvim.eval("[win_getid(),getcwd()]");
        let { openCommand } = this.config;
        if (!nvim.isVim && !srcId3) srcId3 = await this.nvim.createNamespace("coc-refactor");
        nvim.pauseNotification();
        nvim.command(`${openCommand} ${name}${refactorId++}`, true);
        nvim.command(`setl buftype=acwrite nobuflisted bufhidden=wipe nofen wrap conceallevel=2 concealcursor=n`, true);
        nvim.command(`setl undolevels=-1 nolist nospell noswapfile foldmethod=expr foldexpr=coc#util#refactor_foldlevel(v:lnum)`, true);
        nvim.command(`setl foldtext=coc#util#refactor_fold_text(v:foldstart)`, true);
        nvim.call("setline", [1, ["Save current buffer to make changes", SEPARATOR]], true);
        nvim.call("matchadd", ["Comment", "\\%1l"], true);
        nvim.call("matchadd", ["Conceal", "^\\%u3000"], true);
        nvim.call("matchadd", ["Label", "^\\%u3000\\zs\\S\\+"], true);
        nvim.command("setl nomod", true);
        if (filetype) nvim.command(`runtime! syntax/${filetype}.vim`, true);
        nvim.call("coc#util#do_autocmd", ["CocRefactorOpen"], true);
        await nvim.resumeNotification();
        let [bufnr, win] = await nvim.eval('[bufnr("%"),win_getid()]');
        let opts = { fromWinid, winid: win, cwd: cwd2 };
        await workspace_default.document;
        let buf = new RefactorBuffer(bufnr, conceal ? void 0 : srcId3, this.nvim, this.config, opts);
        this.buffers.set(bufnr, buf);
        return buf;
      }
      /**
       * Create refactor buffer from lines
       */
      async fromLines(lines) {
        let buf = await this.createRefactorBuffer();
        await buf.buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false });
        return buf;
      }
      /**
       * Create refactor buffer from locations
       */
      async fromLocations(locations, filetype) {
        if (!locations || locations.length == 0) return void 0;
        let changes = {};
        let edit2 = { changes };
        for (let location of locations) {
          let edits = changes[location.uri] || [];
          edits.push({ range: location.range, newText: "" });
          changes[location.uri] = edits;
        }
        return await this.fromWorkspaceEdit(edit2, filetype);
      }
      /**
       * Start refactor from workspaceEdit
       */
      async fromWorkspaceEdit(edit2, filetype) {
        if (!edit2 || emptyWorkspaceEdit(edit2)) return void 0;
        let items = [];
        let { beforeContext, afterContext } = this.config;
        let { changes, documentChanges } = edit2;
        if (!changes) {
          changes = {};
          for (let change of documentChanges || []) {
            if (TextDocumentEdit.is(change)) {
              let { textDocument, edits } = change;
              changes[textDocument.uri] = edits;
            }
          }
        }
        for (let key of Object.keys(changes)) {
          let max = await this.getLineCount(key);
          let edits = changes[key];
          let ranges = [];
          let start = null;
          let end = null;
          let highlights = [];
          edits.sort((a, b) => a.range.start.line - b.range.start.line);
          for (let edit3 of edits) {
            let { line } = edit3.range.start;
            let s = Math.max(0, line - beforeContext);
            if (start != null && s < end) {
              end = Math.min(max, line + afterContext + 1);
              highlights.push(adjustRange2(edit3.range, start));
            } else {
              if (start != null) ranges.push({ start, end, highlights });
              start = s;
              end = Math.min(max, line + afterContext + 1);
              highlights = [adjustRange2(edit3.range, start)];
            }
          }
          if (start != null) ranges.push({ start, end, highlights });
          items.push({
            ranges,
            filepath: URI2.parse(key).fsPath
          });
        }
        let buf = await this.createRefactorBuffer(filetype);
        await buf.addFileItems(items);
        return buf;
      }
      async getLineCount(uri) {
        let doc = workspace_default.getDocument(uri);
        if (doc) return doc.lineCount;
        return await getFileLineCount(URI2.parse(uri).fsPath);
      }
      reset() {
        for (let buf of this.buffers.values()) {
          buf.dispose();
        }
        this.buffers.clear();
      }
      dispose() {
        this._onCreate.dispose();
        this.buffers.clear();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/rename.ts
var Rename;
var init_rename2 = __esm({
  "src/handler/rename.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_position();
    init_protocol();
    init_window();
    init_workspace();
    Rename = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
      }
      async getWordEdit() {
        let { doc, position } = await this.handler.getCurrentState();
        let range = doc.getWordRangeAtPosition(position);
        if (!range || emptyRange(range)) return null;
        let curname = doc.textDocument.getText(range);
        if (languages_default.hasProvider("rename" /* Rename */, doc.textDocument)) {
          await doc.synchronize();
          let requestTokenSource = new import_node4.CancellationTokenSource();
          let res = await languages_default.prepareRename(doc.textDocument, position, requestTokenSource.token);
          if (res !== false) {
            let newName = curname.startsWith("a") ? "b" : "a";
            let edit2 = await languages_default.provideRenameEdits(doc.textDocument, position, newName, requestTokenSource.token);
            if (edit2) return edit2;
          }
        }
        void window_default.showInformationMessage("Rename provider not found, extract word ranges from current buffer");
        let ranges = doc.getSymbolRanges(curname);
        return {
          changes: {
            [doc.uri]: ranges.map((r) => ({ range: r, newText: curname }))
          }
        };
      }
      async rename(newName) {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("rename" /* Rename */, doc.textDocument);
        await doc.synchronize();
        let token = new import_node4.CancellationTokenSource().token;
        let res = await languages_default.prepareRename(doc.textDocument, position, token);
        if (res === false) {
          void window_default.showWarningMessage("Invalid position for rename");
          return false;
        }
        let curname;
        if (!newName) {
          if (Range.is(res)) {
            curname = doc.textDocument.getText(res);
            await window_default.moveTo(res.start);
          } else if (res && typeof res.placeholder === "string") {
            curname = res.placeholder;
          } else {
            curname = await this.nvim.eval('expand("<cword>")');
          }
          const config = workspace_default.getConfiguration("coc.preferences", null);
          newName = await window_default.requestInput("New name", config.get("renameFillCurrent", true) ? curname : "");
        }
        if (newName === "") void window_default.showWarningMessage("Empty word, rename canceled");
        if (!newName) return false;
        let edit2 = await languages_default.provideRenameEdits(doc.textDocument, position, newName, token);
        if (token.isCancellationRequested || !edit2) return false;
        await workspace_default.applyEdit(edit2);
        return true;
      }
    };
  }
});

// src/handler/selectionRange.ts
var SelectionRangeHandler;
var init_selectionRange2 = __esm({
  "src/handler/selectionRange.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_array();
    init_object();
    init_position();
    init_window();
    SelectionRangeHandler = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.selectionRange = null;
      }
      async getSelectionRanges() {
        let { doc, position } = await this.handler.getCurrentState();
        this.handler.checkProvider("selectionRange" /* SelectionRange */, doc.textDocument);
        await doc.synchronize();
        return await this.handler.withRequestToken("selection ranges", (token) => {
          return languages_default.getSelectionRanges(doc.textDocument, [position], token);
        });
      }
      async selectRange(visualmode, forward) {
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvider("selectionRange" /* SelectionRange */, doc.textDocument);
        let positions = [];
        if (!forward && (!this.selectionRange || !visualmode)) return;
        if (visualmode) {
          let range = await window_default.getSelectedRange(visualmode);
          positions.push(range.start, range.end);
        } else {
          let position = await window_default.getCursorPosition();
          positions.push(position);
        }
        if (!forward) {
          let curr = Range.create(positions[0], positions[1]);
          let { selectionRange: selectionRange2 } = this;
          while (selectionRange2 && selectionRange2.parent) {
            if (equals(selectionRange2.parent.range, curr)) {
              break;
            }
            selectionRange2 = selectionRange2.parent;
          }
          if (selectionRange2 && selectionRange2.parent) {
            await window_default.selectRange(selectionRange2.range);
          }
          return;
        }
        await doc.synchronize();
        let selectionRanges = await this.handler.withRequestToken("selection ranges", (token) => {
          return languages_default.getSelectionRanges(doc.textDocument, positions, token);
        });
        if (isFalsyOrEmpty(selectionRanges)) return false;
        let selectionRange;
        if (selectionRanges.length == 1) {
          selectionRange = selectionRanges[0];
        } else {
          let end = positions[1] ?? positions[0];
          let r = Range.create(positions[0], end);
          selectionRange = selectionRanges[0];
          while (selectionRange) {
            if (equals(r, selectionRange.range)) {
              selectionRange = selectionRange.parent;
              continue;
            }
            if (positionInRange(positions[0], selectionRange.range) == 0 && positionInRange(end, selectionRange.range) == 0) {
              break;
            }
            selectionRange = selectionRange.parent;
          }
        }
        if (!selectionRange) return false;
        this.selectionRange = selectionRanges[0];
        await window_default.selectRange(selectionRange.range);
        return true;
      }
    };
  }
});

// src/handler/semanticTokens/buffer.ts
function toHighlightPart(token) {
  if (!token) return "";
  if (highlightGroupMap.has(token)) return highlightGroupMap.get(token);
  let chars = [];
  for (let i = 0; i < token.length; i++) {
    let ch = token[i];
    ch = isHighlightGroupCharCode(ch.charCodeAt(0)) ? ch : "_";
    chars.push(i == 0 ? ch.toUpperCase() : ch);
  }
  let part = chars.join("");
  highlightGroupMap.set(token, part);
  return part;
}
var logger55, yieldEveryMilliseconds, HLGROUP_PREFIX, NAMESPACE4, debounceInterval2, requestDelay2, highlightGroupMap, SemanticTokensBuffer;
var init_buffer6 = __esm({
  "src/handler/semanticTokens/buffer.ts"() {
    "use strict";
    init_main();
    init_languages();
    init_logger();
    init_regions();
    init_util();
    init_array();
    init_errors();
    init_util();
    init_numbers();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    logger55 = createLogger("semanticTokens-buffer");
    yieldEveryMilliseconds = getConditionValue(15, 5);
    HLGROUP_PREFIX = "CocSem";
    NAMESPACE4 = "semanticTokens";
    debounceInterval2 = getConditionValue(100, 20);
    requestDelay2 = getConditionValue(500, 20);
    highlightGroupMap = /* @__PURE__ */ new Map();
    SemanticTokensBuffer = class {
      constructor(nvim, doc, staticConfig) {
        this.nvim = nvim;
        this.doc = doc;
        this.staticConfig = staticConfig;
        this._dirty = false;
        this.regions = new Regions();
        this._onDidRefresh = new import_node4.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        if (this.hasProvider) this.doHighlight().catch(onUnexpectedError);
      }
      get config() {
        if (this._config) return this._config;
        this.loadConfiguration();
        return this._config;
      }
      loadConfiguration() {
        let config = workspace_default.getConfiguration("semanticTokens", this.doc);
        let changed = this._config != null && this._config.enable != config.enable;
        this._config = {
          enable: config.get("enable"),
          highlightPriority: config.get("highlightPriority"),
          incrementTypes: config.get("incrementTypes"),
          combinedModifiers: config.get("combinedModifiers")
        };
        if (changed) {
          if (this._config.enable) {
            this.forceHighlight().catch(onUnexpectedError);
          } else {
            this.clearHighlight();
          }
        }
      }
      get configEnabled() {
        let { enable } = this.config;
        let { filetypes } = this.staticConfig;
        if (Array.isArray(filetypes)) return filetypes.includes("*") || filetypes.includes(this.doc.filetype);
        return enable;
      }
      get bufnr() {
        return this.doc.bufnr;
      }
      onChange() {
        this.doHighlight().catch(onUnexpectedError);
      }
      onTextChange() {
        this._version = void 0;
        this.cancel();
      }
      async forceHighlight() {
        this.clearHighlight();
        await this.doHighlight(true, 0);
      }
      async onShown(winid) {
        if (!this.shouldHighlight) return;
        await this.doHighlight(false, debounceInterval2, winid);
      }
      async onWinScroll(winid) {
        if (!this.shouldHighlight) return;
        this.cancel(true);
        let rangeTokenSource = this.rangeTokenSource = new import_node4.CancellationTokenSource();
        let token = rangeTokenSource.token;
        await waitWithToken(debounceInterval2, token);
        if (token.isCancellationRequested) return;
        if (this.shouldRangeHighlight) {
          await this.doRangeHighlight(winid, token);
        } else {
          await this.highlightRegions(winid, token);
        }
      }
      get hasProvider() {
        return languages_default.hasProvider("semanticTokens" /* SemanticTokens */, this.doc) || languages_default.hasProvider("semanticTokensRange" /* SemanticTokensRange */, this.doc);
      }
      get hasLegend() {
        let { textDocument } = this.doc;
        return languages_default.getLegend(textDocument) != null || languages_default.getLegend(textDocument, true) != null;
      }
      get rangeProviderOnly() {
        return !languages_default.hasProvider("semanticTokens" /* SemanticTokens */, this.doc) && languages_default.hasProvider("semanticTokensRange" /* SemanticTokensRange */, this.doc);
      }
      get shouldRangeHighlight() {
        let { textDocument } = this.doc;
        return languages_default.hasProvider("semanticTokensRange" /* SemanticTokensRange */, textDocument) && this.previousResults == null;
      }
      /**
       * Get current highlight items
       */
      get highlights() {
        if (!this._highlights) return void 0;
        return this._highlights[1];
      }
      get buffer() {
        return this.nvim.createBuffer(this.bufnr);
      }
      get enabled() {
        if (!this.configEnabled || !this.hasLegend) return false;
        return this.hasProvider;
      }
      get shouldHighlight() {
        if (!this.enabled) return false;
        const { doc } = this;
        if (doc.dirty || doc.version === this._version) return false;
        return true;
      }
      checkState() {
        if (!this.configEnabled) throw new Error(`Semantic tokens highlight not enabled for current filetype: ${this.doc.filetype}`);
        if (!this.hasProvider || !this.hasLegend) throw new Error(`SemanticTokens provider not found for ${this.doc.uri}`);
      }
      async getTokenRanges(tokens, legend, token) {
        let currentLine = 0;
        let currentCharacter = 0;
        let highlights = [];
        let toBytes;
        let textDocument = this.doc.textDocument;
        let tickStart = Date.now();
        for (let i = 0; i < tokens.length; i += 5) {
          if (i == 0 || Date.now() - tickStart > yieldEveryMilliseconds) {
            await waitImmediate();
            if (token.isCancellationRequested) break;
            tickStart = Date.now();
          }
          const deltaLine = tokens[i];
          const deltaCharacter = tokens[i + 1];
          const length = tokens[i + 2];
          const tokenType = legend.tokenTypes[tokens[i + 3]];
          const tokenModifiers = legend.tokenModifiers.filter((_, m) => tokens[i + 4] & 1 << m);
          const lnum = currentLine + deltaLine;
          if (deltaLine != 0 || !toBytes) {
            toBytes = bytes(toText(textDocument.lines[lnum]));
          }
          const sc = deltaLine === 0 ? currentCharacter + deltaCharacter : deltaCharacter;
          const ec = sc + length;
          currentLine = lnum;
          currentCharacter = sc;
          this.addHighlightItems(highlights, [lnum, toBytes(sc), toBytes(ec)], tokenType, tokenModifiers);
        }
        if (token.isCancellationRequested) return null;
        return highlights;
      }
      /**
       * Single line only.
       */
      addHighlightItems(highlights, range, tokenType, tokenModifiers) {
        let { combinedModifiers } = this.config;
        let combine = false;
        highlights.push({
          range,
          tokenType,
          combine,
          hlGroup: HLGROUP_PREFIX + "Type" + toHighlightPart(tokenType),
          tokenModifiers
        });
        if (tokenModifiers.length) {
          const modifier = tokenModifiers[0];
          combine = combinedModifiers.includes(modifier);
          highlights.push({
            range,
            tokenType,
            combine,
            hlGroup: HLGROUP_PREFIX + "TypeMod" + toHighlightPart(tokenType) + toHighlightPart(modifier),
            tokenModifiers
          });
        }
      }
      toHighlightItems(highlights, span) {
        let { incrementTypes } = this.config;
        let filter2 = Array.isArray(span);
        let res = [];
        for (let hi of highlights) {
          if (!hi.hlGroup) continue;
          let lnum = hi.range[0];
          if (filter2 && (lnum < span[0] || lnum > span[1])) continue;
          let item = {
            lnum,
            hlGroup: hi.hlGroup,
            colStart: hi.range[1],
            colEnd: hi.range[2],
            combine: hi.combine
          };
          if (incrementTypes.includes(hi.tokenType)) {
            item.end_incl = true;
            item.start_incl = true;
          }
          res.push(item);
        }
        return res;
      }
      async doHighlight(forceFull = false, wait2 = debounceInterval2, winid) {
        this.cancel();
        let tokenSource = this.tokenSource = new import_node4.CancellationTokenSource();
        let token = tokenSource.token;
        await waitWithToken(wait2, token);
        if (token.isCancellationRequested) return;
        const winids = winid == null ? workspace_default.editors.getBufWinids(this.bufnr) : [winid];
        if (!this.enabled || winids.length === 0) return;
        if (this.shouldRangeHighlight) {
          this.cancel(true);
          let rangeTokenSource = this.rangeTokenSource = new import_node4.CancellationTokenSource();
          let rangeToken = rangeTokenSource.token;
          for (const win of winids) {
            await this.doRangeHighlight(win, rangeToken);
            if (rangeToken.isCancellationRequested) break;
          }
        }
        if (token.isCancellationRequested || this.rangeProviderOnly) return;
        this.cancel(true);
        const { doc } = this;
        const version2 = doc.version;
        let tokenRanges;
        if (version2 === this.previousResults?.version) {
          if (this._highlights && this._highlights[0] == version2) {
            tokenRanges = this._highlights[1];
          } else {
            const tokens = this.previousResults.tokens;
            const legend = languages_default.getLegend(doc.textDocument);
            tokenRanges = await this.getTokenRanges(tokens, legend, token);
          }
        } else {
          tokenRanges = await this.sendRequest(() => {
            return this.requestAllHighlights(token, forceFull);
          }, token);
        }
        if (token.isCancellationRequested || !tokenRanges) return;
        this._highlights = [version2, tokenRanges];
        if (!this._dirty || tokenRanges.length < 500) {
          let succeed = await this.addHighlights(tokenRanges, void 0, token);
          if (succeed) this._version = version2;
        } else {
          this.regions.clear();
          await this.highlightRegions(winid, token);
        }
        this._onDidRefresh.fire();
      }
      async addHighlights(highlights, span, token) {
        const { bufnr, regions, doc, config } = this;
        let items = this.toHighlightItems(highlights, span);
        let diff = await window_default.diffHighlights(bufnr, NAMESPACE4, items, span, token);
        if (!diff || token.isCancellationRequested) return false;
        const priority = config.highlightPriority;
        await window_default.applyDiffHighlights(bufnr, NAMESPACE4, priority, diff, true);
        this._dirty = true;
        if (span) {
          regions.add(span[0], span[1]);
        } else {
          regions.add(0, doc.lineCount);
        }
        return true;
      }
      async sendRequest(fn, token) {
        try {
          return await fn();
        } catch (e) {
          if (!token.isCancellationRequested) {
            if (e instanceof CancellationError) {
              this.doHighlight(true, requestDelay2).catch(onUnexpectedError);
            } else {
              logger55.error("Error on request semanticTokens: ", e);
            }
          }
          return void 0;
        }
      }
      /**
       * Perform range highlight request and update.
       */
      async doRangeHighlight(winid, token) {
        const { version: version2 } = this.doc;
        let res = await this.sendRequest(() => {
          return this.requestRangeHighlights(winid, token);
        }, token);
        if (res == null || token.isCancellationRequested) return;
        const { highlights, start, end } = res;
        if (this.rangeProviderOnly || !this.previousResults) {
          if (!this._highlights || version2 !== this._highlights[0]) {
            this._highlights = [version2, []];
          }
          let tokenRanges = this._highlights[1];
          let usedLines = tokenRanges.reduce((p, c) => p.add(c.range[0]), /* @__PURE__ */ new Set());
          highlights.forEach((hi) => {
            if (!usedLines.has(hi.range[0])) {
              tokenRanges.push(hi);
            }
          });
        }
        await this.addHighlights(highlights, [start, end], token);
      }
      /**
       * highlight current visible regions, highlight all associated winids when winid is undefined
       */
      async highlightRegions(winid, token) {
        let { regions, highlights, doc, bufnr } = this;
        if (!highlights) return;
        let spans = await window_default.getVisibleRanges(bufnr, winid);
        if (token.isCancellationRequested) return;
        for (let lines of spans) {
          let span = regions.toUncoveredSpan([lines[0] - 1, lines[1] - 1], workspace_default.env.lines, doc.lineCount);
          if (span) await this.addHighlights(highlights, span, token);
        }
      }
      /**
       * Request highlights for visible range of winid.
       */
      async requestRangeHighlights(winid, token) {
        let { nvim, doc } = this;
        let region = await nvim.call("coc#window#visible_range", [winid]);
        if (!region || token.isCancellationRequested) return null;
        let span = this.regions.toUncoveredSpan([region[0] - 1, region[1] - 1], workspace_default.env.lines, doc.lineCount);
        if (!span) return null;
        const startLine = span[0];
        const endLine = span[1];
        let range = doc.textDocument.intersectWith(Range.create(startLine, 0, endLine + 1, 0));
        let res = await languages_default.provideDocumentRangeSemanticTokens(doc.textDocument, range, token);
        if (!res || !SemanticTokens.is(res) || token.isCancellationRequested) return null;
        let legend = languages_default.getLegend(doc.textDocument, true);
        let highlights = await this.getTokenRanges(res.data, legend, token);
        if (!highlights) return null;
        return { highlights, start: startLine, end: endLine };
      }
      /**
       * Request highlights from provider, return undefined when can't request or request cancelled
       * Use range provider only when not semanticTokens provider exists.
       */
      async requestAllHighlights(token, forceFull) {
        const textDocument = this.doc.textDocument;
        const legend = languages_default.getLegend(textDocument);
        const hasEditProvider = languages_default.hasSemanticTokensEdits(textDocument);
        const previousResult = forceFull ? null : this.previousResults;
        const version2 = textDocument.version;
        let result;
        if (hasEditProvider && previousResult?.resultId) {
          result = await languages_default.provideDocumentSemanticTokensEdits(textDocument, previousResult.resultId, token);
        } else {
          result = await languages_default.provideDocumentSemanticTokens(textDocument, token);
        }
        if (token.isCancellationRequested || result == null) return;
        let tokens = [];
        if (SemanticTokens.is(result)) {
          tokens = result.data;
        } else if (previousResult && Array.isArray(result.edits)) {
          tokens = previousResult.tokens;
          result.edits.forEach((e) => {
            tokens.splice(e.start, toNumber(e.deleteCount), ...toArray(e.data));
          });
        }
        this.previousResults = { resultId: result.resultId, tokens, version: version2 };
        return await this.getTokenRanges(tokens, legend, token);
      }
      clearHighlight() {
        this.reset();
        this.buffer.clearNamespace(NAMESPACE4);
      }
      onProviderChange() {
        if (!this.hasProvider) {
          this.cancel();
          this.clearHighlight();
        } else {
          this.reset();
          this.doHighlight(true, 0).catch(onUnexpectedError);
        }
      }
      cancel(rangeOnly = false) {
        if (this.rangeTokenSource) {
          this.rangeTokenSource.cancel();
          this.rangeTokenSource = null;
        }
        if (rangeOnly) return;
        this.regions.clear();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      reset() {
        this.previousResults = void 0;
        this._highlights = void 0;
        this._version = void 0;
        this.regions.clear();
      }
      dispose() {
        this.cancel();
        this.reset();
        this._onDidRefresh.dispose();
      }
    };
  }
});

// src/handler/semanticTokens/index.ts
var headGroup, floatFactory3, SemanticTokens5;
var init_semanticTokens2 = __esm({
  "src/handler/semanticTokens/index.ts"() {
    "use strict";
    init_commands();
    init_events();
    init_languages();
    init_highlighter();
    init_util();
    init_array();
    init_string();
    init_window();
    init_workspace();
    init_buffer6();
    headGroup = "Statement";
    SemanticTokens5 = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        this.setStaticConfiguration();
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("semanticTokens")) {
            this.setStaticConfiguration();
            for (let item of this.highlighters.items) {
              item.loadConfiguration();
            }
          }
        }, this, this.disposables);
        commands_default.register({
          id: "semanticTokens.checkCurrent",
          execute: async () => {
            await this.showHighlightInfo();
          }
        }, false, "show semantic tokens highlight information of current buffer");
        commands_default.register({
          id: "semanticTokens.refreshCurrent",
          execute: () => {
            return this.highlightCurrent();
          }
        }, false, "refresh semantic tokens highlight of current buffer.");
        commands_default.register({
          id: "semanticTokens.inspect",
          execute: () => {
            return this.inspectSemanticToken();
          }
        }, false, "Inspect semantic token information at cursor position.");
        commands_default.register({
          id: "semanticTokens.clearCurrent",
          execute: async () => {
            let buf = await nvim.buffer;
            buf.clearNamespace(NAMESPACE4, 0, -1);
          }
        }, false, "clear semantic tokens highlight of current buffer");
        commands_default.register({
          id: "semanticTokens.clearAll",
          execute: async () => {
            let bufs = await nvim.buffers;
            for (let buf of bufs) {
              buf.clearNamespace(NAMESPACE4, 0, -1);
            }
          }
        }, false, "clear semantic tokens highlight of all buffers");
        this.highlighters = workspace_default.registerBufferSync((doc) => {
          return new SemanticTokensBuffer(this.nvim, doc, this.staticConfig);
        });
        languages_default.onDidSemanticTokensRefresh(async (selector) => {
          let visibleBufs = window_default.visibleTextEditors.map((o) => o.document.bufnr);
          for (let item of this.highlighters.items) {
            if (workspace_default.match(selector, item.doc) && visibleBufs.includes(item.bufnr)) {
              item.onProviderChange();
            }
          }
        }, null, this.disposables);
        events_default.on("BufWinEnter", async (bufnr, winid) => {
          let item = this.highlighters.getItem(bufnr);
          if (item) await item.onShown(winid);
        }, null, this.disposables);
        events_default.on("WinScrolled", async (winid, bufnr) => {
          let item = this.highlighters.getItem(bufnr);
          if (item) await item.onWinScroll(winid);
        }, null, this.disposables);
      }
      setStaticConfiguration() {
        const filetypes = workspace_default.initialConfiguration.get("semanticTokens.filetypes", null);
        this.staticConfig = Object.assign(this.staticConfig ?? {}, { filetypes });
      }
      async inspectSemanticToken() {
        let item = await this.getCurrentItem();
        if (!item || !item.enabled) {
          if (!item) {
            let doc = await workspace_default.document;
            void window_default.showErrorMessage(`Document not attached, ${doc.notAttachReason}`);
          } else {
            try {
              item.checkState();
            } catch (e) {
              void window_default.showErrorMessage(e.message);
            }
          }
          this.closeFloat();
          return;
        }
        let [_, line, col] = await this.nvim.call("getcurpos", []);
        let highlights = toArray(item.highlights);
        let highlight = highlights.find((o) => {
          let column = col - 1;
          return o.range[0] === line - 1 && column >= o.range[1] && column < o.range[2];
        });
        if (highlight) {
          let modifiers = toArray(highlight.tokenModifiers);
          let highlights2 = [];
          if (highlight.hlGroup) {
            let s = "Highlight group: ".length;
            highlights2.push({
              lnum: 2,
              colStart: s,
              colEnd: s + highlight.hlGroup.length,
              hlGroup: highlight.hlGroup
            });
          }
          let docs = [{
            filetype: "txt",
            content: `Type: ${highlight.tokenType}
Modifiers: ${modifiers.join(", ")}
Highlight group: ${toText(highlight.hlGroup)}`,
            highlights: highlights2
          }];
          if (!floatFactory3) {
            floatFactory3 = window_default.createFloatFactory({
              title: "Semantic token info",
              highlight: "Normal",
              borderhighlight: "MoreMsg",
              border: [1, 1, 1, 1]
            });
          }
          await floatFactory3.show(docs, { winblend: 0 });
        } else {
          this.closeFloat();
        }
      }
      closeFloat() {
        floatFactory3?.close();
      }
      async getCurrentItem() {
        let buf = await this.nvim.buffer;
        return this.getItem(buf.id);
      }
      getItem(bufnr) {
        return this.highlighters.getItem(bufnr);
      }
      /**
       * Force highlight of current buffer
       */
      async highlightCurrent() {
        let item = await this.getCurrentItem();
        if (!item || !item.enabled) throw new Error(`Unable to perform semantic highlights for current buffer.`);
        await item.forceHighlight();
      }
      /**
       * Show semantic highlight info in temporarily buffer
       */
      async showHighlightInfo() {
        let bufnr = await this.nvim.call("bufnr", ["%"]);
        workspace_default.getAttachedDocument(bufnr);
        let { nvim } = this;
        let item = this.highlighters.getItem(bufnr);
        let hl = new Highlighter();
        nvim.pauseNotification();
        nvim.command(`vs +setl\\ buftype=nofile __coc_semantic_highlights_${bufnr}__`, true);
        nvim.command(`setl bufhidden=wipe noswapfile nobuflisted wrap undolevels=-1`, true);
        nvim.call("bufnr", ["%"], true);
        let res = await nvim.resumeNotification();
        hl.addLine("Semantic highlights info", headGroup);
        hl.addLine("");
        try {
          item.checkState();
          let highlights = item.highlights ?? [];
          hl.addLine("The number of semantic tokens: ");
          hl.addText(String(highlights.length), "Number");
          hl.addLine("");
          hl.addLine("Semantic highlight groups used by current buffer", headGroup);
          hl.addLine("");
          const groups = distinct(highlights.filter((o) => o.hlGroup != null).map(({ hlGroup }) => hlGroup));
          for (const hlGroup of groups) {
            hl.addTexts([{ text: "-", hlGroup: "Comment" }, { text: " " }, { text: hlGroup, hlGroup }]);
          }
          hl.addLine("");
          hl.addLine("Tokens types that current Language Server supported:", headGroup);
          hl.addLine("");
          let doc = workspace_default.getDocument(item.bufnr);
          let legend = languages_default.getLegend(doc.textDocument) ?? languages_default.getLegend(doc.textDocument, true);
          if (legend.tokenTypes.length) {
            for (const t of [...new Set(legend.tokenTypes)]) {
              let text = HLGROUP_PREFIX + "Type" + toHighlightPart(t);
              hl.addTexts([{ text: "-", hlGroup: "Comment" }, { text: " " }, { text, hlGroup: text }]);
            }
            hl.addLine("");
          } else {
            hl.addLine("No token types supported", "Comment");
            hl.addLine("");
          }
        } catch (e) {
          hl.addLine(toErrorText(e));
        }
        nvim.pauseNotification();
        hl.render(nvim.createBuffer(res[0][2]));
        nvim.resumeNotification(true, true);
      }
      dispose() {
        this.highlighters.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/util.ts
function toDocumentation(doc) {
  return {
    content: typeof doc === "string" ? doc : doc.value,
    filetype: isMarkdown(doc) ? "markdown" : "txt"
  };
}
var init_util7 = __esm({
  "src/handler/util.ts"() {
    "use strict";
    init_is();
  }
});

// src/handler/signature.ts
var debounceTime13, Signature;
var init_signature = __esm({
  "src/handler/signature.ts"() {
    "use strict";
    init_events();
    init_languages();
    init_util();
    init_array();
    init_node();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    init_util7();
    debounceTime13 = getConditionValue(100, 10);
    Signature = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.loadConfiguration();
        this.signatureFactory = window_default.createFloatFactory(Object.assign({
          preferTop: this.config.preferAbove,
          autoHide: false,
          modes: ["i", "ic", "s"]
        }, this.config.floatConfig));
        this.disposables.push(this.signatureFactory);
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        events_default.on("CursorMovedI", debounce(this.checkCurosr.bind(this), debounceTime13), null, this.disposables);
        events_default.on(["InsertLeave", "BufEnter"], () => {
          this.tokenSource?.cancel();
        }, null, this.disposables);
        events_default.on("TextChangedI", () => {
          if (this.config.hideOnChange) {
            this.signatureFactory.close();
          }
        }, null, this.disposables);
        events_default.on("TextInsert", async (bufnr, info, character) => {
          if (!this.shouldAutoTrigger(bufnr, character)) return;
          let doc = workspace_default.getDocument(bufnr);
          await this._triggerSignatureHelp(doc, { line: info.lnum - 1, character: info.pre.length }, false);
        }, null, this.disposables);
        events_default.on("PlaceholderJump", async (bufnr, info) => {
          if (workspace_default.env.jumpAutocmd || info.charbefore === "") return;
          await wait(50);
          if (!this.shouldAutoTrigger(bufnr, info.charbefore)) return;
          let doc = workspace_default.getDocument(bufnr);
          await this._triggerSignatureHelp(doc, info.range.start, false);
        }, null, this.disposables);
        window_default.onDidChangeActiveTextEditor(() => {
          this.loadConfiguration();
        }, null, this.disposables);
      }
      shouldAutoTrigger(bufnr, character) {
        if (!this.config.enableTrigger) return false;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached || !languages_default.shouldTriggerSignatureHelp(doc.textDocument, character)) return false;
        return true;
      }
      checkCurosr(bufnr, cursor) {
        let pos = this.lastPosition;
        let floatFactory4 = this.signatureFactory;
        if (!pos || bufnr !== pos.bufnr || floatFactory4.window == null) return;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || cursor[0] != pos.lnum || cursor[1] < pos.col) {
          floatFactory4.close();
          return;
        }
        let line = doc.getline(pos.lnum - 1);
        let text = byteSlice(line, pos.col - 1, cursor[1] - 1);
        if (text.endsWith(")")) return floatFactory4.close();
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("signature")) {
          let doc = window_default.activeTextEditor?.document;
          let config = workspace_default.getConfiguration("signature", doc);
          this.config = {
            target: config.get("target", "float"),
            floatConfig: config.get("floatConfig", {}),
            enableTrigger: config.get("enable", true),
            wait: Math.max(config.get("triggerSignatureWait", 500), 200),
            preferAbove: config.get("preferShownAbove", true),
            hideOnChange: config.get("hideOnTextChange", false)
          };
        }
      }
      async triggerSignatureHelp() {
        let { doc, position } = await this.handler.getCurrentState();
        if (!languages_default.hasProvider("signature" /* Signature */, doc.textDocument)) return false;
        return await this._triggerSignatureHelp(doc, position, true, 0);
      }
      async _triggerSignatureHelp(doc, position, invoke, offset = 0) {
        this.tokenSource?.cancel();
        let tokenSource = this.tokenSource = new import_node4.CancellationTokenSource();
        let token = tokenSource.token;
        token.onCancellationRequested(() => {
          tokenSource.dispose();
          this.tokenSource = void 0;
        });
        let { target } = this.config;
        let timer = this.timer = setTimeout(() => {
          tokenSource.cancel();
        }, this.config.wait);
        await doc.patchChange();
        let signatureHelp = await languages_default.getSignatureHelp(doc.textDocument, position, token, {
          isRetrigger: this.signatureFactory.checkRetrigger(doc.bufnr),
          triggerKind: invoke ? import_node4.SignatureHelpTriggerKind.Invoked : import_node4.SignatureHelpTriggerKind.TriggerCharacter
        });
        clearTimeout(timer);
        if (token.isCancellationRequested) return false;
        if (!signatureHelp || signatureHelp.signatures.length == 0) {
          this.signatureFactory.close();
          return false;
        }
        let { activeSignature, signatures } = signatureHelp;
        if (activeSignature) {
          let [active] = signatures.splice(activeSignature, 1);
          if (active) signatures.unshift(active);
        }
        if (target == "echo") {
          this.echoSignature(signatureHelp);
        } else {
          await this.showSignatureHelp(doc, position, signatureHelp, offset);
        }
        return true;
      }
      async showSignatureHelp(doc, position, signatureHelp, offset) {
        let { signatures, activeParameter } = signatureHelp;
        activeParameter = typeof activeParameter === "number" ? activeParameter : void 0;
        let paramDoc = null;
        let startOffset = offset;
        let docs = signatures.reduce((p, c, idx) => {
          let activeIndexes = null;
          let activeIndex = c.activeParameter ?? activeParameter;
          if (activeIndex === void 0 && !isFalsyOrEmpty(c.parameters)) {
            activeIndex = 0;
          }
          let nameIndex = c.label.indexOf("(");
          if (idx == 0 && typeof activeIndex === "number") {
            let active = c.parameters?.[activeIndex];
            if (active) {
              let after = c.label.slice(nameIndex == -1 ? 0 : nameIndex);
              paramDoc = active.documentation;
              if (typeof active.label === "string") {
                let str = after.slice(0);
                let ms = str.match(new RegExp("\\b" + active.label.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b"));
                let index = ms ? ms.index : str.indexOf(active.label);
                if (index != -1) {
                  activeIndexes = [
                    index + nameIndex,
                    index + active.label.length + nameIndex
                  ];
                }
              } else {
                activeIndexes = active.label;
              }
            }
          }
          if (activeIndexes == null) {
            activeIndexes = [nameIndex + 1, nameIndex + 1];
          }
          if (offset == startOffset) {
            offset = offset + activeIndexes[0] + 1;
          }
          p.push({
            content: c.label,
            filetype: doc.filetype,
            active: activeIndexes
          });
          if (paramDoc) {
            p.push(toDocumentation(paramDoc));
          }
          if (idx == 0 && c.documentation) {
            p.push(toDocumentation(c.documentation));
          }
          return p;
        }, []);
        let content = doc.getline(position.line, false).slice(0, position.character);
        this.lastPosition = { bufnr: doc.bufnr, lnum: position.line + 1, col: byteLength(content) + 1 };
        await this.signatureFactory.show(docs, { offsetX: offset });
      }
      echoSignature(signatureHelp) {
        let { signatures, activeParameter } = signatureHelp;
        let columns = workspace_default.env.columns;
        signatures = signatures.slice(0, workspace_default.env.cmdheight);
        let signatureList = [];
        for (let signature of signatures) {
          let parts = [];
          let { label } = signature;
          label = label.replace(/\n/g, " ");
          if (label.length >= columns - 16) {
            label = label.slice(0, columns - 16) + "...";
          }
          let nameIndex = label.indexOf("(");
          if (nameIndex == -1) {
            parts = [{ text: label, type: "Normal" }];
          } else {
            parts.push({
              text: label.slice(0, nameIndex),
              type: "Label"
            });
            let after = label.slice(nameIndex);
            if (signatureList.length == 0 && activeParameter != null) {
              let active = signature.parameters?.[activeParameter];
              if (active) {
                let start;
                let end;
                if (typeof active.label === "string") {
                  let str = after.slice(0);
                  let ms = str.match(new RegExp("\\b" + active.label.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b"));
                  let idx = ms ? ms.index : str.indexOf(active.label);
                  if (idx == -1) {
                    parts.push({ text: after, type: "Normal" });
                  } else {
                    start = idx;
                    end = idx + active.label.length;
                  }
                } else {
                  [start, end] = active.label;
                  start = start - nameIndex;
                  end = end - nameIndex;
                }
                if (start != null && end != null) {
                  parts.push({ text: after.slice(0, start), type: "Normal" });
                  parts.push({ text: after.slice(start, end), type: "MoreMsg" });
                  parts.push({ text: after.slice(end), type: "Normal" });
                }
              }
            } else {
              parts.push({
                text: after,
                type: "Normal"
              });
            }
          }
          signatureList.push(parts);
        }
        this.nvim.callTimer("coc#ui#echo_signatures", [signatureList], true);
      }
      dispose() {
        disposeAll(this.disposables);
        if (this.timer) {
          clearTimeout(this.timer);
        }
      }
    };
  }
});

// src/handler/symbols/buffer.ts
var logger56, DEBEBOUNCE_INTERVAL, SymbolsBuffer;
var init_buffer7 = __esm({
  "src/handler/symbols/buffer.ts"() {
    "use strict";
    init_languages();
    init_logger();
    init_util();
    init_errors();
    init_node();
    init_protocol();
    logger56 = createLogger("symbols-buffer");
    DEBEBOUNCE_INTERVAL = getConditionValue(500, 10);
    SymbolsBuffer = class {
      constructor(doc, autoUpdateBufnrs) {
        this.doc = doc;
        this.autoUpdateBufnrs = autoUpdateBufnrs;
        this.disposables = [];
        this._onDidUpdate = new import_node4.Emitter();
        this.onDidUpdate = this._onDidUpdate.event;
        this.fetchSymbols = debounce(() => {
          this._fetchSymbols().catch(onUnexpectedError);
        }, DEBEBOUNCE_INTERVAL);
      }
      /**
       * Enable autoUpdate when invoked.
       */
      async getSymbols() {
        let { doc } = this;
        await doc.patchChange();
        this.autoUpdateBufnrs.add(doc.bufnr);
        if (doc.version == this.version && this.symbols?.length) return this.symbols;
        this.cancel();
        await this._fetchSymbols();
        return this.symbols;
      }
      onChange(e) {
        if (e.contentChanges.length === 0) return;
        this.cancel();
        if (this.autoUpdateBufnrs.has(this.doc.bufnr)) {
          this.fetchSymbols();
        }
      }
      async _fetchSymbols() {
        let { textDocument } = this.doc;
        let { version: version2 } = textDocument;
        let tokenSource = this.tokenSource = new import_node4.CancellationTokenSource();
        let { token } = tokenSource;
        let symbols = await languages_default.getDocumentSymbol(textDocument, token);
        this.tokenSource = void 0;
        if (symbols == null || token.isCancellationRequested) return;
        this.version = version2;
        this.symbols = symbols;
        this._onDidUpdate.fire(symbols);
      }
      cancel() {
        this.fetchSymbols.clear();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource.dispose();
          this.tokenSource = null;
        }
      }
      dispose() {
        this.cancel();
        this.symbols = void 0;
        this._onDidUpdate.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/tree/BasicDataProvider.ts
function isIcon(obj) {
  if (!obj) return false;
  return typeof obj.text === "string" && typeof obj.hlGroup === "string";
}
function sameTreeNode(one, two) {
  if (one.label === two.label && one.deprecated === two.deprecated && one.key === two.key) {
    return true;
  }
  return false;
}
function sameTreeNodes(one, two) {
  if (one.length !== two.length) return false;
  return one.every((v, idx) => sameTreeNode(v, two[idx]));
}
var BasicDataProvider;
var init_BasicDataProvider = __esm({
  "src/tree/BasicDataProvider.ts"() {
    "use strict";
    init_esm_node();
    init_protocol();
    init_commands();
    init_util();
    init_TreeItem();
    init_array();
    BasicDataProvider = class {
      // data is shared with TreeView
      constructor(opts) {
        this.opts = opts;
        this.disposables = [];
        // only fired for change of exists TreeNode
        this._onDidChangeTreeData = new import_node4.Emitter();
        this.onDidChangeTreeData = this._onDidChangeTreeData.event;
        this.invokeCommand = `_invoke_${v4_default()}`;
        this.disposables.push(commands_default.registerCommand(this.invokeCommand, async (node) => {
          await opts.handleClick(node);
        }, null, true));
        if (typeof opts.resolveActions === "function") {
          this.resolveActions = opts.resolveActions.bind(this);
        }
      }
      iterate(node, parentNode, level2, fn) {
        let res = fn(node, parentNode, level2);
        if (res === false) return false;
        if (Array.isArray(node.children)) {
          for (let element of node.children) {
            let res2 = this.iterate(element, node, level2 + 1, fn);
            if (res2 === false) return false;
          }
        }
        return res;
      }
      /**
       * Change old array to new nodes in place, keep old reference when possible.
       */
      updateNodes(old, data, parentNode, fireEvent = true) {
        let sameNodes = sameTreeNodes(old, data);
        const applyNode = (previous, curr, fireEvent2) => {
          let changed = false;
          for (let key of Object.keys(curr)) {
            if (["children", "key"].includes(key)) continue;
            previous[key] = curr[key];
          }
          if (previous.children?.length && !curr.children?.length) {
            delete previous.children;
            changed = true;
          }
          if (!previous.children?.length && curr.children?.length) {
            previous.children = curr.children;
            changed = true;
          }
          if (changed) {
            if (fireEvent2) this._onDidChangeTreeData.fire(previous);
            return;
          }
          if (toArray(previous.children).length > 0 && toArray(curr.children).length > 0) {
            this.updateNodes(previous.children, curr.children, previous, fireEvent2);
          }
        };
        if (sameNodes) {
          for (let i = 0; i < old.length; i++) {
            applyNode(old[i], data[i], fireEvent);
          }
        } else {
          let oldNodes = old.splice(0, old.length);
          let used = /* @__PURE__ */ new Set();
          for (let i = 0; i < data.length; i++) {
            let curr = data[i];
            let findIndex;
            if (curr.key) {
              findIndex = oldNodes.findIndex((o, i2) => !used.has(i2) && o.key == curr.key);
            } else {
              findIndex = oldNodes.findIndex((o, i2) => !used.has(i2) && o.label == curr.label);
            }
            if (findIndex === -1) {
              old[i] = curr;
            } else {
              used.add(findIndex);
              let previous = oldNodes[findIndex];
              applyNode(previous, curr, false);
              old[i] = previous;
            }
          }
          if (fireEvent) {
            this._onDidChangeTreeData.fire(parentNode);
          }
        }
      }
      /**
       * Update with new data, fires change event when necessary.
       */
      update(data, reset) {
        if (!this.data) return;
        if (reset) {
          this.data = toArray(data);
          this._onDidChangeTreeData.fire(void 0);
        } else {
          this.updateNodes(this.data, toArray(data), void 0);
        }
        return this.data;
      }
      getTreeItem(node) {
        let label = node.label;
        let { expandLevel } = this.opts;
        let item;
        if (!node.children?.length) {
          item = new TreeItem(label);
        } else {
          if (expandLevel && expandLevel > 0) {
            let level2 = this.getLevel(node);
            let state = level2 && level2 <= expandLevel ? 2 /* Expanded */ : 1 /* Collapsed */;
            item = new TreeItem(label, state);
          } else {
            item = new TreeItem(label, 1 /* Collapsed */);
          }
        }
        item.description = node.description;
        if (node.deprecated) item.deprecated = true;
        if (node.tooltip) item.tooltip = node.tooltip;
        if (isIcon(node.icon)) {
          item.icon = node.icon;
        } else if (typeof this.opts.resolveIcon === "function") {
          let res = this.opts.resolveIcon(node);
          if (res && isIcon(res)) item.icon = res;
        }
        return item;
      }
      async getChildren(element) {
        if (element) return element.children ?? [];
        if (this.data) return this.data;
        let data = await Promise.resolve(this.opts.provideData());
        if (!Array.isArray(data)) throw new Error(`Unable to fetch data`);
        this.data = data;
        return data;
      }
      /**
       * Use reference check
       */
      getParent(element) {
        if (!this.data) return void 0;
        let find;
        for (let item of this.data) {
          let res = this.iterate(item, null, 0, (node, parentNode) => {
            if (node === element) {
              find = parentNode;
              return false;
            }
          });
          if (res === false) break;
        }
        return find;
      }
      getLevel(element) {
        if (!this.data) return 0;
        let level2 = 0;
        for (let item of toArray(this.data)) {
          let res = this.iterate(item, null, 1, (node, _parentNode, l) => {
            if (node === element) {
              level2 = l;
              return false;
            }
          });
          if (res === false) break;
        }
        return level2;
      }
      /**
       * Resolve command and tooltip
       */
      async resolveTreeItem(item, element, token) {
        if (typeof this.opts.resolveItem === "function") {
          let res = await Promise.resolve(this.opts.resolveItem(item, element, token));
          if (res) Object.assign(item, res);
        }
        if (!item.command) {
          item.command = {
            title: `invoke ${element.label}`,
            command: this.invokeCommand,
            arguments: [element]
          };
        }
        return item;
      }
      dispose() {
        this.data = [];
        this._onDidChangeTreeData.dispose();
        if (typeof this.opts.onDispose === "function") {
          this.opts.onDispose();
        }
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/symbols/outline.ts
function getNodeByPosition(position, nodes) {
  let curr;
  let checkNodes = (nodes2) => {
    for (let node of nodes2) {
      if (positionInRange(position, node.range) == 0) {
        curr = node;
        if (Array.isArray(node.children)) {
          checkNodes(node.children);
        }
        break;
      }
    }
  };
  checkNodes(nodes);
  return curr;
}
var hoverTimeout, SymbolsOutline;
var init_outline2 = __esm({
  "src/handler/symbols/outline.ts"() {
    "use strict";
    init_main();
    init_events();
    init_languages();
    init_BasicDataProvider();
    init_TreeView();
    init_util();
    init_position();
    init_window();
    init_workspace();
    hoverTimeout = getConditionValue(300, 10);
    SymbolsOutline = class {
      constructor(nvim, buffers, handler) {
        this.nvim = nvim;
        this.buffers = buffers;
        this.handler = handler;
        this.treeViewList = [];
        this.providersMap = /* @__PURE__ */ new Map();
        this.sortByMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        workspace_default.onDidCloseTextDocument(async (e) => {
          let { bufnr } = e;
          let provider = this.providersMap.get(bufnr);
          if (!provider) return;
          let loaded = await nvim.call("bufloaded", [bufnr]);
          if (loaded) return;
          this.providersMap.delete(bufnr);
          provider.dispose();
        }, null, this.disposables);
        window_default.onDidChangeActiveTextEditor(async (editor) => {
          if (!this.config.checkBufferSwitch) return;
          let view = this.treeViewList.find((v) => v.visible && v.targetTabId == editor.tabpageid);
          if (view) {
            await this.showOutline(editor.document.bufnr, editor.tabpageid);
            await nvim.command(`noa call win_gotoid(${editor.winid})`);
          }
        }, null, this.disposables);
        events_default.on("CursorHold", async (bufnr, cursor) => {
          if (!this.config.followCursor) return;
          let provider = this.providersMap.get(bufnr);
          if (!provider) return;
          let tabpage = await nvim.tabpage;
          let view = this.treeViewList.find((o) => o.visible && o.targetBufnr == bufnr && o.targetTabId == tabpage.id);
          if (!view) return;
          await this.revealPosition(bufnr, view, Position.create(cursor[0] - 1, cursor[1] - 1));
        }, null, this.disposables);
      }
      async revealPosition(bufnr, treeView, position) {
        let provider = this.providersMap.get(bufnr);
        let nodes = await Promise.resolve(provider.getChildren());
        let curr = getNodeByPosition(position, nodes);
        if (curr) await treeView.reveal(curr);
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("outline")) {
          let c = workspace_default.getConfiguration("outline", null);
          this.config = {
            splitCommand: c.get("splitCommand"),
            switchSortKey: c.get("switchSortKey"),
            togglePreviewKey: c.get("togglePreviewKey"),
            followCursor: c.get("followCursor"),
            keepWindow: c.get("keepWindow"),
            expandLevel: c.get("expandLevel"),
            autoWidth: c.get("autoWidth"),
            checkBufferSwitch: c.get("checkBufferSwitch"),
            detailAsDescription: c.get("detailAsDescription"),
            sortBy: c.get("sortBy"),
            showLineNumber: c.get("showLineNumber"),
            codeActionKinds: c.get("codeActionKinds"),
            autoHide: c.get("autoHide"),
            autoPreview: c.get("autoPreview"),
            previewMaxWidth: c.get("previewMaxWidth"),
            previewBorder: c.get("previewBorder"),
            previewBorderRounded: c.get("previewBorderRounded"),
            previewHighlightGroup: c.get("previewHighlightGroup"),
            previewBorderHighlightGroup: c.get("previewBorderHighlightGroup"),
            previewWinblend: c.get("previewWinblend")
          };
        }
      }
      convertSymbolToNode(documentSymbol, sortFn) {
        let descs = [];
        let { detailAsDescription, showLineNumber } = this.config;
        if (detailAsDescription && documentSymbol.detail) descs.push(documentSymbol.detail);
        if (showLineNumber) descs.push(`${documentSymbol.selectionRange.start.line + 1}`);
        return {
          label: documentSymbol.name,
          tooltip: detailAsDescription ? void 0 : documentSymbol.detail,
          description: descs.join(" "),
          icon: this.handler.getIcon(documentSymbol.kind),
          deprecated: documentSymbol.tags?.includes(SymbolTag.Deprecated),
          kind: documentSymbol.kind,
          range: documentSymbol.range,
          selectRange: documentSymbol.selectionRange,
          children: Array.isArray(documentSymbol.children) ? documentSymbol.children.map((o) => {
            return this.convertSymbolToNode(o, sortFn);
          }).sort(sortFn) : void 0
        };
      }
      setMessage(bufnr, msg) {
        this.treeViewList.forEach((v) => {
          if (v.valid && v.targetBufnr == bufnr) {
            v.message = msg;
          }
        });
      }
      convertSymbols(bufnr, symbols) {
        let sortBy = this.getSortBy(bufnr);
        let sortFn = (a, b) => {
          if (sortBy === "name") {
            return a.label < b.label ? -1 : 1;
          }
          if (sortBy === "category") {
            if (a.kind == b.kind) return a.label < b.label ? -1 : 1;
            return a.kind - b.kind;
          }
          return comparePosition(a.selectRange.start, b.selectRange.start);
        };
        return symbols.map((s) => this.convertSymbolToNode(s, sortFn)).sort(sortFn);
      }
      onSymbolsUpdate(bufnr, symbols) {
        let provider = this.providersMap.get(bufnr);
        if (provider) provider.update(this.convertSymbols(bufnr, symbols));
      }
      createProvider(bufnr) {
        let { nvim } = this;
        let provider = new BasicDataProvider({
          expandLevel: this.config.expandLevel,
          provideData: async () => {
            let buf = this.buffers.getItem(bufnr);
            if (!buf) throw new Error("Document not attached");
            let doc = workspace_default.getDocument(bufnr);
            if (!languages_default.hasProvider("documentSymbol" /* DocumentSymbol */, doc.textDocument)) {
              throw new Error("Document symbol provider not found");
            }
            let meta = languages_default.getDocumentSymbolMetadata(doc.textDocument);
            if (meta && meta.label) {
              let views = this.treeViewList.filter((v) => v.valid && v.targetBufnr == bufnr);
              views.forEach((view) => view.description = meta.label);
            }
            this.setMessage(bufnr, "Loading document symbols");
            let arr = await buf.getSymbols();
            if (!arr || arr.length == 0) {
              throw new Error("Empty symbols returned from language server. ");
            }
            this.setMessage(bufnr, void 0);
            return this.convertSymbols(bufnr, arr);
          },
          handleClick: async (item) => {
            let winnr = await nvim.call("bufwinnr", [bufnr]);
            if (winnr == -1) return;
            nvim.pauseNotification();
            nvim.command(`${winnr}wincmd w`, true);
            let pos = item.selectRange.start;
            nvim.call("coc#cursor#move_to", [pos.line, pos.character], true);
            nvim.command(`normal! zz`, true);
            let buf = nvim.createBuffer(bufnr);
            buf.highlightRanges("outline-hover", "CocHoverRange", [item.selectRange]);
            nvim.command("redraw", true);
            await nvim.resumeNotification();
            setTimeout(() => {
              buf.clearNamespace("outline-hover");
              nvim.command("redraw", true);
            }, hoverTimeout);
            if (this.config.autoHide) {
              await this.hide();
            }
          },
          resolveActions: async (_, element) => {
            let winnr = await nvim.call("bufwinnr", [bufnr]);
            if (winnr == -1) return;
            let doc = workspace_default.getDocument(bufnr);
            let actions = await this.handler.getCodeActions(doc, element.range, this.config.codeActionKinds);
            let arr = actions.map((o) => {
              return {
                title: o.title,
                handler: async () => {
                  let position = element.range.start;
                  await nvim.command(`${winnr}wincmd w`);
                  await this.nvim.call("coc#cursor#move_to", [position.line, position.character]);
                  await this.handler.applyCodeAction(o);
                }
              };
            });
            return [...arr, {
              title: "Visual Select",
              handler: async (item) => {
                await nvim.command(`${winnr}wincmd w`);
                await window_default.selectRange(item.range);
              }
            }];
          },
          onDispose: () => {
            for (let view of this.treeViewList.slice()) {
              if (view.provider === provider) {
                view.dispose();
              }
            }
          }
        });
        return provider;
      }
      getSortBy(bufnr) {
        return this.sortByMap.get(bufnr) ?? this.config.sortBy;
      }
      async showOutline(bufnr, tabId) {
        if (!this.providersMap.has(bufnr)) {
          this.providersMap.set(bufnr, this.createProvider(bufnr));
        }
        let treeView = this.treeViewList.find((v) => v.valid && v.targetBufnr == bufnr && v.targetTabId == tabId);
        if (!treeView) {
          let { switchSortKey, togglePreviewKey } = this.config;
          let autoPreview = this.config.autoPreview;
          let previewBufnr;
          treeView = new BasicTreeView("OUTLINE", {
            autoWidth: this.config.autoWidth,
            bufhidden: "hide",
            enableFilter: true,
            treeDataProvider: this.providersMap.get(bufnr)
          });
          let sortBy = this.getSortBy(bufnr);
          let prev;
          treeView.description = `${sortBy[0].toUpperCase()}${sortBy.slice(1)}`;
          this.treeViewList.push(treeView);
          let disposable = events_default.on("BufEnter", (bufnr2) => {
            if (previewBufnr && bufnr2 !== previewBufnr) {
              prev = void 0;
              this.closePreview();
            }
          });
          treeView.onDispose(() => {
            let idx = this.treeViewList.findIndex((v) => v === treeView);
            if (idx !== -1) this.treeViewList.splice(idx, 1);
            disposable.dispose();
            this.closePreview();
          });
          treeView.onDidChangeVisibility((visible) => {
            if (this.nvim.isVim && visible && previewBufnr) {
              prev = void 0;
              this.closePreview();
            }
          });
          treeView.onDidCursorMoved(async (node) => {
            if (autoPreview && prev !== node) {
              prev = node;
              previewBufnr = await this.doPreview(bufnr, node);
            }
          });
          treeView.registerLocalKeymap("n", switchSortKey, async () => {
            let arr = ["category", "name", "position"];
            let curr = this.getSortBy(bufnr);
            let items = arr.map((s) => {
              return { text: s, disabled: s === curr };
            });
            let res = await window_default.showMenuPicker(items, { title: "Choose sort method" });
            if (res < 0) return;
            let sortBy2 = arr[res];
            this.sortByMap.set(bufnr, sortBy2);
            let views = this.treeViewList.filter((o) => o.targetBufnr == bufnr);
            views.forEach((view) => {
              view.description = `${sortBy2[0].toUpperCase()}${sortBy2.slice(1)}`;
            });
            let item = this.buffers.getItem(bufnr);
            this.onSymbolsUpdate(bufnr, item.symbols);
          }, true);
          treeView.registerLocalKeymap("n", togglePreviewKey, async (node) => {
            autoPreview = !autoPreview;
            if (!autoPreview) {
              prev = void 0;
              this.closePreview();
            } else {
              previewBufnr = await this.doPreview(bufnr, node);
            }
          }, true);
        }
        await treeView.show(this.config.splitCommand, false);
        return treeView;
      }
      async doPreview(bufnr, node) {
        if (!node) {
          this.closePreview();
          return;
        }
        let config = {
          bufnr,
          range: node.range,
          border: this.config.previewBorder,
          rounded: this.config.previewBorderRounded,
          maxWidth: this.config.previewMaxWidth,
          highlight: this.config.previewHighlightGroup,
          borderhighlight: this.config.previewBorderHighlightGroup,
          winblend: this.config.previewWinblend
        };
        return await this.nvim.call("coc#ui#outline_preview", [config]);
      }
      closePreview() {
        this.nvim.call("coc#ui#outline_close_preview", [], true);
      }
      /**
       * Create outline view.
       */
      async show(keep) {
        let [bufnr, winid] = await this.nvim.eval('[bufnr("%"),win_getid()]');
        let tabpage = await this.nvim.tabpage;
        let doc = workspace_default.getDocument(bufnr);
        if (doc && !doc.attached) {
          void window_default.showErrorMessage(`Unable to show outline, ${doc.notAttachReason}`);
          return;
        }
        let position = await window_default.getCursorPosition();
        let treeView = await this.showOutline(bufnr, tabpage.id);
        if (keep == 1 || keep === void 0 && this.config.keepWindow) {
          await this.nvim.command(`noa call win_gotoid(${winid})`);
        } else if (this.config.followCursor) {
          let disposable = treeView.onDidRefrash(async () => {
            disposable.dispose();
            let curr = await this.nvim.eval('bufnr("%")');
            if (curr == bufnr && treeView.visible) {
              await this.revealPosition(bufnr, treeView, position);
            }
          });
        }
      }
      has(bufnr) {
        return this.providersMap.has(bufnr);
      }
      /**
       * Hide outline of current tab.
       */
      async hide() {
        let winid = await this.nvim.call("coc#window#find", ["cocViewId", "OUTLINE"]);
        if (winid == -1) return;
        await this.nvim.call("coc#window#close", [winid]);
      }
      dispose() {
        for (let view of this.treeViewList) {
          view.dispose();
        }
        this.treeViewList = [];
        for (let provider of this.providersMap.values()) {
          provider.dispose();
        }
        this.providersMap.clear();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/symbols/util.ts
function convertSymbols(symbols) {
  let res = [];
  let arr = symbols.slice();
  arr.sort(sortDocumentSymbols);
  arr.forEach((s) => addDocumentSymbol(res, s, 0));
  return res;
}
function sortDocumentSymbols(a, b) {
  let ra = a.selectionRange;
  let rb = b.selectionRange;
  return comparePosition(ra.start, rb.start);
}
function addDocumentSymbol(res, sym, level2) {
  let { name: name2, selectionRange, detail, kind, children, range, tags } = sym;
  let { start } = defaultValue(selectionRange, range);
  let obj = {
    col: start.character + 1,
    lnum: start.line + 1,
    text: name2,
    level: level2,
    kind: getSymbolKind(kind),
    range,
    selectionRange
  };
  if (detail) obj.detail = detail;
  if (tags && tags.includes(SymbolTag.Deprecated)) obj.deprecated = true;
  res.push(obj);
  if (children && children.length) {
    children.sort(sortDocumentSymbols);
    for (let sym2 of children) {
      addDocumentSymbol(res, sym2, level2 + 1);
    }
  }
}
var init_util8 = __esm({
  "src/handler/symbols/util.ts"() {
    "use strict";
    init_main();
    init_util();
    init_convert();
    init_position();
  }
});

// src/handler/symbols/index.ts
var Symbols2;
var init_symbols2 = __esm({
  "src/handler/symbols/index.ts"() {
    "use strict";
    init_main();
    init_events();
    init_languages();
    init_util();
    init_node();
    init_object();
    init_position();
    init_protocol();
    init_string();
    init_window();
    init_workspace();
    init_buffer7();
    init_outline2();
    init_util8();
    Symbols2 = class {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.autoUpdateBufnrs = /* @__PURE__ */ new Set();
        this.buffers = workspace_default.registerBufferSync((doc) => {
          let { bufnr } = doc;
          let buf = new SymbolsBuffer(doc, this.autoUpdateBufnrs);
          buf.onDidUpdate((symbols) => {
            if (!this.outline) return;
            this.outline.onSymbolsUpdate(bufnr, symbols);
          });
          return buf;
        });
        this.outline = new SymbolsOutline(nvim, this.buffers, handler);
        const debounceTime14 = workspace_default.initialConfiguration.get("coc.preferences.currentFunctionSymbolDebounceTime", 300);
        let prev = "";
        let debounced = debounce(async (bufnr, cursor) => {
          if (!this.buffers.getItem(bufnr) || !this.autoUpdate(bufnr)) return;
          let doc = workspace_default.getDocument(bufnr);
          let character = characterIndex(doc.getline(cursor[0] - 1), cursor[1] - 1);
          let pos = Position.create(cursor[0] - 1, character);
          let func2 = await this.getFunctionSymbol(bufnr, pos);
          let buffer = nvim.createBuffer(bufnr);
          if (func2 != prev) {
            prev = func2;
            buffer.setVar("coc_current_function", func2, true);
            this.nvim.callTimer("coc#util#do_autocmd", ["CocStatusChange"], true);
          }
        }, getConditionValue(debounceTime14, 0));
        events_default.on("CursorMoved", debounced, this, this.disposables);
        this.disposables.push(import_node4.Disposable.create(() => {
          debounced.clear();
        }));
        events_default.on("InsertEnter", (bufnr) => {
          debounced.clear();
          let buf = this.buffers.getItem(bufnr);
          if (buf) buf.cancel();
        }, null, this.disposables);
      }
      autoUpdate(bufnr) {
        let doc = workspace_default.getDocument(bufnr);
        let config = workspace_default.getConfiguration("coc.preferences", doc);
        return config.get("currentFunctionSymbolAutoUpdate", false);
      }
      get labels() {
        return workspace_default.getConfiguration("suggest").get("completionItemKindLabels", {});
      }
      async getWorkspaceSymbols(input) {
        this.handler.checkProvider("workspaceSymbols" /* WorkspaceSymbols */, null);
        let tokenSource = new import_node4.CancellationTokenSource();
        return await languages_default.getWorkspaceSymbols(input, tokenSource.token);
      }
      async resolveWorkspaceSymbol(symbolInfo) {
        if (symbolInfo.location?.uri) return symbolInfo;
        let tokenSource = new import_node4.CancellationTokenSource();
        return await languages_default.resolveWorkspaceSymbol(symbolInfo, tokenSource.token);
      }
      async getDocumentSymbols(bufnr) {
        if (!bufnr) {
          bufnr = await this.nvim.call("bufnr", ["%"]);
          let doc = workspace_default.getDocument(bufnr);
          if (!doc || !doc.attached) return void 0;
        }
        let buf = this.buffers.getItem(bufnr);
        if (!buf) return;
        let res = await buf.getSymbols();
        return res ? convertSymbols(res) : void 0;
      }
      async getFunctionSymbol(bufnr, position) {
        let symbols = await this.getDocumentSymbols(bufnr);
        if (!symbols || symbols.length === 0) return "";
        symbols = symbols.filter((s) => [
          "Class",
          "Method",
          "Function",
          "Struct"
        ].includes(s.kind));
        let functionName = "";
        let labels = this.labels;
        for (let sym of symbols.reverse()) {
          if (sym.range && positionInRange(position, sym.range) == 0 && !sym.text.endsWith(") callback")) {
            functionName = sym.text;
            let label = labels[sym.kind.toLowerCase()];
            if (label) functionName = `${label} ${functionName}`;
            break;
          }
        }
        return functionName;
      }
      async getCurrentFunctionSymbol() {
        let bufnr = await this.nvim.call("bufnr", ["%"]);
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached || !languages_default.hasProvider("documentSymbol" /* DocumentSymbol */, doc.textDocument)) return;
        let position = await window_default.getCursorPosition();
        return await this.getFunctionSymbol(bufnr, position);
      }
      /*
       * supportedSymbols must be string values of symbolKind
       */
      async selectSymbolRange(inner, visualmode, supportedSymbols) {
        let { doc } = await this.handler.getCurrentState();
        this.handler.checkProvider("documentSymbol" /* DocumentSymbol */, doc.textDocument);
        let range;
        if (visualmode) {
          range = await window_default.getSelectedRange(visualmode);
        } else {
          let pos = await window_default.getCursorPosition();
          range = Range.create(pos, pos);
        }
        let symbols = await this.getDocumentSymbols(doc.bufnr);
        if (!symbols || symbols.length === 0) {
          void window_default.showWarningMessage("No symbols found");
          return;
        }
        symbols = symbols.filter((s) => supportedSymbols.includes(s.kind));
        let selectRange2;
        for (let sym of symbols.reverse()) {
          if (sym.range && !equals(sym.range, range) && rangeInRange(range, sym.range)) {
            selectRange2 = sym.range;
            break;
          }
        }
        if (inner && selectRange2) {
          let { start, end } = selectRange2;
          let line = doc.getline(start.line + 1);
          let endDelta = doc.filetype === "python" ? 0 : 1;
          let endLine = doc.getline(end.line - endDelta);
          selectRange2 = Range.create(start.line + 1, line.match(/^\s*/)[0].length, end.line - endDelta, endLine.length);
        }
        if (selectRange2) {
          await window_default.selectRange(selectRange2);
        } else if (["v", "V", ""].includes(visualmode)) {
          await this.nvim.command("normal! gv");
        }
      }
      async showOutline(keep) {
        await this.outline.show(keep);
      }
      async hideOutline() {
        await this.outline.hide();
      }
      hasOutline(bufnr) {
        return this.outline.has(bufnr);
      }
      dispose() {
        this.outline.dispose();
        this.buffers.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/typeHierarchy.ts
function toTypeHierarchyItem(item) {
  return omit(item, ["children", "parent"]);
}
function getTitle2(kind) {
  return kind === "supertypes" ? "Super types" : "Sub types";
}
var TypeHierarchyHandler;
var init_typeHierarchy2 = __esm({
  "src/handler/typeHierarchy.ts"() {
    "use strict";
    init_commands();
    init_events();
    init_languages();
    init_LocationsDataProvider();
    init_TreeView();
    init_util();
    init_array();
    init_lodash();
    init_window();
    init_workspace();
    TypeHierarchyHandler = class _TypeHierarchyHandler {
      constructor(nvim, handler) {
        this.nvim = nvim;
        this.handler = handler;
        this.disposables = [];
        this.highlightWinids = /* @__PURE__ */ new Set();
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        events_default.on("BufWinEnter", (_, winid) => {
          if (this.highlightWinids.has(winid)) {
            this.highlightWinids.delete(winid);
            let win = nvim.createWindow(winid);
            win.clearMatchGroup(_TypeHierarchyHandler.rangesHighlight);
          }
        }, null, this.disposables);
        this.disposables.push(commands_default.registerCommand(_TypeHierarchyHandler.commandId, async (winid, item, openCommand) => {
          let { nvim: nvim2 } = this;
          await nvim2.call("win_gotoid", [winid]);
          await workspace_default.jumpTo(item.uri, item.range.start, openCommand);
          let win = await nvim2.window;
          win.clearMatchGroup(_TypeHierarchyHandler.rangesHighlight);
          win.highlightRanges(_TypeHierarchyHandler.rangesHighlight, [item.selectionRange], 10, true);
          this.highlightWinids.add(win.id);
        }, null, true));
      }
      static {
        this.rangesHighlight = "CocSelectedRange";
      }
      static {
        this.commandId = "typeHierarchy.reveal";
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("typeHierarchy")) {
          let c = workspace_default.getConfiguration("typeHierarchy", null);
          this.config = {
            splitCommand: c.get("splitCommand"),
            openCommand: c.get("openCommand"),
            enableTooltip: c.get("enableTooltip")
          };
        }
      }
      createProvider(rootItems, winid, kind) {
        let provider = new LocationsDataProvider(
          kind,
          winid,
          this.config,
          _TypeHierarchyHandler.commandId,
          rootItems,
          (kind2) => this.handler.getIcon(kind2),
          (el, meta, token) => this.getChildren(el, meta, token)
        );
        provider.addAction(`Show Super Types`, (el) => {
          provider.meta = "supertypes";
          let rootItems2 = [omit(el, ["children", "parent"])];
          provider.reset(rootItems2);
        });
        provider.addAction(`Show Sub Types`, (el) => {
          provider.meta = "subtypes";
          let rootItems2 = [omit(el, ["children", "parent"])];
          provider.reset(rootItems2);
        });
        return provider;
      }
      async getChildren(item, kind, token) {
        let res = [];
        let typeHierarchyItem = toTypeHierarchyItem(item);
        if (kind == "supertypes") {
          res = await languages_default.provideTypeHierarchySupertypes(typeHierarchyItem, token);
        } else {
          res = await languages_default.provideTypeHierarchySubtypes(typeHierarchyItem, token);
        }
        return res;
      }
      async prepare(doc, position) {
        this.handler.checkProvider("typeHierarchy" /* TypeHierarchy */, doc);
        return await this.handler.withRequestToken("typeHierarchy", async (token) => {
          return await languages_default.prepareTypeHierarchy(doc, position, token);
        }, false);
      }
      async showTypeHierarchyTree(kind) {
        const { doc, position, winid } = await this.handler.getCurrentState();
        await doc.synchronize();
        const rootItems = await this.prepare(doc.textDocument, position);
        if (isFalsyOrEmpty(rootItems)) {
          void window_default.showWarningMessage("Unable to get TypeHierarchyItems at cursor position.");
          return;
        }
        let provider = this.createProvider(rootItems, winid, kind);
        let treeView = new BasicTreeView("TYPES", { treeDataProvider: provider });
        treeView.title = getTitle2(kind);
        provider.onDidChangeTreeData((e) => {
          if (!e) treeView.title = getTitle2(provider.meta);
        });
        treeView.onDidChangeVisibility((e) => {
          if (!e.visible) provider.dispose();
        });
        this.disposables.push(treeView);
        await treeView.show(this.config.splitCommand);
      }
      dispose() {
        this.highlightWinids.clear();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/handler/workspace.ts
var import_v8, WorkspaceHandler;
var init_workspace2 = __esm({
  "src/handler/workspace.ts"() {
    "use strict";
    init_esm_node();
    import_v8 = require("v8");
    init_esm();
    init_commands();
    init_workspaceFolder();
    init_extension();
    init_languages();
    init_logger();
    init_highlighter();
    init_manager4();
    init_util();
    init_constants();
    init_errors();
    init_fs();
    init_is();
    init_node();
    init_string();
    init_window();
    init_workspace();
    WorkspaceHandler = class {
      constructor(nvim) {
        this.nvim = nvim;
        Object.defineProperty(window_default, "openLocalConfig", {
          get: () => this.openLocalConfig.bind(this)
        });
        extension_default.onDidUnloadExtension((name2) => {
          workspace_default.autocmds.removeExtensionAutocmds(name2);
        });
        commands_default.register({
          id: "workspace.openLocation",
          execute: async (winid, loc, openCommand) => {
            await nvim.call("win_gotoid", [winid]);
            await workspace_default.jumpTo(loc.uri, loc.range.start, openCommand);
          }
        }, true);
        commands_default.register({
          id: "workspace.openLocalConfig",
          execute: async () => {
            await this.openLocalConfig();
          }
        }, false, "Open config file of current workspace folder");
        commands_default.register({
          id: "workspace.undo",
          execute: async () => {
            await workspace_default.files.undoWorkspaceEdit();
          }
        }, false, "Undo previous this.workspace edit");
        commands_default.register({
          id: "workspace.redo",
          execute: async () => {
            await workspace_default.files.redoWorkspaceEdit();
          }
        }, false, "Redo previous this.workspace edit");
        commands_default.register({
          id: "workspace.inspectEdit",
          execute: async () => {
            await workspace_default.files.inspectEdit();
          }
        }, false, "Inspect previous this.workspace edit in new tab");
        commands_default.register({
          id: "workspace.renameCurrentFile",
          execute: async () => {
            await this.renameCurrent();
          }
        }, false, "change current filename to a new name and reload it.");
        commands_default.register({
          id: "document.checkBuffer",
          execute: async () => {
            await this.bufferCheck();
          }
        }, false, "Check providers for current buffer.");
        commands_default.register({
          id: "document.echoFiletype",
          execute: async () => {
            let bufnr = await nvim.call("bufnr", "%");
            let doc = workspace_default.getAttachedDocument(bufnr);
            await window_default.echoLines([doc.filetype]);
          }
        }, false, "echo the mapped filetype of the current buffer");
        commands_default.register({
          id: "workspace.workspaceFolders",
          execute: async () => {
            let folders = workspace_default.workspaceFolders;
            let lines = folders.map((folder) => URI2.parse(folder.uri).fsPath);
            await window_default.echoLines(lines);
          }
        }, false, "show opened workspaceFolders.");
        commands_default.register({
          id: "workspace.writeHeapSnapshot",
          execute: async () => {
            let filepath = path.join(os.homedir(), `${v4_default()}-${process.pid}.heapsnapshot`);
            (0, import_v8.writeHeapSnapshot)(filepath);
            void window_default.showInformationMessage(`Create heapdump at: ${filepath}`);
            return filepath;
          }
        }, false, "Generates a snapshot of the current V8 heap and writes it to a JSON file.");
        commands_default.register({
          id: "workspace.showOutput",
          execute: async (name2, cmd) => {
            if (!name2) name2 = await window_default.showQuickPick(workspace_default.channelNames, { title: "Choose output name" });
            window_default.showOutputChannel(toText(name2), cmd);
          }
        }, false, "open output buffer to show output from languageservers or extensions.");
        commands_default.register({
          id: "workspace.clearWatchman",
          execute: async () => {
            let res = await window_default.runTerminalCommand("watchman watch-del-all");
            if (res.success) void window_default.showInformationMessage("Cleared watchman watching directories.");
            return res.success;
          }
        }, false, "run watch-del-all for watchman to free up memory.");
      }
      async openLog() {
        let file = getLoggerFile();
        await workspace_default.jumpTo(URI2.file(file).toString());
      }
      /**
       * Open local config file
       */
      async openLocalConfig() {
        let fsPath2 = await this.nvim.call("coc#util#get_fullpath", []);
        let filetype = await this.nvim.eval("&filetype");
        if (!fsPath2 || !path.isAbsolute(fsPath2)) {
          void window_default.showWarningMessage(`Current buffer doesn't have valid file path.`);
          return;
        }
        let folder = workspace_default.getWorkspaceFolder(URI2.file(fsPath2).toString());
        if (!folder) {
          let c = workspace_default.initialConfiguration.get("workspace");
          let patterns = defaultValue(c.rootPatterns, []);
          let ignored = defaultValue(c.ignoredFiletypes, []);
          let msg;
          if (ignored.includes(filetype)) msg = `Filetype '${filetype}' is ignored for workspace folder resolve.`;
          if (!msg) msg = `Can't resolve workspace folder for file '${fsPath2}, consider create one of ${patterns.join(", ")} in your project root.'.`;
          void window_default.showWarningMessage(msg);
          return;
        }
        let root = URI2.parse(folder.uri).fsPath;
        let dir = path.join(root, ".vim");
        if (!fs.existsSync(dir)) {
          let res = await window_default.showPrompt(`Would you like to create folder'${root}/.vim'?`);
          if (!res) return;
          fs.mkdirSync(dir);
        }
        await workspace_default.jumpTo(URI2.file(path.join(dir, CONFIG_FILE_NAME)));
      }
      async renameCurrent() {
        let { nvim } = this;
        let oldPath = await nvim.call("coc#util#get_fullpath", []);
        let newPath = await nvim.callAsync("coc#util#with_callback", ["input", ["New path: ", oldPath, "file"]]);
        newPath = newPath.trim();
        if (newPath === oldPath || !newPath) return;
        if (oldPath.toLowerCase() != newPath.toLowerCase() && fs.existsSync(newPath)) {
          let overwrite = await window_default.showPrompt(`${newPath} exists, overwrite?`);
          if (!overwrite) return;
        }
        await workspace_default.renameFile(oldPath, newPath, { overwrite: true });
      }
      addWorkspaceFolder(folder) {
        if (!string(folder)) throw TypeError(`folder should be string`);
        folder = workspace_default.expand(folder);
        if (!isDirectory(folder)) throw directoryNotExists(folder);
        workspace_default.workspaceFolderControl.addWorkspaceFolder(folder, true);
      }
      removeWorkspaceFolder(folder) {
        if (!string(folder)) throw TypeError(`folder should be string`);
        folder = workspace_default.expand(folder);
        if (!isDirectory(folder)) throw directoryNotExists(folder);
        workspace_default.workspaceFolderControl.removeWorkspaceFolder(folder);
      }
      async bufferCheck() {
        let doc = await workspace_default.document;
        if (!doc.attached) {
          await window_default.showDialog({
            title: "Buffer check result",
            content: `Document not attached, ${doc.notAttachReason}`,
            highlight: "WarningMsg"
          });
          return;
        }
        let hi = new Highlighter();
        hi.addLine("Provider state", "Title");
        hi.addLine("");
        for (let name2 of Object.values(ProviderName)) {
          if (name2 === "onTypeEdit" /* OnTypeEdit */) continue;
          let exists = languages_default.hasProvider(name2, doc.textDocument);
          hi.addTexts([
            { text: "-", hlGroup: "Comment" },
            { text: " " },
            exists ? { text: "\u2713", hlGroup: "CocListFgGreen" } : { text: "\u2717", hlGroup: "CocListFgRed" },
            { text: " " },
            { text: name2, hlGroup: exists ? "Normal" : "CocFadeOut" }
          ]);
        }
        await window_default.showDialog({
          title: "Buffer check result",
          content: hi.content,
          highlights: hi.highlights
        });
      }
      async doAutocmd(id2, args) {
        let timeout2 = workspace_default.getConfiguration("editor", null).get("timeout", 1e3);
        await workspace_default.autocmds.doAutocmd(id2, args, timeout2);
      }
      async getConfiguration(key) {
        let document2 = await workspace_default.document;
        return workspace_default.getConfiguration(key, document2);
      }
      getRootPatterns(bufnr) {
        let doc = workspace_default.getDocument(bufnr);
        if (!doc) return null;
        return {
          buffer: workspace_default.workspaceFolderControl.getRootPatterns(doc, 0 /* Buffer */),
          server: workspace_default.workspaceFolderControl.getRootPatterns(doc, 1 /* LanguageServer */),
          global: workspace_default.workspaceFolderControl.getRootPatterns(doc, 2 /* Global */)
        };
      }
      async ensureDocument(bufnr) {
        let doc = bufnr ? workspace_default.getDocument(bufnr) : await workspace_default.document;
        return doc && doc.attached;
      }
      async doKeymap(key, defaultReturn = "") {
        return await workspace_default.keymaps.doKeymap(key, defaultReturn);
      }
      async snippetCheck(checkExpand, checkJump) {
        if (checkJump) {
          let jumpable = manager_default3.jumpable();
          if (jumpable) return true;
        }
        if (checkExpand) {
          let expandable = await Promise.resolve(extension_default.manager.call("coc-snippets", "expandable", []));
          if (expandable) return true;
        }
        return false;
      }
      async showInfo() {
        let lines = [];
        let version2 = workspace_default.version + (true ? "-7d5f07f4 2025-05-08 11:26:38 +0800" : "");
        lines.push("## versions");
        lines.push("");
        let out = await this.nvim.call("execute", ["version"]);
        let first = out.trim().split(/\r?\n/, 2)[0].replace(/\(.*\)/, "").trim();
        lines.push("vim version: " + first + `${isVim ? " " + workspace_default.env.version : ""}`);
        lines.push("node version: " + process.version);
        lines.push("coc.nvim version: " + version2);
        lines.push("coc.nvim directory: " + path.dirname(__dirname));
        lines.push("term: " + defaultValue(process.env.TERM_PROGRAM, process.env.TERM));
        lines.push("platform: " + process.platform);
        lines.push("");
        lines.push("## Log of coc.nvim");
        lines.push("");
        let file = getLoggerFile();
        const stripAnsi3 = require_strip_ansi();
        if (fs.existsSync(file)) {
          let content = fs.readFileSync(file, { encoding: "utf8" });
          lines.push(...content.split(/\r?\n/).map((line) => stripAnsi3(line)));
        }
        await this.nvim.command("vnew +setl\\ buftype=nofile\\ bufhidden=wipe\\ nobuflisted");
        let buf = await this.nvim.buffer;
        await buf.setLines(lines, { start: 0, end: -1, strictIndexing: false });
      }
    };
  }
});

// src/handler/index.ts
var logger57, requestTimeout, Handler;
var init_handler = __esm({
  "src/handler/index.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_events();
    init_languages();
    init_logger();
    init_util();
    init_convert();
    init_is();
    init_object();
    init_protocol();
    init_textedit();
    init_window();
    init_workspace();
    init_callHierarchy2();
    init_codeActions();
    init_codelens();
    init_colors();
    init_commands3();
    init_fold();
    init_format2();
    init_highlights2();
    init_hover2();
    init_inlayHint2();
    init_linkedEditing();
    init_links2();
    init_locations();
    init_refactor();
    init_rename2();
    init_selectionRange2();
    init_semanticTokens2();
    init_signature();
    init_symbols2();
    init_typeHierarchy2();
    init_workspace2();
    logger57 = createLogger("Handler");
    requestTimeout = getConditionValue(500, 10);
    Handler = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.disposables = [];
        events_default.on(["CursorMoved", "CursorMovedI", "InsertEnter", "InsertSnippet", "InsertLeave"], () => {
          if (this.requestTokenSource) {
            this.requestTokenSource.cancel();
            this.requestTokenSource = null;
          }
        }, null, this.disposables);
        this.fold = new FoldHandler(nvim, this);
        this.links = new Links(nvim, this);
        this.codeLens = new CodeLensManager2(nvim);
        this.colors = new Colors(nvim, this);
        this.format = new FormatHandler(nvim, this);
        this.symbols = new Symbols2(nvim, this);
        this.refactor = new Refactor(nvim, this);
        this.hover = new HoverHandler(nvim, this);
        this.locations = new LocationsHandler(nvim, this);
        this.signature = new Signature(nvim, this);
        this.rename = new Rename(nvim, this);
        this.workspace = new WorkspaceHandler(nvim);
        this.codeActions = new CodeActions(nvim, this);
        this.commands = new Commands(nvim);
        this.callHierarchy = new CallHierarchyHandler(nvim, this);
        this.typeHierarchy = new TypeHierarchyHandler(nvim, this);
        this.documentHighlighter = new Highlights2(nvim, this);
        this.semanticHighlighter = new SemanticTokens5(nvim);
        this.selectionRange = new SelectionRangeHandler(nvim, this);
        this.linkedEditingHandler = new LinkedEditingHandler(nvim, this);
        this.inlayHintHandler = new InlayHintHandler(nvim, this);
        this.disposables.push({
          dispose: () => {
            this.callHierarchy.dispose();
            this.typeHierarchy.dispose();
            this.codeLens.dispose();
            this.links.dispose();
            this.refactor.dispose();
            this.signature.dispose();
            this.symbols.dispose();
            this.hover.dispose();
            this.colors.dispose();
            this.documentHighlighter.dispose();
            this.semanticHighlighter.dispose();
          }
        });
        this.registerCommands();
      }
      registerCommands() {
        commands_default.register({
          id: "document.renameCurrentWord",
          execute: async () => {
            let doc = await workspace_default.document;
            let edit2 = await this.rename.getWordEdit();
            let ranges = getRangesFromEdit(doc.uri, toObject(edit2));
            if (!ranges) return window_default.showWarningMessage("Invalid position");
            await commands_default.executeCommand("editor.action.addRanges", ranges);
          }
        }, false, "rename word under cursor in current buffer by multiple cursors.");
        commands_default.register({
          id: ["workbench.action.reloadWindow", "editor.action.restart"],
          execute: () => {
            this.nvim.command("CocRestart", true);
          }
        }, true);
        commands_default.register({
          id: "workbench.action.openSettingsJson",
          execute: () => {
            this.nvim.command("CocConfig", true);
          }
        }, true);
        this.register("vscode.open", async (url) => {
          await workspace_default.openResource(url.toString());
        });
        this.register("editor.action.doCodeAction", async (action) => {
          await this.codeActions.applyCodeAction(action);
        });
        this.register("editor.action.triggerParameterHints", async () => {
          await this.signature.triggerSignatureHelp();
        });
        this.register("editor.action.showReferences", async (uri, position, references) => {
          await workspace_default.jumpTo(uri, position);
          await workspace_default.showLocations(references);
        });
        this.register("editor.action.rename", async (uri, position, newName) => {
          if (Array.isArray(uri)) {
            position = uri[1];
            uri = uri[0];
          }
          await workspace_default.jumpTo(uri, position);
          return await this.rename.rename(newName);
        });
        this.register("editor.action.format", async () => {
          await this.format.formatCurrentBuffer();
        });
        this.register("editor.action.showRefactor", async (locations) => {
          let locs = locations.filter((o) => Location.is(o));
          return await this.refactor.fromLocations(locs);
        });
      }
      register(key, handler) {
        this.disposables.push(commands_default.registerCommand(key, handler, null, true));
      }
      get requestStatusItem() {
        if (this._requestStatusItem) return this._requestStatusItem;
        this._requestStatusItem = window_default.createStatusBarItem(0, { progress: true });
        return this._requestStatusItem;
      }
      get labels() {
        let configuration2 = workspace_default.initialConfiguration;
        return configuration2.get("suggest.completionItemKindLabels", {});
      }
      get uri() {
        return window_default.activeTextEditor?.document.uri;
      }
      async getCurrentState() {
        let { nvim } = this;
        let [bufnr, [line, character], winid, mode] = await nvim.eval("[bufnr('%'),coc#cursor#position(),win_getid(),mode()]");
        let doc = workspace_default.getAttachedDocument(bufnr);
        return {
          doc,
          mode,
          position: Position.create(line, character),
          winid
        };
      }
      addDisposable(disposable) {
        this.disposables.push(disposable);
      }
      /**
       * Throw error when provider doesn't exist.
       */
      checkProvider(id2, document2) {
        if (!languages_default.hasProvider(id2, document2)) {
          throw new Error(`${id2} provider not found for current buffer, your language server doesn't support it.`);
        }
      }
      async withRequestToken(name2, fn, checkEmpty) {
        if (this.requestTokenSource) {
          this.requestTokenSource.cancel();
          this.requestTokenSource.dispose();
        }
        clearTimeout(this.requestTimer);
        let statusItem = this.requestStatusItem;
        this.requestTokenSource = new import_node4.CancellationTokenSource();
        let { token } = this.requestTokenSource;
        token.onCancellationRequested(() => {
          statusItem.text = `${name2} request canceled`;
          statusItem.isProgress = false;
          this.requestTimer = setTimeout(() => {
            statusItem.hide();
          }, requestTimeout);
        });
        statusItem.isProgress = true;
        statusItem.text = `requesting ${name2}`;
        statusItem.show();
        let res;
        try {
          res = await Promise.resolve(fn(token));
        } catch (e) {
          logger57.error(`Error on request ${name2}`, e);
          this.nvim.errWriteLine(`Error on ${name2}: ${e}`);
        }
        if (this.requestTokenSource) {
          this.requestTokenSource.dispose();
          this.requestTokenSource = void 0;
        }
        if (token.isCancellationRequested) return null;
        statusItem.hide();
        if (checkEmpty && (!res || Array.isArray(res) && res.length == 0)) {
          void window_default.showWarningMessage(`${name2} not found`);
          return null;
        }
        return res;
      }
      getIcon(kind) {
        let { labels } = this;
        let kindText = getSymbolKind(kind);
        const key = kindText[0].toLowerCase() + kindText.slice(1);
        let text = hasOwnProperty2(labels, key) ? labels[key] : void 0;
        if (!string(text) || !text.length) text = string(labels["default"]) ? labels["default"] : kindText[0].toLowerCase();
        return {
          text,
          hlGroup: kindText == "Unknown" ? "CocSymbolDefault" : `CocSymbol${kindText}`
        };
      }
      async getCodeActions(doc, range, only) {
        let codeActions = await this.codeActions.getCodeActions(doc, range, only);
        return codeActions.filter((o) => !o.disabled);
      }
      async applyCodeAction(action) {
        await this.codeActions.applyCodeAction(action);
      }
      async hasProvider(id2, bufnr) {
        if (!bufnr) bufnr = await this.nvim.call("bufnr", "%");
        let doc = workspace_default.getDocument(bufnr);
        if (!doc || !doc.attached) return false;
        return languages_default.hasProvider(id2, doc.textDocument);
      }
      dispose() {
        if (this.requestTimer) {
          clearTimeout(this.requestTimer);
        }
        disposeAll(this.disposables);
      }
    };
  }
});

// src/plugin.ts
var logger58, Plugin;
var init_plugin = __esm({
  "src/plugin.ts"() {
    "use strict";
    init_main();
    init_commands();
    init_completion2();
    init_sources2();
    init_cursors();
    init_manager();
    init_events();
    init_extension();
    init_handler();
    init_manager3();
    init_logger();
    init_services();
    init_manager4();
    init_util();
    init_window();
    init_workspace();
    logger58 = createLogger("plugin");
    Plugin = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.ready = false;
        this.initialized = false;
        this.actions = /* @__PURE__ */ new Map();
        this.disposables = [];
        Object.defineProperty(window_default, "workspace", {
          get: () => workspace_default
        });
        Object.defineProperty(workspace_default, "nvim", {
          get: () => this.nvim
        });
        Object.defineProperty(window_default, "nvim", {
          get: () => this.nvim
        });
        Object.defineProperty(window_default, "cursors", {
          get: () => this.cursors
        });
        Object.defineProperty(commands_default, "nvim", {
          get: () => this.nvim
        });
        this.cursors = new Cursors(nvim);
        manager_default2.init(nvim);
        this.addAction("checkJsonExtension", () => {
          if (extension_default.has("coc-json")) return;
          void window_default.showInformationMessage(`Run :CocInstall coc-json for json intellisense`);
        });
        this.addAction("rootPatterns", (bufnr) => this.handler.workspace.getRootPatterns(bufnr));
        this.addAction("ensureDocument", (bufnr) => this.handler.workspace.ensureDocument(bufnr));
        this.addAction("addWorkspaceFolder", (folder) => this.handler.workspace.addWorkspaceFolder(folder));
        this.addAction("removeWorkspaceFolder", (folder) => this.handler.workspace.removeWorkspaceFolder(folder));
        this.addAction("getConfig", (key) => this.handler.workspace.getConfiguration(key));
        this.addAction("doAutocmd", (id2, ...args) => this.handler.workspace.doAutocmd(id2, args));
        this.addAction("openLog", () => this.handler.workspace.openLog());
        this.addAction("attach", () => workspace_default.attach());
        this.addAction("detach", () => workspace_default.detach());
        this.addAction("doKeymap", (key, defaultReturn) => this.handler.workspace.doKeymap(key, defaultReturn));
        this.addAction("registerExtensions", (...folders) => extension_default.manager.loadExtension(folders), "registExtensions");
        this.addAction("snippetCheck", (checkExpand, checkJump) => this.handler.workspace.snippetCheck(checkExpand, checkJump));
        this.addAction("snippetInsert", (range, newText, mode, ultisnip) => manager_default3.insertSnippet(newText, true, range, mode, ultisnip));
        this.addAction("snippetNext", () => manager_default3.nextPlaceholder());
        this.addAction("snippetPrev", () => manager_default3.previousPlaceholder());
        this.addAction("snippetCancel", () => manager_default3.cancel());
        this.addAction("openLocalConfig", () => this.handler.workspace.openLocalConfig());
        this.addAction("bufferCheck", () => this.handler.workspace.bufferCheck());
        this.addAction("showInfo", () => this.handler.workspace.showInfo());
        this.addAction("hasProvider", (id2, bufnr) => this.handler.hasProvider(id2, bufnr));
        this.addAction("cursorsSelect", (bufnr, kind, mode) => this.cursors.select(bufnr, kind, mode));
        this.addAction("commandList", () => this.handler.commands.getCommandList());
        this.addAction("selectSymbolRange", (inner, visualmode, supportedSymbols) => this.handler.symbols.selectSymbolRange(inner, visualmode, supportedSymbols));
        this.addAction("openList", (...args) => manager_default2.start(args));
        this.addAction("listNames", () => manager_default2.names);
        this.addAction("listDescriptions", () => manager_default2.descriptions);
        this.addAction("listLoadItems", (name2) => manager_default2.loadItems(name2));
        this.addAction("listResume", (name2) => manager_default2.resume(name2));
        this.addAction("listCancel", () => manager_default2.cancel(true));
        this.addAction("listPrev", (name2) => manager_default2.previous(name2));
        this.addAction("listNext", (name2) => manager_default2.next(name2));
        this.addAction("listFirst", (name2) => manager_default2.first(name2));
        this.addAction("listLast", (name2) => manager_default2.last(name2));
        this.addAction("sendRequest", (id2, method, params) => services_default.sendRequest(id2, method, params));
        this.addAction("sendNotification", (id2, method, params) => services_default.sendNotification(id2, method, params));
        this.addAction("registerNotification", (id2, method) => services_default.registerNotification(id2, method), "registNotification");
        this.addAction("updateConfig", (section2, val) => workspace_default.configurations.updateMemoryConfig({ [section2]: val }));
        this.addAction("links", () => this.handler.links.getLinks());
        this.addAction("openLink", () => this.handler.links.openCurrentLink());
        this.addAction("pickColor", () => this.handler.colors.pickColor());
        this.addAction("colorPresentation", () => this.handler.colors.pickPresentation());
        this.addAction("highlight", () => this.handler.documentHighlighter.highlight());
        this.addAction("fold", (kind) => this.handler.fold.fold(kind));
        this.addAction("startCompletion", (option) => completion_default.startCompletion(option));
        this.addAction("stopCompletion", (kind) => completion_default.stop(kind));
        this.addAction("sourceStat", () => sources_default.sourceStats());
        this.addAction("refreshSource", (name2) => sources_default.refresh(name2));
        this.addAction("toggleSource", (name2) => sources_default.toggleSource(name2));
        this.addAction("fillDiagnostics", (bufnr) => manager_default.setLocationlist(bufnr));
        this.addAction("diagnosticRefresh", (bufnr) => manager_default.refresh(bufnr));
        this.addAction("diagnosticInfo", (target) => manager_default.echoCurrentMessage(target));
        this.addAction("diagnosticToggle", (enable) => manager_default.toggleDiagnostic(enable));
        this.addAction("diagnosticToggleBuffer", (bufnr, enable) => manager_default.toggleDiagnosticBuffer(bufnr, enable));
        this.addAction("diagnosticNext", (severity) => manager_default.jumpNext(severity));
        this.addAction("diagnosticPrevious", (severity) => manager_default.jumpPrevious(severity));
        this.addAction("diagnosticPreview", () => manager_default.preview());
        this.addAction("diagnosticList", () => manager_default.getDiagnosticList());
        this.addAction("diagnosticRelatedInformation", () => manager_default.relatedInformation());
        this.addAction("findLocations", (id2, method, params, openCommand) => this.handler.locations.findLocations(id2, method, params, openCommand));
        this.addAction("getTagList", () => this.handler.locations.getTagList());
        this.addAction("definitions", () => this.handler.locations.definitions());
        this.addAction("declarations", () => this.handler.locations.declarations());
        this.addAction("implementations", () => this.handler.locations.implementations());
        this.addAction("typeDefinitions", () => this.handler.locations.typeDefinitions());
        this.addAction("references", (excludeDeclaration) => this.handler.locations.references(excludeDeclaration));
        this.addAction("jumpUsed", (openCommand) => this.handler.locations.gotoReferences(openCommand, false));
        this.addAction("jumpDefinition", (openCommand) => this.handler.locations.gotoDefinition(openCommand));
        this.addAction("jumpReferences", (openCommand) => this.handler.locations.gotoReferences(openCommand));
        this.addAction("jumpTypeDefinition", (openCommand) => this.handler.locations.gotoTypeDefinition(openCommand));
        this.addAction("jumpDeclaration", (openCommand) => this.handler.locations.gotoDeclaration(openCommand));
        this.addAction("jumpImplementation", (openCommand) => this.handler.locations.gotoImplementation(openCommand));
        this.addAction("doHover", (hoverTarget) => this.handler.hover.onHover(hoverTarget));
        this.addAction("definitionHover", (hoverTarget) => this.handler.hover.definitionHover(hoverTarget));
        this.addAction("getHover", (loc) => this.handler.hover.getHover(loc));
        this.addAction("showSignatureHelp", () => this.handler.signature.triggerSignatureHelp());
        this.addAction("documentSymbols", (bufnr) => this.handler.symbols.getDocumentSymbols(bufnr));
        this.addAction("symbolRanges", () => this.handler.documentHighlighter.getSymbolsRanges());
        this.addAction("selectionRanges", () => this.handler.selectionRange.getSelectionRanges());
        this.addAction("rangeSelect", (visualmode, forward) => this.handler.selectionRange.selectRange(visualmode, forward));
        this.addAction("rename", (newName) => this.handler.rename.rename(newName));
        this.addAction("getWorkspaceSymbols", (input) => this.handler.symbols.getWorkspaceSymbols(input));
        this.addAction("resolveWorkspaceSymbol", (symbolInfo) => this.handler.symbols.resolveWorkspaceSymbol(symbolInfo));
        this.addAction("formatSelected", (mode) => this.handler.format.formatCurrentRange(mode));
        this.addAction("format", () => this.handler.format.formatCurrentBuffer());
        this.addAction("commands", () => commands_default.commandList);
        this.addAction("services", () => services_default.getServiceStats());
        this.addAction("toggleService", (name2) => services_default.toggle(name2));
        this.addAction("codeAction", (mode, only, noExclude) => this.handler.codeActions.doCodeAction(mode, only, noExclude));
        this.addAction("organizeImport", () => this.handler.codeActions.organizeImport());
        this.addAction("fixAll", () => this.handler.codeActions.doCodeAction(null, [CodeActionKind.SourceFixAll]));
        this.addAction("doCodeAction", (codeAction) => this.handler.codeActions.applyCodeAction(codeAction));
        this.addAction("codeActions", (mode, only) => this.handler.codeActions.getCurrentCodeActions(mode, only));
        this.addAction("quickfixes", (mode) => this.handler.codeActions.getCurrentCodeActions(mode, [CodeActionKind.QuickFix]));
        this.addAction("codeLensAction", () => this.handler.codeLens.doAction());
        this.addAction("doQuickfix", () => this.handler.codeActions.doQuickfix());
        this.addAction("search", (...args) => this.handler.refactor.search(args));
        this.addAction("saveRefactor", (bufnr) => this.handler.refactor.save(bufnr));
        this.addAction("refactor", () => this.handler.refactor.doRefactor());
        this.addAction("runCommand", (...args) => this.handler.commands.runCommand(...args));
        this.addAction("repeatCommand", () => this.handler.commands.repeat());
        this.addAction("installExtensions", (...list2) => extension_default.installExtensions(list2));
        this.addAction("updateExtensions", (silent) => extension_default.updateExtensions(silent, extension_default.getUpdateSettings().updateUIInTab));
        this.addAction("extensionStats", () => extension_default.getExtensionStates());
        this.addAction("loadedExtensions", () => extension_default.manager.loadedExtensions);
        this.addAction("watchExtension", (id2) => extension_default.manager.watchExtension(id2));
        this.addAction("activeExtension", (name2) => extension_default.manager.activate(name2));
        this.addAction("deactivateExtension", (name2) => extension_default.manager.deactivate(name2));
        this.addAction("reloadExtension", (name2) => extension_default.manager.reloadExtension(name2));
        this.addAction("toggleExtension", (name2) => extension_default.manager.toggleExtension(name2));
        this.addAction("uninstallExtension", (...args) => extension_default.manager.uninstallExtensions(args));
        this.addAction("getCurrentFunctionSymbol", () => this.handler.symbols.getCurrentFunctionSymbol());
        this.addAction("showOutline", (keep) => this.handler.symbols.showOutline(keep));
        this.addAction("hideOutline", () => this.handler.symbols.hideOutline());
        this.addAction("getWordEdit", () => this.handler.rename.getWordEdit());
        this.addAction("addCommand", (cmd) => this.handler.commands.addVimCommand(cmd));
        this.addAction("addRanges", (ranges) => this.cursors.addRanges(ranges));
        this.addAction("currentWorkspacePath", () => workspace_default.rootPath);
        this.addAction("selectCurrentPlaceholder", (triggerAutocmd) => manager_default3.selectCurrentPlaceholder(!!triggerAutocmd));
        this.addAction("codeActionRange", (start, end, only) => this.handler.codeActions.codeActionRange(start, end, only));
        this.addAction("incomingCalls", (item) => this.handler.callHierarchy.getIncoming(item));
        this.addAction("outgoingCalls", (item) => this.handler.callHierarchy.getOutgoing(item));
        this.addAction("showIncomingCalls", () => this.handler.callHierarchy.showCallHierarchyTree("incoming"));
        this.addAction("showOutgoingCalls", () => this.handler.callHierarchy.showCallHierarchyTree("outgoing"));
        this.addAction("showSuperTypes", () => this.handler.typeHierarchy.showTypeHierarchyTree("supertypes"));
        this.addAction("showSubTypes", () => this.handler.typeHierarchy.showTypeHierarchyTree("subtypes"));
        this.addAction("inspectSemanticToken", () => this.handler.semanticHighlighter.inspectSemanticToken());
        this.addAction("semanticHighlight", () => this.handler.semanticHighlighter.highlightCurrent());
        this.addAction("showSemanticHighlightInfo", () => this.handler.semanticHighlighter.showHighlightInfo());
      }
      get workspace() {
        return workspace_default;
      }
      get completion() {
        return completion_default;
      }
      addAction(key, fn, alias) {
        if (this.actions.has(key)) {
          throw new Error(`Action ${key} already exists`);
        }
        this.actions.set(key, fn);
        if (alias) this.actions.set(alias, fn);
      }
      async init(rtp) {
        if (this.initialized) return;
        this.initialized = true;
        let { nvim } = this;
        await extension_default.init(rtp);
        await workspace_default.init(window_default);
        nvim.setVar("coc_workspace_initialized", true, true);
        manager_default3.init();
        services_default.init();
        sources_default.init();
        completion_default.init();
        manager_default.init();
        this.handler = new Handler(nvim);
        this.disposables.push(this.handler);
        manager_default2.registerLists();
        await extension_default.activateExtensions();
        workspace_default.configurations.flushConfigurations();
        nvim.pauseNotification();
        nvim.setVar("coc_service_initialized", 1, true);
        nvim.call("coc#util#do_autocmd", ["CocNvimInit"], true);
        nvim.resumeNotification(false, true);
        logger58.info(`coc.nvim initialized with node: ${process.version} after`, Date.now() - getConditionValue(global.__starttime, Date.now()));
        this.ready = true;
        await events_default.fire("ready", []);
      }
      get isReady() {
        return this.ready;
      }
      hasAction(method) {
        return this.actions.has(method);
      }
      async cocAction(method, ...args) {
        let fn = this.actions.get(method);
        if (!fn) throw new Error(`Action "${method}" does not exist`);
        return await Promise.resolve(fn.apply(null, args));
      }
      getHandler() {
        return this.handler;
      }
      dispose() {
        disposeAll(this.disposables);
        extension_default.dispose();
        manager_default2.dispose();
        workspace_default.dispose();
        window_default.dispose();
        sources_default.dispose();
        services_default.dispose();
        manager_default3.dispose();
        commands_default.dispose();
        completion_default.dispose();
        manager_default.dispose();
      }
    };
  }
});

// src/attach.ts
var attach_exports = {};
__export(attach_exports, {
  default: () => attach_default
});
var import_neovim, logger59, ACTIONS_NO_WAIT, semVer, pendingNotifications, NO_ERROR_REQUEST, attach_default;
var init_attach = __esm({
  "src/attach.ts"() {
    "use strict";
    import_neovim = __toESM(require_lib2());
    init_events();
    init_logger();
    init_plugin();
    init_constants();
    init_node();
    init_string();
    init_timing();
    logger59 = createLogger("attach");
    ACTIONS_NO_WAIT = ["installExtensions", "updateExtensions"];
    semVer = semver.parse(VERSION);
    pendingNotifications = [];
    NO_ERROR_REQUEST = ["doAutocmd", "CocAutocmd"];
    attach_default = (opts, requestApi = false) => {
      const nvim = (0, import_neovim.attach)(opts, createLogger("node-client"), requestApi);
      nvim.setVar("coc_process_pid", process.pid, true);
      nvim.setClientInfo("coc", { major: semVer.major, minor: semVer.minor, patch: semVer.patch }, "remote", {}, {});
      const plugin = new Plugin(nvim);
      let disposable = events_default.on("ready", () => {
        disposable.dispose();
        for (let [method, args] of pendingNotifications) {
          plugin.cocAction(method, ...args).catch((e) => {
            console.error(`Error on notification "${method}": ${e}`);
            logger59.error(`Error on notification ${method}`, e);
          });
        }
        pendingNotifications = [];
      });
      nvim.on("notification", async (method, args) => {
        switch (method) {
          case "VimEnter": {
            await plugin.init(args[0]);
            break;
          }
          case "Log": {
            logger59.debug("Vim log", ...args);
            break;
          }
          case "TaskExit":
          case "TaskStderr":
          case "TaskStdout":
          case "GlobalChange":
          case "PromptInsert":
          case "InputChar":
          case "MenuInput":
          case "OptionSet":
          case "PromptKeyPress":
          case "FloatBtnClick":
          case "InputListSelect":
          case "PumNavigate":
            logger59.trace("Event: ", method, ...args);
            await events_default.fire(method, args);
            break;
          case "CocAutocmd":
            logger59.trace("Notification autocmd:", ...args);
            await events_default.fire(args[0], args.slice(1));
            break;
          case "redraw":
            break;
          default: {
            try {
              logger59.info("receive notification:", method, args);
              if (!plugin.isReady) {
                pendingNotifications.push([method, args]);
                return;
              }
              await plugin.cocAction(method, ...args);
            } catch (e) {
              console.error(`Error on notification "${method}": ${toErrorText(e)}`);
              logger59.error(`Error on notification ${method}`, e);
            }
          }
        }
      });
      let timing = createTiming("Request", 3e3);
      nvim.on("request", async (method, args, resp) => {
        timing.start(method);
        try {
          events_default.requesting = true;
          if (method == "CocAutocmd") {
            logger59.trace("Request autocmd:", ...args);
            await events_default.fire(args[0], args.slice(1));
            resp.send(void 0);
          } else {
            if (!plugin.isReady && !ACTIONS_NO_WAIT.includes(method)) {
              logger59.warn(`Plugin not ready on request "${method}"`, args);
              resp.send("Plugin not ready", true);
            } else {
              logger59.info("Request action:", method, args);
              let res = await plugin.cocAction(method, ...args);
              resp.send(res);
            }
          }
          events_default.requesting = false;
        } catch (e) {
          events_default.requesting = false;
          if (NO_ERROR_REQUEST.includes(method)) {
            nvim.echoError(new Error(`Request "${method}" failed`));
            resp.send("");
          } else {
            resp.send(toErrorText(e), true);
          }
          logger59.error(`Request error:`, method, args, e);
        }
        timing.stop();
      });
      return plugin;
    };
  }
});

// entry-ns:index.js
if (global.__isMain) {
  Object.defineProperty(console, "log", {
    value() {
      if (logger60) logger60.info(...arguments);
    }
  });
  const { createLogger: createLogger2 } = (init_logger(), __toCommonJS(logger_exports));
  const logger60 = createLogger2("server");
  process.on("uncaughtException", function(err) {
    let msg = "Uncaught exception: " + err.message;
    console.error(msg);
    logger60.error("uncaughtException", err.stack);
  });
  process.on("unhandledRejection", function(reason, p) {
    if (reason instanceof Error) {
      if (typeof reason.code === "number") {
        let msg = "Unhandled response error " + reason.code + " from language server: " + reason.message;
        if (reason.data != null) {
          console.error(msg, reason.data);
        } else {
          console.error(msg);
        }
      } else {
        console.error("UnhandledRejection: " + reason.message + "\n" + reason.stack);
      }
    } else {
      console.error("UnhandledRejection: " + reason);
    }
    logger60.error("unhandledRejection ", p, reason);
  });
  const attach2 = (init_attach(), __toCommonJS(attach_exports)).default;
  attach2({ reader: process.stdin, writer: process.stdout });
} else {
  const exports2 = require_src3();
  const logger60 = (init_logger(), __toCommonJS(logger_exports)).logger;
  const attach2 = (init_attach(), __toCommonJS(attach_exports)).default;
  module.exports = { attach: attach2, exports: exports2, logger: logger60, loadExtension: (filepath, active) => {
    return exports2.extensions.manager.load(filepath, active);
  } };
}
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

bytes/index.js:
  (*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

content-disposition/index.js:
  (*!
   * content-disposition
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
